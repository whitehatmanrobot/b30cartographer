R)0xc, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0x6, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x16, 
	(UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x6, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0x3, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x20, (UCHAR)0x12, (UCHAR)0xd, 
	(UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x7, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x3, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x7, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0xd, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0x7, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x17, 
	(UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x7, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0x3, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x21, (UCHAR)0x8, (UCHAR)0x5f, 
	(UCHAR)0x43, (UCHAR)0x52, (UCHAR)0x53, (UCHAR)0x11, (UCHAR)0x42, (UCHAR)0x7, (UCHAR)0xa, (UCHAR)0x6e, 
	(UCHAR)0x88, (UCHAR)0xd, (UCHAR)0, (UCHAR)0x2, (UCHAR)0xf, (UCHAR)0, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0xff, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0x1, 
	(UCHAR)0x47, (UCHAR)0x1, (UCHAR)0xf8, (UCHAR)0xc, (UCHAR)0xf8, (UCHAR)0xc, (UCHAR)0x1, (UCHAR)0x8, 
	(UCHAR)0x88, (UCHAR)0xd, (UCHAR)0, (UCHAR)0x1, (UCHAR)0xc, (UCHAR)0x3, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0xf7, (UCHAR)0xc, (UCHAR)0, (UCHAR)0, (UCHAR)0xf8, (UCHAR)0xc, 
	(UCHAR)0x88, (UCHAR)0xd, (UCHAR)0, (UCHAR)0x1, (UCHAR)0xc, (UCHAR)0x3, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0xd, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0xf3, 
	(UCHAR)0x87, (UCHAR)0x17, (UCHAR)0, (UCHAR)0, (UCHAR)0xc, (UCHAR)0x2, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0xf, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0x6, (UCHAR)0, (UCHAR)0x87, (UCHAR)0x17, (UCHAR)0, (UCHAR)0, (UCHAR)0xc, (UCHAR)0x1, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0xf0, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0xfd, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0xe, (UCHAR)0x79, (UCHAR)0, (UCHAR)0x5b, (UCHAR)0x82, 
	(UCHAR)0x40, (UCHAR)0xa, (UCHAR)0x49, (UCHAR)0x53, (UCHAR)0x41, (UCHAR)0x5f, (UCHAR)0x8, (UCHAR)0x5f, 
	(UCHAR)0x41, (UCHAR)0x44, (UCHAR)0x52, (UCHAR)0xc, (UCHAR)0, (UCHAR)0, (UCHAR)0x4, (UCHAR)0, 
	(UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x37, (UCHAR)0x50, (UCHAR)0x53, (UCHAR)0x32, (UCHAR)0x4b, (UCHAR)0x8, 
	(UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, (UCHAR)0xd0, (UCHAR)0x3, 
	(UCHAR)0x3, (UCHAR)0x14, (UCHAR)0x9, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x54, (UCHAR)0x41, (UCHAR)0, 
	(UCHAR)0xa4, (UCHAR)0xa, (UCHAR)0xf, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x43, (UCHAR)0x52, (UCHAR)0x53, 
	(UCHAR)0x11, (UCHAR)0x18, (UCHAR)0xa, (UCHAR)0x15, (UCHAR)0x47, (UCHAR)0x1, (UCHAR)0x60, (UCHAR)0, 
	(UCHAR)0x60, (UCHAR)0, (UCHAR)0x1, (UCHAR)0x1, (UCHAR)0x47, (UCHAR)0x1, (UCHAR)0x64, (UCHAR)0, 
	(UCHAR)0x64, (UCHAR)0, (UCHAR)0x1, (UCHAR)0x1, (UCHAR)0x22, (UCHAR)0x2, (UCHAR)0, (UCHAR)0x79, 
	(UCHAR)0, (UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x27, (UCHAR)0x50, (UCHAR)0x53, (UCHAR)0x32, (UCHAR)0x4d, 
	(UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, (UCHAR)0xd0, 
	(UCHAR)0xf, (UCHAR)0x13, (UCHAR)0x14, (UCHAR)0x9, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x54, (UCHAR)0x41, 
	(UCHAR)0, (UCHAR)0xa4, (UCHAR)0xa, (UCHAR)0xf, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x43, (UCHAR)0x52, 
	(UCHAR)0x53, (UCHAR)0x11, (UCHAR)0x8, (UCHAR)0xa, (UCHAR)0x5, (UCHAR)0x22, (UCHAR)0, (UCHAR)0x10, 
	(UCHAR)0x79, (UCHAR)0, (UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x2c, (UCHAR)0x55, (UCHAR)0x41, (UCHAR)0x52, 
	(UCHAR)0x31, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, 
	(UCHAR)0xd0, (UCHAR)0x5, (UCHAR)0x1, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x55, (UCHAR)0x49, (UCHAR)0x44, 
	(UCHAR)0xa, (UCHAR)0x1, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x43, (UCHAR)0x52, (UCHAR)0x53, (UCHAR)0x11, 
	(UCHAR)0x10, (UCHAR)0xa, (UCHAR)0xd, (UCHAR)0x47, (UCHAR)0x1, (UCHAR)0xf8, (UCHAR)0x3, (UCHAR)0xf8, 
	(UCHAR)0x3, (UCHAR)0x1, (UCHAR)0x8, (UCHAR)0x22, (UCHAR)0x10, (UCHAR)0, (UCHAR)0x79, (UCHAR)0, 
	(UCHAR)0x10, (UCHAR)0xd, (UCHAR)0x5c, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x49, (UCHAR)0x5f, (UCHAR)0x14, 
	(UCHAR)0x6, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x53, (UCHAR)0x54, (UCHAR)0x1, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\fpswa.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    fpswa.h
    
Abstract:

    EFI driver wrapper for FPSWA

Revision History

--*/

// #include "efi.h"
// #include "efilib.h"

//
// First define PAL_RETURN
//
// typedef int PAL_RETURN;

//
// Global ID for fpswa driver & protocol
//



#define EFI_INTEL_FPSWA     \
    { 0xc41b6531, 0x97b9, 0x11d3, 0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define EFI_INTEL_FPSWA_REVISION    0x00010000

//
//
//

typedef 
PAL_RETURN
(*EFI_FPSWA) (
    IN unsigned int     TrapType,
    IN OUT BUNDLE       *pBundle,
    IN OUT UINT64       *pipsr,
    IN OUT UINT64       *pfsr,
    IN OUT UINT64       *pisr,
    IN OUT UINT64       *ppreds,
    IN OUT UINT64       *pifs,
    IN OUT FP_STATE     *fp_state
    );


typedef struct _FPSWA_INTERFACE {
    UINT32      Revision;
    UINT32      Reserved;
    EFI_FPSWA   Fpswa;    
} FPSWA_INTERFACE;

//
// Prototypes
//

// PAL_RETURN
// fp_emulate (
//   IN unsigned int             TrapType,
//   IN OUT BUNDLE               *pBundle,
//   IN OUT UINT64               *pipsr,
//   IN OUT UINT64               *pfsr,
//   IN OUT UINT64               *pisr,
//   IN OUT UINT64               *ppreds,
//   IN OUT UINT64               *pifs,
//   IN OUT FP_STATE             *fp_state
//   );

//
// Globals
//

// extern EFI_GUID FpswaId;
// extern FPSWA_INTERFACE FpswaInterface;
// extern EFI_EVENT       FpswaEvent;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=hal

TARGETPATH=obj

!IF $(IA64)

TARGETTYPE=HAL

PASS1_PUBLISH={$(O)\hal.lib=$(DDK_LIB_PATH)\hal.lib}

INCLUDES=$(PROJECT_ROOT)\ntos\inc;               \
         $(PROJECT_ROOT)\ntos\ke;                \
         $(PROJECT_ROOT)\ntos\ke\ia64;           \
         ..\..;                                  \
         ..;                                     \
         $(PROJECT_ROOT)\ntos\io;                \
         ..\ia64;                                \
         ..\..\inc;                              \
         $(PROJECT_ROOT)\hals\x86new;            \
         $(HALKIT_INC_PATH);                     \
         $(HALKIT_INC_PATH)\ia64

LINKLIBS=..\..\x86new\$(O)\x86new.lib $(SDK_LIB_PATH)\libc.lib $(PROJECT_ROOT)\boot\kdcom\dll\$(O)\kdcom.lib
LINKER_FLAGS =$(LINKER_FLAGS) -map

!ELSE

TARGETTYPE=DRIVER

!ENDIF

C_DEFINES=-DAPIC_MACHINE -DACPI64 $(C_DEFINES) -DNO_LEGACY_DRIVERS

SOURCES=

IA64_SOURCES=..\hal.rc            \
             ..\acpidtct.c   \
             ..\ia64\haldebug.c   \
             ..\ia64\i64cache.c   \
             ..\ia64\ixhalt.c     \
             ..\ia64\ixhwsup.c    \
             ..\ia64\ixinfo.c     \
             ..\ia64\ixisasup.c   \
             ..\ia64\ixmca.c      \
             ..\ia64\ixphwsup.c   \
             ..\ia64\ixpnpdrv.c   \
             ..\ia64\ixreboot.c   \
             ..\ia64\ixslpsup.c   \
             ..\ia64\ixthrotl.c   \
             ..\ia64\ixusage.c    \
             ..\ia64\ixisabus.c   \
             ..\ia64\i64pcibus.c  \
             ..\ia64\i64ioacc.c   \
             ..\ia64\i64fwasm.s   \
             ..\ia64\i64itm.s     \
             ..\ia64\i64dma.c     \
             ..\ia64\i64krnl.c    \
             ..\ia64\i64clock.c   \
             ..\ia64\i64lock.c    \
             ..\ia64\i64bios.c    \
             ..\ia64\i64efi.c     \
             ..\ia64\i64efis.s    \
             ..\ia64\i64fw.c      \
             ..\ia64\i64perfc.c   \
             ..\ia64\i64prfle.c   \
             ..\ia64\i64prfls.s   \
             ..\ia64\i64sxint.c   \
             ..\ia64\i64sapic.c   \
             ..\ia64\i64sysbus.c  \
             ..\ia64\i64dat.c     \
             ..\ia64\i64bus.c     \
             ..\ia64\merced.c     \
             ..\ia64\mckinley.c   \
             ..\ia64\miscs.s      \
             ..\ia64\gbacpi.c     \
             ..\ia64\osmca.c      \
             ..\ia64\osinit.c     \
             ..\ia64\osmchk.s     \
             ..\ia64\osinitchk.s  \
             ..\ia64\pmsapic.c    \
             ..\ia64\pmbus.c      \
             ..\ia64\pmpcisup.c   \
             ..\ia64\pmsleep.c    \
             ..\ia64\pmisabus.c   \
             ..\ia64\pmdata.c     \
             ..\ia64\xxacpi.c     \
             ..\ia64\xxbiosc.c    \
             ..\ia64\xxhal.c      \
             ..\ia64\xxdisp.c     \
             ..\ia64\xxmemory.c   \
             ..\ia64\xxstubs.c    \
             ..\ia64\xxtime.c     \
             ..\ia64\sratnuma.c

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\check.h ===
#ifndef CHECK_H_INCLUDED
#define CHECK_H_INCLUDED

//###########################################################################
//**
//**  Copyright  (C) 1996-99 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header: /dev/SAL/INCLUDE/check.h 3     4/21/00 12:52p Mganesan $
// $Log: /dev/SAL/INCLUDE/check.h $
//
// 3     4/21/00 12:52p Mganesan
// Sync Up SAL 5.8
//
//   Rev 1.8   18 Jun 1999 16:29:00   smariset
//
//
//   Rev 1.7   08 Jun 1999 11:29:04   smariset
//Added Fatal Error Define
//
//   Rev 1.6   14 May 1999 09:01:26   smariset
//removal of tabs
//
//   Rev 1.5   07 May 1999 11:27:16   smariset
//Copyright update and Platform Record Hdr. Update
//
//   Rev 1.4   06 May 1999 16:06:42   smariset
//PSI Record Valid Bits Change (No bnk Regs)
//
//   Rev 1.3   05 May 1999 14:13:12   smariset
//Pre Fresh Build 
//
//   Rev 1.2   24 Mar 1999 09:40:06   smariset
// 
//
//   Rev 1.1   09 Mar 1999 13:12:52   smariset
//updated
//
//   Rev 1.0   09 Mar 1999 10:02:28   smariset
//First time check
// 
//*****************************************************************************//

// #define _INTEL_CHECK_H  1

#if defined(_INTEL_CHECK_H)

#define OEM_RECID_CMOS_RAM_ADDR 64              // OEM should define this
#define INIT_IPI_VECTOR         0x500
// SAL_MC_SET_PARAMS
#define RZ_VECTOR               0xf3
#define WKP_VECTOR              0x12            // Rendz. wakeup interrupt vector (IA-32 MCHK Exception Vector)
#define CMC_VECTOR              0xf2            //
#define TIMEOUT                 1000

#endif // _INTEL_CHECK_H

#define IntrVecType             0x01
#define MemSemType              0x02
#define RendzType               0x01
#define WakeUpType              0x02
#define CpevType                0x03

// SAL_SET_VECTORS
#define MchkEvent               0x00
#define InitEvent               0x01
#define BootRzEvent             0x02

#if defined(_INTEL_CHECK_H)

#define ProcCmcEvent            0x02
#define PlatCmcEvent            0x03
#define OsMcaSize               0x20
#define OsInitSize              0x20

// Misc. Flags
#define OS_FLAG                 0x03
#define OEM_FLAG                0x04

// Record Type
#define PROC_RECORD             0x00
#define PLAT_RECORD             0x01
#define NUM_PROC                0x04            // number of processors
#define PSI_REC_VERSION         0x01            // 0.01

// Oem SubTypes
#define MEM_Record              0x00
#define BUS_Record              0x02
#define COMP_Record             0x04
#define SEL_Record              0x08


// Record valid flags
#define MEM_Record_VALID        0x00
#define BUS_Record_VALID        0x02
#define COMP_Record_VALID       0x04
#define SEL_Record_VALID        0x08

#define RdNvmRecord             0x00
#define WrNvmRecord             0x01
#define ClrNvmRecord            0x02
#define ChkIfMoreNvmRecord      0x03

#else // !_INTEL_CHECK_H

// SAL 0800: Reserved           0x03-0x40

// SAL STATE_INFO
//
// Thierry 08/2000 - WARNING:
// These definitions match the ntos\inc\hal.h definitions for KERNEL_MCE_DELIVERY.Reserved.EVENTYPE.
//
#define MCA_EVENT               0x00   // MCA  Event Information
#define INIT_EVENT              0x01   // INIT Event Information 
#define CMC_EVENT               0x02   // Processor CMC Event Information
#define CPE_EVENT               0x03   // Corrected Platform Event Information
// SAL 0800: Reserved           other values...

#endif // !_INTEL_CHECK_H

// // constant defines
// Processor State Parameter error conditions from PAL in GR20
// Processor State Parameters from PAL during machine check bit position
#define PSPrz        2                              // Rendez Request Success
#define PSPra        3                              // Rendez Attempted
#define PSPme        4
#define PSPmn        5
#define PSPsy        6                              // storage inetgrity
#define PSPco        7                              // continuable error
#define PSPci        8                              // contained error, recovery possible
#define PSPus        9                              // uncontained memory failure
#define PSPhd        10                             // damaged hardware
#define PSPtl        11
#define PSPmi        12
#define PSPpi        13
#define PSPpm        14
#define PSPdy        15
#define PSPin        16
#define PSPrs        17
#define PSPcm        18                             // machine check corrected
#define PSPex        19                             // machine check expected
#define PSPcr        20
#define PSPpc        21
#define PSPdr        22
#define PSPtr        23
#define PSPrr        24
#define PSPar        25
#define PSPbr        26
#define PSPpr        27
#define PSPfp        28
#define PSPb1        29
#define PSPb0        30
#define PSPgr        31

#define PSPcc        59                             // cache check, SAL's domain 
#define PSPtc        60                             // tlb check error, SAL's domain
#define PSPbc        61                             // bus check error, SAL's domain
#define PSPrc        62                             // register file check error, SAL's domain
#define PSPuc        63                             // unknown error, SAL's domain

#define BusChktv     21                             // Bus check.tv bit or bus error info
#define CacheChktv     23

#if defined(_INTEL_CHECK_H)

// SAL PSI Validation flag bit mask
#define vPSIpe       0x01<<0                        // start bit pos. for processor error map
#define vPSIps       0x01<<1
#define vPSIid       0x01<<2                        // processor LID register value
#define vPSIStatic   0x01<<3                        // processor static info.
#define vPSIcc       0x01<<4                        // start bit pos. for cache error
#define vPSItc       0x01<<8                        // start bit pos. for tlb errors
#define vPSIbc       0x01<<12                       // bus check valid bit
#define vPSIrf       0x01<<16                       // register file check valid bit
#define vPSIms       0x01<<20                       // ms check valid bit

// Valid bit flags for CR and AR registers for this generation of EM Processor
#define vPSIMinState      0x01<<0
#define vPSIBRs           0x01<<1
#define vPSICRs           0x01<<2
#define vPSIARs           0x01<<3
#define vPSIRRs           0x01<<4
#define vPSIFRs           0x01<<5
#define vPSIRegs          vPSIBRs+vPSICRs+vPSIARs+vPSIRRs+vPSIMinState

///*** All Processor PAL call specific info.
// Processor Error Info Type Index for PAL_MC_ERROR_INFO call
#define PROC_ERROR_MAP      0                       // index for Proc. error map
#define PROC_STATE_PARAM    1                       // index for Proc. state parameter
#define PROC_STRUCT         2                       // index for structure specific error info.

#define PEIsse      0                               // index for Proc. structure specific level index
#define PEIta       1                               // index for target identifer
#define PEIrq       2                               // index for requestor
#define PEIrs       3                               // index for responder
#define PEIip       4                               // index for precise IP

// processor error map starting bit positions for each field (level index)
#define PEMcid            0                     // core ID
#define PEMtid            4                     // thread ID
#define PEMeic            8                     // inst. cache error index
#define PEMedc            12                    // data cache error index
#define PEMeit            16                    // inst. tlb error index
#define PEMedt            20                    // data tlb error index
#define PEMebh            24                    // bus error index
#define PEMerf            28                    // register file error index
#define PEMems            32                    // micro-arch error index

// processor structure specific error bit mappings
#define PEtv                0x01<<60            // valid target identifier
#define PErq                0x01<<61            // valid request identifier
#define PErp                0x01<<62            // valid responder identifier
#define PEpi                0x01<<63            // valid precise IP


// Error Severity: using bits (cm) & (us) only
#define RECOVERABLE     0x00
#define FATAL           0x01
#define CONTINUABLE     0x02
#define BCib            0x05
#define BCeb            0x06

#else  // !_INTEL_CHECK_H

//
// Error Severity: using vits (PSPcm) & (PSPus) only
// The SAL spec'ed values are defined in ntos\inc\hal.h
//
// To remind you:
//  #define ErrorRecoverable  ((USHORT)0)
//  #define ErrorFatal        ((USHORT)1)
//  #define ErrorCorrected    ((USHORT)2)
//
// The following values define some of the reserved ErrorOthers.

#define ErrorBCeb   ((USHORT)6)

#endif // !_INTEL_CHECK_H

#if defined(_INTEL_CHECK_H)

// System Errors bits masks to be handled by SAL, mask bits in d64-d32
#define parError     0x000100000000                 // Memory parity error
#define eccError     0x000200000000                 // Memory ECC error
#define busError     PSPbc                          // System Bus Check/Error
#define iocError     0x000800000000                 // System IO Check Errors
#define temError     0x002000000000                 // System Temperature Error
#define vccError     0x004000000000                 // System Voltage Error
#define intError     0x010000000000                 // Intrusion Error for servers
#define cacError     PSPcc                          // Cache Error
#define tlbError     PSPtc                          // TLB error
#define unkError     PSPuc                          // Unknown/Catastrophic error

// error bits masks
#define PALErrMask     0x0ff                        // bit mask of errors correctable by PAL
#define SALErrMask     busError+cacError+tlbError+unkError // SAL error bit mask
#define OSErrMask      0x0ff                         // OS expected error conditions
#define MCAErrMask     0x0ff                        // Given MCA Error Mask bit map

// New processor error Record structures ACO504
typedef struct tagModInfo
{
    U64		eValid;								// Valid bits for module entries
	U64     eInfo;								// error info cache/tlb/bus
    U64     ReqId;								// requester ID
    U64     ResId;								// responder ID
    U64     TarId;								// target ID
    U64     IP;									// Precise IP
} ModInfo;

typedef struct tagSAL_GUID
{          
    U32  Data1;
    U16  Data2;
    U16  Data3;
    U8   Data4[8]; 
} SAL_GUID;

typedef struct tagProcessorInfo
{
    U64         ValidBits;
    U64         Pem;							// processor map
	U64			Psp;							// processor state parameter
	U64			Pid;							// processor LID register value
    ModInfo		cInfo[8];						// cache check max of 8
    ModInfo     tInfo[8];						// tlb check max of 8
    ModInfo     bInfo[4];						// bus check max or 4
	U64			rInfo[4];						// register file check max of 4
	U64			mInfo[4];						// micro-architectural information max of 
    U64         Psi[584+8];						// 584 bytes
} ProcessorInfo;

typedef struct tagMinProcessorInfo
{
    U64         ValidBits;
    U64         Psp;							// processor state parameter
	U64			Pem;							// processor map
	U64			Pid;							// processor LID register value
} MinProcessorInfo;


// end ACO504 changes.

// platform error Record structures
typedef struct tagCfgSpace
{
	// data - error register dump
	U64     CfgRegAddr;							// register offset/addr
	U64     CfgRegVal; 							// register data/value
} CfgSpace;

typedef struct tagMemSpace
{
	// data - error register dump
	U64     MemRegAddr;							// register offset/addr
	U64     MemRegVal;							// register data/value
} MemSpace;

typedef union tagMemCfgSpace
{
	MemSpace		mSpace;
	CfgSpace		cSpace;
} MemCfgSpace;

typedef struct tagSysCompErr                    // per component
{
    U64     vFlag;                              // bit63=PCI device Flag, LSB:valid bits for each field in the Record

    // header for component Record
    U64     BusNum;                             // bus number on which the component resides
    U64     DevNum;                             // same as device select
    U64     FuncNum;                            // function ID of the device
    U64     DevVenID;                           // PCI device & vendor ID
	U64		SegNum;								// segment number as defined in SAL spec.

	// register dump info.
	U64     MemSpaceNumRegPair;					// number of reg addr/value pairs returned in this Record
	U64     CfgSpaceNumRegPair;					// number of reg addr/value pairs returned in this Record
	MemCfgSpace mcSpace;						// register add/data value pair array

} cErrRecord;

#define BusNum_valid				0x01                         
#define DevNum_valid				0x02                          
#define FuncNum_valid				0x04                           
#define DevVenID_valid				0x08                         
#define SegNum_valid				0x10								
#define MemSpaceNumRegPair_valid	0x20					
#define CfgSpaceNumRegPair_valid	0x40					
#define mcSpace_valid				0x80						

typedef struct tagPlatErrSection
{
    U64         vFlag;							// valid bits for each type of Record
    U64			Addr;							// memory address
    U64			Data;							// memory data
    U64			CmdType;						// command/operation type                            
	U64			BusID;							// bus ID if applicable
	U64			RequesterID;					// Requestor of the transaction if any                   
	U64			ResponderID;    				// Intended target or responder 
	U64			NumOemExt;						// Number of OEM Extension Arrays
	cErrRecord	OemExt;							// Value Array of OEM extensions
} PlatformInfo;

#define Addr_valid				0x01						
#define Data_valid				0x02						
#define CmdType_valid			0x04						
#define BusID_valid				0x08					
#define RequesterID_valid		0x10
#define ResponderID_valid		0x20  				
#define NumOemExt_valid			0x40				
#define OemExt_valid			0x80						

// over all Record structure (processor+platform)
typedef union utagDeviceSpecificSection
{
    ProcessorInfo   procSection;
    PlatformInfo    platSection;
} DeviceSection;

// SAL PSI Record & Section structure
typedef struct tagPsiSectionHeader
{
    SAL_GUID		SectionGuid;
	U16				Revision;
	U16				Reserved;
    U32				SectionLength;
} PsiSectionHeader;

typedef struct tagPsiSection
{
    SAL_GUID		SectionGuid;
	U16				Revision;
	U16				Reserved;
    U32				SectionLength;
    DeviceSection	DevSection;
} PsiSection;

typedef struct tagPsiRecordHeader
{
    U64				RecordID;
	U16				Revision;
	U16				eSeverity;
    U32				RecordLength;
    U64				TimeStamp;
} PsiRecordHeader;

typedef struct tagPsiRecord
{
    U64				RecordID;
	U16				Revision;
	U16				eSeverity;
    U32				RecordLength;
    U64				TimeStamp;
    PsiSection		PsiDevSection;
} PsiRecord;

/*
	LION 460GX: 
			SAC: SAC_FERR, SAC_FERR
			SDC: SDC_FERR, SDC_NERR
			MAC: FERR_MAC
			GXB: FERR_GXB, FERR_PCI, FERR_GART, FERR_F16, FERR_AGP
*/
typedef struct tagPciCfgHdr
{
	U8			RegAddr;
	U8			FuncNum;
	U8			DevNum;
	U8			BusNum;
	U8			SegNum;
	U8			Res[3];
} PciCfgHdr;

#define  PLATFORM_REC_CNT	0x01				// number of consecutive Records in the platform Record linked list
#define  OEM_EXT_REC_CNT	0x06				// number of consecutive OEM extension Array count

// number of registers that will be returned for each device
#define	SAC_REG_CNT				0x02
#define	SDC_REG_CNT				0x02
#define	MAC_REG_CNT				0x01
#define	GXB_REG_CNT				0x04
												
typedef struct tagSacRegs
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[SAC_REG_CNT];
} SacDevInfo;

typedef struct tagSdcRegs
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[SDC_REG_CNT];
} SdcDevInfo;

typedef struct tagMacRegs
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[MAC_REG_CNT];
} MacDevInfo;

typedef struct tagGxbRegs
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[GXB_REG_CNT];
} GxbDevInfo;

typedef struct tagDevInfo
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[4];
} DevInfo;


#define DEV_VEN_ID_ADDR		0x0
#define SAC_BN					0x10

#define  DevNumber0             0x0
#define  DevNumber1				0x1
#define  DevNumber2				0x2
#define  DevNumber3             0x3
#define  DevNumber4				0x4
#define  DevNumber5				0x5
#define  DevNumber6             0x6

// function prototypes
rArg _BuildProcErrSection(PsiRecord*, U64, U64, U64);
rArg _BuildPlatErrSection(PsiSection*, U64, U64, U64);
rArg _BuildChipSetSection(PsiSection*, U64);
rArg _GetErrRecord(PsiRecord*, U64, PsiRecord*,PsiSection*, U64*, U64);
rArg _NvmErrRecordMgr(U64, U64, U64, U64);
rArg GetDeviceRecord(cErrRecord*, DevInfo*);
rArg SAL_PCI_CONFIG_READ_(U64, U64, U64, U64, U64, U64, U64, U64);
rArg SAL_PCI_CONFIG_WRITE_(U64, U64, U64, U64, U64, U64, U64, U64);
rArg OemGetInitSource();
rArg _MakeStaticPALCall(U64, U64, U64, U64, U64);
rArg GetProcNum();

#endif // _INTEL_CHECK_H

#endif // CHECK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\haldebug.c ===
#if DBG

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    haldebug.c

Abstract:

    This module contains debugging code for the HAL.

Author:

    Thierry Fevrier 15-Jan-2000

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"

#include <stdarg.h>
#include <stdio.h>

UCHAR HalpDebugPrintBuffer[512];

ULONG HalpUseDbgPrint = 0;

VOID
HalpDebugPrint(
    ULONG  Level, 
    PCCHAR Message,
    ...
    )
{
    va_list ap;
    va_start(ap, Message);
    _vsnprintf( HalpDebugPrintBuffer, sizeof(HalpDebugPrintBuffer), Message, ap );
    va_end(ap);
    if ( !HalpUseDbgPrint ) {
        HalDisplayString( HalpDebugPrintBuffer );
    }
    else    {
        DbgPrintEx( DPFLTR_HALIA64_ID, Level, HalpDebugPrintBuffer );
    }
    return;
} // HalpDebugPrint()

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\gbacpi.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    GbAcpi.c

Abstract:

    Temporary support for Acpi tables in Gambit simulator environment. This
    file should be removed when Gambit/Vpc provides Acpi tables.

    The Acpi tables are created and a pointer to the RSDT is put into the
    Loader block.

Author:

    Todd Kjos (HP) (v-tkjos) 1-Jun-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

BOOLEAN
HalpFakeAcpiRegisters(
    VOID
    );

#define PMIO 0x8000
#define PM1a_EVT_BLK (PMIO+0x0)
#define PM1a_STS     PM1a_EVT_BLK
#define PM1a_EN      (PM1a_STS+2)

#define PM1a_CNT_BLK (PMIO+0x4)
#define PM1a_CNTa    PM1a_CNT_BLK

#define PM_TMR       (PMIO+0x8)
#define GP0          (PMIO+0xc)
#define GP0_STS_0    GP0
#define GP0_STS_1    (GP0+1)
#define GP0_EN_0     (GP0+2)
#define GP0_EN_1     (GP0+3)

PCHAR HalpFakeAcpiRegisterFadtIds[][2] =
{
    {"INTEL",       "LIONEMU"},
    {"INTEL",       "SR460AC"},
    {"INTEL",       "AL460GX"},
    {NULL, NULL}
};            

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpFakeAcpiRegisters)
#endif

USHORT AcpiRegPM1a_STS  = 0;
USHORT AcpiRegPM1a_EN   = 0;
USHORT AcpiRegPM1_CNTa  = 1;  // SCI_EN
ULONG  AcpiRegPM_TMR    = 0;
UCHAR  AcpiRegGP0_STS_0 = 0;
UCHAR  AcpiRegGP0_STS_1 = 0;
UCHAR  AcpiRegGP0_EN_0  = 0;
UCHAR  AcpiRegGP0_EN_1  = 0;
UCHAR  AcpiRegNeedToImplement = 0;

BOOLEAN GambitAcpiDebug = FALSE;

//#define TKPRINT(X,Y) if (GambitAcpiDebug) HalDebugPrint(( HAL_INFO, "%s of %s (%#x)\n",X,# Y,Y ))
#define TKPRINT(x, y)

BOOLEAN
GbAcpiReadFakePort(
    UINT_PTR Port,
    PVOID Data,
    ULONG Length
   )
{
    if (Port < PMIO || Port > PMIO+0xfff) return(FALSE);

   switch (Port) {
   case PM1a_STS:
      ASSERT(Length == 2);
      *(USHORT UNALIGNED *)Data = AcpiRegPM1a_STS;
      TKPRINT("Read",AcpiRegPM1a_STS);
      return TRUE;
   case PM1a_EN:
      ASSERT(Length == 2);
      *(USHORT UNALIGNED *)Data = AcpiRegPM1a_EN;
      TKPRINT("Read",AcpiRegPM1a_EN);
      return TRUE;
   case PM1a_CNTa:
      ASSERT(Length == 2);
      *(USHORT UNALIGNED *)Data = AcpiRegPM1_CNTa;
      TKPRINT("Read",AcpiRegPM1_CNTa);
      return TRUE;
   case PM_TMR:
      ASSERT(Length == 4);
      *(ULONG UNALIGNED *)Data = AcpiRegPM_TMR;
      TKPRINT("Read",AcpiRegPM_TMR);
      return TRUE;
   case GP0_STS_0:
      ASSERT(Length == 1);
      *(UCHAR UNALIGNED *)Data = AcpiRegGP0_STS_0;
      TKPRINT("Read",AcpiRegGP0_STS_0);
      return TRUE;
   case GP0_STS_1:
      ASSERT(Length == 1);
      *(UCHAR UNALIGNED *)Data = AcpiRegGP0_STS_1;
      TKPRINT("Read",AcpiRegGP0_STS_1);
      return TRUE;
   case GP0_EN_0:
      ASSERT(Length == 1);
      *(UCHAR UNALIGNED *)Data = AcpiRegGP0_EN_0;
      TKPRINT("Read",AcpiRegGP0_EN_0);
      return TRUE;
   case GP0_EN_1:
      ASSERT(Length == 1);
      *(UCHAR UNALIGNED *)Data = AcpiRegGP0_EN_1;
      TKPRINT("Read",AcpiRegGP0_EN_1);
      return TRUE;
        case 0x802b:
               ASSERT(Length == 1);
               *(UCHAR UNALIGNED *)Data = AcpiRegNeedToImplement;
               TKPRINT("Read",AcpiRegNeedToImplement);
               return TRUE;
   default:
      ;
//      HalDebugPrint(( HAL_ERROR, "HAL: AcpiSimulation - Unknown Acpi register: %#Ix\n", Port ));
//      ASSERT(0);
   }
   return(FALSE);
}

BOOLEAN
GbAcpiWriteFakePort(
    UINT_PTR Port,
    PVOID Value,
    ULONG Length
   )
{
   if (Port < PMIO || Port > PMIO+0xfff) return(FALSE);

   switch (Port) {
   case PM1a_STS:
      ASSERT(Length == 2);
      AcpiRegPM1a_STS &= ~(*(USHORT UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegPM1a_STS);
      return TRUE;
   case PM1a_EN:
      ASSERT(Length == 2);
      AcpiRegPM1a_EN = *((USHORT UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegPM1a_EN);
      return TRUE;
   case PM1a_CNTa:
      ASSERT(Length == 2);
      AcpiRegPM1_CNTa = *((USHORT UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegPM1_CNTa);
      return TRUE;
   case PM_TMR:
      ASSERT(Length == 4);
      AcpiRegPM_TMR = *((ULONG UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegPM_TMR);
      return TRUE;
   case GP0_STS_0:
      ASSERT(Length == 1);
      AcpiRegGP0_STS_0 &= ~(*(UCHAR UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegGP0_STS_0);
      return TRUE;
   case GP0_STS_1:
      ASSERT(Length == 1);
      AcpiRegGP0_STS_1 &= ~(*(UCHAR UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegGP0_STS_1);
      return TRUE;
   case GP0_EN_0:
      ASSERT(Length == 1);
      AcpiRegGP0_EN_0 = *((UCHAR UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegGP0_EN_0);
      return TRUE;
   case GP0_EN_1:
      ASSERT(Length == 1);
      AcpiRegGP0_EN_1 = *((UCHAR UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegGP0_EN_1);
      return TRUE;
   default:
      ;
//      HalDebugPrint(( HAL_ERROR, "HAL: AcpiSimulation - Unknown Acpi register: %#Ix\n",Port ));
//      ASSERT(0);
   }
   return(FALSE);
}

USHORT
HalpReadAcpiRegister(
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register
  )
{
    USHORT  value;
    BOOLEAN retVal = FALSE;
    
    switch (AcpiReg) {
    case PM1a_ENABLE:

        retVal = GbAcpiReadFakePort(PM1a_EN, &value, 2);
        break;
        
    case PM1a_STATUS:

        retVal = GbAcpiReadFakePort(PM1a_STS, &value, 2);
        break;
        
    case PM1a_CONTROL:

        retVal = GbAcpiReadFakePort(PM1a_CNTa, &value, 2);
        break;
        
    case GP_STATUS:

        retVal = GbAcpiReadFakePort(GP0_STS_0, &value, 1);
        if (!retVal) break;
        retVal = GbAcpiReadFakePort(GP0_STS_1, ((PUCHAR)&value) + 1, 1);
        break;
        
    case GP_ENABLE:

        retVal = GbAcpiReadFakePort(GP0_EN_0, &value, 1);
        if (!retVal) break;
        retVal = GbAcpiReadFakePort(GP0_EN_1, ((PUCHAR)&value) + 1, 1);
        break;
        
    }
    
    if (retVal) {

        return value;

    } else {
        
        return 0xffff;
    }
}

VOID
HalpWriteAcpiRegister(
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register,
  IN USHORT        Value
  )
{
    BOOLEAN retVal = FALSE;
    
    switch (AcpiReg) {
    case PM1a_ENABLE:

        retVal = GbAcpiWriteFakePort(PM1a_EN, &Value, 2);
        break;
        
    case PM1a_STATUS:

        retVal = GbAcpiWriteFakePort(PM1a_STS, &Value, 2);
        break;
        
    case PM1a_CONTROL:

        retVal = GbAcpiWriteFakePort(PM1a_CNTa, &Value, 2);
        break;
        
    case GP_STATUS:

        retVal = GbAcpiWriteFakePort(GP0_STS_0, &Value, 1);
        if (!retVal) break;
        retVal = GbAcpiWriteFakePort(GP0_STS_1, ((PUCHAR)&Value) + 1, 1);
        break;
        
    case GP_ENABLE:

        switch (Register) {
        case 0:
            retVal = GbAcpiWriteFakePort(GP0_EN_0, &Value, 1);
            break;
        case 1:
            retVal = GbAcpiWriteFakePort(GP0_EN_1, ((PUCHAR)&Value) + 1, 1);
            break;
        }
    }
}

BOOLEAN
HalpFakeAcpiRegisters(
    VOID
    )
{
    ULONG   i = 0;
    
    PAGED_CODE();

    while (HalpFakeAcpiRegisterFadtIds[i][0] != NULL) {

      //DbgPrint("Comparing [%s]-[%s] to [%s]-[%s]\n",
      //         HalpFixedAcpiDescTable.Header.OEMID,
      //         HalpFixedAcpiDescTable.Header.OEMTableID,
      //         HalpFakeAcpiRegisterFadtIds[i][0],
      //         HalpFakeAcpiRegisterFadtIds[i][1]);
        
        if ((!strncmp(HalpFixedAcpiDescTable.Header.OEMID, 
                      HalpFakeAcpiRegisterFadtIds[i][0],
                      6)) &&
            (!strncmp(HalpFixedAcpiDescTable.Header.OEMTableID, 
                      HalpFakeAcpiRegisterFadtIds[i][1],
                      8))) {

            //
            // This machine matches one of the entries
            // in the table that tells us that we should fake
            // our ACPI registers.
            //

            //DbgPrint("Found a match\n");
            //
            // Make sure the oem revision is less than 3.
            // Then we need to fake the acpi registers
            //
            if(HalpFixedAcpiDescTable.Header.OEMRevision < 3)
                return TRUE;
        }

        i++;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\fwglobal.h ===
//###########################################################################
//**
//**  Copyright  (C) 1996-99 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

;//-----------------------------------------------------------------------------
;// Version control information follows.
;//
;// $Header:   I:/DEVPVCS/sal/INCLUDE/FWGLOBAL.H   6.6   07 May 1999 10:52:24   smariset  $
;// $Log:   I:/DEVPVCS/sal/INCLUDE/FWGLOBAL.H  $
;//
;//   Rev 6.6   07 May 1999 10:52:24   smariset
;//Copyright year update
;//
;//   Rev 6.5   05 May 1999 14:13:30   smariset
;//Pre Fresh Build 
;//
;//   Rev 6.4   16 Apr 1999 13:45:34   smariset
;//MinState Size Change, Procs Clean Up
;//
;//   Rev 6.2   04 Mar 1999 13:36:06   smariset
;//Pre 0.6 release symbol globalization
;//
;//   Rev 6.1   10 Feb 1999 15:58:38   smariset
;//Boot Mgr Updates
;//
;//   Rev 6.0   Dec 11 1998 10:23:08   khaw
;//Post FW 0.5 release sync-up
;//
;//   Rev 5.0   27 Aug 1998 11:52:28   khaw
;//FW merged for EAS 2.4 SDK tools
;//
;//   Rev 4.1   20 Aug 1998 16:53:30   smariset
;//EAS 2.4 Changes
;//
;//   Rev 4.0   06 May 1998 22:22:50   khaw
;//Major update for MP SAL, tools and build.
;//SAL A/B common source.  .s extension.
;//
;//   Rev 3.3   17 Feb 1998 08:37:24   khaw
;//SAL buid/code update for SDK0.3
;//
;//   Rev 3.2   06 Jan 1998 12:52:48   smariset
;//One more flag: OStoPalRtn
;//
;//   Rev 3.1   06 Jan 1998 09:16:50   smariset
;//Hazard Checked
;//
;//   Rev 3.0   17 Dec 1997 12:42:54   khaw
;// Merced Firmware Development Kit  Rev 0.2
;//
;//   Rev 2.8   Apr 02 1997 14:18:40   smariset
;//Post release clean up
;//
;//   Rev 2.7   Mar 31 1997 12:28:48   smariset
;//Indent tabs replaced by spaces
;//
;//   Rev 2.0   Feb 04 1997 07:29:54   khaw
;//PAL_A/B, SAL_A/B updates
;//
;//*****************************************************************************//
        #define xs0 s0
        #define xs1 s1          
        #define xs2 s2
        #define xs3 s3          

// constants
        #define  Sz64b            64
        #define  Sz128b           128
        #define  Sz256b           0x00100
        #define  Sz512b           0x00200
        #define  Sz1kb            0x00400
        #define  Sz2kb            0x00800
        #define  Sz4kb            0x01000
        #define  Sz6kb            0x01800
        #define  Sz8kb            0x02000
        #define  Sz16kb           0x04000
        #define  Sz20kb           0x05000
        #define  Sz32kb           0x08000
        #define  SzSALGlobal      Sz16kb        // 16K size
        #define  SzSALData        Sz20kb        // size MCA/INIT/CMC areas
        #define  SzPMIData        Sz4kb
        #define  SzBkpStore       Sz512b
        #define  SzStackFrame     Sz256b+Sz128b
        #define  SALGpOff         0x08
        #define  PMIGpOff         0x0f
        #define  SzProcMinState   0x1000        // Architected MinState+ScratchMinState Size
        #define  aSzProcMinState  0x400         // architected MinState Size
        #define  PSI_hLogSz       8*3           // PSI log header size
        #define  PSI_procLogSz    (8*4+16*2+48*2+64*2+128+2*1024+aSzProcMinState)    // size of processor PSI log size
        #define  PSI_platLogSz    Sz4kb         // size of platform log


// primary and secondary debug port numbers
//      #define  pDbgPort         0x080         // used for release code        
        #define  sDbgPort         0x0a0         // used for non-release code only

// increment contstans
        #define  Inc4             4
        #define  Dec4             (-4)
        #define  Inc8             8
        #define  Dec8             (-8)
        #define  Inc16            16
        #define  Dec16            (-16)
        #define  Inc32            32
        #define  Dec32            (-32)
        #define  Inc48            48
        #define  Dec48            (-48)
        #define  Inc64            64
        #define  Dec64            (-64)

// defines
        #define  PMITimeOutValue 0x0f           // PMI Time Out Value
        #define  DestIDMask      0x0ff000000    // LID info.
        #define  DestEIDMask     0x000ff0000
        #define  DestIDMaskPos   24             // LID.id  position
        #define  DestEIDMaskPos  16             // LID.eid position
        #define  IntStoreAddrMsk 0x0fee00000000 // SAPIC store address message mask
        #define  InitDelvModeMsk 0x0500         // SAPIC INIT del. message mask
        #define  PmiDelvModeMsk  0x0200         // SAPIC PMI del. message mask
        #define  FixedDelvModeMsk 0x0000        // SAPIC Fixed Del Mode mask
        #define  MCAFlagMsk      0x01           // bit1 of SalFlags, indicating that a CPU is in MCA
        #define  OSFlagEMMsk     0x01           // bit2 of SalFlags=1/0
        #define  PDSSize         0x02000        // Processor Data Structure memory size 8Kb
        #define  GDataSize       0x01000        // Global Data Area Memory Size 4Kb
        #define  FlushPMI        0x0            // PMI Flush Bit mask
        #define  MsgPMI          0x01           // PMI due to SAPIC Msg
        #define  PSIvLog         0x01           // PSI Structure Log Valid Bit Position
        #define  IntrPMI         0x02           // vector for Rendez. PMI interrupt
        #define  RendzNotRequired 0x00
        #define  RendezOk        0x01
        #define  RendezThruInitCombo 0x02
        #define  MulProcInMca    0x02
        #define  RendezFailed    (-0x01)

// Processor State Register Bit position value for PSR bits.
        #define  PSRor           0
        #define  PSRbe           1
        #define  PSRup           2
        #define  PSRac           3
        
        #define  PSRic           13
        #define  PSRi            14
        #define  PSRpk           15
        #define  PSRrv           16
        
        #define  PSRdt           17
        #define  PSRdfl          18
        #define  PSRdfh          19
        #define  PSRsp           20
        #define  PSRpp           21
        #define  PSRdi           22
        #define  PSRsi           23
        #define  PSRdb           24
        #define  PSRlp           25
        #define  PSRtb           26
        #define  PSRrt           27
// since PSR.um only starts from bit 32 and up and gets loaded that way
        #define  PSRcpl0         32
        #define  PSRcpl1         33
        #define  PSRis           34
        #define  PSRmc           35
        #define  PSRit           36
        #define  PSRid           37
        #define  PSRda           38
        #define  PSRdd           39
        #define  PSRss           40
        #define  PSRri0          41
        #define  PSRri1          42
        #define  PSRed           43
        #define  PSRbn           44
        
        #define  RSCmode         0x0003

        #define  PSRmcMask       0x0800000000
        #define  PSRicMask       0x02000
        #define  PSRiMask        0x04000

// RSE management registers offset
        #define  rRSCOff         0
        #define  rPFSOff         (rRSCOff+0x08)
        #define  rIFSOff         (rPFSOff+0x08)
        #define  rBSPStOff       (rIFSOff+0x08)
        #define  rRNATOff        (rBSPStOff+0x08)
        #define  rBSPDiffOff     (rRNATOff+0x08)
//********************* start of First 4K Shared Data ***************************
// variable offsets used by SAL Set MC Interrupt call
        #define  IPIVectorOff    0x00                  // fix this later to 0, data area bug

// MP synch. semaphores
        #define  InMCAOff        (IPIVectorOff+0x08)    // byte flags per processor to indicate that it is in MC
        #define  InRendzOff      (InMCAOff+0x08)
        #define  RendzCheckInOff (InRendzOff+0x08)     // indicates that processor checkin status
        #define  RendzResultOff  (RendzCheckInOff+0x08)
        #define  PMICheckInOff   (RendzResultOff+0x08)

// Platform Log valid flag bits
        #define  PSI_vPlatLogOff  (PMICheckInOff+0x08)   // platform non-CMC state log flag  
        #define  PSI_cvPlatLogOff (PSI_vPlatLogOff+0x01)   // platform CMC state log flag
        #define  PSI_ivPlatLogOff (PSI_cvPlatLogOff+0x01)  // platform INIT state log flag


//********************* start of Next 4K block of Shared Data Area ******************
// each platform log is 4kb in size (three logs here for MCA, CMC, INIT each 4x3=12Kbytes total
// PSI MCA generic header field offsets from BOM; applies to PSI MemInfo and IOInfo
// PSI MCA Platform Info. data area
        #define  PSI_PlatInfoOff PSI_platLogSz
        #define  PSI_gLogNext    PSI_platLogSz              // platform area starts at 4K from BOM
        #define  PSI_gLength     (PSI_gLogNext+0x08)
        #define  PSI_gType       (PSI_gLength+0x04)
        #define  PSI_gTimeStamp  (PSI_gType+0x04)

// PSI INIT generic header field offsets from BOM; applies to PSI MemInfo and IOInfo
// PSI INIT Platform Info. data area
        #define  PSI_iPlatInfoOff (PSI_PlatInfoOff+PSI_platLogSz)
        #define  PSI_igLogNext   (PSI_cgLogNext+PSI_platLogSz)
        #define  PSI_igLength    (PSI_igLogNext+0x08)
        #define  PSI_igType      (PSI_igLength+0x04)
        #define  PSI_igTimeStamp (PSI_igType+0x04)

// PSI CMC generic header field offsets from BOM; applies to PSI MemInfo and IOInfo)
// PSI CMC Platform Info. data area
        #define  PSI_cPlatInfoOff (PSI_iPlatInfoOff+PSI_platLogSz)
        #define  PSI_cgLogNext   (PSI_gLogNext+PSI_platLogSz)   
        #define  PSI_cgLength    (PSI_cgLogNext+0x08)
        #define  PSI_cgType      (PSI_cgLength+0x04)
        #define  PSI_cgTimeStamp (PSI_cgType+0x04)


//1******************* start of First Proc. Specific 4K block *****************
// Offsets from start of MinState Area *** Start of Min State Area ***
        #define  Min_ProcStateOff 0                      // 512byte aligned always 

//2******************* start of First Proc. 2nd 4K block *****************
// pointer to TOM is registered here by SAL malloc/init. code
        #define  TOMPtrOff       SzProcMinState          // offset from min state ptr.

// Mail box for software SAPIC PMI type message
        #define  PMIMailBoxOff     (TOMPtrOff+0x08)        // software PMI request mailbox            
        #define  OStoPalRtnFlagOff (PMIMailBoxOff+0x01)    // set by OS_MCA Call processing
        
// processor state log valid word MCA, INIT, CMC log areas
        #define  PSI_vProcLogOff  (PMIMailBoxOff+0x10)     // log valid flag for non-CMC log area
        #define  PSI_cvProcLogOff (PSI_vProcLogOff+0x01)   // log valid flag for CMC log area
        #define  PSI_ivProcLogOff (PSI_cvProcLogOff+0x01)  // log valid flag for INIT log area

// processor stack frame
        #define  StackFrameOff   (PSI_vProcLogOff+0x08)    //PSI_vProcLogOff+0x08

// bspstore
        #define  BL_SP_BASEOff   (StackFrameOff+SzStackFrame)    // stack frame size of 256 bytes
        #define  BL_R12_BASEOff  (BL_SP_BASEOff+Sz1kb+Sz512b) // assuming 1.5Kb size for BspMemory

//3**************** start of First Proc. Specific PSI 4K block ****************
// data structure SAL Processor-0 State Info (PSI) Structure
// push header data structure above the second 4k boundary, or below the first 4k 
        #define  PSI_LogNextOff   (TOMPtrOff+Sz4kb)-(PSI_hLogSz+24*8)  // offset from beginning of MinState
        #define  PSI_LengthOff    (PSI_LogNextOff+0x08)
        #define  PSI_LogTypeOff   (PSI_LengthOff+0x04)
        #define  PSI_TimeStampOff (PSI_LogTypeOff+0x04)
        
// PSI Processor Specific Info Header
        #define  PSI_pValidOff    (PSI_TimeStampOff+0x08)  

// PSI Proc. State, Cache, TLB & Bus Check info.
        #define  PSI_StatusCmdOff    (PSI_pValidOff+0x08)
        #define  PSI_CacheCheckOff   (PSI_StatusCmdOff+0x08)    
        #define  PSI_CacheTarAdrOff  (PSI_CacheCheckOff+0x008)  
        #define  PSI_CacheCheck1Off  (PSI_CacheTarAdrOff+0x08)    
        #define  PSI_CacheTarAd1rOff (PSI_CacheCheck1Off+0x008)  
        #define  PSI_CacheCheck2Off  (PSI_CacheTarAd1rOff+0x08)    
        #define  PSI_CacheTarAdr2Off (PSI_CacheCheck2Off+0x008)  
        #define  PSI_CacheCheck3Off  (PSI_CacheTarAdr2Off+0x08)    
        #define  PSI_CacheTarAdr3Off (PSI_CacheCheck3Off+0x008)  
        #define  PSI_CacheCheck4Off  (PSI_CacheTarAdr3Off+0x08)    
        #define  PSI_CacheTarAdr4Off (PSI_CacheCheck4Off+0x008)  
        #define  PSI_CacheCheck5Off  (PSI_CacheTarAdr4Off+0x08)    
        #define  PSI_CacheTarAdr5Off (PSI_CacheCheck5Off+0x008)  
        #define  PSI_TLBCheckOff     (PSI_CacheTarAdr5Off+0x008)  
        #define  PSI_BusCheckOff     (PSI_TLBCheckOff+0x030)  
        #define  PSI_BusReqAdrOff    (PSI_BusCheckOff+0x008)  
        #define  PSI_BusResAdrOff    (PSI_BusReqAdrOff+0x008)  
        #define  PSI_BusTarAdrOff    (PSI_BusResAdrOff+0x008)  

// PSI Static Info - 512 bytes aligned starting at 4K boundary
        #define  PSI_MinStateOff  (PSI_BusTarAdrOff+0x08)   
        #define  PSI_BankGRsOff   (PSI_MinStateOff+aSzProcMinState)  
        #define  PSI_GRNaTOff     (PSI_BankGRsOff+Sz128b)
        #define  PSI_BRsOff       (PSI_GRNaTOff+0x08)
        #define  PSI_CRsOff       (PSI_BRsOff+Sz64b)
        #define  PSI_ARsOff       (PSI_CRsOff+Sz1kb)
        #define  PSI_RRsOff       (PSI_ARsOff+Sz1kb)

//4************ start of First Proc. Specific INIT PSI 4K block ************
// data structure SAL INIT Processor-0 State Info (PSI) Structure 
// offset from beginning of MinState
        #define  PSI_iLogNextOff   (PSI_LogNextOff+Sz4kb)      
        #define  PSI_iLengthOff    (PSI_iLogNextOff+0x08)
        #define  PSI_iLogTypeOff   (PSI_iLengthOff+0x04)
        #define  PSI_iTimeStampOff (PSI_iLogTypeOff+0x04)
        
// PSI Processor Specific Info Header
        #define  PSI_ipValidOff    (PSI_iTimeStampOff+0x08)  

// PSI Proc. State, Cache, TLB & Bus Check info.
        //#define  PSI_iStatusCmdOff  (PSI_ipValidOff+0x04)
        #define  PSI_iStaticSizeOff (PSI_ipValidOff+0x04)

// PSI Proc. State, Cache, TLB & Bus Check info.
        #define  PSI_iStatusCmdOff    (PSI_ipValidOff+0x08)
        #define  PSI_iCacheCheckOff   (PSI_iStatusCmdOff+0x08)    
        #define  PSI_iCacheTarAdrOff  (PSI_iCacheCheckOff+0x008)  
        #define  PSI_iCacheCheck1Off  (PSI_iCacheTarAdrOff+0x08)    
        #define  PSI_iCacheTarAd1rOff (PSI_iCacheCheck1Off+0x008)  
        #define  PSI_iCacheCheck2Off  (PSI_iCacheTarAd1rOff+0x08)    
        #define  PSI_iCacheTarAdr2Off (PSI_iCacheCheck2Off+0x008)  
        #define  PSI_iCacheCheck3Off  (PSI_iCacheTarAdr2Off+0x08)    
        #define  PSI_iCacheTarAdr3Off (PSI_iCacheCheck3Off+0x008)  
        #define  PSI_iCacheCheck4Off  (PSI_iCacheTarAdr3Off+0x08)    
        #define  PSI_iCacheTarAdr4Off (PSI_iCacheCheck4Off+0x008)  
        #define  PSI_iCacheCheck5Off  (PSI_iCacheTarAdr4Off+0x08)    
        #define  PSI_iCacheTarAdr5Off (PSI_iCacheCheck5Off+0x008)  
        #define  PSI_iTLBCheckOff     (PSI_iCacheTarAdr5Off+0x008)  
        #define  PSI_iBusCheckOff     (PSI_iTLBCheckOff+0x030)  
        #define  PSI_iBusReqAdrOff    (PSI_iBusCheckOff+0x008)  
        #define  PSI_iBusResAdrOff    (PSI_iBusReqAdrOff+0x008)  
        #define  PSI_iBusTarAdrOff    (PSI_iBusResAdrOff+0x008)  


// PSI Static Info - 512 bytes aligned starting at 4K boundary
        #define  PSI_iMinStateOff  (PSI_iBusTarAdrOff+0x08)   
        #define  PSI_iBankGRsOff   (PSI_iMinStateOff+aSzProcMinState)  
        #define  PSI_iGRNaTOff     (PSI_iBankGRsOff+Sz128b)
        #define  PSI_iBRsOff       (PSI_iGRNaTOff+0x08)
        #define  PSI_iCRsOff       (PSI_iBRsOff+Sz64b)
        #define  PSI_iARsOff       (PSI_iCRsOff+Sz1kb)
        #define  PSI_iRRsOff       (PSI_iARsOff+Sz1kb)


//5************ start of First Proc. Specific CMC PSI 4K block *************
// data structure SAL CMC Processor State Info (PSI) Structure 
// offset from beginning of MinState
        #define  PSI_cLogNextOff   (PSI_iLogNextOff+Sz4kb)      
        #define  PSI_cLengthOff    (PSI_cLogNextOff+0x08)
        #define  PSI_cLogTypeOff   (PSI_cLengthOff+0x04)
        #define  PSI_cTimeStampOff (PSI_cLogTypeOff+0x04)
        
// PSI Processor Specific Info Header
        #define  PSI_cpValidOff    (PSI_cTimeStampOff+0x08)  

// PSI Proc. State, Cache, TLB & Bus Check info.
        #define  PSI_cStatusCmdOff    (PSI_cpValidOff+0x08)
        #define  PSI_cCacheCheckOff   (PSI_cStatusCmdOff+0x08)    
        #define  PSI_cCacheTarAdrOff  (PSI_cCacheCheckOff+0x008)  
        #define  PSI_cCacheCheck1Off  (PSI_cCacheTarAdrOff+0x08)    
        #define  PSI_cCacheTarAd1rOff (PSI_cCacheCheck1Off+0x008)  
        #define  PSI_cCacheCheck2Off  (PSI_cCacheTarAd1rOff+0x08)    
        #define  PSI_cCacheTarAdr2Off (PSI_cCacheCheck2Off+0x008)  
        #define  PSI_cCacheCheck3Off  (PSI_cCacheTarAdr2Off+0x08)    
        #define  PSI_cCacheTarAdr3Off (PSI_cCacheCheck3Off+0x008)  
        #define  PSI_cCacheCheck4Off  (PSI_cCacheTarAdr3Off+0x08)    
        #define  PSI_cCacheTarAdr4Off (PSI_cCacheCheck4Off+0x008)  
        #define  PSI_cCacheCheck5Off  (PSI_cCacheTarAdr4Off+0x08)    
        #define  PSI_cCacheTarAdr5Off (PSI_cCacheCheck5Off+0x008)  
        #define  PSI_cTLBCheckOff     (PSI_cCacheTarAdr5Off+0x008)  
        #define  PSI_cBusCheckOff     (PSI_cTLBCheckOff+0x030)  
        #define  PSI_cBusReqAdrOff    (PSI_cBusCheckOff+0x008)  
        #define  PSI_cBusResAdrOff    (PSI_cBusReqAdrOff+0x008)  
        #define  PSI_cBusTarAdrOff    (PSI_cBusResAdrOff+0x008)  


// PSI Static Info - 512 bytes aligned starting at 4K boundary
        #define  PSI_cMinStateOff (PSI_cBusTarAdrOff+0x08)   
        #define  PSI_cBankGRsOff  (PSI_cMinStateOff+aSzProcMinState)  
        #define  PSI_cGRNaTOff    (PSI_cBankGRsOff+Sz128b)
        #define  PSI_cBRsOff      (PSI_cGRNaTOff+0x08)
        #define  PSI_cCRsOff      (PSI_cBRsOff+Sz64b)
        #define  PSI_cARsOff      (PSI_cCRsOff+Sz1kb)
        #define  PSI_cRRsOff      (PSI_cARsOff+Sz1kb)

//6************ start of First Proc. Specific PMI 4K block *************
//PMI Data Area 4 Kbytes, offsets from MinState Ptr.
        #define  PMI_BL_SP_BASEOff SzSALData
        #define  PmiStackFrameOff  (PMI_BL_SP_BASEOff+SzBkpStore)  
        #define  PMIGlobalDataOff  (PmiStackFrameOff+SzStackFrame)

        #define TOM TOMPtrOff

// returns Entry Points in regX for whatever SAL/PAL procs, ProcNum value etc.
#define GetEPs(NameOff,regX,regY) \
        add     regX= TOMPtrOff,regX;;\
        ld8     regY = [regX];;\
        movl    regX=NameOff;;\
        add     regY = regX,regY;;\
        ld8     regX = [regY];;                 

#define GetEPsRAM(NameOff,regX,rBOM) \
        movl    regX= SALDataBlockLength;;\
        add     regX = regX,rBOM;\
        movl    rBOM=NameOff;; \
        add     regX = regX,rBOM;;\
        ld8     regX = [regX];;                 

// calculates absolute physical ptr to  variable from offset and base
#define GetAbsPtr(Var,RegX,BASE) \
        movl RegX=Var##Off##;;\
        add RegX=RegX, BASE;;

// input regX=XR0, returns Bottom of Memory (BOM) TOM-256k in regX
#define GetBOM(regX,regY) \
        add     regX= TOM,regX;;\
        ld8     regX=[regX];; \
        movl    regY=SALDataBlockLength;; \
        sub     regX=regX,regY;;

// input regX=XR0, returns Top of Memory (TOM) in regX
#define GetTOM(regX) \
        add     regX= TOM,regX;;\
        ld8     regX=[regX];; 

// returns the pointer to "this" processor MinState Area beginning in regX 
// bom is preserved
#define GetMinStateHead(regX,regY,bom,ProcX) \
        movl    regX=SzPMIData+SzSALData;; \
        shl     regX=regX, ProcX;; \
        movl    ProcX=SzPMIData+SzSALData;; \
        sub     regX=regX,ProcX;; \
        movl    regY=SzSALGlobal;; \
        add     regX=regY,regX;; \
        add     regX=regX,bom;;

// the save and restore macros saves R17-R19 during MCA and INIT before any
// external PAL and SAL calls
#define SaveRs(regX,regY,regZ) \
        mov     xs0=regX;\
        mov     xs1=regY; \
        mov     xs2=regZ

#define ResRs(regX,regY,regZ) \
        mov     regX=xs0;\
        mov     regY=xs1; \
        mov     regZ=xs2;;

//this macro manages the stack frame for the new context, by saving the previous one
#define SwIntCxt(regX,pStkFrm,pBspStore) \
        ;; \
        mov     regX=ar##.##rsc;; \
        st8     [pStkFrm]=regX,Inc8;; \
        mov     regX=ar##.##pfs;; \
        st8     [pStkFrm]=regX,Inc8; \
        cover ;;\
        mov     regX=cr##.##ifs;; \
        st8     [pStkFrm]=regX,Inc8;; \
        mov     regX=ar##.##bspstore;; \
        st8     [pStkFrm]=regX,Inc8;; \
        mov     regX=ar##.##rnat;; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     ar##.##bspstore=pBspStore;; \
        mov     regX=ar##.##bsp;; \
        sub     regX=regX,pBspStore;;\
        st8     [pStkFrm]=regX,Inc8

//this macro restores the stack frame of the previous context 
#define RtnIntCxt(PSRMaskReg,regX,pStkFrm) \
        ;; \
        alloc   regX=ar.pfs,0,0,0,0;\
        add     pStkFrm=rBSPDiffOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        shl     regX=regX,16;;\
        mov     ar##.##rsc=regX;; \
        loadrs;;\
        add     pStkFrm=-rBSPDiffOff+rBSPStOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     ar##.##bspstore=regX;; \
        add     pStkFrm=-rBSPStOff+rRNATOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     ar##.##rnat=regX;;\
        add     pStkFrm=-rRNATOff+rPFSOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     ar##.##pfs=regX;\
        add     pStkFrm=-rPFSOff+rIFSOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     cr##.##ifs=regX;\
        add     pStkFrm=-rIFSOff+rRSCOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     ar##.##rsc=regX ;\
        add     pStkFrm=-rRSCOff,pStkFrm;\
        mov     regX=cr.ipsr;;\
        st8     [pStkFrm]=regX,Inc8;\
        mov     regX=cr.iip;;\
        st8     [pStkFrm]=regX,-Inc8;\
        mov     regX=psr;;\
        or      regX=regX,PSRMaskReg;;\
        mov     cr.ipsr=regX;;\
        mov     regX=ip;;\
        add     regX=0x30,regX;;\
        mov     cr.iip=regX;;\
        rfi;;\
        ld8     regX=[pStkFrm],Inc8;;\
        mov     cr.ipsr=regX;;\
        ld8     regX=[pStkFrm];;\
        mov     cr.iip=regX

//these macros do left and right rotate respectively.
#define lRotate(regX, regCnt,nLabel) \
        mov     ar##.##lc=regCnt;\
nLabel:;\
        shrp        regX=regX,regX,63;\
        br##.##cloop##.##dpnt   nLabel


#define rRotate(regX, regCnt,nLabel) \
        mov     ar##.##lc=regCnt;\
nLabel:;\
        shrp        regX=regX,regX,1;\
        br##.##cloop##.##dpnt   nLabel

// macro increments pointer in regX by (4Kbytes x regCnt)
#define Mul(regX, regCnt,regI) \
        cmp.eq.unc pt0,p0=0x02, regCnt;\
        movl    regI=Sz4kb;;\
        shl     regI=regI,regCnt;;\
        adds    regI=-Sz4kb,regI;;\
(pt0)   adds    regI=-Sz4kb,regI;;\
        add     regX=regX,regI

// this macro loads the return pointer in b0 during static procedure calls
// rLabel=label after macro, pLabel=label prior to this macro
#define SetupBrFrame(regX, regY, regZ, pLabel,rLabel) \
        mov     regX=ip;\
        movl    regY=pLabel;\
        movl    regZ=rLabel;;\
        sub     regZ=regZ,regY;;\
        add     regX=regX,regZ;;\
        mov     b0=regX

//this macro manages the stack frame for the new context, by saving the previous one
#define nSwIntCxt(regX,pStkFrm,pBspStore) \
        mov     regX=ar##.##rsc; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     regX=ar##.##pfs; \
        st8     [pStkFrm]=regX,Inc8; \
        cover;;\
        mov     regX=ar##.##ifs; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     regX=ar##.##bspstore; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     regX=ar##.##rnat; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     ar##.##bspstore=pBspStore; \
        mov     regX=ar##.##bsp; \
        st8     [pStkFrm]=regX,Inc8;\
        mov     regX=b0;\
        st8     [pStkFrm]=regX,Inc8

//this macro restores the stack frame of the previous context 
#define nRtnIntCxt(regX,pStkFrm) \
        alloc   regX=ar.pfs,0,0,0,0;\
        ld8     regX=[pStkFrm],Inc8; \
        mov     ar##.##bspstore=regX; \
        ld8     regX=[pStkFrm],Inc8; \
        mov     ar##.##rnat=regX


#define GLOBAL_FUNCTION(Function) \
         .##type   Function, @function; \
         .##global Function


#define WRITE_MASK  (0x8000000000000000)    // RTC IO port write mask

//
// GetProcessorLidBasedEntry()
//  - macro to setup register regX with arrary entry, indexed with LID.ID field.
//

#define GetProcessorLidBasedEntry(regX,regY,szOffset,VarName,lpName) \
        mov         regY=ar##.##lc;\
        mov         regX=cr##.##lid;;\
        extr##.##u  regX=regX,DestIDMaskPos,8;;\
        mov         ar##.##lc=regX;;\
        movl        regX=VarName;;\
        lpName##:##;\
        addl        regX=szOffset,regX;\
        br##.##cloop##.##dpnt lpName;;\
        mov         ar##.##lc=regY;\
        addl        regX=-szOffset, regX;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\halnls.h ===
//
// Include code from halx86 and append IA64 specific definitions.
// This is a cpp style symbolic link
//

#include "..\..\halx86\i386\halnls.h"

#define MSG_MCA_HARDWARE_ERROR  "\n*** Machine Check Abort: Hardware Malfunction\n\n"
#define MSG_INIT_HARDWARE_ERROR "\n*** Machine Initialization Event: Hardware Malfunction\n\n"

#define MSG_CMC_PENDING  "Corrected Machine Check pending, HAL CMC handling not enabled\n" 
#define MSG_CPE_PENDING  "Corrected Platform Errors pending, HAL CPE handling is not enabled\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64bus.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64bus.c

Abstract:

    This module implements the routines to support the management
    of bus resources and translation of bus addresses.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

    Based on simbus.c

--*/

#include "halp.h"
#include "hal.h"

const UCHAR   HalName[] = "ACPI 2.0 - APIC platform";
#define HalName L"ACPI 2.0 - APIC platform"

const ULONG HalDisableFirmwareMapper = 1;

VOID
HalpInitializePciBus (
    VOID
    );

VOID
HalpInheritBusAddressMapInfo (
    VOID
    );

VOID
HalpInitBusAddressMapInfo (
    VOID
    );

BOOLEAN
HalpTranslateSystemBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
KeFlushWriteBuffer(
    VOID
    )

/*++

Routine Description:

KeFlushWriteBuffer
    Flushes all write buffers and/or other data storing or reordering
    hardware on the current processor.  This ensures that all previous
    writes will occur before any new reads or writes are completed.

    In the simulation environment, there is no write buffer and nothing
    needs to be done.

Arguments:

    None

Return Value:

    None.

--*/
{
    __mf();
    return;
}

VOID
HalReportResourceUsage (
    VOID
    )
/*++

Routine Description:
    The registery is now enabled - time to report resources which are
    used by the HAL.

Arguments:

Return Value:

--*/
{
    UNICODE_STRING  UHalName;
    INTERFACE_TYPE  interfacetype;

    //
    // Set type
    //

    switch (HalpBusType) {
        case MACHINE_TYPE_ISA:  interfacetype = Isa;            break;
        case MACHINE_TYPE_EISA: interfacetype = Eisa;           break;
        case MACHINE_TYPE_MCA:  interfacetype = MicroChannel;   break;
        default:                interfacetype = Internal;       break;
    }

    //
    // Report HALs resource usage
    //

    RtlInitUnicodeString (&UHalName, HalName);

    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        interfacetype
    );

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();
#ifdef notyet
    //
    // Update supported address info with MPS bus address map
    //

    HalpInitBusAddressMapInfo ();

    //
    // Inherit any bus address mappings from MPS hierarchy descriptors
    //

    HalpInheritBusAddressMapInfo ();
#endif // notyet

    HalpRegisterPciDebuggingDeviceInfo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\halp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    halp.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces, defines and structures.

Author:

    John Vert (jvert) 11-Feb-92


Revision History:

--*/
#ifndef _HALP_H_
#define _HALP_H_

#include "nthal.h"
#include "hal.h"
#include "halnls.h"
#include "kxia64.h"
#include "acpitabl.h"

//
// Pickup the pnp guid definitions.
//

#include "wdmguid.h"

#ifndef _HALI_
#include "..\inc\hali.h"
#endif

#include "i64fw.h"

#define SAPIC_SPURIOUS_LEVEL 0
#define DPC_LEVEL            2
#define CMCI_LEVEL           3

#define SAPIC_SPURIOUS_VECTOR 0x0F

#define CMCI_VECTOR (CMCI_LEVEL << VECTOR_IRQL_SHIFT)          // 0x30
#define CPEI_VECTOR (CMCI_VECTOR+1)                            // 0x31
// CPEI_VECTOR is defined relative to CMCI_VECTOR,
// CPEI_LEVEL  is defined from CPEI_VECTOR.
#define CPEI_LEVEL  (CPEI_VECTOR >> VECTOR_IRQL_SHIFT)

#define SYNCH_VECTOR (SYNCH_LEVEL << VECTOR_IRQL_SHIFT)        // 0xD0
#define CLOCK_VECTOR (CLOCK_LEVEL << VECTOR_IRQL_SHIFT)        // 0xD0

#define IPI_VECTOR (IPI_LEVEL << VECTOR_IRQL_SHIFT)            // 0xE0

#define PROFILE_VECTOR (PROFILE_LEVEL << VECTOR_IRQL_SHIFT)    // 0xF0
#define PERF_VECTOR    (PROFILE_VECTOR+1)                      // 0xF1
#define MC_RZ_VECTOR   (0xD+(HIGH_LEVEL << VECTOR_IRQL_SHIFT)) // 0xFD
#define MC_WKUP_VECTOR (MC_RZ_VECTOR+1)                        // 0xFE

//
// define MCA_LEVEL, the irql level that the MCA handler will run
//
#define MCA_LEVEL SYNCH_LEVEL

#if DBG

//
// _HALIA64_DPFLTR_LEVEL: HALIA64 specific DbgPrintEx() levels.
//

#ifndef DPFLTR_COMPONENT_PRIVATE_MINLEVEL
//
// FIXFIX - 01/2000: The DPFLTR LEVEL definitions do not specify a maximum.
//                   We are defining DPFLTR_INFO_LEVEL as the default max.
//
#define DPFLTR_COMPONENT_PRIVATE_MINLEVEL (DPFLTR_INFO_LEVEL + 1)
#endif // !DPFLTR_COMPONENT_PRIVATE_MINLEVEL

typedef enum _HALIA64_DPFLTR_LEVEL {
    HALIA64_DPFLTR_PNP_LEVEL      = DPFLTR_COMPONENT_PRIVATE_MINLEVEL,
    HALIA64_DPFLTR_PROFILE_LEVEL,
    HALIA64_DPFLTR_MCE_LEVEL,     // Machine Check Events level
    HALIA64_DPFLTR_MAX_LEVEL,
    HALIA64_DPFLTR_MAXMASK        = (((unsigned int)0xffffffff) >> ((unsigned int)(32-HALIA64_DPFLTR_MAX_LEVEL)))
} HALIA64_DPFLTR_LEVEL;

#define HAL_FATAL_ERROR   DPFLTR_ERROR_LEVEL
#define HAL_ERROR         DPFLTR_ERROR_LEVEL
#define HAL_WARNING       DPFLTR_WARNING_LEVEL
#define HAL_INFO          DPFLTR_INFO_LEVEL
#define HAL_VERBOSE       DPFLTR_INFO_LEVEL
#define HAL_PNP           HALIA64_DPFLTR_PNP_LEVEL
#define HAL_PROFILE       HALIA64_DPFLTR_PROFILE_LEVEL
#define HAL_MCE           HALIA64_DPFLTR_MCE_LEVEL

extern ULONG HalpUseDbgPrint;

VOID
__cdecl
HalpDebugPrint(
    ULONG  Level,
    PCCHAR Message,
    ...
    );

#define HalDebugPrint( _x_ )  HalpDebugPrint _x_

#else  // !DBG

#define HalDebugPrint( _x_ )

#endif // !DBG

//
// HALP_VALIDATE_LOW_IRQL()
//
// This macro validates the call at low irql - passive or apc levels - and returns
// STATUS_UNSUCCESSFUL if high irql.
//

#define HALP_VALIDATE_LOW_IRQL() \
 if (KeGetCurrentIrql() > APC_LEVEL) { \
    HalDebugPrint((HAL_ERROR,"HAL: code called at IRQL %d > APC_LEVEL\n", KeGetCurrentIrql() )); \
    ASSERT(FALSE); \
    return( STATUS_UNSUCCESSFUL );  \
 }

#define HAL_MAXIMUM_PROCESSOR 64
#define HAL_MAXIMUM_LID_ID    256

//
// Default clock and profile timer intervals (in 100ns-unit)
//

#define DEFAULT_CLOCK_INTERVAL 100000         // 10  ms
#define MINIMUM_CLOCK_INTERVAL 10000          //  1  ms
#define MAXIMUM_CLOCK_INTERVAL 100000         // 10  ms
#define CLOCK_UPDATE_THRESHOLD  (500 * MAXIMUM_CLOCK_INTERVAL)  // 5 seconds

extern double HalpITCTicksPer100ns;
extern ULONG HalpCPUMHz;


//
// Define Realtime Clock register numbers.
//

#define RTC_SECOND 0                    // second of minute [0..59]
#define RTC_SECOND_ALARM 1              // seconds to alarm
#define RTC_MINUTE 2                    // minute of hour [0..59]
#define RTC_MINUTE_ALARM 3              // minutes to alarm
#define RTC_HOUR 4                      // hour of day [0..23]
#define RTC_HOUR_ALARM 5                // hours to alarm
#define RTC_DAY_OF_WEEK 6               // day of week [1..7]
#define RTC_DAY_OF_MONTH 7              // day of month [1..31]
#define RTC_MONTH 8                     // month of year [1..12]
#define RTC_YEAR 9                      // year [00..99]
#define RTC_CENTURY 0x32                // Century byte offset
#define RTC_CONTROL_REGISTERA 10        // control register A
#define RTC_CONTROL_REGISTERB 11        // control register B
#define RTC_CONTROL_REGISTERC 12        // control register C
#define RTC_CONTROL_REGISTERD 13        // control register D
#define RTC_REGNUMBER_RTC_CR1 0x6A      // control register 1

#define RTC_ISA_ADDRESS_PORT   0x070

#define RTC_ISA_DATA_PORT      0x071

#include <efi.h>

#define EFI_PHYSICAL_GET_VARIABLE_INDEX  0xFF // GetVariable;
#define EFI_PHYSICAL_SET_VARIABLE_INDEX  0xFE // SetVariable;

//
// Time Services
//

#define EFI_GET_TIME_INDEX              0 // GetTime;
#define EFI_SET_TIME_INDEX              1 // SetTime;
#define EFI_GET_WAKEUP_TIME_INDEX       2 // GetWakeupTime;
#define EFI_SET_WAKEUP_TIME_INDEX       3 // SetWakeupTime;

//
// Virtual memory services
//

#define EFI_SET_VIRTUAL_ADDRESS_MAP_INDEX     4  // SetVirtualAddressMap;
#define EFI_CONVERT_POINTER_INDEX             5  // ConvertPointer;

//
// Variable serviers
//

#define EFI_GET_VARIABLE_INDEX                6 // GetVariable;
#define EFI_GET_NEXT_VARIABLE_NAME_INDEX      7 // GetNextVariableName;
#define EFI_SET_VARIABLE_INDEX                8 // SetVariable;

//
// Misc
//

#define EFI_GET_NEXT_HIGH_MONO_COUNT_INDEX    9  // GetNextHighMonotonicCount;
#define EFI_RESET_SYSTEM_INDEX               0xA // ResetSystem;


//
// Task priority functions
//

#define EFI_RAISE_TPL_INDEX                        0xB // Raise TPL
#define EFI_RESTORE_TPL_INDEX                      0xC // Restore TPL

//
// Memory functions
//

#define EFI_ALLOCATE_PAGES_INDEX                    0xD  // AllocatePages
#define EFI_FREE_PAGES_INDEX                        0xE  // FreePages
#define EFI_GET_MEMORY_MAP_INDEX                    0xF  // GetMemoryMap
#define EFI_ALLOCATE_POOL_INDEX                     0x10 // AllocatePool
#define EFI_FREE_POOL_INDEX                         0x11 // FreePool

//
// Event & timer functions
//

#define EFI_CREATE_EVENT_INDEX                      0x12 // CreateEvent
#define EFI_SET_TIMER_INDEX                         0x13 // SetTimer
#define EFI_WAIT_FOR_EVENT_INDEX                    0x14 // WaitForEvent
#define EFI_SIGNAL_EVENT_INDEX                      0x15 // SignalEvent
#define EFI_CLOSE_EVENT_INDEX                       0x16 // CloseEvent
#define EFI_NOTIFY_IDLE_INDEX                       0x17 // NotifyIdle



//
// Protocol handler functions
//

#define EFI_INSTALL_PROTOCOL_INTERFACE_INDEX        0x18 // InstallProtocolInterface;
#define EFI_REINSTALL_PROTOCOL_INTERFACE_INDEX      0x19 // ReinstallProtocolInterface;
#define EFI_UNINSTALL_PROTOCOL_INTERFACE_INDEX      0x1A // UninstallProtocolInterface;
#define EFI_HANDLE_PROTOCOL_INDEX                   0x1B // HandleProtocol;
#define EFI_REGISTER_PROTOCOL_NOTIFY_INDEX          0x1C // RegisterProtocolNotify;
#define EFI_LOCATE_HANDLE_INDEX_INDEX               0x1D // LocateHandle;
#define EFI_LOCATE_DEVICE_PATH_INDEX                0x1E // LocateDevicePath;
#define EFI_UNREFERENCE_HANDLE_INDEX                0x1F // UnreferenceHandle;
#define EFI_LOCATE_PROTOCOL_INDEX                   0x20 // LocateProtocol;

    //
    // Image functions
    //

#define EFI_IMAGE_LOAD_INDEX                        0x21 // LoadImage;
#define EFI_IMAGE_START_INDEX                       0x22 // StartImage;
#define EFI_EXIT_INDEX                              0x23 // Exit;
#define EFI_IMAGE_UNLOAD_INDEX                      0x24 // UnloadImage;
#define EFI_EXIT_BOOT_SERVICES_INDEX                0x25 // ExitBootServices;

    //
    // Misc functions
    //

#define    EFI_GET_NEXT_MONOTONIC_COUNT_INDEX       0x26 // GetNextMonotonicCount;
#define    EFI_STALL_INDEX                          0x27 // Stall;
#define    EFI_SET_WATCHDOG_TIMER_INDEX             0x28 // SetWatchdogTimer;


#define EFI_VARIABLE_ATTRIBUTE               \
        EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS


extern PVOID HalpRtcAddressPort;

extern PVOID HalpRtcDataPort;

extern PLOADER_PARAMETER_BLOCK KeLoaderBlock;

//
// Define Control Register A structure.
//

typedef struct _RTC_CONTROL_REGISTER_A {
    UCHAR RateSelect : 4;
    UCHAR TimebaseDivisor : 3;
    UCHAR UpdateInProgress : 1;
} RTC_CONTROL_REGISTER_A, *PRTC_CONTROL_REGISTER_A;

//
// Define Control Register B structure.
//

typedef struct _RTC_CONTROL_REGISTER_B {
    UCHAR DayLightSavingsEnable : 1;
    UCHAR HoursFormat : 1;
    UCHAR DataMode : 1;
    UCHAR SquareWaveEnable : 1;
    UCHAR UpdateInterruptEnable : 1;
    UCHAR AlarmInterruptEnable : 1;
    UCHAR TimerInterruptEnable : 1;
    UCHAR SetTime : 1;
} RTC_CONTROL_REGISTER_B, *PRTC_CONTROL_REGISTER_B;

//
// Define Control Register C structure.
//

typedef struct _RTC_CONTROL_REGISTER_C {
    UCHAR Fill : 4;
    UCHAR UpdateInterruptFlag : 1;
    UCHAR AlarmInterruptFlag : 1;
    UCHAR TimeInterruptFlag : 1;
    UCHAR InterruptRequest : 1;
} RTC_CONTROL_REGISTER_C, *PRTC_CONTROL_REGISTER_C;

//
// Define Control Register D structure.
//

typedef struct _RTC_CONTROL_REGISTER_D {
    UCHAR Fill : 7;
    UCHAR ValidTime : 1;
} RTC_CONTROL_REGISTER_D, *PRTC_CONTROL_REGISTER_D;




#define EISA_DMA_CHANNELS 8

extern UCHAR HalpDmaChannelMasks[];

//
// HalpOwnedDisplayBeforeSleep is defined in mpdat.c
//

extern BOOLEAN HalpOwnedDisplayBeforeSleep;

#define PIC_VECTORS 16

#define PRIMARY_VECTOR_BASE  0x30

extern KAFFINITY HalpDefaultInterruptAffinity;

//
// Thierry / PeterJ 02/00:
//  Instead of implementing our own IPI generic call, we use KiIpiGenericCall().
//

typedef
ULONG_PTR
(*PKIPI_BROADCAST_WORKER)(
    IN ULONG_PTR Argument
    );

ULONG_PTR
KiIpiGenericCall (
    IN PKIPI_BROADCAST_WORKER BroadcastFunction,
    IN ULONG_PTR Context
    );

//
// ROUND UP SIZE macros:
//
// SIZE_T
// ROUND_UP_SIZE_T(
//      IN SIZE_T _SizeT,
//      IN ULONG  _Pow2,
//      )
//

#define ROUND_UP_SIZE_T(_SizeT, _Pow2) \
        ( (SIZE_T) ( (((SIZE_T)(_SizeT))+(_Pow2)-1) & (~(((LONG)(_Pow2))-1)) ) )

#define ROUND_UP_SIZE(/* SIZE_T */ _SizeT) ROUND_UP_SIZE_T((_SizeT), sizeof(SIZE_T))

//
// PCR has HalReserved area. The following will be the offsets reserved
// by HAL in the HalReserved area.
//

#define CURRENT_ITM_VALUE_INDEX                    0
#define PROCESSOR_ID_INDEX                         1
#define PROCESSOR_PHYSICAL_FW_STACK_INDEX          2
#define PROCESSOR_INDEX_BEFORE_PROFILING           3  // ToBeIncremented if new index

// PROCESSOR_PROFILING_INDEX:
// HalReserved[] base of indexes used for Performance Profiling based
// on the IA64 Performance Counters. Refer to ia64prof.h:_HALPROFILE_PCR.
//

#define PROCESSOR_PROFILING_INDEX       (PROCESSOR_INDEX_BEFORE_PROFILING + 1)

#define PIC_SLAVE_IRQ      2
#define PIC_SLAVE_REDIRECT 9

extern PVOID HalpSleepPageLock;


NTSTATUS
HalpQueryFrequency(
    PULONGLONG ITCFrequency,
    PULONGLONG ProcessorFrequency
    );

VOID
HalpSynchICache (
    VOID
    );

VOID
KeSetAffinityThread (
    PKTHREAD       Thread,
    KAFFINITY      HalpActiveProcessors
    );

extern BOOLEAN
KdPollBreakIn (
    VOID
    );


NTSTATUS
HalAllocateAdapterChannel (
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    );

NTSTATUS
HalRealAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

ULONG
HalReadDmaCounter (
   IN PADAPTER_OBJECT AdapterObject
   );

VOID
HalpInitializeInterrupts (
    VOID
    );

VOID
HalpInitInterruptTables(
    VOID
    );

VOID
HalpInitEOITable(
    VOID
    );

VOID
HalpInitPlatformInterrupts(
    VOID
    );

VOID
HalpWriteEOITable(
    IN ULONG Vector,
    IN PULONG_PTR EoiAddress,
    IN ULONG Number
    );

VOID
HalInitializeProcessor (
    ULONG Number,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitIoMemoryBase (
    VOID
    );

VOID
HalpInitializeX86Int10Call (
    VOID
    );

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
     );


VOID
HalpClearClock (
      VOID
     );

VOID
HalpIpiInterruptHandler(
   IN PKINTERRUPT_ROUTINE Interrupt,
   IN PKTRAP_FRAME TrapFrame
   );

VOID
HalpSpuriousHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );


VOID
HalpCMCIHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpCPEIHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpMcRzHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );


VOID
HalpMcWkupHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );


NTSTATUS
HalpInitializePalTrInfo(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );


NTSTATUS
HalpEfiInitialization (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );


VOID
HalpPerfInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

typedef VOID    (*PHAL_INTERRUPT_ROUTINE)(
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpSetInternalVector (
    IN ULONG InternalVector,
    IN PHAL_INTERRUPT_ROUTINE HalInterruptServiceRoutine
    );

VOID
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpClockInterruptPn(
   IN PKINTERRUPT_ROUTINE Interrupt,
   IN PKTRAP_FRAME TrapFrame
  );

VOID
HalpInitializeClock  (
    VOID
    );

VOID
HalpInitializeClockPn (
    VOID
    );

VOID
HalpInitializeClockInterrupts(
    VOID
    );

VOID
HalpSetInitialClockRate (
    VOID
    );

VOID
HalpInitializeTimerResolution (
    ULONG Rate
    );

VOID
HalpInitApicDebugMappings(
    VOID
    );

VOID
HalpSendIPI (
    IN USHORT ProcessorID,
    IN ULONGLONG Data
    );


VOID
HalpMcWakeUp (
    VOID
    );



VOID
HalpOSRendez (
    IN USHORT ProcessorID
    );


VOID
HalpInitCacheInfo(
    ULONG   Stride
    );

VOID
HalSweepDcache (
    VOID
    );

VOID
HalSweepIcache (
    VOID
    );

VOID
HalSweepIcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

VOID
HalSweepDcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

VOID
HalSweepCacheRange (
   IN PVOID BaseAddress,
   IN SIZE_T Length
   );

VOID
HalpSweepcacheLines (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfLines
    );

LONGLONG
HalCallPal (
   IN ULONGLONG FunctionIndex,
   IN ULONGLONG Arguement1,
   IN ULONGLONG Arguement2,
   IN ULONGLONG Arguement3,
   OUT PULONGLONG ReturnValue0,
   OUT PULONGLONG ReturnValue1,
   OUT PULONGLONG ReturnValue2,
   OUT PULONGLONG ReturnValue3
   );

ULONG
HalGetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

ULONG
HalSetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

NTSTATUS
HalpHibernateHal (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler
    );

NTSTATUS
HalpResumeHal (
    IN PBUS_HANDLER  BusHandler,
    IN PBUS_HANDLER  RootHandler
    );


ULONG
HalpGetFeatureBits (
    VOID
    );

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    );

ULONG
HalpGetProcessorNumberByApicId(
    USHORT ApicId
    );

extern UCHAR  HalpMaxProcsPerCluster;

//
// Always called with the IDT form of the vector
//

#define HalpSetHandlerAddressToVector(Vector, Handler) \
   PCR-> InterruptRoutine[Vector] = (PKINTERRUPT_ROUTINE)Handler;

#define HalpEnableInterrupts()   __ssm(1 << PSR_I)

BOOLEAN
HalpDisableInterrupts (
    VOID
    );

ULONG
HalpAcquireHighLevelLock (
    PKSPIN_LOCK Lock
    );

VOID
HalpReleaseHighLevelLock (
    PKSPIN_LOCK Lock,
    ULONG       OldLevel
    );

#include "ixisa.h"

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
//
//

typedef struct _PROCESSOR_INFO {
    UCHAR   NtProcessorNumber;
    UCHAR   AcpiProcessorID;
    USHORT  LocalApicID;

} PROCESSOR_INFO, *PPROCESSOR_INFO;

extern PROCESSOR_INFO HalpProcessorInfo[HAL_MAXIMUM_PROCESSOR];

struct _MPINFO {
    ULONG ProcessorCount;
    ULONG IoSapicCount;
};

extern struct _MPINFO HalpMpInfo;

//
// HAL private Mask of all of the active processors.
//
// The specific processors bits are based on their _KPCR.Number values.

extern KAFFINITY HalpActiveProcessors;

#define VECTOR_SIZE     8
#define IPI_ID_SHIFT    4
#define IpiTOKEN_SHIFT  20
#define IpiTOKEN    0xFFE

#define EID_MASK        0xFF00

//
// Should be read from SST
//

#define DEFAULT_OS_RENDEZ_VECTOR  0xF0

#define RENDEZ_TIME_OUT  0XFFFF

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern PADAPTER_OBJECT MasterAdapterObject;

extern POBJECT_TYPE *IoAdapterObjectType;

extern BOOLEAN NoMemoryAbove4Gb;

extern BOOLEAN HalpEisaDma;

//
// Map buffer prameters.  These are initialized in HalInitSystem
//

extern PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
extern ULONG HalpMapBufferSize;

extern ULONG HalpBusType;
extern ULONG HalpCpuType;
extern UCHAR HalpSerialLen;
extern UCHAR HalpSerialNumber[];

//
// Video mapping ranges.
//

extern PVOID HalpIoMemoryBase;
extern PVOID HalpFrameBufferBase;
extern PVOID HalpLowMemoryBase;

//
// Resource usage information
//

#pragma pack(1)
typedef struct {
    UCHAR   Flags;
    KIRQL   Irql;
    UCHAR   BusReleativeVector;
} IDTUsage;

typedef struct _HalAddressUsage{
    struct _HalAddressUsage *Next;
    CM_RESOURCE_TYPE        Type;       // Port or Memory
    UCHAR                   Flags;      // same as IDTUsage.Flags
    struct {
        ULONG   Start;
        ULONG   Length;
    }                       Element[];
} ADDRESS_USAGE;
#pragma pack()

//
// Added the following line
//

#define MAXIMUM_IDTVECTOR   0x0FF

#define IDTOwned            0x01        // IDT is not available for others
#define InterruptLatched    0x02        // Level or Latched
#define InternalUsage       0x11        // Report usage on internal bus
#define DeviceUsage         0x21        // Report usage on device bus

extern IDTUsage         HalpIDTUsage[];
extern ADDRESS_USAGE   *HalpAddressUsageList;

#define HalpRegisterAddressUsage(a) \
    (a)->Next = HalpAddressUsageList, HalpAddressUsageList = (a);


//
// Temp definitions to thunk into supporting new bus extension format
//

VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusDataType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    );

#define HalpHandlerForBus   HaliHandlerForBus
#define HalpSetBusHandlerParent(c,p)    (c)->ParentHandler = p;

//
// Define function prototypes.
//

VOID
HalInitSystemPhase2(
    VOID
    );

KIRQL
HaliRaiseIrqlToDpcLevel (
   VOID
   );

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

KIRQL
HalpDisableAllInterrupts (
    VOID
    );

VOID
HalpReenableInterrupts (
    KIRQL NewIrql
    );

VOID
HalpInitializeClock(
    VOID
    );

VOID
HalpInitializeStallExecution(
    IN CCHAR ProcessorNumber
    );

VOID
HalpRemoveFences (
    VOID
    );

VOID
HalpInitializePICs(
    BOOLEAN EnableInterrupts
    );

VOID
HalpIrq13Handler (
    VOID
   );

VOID
HalpFlushTLB (
    VOID
    );

VOID
HalpSerialize (
    VOID
    );


PVOID
HalpMapPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages,
    IN MEMORY_CACHING_TYPE CacheType
    );

PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );

VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );

BOOLEAN
HalpVirtualToPhysical(
    IN  ULONG_PTR           VirtualAddress,
    OUT PPHYSICAL_ADDRESS   PhysicalAddress
    );

PVOID
HalpMapPhysicalMemoryWriteThrough(
    IN PVOID  PhysicalAddress,
    IN ULONG  NumberPages
    );

PVOID
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG_PTR MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    );

BOOLEAN
HalpBiosDisplayReset(
    IN VOID
    );

HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    );

VOID
HalpInitializeCmos (
   VOID
   );

VOID
HalpReadCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpWriteCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpAcquireCmosSpinLock (
    VOID
    );

VOID
HalpReleaseCmosSpinLock (
    VOID
    );

VOID
HalpResetAllProcessors (
    VOID
    );

VOID
HalpCpuID (
    ULONG   InEax,
    PULONG  OutEax,
    PULONG  OutEbx,
    PULONG  OutEcx,
    PULONG  OutEdx
    );

VOID
HalpYieldProcessor (
    VOID
    );

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrAddress
    );

VOID
WRMSR (
    IN ULONG        MsrAddress,
    IN ULONGLONG    MsrValue
    );

VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    );

VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    );

VOID
HalpYearIs(
    IN ULONG Year
    );

VOID
HalpRecordEisaInterruptVectors(
    VOID
    );

VOID
HalpMcaCurrentProcessorSetConfig(
    VOID
    );

NTSTATUS
HalpGetNextProcessorApicId(
    IN ULONG ProcessorNumber,
    IN OUT UCHAR    *ApicId
    );

//
// Defines for HalpFeatureBits
//

typedef enum _HALP_FEATURE {
    HAL_PERF_EVENTS                 = 0x00000001,
    HAL_MCA_PRESENT                 = 0x00000002,
    HAL_CMC_PRESENT                 = 0x00000004,
    HAL_CPE_PRESENT                 = 0x00000008,
    HAL_MCE_OEMDRIVERS_ENABLED      = 0x00000010
} HALP_FEATURE;

#define HALP_FEATURE_INIT   HAL_MCA_PRESENT

extern ULONG HalpFeatureBits;

//
// Added HalpPciIrqMask
//

extern USHORT HalpPciIrqMask;


//
// Added ITIR bit field masks
//

#define ITIR_PPN_MASK       0x7FFF000000000000
#define IoSpaceSize         0x14
#define Attribute_PPN_Mask  0x0000FFFFFFFFF000

#define IoSpaceAttribute    0x0010000000000473

//
// IA64 ERROR Apis
//

#define HALP_KERNEL_TOKEN  0x4259364117

NTSTATUS
HalpGetMceInformation(
    IN  PHAL_ERROR_INFO ErrorInfo,
    OUT PULONG          ErrorInfoLength
    );

NTSTATUS
HalpMceRegisterKernelDriver(
    IN PKERNEL_ERROR_HANDLER_INFO KernelErrorHandler,
    IN ULONG                      InfoSize
    );

typedef struct _HALP_MCELOGS_STATS *PHALP_MCELOGS_STATS; // forward declaration.

NTSTATUS
HalpGetFwMceLog(
    IN ULONG                MceType,
    IN PERROR_RECORD_HEADER Record,
    IN PHALP_MCELOGS_STATS  MceLogsStats,
    IN BOOLEAN              DoClearLog
    );

//
// IA64 Machine Check Error Logs:
//      WMI requires processor LID being stored in the Log.
//      This LID corresponds to the processor on which the SAL_PROC was executed on.
//
// TEMPTEMP: Implementation is temporary, until we implement HAL SW Error Section.
//           It currently used the LID value stored in HalReserved[PROCESSOR_ID_INDEX]
//           at processor initialization.
//           Note that the current FW builds do not update the _ERROR_PROCESSOR.CRLid field,
//           assuming there is a _ERROR_PROCESSOR section in the record.
//
//           This function should be in sync with the mce.h function GetFwMceLogProcessorNumber().
//

__inline
VOID
HalpSetFwMceLogProcessorNumber(
    PERROR_RECORD_HEADER Log
    )
{
    USHORT lid = (USHORT)(PCR->HalReserved[PROCESSOR_ID_INDEX]);
    PERROR_SECTION_HEADER section = (PERROR_SECTION_HEADER)((ULONG64)Log + sizeof(*Log));
    Log->TimeStamp.Reserved = (UCHAR)((lid >> 8) & 0xff);
    section->Reserved = (UCHAR)(lid & 0xff);
} // HalpSetFwMceLogProcessorNumber()

#define HalpGetFwMceLogProcessorNumber( /* PERROR_RECORD_HEADER */ _Log ) \
    GetFwMceLogProcessorNumber( (_Log) )

#define HALP_FWMCE_DO_CLEAR_LOG     (TRUE)
#define HALP_FWMCE_DONOT_CLEAR_LOG  (FALSE)

#define HALP_MCA_STATEDUMP_SIZE  (1024 * sizeof(ULONGLONG))     //  8KB
#define HALP_MCA_BACKSTORE_SIZE  (4 * 1024 * sizeof(ULONGLONG)) // 32KB
#define HALP_MCA_STACK_SIZE      (4 * 1024 * sizeof(ULONGLONG)) // 32KB

#define HALP_INIT_STATEDUMP_SIZE (1024 * sizeof(ULONGLONG))     //  8KB
#define HALP_INIT_BACKSTORE_SIZE (4 * 1024 * sizeof(ULONGLONG)) // 32KB
#define HALP_INIT_STACK_SIZE     (4 * 1024 * sizeof(ULONGLONG)) // 32KB

BOOLEAN
HalpAllocateMceStacks(
    IN ULONG Number
    );

BOOLEAN
HalpPreAllocateMceRecords(
    IN ULONG Number
    );

//
// IA64 MCA Apis
//

VOID
HalpMCAEnable (
    VOID
    );

NTSTATUS
HalpGetMcaLog(
    OUT PMCA_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpSetMcaLog(
    IN  PMCA_EXCEPTION Buffer,
    IN  ULONG          BufferSize
    );

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO pMcaDriverInfo  // Info about registering driver
    );

VOID
HalpMcaInit(
    VOID
    );

VOID
HalpMCADisable(
    VOID
    );

//
// MCA (but non-OS_MCA related) KeBugCheckEx wrapper:
//

#define HalpMcaKeBugCheckEx( _McaBugCheckType, _McaLog, _McaAllocatedLogSize, _Arg4 )      \
                KeBugCheckEx( MACHINE_CHECK_EXCEPTION, (ULONG_PTR)(_McaBugCheckType),      \
                                                       (ULONG_PTR)(_McaLog),               \
                                                       (ULONG_PTR)(_McaAllocatedLogSize),  \
                                                       (ULONG_PTR)(_Arg4) )

//
// IA64 Default number of MCA Error Records which size is SAL_GET_STATE_INFO_SIZE.MCA
//
// Really the size is rounded up to a multiple of the page size.
//

#define HALP_DEFAULT_PROCESSOR_MCA_RECORDS   1

//
// IA64 Default number of INIT Event Records which size is SAL_GET_STATE_INFO_SIZE.INIT
//
// Really the size is rounded up to a multiple of the page size.
//

#define HALP_DEFAULT_PROCESSOR_INIT_RECORDS  1

//
// IA64 CMC Apis related to:
//
//  - Processor
//  - Platform
//

NTSTATUS
HalpGetCmcLog(
    OUT PCMC_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpSetCmcLog(
    IN  PCMC_EXCEPTION Buffer,
    IN  ULONG          BufferSize
    );

NTSTATUS
HalpCmcRegisterDriver(
    IN PCMC_DRIVER_INFO pCmcDriverInfo  // Info about registering driver
    );

NTSTATUS
HalpGetCpeLog(
    OUT PCPE_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpSetCpeLog(
    IN  PCPE_EXCEPTION Buffer,
    IN  ULONG          BufferSize
    );

NTSTATUS
HalpCpeRegisterDriver(
    IN PCPE_DRIVER_INFO pCmcDriverInfo  // Info about registering driver
    );

#define HalpWriteCMCVector( Value ) __setReg(CV_IA64_SaCMCV, Value)

ULONG_PTR
HalpSetCMCVector(
    IN ULONG_PTR CmcVector
    );

//
// IA64 generic MCE Definitions.
//

#define HALP_MCELOGS_MAXCOUNT  50L

typedef struct _HALP_MCELOGS_STATS   {  // The following counts are for the entire boot session.
    ULONG      MaxLogSize;          // Maximum size of the information logged by SAL.
    LONG       Count1;              // Event type specific Counter.
    LONG       Count2;              // Event type specific Counter.
    LONG       KernelDeliveryFails; // Number of Kernel callback failures.
    LONG       DriverDpcQueueFails; // Number of OEM CMC Driver Dpc queueing failures.
    ULONG      PollingInterval;     // Polling interval in seconds. Only used for CPE.
    ULONG      GetStateFails;       // Number of failures in getting  the log from FW.
    ULONG      ClearStateFails;     // Number of failures in clearing the log from FW.
    ULONGLONG  LogId;               // Last record identifier.
} HALP_MCELOGS_STATS, *PHALP_MCELOGS_STATS;

//
// MC Event Type specific definition for HALP_MCELOGS_STATS.Count*
//

#define CmcInterruptCount   Count1      // CMC interrupts   count.
#define CpeInterruptCount   Count1      // CMC interrupts   count.
#define McaPreviousCount    Count1      // MCA previous  events counter.
#define McaCorrectedCount   Count2      // MCA corrected events counter.

typedef struct _HALP_MCELOGS_HEADER  {
    ULONG               Count;          // Current number of saved logs.
    ULONG               MaxCount;       // Maximum number of saved logs.
    ULONG               Overflow;       // Number of overflows
    ULONG               Tag;            // Pool allocation tag.
    ULONG               AllocateFails;  // Number of failed allocations.
    ULONG               Padding;
    SINGLE_LIST_ENTRY   Logs;           // List header    of saved logs.
} HALP_MCELOGS_HEADER, *PHALP_MCELOGS_HEADER;

#define HalpMceLogFromListEntry( _ListEntry )  \
    ((PERROR_RECORD_HEADER)((ULONG_PTR)(_ListEntry) + sizeof(SINGLE_LIST_ENTRY)))

//
// IA64 MCA Info Structure
//
//      to keep track of MCA features available on installed hardware
//
//

typedef struct _HALP_MCA_INFO {
    FAST_MUTEX          Mutex;              // non-recursive Mutex for low irql ops.
    HALP_MCELOGS_STATS  Stats;              // Information about log collection and interrupts.
    PVOID               KernelToken;        // Kernel identification.
    LONG                DpcNotification;    // Notify kernel or driver at Dispatch level.
    LONG                NoBugCheck;         // Flag to disable bugcheck calls under OS_MCA.
    KERNEL_MCA_DELIVERY KernelDelivery;     // Kernel-WMI registered notification.
    HALP_MCELOGS_HEADER KernelLogs;         // Saved logs for Kernel queries.
    MCA_DRIVER_INFO     DriverInfo;         // Info about registered OEM MCA driver
    KDPC                DriverDpc;          // DPC object for MCA
    HALP_MCELOGS_HEADER DriverLogs;         // Saved logs for OEM MCA driver.
} HALP_MCA_INFO, *PHALP_MCA_INFO;

extern HALP_MCA_INFO HalpMcaInfo;

#define HalpInitializeMcaMutex()  ExInitializeFastMutex( &HalpMcaInfo.Mutex )
#define HalpInitializeMcaInfo()   \
{ \
    HalpInitializeMcaMutex();                \
    HalpMcaInfo.KernelLogs.Tag = 'KacM';     \
    HalpMcaInfo.KernelLogs.Logs.Next = NULL; \
    HalpMcaInfo.DriverLogs.Tag = 'DacM';     \
    HalpMcaInfo.DriverLogs.Logs.Next = NULL; \
}
#define HalpAcquireMcaMutex()     ExAcquireFastMutex( &HalpMcaInfo.Mutex )
#define HalpReleaseMcaMutex()     ExReleaseFastMutex( &HalpMcaInfo.Mutex )

__inline
ULONG
HalpGetMaxMcaLogSizeProtected(
    VOID
    )
{
    ULONG maxSize;
    HalpAcquireMcaMutex();
    maxSize = HalpMcaInfo.Stats.MaxLogSize;
    HalpReleaseMcaMutex();
    return( maxSize );
} // HalpGetMaxMcaLogSizeProtected()

//
// IA64 HAL private MCE definitions.
//
// Note on current implementation: we use the MCA_INFO.Mutex.
//

#define HalpInitializeMceMutex()
#define HalpAcquireMceMutex()     ExAcquireFastMutex( &HalpMcaInfo.Mutex )
#define HalpReleaseMceMutex()     ExReleaseFastMutex( &HalpMcaInfo.Mutex )

extern KERNEL_MCE_DELIVERY HalpMceKernelDelivery;

//
// HalpMceDeliveryArgument1( )
//
// Note that the low 32 bits are only used for now...
//

#define HalpMceDeliveryArgument1( _MceOperation,  _MceEventType ) \
    ((PVOID)(ULONG_PTR) ((((_MceOperation) & KERNEL_MCE_OPERATION_MASK) * 0x10000) | ((_MceEventType) & KERNEL_MCE_EVENTTYPE_MASK) ) )

//
// IA64 INIT Info Structure
//
//      to keep track of INIT features available on installed hardware
//

typedef struct _HALP_INIT_INFO {
    FAST_MUTEX  Mutex;
    ULONG       MaxLogSize;     // Maximum size of the information logged by SAL.
} HALP_INIT_INFO, *PHALP_INIT_INFO;

extern HALP_INIT_INFO HalpInitInfo;

#define HalpInitializeInitMutex()  ExInitializeFastMutex( &HalpInitInfo.Mutex )
#define HalpAcquireInitMutex()     ExAcquireFastMutex( &HalpInitInfo.Mutex )
#define HalpReleaseInitMutex()     ExReleaseFastMutex( &HalpInitInfo.Mutex )

__inline
ULONG
HalpGetMaxInitLogSizeProtected(
    VOID
    )
{
    ULONG maxSize;
    HalpAcquireInitMutex();
    maxSize = HalpInitInfo.MaxLogSize;
    HalpReleaseInitMutex();
    return( maxSize );
} // HalpGetMaxInitLogSizeProtected()

//
// IA64 CMC
//

//
// HALP_CMC_DEFAULT_POLLING_INTERVAL
// HALP_CMC_MINIMUM_POLLING_INTERVAL
//
// If these should be exposed to WMI or OEM CMC driver, we will expose them in ntos\inc\hal.h
//

#define HALP_CMC_DEFAULT_POLLING_INTERVAL ((ULONG)60)
#define HALP_CMC_MINIMUM_POLLING_INTERVAL ((ULONG)15)

//
// IA64 CMC Info Structure
//
//      to keep track of CMC features available on installed hardware
//
// Implementation Notes - Thierry 09/15/2000.
//
//  - HAL_CMC_INFO and HAL_CPE_INFO have identical definitions at this time.
//    The merging of the code and data definitions was considered and even implemented.
//    However, because of the lack of testing with these FW/SAL features, I decided to
//    keep them separate. After further testing of the IA64 CMC/CPE features, we might
//    decide to merge them or not...
//
// MP notes 08/2000:
//
//  HALP_CMC_INFO.HalpCmcInfo
//      - only one static instance of this structure.
//      - HAL global variable.
//
//  HAL_CMC_INFO.Mutex
//      - Initialized by HalpInitializeOSMCA() on BSP.
//      - Used to synchronize accesses to structure members accessed at passive level operations.
//
//  HAL_CMC_INFO.Stats.MaxLogSize
//      - is updated by HalpInitializeOSMCA() on BSP. Not modified later.
//      - does not require any MP protection for further read accesses.
//
//  HAL_CMC_INFO.Stats.InterruptsCount
//      - Incremented with interlock at CMCI_LEVEL.
//      - Read at passive level. Approximation is fine.
//
//  HAL_CMC_INFO.Stats.KernelDeliveryFails
//      - Incremented with interlock at CMCI_LEVEL.
//      - Read at passive level. Approximation is fine.
//
//  HAL_CMC_INFO.Stats.KernelDeliveryFails
//      - Increment with interlock at CMCI_LEVEL.
//      - Read at passive level. Approximation is fine.
//
//  HAL_CMC_INFO.Stats.GetStateFails
//      - Incremented at passive level under CMC Mutex protection.
//      - Read at passive level with CMC Mutex protection.
//
//  HAL_CMC_INFO.Stats.ClearStateFails
//      - Incremented at passive level under CMC Mutex protection.
//      - Read at passive level with CMC Mutex protection.
//
//  HAL_CMC_INFO.Stats.LogId
//      - Updated at passive level under CMC Mutex protection.
//      - Read at passive level with CMC Mutex protection.
//
//  HAL_CMC_INFO.KernelToken
//      - is updated by HalpInitializeOSMCA() on BSP. Not modified later.
//      - does not require any MP protection for further read accesses.
//
//  HAL_CMC_INFO.KernelDelivery
//      - is updated by HalpMceRegisterKernelDriver() under CMC Mutex protection.
//        FIXFIX - 09/21/2000 - This initialization has a small window of where a CMC interrupt
//                              could occur and the memory change is not committed. ToBeFixed.
//      - Loaded as CMCI_LEVEL and branched to.
//      - Read at passive level as a flag under CMC Mutex protection.
//
//  HAL_CMC_INFO.KernelLogs
//      - This entire structure is initialized and updated at passive level under CMC Mutex
//        protection with the exception of KernelLogs.Tag initialized by HalpInitializeCmcInfo(),
//        called by HalpMcaInit(). HalpMcaInit() is called at end of phase 1 with Phase1 thread
//        and is executed *before* any HalpGetMceLog() calls could be done.
//
//  HAL_CMC_INFO.DriverInfo
//  HAL_CMC_INFO.Dpc
//      - is updated by HalpCmcRegisterlDriver() under CMC Mutex protection.
//        FIXFIX - 09/21/2000 - This initialization has a small window of where a CMC interrupt
//                              could occur and the memory change is not committed. ToBeFixed.
//      - Loaded as CMCI_LEVEL and branched to.
//      - Read at passive level as a flag under CMC Mutex protection.
//
//  HAL_CMC_INFO.DriverLogs
//      - This entire structure is initialized and updated at passive level under CMC Mutex
//        protection with the exception of KernelLogs.Tag initialized by HalpInitializeCmcInfo(),
//        called by HalpMcaInit(). HalpMcaInit() is called at end of phase 1 with Phase1 thread
//        and is executed *before* any HalpGetMceLog() calls could be done.
//

typedef struct _HALP_CMC_INFO {
    FAST_MUTEX          Mutex;                // non-recursive Mutex for low irql operations.
    HALP_MCELOGS_STATS  Stats;                // Information about log collection and interrupts.
    PVOID               KernelToken;          // Kernel identification.
    KERNEL_CMC_DELIVERY KernelDelivery;       // Kernel callback called at CMCI_LEVEL.
    HALP_MCELOGS_HEADER KernelLogs;           // Saved logs for Kernel queries.
    CMC_DRIVER_INFO     DriverInfo;           // Info about OEM CMC registered driver
    KDPC                DriverDpc;            // DPC object for OEM CMC driver.
    HALP_MCELOGS_HEADER DriverLogs;           // Saved logs for OEM CMC driver.
    LARGE_INTEGER       LastTime;             // Time last CMC received
    LARGE_INTEGER       ThresholdTime;        // Period within which we threshold CMC
    ULONG               ThresholdCounter;     // Count of CMC within threshold period
    ULONG               ThresholdMaximum;     // Max CMC to receive within threshold period
} HALP_CMC_INFO, *PHALP_CMC_INFO;

extern HALP_CMC_INFO HalpCmcInfo;

#define HalpInitializeCmcMutex()  ExInitializeFastMutex( &HalpCmcInfo.Mutex )
#define HalpInitializeCmcInfo()   \
{ \
    HalpInitializeCmcMutex();                \
    HalpCmcInfo.KernelLogs.Tag = 'KcmC';     \
    HalpCmcInfo.KernelLogs.Logs.Next = NULL; \
    HalpCmcInfo.DriverLogs.Tag = 'DcmC';     \
    HalpCmcInfo.DriverLogs.Logs.Next = NULL; \
}

#define HalpAcquireCmcMutex()     ExAcquireFastMutex( &HalpCmcInfo.Mutex )
#define HalpReleaseCmcMutex()     ExReleaseFastMutex( &HalpCmcInfo.Mutex )

//
// IA64 CPE
//

//
// HALP_CPE_DEFAULT_POLLING_INTERVAL
// HALP_CPE_MINIMUM_POLLING_INTERVAL
//
// If these should be exposed to WMI or OEM CPE driver, we will expose them in ntos\inc\hal.h
//

#define HALP_CPE_DEFAULT_POLLING_INTERVAL ((ULONG)60)
#define HALP_CPE_MINIMUM_POLLING_INTERVAL ((ULONG)15)

//
// HALP_CPE_MAX_INTERRUPT_SOURCES defines the size of SAPIC CPE related data structures.
//
// TEMPORARY - The CPE Interrupt model based data structures should be allocated while
//             passing through the ACPI platform interrupt source entries.
//             This will eliminate this static limitation in the number of CPEs.
//

#define HALP_CPE_MAX_INTERRUPT_SOURCES  16

//
// IA64 CPE Info Structure
//
//      to keep track of CPE features available on installed hardware
//
// Implementation Notes - Thierry 09/15/2000.
//
//  - HAL_CMC_INFO and HAL_CPE_INFO have identical definitions at this time.
//    The merging of the code and data definitions was considered and even implemented.
//    However, because of the lack of testing with these FW/SAL features, I decided to
//    keep them separate. After further testing of the IA64 CMC/CPE features, we might
//    decide to merge them or not...
//
// MP notes 08/2000:
//
//  As specified above, the MP notes are similar to the HALP_CMC_INFO structure MP notes.
//  With the exception of:
//
//  HAL_CPE_INFO.Stats.PollingInterval
//      - is updated by HalpCPEEnable() on BSP. Not modified later.
//      - does not require any MP protection for further read accesses.
//

typedef struct _HALP_CPE_INFO {
    FAST_MUTEX          Mutex;                // non-recursive Mutex for low irql operations.
    HALP_MCELOGS_STATS  Stats;                // Information about log collection and interrupts.
    PVOID               KernelToken;          // Kernel identification.
    KERNEL_CPE_DELIVERY KernelDelivery;       // Kernel callback called at CPEI_LEVEL.
    HALP_MCELOGS_HEADER KernelLogs;           // Saved logs for Kernel queries.
    CPE_DRIVER_INFO     DriverInfo;           // Info about OEM CPE registered driver
    KDPC                DriverDpc;            // DPC object for OEM CPE driver.
    HALP_MCELOGS_HEADER DriverLogs;           // Saved logs for OEM CPE driver.
    LARGE_INTEGER       LastTime;             // Time last CPE received
    LARGE_INTEGER       ThresholdTime;        // Period within which we threshold CPE
    ULONG               ThresholdCounter;     // Count of CPE within threshold period
    ULONG               ThresholdMaximum;     // Max CPE to receive within threshold period
} HALP_CPE_INFO, *PHALP_CPE_INFO;

extern HALP_CPE_INFO HalpCpeInfo;

#define HalpInitializeCpeMutex()  ExInitializeFastMutex( &HalpCpeInfo.Mutex )
#define HalpInitializeCpeInfo()   \
{ \
    HalpInitializeCpeMutex();                \
    HalpCpeInfo.KernelLogs.Tag = 'KepC';     \
    HalpCpeInfo.KernelLogs.Logs.Next = NULL; \
    HalpCpeInfo.DriverLogs.Tag = 'DepC';     \
    HalpCpeInfo.DriverLogs.Logs.Next = NULL; \
}

#define HalpAcquireCpeMutex()     ExAcquireFastMutex( &HalpCpeInfo.Mutex )
#define HalpReleaseCpeMutex()     ExReleaseFastMutex( &HalpCpeInfo.Mutex )

__inline
ULONG
HalpGetMaxCpeLogSizeProtected(
    VOID
    )
{
    ULONG maxSize;
    HalpAcquireCpeMutex();
    maxSize = HalpCpeInfo.Stats.MaxLogSize;
    HalpReleaseCpeMutex();
    return( maxSize );
} // HalpGetMaxCpeLogSizeProtected()

__inline
ULONG
HalpGetMaxCpeLogSizeAndPollingIntervalProtected(
    PULONG PollingInterval
    )
{
    ULONG maxSize;
    HalpAcquireCpeMutex();
    maxSize = HalpCpeInfo.Stats.MaxLogSize;
    *PollingInterval = HalpCpeInfo.Stats.PollingInterval;
    HalpReleaseCpeMutex();
    return( maxSize );
} // HalpGetMaxCpeLogSizeAndPollingIntervalProtected()

//
// IA64 SAL_MC_SET_PARAMS.time_out default value.
//

#define HALP_DEFAULT_MC_RENDEZ_TIMEOUT 1000

//
// IA64 bugcheck MACHINE_CHECK_EXCEPTION parameters
//
// arg0: MACHINE_EXCEPTION
// arg1: HAL_BUGCHECK_MCE_TYPE
// arg2: mcaLog
// arg3: mcaAllocatedLogSize
// arg4: salStatus
//

typedef enum _HAL_BUGCHECK_MCE_TYPE  {
    HAL_BUGCHECK_MCA_ASSERT           = 1,
    HAL_BUGCHECK_MCA_GET_STATEINFO    = 2,
    HAL_BUGCHECK_MCA_CLEAR_STATEINFO  = 3,
    HAL_BUGCHECK_MCA_FATAL            = 4,
    HAL_BUGCHECK_MCA_NONFATAL         = 5,
    HAL_BUGCHECK_MCA_MAX              = 10,
    HAL_BUGCHECK_INIT_ASSERT          = 11,
    HAL_BUGCHECK_INIT_GET_STATEINFO   = 12,
    HAL_BUGCHECK_INIT_CLEAR_STATEINFO = 13,
    HAL_BUGCHECK_INIT_FATAL           = 14,
    HAL_BUGCHECK_INIT_MAX             = 20,
} HAL_BUGCHECK_MCE_TYPE;

//
// PnP stuff
//

#define HAL_BUS_INTERFACE_STD_VERSION   1
#define HAL_IRQ_TRANSLATOR_VERSION      0
#define HAL_MEMIO_TRANSLATOR_VERSION    1
#define HAL_PORT_RANGE_INTERFACE_VERSION 0


VOID
HalTranslatorReference(
    PVOID Context
    );

VOID
HalTranslatorDereference(
    PVOID Context
    );

NTSTATUS
HalIrqTranslateResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );


ULONG
HalpGetIsaIrqState(
    ULONG   Vector
    );


//
// HAL port range services.
//

NTSTATUS
HalpQueryAllocatePortRange(
    IN BOOLEAN IsSparse,
    IN BOOLEAN PrimaryIsMmio,
    IN PVOID VirtBaseAddr OPTIONAL,
    IN PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
    IN ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
    OUT PUSHORT NewRangeId
    );

VOID
HalpFreePortRange(
    IN USHORT RangeId
    );


//
// Definition for IA64 HalpVectorToINTI
//

#define VECTOR  0xFF;
#define LEVEL   32;
extern ULONG HalpVectorToINTI[];

VOID
HalpEnableNMI (
    VOID
    );

ULONG
HalpInti2BusInterruptLevel(
    ULONG   Inti
    );

ULONG
HalpINTItoVector(
    ULONG   Inti
    );

VOID
HalpSetINTItoVector(
    ULONG   Inti,
    ULONG   Vector
    );

VOID
HalpSetRedirEntry (
    IN ULONG InterruptInput,
    IN ULONG Entry,
    IN USHORT ThisCpuApicID
    );

VOID
HalpGetRedirEntry (
    IN ULONG InterruptInput,
    IN PULONG Entry,
    IN PULONG Destination
    );

VOID
HalpDisableRedirEntry(
    IN ULONG InterruptInput
    );

//
// Definition for IA64 complete
//

//
// ACPI specific stuff
//

//
// from detect\i386\acpibios.h
//

typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT
} ACPI_BIOS_INSTALLATION_CHECK, *PACPI_BIOS_INSTALLATION_CHECK;

NTSTATUS
HalpAcpiFindRsdtPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

ULONG
HalpAcpiNumProcessors(
    VOID
    );

VOID
HaliHaltSystem(
    VOID
    );

VOID
HalpCheckPowerButton(
    VOID
    );

NTSTATUS
HalpRegisterHibernate(
    VOID
    );


VOID
HalpSleepS5(
    VOID
    );

VOID
HalProcessorThrottle (
    IN UCHAR Throttle
    );

VOID
HalpSaveDmaControllerState(
    VOID
    );

VOID
HalpSaveTimerState(
    VOID
    );

VOID
HalpSetAcpiEdgeLevelRegister(
    VOID
    );

VOID
HalpRestoreDmaControllerState(
    VOID
    );

VOID
HalpRestoreTimerState(
    VOID
    );

NTSTATUS
HalacpiGetInterruptTranslator(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

VOID
HalpInitNonBusHandler (
    VOID
    );

VOID
HalpPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );


VOID
HalpSetMaxLegacyPciBusNumber (
    IN ULONG BusNumber
    );


#ifdef notyet

typedef struct {
    UCHAR           Dma1ExtendedModePort;
    UCHAR           Dma2ExtendedModePort;
    DMA1_CONTROL    Dma1Control;
    DMA2_CONTROL    Dma2Control;
} DMA_CONTEXT, *PDMA_CONTEXT;

typedef struct {
    UCHAR   nothing;
} TIMER_CONTEXT, *PTIMER_CONTEXT;

typedef struct {
    PIC_CONTEXT     PicState;
    DMA_CONTEXT     DmaState;
} MOTHERBOARD_CONTEXT, *PMOTHERBOARD_CONTEXT;

extern MOTHERBOARD_CONTEXT  HalpMotherboardState;
extern UCHAR                HalpDmaChannelModes[];
extern PVOID                HalpSleepPageLock;
extern UCHAR                HalpDmaChannelMasks[];
extern BOOLEAN              HalpOwnedDisplayBeforeSleep;

#endif // notyet

//
// External Interrupt Control Registers macros.
//

#define HalpReadLID()       __getReg(CV_IA64_SaLID)
#define HalpClearLID()      __setReg(CV_IA64_SaLID, (unsigned __int64)0)
#define HalpReadTPR()       __getReg(CV_IA64_SaTPR)

//
// ITM/ITC macros
//

__inline
ULONGLONG
HalpReadITC()
{
#ifndef DISABLE_ITC_WORKAROUND
    ULONGLONG   currentITC;

    do {

        currentITC = __getReg(CV_IA64_ApITC);

    } while ((currentITC & 0xFFFFFFFF) == 0xFFFFFFFF);

    return currentITC;

#else
    return __getReg(CV_IA64_ApITC);
#endif
}

#define HalpReadITM()       __getReg(CV_IA64_ApITM)
#define HalpWriteITC(Value) __setReg(CV_IA64_ApITC, Value)
#define HalpWriteITM(Value) __setReg(CV_IA64_ApITM, Value)

//
// set itv control register
//

#define HalpWriteITVector(Vector)   __setReg(CV_IA64_SaITV, Vector)

//
// I/O Port space
//
// IoSpaceSize = 0x16 for 2 power 0x16 is 4Meg space size (ports 0x0000 - 0x1000)
//

#define IO_SPACE_SIZE 0x1A

//
// Present bit       =    1B to wire the space.
// Memory Attributes = 100B for UC Memory type
// Accessed Bit      =    1B to "enable" access without faulting.
// Dirty Bit         =    1B to "enable" write without faulting.
// Privilege Level   =   00B for kernel accesses
// Access Right      =  010B for read/write accesses
// Exception Deferral=    1B for Exception Deferral.
//                               Exceptions are deferred
//                           for speculative loads to pages with
//                               non-spec. mem. attributes anyway.
//
// Protection Key    =    0  for kernel mode
//

#define IO_SPACE_ATTRIBUTE TR_VALUE(1, 0, 3, 0, 1, 1, 4, 1)

#define HAL_READ_REGISTER_UCHAR(x)  \
    (__mf(), *(volatile UCHAR * const)(x))

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}


//
// Firmware interface
//

BOOLEAN HalpInitSalPalNonBsp();
VOID    InternalTestSal();

ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    );

ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Buffer
    );

//
// HALIA64 PROFILING definitions
//

//
// Thierry - FIXFIX - 03/04/2001 - _IA64_LOADERBLOCK_WITHOUT_PERFMON_INFO
//
// Temporary macro for the NT Perf Team, we need to handle the case
// of an osloader block not containing the perfmon info.
//
//
// #define _IA64_LOADERBLOCK_WITHOUT_PERFMON_INFO   1

VOID
HalpSetupProfilingPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitializeProfiling (
    ULONG Number
    );

ULONG_PTR
HalpSetProfileInterruptHandler(
    IN ULONG_PTR ProfileInterruptHandler
    );

VOID
HalpProfileInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

typedef
VOID
(*PHAL_PROFILE_INTERRUPT_HANDLER)(
    IN PKTRAP_FRAME TrapFrame
    );

NTSTATUS
HalpProfileSourceInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    );

NTSTATUS
HalSetProfileSourceInterval(
    IN KPROFILE_SOURCE  ProfileSource,
    IN OUT ULONG_PTR   *Interval
    );

//
// Performance Monitor Registers
//
// FIXFIX - Thierry 01/2000.
//
// The following functions are defined until the compiler supports
// the intrinsics __setReg() and __getReg() for the CV_IA64_PFCx,
// CV_IA64_PFDx and CV_IA64_SaPMV registers.
// Anyway, because of the micro-architecture differences,
// and because the implementation of intrinsics cannot handle all the
// micro-architecture differences, it seems useful to keep these
// functions around.
//

#if 0

#define HalpReadPerfMonVectorReg()      __getReg(CV_IA64_SaPMV)

#define HalpReadPerfMonCnfgReg0()       __getReg(CV_IA64_PFC0)
#define HalpReadPerfMonCnfgReg4()       __getReg(CV_IA64_PFC4)

#define HalpReadPerfMonDataReg0()       __getReg(CV_IA64_PFD0)
#define HalpReadPerfMonDataReg4()       __getReg(CV_IA64_PFD4)

#define HalpWritePerfMonDataReg0(Value) __setReg(CV_IA64_PFD0, Value)
#define HalpWritePerfMonDataReg4(Value) __setReg(CV_IA64_PFD4, Value)

#define HalpWritePerfMonCnfgReg0(Value) __setReg(CV_IA64_PFC0, Value)
#define HalpWritePerfMonCnfgReg4(Value) __setReg(CV_IA64_PFC4, Value)

#define HalpWritePerfMonVectorReg(Value) __setReg(CV_IA64_SaPMV,Value)

#else  // !0

VOID
HalpWritePerfMonVectorReg(
   ULONGLONG Value
   );

ULONGLONG
HalpReadPerfMonVectorReg(
   VOID
   );

VOID
HalpWritePerfMonCnfgReg(
   ULONG      Register,
   ULONGLONG  Value
   );

#define HalpWritePerfMonCnfgReg0(_Value) HalpWritePerfMonCnfgReg(0UL, _Value)
#define HalpWritePerfMonCnfgReg4(_Value) HalpWritePerfMonCnfgReg(4UL, _Value)

ULONGLONG
HalpReadPerfMonCnfgReg(
   ULONG      Register
   );

#define HalpReadPerfMonCnfgReg0() HalpReadPerfMonCnfgReg(0UL)
#define HalpReadPerfMonCnfgReg4() HalpReadPerfMonCnfgReg(4UL)

VOID
HalpWritePerfMonDataReg(
   ULONG      Register,
   ULONGLONG  Value
   );

#define HalpWritePerfMonDataReg0(_Value) HalpWritePerfMonDataReg(0UL, _Value)
#define HalpWritePerfMonDataReg4(_Value) HalpWritePerfMonDataReg(4UL, _Value)

ULONGLONG
HalpReadPerfMonDataReg(
   ULONG Register
   );

#define HalpReadPerfMonDataReg0() HalpReadPerfMonDataReg(0UL)
#define HalpReadPerfMonDataReg4() HalpReadPerfMonDataReg(4UL)

#endif // !0

VOID
HalpClearPerfMonCnfgOverflows(
    ULONGLONG Pmc0ClearStatusMask,
    ULONGLONG Pmc1ClearStatusMask,
    ULONGLONG Pmc2ClearStatusMask,
    ULONGLONG Pmc3ClearStatusMask
    );

VOID
HalpUnFreezeProfileCounting(
    VOID
    );

VOID
HalpFreezeProfileCounting(
    VOID
    );

//
// HALIA64 Private EFI definitions
//

EFI_STATUS
HalpCallEfi(
    IN ULONGLONG FunctionId,
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG Arg7,
    IN ULONGLONG Arg8
    );

ULONG
HalpReadGenAddr(
    IN  PGEN_ADDR   GenAddr
    );

VOID
HalpWriteGenAddr(
    IN  PGEN_ADDR   GenAddr,
    IN  ULONG       Value
    );

USHORT
HalpReadAcpiRegister(
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register
  );

VOID
HalpWriteAcpiRegister(
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register,
  IN USHORT        Value
  );

//
// Debugging support functions
//

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    );

//
// Functions related to platform properties as exposed by the IPPT
// table.
//

BOOLEAN
HalpIsInternalInterruptVector(
    IN ULONG SystemVector
    );

NTSTATUS
HalpReserveCrossPartitionInterruptVector (
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    IN OUT PKAFFINITY Affinity,
    OUT PUCHAR HardwareVector
    );

NTSTATUS
HalpSendCrossPartitionIpi(
    IN USHORT ProcessorID,
    IN UCHAR  HardwareVector
    );

NTSTATUS
HalpGetCrossPartitionIpiInterface(
    OUT HAL_CROSS_PARTITION_IPI_INTERFACE * IpiInterface
    );

NTSTATUS
HalpGetPlatformProperties(
    OUT PULONG Properties
    );

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

#endif // _HALP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64bios.c ===
/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1994  Microsoft Corporation

Module Name:

  i64bios.c  copied from hali64\x86bios.c

Abstract:


    This module implements the platform specific interface between a device
    driver and the execution of x86 ROM bios code for the device.

Author:

    William K. Cheung (wcheung) 20-Mar-1996

    based on the version by David N. Cutler (davec) 17-Jun-1994

Environment:

    Kernel mode only.

Revision History:
    Bernard Lint, M.Jayakumar November 1998

--*/

#include "halp.h"
#include "emulate.h"


#define LOW_MEM_SEGMET 0

#define LOW_MEM_OFFSET 0

#define SIZE_OF_VECTOR_TABLE 0x400

#define SIZE_OF_BIOS_DATA_AREA 0x400

extern XM_STATUS x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

extern PVOID x86BiosTranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    );

extern BOOLEAN  HalpVideoBiosPresent;
extern ULONG    HalpMaxPciBus;

ULONG
HalpBiosGetPciConfig(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpBiosSetPciConfig(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


//
// Initialize Default X86 bios spaces
//


#define NUMBER_X86_PAGES (0x100000 / PAGE_SIZE)      // map through 0xfffff

PVOID HalpIoControlBase = NULL;
PVOID HalpIoMemoryBase =  NULL;
PVOID HalpFrameBufferBase = NULL;
PVOID HalpLowMemoryBase = NULL;

#define VGA_FRAMEBUFFER_SIZE  (0xc0000 - 0xa0000)

//
// Define global data.
//

ULONG HalpX86BiosInitialized = FALSE;
ULONG HalpEnableInt10Calls = FALSE;


VOID
HalpInitIoMemoryBase(
    VOID
    )

/*++

Routine Description:
    This routine completes any mappings needed by the bios emulation engine. HalpEfiInitialization maps
    any EFI descriptor that cover the 1st MB of physical memory.  Those mappngs are done according to
    the cachable requirements in the descriptors. Most EFI implementations do not cover the VGA range so
    this function does that if it is not already mapped.

Arguements:

Return Value:

--*/
{
    PHYSICAL_ADDRESS COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS  = { 0xA0000 };


    if (HalpFrameBufferBase == NULL) {
        HalpFrameBufferBase = MmMapIoSpace (COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS,
                                            VGA_FRAMEBUFFER_SIZE,
                                            MmNonCached);

        ASSERT(HalpFrameBufferBase != NULL);

        //
        // Adjust to a zero base.
        //

        HalpFrameBufferBase = (PVOID)((ULONG64) HalpFrameBufferBase - 0XA0000);
    }

    ASSERT(HalpIoMemoryBase);

}


ULONG
HalpSetCmosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return 0;
}


ULONG
HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return 0;
}


VOID
HalpAcquireCmosSpinLock (
    VOID
        )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return;
}


VOID
HalpReleaseCmosSpinLock (
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return ;
}


HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    )

/*++

Routine Description:


Arguements:


Return Value:

--*/




{
    return HalpVideoBiosPresent ? HalDisplayEmulatedBios : HalDisplayNoBios;
}


VOID
HalpInitializeCmos (
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return ;
}


VOID
HalpReadCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return ;
}

VOID
HalpWriteCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return;
}



BOOLEAN
HalpBiosDisplayReset (
    VOID
    )

/*++

Routine Description:


Arguements:


Return Value:

--*/

{
    //
    // Make an int10 call to set the display into 640x480 16 color mode
    //
    // mov ax, 12h
    // int 10h
    //

    ULONG Eax = 0x12;
    ULONG Exx = 0x00;
    BOOLEAN Success;

    Success = HalCallBios(0x10,
                          &Eax,
                          &Exx,
                          &Exx,
                          &Exx,
                          &Exx,
                          &Exx,
                          &Exx);

    return Success;
}


BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    )

/*++

Routine Description:

    This function provides the platform specific interface between a device
    driver and the execution of the x86 ROM bios code for the specified ROM
    bios command.

Arguments:

    BiosCommand - Supplies the ROM bios command to be emulated.

    Eax to Ebp - Supplies the x86 emulation context.

Return Value:

    A value of TRUE is returned if the specified function is executed.
    Otherwise, a value of FALSE is returned.

--*/

{

    XM86_CONTEXT Context;

    HalDebugPrint(( HAL_INFO, "HAL: HalCallBios - Cmd = 0x%x, eax = 0x%p\n", BiosCommand, Eax ));
    //
    // If the x86 BIOS Emulator has not been initialized, then return FALSE.
    //

    if (HalpX86BiosInitialized == FALSE) {
        return FALSE;
    }

    //
    // If the Adapter BIOS initialization failed and an Int10 command is
    // specified, then return FALSE.
    //

    if ((BiosCommand == 0x10) && (HalpEnableInt10Calls == FALSE)) {
        return FALSE;
    }

    //
    // Copy the x86 bios context and emulate the specified command.
    //

    Context.Eax = *Eax;
    Context.Ebx = *Ebx;
    Context.Ecx = *Ecx;
    Context.Edx = *Edx;
    Context.Esi = *Esi;
    Context.Edi = *Edi;
    Context.Ebp = *Ebp;


    if (x86BiosExecuteInterruptShadowed((UCHAR)BiosCommand,
        &Context,
        (PVOID)HalpIoControlBase,
        (PVOID)HalpIoMemoryBase,
        (PVOID)HalpFrameBufferBase
        ) != XM_SUCCESS) {

        HalDebugPrint(( HAL_ERROR, "HAL: HalCallBios - ERROR in Cmd = 0x%x\n", BiosCommand ));
        return FALSE;

    }

    //
    // Copy the x86 bios context and return TRUE.
    //

    *Eax = Context.Eax;
    *Ebx = Context.Ebx;
    *Ecx = Context.Ecx;
    *Edx = Context.Edx;
    *Esi = Context.Esi;
    *Edi = Context.Edi;
    *Ebp = Context.Ebp;
    return TRUE;
}

VOID
HalpInitializeX86Int10Call(
    VOID
    )

/*++

Routine Description:

    This function initializes x86 bios emulator, display data area and
    interrupt vector area.


Arguments:

    None.

Return Value:

    None.

--*/

{
    XM86_CONTEXT State;
    PXM86_CONTEXT Context;
    PULONG x86BiosLowMemoryPtr, PhysicalMemoryPtr;

    if (HalpLowMemoryBase == NULL) {

        //
        // There is no memory at zero so there cannot be any bios.
        //

        return;
    }

    //
    // Initialize the x86 bios emulator.
    //


    x86BiosInitializeBiosShadowedPci(HalpIoControlBase,
                                     HalpIoMemoryBase,
                                     HalpFrameBufferBase,
                                     (UCHAR)(HalpMaxPciBus == 255 ? 255 : (HalpMaxPciBus + 1)),
                                     HalpBiosGetPciConfig,
                                     HalpBiosSetPciConfig
                                     );

    x86BiosLowMemoryPtr = (PULONG)(x86BiosTranslateAddress(LOW_MEM_SEGMET, LOW_MEM_OFFSET));
    PhysicalMemoryPtr   = (PULONG) HalpLowMemoryBase;

    //
    // Copy the VECTOR TABLE from 0 to 2k. This is because we are not executing
    // the initialization of Adapter since SAL takes care of it. However, the
    // emulation memory needs to be updated from the interrupt vector and BIOS
    // data area.
    //

    RtlCopyMemory(x86BiosLowMemoryPtr,
                  PhysicalMemoryPtr,
                  (SIZE_OF_VECTOR_TABLE+SIZE_OF_BIOS_DATA_AREA)
                  );

    HalpX86BiosInitialized = TRUE;

    //
    // Check to see if a video bios appears to be present and int10 vector
    // points somewhere inside of the video bios
    //
    {
        PUSHORT pBiosSignature = (PUSHORT)(x86BiosTranslateAddress(0xc000, // VIDEO_BIOS_SEGMENT
                                                                   0x0000));

        ULONG Address = *(PULONG)(x86BiosTranslateAddress(0x0, 0x40));
        Address = ((Address & 0xFFFF0000) >> 12) + (Address & 0xFFFF); // Normalize

        HalpEnableInt10Calls = (*pBiosSignature == 0xAA55) &&
                               (Address >= 0xC0000) && (Address < 0xD0000);
    }

    return;
}


VOID
HalpResetX86DisplayAdapter(
    VOID
    )

/*++

Routine Description:

    This function resets a display adapter using the x86 bios emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;

    //
    // Initialize the x86 bios context and make the INT 10 call to initialize
    // the display adapter to 80x25 color text mode.
    //

    Eax = 0x0003;  // Function 0, Mode 3
    Ebx = 0;
    Ecx = 0;
    Edx = 0;
    Esi = 0;
    Edi = 0;
    Ebp = 0;

    HalCallBios(0x10,
        &Eax,
        &Ebx,
        &Ecx,
        &Edx,
        &Esi,
        &Edi,
        &Ebp);
}

ULONG
HalpBiosGetPciConfig(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    This function wraps HalGetBusDataByOffset for use by the x86 emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return HalGetBusDataByOffset(PCIConfiguration,
                                 BusNumber,
                                 SlotNumber,
                                 Buffer,
                                 Offset,
                                 Length
                                 );
}

ULONG
HalpBiosSetPciConfig(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

    This function wraps HalGetBusDataByOffset for use by the x86 emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return HalSetBusDataByOffset(PCIConfiguration,
                                 BusNumber,
                                 SlotNumber,
                                 Buffer,
                                 Offset,
                                 Length
                                 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64cache.c ===
/*++

Module Name:

    i64cache.c

Abstract:

    Merced (IA64 processor) has level0 Instruction and Data cache. Level 1 is
    unified Cache. All the caches in level0 and level1 are writeback caches.
    Hardware ensures coherency in both instruction and data cache for DMA
    transfers.

    Level0 Instruction and Data caches are not coherent with respect to self
    modifying or cross modifying code. Also for PIO transfers hardware does not
    ensure coherency. Software has to ensure coherency for self or cross
    modifying code as well as PIO transfers.

Author:

    Bernard Lint
    M. Jayakumar  (Muthurajan.Jayakumar@intel.com)


Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "i64fw.h"

ULONG   CacheFlushStride = 64;  // Default value is the one for Itanium

VOID
HalpInitCacheInfo(
    ULONG   Stride
    )

/*++

Routine Description:

    This sets the stride used for FC instructions.

Arguments:

    Stride - New stride value.

Return Value:

    None.



--*/

{
    //
    // Perform a number of consistency checks on the argument.  If any of them
    // fail we will leave CacheFlushStride at the default.
    //
    // Since the source of this value is a PAL call done by the loader and
    // passed in the loader block we always stand the risk that the loader
    // will be out of date and we will get some garbage from uninitialized
    // memory.
    //

    //
    // The stride value must be a power of 2.
    //
    if ((Stride & (Stride - 1)) != 0) {

        return;
    }

    //
    // The Itanium architecture specifies a minimum of 32
    //
    if (Stride < 32) {

        return;
    }

    CacheFlushStride = Stride;
}

VOID
HalSweepIcache (
    )

/*++

Routine Description:

    This function sweeps the entire I cache on the processor which it runs.

Arguments:

    None.

Return Value:

    None.



NOTE: Anyone modifying the code for HalSweepIcache should note that
    HalSweepIcache CANNOT USE the FC instruction (or any routine that uses FC
    instruction, for example, HalSweepIcacheRange).

    This is because FC can generate page faults and if HalSweepIcache raises its
    IRQL (for avoiding context switch) then page faults will not be tolerated at
    a raied IRQL.
--*/

{

    //
    // Calls SAL_FLUSH to flush the single processor I cache on which it runs
    // and the platform cache, if any.
    // Calls PAL_FLUSH to flush only the processor I cache on which it runs.
    // PAL_FLUSH does not flush the platform cache.

    // The decision to choose PAL_FLUSH or SAL_FLUSH is made using a
    // interlockedCompareExchange to a semaphore.This allows only one processor
    // to call SAL_FLUSH and other processors to call PAL_FLUSH. This avoids
    // unnecessary overhead of flushing the platform cache multiple times.
    // The assumption in using InterlockedCompareExchange is that by the time
    // the CPU which grabs the semaphore comes out after doing the SAL_FLUSH,
    // all other CPUs at least have entered their PAL_FLUSH. If this assumption
    // is voilated, the platform cache will be flushed multiple times.
    // Functionally nothing fails.

    SAL_PAL_RETURN_VALUES rv = {0};

    HalpPalCall(PAL_CACHE_FLUSH, FLUSH_COHERENT,0,0,&rv);
}




VOID
HalSweepDcache (
    )

/*++

Routine Description:

    This function sweeps the entire D cache on ths processor which it runs.

    Arguments:

    None.

    Return Value:

    None.

    NOTE: Anyone modifying this code for HalSweepDcache should note that
    HalSweepDcache CANNOT USE FC instruction (or any routine that uses FC
    instruction,for example,HalSweepDcacheRange).
    This is because FC can generate page faults and if HalSweepDcache raises its
    IRQL (for avoiding context switch) then page faults will not be tolerated at
    a raied IRQL.

--*/

{

    //
    // Calls SAL_FLUSH to flush the single processor D cache on which it runs
    // and the platform cache, if any.
    // Calls PAL_FLUSH to flush only the processor D cache on which it runs.
    // PAL_FLUSH does not flush the platform cache.

    // The decision to choose PAL_FLUSH or SAL_FLUSH is made using a
    // interlockedCompareExchange to a semaphore.This allows only one processor
    // to call SAL_FLUSH and other processors to call PAL_FLUSH. This avoids
    // unnecessary overhead of flushing the platform cache multiple times.
    // The assumption in using InterlockedCompareExchange is that by the time
    // the CPU which grabs the semaphore comes out after doing the SAL_FLUSH,
    // all other CPUs at least have entered their PAL_FLUSH. If this assumption
    // is violated, the platform cache will be flushed multiple times.
    // Functionally nothing fails.
    //
    //

    SAL_PAL_RETURN_VALUES rv = {0};
    HalpSalCall(SAL_CACHE_FLUSH,FLUSH_DATA_CACHE,0,0,0,0,0,0,&rv);
}



VOID
HalSweepCacheRange (
     IN PVOID BaseAddress,
     IN SIZE_T Length
    )

/*++

Routine Description:
    This function sweeps the range of address in the I cache throughout the
    system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the data cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the data cache.


Return Value:

    None.


PS: HalSweepCacheRange just flushes the cache. It does not synchrnoize the
    I-Fetch pipeline with the flush operation. To Achieve pipeline flush also,
    one has to call KeSweepCacheRange.

--*/

{
    ULONGLONG SweepAddress, LastAddress;

    //
    // Do we need to prevent a context switch? No. We will allow context
    // switching in between fc.
    // Flush the specified range of virtual addresses from the primary
    // instruction cache.
    //

    //
    // Since Merced hardware aligns the address on cache line boundary for
    // flush cache instruction we don't have to align it ourselves.  However
    // the boundary cases are much easier to get right if we just align it.
    //

    SweepAddress = ((ULONGLONG)BaseAddress & ~((ULONGLONG)CacheFlushStride - 1));
    LastAddress = (ULONGLONG)BaseAddress + Length;

    do {

       __fc((__int64)SweepAddress);

       SweepAddress += CacheFlushStride;

    } while (SweepAddress < LastAddress);
}



VOID
HalSweepDcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    )

/*++

Routine Description:
    This function sweeps the range of address in the D cache throughout the
    system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the data cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the data cache.


Return Value:

    None.

PS: HalSweepCacheRange just flushes the cache. It does not synchrnoizes the
    I-Fetch pipeline with the flush operation. To Achieve pipeline flush also,
    one has to call KeSweepCacheRange.

--*/

{
    HalSweepCacheRange(BaseAddress,Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64dma.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64dma.c

Abstract:

    This module implements the DMA support routines for the HAL DLL.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"



VOID
HalFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    )

/*++

Routine Description:

    This function flushes the I/O buffer specified by the memory descriptor
    list from the data cache on the current processor.

Arguments:

    Mdl - Supplies a pointer to a memory descriptor list that describes the
        I/O buffer location.

    ReadOperation - Supplies a boolean value that determines whether the I/O
        operation is a read into memory.

    DmaOperation - Supplies a boolean value that determines whether the I/O
        operation is a DMA operation.

Return Value:

    None.

--*/

{
    //
    // 
    // In IA64 systems, DMA is coherent with Dcache and Icache.
    // In PIO, Dcache is coherent and Icache is NOT coherent.
    // Only on Page read using PIO Icache coherency is needed to be
    // maintained by software. So, HalFlushIoBuffer will flush the Icache
    // only on Page read using PIO.
    //
    //

    return;

}


ULONG
HalGetDmaAlignmentRequirement (
    VOID
    )

/*++

Routine Description:

    This function returns the alignment requirements for DMA transfers on
    host system.

Arguments:

    None.

Return Value:

    The DMA alignment requirement is returned as the fucntion value.

--*/

{

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64dat.c ===
/*       title  "IA64 Hal static data"
;++
;
; Copyright (c) 1998 Intel Corporation
;
; Module Name:
;
;   i64dat.c (derived from nthals\halx86\ixdat.c)
;
; Abstract:
;
;   Declares various INIT or pagable data
;
; Author:
;
;    Todd Kjos (v-tkjos) 5-Mar-1998
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "iosapic.h"


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

//
// The following data is only valid during system initialiation
// and the memory will be re-claimed by the system afterwards
//

ADDRESS_USAGE HalpDefaultPcIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
        0x000,  0x10,   // ISA DMA
        0x0C0,  0x10,   // ISA DMA
        0x080,  0x10,   // DMA

        0x020,  0x2,    // PIC
        0x0A0,  0x2,    // Cascaded PIC

        0x040,  0x4,    // Timer1, Referesh, Speaker, Control Word
        0x048,  0x4,    // Timer2, Failsafe

        0x092,  0x1,    // system control port A

        0x070,  0x2,    // Cmos/NMI enable
        0x0F0,  0x10,   // coprocessor ports
        0xCF8,  0x8,    // PCI Config Space Access Pair
        0,0
    }
};

//
// From usage.c
//

ADDRESS_USAGE  *HalpAddressUsageList;
IDTUsage        HalpIDTUsage[MAXIMUM_IDTVECTOR+1];

//
// Strings used for boot.ini options
// from mphal.c
//

UCHAR HalpSzBreak[]     = "BREAK";
UCHAR HalpSzOneCpu[]    = "ONECPU";
UCHAR HalpSzPciLock[]   = "PCILOCK";
UCHAR HalpSzTimerRes[]  = "TIMERES";
UCHAR HalpGenuineIntel[]= "GenuineIntel";
UCHAR HalpSzInterruptAffinity[]= "INTAFFINITY";
UCHAR HalpSzForceClusterMode[]= "MAXPROCSPERCLUSTER";

//
// Error messages
//

UCHAR  rgzNoMpsTable[]      = "HAL: No MPS Table Found\n";
UCHAR  rgzNoApic[]          = "HAL: No IO SAPIC Found\n";
UCHAR  rgzBadApicVersion[]  = "HAL: Bad SAPIC Version\n";
UCHAR  rgzApicNotVerified[] = "HAL: IO SAPIC not verified\n";
UCHAR  rgzRTCNotFound[]     = "HAL: No RTC device interrupt\n";


//
// From ixmca.c
//
UCHAR   MsgCMCPending[] = MSG_CMC_PENDING;
UCHAR   MsgCPEPending[] = MSG_CPE_PENDING;
WCHAR   rgzSessionManager[] = L"Session Manager";
WCHAR   rgzEnableMCA[] = L"EnableMCA";
WCHAR   rgzEnableCMC[] = L"EnableCMC";
WCHAR   rgzEnableCPE[] = L"EnableCPE";
WCHAR   rgzNoMCABugCheck[] = L"NoMCABugCheck";
WCHAR   rgzEnableMCEOemDrivers[] = L"EnableMCEOemDrivers";
WCHAR   rgzCMCThresholdCount[] = L"CMCThresholdCount";
WCHAR   rgzCMCThresholdTime[] = L"CMCThresholdSeconds";
WCHAR   rgzCPEThresholdCount[] = L"CPEThresholdCount";
WCHAR   rgzCPEThresholdTime[] = L"CPEThresholdSeconds";


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

ULONG HalpFeatureBits = HALP_FEATURE_INIT;


volatile BOOLEAN HalpHiberInProgress = FALSE;

//
// Stuff that we only need while we
// sleep or hibernate.
//

#ifdef notyet

MOTHERBOARD_CONTEXT HalpMotherboardState = {0};

#endif //notyet


//
// PAGELK handle
//
PVOID   HalpSleepPageLock = NULL;

USHORT  HalpPciIrqMask = 0;
USHORT  HalpEisaIrqIgnore = 0x1000;

PULONG_PTR *HalEOITable[HAL_MAXIMUM_PROCESSOR];

PROCESSOR_INFO HalpProcessorInfo[HAL_MAXIMUM_PROCESSOR];

//
// HAL private Mask of all of the active processors.
//
// The specific processors bits are based on their _KPCR.Number values.

KAFFINITY HalpActiveProcessors;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64clock.c ===
/*++

Module Name:

    i64clock.c

Abstract:

Author:

    Bernard Lint, M. Jayakumar
    Ron Mosgrove - Intel

Environment:

    Kernel mode

Revision History:

    Based on halmps/mpclockc.c


--*/

#include "halp.h"

extern ULONG HalpNextRate;
extern BOOLEAN HalpClockSetMSRate;
int _fltused;

BOOLEAN ReadPerfMonCounter = FALSE;
ULONG HalpCPUMHz;

#if defined(INSTRUMENT_CLOCK_DRIFT)
ULONGLONG HalpITMSkew;
ULONG     HalpCountBadITMValues;
ULONGLONG HalpMinITMMissed;
ULONGLONG HalpMaxITMMissed;

ULONG   HalpBreakMissedTickMin;
ULONG   HalpBreakMissedTickMax = ~0U;
BOOLEAN HalpResetITMDebug;
#endif

#if DBG
// Thierry - until compiler supports the generation of enum types in pdbs...
//          At that time, we will be able the use the enums instead of globals.
unsigned int HalpDpfltrMaxMask = HALIA64_DPFLTR_MAXMASK;

ULONG   HalpTimeOverflows;
#endif // DBG


ULONGLONG HalpITCFrequency = 500000000; // 500MHz for default real hardware power on.
ULONGLONG HalpProcessorFrequency = 500000000; // 500MHz CPU

//
// Ticks per 100ns used to compute ITM update count
//

double HalpITCTicksPer100ns;
ULONGLONG HalpClockCount;

//
// HalpSetNextClockInterrupt():
//  move to cr.itm latency (= 40 cycles) + 2 cycles from the itc read.
//

ULONGLONG HalpITMUpdateLatency = 42;

//
// HalpSetNextClockInterrupt() uses this as the minimum time before the next
// interrupt.  If the next interrupt would occur too soon then the next
// interrupt will be scheduled another HalpClockCount ITC ticks.
//

ULONGLONG HalpITMMinimumUpdate;
//
// All of these are in 100ns units
//

ULONGLONG   HalpCurrentTimeIncrement = DEFAULT_CLOCK_INTERVAL;
ULONGLONG   HalpNextTimeIncrement    = DEFAULT_CLOCK_INTERVAL;
ULONGLONG   HalpNewTimeIncrement     = DEFAULT_CLOCK_INTERVAL;

ULONGLONG // = (current ITC - previous ITM)
HalpSetNextClockInterrupt(
    ULONGLONG PreviousITM
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpSetInitialClockRate)
#pragma alloc_text(INIT,HalpInitializeTimerResolution)
#endif



VOID
HalpClearClock (
    )

/*++

Routine Description:

    Set clock to zero.

    Return Value:

    None.


--*/

{
    HalpWriteITC(0);
    HalpWriteITM(0);
    return;
}


VOID
HalpInitializeClock (
    VOID
    )

/*++

Routine Description:

    Initialize system time clock (ITC and ITM) to generate an interrupt
    at every 10 ms interval at ITC_CLOCK_VECTOR.

    Previously this routine initialize system time clock using 8254 timer1
    counter 0 to generate an interrupt at every 15ms interval at 8259 irq0.

    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
    needs to be changed.

    Arguments:

    None

    Return Value:

    None.


--*/

{
    HalpSetInitialClockRate();
    HalpClearClock();
    HalpWriteITM(PCR->HalReserved[CURRENT_ITM_VALUE_INDEX]);
    return;
}


VOID
HalpInitializeClockPn (
     VOID
     )

/*++

Routine Description:

     Assumes that only non-BSP processors call this routine.
     Initializes system time clock (ITC and ITM) to generate an interrupt
     at every 10 ms interval at ITC_CLOCK_VECTOR.

     Previously this routine initialize system time clock using 8254 timer1
     counter 0 to generate an interrupt at every 15ms interval at 8259 irq0.

     See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
     needs to be changed.

     Arguments:

     None

     Return Value:

     None.

--*/

{
    ULONGLONG itmValue;

    itmValue = (ULONGLONG)(HalpITCTicksPer100ns * MAXIMUM_CLOCK_INTERVAL);
    PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] = itmValue;
    HalpClearClock();
    HalpWriteITM( itmValue );
    return;
}


VOID
HalpSetInitialClockRate (
    VOID
    )

/*++

Routine Description:

    This function is called to set the initial clock interrupt rate
    Assumes that only the BSP processor calls this routine.

Arguments:

    None

Return Value:

    None

--*/

{

    //
    // CPU Frequency in MHz = ticks per second / 10 ** 6
    //

    HalpCPUMHz = (ULONG)((HalpProcessorFrequency + 500000) / 1000000);

    //
    // Ticks per 100ns = ticks per second / 10 ** 7
    //

    HalpITCTicksPer100ns = (double) HalpITCFrequency / (10000000.);
    if (HalpITCTicksPer100ns < 1) {
        HalpITCTicksPer100ns = 1;
    }
    HalpClockCount = (ULONGLONG)(HalpITCTicksPer100ns * MAXIMUM_CLOCK_INTERVAL);
    HalpITMMinimumUpdate = HalpClockCount >> 3;
    PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] = HalpClockCount;
    KeSetTimeIncrement(MAXIMUM_CLOCK_INTERVAL, MINIMUM_CLOCK_INTERVAL);

}



VOID
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Clock Interrupt Handler, for P0 processor only.

    N.B. Assumptions: Comes with IRQL set to CLOCK_LEVEL to disable
         interrupts.

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
    ULONGLONG currentITC;
    ULONGLONG currentITCDelta;
    ULONGLONG elapsedTimeIn100ns;
#if defined(INSTRUMENT_CLOCK_DRIFT)
    ULONGLONG currentITM, excessITM;
#endif
    ULONGLONG previousITM;
    LONG      mcaNotification;

    //
    // Check to see if a clock interrupt is generated in a small latency window
    // in HalpSetNextClockInterrupt.
    //

    if ((LONGLONG)(PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] - HalpReadITC()) > 0)
    {
        return;
    }

    //
    // PerfMon: Per P0 clock interrupt PMD4 collection.
    //

    if (ReadPerfMonCounter) {
       ULONGLONG currentPerfMonValue;

       currentPerfMonValue = HalpReadPerfMonDataReg4();
       HalDebugPrint(( HAL_INFO, "\nHAL: HalpClockInterrupt - PMD4=%I64x\n", currentPerfMonValue ));
    }

    //
    // Calculate the number of ticks that have gone by since the Interrupt
    // was supposed to fire.  If it is a small number of ticks we will do the
    // calculation in HalpSetNextClockInterrupt and avoid the multiply and
    // divide.
    //
    previousITM = (ULONGLONG)PCR->HalReserved[CURRENT_ITM_VALUE_INDEX];
    currentITC = HalpReadITC();

    if ((currentITC - previousITM) > (HalpClockCount << 2)) {

        currentITCDelta = (currentITC - previousITM) / HalpClockCount * HalpClockCount;
        previousITM += currentITCDelta;

    } else {

        currentITCDelta = 0;
    }

    //
    // Set next clock interrupt, based on ITC and
    // increment ITM, accounting for interrupt latency.
    //

    currentITCDelta += HalpSetNextClockInterrupt(previousITM);

#if defined(INSTRUMENT_CLOCK_DRIFT)
    //
    // Time the next interrupt is scheduled to occur
    //
    currentITM = (ULONGLONG)PCR->HalReserved[CURRENT_ITM_VALUE_INDEX];

    excessITM = (currentITM - previousITM) / HalpClockCount - 1;

    if (excessITM != 0) {
        if (HalpMinITMMissed == 0 || excessITM < HalpMinITMMissed)  {
            HalpMinITMMissed = excessITM;
        }
        if (excessITM > HalpMaxITMMissed) {
            HalpMaxITMMissed = excessITM;
        }

        HalpCountBadITMValues++;
        HalpITMSkew += excessITM;

        if (HalpBreakMissedTickMin != 0 &&
            HalpBreakMissedTickMin <= excessITM &&
            HalpBreakMissedTickMax >= excessITM &&
            !HalpResetITMDebug) {
            DbgBreakPoint();
        }
    }

    if (HalpResetITMDebug) {
        HalpResetITMDebug = FALSE;
        HalpCountBadITMValues = 0;
        HalpITMSkew = 0;
        HalpMinITMMissed = 0;
        HalpMaxITMMissed = 0;
    }
#endif

    //
    // Call the kernel to update system time.
    // P0 updates System time and Run Time.
    //

    elapsedTimeIn100ns = (ULONGLONG) (currentITCDelta/HalpITCTicksPer100ns);

    elapsedTimeIn100ns += HalpCurrentTimeIncrement;

    //
    // KeUpdateSystemTime takes a ULONG which is actually used as a LONG.  This
    // overflows after 214 seconds.  Since everytime we break into the debugger
    // that is exceeded we will cap it at something more reasonable.
    //
    if (elapsedTimeIn100ns > CLOCK_UPDATE_THRESHOLD) {

        elapsedTimeIn100ns = CLOCK_UPDATE_THRESHOLD;

#if DBG
        HalpTimeOverflows++;
#endif
    }

    KeUpdateSystemTime(TrapFrame, (ULONG)elapsedTimeIn100ns);

    HalpCurrentTimeIncrement = HalpNextTimeIncrement;
    HalpNextTimeIncrement    = HalpNewTimeIncrement;

    //
    // If MCA notification was requested by MCA Handler, execute it.
    //

    mcaNotification = InterlockedExchange( &HalpMcaInfo.DpcNotification, 0 );
    if ( mcaNotification )  {
        if ( HalpMcaInfo.KernelDelivery ) {
            if ( !HalpMcaInfo.KernelDelivery( HalpMcaInfo.KernelToken, McaAvailable, NULL ) ) {
                InterlockedIncrement( &HalpMcaInfo.Stats.KernelDeliveryFails );
            }
        }
        if ( HalpMcaInfo.DriverInfo.DpcCallback )   {
             if ( !KeInsertQueueDpc( &HalpMcaInfo.DriverDpc, NULL, NULL ) )  {
                 InterlockedIncrement( &HalpMcaInfo.Stats.DriverDpcQueueFails );
             }
        }
    }

    //
    // Poll for debugger breakin if enabled.
    //

    if ( KdDebuggerEnabled ) { 

       if ((PCR->PollSlot == PCR->Number) && KdPollBreakIn() )  {
           KeBreakinBreakpoint();
       }
       
       PCR->PollSlot++;

       if (PCR->PollSlot >= KeNumberProcessors) {
           PCR->PollSlot = 0;
       }
    }

} // HalpClockInterrupt()


VOID
HalpClockInterruptPn (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Clock Interrupt Handler, for processors other than P0.

    N.B. Assumptions: Comes with IRQL set to CLOCK_LEVEL to disable
         interrupts.

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
    ULONGLONG previousITM, currentITC;

    //
    // Calculate the number of ticks that have gone by since the Interrupt
    // was supposed to fire.  It is easier to do this in C than asm.
    //
    previousITM = (ULONGLONG)PCR->HalReserved[CURRENT_ITM_VALUE_INDEX];
    currentITC = HalpReadITC();

    if ((currentITC - previousITM) > (HalpClockCount << 2)) {

        previousITM += (currentITC - previousITM) / HalpClockCount * HalpClockCount;

    }

    //
    // Set next clock interrupt, based on ITC and
    // increment ITM, accounting for interrupt latency.
    //

    (void)HalpSetNextClockInterrupt(previousITM);

    //
    // Call the kernel to update run time.
    // Pn updates only Run time.
    //

    KeUpdateRunTime(TrapFrame);

    // IA64 MCA Notification - 09/18/2000 - WARNING
    // If faster MCA notification was required, the BSP MCA notification checking
    // should be placed here.
    //

    //
    // Poll for debugger breakin if enabled.
    //

    if ( KdDebuggerEnabled ) { 

       if ((PCR->PollSlot == PCR->Number) && KdPollBreakIn() )  {
           KeBreakinBreakpoint();
       }
       
       PCR->PollSlot++;

       if (PCR->PollSlot >= KeNumberProcessors) {
           PCR->PollSlot = 0;
       }
    }

} // HalpClockInterruptPn()



VOID
HalpInitializeClockInterrupts (
    VOID
    )

{
    PKPRCB Prcb;
    UCHAR InterruptVector;
    ULONGLONG ITVData;

    Prcb = PCR->Prcb;
    InterruptVector = CLOCK_LEVEL << VECTOR_IRQL_SHIFT;

    if (Prcb->Number == 0) {

        HalpSetInternalVector(InterruptVector, HalpClockInterrupt);

    } else {

        //
        // Non-BSP processor
        //

        HalpSetInternalVector(InterruptVector, HalpClockInterruptPn);

    }

    ITVData = (ULONGLONG) InterruptVector;

    HalpWriteITVector(ITVData);

    return;

}


ULONG
HalSetTimeIncrement (
    IN ULONG DesiredIncrement
    )

/*++

Routine Description:

    This function is called to set the clock interrupt rate to the frequency
    required by the specified time increment value.

    N.B. This function is only executed on the processor that keeps the
         system time. Previously this was called HalpSetTimeIncrement. We
         have renamed it HalSetTimeIncrement.


Arguments:

    DesiredIncrement - Supplies desired number of 100ns units between clock
        interrupts.

Return Value:

    The actual time increment in 100ns units.

--*/

{
    ULONGLONG NextIntervalCount;
    KIRQL     OldIrql;

    //
    // DesiredIncrement must map within the acceptable range.
    //

    if (DesiredIncrement < MINIMUM_CLOCK_INTERVAL)
        DesiredIncrement = MINIMUM_CLOCK_INTERVAL;
    else if (DesiredIncrement > MAXIMUM_CLOCK_INTERVAL)
        DesiredIncrement = MAXIMUM_CLOCK_INTERVAL;

    //
    // Raise IRQL to the highest level, set the new clock interrupt
    // parameters, lower IRQl, and return the new time increment value.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // Calculate the actual 64 bit time value which forms the target interval.
    // The resulting value is added to the ITC to form the new ITM value.
    // HalpITCTicksPer100ns is the calibrated value for the ITC whose value
    // works out to be 100ns (or as close as we can come).
    // Previously HalpITCTicksPer100ns was called as HalpPerformanceFrequency
    //

    NextIntervalCount = (ULONGLONG)(HalpITCTicksPer100ns * DesiredIncrement);

    //
    // Calculate the number of 100ns units to report to the kernel every
    // time the ITM matches the ITC with this new period.  Note, for small
    // values of DesiredIncrement (min being 10000, ie 1ms), truncation
    // in the above may result in a small decrement in the 5th decimal
    // place.  As we are effectively dealing with a 4 digit number, eg
    // 10000 becomes 9999.something, we really can't do any better than
    // the following.
    //

    HalpClockCount = NextIntervalCount;

    HalpNewTimeIncrement = DesiredIncrement;

    //
    // HalpClockSetMSRate   = TRUE;
    //

    KeLowerIrql(OldIrql);
    return DesiredIncrement;
}

NTSTATUS
HalpQueryFrequency(
    PULONGLONG ITCFrequency,
    PULONGLONG ProcessorFrequency
    )

/*++

Routine Description:

    This function is called to provide the ITC update rate.
    This value is computed by first getting the platform base frequency
    from the SAL_FREQ_BASE call. Then applying on the return value, the
    ITC ratios obtained from the PAL_FREQ_RATIOS call.

Arguments:

    None.

Return Value:

    ULONGLONG ITCFrequency - number of ITC updates per seconds

--*/

{

    ULONG     ITCRatioDenominator = 0;
    ULONG     ITCRatioNumerator   = 0;
    ULONG     ProcessorRatioDenominator = 0;
    ULONG     ProcessorRatioNumerator   = 0;

    SAL_PAL_RETURN_VALUES  SalReturn    = {0};
    SAL_PAL_RETURN_VALUES  PalReturn    = {0};

    SAL_STATUS  SalStatus;
    PAL_STATUS  PalStatus;

    SalStatus = HalpSalCall(SAL_FREQ_BASE,
        0 /* Platform base clock frequency is the clock input to the processor */,
        0,
        0,
        0,
        0,
        0,
        0,
        &SalReturn);
    if (SalStatus != 0) {
        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalInitSystem - Phase1 SAL_FREQ_BASE is returning error # %d\n",
                        SalStatus ));
        return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO, "HAL: HalInitSystem - Platform base clock Frequency is %I64u\n",SalReturn.ReturnValues[1] ));

    PalStatus = HalpPalCall( PAL_FREQ_RATIOS,
                             0,
                             0,
                             0,
                             &PalReturn);
    if (PalStatus != 0) {
        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalInitSystem - Phase1 PAL_FREQ_RATIOS is returning error # %d\n",
                        PalStatus ));
        return STATUS_UNSUCCESSFUL;
    }

    ProcessorRatioNumerator   = (ULONG)((PalReturn.ReturnValues[1]) >> 32);
    ProcessorRatioDenominator = (ULONG)( PalReturn.ReturnValues[1]);

    HalDebugPrint(( HAL_INFO,
                    "HAL: HalInitSystem - PAL returns Processor to Platform clock Frequency as %lu : %lu\n",
                    ProcessorRatioNumerator,
                    ProcessorRatioDenominator));

    *ProcessorFrequency = SalReturn.ReturnValues[1] * ProcessorRatioNumerator / ProcessorRatioDenominator;

    HalDebugPrint(( HAL_INFO,
                    "HAL: HalInitSystem - Processor clock Frequency is %I64u \n",
                    ProcessorFrequency ));

    ITCRatioNumerator   = (ULONG)((PalReturn.ReturnValues[3]) >> 32);
    ITCRatioDenominator = (ULONG)( PalReturn.ReturnValues[3]);

    HalDebugPrint(( HAL_INFO,
                    "HAL: HalInitSystem - PAL returns ITC to Platform clock Frequency as %lu : %lu\n",
                    ITCRatioNumerator,
                    ITCRatioDenominator));

    *ITCFrequency = SalReturn.ReturnValues[1] * ITCRatioNumerator / ITCRatioDenominator;

    HalDebugPrint(( HAL_INFO,
                    "HAL: HalInitSystem - ITC clock Frequency is %I64u \n",
                    ITCFrequency ));


    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64efi.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64efi.c

Abstract:

    This module implements the routines that transfer control
    from the kernel to the EFI code.

Author:

    Bernard Lint
    M. Jayakumar (Muthurajan.Jayakumar@hotmail.com)

Environment:

    Kernel mode

Revision History:

    Neal Vu (neal.vu@intel.com), 03-Apr-2001:
        Added HalpGetSmBiosVersion.


--*/

#include "halp.h"
#include "arc.h"
#include "arccodes.h"
#include "i64fw.h"
#include "floatem.h"
#include "fpswa.h"
#include <smbios.h>

extern ULONGLONG PhysicalIOBase;
extern ULONG     HalpPlatformPropertiesEfiFlags;

BOOLEAN
HalpCompareEfiGuid (
    IN EFI_GUID CheckGuid,
    IN EFI_GUID ReferenceGuid
    );


BOOLEAN
MmSetPageProtection(
    IN PVOID VirtualAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG NewProtect
    );

EFI_STATUS
HalpCallEfiPhysicalEx(
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG EP,
    IN ULONGLONG GP,
    IN ULONGLONG StackPointer,
    IN ULONGLONG BackingStorePointer
    );

typedef
EFI_STATUS
(*HALP_EFI_CALL)(
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG EP,
    IN ULONGLONG GP
    );

EFI_STATUS
HalpCallEfiPhysical(
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG EP,
    IN ULONGLONG GP
    );

EFI_STATUS
HalpCallEfiVirtual(
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG EP,
    IN ULONGLONG GP
    );

LONG
HalFpEmulate(
    ULONG     trap_type,
    BUNDLE    *pbundle,
    ULONGLONG *pipsr,
    ULONGLONG *pfpsr,
    ULONGLONG *pisr,
    ULONGLONG *ppreds,
    ULONGLONG *pifs,
    FP_STATE  *fp_state
    );

BOOLEAN
HalEFIFpSwa(
    VOID
    );

VOID
HalpFpswaPlabelFixup(
    EFI_MEMORY_DESCRIPTOR *EfiVirtualMemoryMapPtr,
    ULONGLONG MapEntries,
    ULONGLONG EfiDescriptorSize,
    PPLABEL_DESCRIPTOR PlabelPointer
    );

PUCHAR
HalpGetSmBiosVersion (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );


//
// External global data
//

extern HALP_SAL_PAL_DATA        HalpSalPalData;
extern ULONGLONG                HalpVirtPalProcPointer;
extern ULONGLONG                HalpSalProcPointer;
extern ULONGLONG                HalpSalProcGlobalPointer;
extern KSPIN_LOCK               HalpSalSpinLock;
extern KSPIN_LOCK               HalpSalStateInfoSpinLock;
extern KSPIN_LOCK               HalpMcaSpinLock;
extern KSPIN_LOCK               HalpInitSpinLock;
extern KSPIN_LOCK               HalpCmcSpinLock;
extern KSPIN_LOCK               HalpCpeSpinLock;

#define VENDOR_SPECIFIC_GUID    \
    { 0xa3c72e56, 0x4c35, 0x11d3, 0x8a, 0x03, 0x0, 0xa0, 0xc9, 0x06, 0xad, 0xec }


#define ConfigGuidOffset        0x100
#define ConfigTableOffset       0x200

#define VariableNameOffset      0x100
#define VendorGuidOffset        0x200
#define AttributeOffset         0x300
#define DataSizeOffset          0x400
#define DataBufferOffset        0x500
#define EndOfCommonDataOffset   0x600

//
// Read Variable and Write Variable will not be called till the copying out of
// Memory Descriptors is done. Because the lock is released before copying and we are using
// the same offset for read/write variable as well as memory layout calls.
//

#define MemoryMapSizeOffset     0x100
#define DescriptorSizeOffset    0x200
#define DescriptorVersionOffset 0x300
#define MemoryMapOffset         0x400


#define OptionROMAddress        0x100000

#define FP_EMUL_ERROR          -1

SST_MEMORY_LIST                 PalCode;

NTSTATUS                        EfiInitStatus = STATUS_UNSUCCESSFUL;

ULONGLONG                       PalTrMask;

EFI_GUID                        CheckGuid;
EFI_GUID                        SalGuid = SAL_SYSTEM_TABLE_GUID;

EFI_GUID                        VendorGuid;

PUCHAR                          HalpVendorGuidPhysPtr;
PUCHAR                          HalpVendorGuidVirtualPtr;

EFI_SYSTEM_TABLE                *EfiSysTableVirtualPtr;
EFI_SYSTEM_TABLE                *EfiSysTableVirtualPtrCpy;

EFI_RUNTIME_SERVICES            *EfiRSVirtualPtr;
EFI_BOOT_SERVICES               *EfiBootVirtualPtr;

PLABEL_DESCRIPTOR               *EfiVirtualGetVariablePtr;           // Get Variable
PLABEL_DESCRIPTOR               *EfiVirtualGetNextVariableNamePtr;   // Get NextVariable Name
PLABEL_DESCRIPTOR               *EfiVirtualSetVariablePtr;           // Set Variable
PLABEL_DESCRIPTOR               *EfiVirtualGetTimePtr;               // Get Time
PLABEL_DESCRIPTOR               *EfiVirtualSetTimePtr;               // Set Time

PLABEL_DESCRIPTOR               *EfiSetVirtualAddressMapPtr;         // Set Virtual Address Map

PLABEL_DESCRIPTOR               *EfiResetSystemPtr;                  // Reboot

PULONGLONG                      AttributePtr;
ULONGLONG                       EfiAttribute;

PULONGLONG                      DataSizePtr;
ULONGLONG                       EfiDataSize;

ULONGLONG                       EfiMemoryMapSize,EfiDescriptorSize,EfiMapEntries;

ULONG                           EfiDescriptorVersion;


PUCHAR                          HalpVirtualCommonDataPointer;

PUCHAR                          HalpPhysCommonDataPointer;

PUCHAR                          HalpVariableNamePhysPtr;

PUCHAR                          HalpVariableAttributesPhysPtr;
PUCHAR                          HalpDataSizePhysPtr;
PUCHAR                          HalpDataPhysPtr;

PUCHAR                          HalpMemoryMapSizePhysPtr;
PUCHAR                          HalpMemoryMapPhysPtr;
PUCHAR                          HalpDescriptorSizePhysPtr;
PUCHAR                          HalpDescriptorVersionPhysPtr;


PUCHAR                          HalpVariableNameVirtualPtr;

PUCHAR                          HalpVariableAttributesVirtualPtr;
PUCHAR                          HalpDataSizeVirtualPtr;
PUCHAR                          HalpDataVirtualPtr;
PUCHAR                          HalpCommonDataEndPtr;

PUCHAR                          HalpMemoryMapSizeVirtualPtr;
PVOID                           HalpMemoryMapVirtualPtr;
PUCHAR                          HalpDescriptorSizeVirtualPtr;
PUCHAR                          HalpDescriptorVersionVirtualPtr;

EFI_FPSWA                       HalpFpEmulate;

KSPIN_LOCK                      EFIMPLock;

UCHAR                           HalpSetVirtualAddressMapCount;

ULONG                           HalpOsBootRendezVector;


BOOLEAN
HalpCompareEfiGuid (
    IN EFI_GUID CheckGuid,
    IN EFI_GUID ReferenceGuid
    )

/*++






--*/

{
    USHORT i;
    USHORT TotalArrayLength = 8;

    if (CheckGuid.Data1 != ReferenceGuid.Data1) {
        return FALSE;

    } else if (CheckGuid.Data2 != ReferenceGuid.Data2) {
        return FALSE;
    } else if (CheckGuid.Data3 != ReferenceGuid.Data3) {
        return FALSE;
    }

    for (i = 0; i != TotalArrayLength; i++) {
        if (CheckGuid.Data4[i] != ReferenceGuid.Data4[i])
            return FALSE;

    }

    return TRUE;

} // HalpCompareEfiGuid()

BOOLEAN
HalpAllocateProcessorPhysicalCallStacks(
    VOID
    )

/*++

Routine Description:

    This function allocates per-processor memory and backstore stacks
    used by FW calls in physical mode.

Arguments:

    None.

Return Value:

    TRUE    : Allocation and Initialization were successful.
    FALSE   : Failure.

--*/

{
    PVOID Addr;
    SIZE_T Length;
    PHYSICAL_ADDRESS PhysicalAddr;

    //
    // Allocate stack and backing store space for physical mode firmware
    // calls.
    //

    Length = HALP_FW_MEMORY_STACK_SIZE + HALP_FW_BACKING_STORE_SIZE;
    PhysicalAddr.QuadPart = 0xffffffffffffffffI64;

    Addr = MmAllocateContiguousMemory(Length, PhysicalAddr);

    if (Addr == NULL) {
        HalDebugPrint((HAL_ERROR, "SAL_PAL: can't allocate stack space for "
                                  "physical mode firmware calls.\n"));
        return FALSE;
    }

    //
    // Store a pointer to the allocated stacks in the PCR.
    //

    PCR->HalReserved[PROCESSOR_PHYSICAL_FW_STACK_INDEX]
        = (ULONGLONG) (MmGetPhysicalAddress(Addr).QuadPart);

    return TRUE;

} // HalpAllocateProcessorPhysicalCallStacks()

VOID
HalpInitSalPalWorkArounds(
    VOID
    )
/*++

Routine Description:

    This function determines and initializes the FW workarounds.

Arguments:

    None.

Return Value:

    None.

Globals:

Notes: This function is being called at the end of HalpInitSalPal.
       It should not access SST members if this SAL table is unmapped.

--*/
{
    NTSTATUS status;
    extern FADT HalpFixedAcpiDescTable;

#define HalpIsIntelOEM() \
    ( !_strnicmp( HalpFixedAcpiDescTable.Header.OEMID, "INTEL", 5 ) )

#define HalpIsBigSur() \
    ( !strncmp( HalpFixedAcpiDescTable.Header.OEMTableID, "W460GXBS", 8 ) )

#define HalpIsLion() \
    ( !strncmp( HalpFixedAcpiDescTable.Header.OEMTableID, "SR460AC", 7 ) )

#define HalpIsIntelBigSur() \
    ( HalpIsIntelOEM() && HalpIsBigSur() )

    if ( HalpIsIntelOEM() ) {

        //
        // If Intel BigSur and FW build < 103 (checked as Pal_A_Revision < 0x20),
        // enable the SAL_GET_STATE_INFO log id increment workaround.
        //

        if ( HalpIsBigSur() )   {

            if ( HalpSalPalData.PalVersion.PAL_A_Revision < 0x20 ) {
                HalpSalPalData.Flags |= HALP_SALPAL_FIX_MCE_LOG_ID;
                HalpSalPalData.Flags |= HALP_SALPAL_FIX_MP_SAFE;
            }

        } else  {
            //
            // If Intel Lion and FW build < 78b (checked as SalRevision < 0x300),
            // enable the SAL_GET_STATE_INFO log id increment workaround.
            //
            if (  HalpSalPalData.SalRevision.Revision < 0x300 )    {
                HalpSalPalData.Flags |= HALP_SALPAL_FIX_MCE_LOG_ID;
                HalpSalPalData.Flags |= HALP_SALPAL_FIX_MP_SAFE;
            }

            //
            // If the PAL revision isn't greater than 6.23, don't allow
            // SAL_GET_STATE_INFO_CALLS
            //

            if ( HalpIsLion() ) {
                if ( ( HalpSalPalData.PalVersion.PAL_B_Model <= 0x66 ) &&
                     ( HalpSalPalData.PalVersion.PAL_B_Revision <= 0x23 ) ) {

                    HalpSalPalData.Flags |= HALP_SALPAL_CMC_BROKEN | HALP_SALPAL_CPE_BROKEN;
                }
            }
        }

    }
} // HalpInitSalPalWorkArounds()

NTSTATUS
HalpInitializePalTrInfo(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function builds an entry for the PAL in the LoaderBlock's
    DtrInfo and ItrInfo arrays.  This is split out into its own function
    so we can call it early and build the TR_INFO structure before
    phase 0 Mm initialization where it is used to build page tables
    for the PAL data.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block which
                  contains the DtrInfo and ItrInfo arrays.

Return Value:

    STATUS_SUCCESS is returned in all cases, no sanity checks are done
    at this point.

--*/

{
    PTR_INFO TrInfo;
    ULONG PalPageShift;
    ULONGLONG PalTrSize;
    ULONGLONG PalEnd;

    //
    // Zero out our data structures.
    //

    RtlZeroMemory(&HalpSalPalData, sizeof(HalpSalPalData));
    RtlZeroMemory(&PalCode, sizeof(SST_MEMORY_LIST));

    //
    // Describe the position of the PAL code for the rest of the
    // HAL.
    //

    PalCode.PhysicalAddress =
        (ULONGLONG) LoaderBlock->u.Ia64.Pal.PhysicalAddressMemoryDescriptor;
    PalCode.Length =
        LoaderBlock->u.Ia64.Pal.PageSizeMemoryDescriptor << EFI_PAGE_SHIFT;
    PalCode.NeedVaReg = TRUE;
    PalCode.VirtualAddress = (ULONGLONG) NULL;

    //
    // Compute the dimensions of the PAL TR.  This will be the smallest
    // block that is naturally aligned on an even power of 2 bytes.
    //

    PalTrSize = SIZE_IN_BYTES_16KB;
    PalTrMask = MASK_16KB;
    PalPageShift = 14;

    PalEnd = PalCode.PhysicalAddress + PalCode.Length;

    //
    // We don't support PAL TRs larger than 16MB, so stop looping if
    // we get to that point.
    //

    while (PalTrMask >= MASK_16MB) {
        //
        // Stop looping if the entire PAL fits within the current
        // TR boundaries.
        //

        if (PalEnd <= ((PalCode.PhysicalAddress & PalTrMask) + PalTrSize)) {
            break;
        }

        //
        // Bump the TR dimensions one level larger.
        //

        PalTrMask <<= 2;
        PalTrSize <<= 2;
        PalPageShift += 2;
    }

    //
    // Store a few values for later consumption elsewhere in the HAL.
    //

    HalpSalPalData.PalTrSize = PalTrSize;
    HalpSalPalData.PalTrBase = PalCode.PhysicalAddress & PalTrMask;

    //
    // Fill in the ItrInfo entry for the PAL.
    //

    TrInfo = &LoaderBlock->u.Ia64.ItrInfo[ITR_PAL_INDEX];

    RtlZeroMemory(TrInfo, sizeof(*TrInfo));

    TrInfo->Index = ITR_PAL_INDEX;
    TrInfo->PageSize = PalPageShift;
    TrInfo->VirtualAddress = HAL_PAL_VIRTUAL_ADDRESS;
    TrInfo->PhysicalAddress = PalCode.PhysicalAddress;

    //
    // Fill in the DtrInfo entry for the PAL.
    //

    TrInfo = &LoaderBlock->u.Ia64.DtrInfo[DTR_PAL_INDEX];

    RtlZeroMemory(TrInfo, sizeof(*TrInfo));

    TrInfo->Index = DTR_PAL_INDEX;
    TrInfo->PageSize = PalPageShift;
    TrInfo->VirtualAddress = HAL_PAL_VIRTUAL_ADDRESS;
    TrInfo->PhysicalAddress = PalCode.PhysicalAddress;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpDoInitializationForPalCalls(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This function virtually maps the PAL code area.

    PAL requires a TR mapping, and is mapped using an architected TR, using the
    smallest page size to map the entire PAL code region.

Arguments:

    LoaderBlock - Supplies a pointer to the Loader parameter block, containing the
    physical address of the PAL code.

Return Value:

    STATUS_SUCCESS is returned if the mapping was successful, and PAL calls can
    be made.  Otherwise, STATUS_UNSUCCESSFUL is returned if it cannot virtually map
    the areas or if PAL requires a page larger than 16MB.

--*/

{
    ULONGLONG PalPteUlong;

    HalpSalPalData.Status = STATUS_SUCCESS;

    //
    // Initialize the HAL private spinlocks
    //
    //  - HalpSalSpinLock, HalpSalStateInfoSpinLock are used for MP synchronization of the
    //    SAL calls that are not MP-safe.
    //  - HalpMcaSpinLock is used for defining an MCA monarch and MP synchrnonization of shared
    //    HAL MCA resources during OS_MCA calls.
    //

    KeInitializeSpinLock(&HalpSalSpinLock);
    KeInitializeSpinLock(&HalpSalStateInfoSpinLock);
    KeInitializeSpinLock(&HalpMcaSpinLock);
    KeInitializeSpinLock(&HalpInitSpinLock);
    KeInitializeSpinLock(&HalpCmcSpinLock);
    KeInitializeSpinLock(&HalpCpeSpinLock);

    //
    // Get the wakeup vector.  This is passed in the loader block
    // it is retrieved in the loader by reading the sal system table.
    //
    HalpOsBootRendezVector = LoaderBlock->u.Ia64.WakeupVector;
    if ((HalpOsBootRendezVector < 0x100 ) && (HalpOsBootRendezVector > 0xF)) {
        HalDebugPrint(( HAL_INFO, "SAL_PAL: Found Valid WakeupVector: 0x%x\n",
                                  HalpOsBootRendezVector ));
    } else {
        HalDebugPrint(( HAL_INFO, "SAL_PAL: Invalid WakeupVector.Using Default: 0x%x\n",
                                  DEFAULT_OS_RENDEZ_VECTOR ));
        HalpOsBootRendezVector = DEFAULT_OS_RENDEZ_VECTOR;
    }

    //
    // If PAL requires a page size of larger than 16MB, fail.
    //

    if (PalTrMask < MASK_16MB) {
        HalDebugPrint(( HAL_ERROR, "SAL_PAL: More than 16MB was required to map PAL" ));
        HalpSalPalData.Status = STATUS_UNSUCCESSFUL;
        return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO,
                    "SAL_PAL: For the PAL code located at phys 0x%I64x - length 0x%I64x, the TrMask is 0x%I64x and TrSize is %d Kbytes\n",
                    PalCode.PhysicalAddress,
                    PalCode.Length,
                    PalTrMask,
                    HalpSalPalData.PalTrSize/1024 ));

    //
    // Map the PAL code at a architected address reserved for SAL/PAL
    //
    // PAL is known to have an alignment of 256KB.
    //

    PalCode.VirtualAddress = HAL_PAL_VIRTUAL_ADDRESS + (PalCode.PhysicalAddress & ~PalTrMask);
    ASSERT( PalCode.VirtualAddress == LoaderBlock->u.Ia64.Pal.VirtualAddress);

    //
    // Setup the ITR to map PAL
    //

    PalPteUlong = HalpSalPalData.PalTrBase | VALID_KERNEL_EXECUTE_PTE;

    KeFillFixedEntryTb((PHARDWARE_PTE)&PalPteUlong,
                       (PVOID)HAL_PAL_VIRTUAL_ADDRESS,
                       LoaderBlock->u.Ia64.ItrInfo[ITR_PAL_INDEX].PageSize,
                       INST_TB_PAL_INDEX);

    LoaderBlock->u.Ia64.ItrInfo[ITR_PAL_INDEX].Valid = TRUE;

    HalpSalPalData.Status = STATUS_SUCCESS;

    HalpVirtPalProcPointer    = PalCode.VirtualAddress +
                            (LoaderBlock->u.Ia64.Pal.PhysicalAddress - PalCode.PhysicalAddress);

    return(STATUS_SUCCESS);

}


NTSTATUS
HalpInitSalPal(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function virtually maps the SAL code and SAL data areas.  If SAL data
    or SAL code areas can be mapped in the same page as the PAL TR, it uses the
    same translation.  Otherwise, it uses MmMapIoSpace.

Arguments:

    LoaderBlock - Supplies a pointer to the Loader parameter block.

Return Value:

    STATUS_SUCCESS is returned if the mappings were successful, and SAL/PAL calls can
    be made.  Otherwise, STATUS_UNSUCCESSFUL is returned if it cannot virtually map
    the areas.


Assumptions: The EfiSysTableVirtualPtr is initialized prior by EfiInitialization.

--*/

{
    //
    // Local declarations
    //

    ULONG index,i,SstLength;
    SAL_PAL_RETURN_VALUES RetVals;
    PHYSICAL_ADDRESS physicalAddr;
    SAL_STATUS SALstatus;
    BOOLEAN MmMappedSalCode, MmMappedSalData;
    ULONGLONG physicalSAL, physicalSALGP;
    ULONGLONG PhysicalConfigPtr;
    ULONGLONG SalOffset;
    //SST_MEMORY_LIST SalCode,SalData;
    PAL_VERSION_STRUCT minimumPalVersion;

    ULONGLONG palStatus;

    HalDebugPrint(( HAL_INFO, "SAL_PAL: Entering HalpInitSalPal\n" ));

    //
    // initialize the system for making PAL calls
    //
    HalpDoInitializationForPalCalls(LoaderBlock);

    //
    // Get the PAL version.
    //

    palStatus = HalCallPal(PAL_VERSION,
                           0,
                           0,
                           0,
                           NULL,
                           &minimumPalVersion.ReturnValue,
                           &HalpSalPalData.PalVersion.ReturnValue,
                           NULL);

    if (palStatus != SAL_STATUS_SUCCESS) {
        HalDebugPrint(( HAL_ERROR, "SAL_PAL: Get PAL version number failed. Status = %I64d\n", palStatus ));
    }

    //
    // Retrieve SmBiosVersion and save the pointer into HalpSalPalData.  Note:
    // HalpGetSmBiosVersion will allocate a buffer for SmBiosVersion.
    //

    HalpSalPalData.SmBiosVersion = HalpGetSmBiosVersion(LoaderBlock);

    //
    // Determine and Initialize HAL private SAL/PAL WorkArounds if any.
    //

    HalpInitSalPalWorkArounds();

    // We completed initialization

    HalDebugPrint(( HAL_INFO, "SAL_PAL: Exiting HalpSalPalInitialization with SUCCESS\n" ));
    return HalpSalPalData.Status;

} // HalpInitSalPal()


PUCHAR
HalpGetSmBiosVersion (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function retrieves the SmBiosVersion string from the BIOS structure
    table, allocates memory for the buffer, copies the string to the buffer,
    and returns a pointer to this buffer.  If unsuccessful, this function
    returns a NULL.

Arguments:

    LoaderBlock - Pointer to the loader parameter block.


Return Value:

    Pointer to a buffer that contains SmBiosVersion string.

--*/

{
    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    PDMIBIOS_EPS_HEADER DMIBiosEPSHeader;
    USHORT SMBiosTableLength;
    USHORT SMBiosTableNumberStructures;
    PUCHAR SmBiosVersion;

    PHYSICAL_ADDRESS SMBiosTablePhysicalAddress;
    PUCHAR SMBiosDataVirtualAddress;

    UCHAR Type;
    UCHAR Length;
    UCHAR BiosVersionStringNumber;
    UCHAR chr;
    USHORT i;
    PUCHAR pBuffer;
    BOOLEAN Found;


    if (LoaderBlock->Extension->Size < sizeof(LOADER_PARAMETER_EXTENSION)) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Invalid LoaderBlock extension size\n"));
        return NULL;
    }

    SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)LoaderBlock->Extension->SMBiosEPSHeader;

    //
    // Verify SM Bios Header signature
    //

    if ((SMBiosEPSHeader == NULL) || (strncmp((PUCHAR)SMBiosEPSHeader, "_SM_", 4) != 0)) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Invalid SMBiosEPSHeader\n"));
        return NULL;
    }

    DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader->Signature2[0];

    //
    // Verify DMI Bios Header signature
    //

    if ((DMIBiosEPSHeader == NULL) || (strncmp((PUCHAR)DMIBiosEPSHeader, "_DMI_", 5) != 0)) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Invalid DMIBiosEPSHeader\n"));
        return NULL;
    }

    SMBiosTablePhysicalAddress.HighPart = 0;
    SMBiosTablePhysicalAddress.LowPart = DMIBiosEPSHeader->StructureTableAddress;

    SMBiosTableLength = DMIBiosEPSHeader->StructureTableLength;
    SMBiosTableNumberStructures = DMIBiosEPSHeader->NumberStructures;

    //
    // Map SMBiosTable to virtual address
    //

    SMBiosDataVirtualAddress = MmMapIoSpace(SMBiosTablePhysicalAddress,
                                            SMBiosTableLength,
                                            MmCached
                                            );

    if (!SMBiosDataVirtualAddress) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Failed to map SMBiosTablePhysicalAddress\n"));
        return NULL;
    }

    //
    // The Spec doesn't say that SmBios Type 0 structure has to be the first
    // structure at this entry point... so we have to traverse through memory
    // to find the right one.
    //

    i = 0;
    Found = FALSE;
    while (i < SMBiosTableNumberStructures && !Found) {
        i++;
        Type = (UCHAR)SMBiosDataVirtualAddress[SMBIOS_STRUCT_HEADER_TYPE_FIELD];

        if (Type == 0) {
            Found = TRUE;
        }
        else {

            //
            // Advance to the next structure
            //

            SMBiosDataVirtualAddress += SMBiosDataVirtualAddress[SMBIOS_STRUCT_HEADER_LENGTH_FIELD];

            // Get pass trailing string-list by looking for a double-null
            while (*(USHORT UNALIGNED *)SMBiosDataVirtualAddress != 0) {
                SMBiosDataVirtualAddress++;
            }
            SMBiosDataVirtualAddress += 2;
        }
    }

    if (!Found) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Could not find Type 0 structure\n"));
        return NULL;
    }


    //
    // Extract BIOS Version string from the SmBios Type 0 Structure
    //

    Length = SMBiosDataVirtualAddress[SMBIOS_STRUCT_HEADER_LENGTH_FIELD];
    BiosVersionStringNumber = SMBiosDataVirtualAddress[SMBIOS_TYPE0_STRUCT_BIOSVER_FIELD];

    //
    // Text strings begin right after the formatted portion of the structure.
    //

    pBuffer = (PUCHAR)&SMBiosDataVirtualAddress[Length];

    //
    // Get to the beginning of SmBiosVersion string
    //

    for (i = 0; i < BiosVersionStringNumber - 1; i++) {
        do {
            chr = *pBuffer;
            pBuffer++;
        } while (chr != '\0');
    }

    //
    // Allocate memory for SmBiosVersion string and copy content of
    // pBuffer to SmBiosVersion.
    //

    SmBiosVersion = ExAllocatePool(NonPagedPool, strlen(pBuffer)+1);

    if (!SmBiosVersion) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Failed to allocate memory for SmBiosVersion\n"));
        return NULL;
    }

    strcpy(SmBiosVersion, pBuffer);

    MmUnmapIoSpace(SMBiosDataVirtualAddress,
                   SMBiosTableLength
                   );

    return SmBiosVersion;
}


BOOLEAN
HalpInitSalPalNonBsp(
    VOID
    )

/*++

Routine Description:

    This function is called for the non-BSP processors to simply set up the same
    TR registers that HalpInitSalPal does for the BSP processor.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG PalPageShift;
    ULONGLONG PalPteUlong;
    ULONGLONG PalTrSize;

    // If we successfully initialized in HalpSalPalInitialization, then set-up the TR

    if (!NT_SUCCESS(HalpSalPalData.Status)) {
        return FALSE;
    }

    PalTrSize = HalpSalPalData.PalTrSize;
    PalPageShift = 14;

    while (PalTrSize > ((ULONGLONG)1 << PalPageShift)) {
        PalPageShift += 2;
    }

    PalPteUlong = HalpSalPalData.PalTrBase | VALID_KERNEL_EXECUTE_PTE;

    KeFillFixedEntryTb((PHARDWARE_PTE)&PalPteUlong,
                       (PVOID)HAL_PAL_VIRTUAL_ADDRESS,
                       PalPageShift,
                       INST_TB_PAL_INDEX);

    //
    // Allocate the stacks needed to allow physical mode firmware calls
    // on this processor.
    //

    return HalpAllocateProcessorPhysicalCallStacks();

} // HalpInitSalPalNonBsp()

VOID
PrintEfiMemoryDescriptor(
    IN EFI_MEMORY_DESCRIPTOR * descriptor
    )
{
    char * typeStr = "<unknown>";

    switch (descriptor->Type) {
        case EfiReservedMemoryType: typeStr = "EfiReservedMemoryType"; break;
        case EfiLoaderCode: typeStr = "EfiLoaderCode"; break;
        case EfiLoaderData: typeStr = "EfiLoaderData"; break;
        case EfiBootServicesCode: typeStr = "EfiBootServicesCode"; break;
        case EfiBootServicesData: typeStr = "EfiBootServicesData"; break;
        case EfiRuntimeServicesCode: typeStr = "EfiRuntimeServicesCode"; break;
        case EfiRuntimeServicesData: typeStr = "EfiRuntimeServicesData"; break;
        case EfiConventionalMemory: typeStr = "EfiConventionalMemory"; break;
        case EfiUnusableMemory: typeStr = "EfiUnusableMemory"; break;
        case EfiACPIReclaimMemory: typeStr = "EfiACPIReclaimMemory"; break;
        case EfiACPIMemoryNVS: typeStr = "EfiACPIMemoryNVS"; break;
        case EfiMemoryMappedIO: typeStr = "EfiMemoryMappedIO"; break;
        case EfiMemoryMappedIOPortSpace: typeStr = "EfiMemoryMappedIOPortSpace"; break;
        case EfiPalCode: typeStr = "EfiPalCode"; break;
        case EfiMaxMemoryType: typeStr = "EfiMaxMemoryType"; break;
    }

    DbgPrint("  Type=%s(0x%x)\n    PhysicalStart=0x%I64x\n    VirtualStart=0x%I64x\n    NumberOfPages=0x%I64x\n    Attribute=0x%I64x\n",
             typeStr,
             descriptor->Type,
             descriptor->PhysicalStart,
             descriptor->VirtualStart,
             descriptor->NumberOfPages,
             descriptor->Attribute);
}

VOID
PrintEfiMemoryMap(
    IN EFI_MEMORY_DESCRIPTOR * memoryMapPtr,
    IN ULONGLONG numMapEntries
    )
{
    ULONGLONG index;

    DbgPrint("Printing 0x%x EFI memory descriptors\n", numMapEntries);

    for (index = 0; index < numMapEntries; ++index) {
        PrintEfiMemoryDescriptor(memoryMapPtr);
        DbgPrint("\n");

        memoryMapPtr = NextMemoryDescriptor(memoryMapPtr, EfiDescriptorSize);
    }
}

BOOLEAN
HalpDescriptorContainsAddress(
    EFI_MEMORY_DESCRIPTOR *EfiMd,
    ULONGLONG PhysicalAddress
    )
{
    ULONGLONG MdPhysicalStart, MdPhysicalEnd;

    MdPhysicalStart = (ULONGLONG)EfiMd->PhysicalStart;
    MdPhysicalEnd = MdPhysicalStart + (ULONGLONG)(EfiMd->NumberOfPages << EFI_PAGE_SHIFT);

    if ((PhysicalAddress >= MdPhysicalStart) &&
        (PhysicalAddress < MdPhysicalEnd)) {
        return(TRUE);
    }

    return(FALSE);

}


NTSTATUS
HalpEfiInitialization(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function

Arguments:

    LoaderBlock - Supplies a pointer to the Loader parameter block, containing the
    physical address of the EFI system table.

Return Value:

    STATUS_SUCCESS is returned if the mappings were successful, and EFI calls can
    be made.  Otherwise, STATUS_UNSUCCESSFUL is returned.


--*/

{

//
// Local declarations
//

    EFI_MEMORY_DESCRIPTOR *efiMapEntryPtr, *efiVirtualMemoryMapPtr;
    EFI_STATUS             status;
    ULONGLONG              index, mapEntries;

    ULONGLONG physicalEfiST, physicalEfiMemoryMapPtr, physicalRunTimeServicesPtr;
    ULONGLONG physicalEfiGetVariable, physicalEfiGetNextVariableName, physicalEfiSetVariable;
    ULONGLONG physicalEfiGetTime, physicalEfiSetTime;
    ULONGLONG physicalEfiSetVirtualAddressMap, physicalEfiResetSystem;

    PHYSICAL_ADDRESS  physicalAddr;

    ULONGLONG         physicalPlabel_Fpswa;

    FPSWA_INTERFACE  *interfacePtr;
    PVOID             tmpPtr;

    SST_MEMORY_LIST SalCode, SalData, SalDataGPOffset;
    ULONGLONG       SalOffset = 0, SalDataOffset = 0;

    MEMORY_CACHING_TYPE cacheType;

    RtlZeroMemory(&SalCode, sizeof(SST_MEMORY_LIST));
    RtlZeroMemory(&SalData, sizeof(SST_MEMORY_LIST));
    RtlZeroMemory(&SalDataGPOffset, sizeof(SST_MEMORY_LIST));

    //
    // get the sal code, and data filled in with data from the loader block.
    //
    SalCode.PhysicalAddress = LoaderBlock->u.Ia64.Sal.PhysicalAddress;
    SalData.PhysicalAddress = LoaderBlock->u.Ia64.SalGP.PhysicalAddress;

    SalDataGPOffset.PhysicalAddress = SalData.PhysicalAddress - (2 * 0x100000);

    //
    // First, get the physical address of the fpswa entry point PLABEL.
    //
    if (LoaderBlock->u.Ia64.FpswaInterface != (ULONG_PTR) NULL) {
        physicalAddr.QuadPart = LoaderBlock->u.Ia64.FpswaInterface;
        interfacePtr = MmMapIoSpace(physicalAddr,
                                    sizeof(FPSWA_INTERFACE),
                                    MmCached
                                   );

        if (interfacePtr == NULL) {
            HalDebugPrint(( HAL_FATAL_ERROR, "FpswaInterfacePtr is Null. Efi handle not available\n"));
            KeBugCheckEx(FP_EMULATION_ERROR, 0, 0, 0, 0);
            return STATUS_UNSUCCESSFUL;
        }

        physicalPlabel_Fpswa = (ULONGLONG)(interfacePtr->Fpswa);
    }
    else {
        HalDebugPrint(( HAL_FATAL_ERROR, "HAL: EFI FpswaInterface is not available\n"));
        KeBugCheckEx(FP_EMULATION_ERROR, 0, 0, 0, 0);
        return STATUS_UNSUCCESSFUL;
    }

    physicalEfiST =  LoaderBlock->u.Ia64.EfiSystemTable;

    physicalAddr.QuadPart = physicalEfiST;

    EfiSysTableVirtualPtr = MmMapIoSpace( physicalAddr, sizeof(EFI_SYSTEM_TABLE), MmCached);

    if (EfiSysTableVirtualPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiSystem Table Virtual Addr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;

    }

    EfiSysTableVirtualPtrCpy = EfiSysTableVirtualPtr;

    physicalRunTimeServicesPtr = (ULONGLONG) EfiSysTableVirtualPtr->RuntimeServices;
    physicalAddr.QuadPart = physicalRunTimeServicesPtr;

    EfiRSVirtualPtr       = MmMapIoSpace(physicalAddr, sizeof(EFI_RUNTIME_SERVICES),MmCached);

    if (EfiRSVirtualPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: Run Time Table Virtual Addr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    EfiMemoryMapSize         = LoaderBlock->u.Ia64.EfiMemMapParam.MemoryMapSize;

    EfiDescriptorSize        = LoaderBlock->u.Ia64.EfiMemMapParam.DescriptorSize;

    EfiDescriptorVersion     = LoaderBlock->u.Ia64.EfiMemMapParam.DescriptorVersion;


    physicalEfiMemoryMapPtr = (ULONGLONG)LoaderBlock->u.Ia64.EfiMemMapParam.MemoryMap;
    physicalAddr.QuadPart   = physicalEfiMemoryMapPtr;
    efiVirtualMemoryMapPtr  = MmMapIoSpace (physicalAddr, EfiMemoryMapSize, MmCached);

    if (efiVirtualMemoryMapPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: Virtual Set Memory Map Virtual Addr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }

    //
    // #define VENDOR_SPECIFIC_GUID    \
    // { 0xa3c72e56, 0x4c35, 0x11d3, 0x8a, 0x03, 0x0, 0xa0, 0xc9, 0x06, 0xad, 0xec }
    //

    VendorGuid.Data1    =  0x8be4df61;
    VendorGuid.Data2    =  0x93ca;
    VendorGuid.Data3    =  0x11d2;
    VendorGuid.Data4[0] =  0xaa;
    VendorGuid.Data4[1] =  0x0d;
    VendorGuid.Data4[2] =  0x00;
    VendorGuid.Data4[3] =  0xe0;
    VendorGuid.Data4[4] =  0x98;
    VendorGuid.Data4[5] =  0x03;
    VendorGuid.Data4[6] =  0x2b;
    VendorGuid.Data4[7] =  0x8c;

    HalDebugPrint(( HAL_INFO,
                    "HAL: EFI SystemTable     VA = 0x%I64x, PA = 0x%I64x\n"
                    "HAL: EFI RunTimeServices VA = 0x%I64x, PA = 0x%I64x\n"
                    "HAL: EFI MemoryMapPtr    VA = 0x%I64x, PA = 0x%I64x\n"
                    "HAL: EFI MemoryMap     Size = 0x%I64x\n"
                    "HAL: EFI Descriptor    Size = 0x%I64x\n",
                    EfiSysTableVirtualPtr,
                    physicalEfiST,
                    EfiRSVirtualPtr,
                    physicalRunTimeServicesPtr,
                    efiVirtualMemoryMapPtr,
                    physicalEfiMemoryMapPtr,
                    EfiMemoryMapSize,
                    EfiDescriptorSize
                    ));

    // GetVariable

    physicalEfiGetVariable = (ULONGLONG) (EfiRSVirtualPtr -> GetVariable);
    physicalAddr.QuadPart  = physicalEfiGetVariable;

    EfiVirtualGetVariablePtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);

    if (EfiVirtualGetVariablePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiGetVariable Virtual Addr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO, "HAL: EFI GetVariable     VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiVirtualGetVariablePtr, physicalEfiGetVariable ));

    // GetNextVariableName

    physicalEfiGetNextVariableName =  (ULONGLONG) (EfiRSVirtualPtr -> GetNextVariableName);
    physicalAddr.QuadPart  = physicalEfiGetNextVariableName;

    EfiVirtualGetNextVariableNamePtr = MmMapIoSpace (physicalAddr,sizeof(PLABEL_DESCRIPTOR),MmCached);


    if (EfiVirtualGetNextVariableNamePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiVirtual Get Next Variable Name Ptr Addr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    //SetVariable

    physicalEfiSetVariable = (ULONGLONG) (EfiRSVirtualPtr -> SetVariable);
    physicalAddr.QuadPart  = physicalEfiSetVariable;

    EfiVirtualSetVariablePtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);

    if (EfiVirtualSetVariablePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiVariableSetVariable Pointer dr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    HalDebugPrint(( HAL_INFO, "HAL: EFI Set Variable    VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiVirtualSetVariablePtr, physicalEfiSetVariable ));


    //GetTime

    physicalEfiGetTime = (ULONGLONG) (EfiRSVirtualPtr -> GetTime);
    physicalAddr.QuadPart  = physicalEfiGetTime;

    EfiVirtualGetTimePtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);

    if (EfiVirtualGetTimePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiGetTime Virtual Addr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    HalDebugPrint(( HAL_INFO, "HAL: EFI GetTime         VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiVirtualGetTimePtr, physicalEfiGetTime ));


    //SetTime

        physicalEfiSetTime = (ULONGLONG) (EfiRSVirtualPtr -> SetTime);
    physicalAddr.QuadPart  = physicalEfiSetTime;

    EfiVirtualSetTimePtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);

    if (EfiVirtualSetTimePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiSetTime Virtual Addr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    HalDebugPrint(( HAL_INFO, "HAL: EFI SetTime         VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiVirtualSetTimePtr, physicalEfiSetTime ));


    //SetVirtualAddressMap

    physicalEfiSetVirtualAddressMap = (ULONGLONG) (EfiRSVirtualPtr -> SetVirtualAddressMap);
    physicalAddr.QuadPart  = physicalEfiSetVirtualAddressMap;

    EfiSetVirtualAddressMapPtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);

    if (EfiSetVirtualAddressMapPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: Efi Set VirtualMapPointer Virtual  Addr is NULL\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    HalDebugPrint(( HAL_INFO, "HAL: EFI SetVirtualAddressMap VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiSetVirtualAddressMapPtr, physicalEfiSetVirtualAddressMap ));


    //ResetSystem

    physicalEfiResetSystem = (ULONGLONG) (EfiRSVirtualPtr -> ResetSystem);
    physicalAddr.QuadPart  = physicalEfiResetSystem;

    EfiResetSystemPtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);

    if (EfiResetSystemPtr == NULL) {
       HalDebugPrint(( HAL_ERROR,"HAL: Efi Reset System Virtual  Addr is NULL\n" ));
       EfiInitStatus = STATUS_UNSUCCESSFUL;
       return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO, "HAL: EFI ResetSystem     VA = 0x%I64x, PA = 0x%I64x\n",
                  EfiResetSystemPtr, physicalEfiResetSystem ));

    //
    // The round to pages should not be needed below, but this change was made late so I made it 
    // page aligned size since the old one was just page size.
    //

    HalpVirtualCommonDataPointer = (PUCHAR)(ExAllocatePool (NonPagedPool, ROUND_TO_PAGES( EfiMemoryMapSize + MemoryMapOffset)));

    if (HalpVirtualCommonDataPointer == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: Common data allocation failed\n" ));

            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }

    HalpVariableNameVirtualPtr       = HalpVirtualCommonDataPointer + VariableNameOffset;
    HalpVendorGuidVirtualPtr         = HalpVirtualCommonDataPointer + VendorGuidOffset;
    HalpVariableAttributesVirtualPtr = HalpVirtualCommonDataPointer + AttributeOffset;
    HalpDataSizeVirtualPtr           = HalpVirtualCommonDataPointer + DataSizeOffset;
    HalpDataVirtualPtr               = HalpVirtualCommonDataPointer + DataBufferOffset;
    HalpCommonDataEndPtr             = HalpVirtualCommonDataPointer + EndOfCommonDataOffset;

    HalpMemoryMapSizeVirtualPtr      = HalpVirtualCommonDataPointer + MemoryMapSizeOffset;
    HalpMemoryMapVirtualPtr          = (PUCHAR)(HalpVirtualCommonDataPointer + MemoryMapOffset);
    HalpDescriptorSizeVirtualPtr     = HalpVirtualCommonDataPointer + DescriptorSizeOffset;
    HalpDescriptorVersionVirtualPtr  = HalpVirtualCommonDataPointer + DescriptorVersionOffset;


    HalpPhysCommonDataPointer = (PUCHAR)((MmGetPhysicalAddress(HalpVirtualCommonDataPointer)).QuadPart);


    HalpVariableNamePhysPtr          = HalpPhysCommonDataPointer + VariableNameOffset;
    HalpVendorGuidPhysPtr            = HalpPhysCommonDataPointer + VendorGuidOffset;
    HalpVariableAttributesPhysPtr    = HalpPhysCommonDataPointer + AttributeOffset;
    HalpDataSizePhysPtr              = HalpPhysCommonDataPointer + DataSizeOffset;
    HalpDataPhysPtr                  = HalpPhysCommonDataPointer + DataBufferOffset;


    HalpMemoryMapSizePhysPtr         = HalpPhysCommonDataPointer + MemoryMapSizeOffset;
    HalpMemoryMapPhysPtr             = HalpPhysCommonDataPointer + MemoryMapOffset;
    HalpDescriptorSizePhysPtr        = HalpPhysCommonDataPointer + DescriptorSizeOffset;
    HalpDescriptorVersionPhysPtr     = HalpPhysCommonDataPointer + DescriptorVersionOffset;


    AttributePtr             = &EfiAttribute;

    DataSizePtr              = &EfiDataSize;

    RtlCopyMemory ((PULONGLONG)HalpMemoryMapVirtualPtr,
                   efiVirtualMemoryMapPtr,
                   (ULONG)(EfiMemoryMapSize)
                  );

    //
    // Now, extract SAL, PAL information from the loader parameter block and
    // initializes HAL SAL, PAL definitions.
    //
    // N.B 10/2000:
    //  We do not check the return status of HalpInitSalPal(). We should. FIXFIX.
    //  In case of failure, we currently flag HalpSalPalData.Status as unsuccessful.
    //

    HalpInitSalPal(LoaderBlock);

    //
    // Initialize Spin Lock
    //

    KeInitializeSpinLock(&EFIMPLock);

    ASSERT (EfiDescriptorVersion == EFI_MEMORY_DESCRIPTOR_VERSION);

    // if (EfiDescriptorVersion != EFI_MEMORY_DESCRIPTION_VERSION) {

    //    HalDebugPrint(HAL_ERROR,("Efi Memory Map Pointer VAddr is NULL\n"));

    //    EfiInitStatus = STATUS_UNSUCCESSFUL;

    //    return STATUS_UNSUCCESSFUL;
    // }

    HalDebugPrint(( HAL_INFO, "HAL: Creating EFI virtual address mapping\n" ));

    efiMapEntryPtr = efiVirtualMemoryMapPtr;

    if (efiMapEntryPtr == NULL) {

        HalDebugPrint(( HAL_ERROR, "HAL: Efi Memory Map Pointer VAddr is NULL\n" ));

        EfiInitStatus = STATUS_UNSUCCESSFUL;

        return STATUS_UNSUCCESSFUL;
    }

    mapEntries = EfiMemoryMapSize/EfiDescriptorSize;

    HalDebugPrint(( HAL_INFO,
                            "HAL: Sal: 0x%I64x  (offset 0x%I64x) SalGP: 0x%I64x (offset 0x%I64x) SalDataGPOffset: 0x%I64x\n",
                            SalCode.PhysicalAddress,
                            SalOffset,
                            SalData.PhysicalAddress,
                            SalDataOffset,
                            SalDataGPOffset.PhysicalAddress
                            ));

    HalDebugPrint(( HAL_INFO, "HAL: EfiMemoryMapSize: 0x%I64x & EfiDescriptorSize: 0x%I64x & #of entries: 0x%I64x\n",
                    EfiMemoryMapSize,
                    EfiDescriptorSize,
                    mapEntries ));

    HalDebugPrint(( HAL_INFO, "HAL: Efi RunTime Attribute will be printed as 1\n" ));

    for (index = 0; index < mapEntries; index= index + 1) {

        BOOLEAN attribute = 0;
        ULONGLONG physicalStart = efiMapEntryPtr->PhysicalStart;
        ULONGLONG physicalEnd   = physicalStart + (efiMapEntryPtr->NumberOfPages << EFI_PAGE_SHIFT);

        physicalAddr.QuadPart = efiMapEntryPtr -> PhysicalStart;

        //
        // To handle video bios mapping issues, HALIA64 maps every EFI MD
        // regardless of the EFI_MEMORY_RUNTIME flag.
        //
        // Implementation Note: ia64ldr ignored 1rst MB range and did not pass 
        //                      this memory to MM. MM considers this range as 
        //                      IO space.
        //

        if ( (efiMapEntryPtr->NumberOfPages > 0) && (physicalStart < OptionROMAddress) )   {
            ULONGLONG numberOfPages = efiMapEntryPtr->NumberOfPages;

            cacheType = (efiMapEntryPtr->Attribute & EFI_MEMORY_UC) ? MmNonCached : MmCached;

            efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace (physicalAddr,
                                              (EFI_PAGE_SIZE) * numberOfPages,
                                              cacheType
                                                       ));
            if ((efiMapEntryPtr->VirtualStart) == 0) {
               HalDebugPrint(( HAL_ERROR, 
                               "HAL: Efi Video Bios area PA 0x%I64x, VAddr is NULL\n", physicalStart
                            ));
               EfiInitStatus = STATUS_UNSUCCESSFUL;
               return STATUS_UNSUCCESSFUL;
            }

            HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart));

            //
            // Initialize known HAL video bios pointers. These pointer must be zero based
            //

            if (physicalStart == 0x00000) {
                
                HalpLowMemoryBase = (PVOID) efiMapEntryPtr->VirtualStart;
            }

            if ( physicalStart <= 0xA0000  && physicalEnd > 0xA0000) {
                HalpFrameBufferBase =  (PVOID)(efiMapEntryPtr->VirtualStart - physicalStart);
            }

            if ( physicalStart <= 0xC0000 && physicalEnd > 0xC0000 ) {
                HalpIoMemoryBase =  (PVOID)(efiMapEntryPtr->VirtualStart - physicalStart);
            }
        }
        else if ((efiMapEntryPtr->Attribute) & EFI_MEMORY_RUNTIME) 
        {
            attribute = 1;
            switch (efiMapEntryPtr->Type) {
                case EfiRuntimeServicesData:
                case EfiReservedMemoryType:
                case EfiACPIMemoryNVS:
                    if(efiMapEntryPtr->Type == EfiACPIMemoryNVS) {
                        //
                        // note: we allow ACPI NVS to be mapped per the 
                        // firmware's specification instead of forcing it to
                        // be non-cached.  We are relying on the first mapping
                        // of this range to have the "correct" caching flag, as
                        // that is the cachability attribute that all 
                        // subsequent mappings of this range (ie., mapping of
                        // additional data in the same page from ACPI driver 
                        // for a memory operation region, etc.). This semantic
                        // is enforced by the memory manager.
                        //
                        efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace (physicalAddr,
                                                                     (SIZE_T)((EFI_PAGE_SIZE)*(efiMapEntryPtr->NumberOfPages)),
                                                                     (efiMapEntryPtr->Attribute & EFI_MEMORY_UC) ? MmNonCached : MmCached
                                                                     ));

                    } else {

                        efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace (physicalAddr,
                                                (SIZE_T)((EFI_PAGE_SIZE)*(efiMapEntryPtr->NumberOfPages)),
                                                           (efiMapEntryPtr->Attribute & EFI_MEMORY_WB) ? MmCached : MmNonCached
                                                           ));

                    }
                    if ((efiMapEntryPtr->VirtualStart) == 0) {

                        HalDebugPrint(( HAL_ERROR, "HAL: Efi RunTimeSrvceData/RsrvdMemory/ACPIMemoryNVS area VAddr is NULL\n" ));

                        EfiInitStatus = STATUS_UNSUCCESSFUL;

                        return STATUS_UNSUCCESSFUL;
                    }


                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4k pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));

                    if (efiMapEntryPtr->Type == EfiRuntimeServicesData) {
                        if (HalpDescriptorContainsAddress(efiMapEntryPtr,SalData.PhysicalAddress)) {
                            //
                            // save off salgp virtual address
                            //
                            SalData.VirtualAddress = efiMapEntryPtr->VirtualStart;
                            SalDataOffset = SalData.PhysicalAddress - efiMapEntryPtr->PhysicalStart;

                            HalDebugPrint(( HAL_INFO,
                                "HAL: prior descriptor contains SalData.PhysicalAddress 0x%I64x\n",
                                SalData.PhysicalAddress ));

                        }

                        if (HalpDescriptorContainsAddress(efiMapEntryPtr,SalDataGPOffset.PhysicalAddress)) {
                            //
                            // save off salgp virtual address
                            //
                            SalDataGPOffset.VirtualAddress = efiMapEntryPtr->VirtualStart;

                            //
                            // Don't overwrite an existing SalDataOffset
                            // (generated using SalData.PhysicalAddress) since
                            // SalDataGPOffset is only needed when
                            // SalData.PhysicalAddress lies outside of the EFI
                            // memory map.
                            //
                            if (SalDataOffset == 0) {
                                SalDataOffset = SalDataGPOffset.PhysicalAddress - efiMapEntryPtr->PhysicalStart;
                            }

                            HalDebugPrint(( HAL_INFO,
                                "HAL: prior descriptor contains SalDataGPOffset.PhysicalAddress 0x%I64x\n",
                                SalData.PhysicalAddress ));
                        }
                    }


                    break;

                case EfiPalCode:

                    efiMapEntryPtr->VirtualStart = PalCode.VirtualAddress;

                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));

                    break;

                case EfiRuntimeServicesCode:

                    //
                    // Skip over Option rom addresses.  They are not really needed by the EFI runtime
                    // and most users want it mapped non-cached.
                    //

                    cacheType = (efiMapEntryPtr->Attribute & EFI_MEMORY_WB) ? MmCached : MmNonCached;

                    efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace (physicalAddr,
                                                     (EFI_PAGE_SIZE) * (efiMapEntryPtr->NumberOfPages),
                                                      cacheType
                                                      ));

                    if ((efiMapEntryPtr->VirtualStart) == 0) {

                        HalDebugPrint(( HAL_ERROR, "HAL: Efi RunTimeSrvceCode area VAddr is NULL\n" ));

                        EfiInitStatus = STATUS_UNSUCCESSFUL;

                        return STATUS_UNSUCCESSFUL;
                     }

                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart));

                    if (HalpDescriptorContainsAddress(efiMapEntryPtr,SalData.PhysicalAddress)) {
                        //
                        // save off salgp virtual address
                        //
                        SalData.VirtualAddress = efiMapEntryPtr->VirtualStart;
                        SalDataOffset =  SalData.PhysicalAddress - efiMapEntryPtr->PhysicalStart;
                    }

                    if (HalpDescriptorContainsAddress(efiMapEntryPtr,SalDataGPOffset.PhysicalAddress)) {
                        //
                        // save off salgp virtual address
                        //
                        SalDataGPOffset.VirtualAddress = efiMapEntryPtr->VirtualStart;

                        //
                        // Don't overwrite an existing SalDataOffset
                        // (generated using SalData.PhysicalAddress) since
                        // SalDataGPOffset is only needed when
                        // SalData.PhysicalAddress lies outside of the EFI
                        // memory map.
                        //
                        if (SalDataOffset == 0) {
                            SalDataOffset = SalDataGPOffset.PhysicalAddress - efiMapEntryPtr->PhysicalStart;
                        }

                        HalDebugPrint(( HAL_INFO,
                            "HAL: prior descriptor contains SalDataGPOffset.PhysicalAddress 0x%I64x\n",
                            SalData.PhysicalAddress ));
                    }


                    if (HalpDescriptorContainsAddress(efiMapEntryPtr,SalCode.PhysicalAddress)) {
                        //
                        // save off sal code virtual address
                        //
                        SalCode.VirtualAddress = efiMapEntryPtr->VirtualStart;
                        SalOffset = SalCode.PhysicalAddress - efiMapEntryPtr->PhysicalStart;
                    }

                    break;
                case EfiMemoryMappedIO:
                    efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace (physicalAddr,
                                                      (EFI_PAGE_SIZE) * (efiMapEntryPtr->NumberOfPages),
                                                      MmNonCached
                                                      ));

                    if ((efiMapEntryPtr->VirtualStart) == 0) {

                        HalDebugPrint(( HAL_ERROR, "HAL: Efi MemoryMappedIO VAddr is NULL\n" ));

                        EfiInitStatus = STATUS_UNSUCCESSFUL;

                        return STATUS_UNSUCCESSFUL;
                    }

                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));
                     break;

                case EfiMemoryMappedIOPortSpace:

                    efiMapEntryPtr->VirtualStart = VIRTUAL_IO_BASE;
                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x ALREADY mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));
                    break;

                case EfiACPIReclaimMemory:

                    //
                    // note: we allow ACPI reclaim memory to be mapped per the
                    // firmware's specification instead of forcing it to
                    // be non-cached.  We are relying on the first mapping
                    // of this range to have the "correct" caching flag, as
                    // that is the cachability attribute that all 
                    // subsequent mappings of this range (ie., mapping of
                    // additional data in the same page from ACPI driver 
                    // for a memory operation region, etc.). This semantic
                    // is enforced by the memory manager.
                    //  
                    efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace(
                                                                        physicalAddr,
                                                                        (SIZE_T)((EFI_PAGE_SIZE)*(efiMapEntryPtr->NumberOfPages)), 
                                                                        (efiMapEntryPtr->Attribute & EFI_MEMORY_UC) ? MmNonCached : MmCached));
                    if ((efiMapEntryPtr->VirtualStart) == 0) {

                        HalDebugPrint(( HAL_ERROR, "HAL: Efi ACPI Reclaim VAddr is NULL\n" ));
                        EfiInitStatus = STATUS_UNSUCCESSFUL;
                        return STATUS_UNSUCCESSFUL;

                    }
                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));
                     break;

                default:

                    HalDebugPrint(( HAL_INFO, "HAL: Efi CONTROL SHOULD NOT COME HERE\n" ));
                    HalDebugPrint(( HAL_INFO,
                        "HAL: NON-SUPPORTED Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart ));

                    EfiInitStatus = STATUS_UNSUCCESSFUL;

                    return STATUS_UNSUCCESSFUL;

                    break;
            }

        } else {

                HalDebugPrint(( HAL_INFO,
                    "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x ALREADY mapped to VA 0x%I64x\n",
                    attribute,
                    efiMapEntryPtr->Type,
                    efiMapEntryPtr->NumberOfPages,
                    efiMapEntryPtr->PhysicalStart,
                    efiMapEntryPtr->VirtualStart ));

        }

        efiMapEntryPtr = NextMemoryDescriptor(efiMapEntryPtr,EfiDescriptorSize);
    }

    status = HalpCallEfi(EFI_SET_VIRTUAL_ADDRESS_MAP_INDEX,
                         (ULONGLONG)EfiMemoryMapSize,
                         (ULONGLONG)EfiDescriptorSize,
                         (ULONGLONG)EfiDescriptorVersion,
                         (ULONGLONG)efiVirtualMemoryMapPtr,
                         0,
                         0,
                         0,
                         0
                         );


    HalDebugPrint(( HAL_INFO, "HAL: Returned from SetVirtualAddressMap: 0x%Ix\n", status ));

    if (EFI_ERROR( status )) {

        EfiInitStatus = STATUS_UNSUCCESSFUL;

        return STATUS_UNSUCCESSFUL;

    }

    HalDebugPrint(( HAL_INFO, "HAL: EFI Virtual Address mapping done...\n" ));

    //
    // setup sal global pointers.
    //
    if (!SalCode.VirtualAddress) {
        HalDebugPrint(( HAL_FATAL_ERROR, "HAL: no virtual address for sal code\n" ));
        EfiInitStatus = STATUS_UNSUCCESSFUL;
        return (EfiInitStatus);
    }

    //
    // The SAL GP is supposed to point somewhere within the SAL's short data
    // segment (.sdata), meaning that we should be able to use it to find
    // the SAL data area.  Unfortunately most SALs are built using linkers
    // that locate GP well outside of .sdata.  As a consequence the SAL GP
    // lies off of the memory map (not covered by any memory descriptor) on
    // some systems.  In this case we have no way of finding the descriptor
    // that contains the SAL data while needing to relocate the SAL GP based
    // upon the virtual address of this unknown descriptor (the data and GP
    // need to remain fixed in relationship to one another).  We try to detect
    // and work around this problem here.
    //

    if (!SalData.VirtualAddress) {
        //
        // If we get here we'll need to do some tricks in order to
        // generate a virtual address for the SAL data area (basically
        // the SAL GP).
        //

        HalDebugPrint(( HAL_INFO,
            "HAL: no virtual address for SalGP found, checking SalDataGPOffset 0x%I64x\n",
            SalDataGPOffset.VirtualAddress ));

        //
        // Check if we found an EFI descriptor 2MB below the physical SAL GP
        // address.  If we did, add 2MB back to the newly constructed virtual
        // address of that descriptor and call it the GP.  This method will
        // occasionally work because the current linkers typically put the
        // GP 2MB outside of .sdata.
        //

        if (SalDataGPOffset.VirtualAddress) {
            HalDebugPrint(( HAL_INFO, "HAL: using SalDataGPOffset.VirtualAddress\n" ));
            SalData.VirtualAddress = SalDataGPOffset.VirtualAddress + (2 * 0x100000);
        } else {
            //
            // As a last resort assume that the physical SAL GP address
            // is relative to the SAL code memory descriptor.  This will
            // work as long as SAL code and data share the same EFI memory
            // descriptor (otherwise the SAL GP is relative to a SAL data
            // memory descriptor that we weren't able to detect).  Currently
            // there isn't any way to detect the case where SAL data is in
            // a different memory descriptor that doesn't contain the SAL GP.
            //

            HalDebugPrint(( HAL_FATAL_ERROR, "HAL: no virtual address for sal data.  Some systems don't seem to care so we're faking this.\n" ));

            //
            // SalCode.PhysicalAddress is the address of SAL_PROC.  Load
            // up the virtual address of SAL_PROC and the distance the
            // virtual SAL GP should lie away from this point.
            //

            SalData.VirtualAddress = SalCode.VirtualAddress + SalOffset;
            SalDataOffset = SalData.PhysicalAddress - SalCode.PhysicalAddress;
        }
    }

    HalpSalProcPointer       = (ULONGLONG) (SalCode.VirtualAddress + SalOffset);
    HalpSalProcGlobalPointer = (ULONGLONG) (SalData.VirtualAddress + SalDataOffset);

    HalDebugPrint(( HAL_INFO,
        "HAL: SalProc: 0x%I64x  SalGP: 0x%I64x \n",
        HalpSalProcPointer,
        HalpSalProcGlobalPointer
        ));

    EfiInitStatus = STATUS_SUCCESS;

    //
    // Execute some validity checks on the floating point software assist.
    //

    if (LoaderBlock->u.Ia64.FpswaInterface != (ULONG_PTR) NULL) {
        PPLABEL_DESCRIPTOR plabelPointer;

        HalpFpEmulate = interfacePtr->Fpswa;
        if (HalpFpEmulate == NULL ) {
            HalDebugPrint(( HAL_FATAL_ERROR, "HAL: EfiFpswa Virtual Addr is NULL\n" ));
            KeBugCheckEx(FP_EMULATION_ERROR, 0, 0, 0, 0);
            EfiInitStatus = STATUS_UNSUCCESSFUL;
            return STATUS_UNSUCCESSFUL;
        }

        plabelPointer = (PPLABEL_DESCRIPTOR) HalpFpEmulate;
        if ((plabelPointer->EntryPoint & 0xe000000000000000) == 0) {

            HalDebugPrint(( HAL_FATAL_ERROR, "HAL: EfiFpswa Instruction Addr is bougus\n" ));
            KeBugCheckEx(FP_EMULATION_ERROR, 0, 0, 0, 0);
        }

    }

    return STATUS_SUCCESS;

} // HalpEfiInitialization()



EFI_STATUS
HalpCallEfiPhysical(
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG EP,
    IN ULONGLONG GP
    )

/*++

Routine Description:

    This function is a wrapper for making a physical mode EFI call.  This
    function's only job is to provide the stack and backing store pointers
    needed by HalpCallEfiPhysicalEx.

Arguments:

    Arg1 through Arg6 - The arguments to be passed to EFI.

    EP - The entry point of the EFI runtime service we want to call.

    GP - The global pointer associated with the entry point.

Return Value:

    The EFI_STATUS value returned by HalpCallEfiPhysicalEx.

--*/

{
    ULONGLONG StackPointer;
    ULONGLONG BackingStorePointer;
    ULONGLONG StackBase;

    //
    // Load the addresses of the stack and backing store reserved for
    // physical mode EFI calls on this processor.
    //

    StackBase = PCR->HalReserved[PROCESSOR_PHYSICAL_FW_STACK_INDEX];

    StackPointer = GET_FW_STACK_POINTER(StackBase);
    BackingStorePointer = GET_FW_BACKING_STORE_POINTER(StackBase);

    //
    // Branch to the assembly routine that makes the actual EFI call.
    //

    return HalpCallEfiPhysicalEx(
                Arg1,
                Arg2,
                Arg3,
                Arg4,
                Arg5,
                Arg6,
                EP,
                GP,
                StackPointer,
                BackingStorePointer
                );
}

EFI_STATUS
HalpCallEfi(
    IN ULONGLONG FunctionId,
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG Arg7,
    IN ULONGLONG Arg8
    )

/*++

Routine Description:
                                                                :9
    This function is a wrapper function for making a EFI call.  Callers within the
    HAL must use this function to call the EFI.

Arguments:

    FunctionId - The EFI function
    Arg1-Arg7 - EFI defined arguments for each call
    ReturnValues - A pointer to an array of 4 64-bit return values

Return Value:

    SAL's return status, return value 0, is returned in addition to the ReturnValues structure
    being filled

--*/

{
    ULONGLONG EP, GP;
    EFI_STATUS efiStatus;
    HALP_EFI_CALL EfiCall;

    //
    // Storage for old level
    //

    KIRQL OldLevel;

    //
    // Set EfiCall to the physical or virtual mode EFI call dispatcher
    // depending upon whether we've made a successful call to SetVirtual
    // AddressMap.
    //

    if (HalpSetVirtualAddressMapCount == 0) {
        EfiCall = HalpCallEfiPhysical;

    } else {
        EfiCall = HalpCallEfiVirtual;
    }

    //
    // Acquire MP Lock
    //

    KeAcquireSpinLock(&EFIMPLock, &OldLevel);

    switch (FunctionId) {

    case EFI_GET_VARIABLE_INDEX:

        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetVariablePtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetVariablePtr) -> GlobalPointer;

        efiStatus = (EfiCall( (ULONGLONG)Arg1,               // VariableNamePtr
                              (ULONGLONG)Arg2,               // VendorGuidPtr
                              (ULONGLONG)Arg3,               // VariableAttributesPtr,
                              (ULONGLONG)Arg4,               // DataSizePtr,
                              (ULONGLONG)Arg5,               // DataPtr,
                              Arg6,
                              EP,
                              GP
                              ));

        break;

    case EFI_SET_VARIABLE_INDEX:

        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiVirtualSetVariablePtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiVirtualSetVariablePtr) -> GlobalPointer;


        efiStatus = (EfiCall(  Arg1,
                               Arg2,
                               Arg3,
                               Arg4,
                               Arg5,
                               Arg6,
                               EP,
                               GP
                               ));

        break;

    case EFI_GET_NEXT_VARIABLE_NAME_INDEX:

        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetNextVariableNamePtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetNextVariableNamePtr) -> GlobalPointer;


        efiStatus = (EfiCall(  Arg1,
                               Arg2,
                               Arg3,
                               Arg4,
                               Arg5,
                               Arg6,
                               EP,
                               GP
                               ));

        break;


    case EFI_GET_TIME_INDEX:

        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetTimePtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetTimePtr) -> GlobalPointer;

        efiStatus = (EfiCall ((ULONGLONG)Arg1,  //EFI_TIME
                              (ULONGLONG)Arg2,  //EFI_TIME Capabilities
                              Arg3,
                              Arg4,
                              Arg5,
                              Arg6,
                              EP,
                              GP
                              ));

        break;


    case EFI_SET_TIME_INDEX:

        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiVirtualSetTimePtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiVirtualSetTimePtr) -> GlobalPointer;

        efiStatus = (EfiCall ((ULONGLONG)Arg1,  //EFI_TIME
                              Arg2,
                              Arg3,
                              Arg4,
                              Arg5,
                              Arg6,
                              EP,
                              GP
                              ));

        break;


    case EFI_SET_VIRTUAL_ADDRESS_MAP_INDEX:

        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiSetVirtualAddressMapPtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiSetVirtualAddressMapPtr) -> GlobalPointer;


        //
        // Arg 1 and 5 are virtual mode pointers. We need to convert to physical
        //

        RtlCopyMemory (HalpMemoryMapVirtualPtr,
                      (PULONGLONG)Arg4,
                      (ULONG)EfiMemoryMapSize
                      );


        efiStatus = (EfiCall ((ULONGLONG)EfiMemoryMapSize,
                              (ULONGLONG)EfiDescriptorSize,
                              (ULONGLONG)EfiDescriptorVersion,
                              (ULONGLONG)HalpMemoryMapPhysPtr,
                              Arg5,
                              Arg6,
                              EP,
                              GP
                              ));

        //
        // If the call was successful make a note in HalpSetVirtualAddressMap
        // Count that EFI is now running in virtual mode.
        //

        if (efiStatus == EFI_SUCCESS) {
            HalpSetVirtualAddressMapCount++;
        }

        break;

    case EFI_RESET_SYSTEM_INDEX:

        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiResetSystemPtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiResetSystemPtr) -> GlobalPointer;

        efiStatus = ((EfiCall ( Arg1,
                                Arg2,
                                Arg3,
                                Arg4,
                                Arg5,
                                Arg6,
                                EP,
                                GP
                                )));

        break;

    default:

        //
        // DebugPrint("EFI: Not supported now\n");
        //

        efiStatus = EFI_UNSUPPORTED;

        break;

    }

    //
    // Release the MP Lock
    //

    KeReleaseSpinLock (&EFIMPLock, OldLevel);

    return efiStatus;

} // HalpCallEfi()



HalpFpErrorPrint (PAL_RETURN pal_ret)

{

    ULONGLONG err_nr;
    unsigned int qp;
    ULONGLONG OpCode;
    unsigned int rc;
    unsigned int significand_size;
    unsigned int ISRlow;
    unsigned int f1;
    unsigned int sign;
    unsigned int exponent;
    ULONGLONG significand;
    unsigned int new_trap_type;


    err_nr = pal_ret.err1 >> 56;

    switch (err_nr) {
    case 1:
        // err_nr = 1         in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: template FXX is invalid\n"));
        break;
    case 2:
        // err_nr = 2           in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: instruction slot 3 is not valid \n"));
        break;
    case 3:
        // err_nr = 3           in err1, bits 63-56
        // qp                   in err1, bits 31-0
        qp = (unsigned int) pal_ret.err1 & 0xffffffff;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: qualifying predicate PR[%ud] = 0 \n",qp));
        break;

    case 4:
        // err_nr = 4           in err1, bits 63-56
        // OpCode               in err2, bits 63-0
        OpCode = pal_ret.err2;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: instruction opcode %8x%8x not recognized \n",
                                  (unsigned int)((OpCode >> 32) & 0xffffffff),(unsigned int)(OpCode & 0xffffffff)));
        break;

    case 5:
        // err_nr = 5           in err1, bits 63-56
        // rc                   in err1, bits 31-0 (1-0)
        rc = (unsigned int) pal_ret.err1 & 0xffffffff;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: invalid rc = %ud\n", rc));
        break;

    case 6:
        // err_nr = 6           in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: cannot determine the computation model \n"));
        break;

    case 7:
        // err_nr = 7           in err1, bits 63-56
        // significand_size     in err1, bits 55-32
        // ISRlow               in err1, bits 31-0
        // f1                   in err2, bits 63-32
        // tmp_fp.sign          in err2, bit 17
        // tmp_fp.exponent      in err2, bits 16-0
        // tmp_fp.significand   in err3
        significand_size = (unsigned int)((pal_ret.err1 >> 32) & 0xffffff);
        ISRlow = (unsigned int) (pal_ret.err1 & 0xffffffff);
        f1 = (unsigned int) ((pal_ret.err2 >> 32) & 0xffffffff);
        sign = (unsigned int) ((pal_ret.err2 >> 17) & 0x01);
        exponent = (unsigned int) (pal_ret.err2 & 0x1ffff);
        significand = pal_ret.err3;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: incorrect significand \
            size %ud for ISRlow = %4.4x and FR[%ud] = %1.1x %5.5x %8x%8x\n",
            significand_size, ISRlow, f1, sign, exponent,
            (unsigned int)((significand >> 32) & 0xffffffff),
            (unsigned int)(significand & 0xffffffff)));
        break;

    case 8:

        // err_nr = 8           in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: non-tiny result\n"));
        break;

    case 9:
        // err_nr = 9           in err1, bits 63-56
        // significand_size     in err1, bits 31-0
        significand_size = (unsigned int) pal_ret.err1 & 0xffffffff;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: incorrect significand \
            size %ud\n", significand_size));
        break;

    case 10:
        // err_nr = 10          in err1, bits 63-56
        // rc                   in err1, bits 31-0
        rc = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: invalid rc = %ud for \
            non-SIMD F1 instruction\n", rc));
        break;

    case 11:
        // err_nr = 11          in err1, bits 63-56
        // ISRlow & 0x0ffff     in err1, bits 31-0
        ISRlow = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: SWA trap code invoked \
              with F1 instruction, w/o O or U set in ISR.code = %x\n", ISRlow));
        break;

    case 12:
        // err_nr = 12          in err1, bits 63-56
        // ISRlow & 0x0ffff     in err1, bits 31-0
        ISRlow = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: SWA trap code invoked \
        with SIMD F1 instruction, w/o O or U set in ISR.code = %x\n", ISRlow));
        break;


    case 13:
        // err_nr = 13          in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: non-tiny result low\n"));
        break;

    case 14:
        // err_nr = 14          in err1, bits 63-56
        // rc                   in err1, bits 31-0
        rc = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: invalid rc = %ud for \
            SIMD F1 instruction\n", rc));
        break;

    case 15:
        // err_nr = 15          in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: non-tiny result high\n"));
        break;

    case 16:
        // err_nr = 16          in err1, bits 63-56
        // OpCode               in err2, bits 63-0
        OpCode = pal_ret.err2;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: instruction opcode %8x%8x \
            not valid for SWA trap\n", (unsigned int)((OpCode >> 32) & 0xffffffff),
            (unsigned int)(OpCode & 0xffffffff)));
        break;

    case 17:
        // err_nr = 17          in err1, bits 63-56
        // OpCode               in err2, bits 63-0
        // ISRlow               in err3, bits 31-0
        OpCode = pal_ret.err2;
        ISRlow = (unsigned int) (pal_ret.err3 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: fp_emulate () called w/o \
            trap_type FPFLT or FPTRAP, OpCode = %8x%8x, and ISR code = %x\n",
            (unsigned int)((OpCode >> 32) & 0xffffffff),
            (unsigned int)(OpCode & 0xffffffff), ISRlow));
        break;

    case 18:
        // err_nr = 18          in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: SWA fault repeated\n"));
        break;

    case 19:
        // err_nr = 19          in err1, bits 63-56
        // new_trap_type        in err1, bits 31-0
        new_trap_type = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: new_trap_type = %x\n",
            new_trap_type));
        break;

    default:
        // error
        HalDebugPrint(( HAL_ERROR, "Incorrect err_nr = %8x%8x from fp_emulate ()\n",
            (unsigned int)((err_nr >> 32) & 0xffffffff),
            (unsigned int)(err_nr & 0xffffffff)));

    }
}


LONG
HalFpEmulate (
    ULONG     trap_type,
    BUNDLE    *pbundle,
    ULONGLONG *pipsr,
    ULONGLONG *pfpsr,
    ULONGLONG *pisr,
    ULONGLONG *ppreds,
    ULONGLONG *pifs,
    FP_STATE  *fp_state
    )
/*++

Routine Description:

    This function is a wrapper function to make fp_emulate() call
    to EFI FPSWA driver.

Arguments:

    trap_type - indicating which FP trap it is.
    pbundle   - bundle where this trap occurred
    pipsr     - IPSR value
    pfpsr     - FPSR value
    pisr      - ISR value
    ppreds    - value of predicate registers
    pifs      - IFS value
    fp_state  - floating point registers

Return Value:

    return IEEE result of the floating point operation

--*/

{
    PAL_RETURN ret;

    ret  =  (*HalpFpEmulate) (
                                trap_type,
                                pbundle,
                                pipsr,
                                pfpsr,
                                pisr,
                                ppreds,
                                pifs,
                                fp_state
                                );
    if (ret.retval == FP_EMUL_ERROR) {
       HalpFpErrorPrint (ret);
    }

    return ((LONG) (ret.retval));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64efis.s ===
//
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  EFIASM.S - IA64 EFI Physical Mode Calls //
// Description:
// Target Platform:  Merced
//
// Reuse: None
//
///////////////////////////////////////////////////////////////////////////////

#include "regia64.h"
#include "kxia64.h"

        .global HalpCallEfiPhysicalEx
        .text

//++
// Name: HalpCallEfiPhysicalEx()
// 
// Routine Description:
//
// Arguments:
//
//      Arg 0 to Arg 5
//      EntryPoint
//      GlobalPointer
//      StackPointer
//      BackingStorePointer
//
// Return Value: EFI_STATUS
//
//--


        NESTED_ENTRY(HalpCallEfiPhysicalEx)
        NESTED_SETUP(8,2,0,0)

//
//      Aliases
//
        rSaveEP     = t22
        rSaveGP     = t21
        rSaveA5     = t20
        rSaveA4     = t19
        rSaveA3     = t18
        rSaveA2     = t17
        rSaveA1     = t16
        rSaveA0     = t15

        rSaveSp     = t14
        rSaveBSP    = t13
        rSavePfs    = t12
        rSaveBrp    = t11
        rSaveRSC    = t10
        rSaveRNAT   = t9
        rSavePSR    = t8

        rNewSp      = t7
        rNewBSP     = t6

        rT1         = t1
        rT2         = t2
        rT3         = t3
                
// Save Arguements in static Registers
   
        mov         rSaveA0  = a0
        mov         rSaveA1  = a1
        mov         rSaveA2  = a2
        mov         rSaveA3  = a3
        mov         rSaveA4  = a4
        mov         rSaveA5  = a5
        mov         rSaveEP  = a6
        mov         rSaveGP  = a7

        mov         rSaveSp = sp
        mov         rSavePfs = ar.pfs
        mov         rSaveBrp = brp
        
//
// Retrieve the physical sp and bsp from the stack.
//

        add          rT1 = 16, sp
        add          rT2 = 24, sp
        ;;
        ld8          rNewSp = [rT1]
        ld8          rNewBSP = [rT2]

// Allocate 0
        ;;
        alloc       rT1 = 0,0,0,0

// Flush RSE 
        ;;
        flushrs
        ;;
        mov         rSavePSR = psr
        movl        rT2 = (1 << PSR_BN)
        ;;
        or          rSavePSR = rT2, rSavePSR    // psr.bn stays on
        rsm         (1 << PSR_I)        
        
        mov         rSaveRSC = ar.rsc

// Flush RSE to enforced lazy mode by clearing both RSC.mode bits

        mov         rT1 = RSC_KERNEL_DISABLED
        ;;
        mov         ar.rsc = rT1
        ;;
//
// save RSC, RNAT, BSP, PSR, SP in the allocated space during initialization 
//
        mov         rSaveBSP = ar.bsp
        mov         rSaveRNAT = ar.rnat
//
// IC = 0; I = 0; 
//
        ;;
        rsm         (1 << PSR_IC)
        ;;
//        
// IIP = HceContinuePhysical:  IPSR is physical
//        
        movl        rT1 = (1 << PSR_IT) | (1 << PSR_RT) | (1 << PSR_DT) | (1 << PSR_I)
        movl        rT2 = 0xffffffffffffffff
        ;;
        xor         rT1 = rT1, rT2
        ;;
        and         rT1 = rT1, rSavePSR         // rT1 = old PSR & zero it, dt, rt, i
        srlz.i
        ;;
        mov         cr.ipsr = rT1
        mov         cr.ifs = zero
        ;;
        movl        rT2 = HceContinuePhysical
        movl        rT3 = 0xe0000000ffffffff
        ;;
        and         rT2 = rT2, rT3
        ;;
        tpa         rT2 = rT2                   // phys address of new ip
        ;;
        mov         cr.iip = rT2
        ;;
        rfi
        ;;
      
//
// Now in physical mode, ic = 1, i = 0
//

HceContinuePhysical::

//
// Switch to new bsp, sp
//
        mov         sp = rNewSp
        mov         ar.bspstore = rNewBSP
        ;;        
        mov         ar.rnat = zero
        ;;
//
// Enable RSC
//
        mov         ar.rsc = RSC_KERNEL

//
// Allocate frame on new bsp
//
        ;;
        alloc       rT1 = ar.pfs,0,7,6,0

//
// Save caller's state in register stack
//

        mov         loc0 = rSaveRNAT
        mov         loc1 = rSaveSp
        mov         loc2 = rSaveBSP
        mov         loc3 = rSaveRSC
        mov         loc4 = rSaveBrp
        mov         loc5 = rSavePfs
        mov         loc6 = rSavePSR
        ;;
// Setup Arguements

        mov         out0 = rSaveA0
        mov         out1 = rSaveA1
        mov         out2 = rSaveA2
        mov         out3 = rSaveA3
        mov         out4 = rSaveA4
        mov         out5 = rSaveA5

        movl        rT1 = HceEfiReturnAddress
        movl        rT2 = 0xe0000000FFFFFFFF
        ;;
        and         rT2 = rT2, rT1
        ;;
        tpa         rT2 = rT2
        ;;
        mov         brp = rT2
        mov         gp = rSaveGP
        mov         bt0 = rSaveEP        
        ;;
        br.call.sptk brp = bt0
        ;;

HceEfiReturnAddress::
//
// In physical mode: switch to virtual
//

//
// Restore saved state
//
        mov         rSaveRNAT = loc0
        mov         rSaveSp  = loc1
        mov         rSaveBSP = loc2
        mov         rSaveRSC = loc3
        mov         rSaveBrp = loc4
        mov         rSavePfs = loc5
        mov         rSavePSR = loc6
        ;;
//
// Restore BSP, SP
//
        ;;
        mov         ar.rsc = RSC_KERNEL_DISABLED
        ;;
        alloc       rT1 = 0,0,0,0
        ;;
        mov         ar.bspstore = rSaveBSP
        ;;
        mov         ar.rnat = rSaveRNAT
        mov         sp = rSaveSp
        ;;
        rsm         (1 << PSR_IC)
        ;;
        
        movl        rT1 = HceContinueVirtual
        movl        rT2 = 0xe0000000ffffffff
        ;;
        and         rT1 = rT2, rT1
        ;;
        srlz.i
        ;;
        mov         cr.iip = rT1
        mov         cr.ipsr = rSavePSR
        mov         cr.ifs = zero
        ;;
        rfi
        ;;
//
// Now in virtual mode, ic = 1, i = 1
//
HceContinueVirtual::

//
// Restore psf, brp and return
//
        mov         ar.rsc = rSaveRSC
        ;;
        mov         ar.pfs = rSavePfs
        mov         brp = rSaveBrp
        ;;
        br.ret.sptk brp
        NESTED_EXIT(HalpCallEfiPhysicalEx)      





//++
//
//  VOID
//  HalpCallEfiVirtual(
//      ULONGLONG a0,  /* Arg 1 */
//      ULONGLONG a1,  /* Arg 2 */
//      ULONGLONG a2, /*  Arg 3 */
//      ULONGLONG a3, /*  Arg 4 */
//      ULONGLONG a4, /*  Arg 5 */
//      ULONGLONG a5, /*  Arg 6 */
//      ULONGLONG a6, /*  Entry Point */
//      ULONGLONG a7  /*  GP    */
//      );
//
//  Routine Description:
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values, r8 is the status
//--

        NESTED_ENTRY(HalpCallEfiVirtual)
        
        NESTED_SETUP(8,2,8,0)
        
        // copy args to outs
        mov         out0 = a0
        mov         out1 = a1
        mov         out2 = a2
        mov         out3 = a3
        mov         out4 = a4
        mov         out5 = a5
        mov         out6 = a6
        mov         out7 = a7
        ;;
        
        // Simply load the address and branch to it

        
        mov         gp   = a7
        ;;
        mov         bt0 =  a6
        ;;
        br.call.sptk brp = bt0
        ;;
        NESTED_RETURN
        
        NESTED_EXIT(HalpCallEfiVirtual)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64fw.h ===
//
//
//  Module name
//      i64fw.h
//  Author
//      Arad Rostampour (arad@fc.hp.com)    Mar-22-99
//  Description
//      Defines SAL/PAL data structures and prototypes
//

#ifndef _I64FW_H_
#define _I64FW_H_



#define SET_ITR_AND_DTR                              3
#define SET_DTR_ONLY                                 2
#define SET_ITR_ONLY                                 1

// TR for PAL is:
//    ed=1, PPN=0 (to be ORed in), RWX privledge only for ring 0, dirty/accessed bit set,
//    cacheable memory, present bit set.

#define HAL_SAL_PAL_TR_ATTRIB TR_VALUE(1,0,3,0,1,1,0,1)
#define HAL_TR_ATTRIBUTE_PPN_MASK    0x0000FFFFFFFFF000I64
#define HAL_RID_MASK 0x00000000FFFFFF00I64
#define HAL_RR_PS_VE 0x69
#define HAL_ITIR_PPN_MASK 0x7FFF000000000000I64
#define PAL_HIGHEST_STATIC_FUNCTION_ID 255


#define REGULAR_MEMORY     0
#define PAL_CODE_MEM       1
#define SAL_CODE_MEM       4
#define SAL_DATA_MEM       5
#define FW_RESERVED       12

#define FIRMWARE_CODE  4
#define FW_SAL_PAL     0

#define OEM_ID_LENGTH          RTL_NUMBER_OF_FIELD( SST_HEADER, OemId )
#define OEM_PRODUCT_ID_LENGTH  RTL_NUMBER_OF_FIELD( SST_HEADER, ProductId )

#define MASK_16KB           0xffffffffffffc000I64
#define MASK_16MB           0xffffffffff000000I64
#define SIZE_IN_BYTES_16KB                  16384

//
// Define the size of the stack and backing store needed by calls to the
// PAL and SAL.  PAL needs 8KB of each and SAL needs 16KB of each so we'll
// set this value to the larger of the two.  The EFI specification defers
// to the SAL specification when discussing stack and backing store needs
// for its runtime services so these stack sizes should accomodate EFI calls
// as well.
//

#define HALP_FW_MEMORY_STACK_SIZE  16384
#define HALP_FW_BACKING_STORE_SIZE 16384

//
// The stack and backing store for physical mode firmware calls are allocated
// in one large block.  These macros extract the top of the stack and the
// bottom of the backing store, respectively, given the base of the combined
// block.
//

#define GET_FW_STACK_POINTER(StackBase)             \
    ((StackBase) + HALP_FW_MEMORY_STACK_SIZE - 16) 

#define GET_FW_BACKING_STORE_POINTER(StackBase)     \
    ((StackBase) + HALP_FW_MEMORY_STACK_SIZE)

// SAL_STATUS and PAL_STATUS is a 64-bit copy of the value in ReturnValues[0]

typedef LONGLONG SAL_STATUS;
typedef LONGLONG PAL_STATUS;

// SAL and PAL return up to 4 64-bit return values; HalpSalCall() and
// HalpPalCall() will return a pointer to this structure

typedef struct _SAL_PAL_RETURN_VALUES {
    LONGLONG ReturnValues[4];
} SAL_PAL_RETURN_VALUES, *PSAL_PAL_RETURN_VALUES;


typedef struct _HAL_PLATFORM_ID {
    ANSI_STRING VendorId;
    ANSI_STRING DeviceId;
} HAL_PLATFORM_ID, *PHAL_PLATFORM_ID;

typedef struct _SST_MEMORY_LIST {
    ULONGLONG PhysicalAddress;
    ULONGLONG VirtualAddress;
    ULONGLONG Length;
    UCHAR     NeedVaReg;
    struct _SST_MEMORY_LIST *Next;
} SST_MEMORY_LIST, *PSST_MEMORY_LIST;

// Function Prototypes: SAL takes 8 arguments, PAL takes 4

VOID
HalpSetupTranslationRegisters(
    ULONGLONG VAddr,
    ULONGLONG PAddr,
    ULONG     PageSize,
    ULONG     TrNumber,
    ULONG     RidValue,
    ULONG     Mode
    );


SAL_STATUS
HalpSalCall(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    );

PAL_STATUS
HalpPalCall(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    );

//
// Define a function prototype for the virtual and physical mode SAL call
// dispatchers.
//

typedef
SAL_PAL_RETURN_VALUES
(*HALP_SAL_PROC) (
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3,
    LONGLONG Arg4,
    LONGLONG Arg5,
    LONGLONG Arg6,
    LONGLONG Arg7
    );

SAL_PAL_RETURN_VALUES
HalpSalProc(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3,
    LONGLONG Arg4,
    LONGLONG Arg5,
    LONGLONG Arg6,
    LONGLONG Arg7
    );

SAL_PAL_RETURN_VALUES
HalpSalProcPhysical(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3,
    LONGLONG Arg4,
    LONGLONG Arg5,
    LONGLONG Arg6,
    LONGLONG Arg7
    );

SAL_PAL_RETURN_VALUES
HalpSalProcPhysicalEx(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3,
    LONGLONG Arg4,
    LONGLONG Arg5,
    LONGLONG Arg6,
    LONGLONG Arg7,
    LONGLONG StackPointer,
    LONGLONG BackingStorePointer
    );

SAL_PAL_RETURN_VALUES
HalpPalProc(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3
    );

SAL_PAL_RETURN_VALUES
HalpPalProcPhysicalStatic(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3
    );

SAL_PAL_RETURN_VALUES
HalpPalProcPhysicalStacked(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3,
    LONGLONG StackPointer,
    LONGLONG BackingStorePointer
    );

NTSTATUS
HalpGetPlatformId(
    OUT PHAL_PLATFORM_ID PlatformId
    );

VOID
InternalTestSal(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    );

VOID
InternalTestPal(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    );

// For SAL cache flush

#define FLUSH_INSTRUCTION_CACHE          1
#define FLUSH_DATA_CACHE                 2
#define FLUSH_INSTRUCTION_AND_DATA_CACHE 3
#define FLUSH_COHERENT                   4

// iA-64 defined SAL function IDs in hex format as in the SAL spec

#define SAL_SET_VECTORS                              0x01000000I64
#define SAL_GET_STATE_INFO                           0x01000001I64
#define SAL_GET_STATE_INFO_SIZE                      0x01000002I64
#define SAL_CLEAR_STATE_INFO                         0x01000003I64
#define SAL_MC_RENDEZ                                0x01000004I64
#define SAL_MC_SET_PARAMS                            0x01000005I64
#define SAL_REGISTER_VIRTUAL_ADDR                    0x01000050I64
#define SAL_REGISTER_PHYSICAL_ADDR                   0x01000006I64
#define SAL_CACHE_FLUSH                              0x01000008I64
#define SAL_CACHE_INIT                               0x01000009I64
#define SAL_PCI_CONFIG_READ                          0x01000010I64
#define SAL_PCI_CONFIG_WRITE                         0x01000011I64
#define SAL_FREQ_BASE                                0x01000012I64
#define SAL_UPDATE_PAL                               0x01000020I64

// iA-64 defined SAL return values

#define SAL_STATUS_SUCCESS                                    0I64
#define SAL_STATUS_SUCCESS_WITH_OVERFLOW                      1I64
#define SAL_STATUS_SUCCESS_MORE_RECORDS                       3I64
#define SAL_STATUS_NOT_IMPLEMENTED                           -1I64
#define SAL_STATUS_INVALID_ARGUMENT                          -2I64
#define SAL_STATUS_ERROR                                     -3I64
#define SAL_STATUS_VA_NOT_REGISTERED                         -4I64
#define SAL_STATUS_NO_INFORMATION_AVAILABLE                  -5I64
#define SAL_STATUS_INSUFFICIENT_NVM_MEMORY                   -6I64
#define SAL_STATUS_INSUFFICIENT_SCRATCH_BUFFER               -7I64
#define SAL_STATUS_INVALID_INTERRUPT_VECTOR                  -8I64
#define SAL_STATUS_PARTITION_TYPE_EXISTS                     -9I64
#define SAL_STATUS_REQUESTED_MEMORY_UNAVAILABLE              -9I64
#define SAL_STATUS_UNABLE_TO_WRITE_NVM                      -10I64
#define SAL_STATUS_INVALID_PARTITION_TYPE                   -11I64
#define SAL_STATUS_INVALID_NVM_OBJECT_ID                    -12I64
#define SAL_STATUS_NVM_OBJECT_MAXIMUM_PARITIONS             -13I64
#define SAL_STATUS_INSUFFICIENT_SPACE_FOR_WRITE             -14I64
#define SAL_STATUS_INSUFFICIENT_SPACE_FOR_READ              -15I64
#define SAL_STATUS_SCRATCH_BUFFER_REQUIRED                  -16I64
#define SAL_STATUS_INSUFFICIENT_NVM_SPACE_FOR_SUBFUNCTION   -17I64
#define SAL_STATUS_INVALID_PARTITION_VALUE                  -18I64
#define SAL_STATUS_RECORD_ORIENTED_IO_NOT_SUPPORTED         -19I64
#define SAL_STATUS_BAD_RECORD_FORMAT_OR_KEYWORD_VARIABLE    -20I64

#define SAL_SUCCESSFUL( /* SAL_PAL_RETURN_VALUE */ _rv ) (((_rv).ReturnValues[0]) >= (LONGLONG)0)

//
// SAL descriptor types
//

typedef enum {
    SAL_PAL_ENTRY_POINT_TYPE = 0,
    SST_MEMORY_DESCRIPTOR_TYPE,
    PLATFORM_FEATURES_TYPE,
    TRANSLATION_REGISTER_TYPE,
    PTC_COHERENCE_DOMAIN_TYPE,
    AP_WAKEUP_DESCRIPTOR_TYPE
};

//
// IA64 PAL:  PAL_VERSION
//

typedef union _PAL_VERSION_STRUCT {
    struct {
        UCHAR         PAL_B_Revision;
        UCHAR         PAL_B_Model;
        UCHAR         PAL_Reserved1;
        UCHAR         PAL_Vendor;
        UCHAR         PAL_A_Revision;
        UCHAR         PAL_A_Model;
        UCHAR         PAL_Reserved2[2];
    };

    ULONGLONG ReturnValue;

}PAL_VERSION_STRUCT, *PPAL_VERSION_STRUCT;

//
// IA64 SAL: SAL_REVISION definitions
//

typedef union _SAL_REVISION {
    USHORT      Revision;           // Major and Minor revision:
    struct {
        UCHAR   Minor;              //  Byte0: Minor.
        UCHAR   Major;              //  Byte1: Major.
    };
} SAL_REVISION, *PSAL_REVISION;

#define HALP_SAL_REVISION_2_90  0x0290  /* v2.9 */
#define HALP_SAL_REVISION_MAX   0xffff

//
//  Format of the SAL System Table (SST) Header. SAL Specs July 2000, Revision: 2.9.
//  The SST is followed by a variable number of entries with varying length.
//

typedef struct _SST_HEADER {
    ULONG   Signature;
    ULONG   Length;
    USHORT  SalRev;
    USHORT  EntryCount;
    UCHAR   CheckSum;
    UCHAR   Reserved1[7];
    USHORT  Sal_A_Version;
    USHORT  Sal_B_Version;
    UCHAR   OemId[32];
    UCHAR   ProductId[32];
    UCHAR   Reserved2[8];
} SST_HEADER, *PSST_HEADER;

//
// Global Data used by the SAL/PAL support routines
//

// _HALP_SAL_PAL_DATA.Flags:
#define HALP_SALPAL_FIX_MCE_LOG_ID                   0x0001
#define HALP_SALPAL_FIX_MP_SAFE                      0x0002
#define HALP_SALPAL_CMC_BROKEN                       0x0004
#define HALP_SALPAL_CPE_BROKEN                       0x0008


typedef struct _HALP_SAL_PAL_DATA {
    PSST_HEADER         SalSystemTable;
    ULONGLONG           PalTrBase;
    ULONGLONG           PalTrSize;
    NTSTATUS            Status;
    SAL_REVISION        SalRevision;  // Copy of SalSystemTable.SalRev in case we unmap SST.
    USHORT              Flags;
    PAL_VERSION_STRUCT  PalVersion;
    PUCHAR              SmBiosVersion;
    ULONGLONG           Reserved[4];
} HALP_SAL_PAL_DATA, *PHALP_SAL_PAL_DATA;

#define SMBIOS_STRUCT_HEADER_TYPE_FIELD         0
#define SMBIOS_STRUCT_HEADER_LENGTH_FIELD       1
#define SMBIOS_STRUCT_HEADER_HANDLE_FIELD       2
#define SMBIOS_TYPE0_STRUCT_BIOSVER_FIELD       5

//
// Listing of Descriptors in the SAL System Table and their formats
//

typedef struct _SAL_PAL_ENTRY_POINT {
    UCHAR EntryType;
    UCHAR Reserved0[7];
    ULONGLONG PalEntryPoint;
    ULONGLONG SalEntryPoint;
    ULONGLONG GlobalPointer;
    UCHAR Reserved1[16];
} SAL_PAL_ENTRY_POINT, *PSAL_PAL_ENTRY_POINT;

typedef struct _SST_MEMORY_DESCRIPTOR {
    UCHAR EntryType;
    UCHAR NeedVaReg;
    UCHAR CurrentAttribute;
    UCHAR PageAccessRights;
    UCHAR SupportedAttribute;
    UCHAR Reserved1[1];
    UCHAR MemoryType;
    UCHAR MemoryUsage;
    ULONGLONG MemoryAddress;
    ULONG Length;
    UCHAR Reserved[4];
    UCHAR OemReserved[8];
} SST_MEMORY_DESCRIPTOR, *PSST_MEMORY_DESCRIPTOR;

typedef struct _PLATFORM_FEATURES {
    UCHAR EntryType;
    UCHAR FeatureList;
    UCHAR Reserved[14];
} PLATFORM_FEATURES, *PPLATFORM_FEATURES;

typedef struct _PTC_COHERENCE_DOMAIN {
    UCHAR EntryType;
    UCHAR Reserved[3];
    ULONG NumberOfDomains;
    ULONGLONG CoherenceDomainInfo;
} PTC_COHERENCE_DOMAIN, *PPTC_COHERENCE_DOMAIN;

typedef struct _COHERENCE_DOMAIN_INFO {
    ULONGLONG NumberOfProcessors;
    ULONGLONG LocalIdRegisters;
} COHERENCE_DOMAIN_INFO, *PCOHERENCE_DOMAIN_INFO;

typedef struct _AP_WAKEUP_DESCRIPTOR {
    UCHAR EntryType;
    UCHAR WakeupMechanism;
    UCHAR Reserved[6];
    ULONGLONG WakeupVector;
} AP_WAKEUP_DESCRIPTOR, *PAP_WAKEUP_DESCRIPTOR;

typedef struct _TRANSLATION_REGISTER {
    UCHAR EntryType;
    UCHAR TRType;
    UCHAR TRNumber;
    UCHAR Reserved1[5];
    ULONGLONG VirtualAddress;
    ULONGLONG PageSize;
    UCHAR Reserved2[8];
} TRANSLATION_REGISTER, *PTRANSLATION_REGISTER;

#endif // _I64FW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64fw.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64fw.c

Abstract:

    This module implements the routines that transfer control
    from the kernel to the PAL and SAL code.

Author:

    Arad Rostampour (arad@fc.hp.com)    Mar-21-99

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "arc.h"
#include "arccodes.h"
#include "i64fw.h"

#include <efi.h>


extern KSPIN_LOCK HalpSalSpinLock;
extern KSPIN_LOCK HalpSalStateInfoSpinLock;

BOOLEAN
MmSetPageProtection(
    IN PVOID VirtualAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG NewProtect
    );

VOID
HalpReboot (
    VOID
    );


HALP_SAL_PAL_DATA HalpSalPalData;
ULONGLONG HalpSalProcPointer=0;
ULONGLONG HalpSalProcGlobalPointer=0;
ULONGLONG HalpPhysSalProcPointer=0;
ULONGLONG HalpPhysSalProcGlobalPointer=0;
ULONGLONG HalpPhysPalProcPointer=0;
ULONGLONG HalpVirtPalProcPointer=0;

// Testing #defines
//
//#define SAL_TEST
//#define PAL_TEST

#if DBG
ULONG HalpDebugTestSalPalCall=0;
#endif


LONGLONG
HalCallPal(
    IN  ULONGLONG FunctionIndex,
    IN  ULONGLONG Arguement1,
    IN  ULONGLONG Arguement2,
    IN  ULONGLONG Arguement3,
    OUT PULONGLONG ReturnValue0,
    OUT PULONGLONG ReturnValue1,
    OUT PULONGLONG ReturnValue2,
    OUT PULONGLONG ReturnValue3
    )

/*++


--*/
{

    //
    // Will interface to PAL Calls.
    //
    LONGLONG Status;

    SAL_PAL_RETURN_VALUES rv = {0};
    PSAL_PAL_RETURN_VALUES p = &rv;

    Status = (LONGLONG) HalpPalCall(FunctionIndex,Arguement1,Arguement2,Arguement3,p);

    if (ReturnValue0 != 0) // Check the pointer is not NULL

        *ReturnValue0 = (ULONGLONG)(p -> ReturnValues[0]);

   if (ReturnValue1 != 0)  // check the pointer is not NULL

        *ReturnValue1 = (ULONGLONG)(p -> ReturnValues[1]);

   if (ReturnValue2 != 0)  // check the pointer is not NULL

        *ReturnValue2 = (ULONGLONG)(p -> ReturnValues[2]);

   if (ReturnValue3 != 0)  // check the pointer is not NULL

        *ReturnValue3 = (ULONGLONG)(p -> ReturnValues[3]);

    return Status;

}

SAL_PAL_RETURN_VALUES
HalpSalProcPhysical(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7
    )

/*++

Routine Description:

    This function is a wrapper for making a physical mode SAL call.  This
    function's only job is to provide the stack and backing store pointers
    needed by HalpSalProcPhysicalEx.

Arguments:

    FunctionId - The SAL function ID.

    Arg1 through Arg7 - The values to be passed to SAL_PROC.

Return Value:

    A SAL_PAL_RETURN_VALUES structure filled in with the data returned by
    HalpSalProcPhysicalEx.

--*/

{
    ULONGLONG StackPointer;
    ULONGLONG BackingStorePointer;
    ULONGLONG StackBase;

    //
    // Load the addresses of the stack and backing store reserved for
    // physical mode SAL calls on this processor.
    //

    StackBase = PCR->HalReserved[PROCESSOR_PHYSICAL_FW_STACK_INDEX];

    StackPointer = GET_FW_STACK_POINTER(StackBase);
    BackingStorePointer = GET_FW_BACKING_STORE_POINTER(StackBase);

    //
    // Branch to the assembly routine that makes the actual SAL call.
    //

    return HalpSalProcPhysicalEx(
                FunctionId,
                Arg1,
                Arg2,
                Arg3,
                Arg4,
                Arg5,
                Arg6,
                Arg7,
                (LONGLONG) StackPointer,
                (LONGLONG) BackingStorePointer
                );
}

SAL_STATUS
HalpSalCall(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    )
/*++

Routine Description:

    This function is a wrapper function for making a SAL call.  Callers within the
    HAL must use this function to call the SAL.

Arguments:

    FunctionId - The SAL function ID
    Arg1-Arg7 - SAL defined arguments for each call
    ReturnValues - A pointer to an array of 4 64-bit return values

Return Value:

    SAL's return status, return value 0, is returned in addition to the ReturnValues structure
    being filled

--*/

{
    KIRQL OldIrql;
    KIRQL TempIrql;
    BOOLEAN fixLogId;
    HALP_SAL_PROC SalProc;

    //
    // Zero out the return buffer.
    //

    RtlZeroMemory(ReturnValues,sizeof(SAL_PAL_RETURN_VALUES));

    //
    // Choose a SAL call dispatcher depending upon whether a virtual mapping
    // for the SAL exists.  If a virtual mapping isn't in place we'll try
    // to make the call in physical mode.  Return SAL_STATUS_NOT_IMPLEMENTED
    // if we aren't configured to make calls in either mode.
    //

    if (!NT_SUCCESS(HalpSalPalData.Status) || HalpSalProcPointer == 0) {

        //
        // We've already ruled out a virtual mode call.  If possible
        // we'll try to make an equivalent physical mode call in this
        // case.
        //

        if (HalpPhysSalProcPointer != 0) {
            SalProc = HalpSalProcPhysical;

        } else {
            return SAL_STATUS_NOT_IMPLEMENTED;
        }

    } else {
        SalProc = HalpSalProc;
    }


    fixLogId = (HalpSalPalData.Flags & HALP_SALPAL_FIX_MCE_LOG_ID) != 0;

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    switch (FunctionId) {

        // These calls are neither re-entrant, nor MP-safe as defined by the SAL spec

        case SAL_SET_VECTORS:
        case SAL_MC_SET_PARAMS:
        case SAL_FREQ_BASE:

            KiAcquireSpinLock(&HalpSalSpinLock);
            *ReturnValues = SalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
            KiReleaseSpinLock(&HalpSalSpinLock);
            break;

        case SAL_GET_STATE_INFO:
           KiAcquireSpinLock(&HalpSalStateInfoSpinLock);
           *ReturnValues = SalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
           if ( fixLogId && (ReturnValues->ReturnValues[0] >= (LONGLONG)0) )    {
              // ERROR_RECORD_HEADER.Id++
              *(PULONGLONG)((ULONGLONG)Arg3) = ++HalpSalPalData.Reserved[0];
           }
           KiReleaseSpinLock(&HalpSalStateInfoSpinLock);
           break;

        case SAL_GET_STATE_INFO_SIZE:
        case SAL_CLEAR_STATE_INFO:

           KiAcquireSpinLock(&HalpSalStateInfoSpinLock);
           *ReturnValues = SalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
           KiReleaseSpinLock(&HalpSalStateInfoSpinLock);
           break;

        case SAL_PCI_CONFIG_READ:
        case SAL_PCI_CONFIG_WRITE:

            KiAcquireSpinLock(&HalpSalSpinLock);
            *ReturnValues = SalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
            KiReleaseSpinLock(&HalpSalSpinLock);
            break;

        //
        // Move these to MP safe after SAL is fixed
        // Kernel ensures only one CACHE_FLUSH at a time
        //

        case SAL_CACHE_INIT:
        case SAL_CACHE_FLUSH:
            if ( HalpSalPalData.Flags & HALP_SALPAL_FIX_MP_SAFE )    {
                KiAcquireSpinLock(&HalpSalSpinLock);
                *ReturnValues = SalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
                KiReleaseSpinLock(&HalpSalSpinLock);
            }
            else
                *ReturnValues = SalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
            break;

        //
        // These SAL calls are MP-safe, but not re-entrant
        //

        case SAL_MC_RENDEZ:
            *ReturnValues = SalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
            break;

        //
        // These calls are not supported at this time
        //

        case SAL_UPDATE_PAL:  // needs end of firmware space to be mapped, and possible authentication code to execute

        default:
            ReturnValues->ReturnValues[0] = SAL_STATUS_NOT_IMPLEMENTED;
    }

    KeLowerIrql(OldIrql);

#ifdef SAL_TEST
    if (ReturnValues->ReturnValues[0] == SAL_STATUS_NOT_IMPLEMENTED) {
        InternalTestSal(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,ReturnValues);
    }
#endif

#if 0
// To avoid Kd hangs while flushing and then MP synchronization issues..
    HalDebugPrint(( HAL_INFO,
                    "HAL: Got out of SAL call #0x%I64x with status 0x%I64x and RetVals 0x%I64x, 0x%I64x, 0x%I64x\n",
                    FunctionId,
                    ReturnValues->ReturnValues[0],
                    ReturnValues->ReturnValues[1],
                    ReturnValues->ReturnValues[2],
                    ReturnValues->ReturnValues[3] ));
#endif

    return (ReturnValues->ReturnValues[0]);

}

PAL_STATUS
HalpPalCall(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    )

/*++

Routine Description:

    This function is a wrapper function for making a PAL call.  Callers within the
    HAL must use this function to call the PAL.

Arguments:

    FunctionId - The PAL function ID
    Arg1-Arg3 - PAL defined arguments for each call
    ReturnValues - A pointer to an array of 4 64-bit return values

Return Value:

    PAL's return status, return value 0, is returned in addition to the ReturnValues structure
    being filled

Assumptions:

    PAL is being called with psr.bn = 1 in all cases (not from an interrupted state)

--*/
{
    // Zero out the return buffer

    RtlZeroMemory(ReturnValues,sizeof(SAL_PAL_RETURN_VALUES));

    // Only allow PAL calls that are supported
    
    switch (FunctionId) {

        // Virtual mode PAL calls

        case PAL_CACHE_FLUSH:
        case PAL_CACHE_INFO:
        case PAL_CACHE_PROT_INFO:
        case PAL_CACHE_SUMMARY:
        case PAL_PTCE_INFO:
        case PAL_VM_INFO:
        case PAL_VM_PAGE_SIZE:
        case PAL_VM_SUMMARY:
        case PAL_PERF_MON_INFO:
        case PAL_MC_CLEAR_LOG:
        case PAL_MC_DRAIN:
        case PAL_MC_ERROR_INFO:
        case PAL_HALT_LIGHT:
        case PAL_PREFETCH_VISIBILITY:
        case PAL_SHUTDOWN:
        case PAL_FREQ_RATIOS:
        case PAL_VERSION:
        case PAL_MEM_ATTRIB:
        case PAL_DEBUG_INFO:
        case PAL_FIXED_ADDR:
        case PAL_FREQ_BASE:
        case PAL_PLATFORM_ADDR:
        case PAL_REGISTER_INFO:
        case PAL_RSE_INFO:

           // PAL is MP-safe, but not re-entrant, HalpPalProc/HalpPalProcPhysicalStatic disables interrupts.

           //
           // FIXFIX: Temporary solution to make sure we have a valid Pal TR per processor
           // to make virtual PAL calls. 
           // PCR->HalReserved[ PROCESSOR_PHYSICAL_FW_STACK_INDEX] gets set for every processor
           // by call to HalpAllocateProcessorPhysicalCallStacks during SalPal init
           //
            if (HalpVirtPalProcPointer && PCR->HalReserved[PROCESSOR_PHYSICAL_FW_STACK_INDEX]) {
      
                *ReturnValues = HalpPalProc(FunctionId,Arg1,Arg2,Arg3);

            } else if (HalpPhysPalProcPointer) {

                // call in physical mode
                *ReturnValues = HalpPalProcPhysicalStatic(FunctionId, Arg1, Arg2, Arg3);

            } else {

                // Hal PalProc pointers are not setup yet
                
                ReturnValues->ReturnValues[0] = PAL_STATUS_NOT_IMPLEMENTED;
            }
            
            break;

        // Physical mode, static PAL calls

        case PAL_HALT:
        case PAL_CACHE_INIT:
        case PAL_BUS_GET_FEATURES:
        case PAL_BUS_SET_FEATURES:
        case PAL_PROC_GET_FEATURES:
        case PAL_PROC_SET_FEATURES:
        case PAL_MC_DYNAMIC_STATE:
        case PAL_MC_EXPECTED:
        case PAL_MC_REGISTER_MEM:
        case PAL_MC_RESUME:
        case PAL_CACHE_LINE_INIT:
        case PAL_MEM_FOR_TEST:
        case PAL_COPY_INFO:
        case PAL_ENTER_IA_32_ENV:
        case PAL_PMI_ENTRYPOINT:

            //
            // PAL is MP-safe, but not re-entrant, HalpPalProcPhysicalStatic
            // disables interrupts.
            //

            if (HalpPhysPalProcPointer) {

                *ReturnValues = HalpPalProcPhysicalStatic(FunctionId, Arg1, Arg2, Arg3);

            } else {

                // Hal PalProc pointers are not setup yet

                ReturnValues->ReturnValues[0] = PAL_STATUS_NOT_IMPLEMENTED;
            }

            break;

        // Physical mode, stacked PAL calls

        case PAL_VM_TR_READ:
        case PAL_CACHE_READ:
        case PAL_CACHE_WRITE:
        case PAL_TEST_PROC:
        case PAL_COPY_PAL:
        case PAL_HALT_INFO:
        {
            ULONGLONG StackBase;
            ULONGLONG BackingStorePointer;
            ULONGLONG StackPointer;

            //
            // Load the addresses of the stack and backing store reserved for
            // physical mode PAL calls on this processor.
            //

            StackBase = PCR->HalReserved[PROCESSOR_PHYSICAL_FW_STACK_INDEX];

            StackPointer = GET_FW_STACK_POINTER(StackBase);
            BackingStorePointer = GET_FW_BACKING_STORE_POINTER(StackBase);

            //
            // PAL is MP-safe, but not re-entrant, HalpPalProcPhysicalStacked
            // disables interrupts.
            //
                
            if (HalpPhysPalProcPointer) {

                *ReturnValues = HalpPalProcPhysicalStacked(
                                    FunctionId,
                                    Arg1,
                                    Arg2,
                                    Arg3,
                                    (LONGLONG) StackPointer,
                                    (LONGLONG) BackingStorePointer
                                    );

            } else {

                // Hal PalProc pointers are not setup yet
                ReturnValues->ReturnValues[0] = PAL_STATUS_NOT_IMPLEMENTED;
            }
        }
            break;

        default:
            HalDebugPrint(( HAL_ERROR, "HAL: Unknown PAL Call ProcId #0x%I64x\n", FunctionId ));
            ReturnValues->ReturnValues[0] = PAL_STATUS_NOT_IMPLEMENTED;
    }

#ifdef PAL_TEST
    if (ReturnValues->ReturnValues[0] == PAL_STATUS_NOT_IMPLEMENTED) {
        InternalTestPal(FunctionId,Arg1,Arg2,Arg3,ReturnValues);
    }
#endif

#if 0
// To avoid Kd hangs while flushing...
    HalDebugPrint(( HAL_INFO,
                    "HAL: Got out of PAL call #0x%I64x with status 0x%I64x and RetVals 0x%I64x, 0x%I64x, 0x%I64x\n",
                    FunctionId,
                    ReturnValues->ReturnValues[0],
                    ReturnValues->ReturnValues[1],
                    ReturnValues->ReturnValues[2],
                    ReturnValues->ReturnValues[3] ));
#endif

    return (ReturnValues->ReturnValues[0]);
}


VOID
HalReturnToFirmware(
    IN FIRMWARE_ENTRY Routine
    )

/*++

Routine Description:

    Returns control to the firmware routine specified.  Since the simulation
    does not provide PAL and SAL support, it just stops the system.

    System reboot can be done here.

Arguments:

    Routine - Supplies a value indicating which firmware routine to invoke.

Return Value:

    Does not return.

--*/

{
    switch (Routine) {
    case HalHaltRoutine:
    case HalPowerDownRoutine:
    case HalRestartRoutine:
    case HalRebootRoutine:
        HalpReboot();
        break;

    default:
        HalDebugPrint(( HAL_INFO, "HAL: HalReturnToFirmware called\n" ));
        DbgBreakPoint();
        break;
    }
}

ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    )

/*++

Routine Description:

    This function locates an environment variable and returns its value.

     The following system environment variables are supported:

    variable                value

    LastKnownGood           FALSE
    SYSTEMPARTITION         multi(0)disk(0)rdisk(0)partition(1)
    OSLOADER                multi(0)disk(0)rdisk(0)partition(1)\osloader.exe
    OSLOADPARTITION         multi(0)disk(0)rdisk(0)partition(1)
    OSLOADFILENAME          \WINNT
    LOADIDENTIFIER          Windows NT
    COUNTDOWN               10
    AUTOLOAD                YES


    The only environment variable this implementation supports is
    "LastKnownGood".  The returned value is always "FALSE".

Arguments:

    Variable - Supplies a pointer to a zero terminated environment variable
        name.

    Length - Supplies the length of the value buffer in bytes.

    Buffer - Supplies a pointer to a buffer that receives the variable value.

Return Value:

    ESUCCESS is returned if the enviroment variable is located. Otherwise,
    ENOENT is returned.

--*/

{
    return ENOENT;
}


ARC_STATUS
HalSetEnvironmentVariable (
   IN PCHAR Variable,
   IN PCHAR Value
   )

/*++

Routine Description:

   This function creates an environment variable with the specified value.

   The environment variable this implementation supports is

   LastKnownGood
   SYSTEMPARTITION
   OSLOADER
   OSLOADPARTITION
   OSLOADFILENAME
   OSLOADOPTIONS
   LOADIDENTIFIER
   COUNTDOWN
   AUTOLOAD

   For all bug LastKnowGood we return ESUCCESS, but don't actually do
   anything.

Arguments:

   Variable - Supplies a pointer to an environment variable name.

   Value - Supplies a pointer to the environment variable value.

Return Value:

   ESUCCESS is returned if the environment variable is created. Otherwise,
   ENOMEM is returned.

--*/

{

   return ENOENT;

}

NTSTATUS
HalGetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    )

/*++

Routine Description:

    This function locates an environment variable and returns its value.

Arguments:

    VariableName - The name of the variable to query. This is a null-terminated
        Unicode string.

    VendorGuid - The GUID for the vendor associated with the variable.

    Value - The address of the buffer into which the variable value is to be copied.

    ValueLength - On input, the length in bytes of the Value buffer. On output,
        the length in bytes of the variable value. If the input buffer is large
        enough, then ValueLength indicates the amount of data copied into Value.
        If the input buffer is too small, then nothing is copied into the buffer,
        and ValueLength indicates the required buffer length.

    Attributes - Returns the attributes of the variable.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_VARIABLE_NOT_FOUND   The requested variable does not exist.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_UNSUPPORTED          The HAL does not support this function.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.

--*/

{
    NTSTATUS ntStatus;
    EFI_STATUS efiStatus;
    ULONGLONG wideValueLength = *ValueLength;
    ULONGLONG wideAttributes;

    efiStatus = HalpCallEfi (
                    EFI_GET_VARIABLE_INDEX,
                    (ULONGLONG)VariableName,
                    (ULONGLONG)VendorGuid,
                    (ULONGLONG)&wideAttributes,
                    (ULONGLONG)&wideValueLength,
                    (ULONGLONG)Value,
                    0,
                    0,
                    0
                    );

    *ValueLength = (ULONG)wideValueLength;
    if ( ARGUMENT_PRESENT(Attributes) ) {
        *Attributes = (ULONG)wideAttributes;
    }
    switch (efiStatus) {
    case EFI_SUCCESS:
        ntStatus = STATUS_SUCCESS;
        break;
    case EFI_NOT_FOUND:
        ntStatus = STATUS_VARIABLE_NOT_FOUND;
        break;
    case EFI_BUFFER_TOO_SMALL:
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        break;
    case EFI_INVALID_PARAMETER:
        ntStatus = STATUS_INVALID_PARAMETER;
        break;
    default:
        ntStatus = STATUS_UNSUCCESSFUL;
        break;
    }

    return ntStatus;
}

NTSTATUS
HalSetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    )

/*++

Routine Description:

   This function creates an environment variable with the specified value.

Arguments:

    VariableName - The name of the variable to set. This is a null-terminated
        Unicode string.

    VendorGuid - The GUID for the vendor associated with the variable.

    Value - The address of the buffer containing the new variable value.

    ValueLength - The length in bytes of the Value buffer.

    Attributes - The attributes of the variable. The attribute bit
        VARIABLE_ATTRIBUTE_NON_VOLATILE MUST be set.

Return Value:

    STATUS_SUCCESS                  The function succeeded.
    STATUS_INSUFFICIENT_RESOURCES   Not enough storage is available.
    STATUS_INVALID_PARAMETER        One of the parameters is invalid.
    STATUS_UNSUPPORTED              The HAL does not support this function.
    STATUS_UNSUCCESSFUL             The firmware returned an unrecognized error.

--*/

{
    NTSTATUS ntStatus;
    EFI_STATUS efiStatus;

    if ( (Attributes & VARIABLE_ATTRIBUTE_NON_VOLATILE) == 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // First, delete the old value, if it exists. This is necessary to ensure that
    // the attributes specified to this routine are correctly applied.
    //

    efiStatus = HalpCallEfi (
                    EFI_SET_VARIABLE_INDEX,
                    (ULONGLONG)VariableName,
                    (ULONGLONG)VendorGuid,
                    (ULONGLONG)0,           // Attributes
                    (ULONGLONG)0,           // ValueLength
                    (ULONGLONG)NULL,        // Value
                    0,
                    0,
                    0
                    );

    //
    // Now create the new variable, unless the ValueLength is zero. In that
    // case, the caller actually wanted the variable deleted, which we just did.
    //

    if (ValueLength != 0) {
        efiStatus = HalpCallEfi (
                        EFI_SET_VARIABLE_INDEX,
                        (ULONGLONG)VariableName,
                        (ULONGLONG)VendorGuid,
                        (ULONGLONG)EFI_VARIABLE_ATTRIBUTE,
                        (ULONGLONG)ValueLength,
                        (ULONGLONG)Value,
                        0,
                        0,
                        0
                        );
    }

    switch (efiStatus) {
    case EFI_SUCCESS:
        ntStatus = STATUS_SUCCESS;
        break;
    case EFI_NOT_FOUND:
        ntStatus = STATUS_VARIABLE_NOT_FOUND;
        break;
    case EFI_OUT_OF_RESOURCES:
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        break;
    case EFI_INVALID_PARAMETER:
        ntStatus = STATUS_INVALID_PARAMETER;
        break;
    default:
        ntStatus = STATUS_UNSUCCESSFUL;
        break;
    }

    return ntStatus;
}

NTSTATUS
HalEnumerateEnvironmentVariablesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    This function returns information about system environment variables.

Arguments:

    InformationClass - Specifies the type of information to return.

    Buffer - The address of the buffer that is to receive the returned data.
        The format of the returned data depends on InformationClass.

    BufferLength - On input, the length in bytes of the buffer. On output,
        the length in bytes of the returned data. If the input buffer is
        large enough, then BufferLength indicates the amount of data copied
        into Buffer. If the input buffer is too small, then BufferLength
        indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_UNSUPPORTED          The HAL does not support this function.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    EFI_STATUS efiStatus;
    PUCHAR currentPtr;
    PVARIABLE_NAME name;
    PVARIABLE_NAME_AND_VALUE nameAndValue;
    PVARIABLE_NAME previousEntry;
    PWCHAR previousName;
    ULONG variableNameLength;
    GUID guid;
    ULONG baseLength;
    ULONG remainingLength;
    PUCHAR valuePtr;
    ULONG valueLength;
    PULONG attrPtr;
    LOGICAL filling;
    ULONG requiredLength;

#define MAX_VARIABLE_NAME 255

    WCHAR variableName[MAX_VARIABLE_NAME + 1];

    if ( (InformationClass != VARIABLE_INFORMATION_NAMES) &&
         (InformationClass != VARIABLE_INFORMATION_VALUES) ) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( ALIGN_DOWN_POINTER(Buffer, ULONG) != Buffer ) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( InformationClass == VARIABLE_INFORMATION_NAMES ) {
        baseLength = FIELD_OFFSET( VARIABLE_NAME, Name );
    } else {
        baseLength = FIELD_OFFSET( VARIABLE_NAME_AND_VALUE, Name );
    }

    currentPtr = Buffer;
    remainingLength = *BufferLength;

    filling = (LOGICAL)(remainingLength != 0);
    if ( !filling ) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    previousEntry = NULL;

    variableName[0] = 0;

    while ( TRUE ) {

        variableNameLength = (MAX_VARIABLE_NAME + 1) * sizeof(WCHAR);

        {
            ULONGLONG wideLength = variableNameLength;

            efiStatus = HalpCallEfi (
                            EFI_GET_NEXT_VARIABLE_NAME_INDEX,
                            (ULONGLONG)&wideLength,
                            (ULONGLONG)variableName,
                            (ULONGLONG)&guid,
                            0,
                            0,
                            0,
                            0,
                            0
                            );

            variableNameLength = (ULONG)wideLength;
        }

        switch (efiStatus) {
        case EFI_SUCCESS:
            break;
        case EFI_NOT_FOUND:
            break;
        default:
            ntStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        if ( efiStatus != EFI_SUCCESS ) {
            break;
        }

        if ( ALIGN_UP_POINTER(currentPtr, ULONG) != currentPtr ) {
            PUCHAR alignedPtr = ALIGN_UP_POINTER( currentPtr, ULONG );
            ULONG fill = (ULONG)(alignedPtr - currentPtr);
            currentPtr = alignedPtr;
            if ( remainingLength < fill ) {
                filling = FALSE;
                remainingLength = 0;
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                remainingLength -= fill;
            }
        }

        requiredLength = baseLength + variableNameLength;
        if ( InformationClass != VARIABLE_INFORMATION_NAMES ) {
            requiredLength = ALIGN_UP( requiredLength, ULONG );
        }

        if ( remainingLength < requiredLength ) {

            remainingLength = 0;
            filling = FALSE;
            ntStatus = STATUS_BUFFER_TOO_SMALL;

        } else {

            remainingLength -= requiredLength;
        }

        name = (PVARIABLE_NAME)currentPtr;
        nameAndValue = (PVARIABLE_NAME_AND_VALUE)currentPtr;

        if ( InformationClass == VARIABLE_INFORMATION_NAMES ) {

            if ( filling ) {

                RtlCopyMemory( &name->VendorGuid, &guid, sizeof(GUID) );
                wcscpy( name->Name, variableName );

                if ( previousEntry != NULL ) {
                    previousEntry->NextEntryOffset = (ULONG)(currentPtr - (PUCHAR)previousEntry);
                }
                previousEntry = (PVARIABLE_NAME)currentPtr;
            }

            currentPtr += requiredLength;

        } else {

            ULONGLONG wideLength;
            ULONGLONG wideAttr;

            if ( filling ) {

                RtlCopyMemory( &nameAndValue->VendorGuid, &guid, sizeof(GUID) );
                wcscpy( nameAndValue->Name, variableName );

                valuePtr = (PUCHAR)nameAndValue->Name + variableNameLength;
                valuePtr = ALIGN_UP_POINTER( valuePtr, ULONG );
                valueLength = remainingLength;
                attrPtr = &nameAndValue->Attributes;

                nameAndValue->ValueOffset = (ULONG)(valuePtr - (PUCHAR)nameAndValue);

            } else {

                valuePtr = NULL;
                valueLength = 0;
                attrPtr = NULL;
            }

            wideLength = valueLength;

            efiStatus = HalpCallEfi (
                            EFI_GET_VARIABLE_INDEX,
                            (ULONGLONG)variableName,
                            (ULONGLONG)&guid,
                            (ULONGLONG)&wideAttr,
                            (ULONGLONG)&wideLength,
                            (ULONGLONG)valuePtr,
                            0,
                            0,
                            0
                            );

            valueLength = (ULONG)wideLength;
            if ( attrPtr != NULL ) {
                *attrPtr = (ULONG)wideAttr;
            }

            switch (efiStatus) {
            case EFI_SUCCESS:
                if ( filling ) {
                    nameAndValue->ValueLength = valueLength;
                    remainingLength -= valueLength;
                    if ( previousEntry != NULL ) {
                        previousEntry->NextEntryOffset = (ULONG)(currentPtr - (PUCHAR)previousEntry);
                    }
                    previousEntry = (PVARIABLE_NAME)currentPtr;
                }
                break;
            case EFI_BUFFER_TOO_SMALL:
                efiStatus = EFI_SUCCESS;
                remainingLength = 0;
                filling = FALSE;
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            default:
                ntStatus = STATUS_UNSUCCESSFUL;
                break;
            }

            if ( efiStatus != EFI_SUCCESS ) {
                break;
            }

            currentPtr += requiredLength + valueLength;
        }
    }

    if ( previousEntry != NULL ) {
        previousEntry->NextEntryOffset = 0;
    }

    *BufferLength = (ULONG)(currentPtr - (PUCHAR)Buffer);

    return ntStatus;
}

NTSTATUS
HalpGetPlatformId(
    OUT PHAL_PLATFORM_ID PlatformId
    )
/*++

Routine Description:

    This function fills in the ANSI_STRING structures for the Vendor and Device IDs out
    of the SalSystemTable.

Arguments:

    PlatformId - Pointer to a structure with two ANSI_STRING structures for Vendor/DeviceIds

Return Value:

    STATUS_SUCCESS if SalSystemTable available, otherwise STATUS_UNSUCCESSFUL

Assumptions:

    The two strings in PlatformId will not be freed or modified, and are therefore pointing
    directly to the SalSystemTable.

--*/

{
    UCHAR i;

    // Initialize the VendorId ANSI_STRING structure to point to SalSystemTable entry
    // Note, both strings are either NULL terminated OR exactly 32-bytes in length and
    // not NULL terminated.

    if (!NT_SUCCESS(HalpSalPalData.Status)) {
        return STATUS_UNSUCCESSFUL;
    }

    i=0;;
    while (HalpSalPalData.SalSystemTable->OemId[i] && i < OEM_ID_LENGTH) {
        i++;
    }
    PlatformId->VendorId.Buffer = HalpSalPalData.SalSystemTable->OemId;
    PlatformId->VendorId.Length = i;
    PlatformId->VendorId.MaximumLength = i;

    // Initialize the DeviceId ANSI_STRING structure to point to SalSystemTable entry

    i=0;
    while (HalpSalPalData.SalSystemTable->ProductId[i] && i < OEM_PRODUCT_ID_LENGTH) {
        i++;
    }
    PlatformId->DeviceId.Buffer = HalpSalPalData.SalSystemTable->ProductId;
    PlatformId->DeviceId.Length = i;
    PlatformId->DeviceId.MaximumLength = i;

    return STATUS_SUCCESS;
}


/*****************************************************************
TEST CODE FOR THE SAL AND PAL:

  These routines provide an infrastructure for supporting SAL and
  PAL calls not supported by firmware, overriding there meaning
  if SAL or PAL returns STATUS_NOT_IMPLEMENTED.  The #define for
  SAL_TEST and/or PAL_TEST must be defined for this behavior.

*****************************************************************/
ULONG
NoSalPCIRead(
    IN ULONG Tok,
    IN ULONG Size
    )
{
    ULONG Data;
    ULONG i = Tok % sizeof(ULONG);

    WRITE_PORT_ULONG((PULONG)0xcf8, 0x80000000 | Tok);
    switch (Size) {
        case 1: Data = READ_PORT_UCHAR((PUCHAR)(ULongToPtr(0xcfc + i) )); break;
        case 2: Data = READ_PORT_USHORT((PUSHORT)(ULongToPtr(0xcfc + i) )); break;
        case 4: Data = READ_PORT_ULONG((PULONG)(0xcfc)); break;
    }
    return(Data);
}

VOID
NoSalPCIWrite(
    IN ULONG Tok,
    IN ULONG Size,
    IN ULONG Data
    )
{
    ULONG i = Tok % sizeof(ULONG);

    WRITE_PORT_ULONG((PULONG)0xcf8, 0x80000000 | Tok);
    switch (Size) {
        case 1: WRITE_PORT_UCHAR((PUCHAR)(ULongToPtr(0xcfc + i) ), (UCHAR)Data); break;
        case 2: WRITE_PORT_USHORT((PUSHORT)(ULongToPtr(0xcfc + i) ), (USHORT)Data); break;
        case 4: WRITE_PORT_ULONG((PULONG)(0xcfc), Data); break;
    }
}


#define PCIBUS(Tok) (((ULONG)(Tok) >> 16) & 0xff)
#define PCIDEV(Tok) (((ULONG)(Tok) >> 11) & 0x1f)
#define PCIFUNC(Tok) (((ULONG)(Tok) >> 8) & 0x7)
#define PCIOFF(Tok)  (((ULONG)(Tok) >> 2) & 0x3f)

VOID
InternalTestSal(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    )
{
    switch (FunctionId) {

        case SAL_PCI_CONFIG_READ: {
            ULONG Data;
            HalDebugPrint(( HAL_INFO, "HAL: << SAL_PCI_CONFIG_READ - Bus: %d Dev: %2d Func: %d  Off: %2d Size = %d ",
                            PCIBUS(Arg1), PCIDEV(Arg1), PCIFUNC(Arg1), PCIOFF(Arg1), Arg2 ));
            ReturnValues->ReturnValues[0] = SAL_STATUS_SUCCESS;
            ReturnValues->ReturnValues[1] = Data = NoSalPCIRead((ULONG)Arg1, (ULONG)Arg2);
            HalDebugPrint(( HAL_INFO, " Data = 0x%08x\n", Data ));
            break;
        }

        case SAL_PCI_CONFIG_WRITE:
            HalDebugPrint(( HAL_INFO, "HAL: >> SAL_PCI_CONFIG_WRITE: Bus: %d Dev: %2d Func: %d Off: %2d  Size = %d Val = 0x%08x\n",
                            PCIBUS(Arg1), PCIDEV(Arg1), PCIFUNC(Arg1), PCIOFF(Arg1), Arg2, Arg3 ));
            NoSalPCIWrite((ULONG)Arg1, (ULONG)Arg2, (ULONG)Arg3);
            ReturnValues->ReturnValues[0] = SAL_STATUS_SUCCESS;
            break;

        default:
            ReturnValues->ReturnValues[0] = SAL_STATUS_NOT_IMPLEMENTED;
    }
}

VOID
InternalTestPal(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    )
{

    switch (FunctionId) {

        default:
            ReturnValues->ReturnValues[0] = SAL_STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64krnl.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64krnl.c

Abstract:

    This module implements the kernel support routines for the HAL DLL.

Author:

   Bernard Lint
   M. Jayakumar (Muthurajan.Jayakumar@intel.com)
   14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "i64fw.h"
#include "check.h"
#include "osmca.h"
#include "iosapic.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"

#define GreaterThan4GB      0x100000000

#define VideoBiosFirstPage  0x60
#define VideoBiosLastPage   0x67

VOID
HalpInitReservedPages(
    VOID
    );

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

extern ADDRESS_USAGE HalpDefaultPcIoSpace;
extern ULONGLONG HalpITCFrequency;
extern ULONGLONG HalpProcessorFrequency;
extern ULONG HalpOsBootRendezVector;

ULONG HalpBusType;

ULONGLONG PhysicalIOBase;

static short HalpOwnDisplay = TRUE;

PULONGLONG InterruptBlock;

extern KEVENT HalpNewAdapter;

extern ULONGLONG HalpPhysPalProcPointer;
extern ULONGLONG HalpPhysSalProcPointer;
extern ULONGLONG HalpPhysSalProcGlobalPointer;

extern ULONG     HalpPlatformPropertiesEfiFlags;

BOOLEAN HalpVideoBiosPresent;

//
// When Accessing IO SAPIC, HalpIoSapicLock is acquired and released
//

KSPIN_LOCK HalpIoSapicLock;

PHYSICAL_ADDRESS INTERRUPT_BLOCK_ADDRESS = { 0x0FEE00000 };

//
// Thierry - 10/01/2000 - Do NOT check the HALP_FIX_KD_HALIA64_MASK related
//                        code and data in the tree.
//
// This is to allow us to enable HAL_INFO level or other desired mask.
// The current debugger does not allow this and it should.
//

// #define HALP_FIX_KD_HALIA64_MASK  1

ULONG HalpFixKdHalia64Mask = 0;


VOID
HalpInitializeInterruptBlock (
    VOID
    )

/*++

Routine Description:

    Map Interrupt Block used for IPI. The size of the IPI area is 1MB.

Arguements:

    None

Return Value:

    None

--*/

{
    InterruptBlock = (PULONGLONG) HalpMapPhysicalMemory (
                                      INTERRUPT_BLOCK_ADDRESS,
                                      256,
                                      MmNonCached);
    return;
}

VOID
HalpCalibrateTB (
    )

/*++

Routine Description:

    This function calibrates the time base by determining the frequency
    that the ITC is running at to determine the interval value for a
    100 ns time increment (used by clock and profile).

 Arguments:

    None.

 Return Value:

    None.

*/

{
    return;
}



VOID
HalpFlushTLB (
    VOID
    )
{
    return;
}



BOOLEAN
HalAllProcessorsStarted (
    VOID
    )

/**++

Routine Description:

    This function returns TRUE if all the processors in the system started
    successfully.

Arguments:

    None.

Return Value:

    Returns TRUE.
--**/

{
    return TRUE;
}


VOID
HalpIpiInterruptHandler(
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by inter
    processor communication.

Arguments:

    Interrupt - Interrupt object address

    TrapFrame - Trap frame address

Return Value:

    None.

--*/
{

    KeIpiInterrupt(TrapFrame);

    return;

}


VOID
HalpSendIPI(
    IN USHORT ProcessorID,
    IN ULONGLONG Data
    )

/*++

Routine Description:

    This function sends IPI to the processor specified.

Arguements:

    ProcessorID   - Supplies the ID of processor to IPI.

    Data          - The formatted Data ready to ship it as IPI.

Return Value:

    None.

--*/
{

    PULONGLONG Address;
    ULONG  tmp1;
    KIRQL OldIrql;

    tmp1 = ProcessorID << IPI_ID_SHIFT;

    Address = (PULONGLONG)((UINT_PTR)(InterruptBlock) + tmp1);

    *(volatile ULONGLONG *)Address = Data;

    return;

}

NTSTATUS
HalpSendCrossPartitionIpi(
    IN USHORT ProcessorID,
    IN UCHAR  HardwareVector
    )

/*++

Routine Description:

    This function sends a cross partition IPI to the processor
    specified.  The caller must know that this processor is in another
    partition and the hardware vector previously reserved for
    receiving cross partition IPIs.

Arguements:

    ProcessorID   - Supplies the ID of processor to IPI.

    HardwareVector - Hardware Vector on remote processor that will
                     receive the interrupt.

Return Value:

    NTSTATUS

--*/
{
    ULONGLONG Data;

    if (HardwareVector < 16) {
        return STATUS_INVALID_PARAMETER;
    }

    Data = HardwareVector | DELIVER_FIXED;
    HalpSendIPI(ProcessorID, Data);

    return STATUS_SUCCESS;
}

VOID
HalpOSRendez (
    IN USHORT ProcessorID
    )

/*++

Routine Description:

   This function does IPI to start the next processor.

Arguements:

   PhysicalNumber  - Supplies the physical number of processor to IPI.

Return Value:

   None.

--*/

{
    HalpSendIPI ( ProcessorID, HalpOsBootRendezVector);
    return;
}

BOOLEAN
HalStartNextProcessor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PKPROCESSOR_STATE ProcessorState
    )

/*++

Routine Description:

    This function is called to start the next processor.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block.

    ProcessorState - Supplies a pointer to the processor state to be
        used to start the processor.

Return Value:

    If a processor is successfully started, then a value of TRUE is
    returned. Otherwise a value of FALSE is returned. If a value of
    TRUE is returned, then the logical processor number is stored
    in the processor control block specified by the loader block.

--*/

{
    ULONG  count;
    ULONGLONG   EntryPoint;
    ULONG ProcNumber = ((PKPRCB)LoaderBlock->Prcb)->Number;
    SAL_PAL_RETURN_VALUES SalReturn;
    SAL_STATUS salStatus;
    NTSTATUS ntStatus;
    USHORT TargetProcessorID;

    if (HalpAcpiNumProcessors() <= ProcNumber) {
       return (FALSE);
    }

    //
    // Boot OS rendezvous entry point
    //

    EntryPoint = ProcessorState->ContextFrame.StIIP;
    salStatus = HalpSalCall(SAL_SET_VECTORS,
                2 /* Boot rendz */,
                (ULONGLONG)(MmGetPhysicalAddress((PUCHAR)EntryPoint).QuadPart),
                0,
                0,
                0,
                0,
                0,
                &SalReturn);

    if (salStatus != 0) {
        HalDebugPrint(( HAL_ERROR, "HAL: HalStartNextProcessor - Cannot register OS rendezvous with SAL for processor %d\n",
                        ProcNumber ));
        return (FALSE);
    }

    //
    // For ia64, we will assume that the processor is ready  and not started
    //

    //
    // Start the next processor, if Processor ID not self
    //


    ntStatus = HalpGetApicIdByProcessorNumber((UCHAR)ProcNumber, &TargetProcessorID);

    if (!NT_SUCCESS(ntStatus)) {

        return FALSE;
    }

    HalpOSRendez(TargetProcessorID);

    count = 0;

    while (*((volatile ULONG_PTR *)&LoaderBlock->Prcb) != 0 && (count < RENDEZ_TIME_OUT)) {
        KeStallExecutionProcessor (1000);    // 1000000
        count++;
    } // end while (count < RENDEZ_TIMEOUT)

    if (LoaderBlock->Prcb != 0) {
        return (FALSE);
    } else {
        return (TRUE);
    }
}



VOID
HalRequestIpi (
    IN KAFFINITY Mask
    )

/*++

Routine Description:

    This function does nothing on a uni-processor platform.

Arguments:

    Mask - A mask that specifies the target processor(s) to which an
           IPI is to be sent.

Return Value:

    None.

--*/

{
    USHORT  LogicalCpu;
    USHORT  ProcessorID;

    //
    // Make sure we don't try and IPI processors that we don't believe are
    // started
    //

    Mask &= HalpActiveProcessors;

    //
    // Scan the processor set and request an interprocessor interrupt on
    // each of the specified targets.
    //

    for (LogicalCpu = 0; LogicalCpu < HalpMpInfo.ProcessorCount; LogicalCpu++) {

        if ((Mask & ((KAFFINITY)1 << HalpProcessorInfo[LogicalCpu].NtProcessorNumber)) != 0)  {

            ProcessorID = HalpProcessorInfo[LogicalCpu].LocalApicID;

            //
            // Request interprocessor interrupt on target physicalCpu.
            //

            HalpSendIPI(ProcessorID, IPI_VECTOR);
        }
    }
}





VOID
HalProcessorIdle (
    VOID
    )

/*++

Routine Description:

    This function calls the TAL function to halt the processor.

Arguments:

    None.

Return Value:

    None.

--*/


{
    _enable();
}

#if !defined(NO_LEGACY_DRIVERS)


BOOLEAN
HalMakeBeep (
    IN ULONG Frequency
    )

/*++

Routine Description:

    This function calls SSC function SscMakeBeep() to make a beep sound
    when the specified frequency has a non-zero value.

Arguments:

    Frequency - the frequency of the sound to be made.

Return Value:

    None.

--*/

{
    if (Frequency > 0) {

        SscMakeBeep(Frequency);
    }
    return TRUE;
}

#endif // NO_LEGACY_DRIVERS


VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    )

/**
Routine Description:

    This function stalls the processor.

Arguments:

    MicroSeconds - Number of microseconds to stall the processor.

Return Value:

    None.

**/

{
    ULONGLONG CurrentITC;
    ULONGLONG LimitITC;

    CurrentITC = HalpReadITC();

    LimitITC = CurrentITC + (ULONGLONG) (HalpITCTicksPer100ns * 10 * MicroSeconds);

    while (LimitITC > CurrentITC) {

        KeYieldProcessor();
        CurrentITC = HalpReadITC();
    }

    return;
}


VOID HalpInitLINT(VOID);

VOID
HalInitializeProcessor (
     ULONG Number,
     PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function is called early in the initialization of the kernel
    to perform platform dependent initialization for each processor
    before the HAL Is fully functional.

    N.B. When this routine is called, the PCR is present but is not
         fully initialized.

Arguments:

    Number - Supplies the number of the processor to initialize.

Return Value:

    None.

--*/


{

    // 
    // If this is the BSP then prepare the HAL to make physical mode firmware 
    // calls on this processor.  This duplicates some of what is later done
    // by HalpAllocateProcessorPhysicalCallStacks on the APs in order to
    // facilitate physical mode calls on the BSP before EFI initialization.
    //

    if (Number == 0) {
        ULONG Length;
        PVOID Block;

        Length = HALP_FW_MEMORY_STACK_SIZE + HALP_FW_BACKING_STORE_SIZE;

        //
        // Allocate sufficient stack and backing store for calls to
        // the firmware.
        //

        Block = HalpAllocPhysicalMemory(LoaderBlock,
                                        MAXIMUM_PHYSICAL_ADDRESS,
                                        Length >> PAGE_SHIFT,
                                        FALSE);
        if (Block == NULL) {
            HalDebugPrint((HAL_ERROR, "HAL_INIT: can't allocate stack space "
                                      "for physical mode firmware calls.\n"));

        } else {

            //
            // Store a pointer to the firmware stacks in the PCR.
            //

            PCR->HalReserved[PROCESSOR_PHYSICAL_FW_STACK_INDEX] =
                (ULONGLONG) Block;

            //
            // Load the physical addresses of SAL_PROC and the SAL GP.
            //

            HalpPhysSalProcPointer = LoaderBlock->u.Ia64.Sal.PhysicalAddress;
            HalpPhysSalProcGlobalPointer
                = LoaderBlock->u.Ia64.SalGP.PhysicalAddress;

            //
            // Load the physical address of PAL_PROC.
            //

            HalpPhysPalProcPointer = LoaderBlock->u.Ia64.Pal.PhysicalAddress;
        }
    }

    //
    // Add this processor to the interrupt affinity mask
    //

    HalpDefaultInterruptAffinity |= 1 << Number;

    //
    // Turn off LINT0 LINT1 (disable 8259)
    //

    // __setReg(CV_IA64_SaLRR0, 0x10000);
    // __setReg(CV_IA64_SaLRR1, 0x10000);
    //

    HalpInitLINT();
    __dsrlz();


    PCR->StallScaleFactor = 0;

    //
    // Save my processor ID in PCR
    //

    PCR->HalReserved[PROCESSOR_ID_INDEX] = HalpReadLID() >> 16;

    if (Number == 0) {

        HalpInitCacheInfo(LoaderBlock->u.Ia64.ProcessorConfigInfo.CacheFlushStride);

        //
        // No need to Initialize the virtual address mapping for IO port space
        // since loader/MM do that
        //

        PhysicalIOBase = LoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].PhysicalAddress;

        //
        // Initialize HAL global PlatformProperties EFI flags with loader value.
        //

        HalpPlatformPropertiesEfiFlags = LoaderBlock->u.Ia64.EfiMemMapParam.InitialPlatformPropertiesEfiFlags;

        //
        // This next call has nothing to do with processor init.
        // But this is the only function in the HAL that gets
        // called before KdInit.
        //

        HalpRegisterKdSupportFunctions(LoaderBlock);
    }
}

VOID
HalpRegisterInternalInterrupts(
    VOID
    )
/*++

Routine Description:

    This function reserves the known HAL IA64 resources usage and
    registers the IDT vectors usage.

Arguements:

    None.

Return Value:

    None.

--*/
{
    ULONG i;

    //
    // Make sure all vectors 00-2f, c0-ff are reserved
    // 00-0E Passive    Reserved by Intel
    // 0F    SAPIC Spurious Interrupt Vector Reserved
    // 10-1F APC priority level   Reserved
    // 20-2F DPC priority level   Reserved
    // c0-ff clock, ipi, synch, high
    // these are reserved in HalpGetSystemInterruptVector()
    // Do not report to IoReportHalResourceUsage()
    //

    for(i=0; i < PRIMARY_VECTOR_BASE; i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }


    //
    // Make sure all the interrupts in the SYNCH IRQL range are
    // also reserved.
    //

    for(i= SYNCH_VECTOR; i < (SYNCH_VECTOR+16); i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }

   //
   // Make sure all the interrupts in the IPI IRQL range are also
   // reserved.
   //

    for(i= IPI_VECTOR; i < (IPI_VECTOR+16); i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }


   //
   // Make sure all the interrupts in the CLOCK IRQL range are also
   // reserved.
   //

    for(i= CLOCK_VECTOR; i < (CLOCK_VECTOR+16); i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }

   //
   // Make sure all interrupts in the PROFILE IRQL range also are
   // reserved.
   //

    for(i= PROFILE_VECTOR; i < (PROFILE_VECTOR+16); i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }

    HalpRegisterVector (
         0,
         SAPIC_SPURIOUS_VECTOR,
         SAPIC_SPURIOUS_VECTOR,
         SAPIC_SPURIOUS_LEVEL
         );

    HalpRegisterVector (
         0,
         (APC_LEVEL << VECTOR_IRQL_SHIFT),
         (APC_LEVEL << VECTOR_IRQL_SHIFT),
         APC_LEVEL
         );

    HalpRegisterVector (
         0,
         (DPC_LEVEL << VECTOR_IRQL_SHIFT),
         (DPC_LEVEL << VECTOR_IRQL_SHIFT),
         DPC_LEVEL
         );

    HalpRegisterVector (
         0,
         MC_RZ_VECTOR,
         MC_RZ_VECTOR,
         HIGH_LEVEL
         );

    HalpRegisterVector (
         0,
         MC_WKUP_VECTOR,
         MC_WKUP_VECTOR,
         HIGH_LEVEL
         );

    //
    // Note that it is possible that HAL_CMC_PRESENT is not set.
    // With the current implementation, we always register the CMC vector.
    //

    HalpRegisterVector (
         0,
         CMCI_VECTOR,
         CMCI_VECTOR,
         CMCI_LEVEL
         );

    //
    // Note that it is possible that HAL_CPE_PRESENT is not set.
    // With the current implementation, we always register the CPE vector.
    //

    HalpRegisterVector (
         0,
         CPEI_VECTOR,
         CPEI_VECTOR,
         CPEI_LEVEL
         );

    HalpRegisterVector (
         0,
         SYNCH_VECTOR,
         SYNCH_VECTOR,
         SYNCH_LEVEL
         );

    HalpRegisterVector (
         0,
         IPI_VECTOR,
         IPI_VECTOR,
         IPI_LEVEL
         );


    HalpRegisterVector (
         0,
         CLOCK_VECTOR,
         CLOCK_VECTOR,
         CLOCK_LEVEL
         );

    HalpRegisterVector (
         0,
         PROFILE_VECTOR,
         PROFILE_VECTOR,
         PROFILE_LEVEL
         );

    HalpRegisterVector (
         0,
         PERF_VECTOR,
         PERF_VECTOR,
         PROFILE_LEVEL
         );

    return;

} // HalpRegisterInternalInterrupts()


VOID
HalpPerfInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:


Arguements:


Return Parameters:


--*/

{

// Thierry: This interrupt handler could be used to implement instructions
//          tracing based on the overflow interrupts generated by PMU events
//          like "retired instructions" or "taken branches".
//          This would provide very valuable inputs for hardware performance simulators.
//
// XXTF - not implemented yet...
    return;

} // HalpPerfInterrupt()



#if defined(HALP_FIX_KD_HALIA64_MASK)
#if DBG

VOID
HalpSetKdHalia64Mask(
   ULONG Mask
   )
//
// Mask == 0 should return without modifying Kd_HALIA64_Mask.
//
{
   NTSTATUS status;
   ULONG    level, levelMasked;
   int      shift;

   if ( Mask == (ULONG)-1 )   {
      status = DbgSetDebugFilterState( DPFLTR_HALIA64_ID, -1, TRUE );
      if ( !NT_SUCCESS(status) ) {
         HalDebugPrint(( HAL_ERROR,
               "HAL!HalInitSystem: failed to set Kd_HALIA64_Mask to maximum debug spew... 0x%lx\n",
               status ));
      }
      return;
   }

   level = levelMasked = Mask & HALIA64_DPFLTR_MAXMASK;
   shift = 0;
   while( level )  {
      level &= 0x1;
      if ( level )    {
        status = DbgSetDebugFilterState( DPFLTR_HALIA64_ID, shift, TRUE );
        if ( !NT_SUCCESS(status) ) {
            HalDebugPrint(( HAL_ERROR,
                         "HAL!HalInitSystem: failed to set Kd_HALIA64_Mask to 0x%lx... 0x%lx\n",
                         shift,
                         status ));
            break;
        }
      }
      shift = shift + 1;
      level = levelMasked >> shift;
    }

    return;

} // HalpSetKdHalia64Mask()

#else  // !DBG

#define HalpSetKdHalia64Mask()

#endif // !DBG
#endif // HALP_FIX_KD_HALIA64_MASK




BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    ia64 system.

Arguments:

    None.

Return Value:

    A value of TRUE is returned is the initialization was successfully
    complete. Otherwise a value of FALSE is returned.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PLIST_ENTRY NextMd;
    PKPRCB      pPRCB;
    volatile KPCR * const pPCR = KeGetPcr();
    BOOLEAN     Found;

    ULONGLONG   ITCFrequencyQueried;
    ULONGLONG   ProcessorFrequencyQueried;

    ULONG       RTCInti;

    KIRQL       OldIrql;
    NTSTATUS    status;

    //
    // This is for testing RTC clock
    //

    TIME_FIELDS CurrentTimeFields;

    pPRCB = KeGetCurrentPrcb();

    if (Phase == 0) {

        extern VOID DetectAcpiMP();
        BOOLEAN IsMP;
        BOOLEAN EnableInterrupts;

        //
        // Phase 0 initialization only called by P0
        //
        HalpBusType = LoaderBlock->u.Ia64.MachineType & 0x00ff;
        HalpGetParameters (LoaderBlock);


                //
        // Disable Interrupts before messing around with the APIC etc.
        //

        EnableInterrupts = HalpDisableInterrupts();

        DetectAcpiMP(&IsMP, LoaderBlock);

        HalpSetupAcpiPhase0(LoaderBlock);

        //
        // Verify Prcb version and build flags conform to
        // this image
        //

        if (pPRCB->MajorVersion != PRCB_MAJOR_VERSION) {
            KeBugCheckEx (
                MISMATCHED_HAL,
                1,
                pPRCB->MajorVersion,
                PRCB_MAJOR_VERSION,
                0
                );
        }

        KeInitializeSpinLock(&HalpIoSapicLock);

        //
        // Fill in handlers for APIs which this hal supports
        //

        HalQuerySystemInformation = HaliQuerySystemInformation;
        HalSetSystemInformation = HaliSetSystemInformation;
        HalInitPnpDriver = HaliInitPnpDriver;

        //
        // HalGetDmaAdapter was commented in previous version
        // also. HalInitPowerManagement, HalLocateHiberRanges and
        // HalGetInterruptTranslator are added in the latest version
        // of Microsoft source code.
        //

        HalGetDmaAdapter = HaliGetDmaAdapter;
        HalHaltSystem = HaliHaltSystem;
        HalResetDisplay = HalpBiosDisplayReset;
        HalAllocateMapRegisters = HalpAllocateMapRegisters;

#if !defined( HAL_SP )
        HalGetInterruptTranslator = HalacpiGetInterruptTranslator;
#endif // HAL_SP

#if DBG
        //
        // Switch from HalDisplayString to DbgPrint.
        //

        HalpUseDbgPrint++;
#endif // DBG

#if !defined( HAL_SP ) && !(MCA)
        HalInitPowerManagement = HaliInitPowerManagement;
        HalLocateHiberRanges = HaliLocateHiberRanges;
#endif// HAL_SP and MCA

        //
        // Register PC style IO space used by hal
        //

        HalpRegisterAddressUsage (&HalpDefaultPcIoSpace);
        HalpInitInterruptTables();

        //
        // Initialize CMOS
        //

        HalpInitializeCmos();

        //
        // Initialize per processor EOI table
        //

        HalpInitEOITable();
        HalpInitPlatformInterrupts();

        //
        // Initialize the clock for the processor that keeps
        // the system time. This uses a stub ISR until Phase 1
        //

        // Initialize Clock interrupts, profile , APC and DPC interrupts,

        HalpInitializeClock();
        HalpRegisterInternalInterrupts();
        HalpInitializeInterrupts();

        //
        // Initialize initial processor and NT profiling state
        // that should be initialized at Phase 0 and
        // do not require to wait for Phase 1.
        //

        HalpSetupProfilingPhase0( LoaderBlock );

        //
        // Interrupts should be safe now.
        //

        if (EnableInterrupts) {
            HalpEnableInterrupts();
        }

        //
        // Initialize event for serialization of new dma adapter events
        //

        KeInitializeEvent(&HalpNewAdapter, SynchronizationEvent, TRUE);

        //
        // Fill in the PAL TR_INFO structure so Mm can build PTEs for
        // the PAL during phase 0 initialization.
        //

        HalpInitializePalTrInfo(LoaderBlock);

        //
        // Determine if there is physical memory above 4 GB.
        //

        HalDebugPrint(( HAL_INFO, "HAL: Determine if there is memory above 4 Gb\n" ));
        NoMemoryAbove4Gb = TRUE;

        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
             Descriptor = CONTAINING_RECORD(
                           NextMd,
                           MEMORY_ALLOCATION_DESCRIPTOR,
                           ListEntry
                           );

            if (Descriptor->MemoryType != LoaderFirmwarePermanent &&
                Descriptor->MemoryType != LoaderSpecialMemory) {
                //
                // Test for 4 GB:
                //
                if ((Descriptor->BasePage + Descriptor->PageCount) > (GreaterThan4GB >> PAGE_SHIFT)) {
                    NoMemoryAbove4Gb = FALSE;
                    HalDebugPrint(( HAL_INFO, "HAL: Memory is present above 4Gb\n" ));

                    if (HalpVideoBiosPresent) {
                        break;
                    }
                }
            } else {
                if ((Descriptor->BasePage <= VideoBiosFirstPage) &&
                    (Descriptor->BasePage + Descriptor->PageCount) > VideoBiosLastPage) {
                    HalpVideoBiosPresent = TRUE;
                    HalDebugPrint(( HAL_INFO, "HAL: Video BIOS present\n" ));

                    if (NoMemoryAbove4Gb == FALSE) {
                        break;
                    }
                }
            }

            NextMd = Descriptor->ListEntry.Flink;
        }

        //
        // Determine the size needed for map buffers.  If this system has
        // memory that requires more than 32 bits to access, then allocate
        // a large chunk; otherwise, allocate a small chunk.
        //

        if (NoMemoryAbove4Gb) {

            //
            // Allocate a small set of map buffers.  They are only need for
            // devices which do not function.
            //

            HalpMapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;
            HalDebugPrint(( HAL_INFO, "HAL: No memory beyond 4Gb\n" ));

        } else {

            //
            // Allocate a larger set of map buffers.  These are used for
            // 32 bit devices to reach memory above 4gb.
            //

            HalpMapBufferSize = INITIAL_MAP_BUFFER_LARGE_SIZE;
            HalDebugPrint(( HAL_INFO, "HAL: Map Buffers for 32 bit devices to reach memory above 4Gb\n" ));

        }

        //
        // Allocate map buffers for the adapter objects
        //

        HalpMapBufferPhysicalAddress.QuadPart = (ULONGLONG)
            HalpAllocPhysicalMemory(LoaderBlock,
                                    MAXIMUM_PHYSICAL_ADDRESS,
                                    HalpMapBufferSize >> PAGE_SHIFT,
                                    TRUE);

        HalpMapBufferPhysicalAddress.HighPart = 0;


        if (!HalpMapBufferPhysicalAddress.LowPart) {

            //
            // There was not a satisfactory block.  Clear the allocation.
            //

            HalpMapBufferSize = 0;
        }

        //
        // Set the processor active in the HAL private active processor mask.
        //
        // For the BSP processor, the specific bit is set at the end of HalInitSystem(Phase0).

        HalpActiveProcessors = 1uI64 << pPRCB->Number;

    } else {

        //
        // Phase 1 initialization
        //

        if ( pPCR->Number == 0) {

            //
            // Back-pocket some PTEs for DMA during low mem
            //
            HalpInitReservedPages();

#if defined(HALP_FIX_KD_HALIA64_MASK)
#if DBG
            HalpSetKdHalia64Mask( HalpFixKdHalia64Mask );
#endif // DBG
#endif // HALP_FIX_KD_HALIA64_MASK

            if (!NT_SUCCESS(HalpEfiInitialization(LoaderBlock))) {
                return(FALSE);
            }

                //
            // Set initial feature bits
            //

            HalpFeatureBits = HalpGetFeatureBits();

            HalpInitIoMemoryBase();
            HalpInitializeX86Int10Call();
            HalpInitializeInterruptBlock();

            //
            // Map the APICs so that MM will allow us to access them in the
            // debugger.
            //

            HalpInitApicDebugMappings();

            //
            // Initialize MCA,INIT parameters and pre-allocate Event records for BSP processor.
            //

            if ( !HalpInitializeOSMCA( pPCR->Number ) )   {
                return FALSE;
            }

            HalpInitNonBusHandler();

            //
            // Raise IRQL to the highest level, set the new clock interrupt
            // parameters, lower IRQl, and return the new time increment value.
            //

            status = HalpQueryFrequency( &ITCFrequencyQueried,
                                         &ProcessorFrequencyQueried);

            KeRaiseIrql(HIGH_LEVEL, &OldIrql);

            if (NT_SUCCESS(status)) {
                HalpITCFrequency = ITCFrequencyQueried;
                HalpProcessorFrequency = ProcessorFrequencyQueried;
            }

            HalpSetInitialClockRate();

            KeLowerIrql(OldIrql);

            //
            // Initialize per-processor profiling
            //
            // Requires HalpITCTicksPer100ns initialized.

            HalpInitializeProfiling( pPCR->Number );

            HalpMCAEnable();
            HalpCMCEnable();
            HalpCPEEnable();

        } else {

                        //
            // Initialize per processor EOI table
            //
            HalpInitEOITable();
            HalpInitPlatformInterrupts();

            //
            //  Initialization needed only on non BSP processors
            //
            if ( !HalpInitSalPalNonBsp() )  {
                return FALSE;
            }

            HalpInitializeClockPn();

            //
            // Allocate MCA, INIT stacks on non BSP processors
            //

            if ( !HalpAllocateMceStacks( pPCR->Number) )  {
                return FALSE;
            }

            //
            // Pre-allocate MCA,INIT records on non BSP processors
            //

            if ( !HalpPreAllocateMceRecords( pPCR->Number) )  {
                return FALSE;
            }

            //
            // Reduce feature bits to be a subset
            //

            HalpFeatureBits &= HalpGetFeatureBits();

            HalpInitializeInterrupts();

            //
            // Initialize per-processor profiling
            //

            HalpInitializeProfiling( pPCR->Number );

            HalpMCAEnable();
            HalpCMCEnable();

            //
            // Set the processor active in the HAL private active processor mask.
            //
            // For non-BSP processors, the specific bit is set at the end of HalInitSystem(Phase1).

            HalpActiveProcessors |= 1uI64 << pPRCB->Number;

        }

    }

    return TRUE;
}


VOID
HalChangeColorPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN ULONG PageFrame
    )
/*++

Routine Description:

   This function changes the color of a page if the old and new colors
   do not match.

Arguments:

   NewColor - Supplies the page aligned virtual address of the
      new color of the page to change.

   OldColor - Supplies the page aligned virtual address of the
      old color of the page to change.

   pageFrame - Supplies the page frame number of the page that
      is changed.

Return Value:

   None.

--*/
{
    return;
}

//****************************************************************
// T. Kjos Added stuff after this line as part of initial
// APIC, PCMP removal.

// From mpsproc.c
ULONG           HalpDontStartProcessors = 0;

//
// Since IA-64 does not support lowest priority interrupts set
// processors per cluster to 1 so that we staically assign interrupts
// in round robin to the processors.
//

UCHAR           HalpMaxProcsPerCluster = 1;

// From pmmphal.c:
BOOLEAN         HalpStaticIntAffinity = FALSE;

extern UCHAR    HalpSzInterruptAffinity[];
extern UCHAR    HalpSzOneCpu[];
extern UCHAR    HalpSzPciLock[];
extern UCHAR    HalpSzBreak[];
extern UCHAR    HalpSzForceClusterMode[];

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This gets any parameters from the boot.ini invocation line.

Arguments:

    None.

Return Value:

    None

--*/
{
    PCHAR       Options;
    PCHAR       p;

    if (LoaderBlock != NULL  &&  LoaderBlock->LoadOptions != NULL) {

        Options = LoaderBlock->LoadOptions;

        //
        //  Has the user set the debug flag?
        //
        //
        //  Has the user requested a particular number of CPU's?
        //

        if (strstr(Options, HalpSzOneCpu)) {
            HalpDontStartProcessors++;
        }

        //
        // Check if user wants device ints to go to highest numbered processor
        //

        if (strstr(Options, HalpSzInterruptAffinity)) {
            HalpStaticIntAffinity = TRUE;
        }

        //
        //  Has the user asked for an initial BreakPoint?
        //

        if (strstr(Options, HalpSzBreak)) {
            DbgBreakPoint();
        }

        //
        // Used to define the size of a node = MaxProcsPerCluster
        // 0 implies one node for the whole machine
        //
        p = strstr(Options, HalpSzForceClusterMode);
        if (p) {
            // skip to value
            while (*p  &&  *p != ' ' &&  (*p < '0'  || *p > '9')) {
                p++;
            }
            HalpMaxProcsPerCluster = (UCHAR)atoi(p);
        }
    }

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64fwasm.s ===
//++
//
//  Module name:
//
//      i64fwasm.s
//
//  Author:
//
//      Arad Rostampour (arad@fc.hp.com)  Mar-21-99
//
//  Description:
//
//      Assembly routines for calling into SAL, PAL, and setting up translation registers
//
//--

#include "ksia64.h"

        .sdata

//
// HalpSalSpinLock:
//
//  HAL private spinlock protecting generic SAL calls.
//

        .align     128
HalpSalSpinLock::
        data8      0

//
// HalpSalStateInfoSpinLock:
//
//  HAL private spinlock protecting specific SAL STATE_INFO calls.
//

        .align     128
HalpSalStateInfoSpinLock::
        data8      0

//
// HalpMcaSpinLock
//
//  HAL private spinlock protecting HAL internal MCA data structures and operations.
//  Including operations at IRQL DISPATCH_LEVEL and higher.
//

        .align     128
HalpMcaSpinLock::
        data8      0

//
// HalpInitSpinLock
//
//  HAL private spinlock protecting HAL internal INIT data structures and operations.
//  Including operations at IRQL DISPATCH_LEVEL and higher.
//

        .align     128
HalpInitSpinLock::
        data8      0

//
// HalpCmcSpinLock
//
//  HAL private spinlock protecting HAL internal CMC data structures and operations.
//  Including operations at IRQL DISPATCH_LEVEL and higher.
//

        .align     128
HalpCmcSpinLock::
        data8      0

//
// HalpCpeSpinLock
//
//  HAL private spinlock protecting HAL internal CPE data structures and operations.
//  Including operations at IRQL DISPATCH_LEVEL and higher.
//

        .align     128
HalpCpeSpinLock::
        data8      0

//
// Definitions used in this file
//
// Bits to set for the Mode argument in the HalpSetupTranslationRegisters call

#define SET_DTR_BIT     1
#define SET_ITR_BIT     0

// TR for PAL is:
//    ed=1, PPN=0 (to be ORed in), RWX privledge only for ring 0, dirty/accessed bit set,
//    cacheable memory, present bit set.

#define HAL_SAL_PAL_TR_ATTRIB TR_VALUE(1,0,3,0,1,1,0,1)
#define HAL_TR_ATTRIBUTE_PPN_MASK    0x0000FFFFFFFFF000

        .file   "i64fwasm.s"

        // These globals are defined in i64fw.c

        .global HalpSalProcPointer
        .global HalpSalProcGlobalPointer
        .global HalpPhysSalProcPointer
        .global HalpPhysSalProcGlobalPointer
        .global HalpVirtPalProcPointer
        .global HalpPhysPalProcPointer


//++
//
//  SAL_PAL_RETURN_VALUES
//  HalpSalProc(
//      LONGLONG a0, /* SAL function ID */
//      LONGLONG a1, /* SAL argument    */
//      LONGLONG a2, /* SAL argument    */
//      LONGLONG a3, /* SAL argument    */
//      LONGLONG a4, /* SAL argument    */
//      LONGLONG a5, /* SAL argument    */
//      LONGLONG a6, /* SAL argument    */
//      LONGLONG a7  /* SAL argument    */
//      );
//
//  Routine Description:
//      This is a simple assembly wrapper that jumps directly to the SAL code.  The ONLY
//      caller should be HalpSalCall.  Other users must use the HalpSalCall API for
//      calling into the SAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for SAL, r8 is the status
//--

        NESTED_ENTRY(HalpSalProc)
        NESTED_SETUP(8,3,8,0)
        
        // copy args to outs
        mov         out0 = a0
        mov         out1 = a1
        mov         out2 = a2
        mov         out3 = a3
        mov         out4 = a4
        mov         out5 = a5
        mov         out6 = a6
        mov         out7 = a7
        ;;
        // Simply load the address and branch to it

        addl        t1 = @gprel(HalpSalProcPointer), gp
        addl        t2 = @gprel(HalpSalProcGlobalPointer), gp
        ;;
        mov       loc2 = gp
        ld8         t0 = [t1]
        ;;
        ld8          gp = [t2]
        mov         bt0 = t0
        rsm         1 << PSR_I          // disable interrupts
        ;;                
        
        // br.sptk.many bt0
        br.call.sptk brp = bt0
        ;;

        mov           gp = loc2
        ssm         1 << PSR_I          // enable interrupts
        ;;
 
        NESTED_RETURN
        NESTED_EXIT(HalpSalProc)

//++
//
//  SAL_PAL_RETURN_VALUES
//  HalpSalProcPhysicalEx(
//      LONGLONG a0, /* SAL function ID */
//      LONGLONG a1, /* SAL argument    */
//      LONGLONG a2, /* SAL argument    */
//      LONGLONG a3, /* SAL argument    */
//      LONGLONG a4, /* SAL argument    */
//      LONGLONG a5, /* SAL argument    */
//      LONGLONG a6, /* SAL argument    */
//      LONGLONG a7, /* SAL argument    */
//      LONGLONG stack,
//      LONGLONG bsp
//      );
//
//  Routine Description
//      This routine calls SAL in physical mode.  The only caller should be
//      HalpSalCall.
//
//--

        NESTED_ENTRY(HalpSalProcPhysicalEx)
        NESTED_SETUP(8,2,8,0)

        //
        // Define our register aliases.
        //

        rSaveGP     = t22
        rSaveEP     = t21
        rSaveA7     = t20
        rSaveA6     = t19
        rSaveA5     = t18
        rSaveA4     = t17
        rSaveA3     = t16
        rSaveA2     = t15
        rSaveA1     = t14
        rSaveA0     = t13

        rSaveSp     = t12
        rSaveBSP    = t11
        rSavePfs    = t10
        rSaveBrp    = t9
        rSaveRSC    = t8
        rSaveRNAT   = t7
        rSavePSR    = t6

        rNewSp      = t5
        rNewBSP     = t4

        rT3         = t3
        rT2         = t2
        rT1         = t1

        //
        // Pull the sp and bsp arguments off of the stack.
        //

        add         rT1 = 24, sp
        add         rT2 = 16, sp
        ;;

        ld8         rNewBSP = [rT1]
        ld8         rNewSp  = [rT2]
        ;;

        //
        // Move our arguments off of the register stack and into static
        // registers.
        //

        mov         rSaveA0  = a0
        mov         rSaveA1  = a1
        mov         rSaveA2  = a2
        mov         rSaveA3  = a3
        mov         rSaveA4  = a4
        mov         rSaveA5  = a5
        mov         rSaveA6  = a6
        mov         rSaveA7  = a7

        //
        // Save copies of a few registers that will be overwritten later on.
        //

        mov         rSaveSp  = sp
        mov         rSavePfs = ar.pfs
        mov         rSaveBrp = brp

        //
        // Load the physical addresses of the SAL entry point and gp.
        //

        add          rT1 = @gprel(HalpPhysSalProcPointer), gp
        add          rT2 = @gprel(HalpPhysSalProcGlobalPointer), gp
        ;;

        ld8          rSaveEP = [rT1]
        ld8          rSaveGP = [rT2]
        ;;

        //
        // Allocate a zero sized frame so that flushrs will move the current
        // register stack out to memory.
        //

        alloc       rT1 = 0,0,0,0
        ;;

        //
        // Flush the RSE.
        //

        flushrs
        ;;

        //
        // Save bits [31:0] and [36:35] of the current psr value.
        //

        mov         rSavePSR = psr

        //
        // The .bn bit of the current psr wasn't copied to rSavePSR by the
        // above operation.  Manually set it here so that we don't rfi
        // to the wrong register bank.
        //

        movl        rT2 = (1 << PSR_BN)
        ;;

        or          rSavePSR = rT2, rSavePSR

        //
        // Disable interrupts.
        //

        rsm         (1 << PSR_I)

        //
        // Move the RSE into enforced lazy mode by manipulating ar.rsc.
        //

        mov         rSaveRSC = ar.rsc
        mov         rT1 = RSC_KERNEL_DISABLED
        ;;

        mov         ar.rsc = rT1
        ;;

        //
        // Save the current backing store pointer (BSP) and RSE NAT collection
        // value.
        //

        mov         rSaveBSP  = ar.bsp
        mov         rSaveRNAT = ar.rnat
        ;;

        //
        // Turn off psr.ic in preparation for the rfi.
        //

        rsm         (1 << PSR_IC)
        ;;

        //
        // Build a new psr value in rT1 by using our original psr value with
        // .it, .dt, .rt, and .i disabled.
        //

        movl        rT1 = (1 << PSR_IT)   \
                          | (1 << PSR_RT) \
                          | (1 << PSR_DT) \
                          | (1 << PSR_I)

        movl        rT2 = 0xffffffffffffffff
        ;;

        xor         rT1 = rT1, rT2
        ;;

        and         rT1 = rT1, rSavePSR

        //
        // Make sure all of our previous psr changes take effect.
        //

        srlz.i
        ;;

        //
        // Load our physical mode psr into cr.ipsr.
        //

        mov         cr.ipsr = rT1

        //
        // Make sure the cfm isn't corrupted when we do the rfi.
        //

        mov         cr.ifs = zero
        ;;

        //
        // Load the physical address of our continuation label into cr.iip.
        //

        movl        rT2 = HalpSalProcContinuePhysical
        ;;

        tpa         rT2 = rT2
        ;;

        mov         cr.iip  = rT2
        ;;

        //
        // Do an rfi to physical mode.
        //

        rfi
        ;;

HalpSalProcContinuePhysical:

        //
        // Switch to the physical mode stack and backing store.  Note that
        // bspstore can only be written when the RSE is in enforced lazy
        // mode.
        //

        mov         sp = rNewSp
        mov         ar.bspstore = rNewBSP
        ;;

        mov         ar.rnat = zero
        ;;

        //
        // Restore the default kernel rsc mode.
        //

        mov         ar.rsc = RSC_KERNEL
        ;;

        //
        // Allocate a new stack frame on the new bsp.
        //

        alloc       rT1 = ar.pfs,0,8,8,0

        //
        // Save the registers that aren't preserved across the procedure
        // call on the register stack.
        //

        mov         loc0 = rSavePSR
        mov         loc1 = rSaveRNAT
        mov         loc2 = rSaveRSC
        mov         loc3 = rSaveBrp
        mov         loc4 = rSavePfs
        mov         loc5 = rSaveBSP
        mov         loc6 = rSaveSp
        mov         loc7 = gp
        ;;

        //
        // Load the arguments for SAL_PROC.
        //

        mov         out0 = rSaveA0
        mov         out1 = rSaveA1
        mov         out2 = rSaveA2
        mov         out3 = rSaveA3
        mov         out4 = rSaveA4
        mov         out5 = rSaveA5
        mov         out6 = rSaveA6
        mov         out7 = rSaveA7

        //
        // Load the physical address of our return label into brp.
        //

        movl        rT1 = HalpSalProcPhysicalReturnAddress
        ;;

        tpa         rT1 = rT1
        ;;

        mov         brp = rT1

        //
        // Load the entry point and gp of SAL_PROC.
        //

        mov         bt0 = rSaveEP
        mov         gp  = rSaveGP
        ;;

        //
        // Call the SAL.
        //

        br.call.sptk brp = bt0
        ;;

HalpSalProcPhysicalReturnAddress:
            
        //
        // Move our saved state off of the register stack and back to
        // static registers.
        //

        mov         rSavePSR  = loc0
        mov         rSaveRNAT = loc1
        mov         rSaveRSC  = loc2
        mov         rSaveBrp  = loc3
        mov         rSavePfs  = loc4
        mov         rSaveBSP  = loc5
        mov         rSaveSp   = loc6
        mov         gp        = loc7
        ;;

        //
        // Stop all RSE accesses and create an empty frame on top of the
        // current one.
        //

        mov         ar.rsc = RSC_KERNEL_DISABLED
        ;;

        alloc       rT1 = 0,0,0,0
        ;;

        //
        // Restore our saved bspstore and rnat values.
        //

        mov         ar.bspstore = rSaveBSP
        ;;
        mov         ar.rnat = rSaveRNAT

        //
        // Restore the stack pointer.
        //

        mov         sp = rSaveSp
        ;;

        //
        // Turn off psr.ic in preparation for the rfi back to virtual
        // mode.
        //

        rsm         (1 << PSR_IC)
        ;;

        movl        rT1 = HalpSalProcCompletePhysical
        ;;

        //
        // Make sure our psr change has taken effect.
        //

        srlz.i
        ;;

        //
        // Load our continuation label address into cr.iip and our saved
        // psr value into cr.ipsr.  Also set cr.ifs so that CFM won't be
        // corrupted by the rfi.
        //

        mov         cr.iip = rT1
        mov         cr.ipsr = rSavePSR
        mov         cr.ifs = zero
        ;;

        //
        // Do an rfi back to virtual mode.
        //

        rfi
        ;;

HalpSalProcCompletePhysical:

        //
        // Restore our RSC state.
        //

        mov         ar.rsc = rSaveRSC
        ;;

        //
        // Restore our saved PFS value along with our return pointer and
        // return to the caller.
        //

        mov         ar.pfs = rSavePfs
        mov         brp    = rSaveBrp
        ;;

        br.ret.sptk brp

        NESTED_EXIT(HalpSalProcPhysicalEx)


//++
//
//  SAL_PAL_RETURN_VALUES
//  HalpPalProc(
//      LONGLONG a0, /* PAL function ID */
//      LONGLONG a1, /* PAL argument    */
//      LONGLONG a2, /* PAL argument    */
//      LONGLONG a3  /* PAL argument    */
//      );
//
//  Routine Description
//      This routine sets up the correct registers for input into PAL depending on
//      if the call uses static or stacked registers, turns off interrupts, ensures
//      the correct bank registers are being used and calls into the PAL.  The ONLY
//      caller should be HalpPalCall.  Other users must use the HalpPalCall API for
//      calling into the PAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for PAL, r8 is the status
//--

        NESTED_ENTRY(HalpPalProc)
        NESTED_SETUP(4,3,4,0)
        PROLOGUE_END

        // For both the static and stacked register conventions, load r28 with FunctionID

        mov     r28 = a0

        // If static register calling convention (1-255, 512-767), copy arguments to r29->r31
        // Otherwise, copy to out0->out3 so they are in r32->r35 in PAL_PROC

        mov     t0 = a0
        ;;
        shr     t0 = t0, 8
        ;;
        tbit.z pt0, pt1 = t0, 0
        ;;

        //
        // Static proc: do br not call
        //
(pt0)   mov         r29 = a1
(pt0)   mov         r30 = a2
(pt0)   mov         r31 = a3

        //
        // Stacked call
        //
(pt1)   mov     out0 = a0
(pt1)   mov     out1 = a1
(pt1)   mov     out2 = a2
(pt1)   mov     out3 = a3

        // Load up the address of PAL_PROC and call it

        addl     t1 = @gprel(HalpVirtPalProcPointer), gp
        ;;
        ld8      t0 = [t1]
        ;;
        mov      bt0 = t0

        // Call into PAL_PROC

(pt0)   addl t1 = @ltoff(PalReturn), gp
        ;;
(pt0)   ld8 t0 = [t1]
        ;;
(pt0)   mov brp = t0
        ;;
        // Disable interrupts

        DISABLE_INTERRUPTS(loc2)
        ;;
        srlz.d
        ;;
(pt0)   br.sptk.many bt0
        ;;
(pt1)   br.call.sptk brp = bt0        
        ;;
PalReturn:
        // Restore the interrupt state

        RESTORE_INTERRUPTS(loc2)
        ;;
        NESTED_RETURN
        NESTED_EXIT(HalpPalProc)


//++
//
//  SAL_PAL_RETURN_VALUES
//  HalpPalProcPhysicalStatic(
//      LONGLONG a0, /* PAL function ID */
//      LONGLONG a1, /* PAL argument    */
//      LONGLONG a2, /* PAL argument    */
//      LONGLONG a3  /* PAL argument    */
//      );
//
//  Routine Description
//      This routine sets up the correct registers for input into PAL turns off interrupts, 
//      ensures the correct bank registers are being used and calls into the PAL in PHYSICAL
//      mode since some of the calls require it.  The ONLY caller should be HalpPalCall.  
//      Other users must use the HalpPalCall API for calling into the PAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for PAL, r8 is the status
//--

        NESTED_ENTRY(HalpPalProcPhysicalStatic)
        NESTED_SETUP(4,5,0,0)
//
//      Aliases
//
        rSaveGP     = t21
        rSaveEP     = t20
//          r28     = t19 is reserved for PAL calling convention.
        rSavePSR    = t18
        rSaveRSC    = loc3

        rT3         = t3
        rT2         = t2
        rT1         = t1
                
        add          rT3 = @gprel(HalpPhysPalProcPointer), gp
        ;;

        ld8          rSaveEP = [rT3]
        ;;
        
//
// Flush RSE and Turn Off interrupts
//        
        flushrs
        mov         rSavePSR = psr
        movl        rT2 = (1 << PSR_BN)
        mov         rSaveRSC = ar.rsc
        mov         rT1 = RSC_KERNEL_DISABLED
        ;;
        or          rSavePSR = rT2, rSavePSR    // psr.bn stays on
        rsm         (1 << PSR_I)
        mov         ar.rsc = rT1
        ;;

// Turn Off Interrupt Collection
        rsm         (1 << PSR_IC)
//
// IC = 0; I = 0;
//

//
// IIP = HalpPalProcContinuePhysicalStatic: IPSR is physical
//
        movl        rT1 = (1 << PSR_IT) | (1 << PSR_RT) | (1 << PSR_DT) | (1 << PSR_I)
        movl        rT2 = 0xffffffffffffffff
        ;;
        xor         rT1 = rT1, rT2
        ;;
        and         rT1 = rT1, rSavePSR // rT1 = old PSR & zero it, dt, rt, i
        srlz.i
        ;;
        mov         cr.ipsr = rT1
        mov         cr.ifs = zero
        ;;
        movl        rT2 = HalpPalProcContinuePhysicalStatic
        ;;
        tpa         rT2 = rT2 // phys address of new ip
        ;;
        mov         cr.iip  = rT2
        ;;
        rfi
        ;;

//
// Now in physical mode, ic = 1, i = 0
//

HalpPalProcContinuePhysicalStatic:
// Setup Arguments

        mov         bt0 = rSaveEP
        mov	    loc2 = rSavePSR     // save PSR value
        mov         r28  = a0
        mov         r29  = a1
        mov         r30  = a2
        mov         r31  = a3
        ;;
        movl        rT1 = HalpPalProcPhysicalStaticReturnAddress
        ;;
        tpa         rT1 = rT1
        ;;
        mov         brp = rT1
        ;;
        br.cond.sptk bt0
        ;;
HalpPalProcPhysicalStaticReturnAddress:
        rsm         (1 << PSR_IC)
        ;;

        movl        rT1 = HalpPalProcCompletePhysicalStatic
        ;;
        srlz.i
        ;;
        mov         ar.rsc = rSaveRSC
        mov         cr.iip = rT1
        mov         cr.ipsr = loc2
        mov         cr.ifs = zero
        ;;
        rfi
        ;;
//
// Now in virtual mode, ic = 1, i = 1
//
HalpPalProcCompletePhysicalStatic:

//
// Restore pfs, brp and return
//
        NESTED_RETURN
        NESTED_EXIT(HalpPalProcPhysicalStatic)

//++
//
//  SAL_PAL_RETURN_VALUES
//  HalpPalProcPhysicalStacked(
//      LONGLONG a0, /* PAL function ID */
//      LONGLONG a1, /* PAL argument    */
//      LONGLONG a2, /* PAL argument    */
//      LONGLONG a3,  /* PAL argument    */
//      LONGLONG StackPointer,
//      LONGLONG BackingStorePointer
//      );
//
//  Routine Description
//      This routine calls PAL in physical mode for the stacked calling
//      convention.  The ONLY caller should be HalpPalCall. Other users must 
//      use the HalpPalCall API for calling into the PAL.
//
//--

        NESTED_ENTRY(HalpPalProcPhysicalStacked)
        NESTED_SETUP(6,2,0,0)
//
//      Aliases
//
        rSaveGP     = t21
        rSaveEP     = t20
//          r28     = t19 is reserved for PAL calling convention.
        rSaveA3     = t18
        rSaveA2     = t17
        rSaveA1     = t16
        rSaveA0     = t15

        rSaveSp     = t14
        rSaveBSP    = t13
        rSavePfs    = t12
        rSaveBrp    = t11
        rSaveRSC    = t10
        rSaveRNAT   = t9
        rSavePSR    = t8

        rNewSp      = t7
        rNewBSP     = t6

        rT3         = t3
        rT2         = t2
        rT1         = t1

// Save Arguments in static Registers

        mov         rSaveA0  = a0
        mov         rSaveA1  = a1
        mov         rSaveA2  = a2
        mov         rSaveA3  = a3

        mov         rSaveSp  = sp
        mov         rSavePfs = ar.pfs
        mov         rSaveBrp = brp

//
// Setup Physical sp, bsp
//

        add          rT3 = @gprel(HalpPhysPalProcPointer), gp
        ;;
        mov          rNewSp  = a4
        mov          rNewBSP = a5
        ld8          rSaveEP = [rT3]
        ;;
 //       tpa          rSaveEP = rSaveEP

// Allocate a zero-sized frame
//        ;;
        alloc       rT1 = 0,0,0,0

// Flush RSE and Turn Off interrupts
        ;;
        flushrs
        ;;
        mov         rSavePSR = psr
        movl        rT2 = (1 << PSR_BN)
        ;;
        or          rSavePSR = rT2, rSavePSR    // psr.bn stays on
        rsm         (1 << PSR_I)

        mov         rSaveRSC = ar.rsc

// Flush RSE to enforced lazy mode by clearing both RSC.mode bits
        mov         rT1 = RSC_KERNEL_DISABLED
        ;;
        mov         ar.rsc = rT1
        ;;
//
// save RSC, RNAT, BSP, PSR, SP in the allocated space during initialization
//
        mov         rSaveBSP  = ar.bsp
        mov         rSaveRNAT = ar.rnat
        ;;

// Turn Off Interrupt Collection
        rsm         (1 << PSR_IC)
        ;;
//
// IC = 0; I = 0;
//

//
// IIP = HalpPalProcContinuePhysicalStacked: IPSR is physical
//
        movl        rT1 = (1 << PSR_IT) | (1 << PSR_RT) | (1 << PSR_DT) | (1 << PSR_I)
        movl        rT2 = 0xffffffffffffffff
        ;;
        xor         rT1 = rT1, rT2
        ;;
        and         rT1 = rT1, rSavePSR // rT1 = old PSR & zero it, dt, rt, i
        srlz.i
        ;;
        mov         cr.ipsr = rT1
        mov         cr.ifs = zero
        ;;
        movl        rT2 = HalpPalProcContinuePhysicalStacked
        ;;
        tpa         rT2 = rT2 // phys address of new ip
        ;;
        mov         cr.iip  = rT2
        ;;
        rfi
        ;;

//
// Now in physical mode, ic = 1, i = 0
//

HalpPalProcContinuePhysicalStacked:

//
// Switch to new bsp, sp
//
        mov         sp = rNewSp
        mov         ar.bspstore = rNewBSP
        ;;
        mov         ar.rnat = zero
        ;;

//
// Enable RSC
//
        mov         ar.rsc = RSC_KERNEL
        ;;

//
// Allocate frame on new bsp
//
        alloc       rT1 = ar.pfs,0,7,4,0

//
// Save caller's state in register stack
//

        mov         loc0 = rSaveRNAT
        mov         loc1 = rSaveSp
        mov         loc2 = rSaveBSP
        mov         loc3 = rSaveRSC
        mov         loc4 = rSaveBrp
        mov         loc5 = rSavePfs
        mov         loc6 = rSavePSR
        ;;

// Setup Arguments

        mov         r28  = rSaveA0
        mov         out0 = rSaveA0
        mov         out1 = rSaveA1
        mov         out2 = rSaveA2
        mov         out3 = rSaveA3

        movl        rT1 = HalpPalProcPhysicalStackedReturnAddress
        ;;
        tpa         rT1 = rT1
        ;;
        mov         brp = rT1
        // mov         gp = rSaveGP
        mov         bt0 = rSaveEP
        ;;
        br.call.sptk brp = bt0
        ;;

HalpPalProcPhysicalStackedReturnAddress:
            
//
// In physical mode: switch to virtual
//

//
// Restore saved state
//
        mov         rSaveRNAT = loc0
        mov         rSaveSp  = loc1
        mov         rSaveBSP = loc2
        mov         rSaveRSC = loc3
        mov         rSaveBrp = loc4
        mov         rSavePfs = loc5
        mov         rSavePSR = loc6
        ;;
//
// Restore BSP, SP
//
        ;;
        mov         ar.rsc = RSC_KERNEL_DISABLED
        ;;
        alloc       rT1 = 0,0,0,0
        ;;
        mov         ar.bspstore = rSaveBSP
        ;;
        mov         ar.rnat = rSaveRNAT
        mov         sp = rSaveSp
        ;;
        rsm         (1 << PSR_IC)
        ;;

        movl        rT1 = HalpPalProcCompletePhysicalStacked
        ;;
        srlz.i
        ;;
        mov         cr.iip = rT1
        mov         cr.ipsr = rSavePSR
        mov         cr.ifs = zero
        ;;
        rfi
        ;;
//
// Now in virtual mode, ic = 1, i = 1
//
HalpPalProcCompletePhysicalStacked:

//
// Restore psf, brp and return
//
        mov         ar.rsc = rSaveRSC
        ;;
        mov         ar.pfs = rSavePfs
        mov         brp    = rSaveBrp
        ;;
        br.ret.sptk brp
        NESTED_EXIT(HalpPalProcPhysicalStacked)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64itm.s ===
//      TITLE ("Memory Fences, Load Acquires and Store Acquires")

/*++

    Copyright (c) 1995  Intel Corporation

    Module Name:

     i64itm.s assembly routines for updating ITM.

    Abstract:

      This module implements the I/O port access routines.

    Author:

      Bernard Lint, M. Jayakumar 17 Sep '97

    Environment:

      Kernel mode

    Revision History:

--*/

#include "ksia64.h"

        .file "i64itm.s"

        .global HalpClockCount
        .global HalpITMMinimumUpdate
        .global HalpITCTicksPer100ns


// Temp until compiler fixed


        LEAF_ENTRY(HalpInitLINT)
        LEAF_SETUP(1,0,0,0)
        mov         t0 = 0x10000
        ;;
        mov         cr.lrr0 = t0
        mov         cr.lrr1 = t0
        ;;
        // Clear pending interrupts from irr's
        // read ivr until spurious (0xf)
        // set tpr level to zero to unmask all ints

        mov         t2 = cr.tpr
        ;;
        mov         cr.tpr = zero
        ;;
        srlz.d
        mov         t0 = 0xf
        ;;
Hil_loop:
        mov         t1 = cr.ivr
        ;;
        cmp.ne      pt0 = t0, t1
        ;;
(pt0)   mov         cr.eoi = zero
(pt0)   br.spnt     Hil_loop

        // Restore tpr

        mov         cr.tpr = t2
        ;;
        srlz.d
        LEAF_RETURN
        LEAF_EXIT(HalpInitLINT)

/*++

BOOLEAN
HalpDisableInterrupts (
    )

Routine Description:

     This function disables interrupts.

Arguements:

     None.

Return Value:

     TRUE if interrupts were previously enabled else FALSE

--*/

        LEAF_ENTRY(HalpDisableInterrupts)

        mov       t0 = psr
        mov       v0 = TRUE         // set return value -- TRUE if enabled
        ;;
        tbit.z    pt1 = t0, PSR_I   // pt1 = 1 if disabled
        ;;

        FAST_DISABLE_INTERRUPTS
(pt1)   mov       v0 = FALSE        // FALSE if disabled
        br.ret.sptk brp

        LEAF_EXIT(HalpDisableInterrupts)

/*++

VOID
HalpTurnOffInterrupts (
    VOID
    )

Routine Description:

     This function turns off interrupts and interruption resources collection.

Arguements:

     None.

Return Value:

     None.

--*/

        LEAF_ENTRY(HalpTurnOffInterrupts)
        rsm     1 << PSR_I
        ;;
        rsm     1 << PSR_IC
        ;;
        srlz.d
        LEAF_RETURN
        LEAF_EXIT(HalpTurnOffInterrupts)

/*++

VOID
HalpTurnOnInterrupts (
    VOID
    )

Routine Description:

     This function turns on interruption resources collection and interrupts.

Arguements:

     None.

Return Value:

     None.

--*/

        LEAF_ENTRY(HalpTurnOnInterrupts)
        ssm     1 << PSR_IC             // set PSR.ic bit again
        ;;
        srlz.i                          // serialize
        ;;
        ssm     1 << PSR_I              // set PSR.i bit again

        LEAF_RETURN
        LEAF_EXIT(HalpTurnOnInterrupts)

/*++

ULONGLONG
HalpSetNextClockInterrupt (
    ULONG PreviousITMValue
    )

Routine Description:

     This function reads the current ITC and updates accordingly the ITM
     register with interruption resources collection and interrupts off.
     The interruption resources collection and interrupts are turned on
     returning to the caller.

Arguements:

     None.

Return Value:

     currentITCValue - previousITMValue.

--*/

        LEAF_ENTRY(HalpSetNextClockInterrupt)
        .regstk 1, 2, 0, 0

        alloc   r2 = 1, 2, 0, 0
        addl    r31 = @gprel(HalpClockCount),gp
        movl    r9 = KiPcr+PcHalReserved   // CURRENT_ITM_VALUE_INDEX = 0
        addl    r30 = @gprel(HalpITMMinimumUpdate),gp
        ;;

        // ld8.acq r11 = [r9]   // r11 = currentITMValue
        ld8     r10 = [r31]  // r10 = HalpClockCount
        ld8     r34 = [r30]  // r34 = HalpITMMinimumUpdate

        ;;

// 08/16/2000 TF
// We should check if r11 == cr.itm here...
//

        add     r11 = r32, r10 // r11 = compareITCValue = currentITMValue + HalpClockCount
        ;;

        rsm     1 << PSR_I
        ;;

        rsm     1 << PSR_IC
        ;;
        srlz.d

retry_itm_read:

        mov     cr.itm = r11  // set itm with the most common scenario
        ;;
        mov     r30 = cr.itm

retry_itc_read:
        mov     r33 = ar.itc  // r33 = currentITCValue
        ;;

        cmp.ne  pt2 = r30, r11
(pt2)   br.cond.spnt retry_itm_read // this should not be taken,
                               // this just makes sure itm is actually written
#ifndef DISABLE_ITC_WORKAROUND
        cmp4.eq pt1 = -1, r33 // if lower 32 bits equal 0xffffffff
(pt1)   br.cond.spnt retry_itc_read
        ;;
#endif // DISABLE_ITC_WORKAROUND

        sub     r30 = r11, r33  // calculate a ITM/ITC delta
        ;;
        cmp.lt  pt0, pt1 = r30, r0  // if a delta is negative set pt0
        ;;
(pt1)   cmp.lt  pt0 = r30, r34  // Is it at least HalpITMMinimumUpdate ticks?
        ;;
(pt0)   add     r11 = r11, r10  // r32 = updated currentITMValue + HalpClockCount
(pt0)   br.cond.spnt retry_itm_read
        ;;

        ssm     1 << PSR_IC     // set PSR.ic bit again
        ;;
        srlz.d                  // serialize
        ssm     1 << PSR_I      // set PSR.i bit again
        st8     [r9] = r11
        sub     r33 = r11, r10  // Pretend now is exactly one TICK before interrupt
        ;;
        sub     r8 = r33, r32   // r8 = currentITCValue - previousITMValue

        LEAF_RETURN
        LEAF_EXIT(HalpSetNextClockInterrupt)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64ioacc.c ===
/*++

 Copyright (c) 1995  Intel Corporation

 Module Name:

   i64ioacc.c

 Abstract:

   This module implements the I/O Register access routines.

 Author:

    Bernard Lint, M. Jayakumar  Sep 16 '97

 Environment:

    Kernel mode

 Revision History:

--*/


//
// XXX: Possible issues:
//  ISA bit
//  non-ISA bit
//  testing
//  Yosemite config
//  Pluto config
//




#include "halp.h"

#if DBG
ULONG DbgIoPorts = 0;
#endif

typedef struct _PORT_RANGE {
    BOOLEAN InUse;
    BOOLEAN IsSparse;        // _TRS
    BOOLEAN PrimaryIsMmio;   // _TTP
    BOOLEAN HalMapped;
    PVOID VirtBaseAddr;
    PHYSICAL_ADDRESS PhysBaseAddr;     // Only valid if PrimaryIsMmio = TRUE
    ULONG Length;            // Length of VirtBaseAddr and PhysBaseAddr ranges.
} PORT_RANGE, *PPORT_RANGE;


//
// Define a range for the architected IA-64 port space.
//
PORT_RANGE
BasePortRange = {
    TRUE,                   // InUse
    FALSE,                  // IsSparse
    FALSE,                  // PrimaryIsMmio
    FALSE,                  // HalMapped
    (PVOID)VIRTUAL_IO_BASE, // VirtBaseAddr
    {0},                    // PhysBaseAddr (unknown, comes from firmware)
    64*1024*1024            // Length
};


//
// Seed the set of ranges with the architected IA-64 port space.
//
PPORT_RANGE PortRanges = &BasePortRange;
USHORT NumPortRanges = 1;


UINT_PTR
GetVirtualPort(
    IN PPORT_RANGE Range,
    IN USHORT Port
    )
{
    UINT_PTR RangeOffset;

    if (Range->PrimaryIsMmio && !Range->IsSparse) {
        //
        // A densely packed range which converts MMIO transactions to
        // I/O port ones.
        //
        RangeOffset = Port;
        
    } else {
        //
        // Either a sparse MMIO->I/O port range, or primary is not
        // MMIO (IA-64 I/O port space).
        //
        RangeOffset = ((Port & 0xfffc) << 10) | (Port & 0xfff);
    }
    
    ASSERT(RangeOffset < Range->Length);

    return ((UINT_PTR)Range->VirtBaseAddr) + RangeOffset;
}

NTSTATUS
HalpAllocatePortRange(
    OUT PUSHORT RangeId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPORT_RANGE OldPortRanges = PortRanges;
    PPORT_RANGE NewPortRanges = NULL;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    
    //
    // First scan the existing ranges, looking for an unused one.
    //

    for (*RangeId = 0; *RangeId < NumPortRanges; *RangeId += 1) {
        if (! PortRanges[*RangeId].InUse) {
            PortRanges[*RangeId].InUse = TRUE;
            return STATUS_SUCCESS;
        }
    }
    

    //
    // Otherwise, grow the set of ranges and copy over the old ones.
    //
    
    NewPortRanges = ExAllocatePool(NonPagedPool,
                                   (NumPortRanges + 1) * sizeof(PORT_RANGE));

    if (NewPortRanges == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (NT_SUCCESS(Status)) {
        RtlCopyMemory(NewPortRanges,
                      OldPortRanges,
                      NumPortRanges * sizeof(PORT_RANGE));
        
        *RangeId = NumPortRanges;

        PortRanges = NewPortRanges;
        NumPortRanges += 1;

        PortRanges[*RangeId].InUse = TRUE;

        if (OldPortRanges != &BasePortRange) {
            ExFreePool(OldPortRanges);
        }
    }

    
    if (! NT_SUCCESS(Status)) {
        //
        // Error case: cleanup.
        //

        if (NewPortRanges != NULL) {
            ExFreePool(NewPortRanges);
        }
    }


    return Status;
}


VOID
HalpFreePortRange(
    IN USHORT RangeId
    )
{
    PPORT_RANGE Range = &PortRanges[RangeId];
    

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    
    ASSERT(Range->InUse);
    Range->InUse = FALSE;

    if (Range->HalMapped) {
        MmUnmapIoSpace(Range->VirtBaseAddr, Range->Length);
    }

    Range->VirtBaseAddr = NULL;
    Range->PhysBaseAddr.QuadPart = 0;
    Range->Length = 0;
}
    

NTSTATUS
HalpAddPortRange(
    IN BOOLEAN IsSparse,
    IN BOOLEAN PrimaryIsMmio,
    IN PVOID VirtBaseAddr OPTIONAL,
    IN PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
    IN ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
    OUT PUSHORT NewRangeId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN HalMapped = FALSE;
    BOOLEAN RangeAllocated = FALSE;


    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    

    Status = HalpAllocatePortRange(NewRangeId);

    RangeAllocated = NT_SUCCESS(Status);


    if (NT_SUCCESS(Status) && (VirtBaseAddr == NULL)) {
        VirtBaseAddr = MmMapIoSpace(PhysBaseAddr, Length, MmNonCached);

        if (VirtBaseAddr == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            HalMapped = TRUE;
        }
    }

    
    if (NT_SUCCESS(Status)) {
        PortRanges[*NewRangeId].IsSparse = IsSparse;
        PortRanges[*NewRangeId].PrimaryIsMmio = PrimaryIsMmio;
        PortRanges[*NewRangeId].HalMapped = HalMapped;
        PortRanges[*NewRangeId].VirtBaseAddr = VirtBaseAddr;
        PortRanges[*NewRangeId].PhysBaseAddr.QuadPart = PhysBaseAddr.QuadPart;
        PortRanges[*NewRangeId].Length = Length;
    }

    
    if (! NT_SUCCESS(Status)) {
        //
        // Error case: cleanup.
        //

        if (HalMapped) {
            MmUnmapIoSpace(VirtBaseAddr, Length);
        }
        
        if (RangeAllocated) {
            HalpFreePortRange(*NewRangeId);
        }
    }


    return Status;
}


PPORT_RANGE
HalpGetPortRange(
    IN USHORT RangeId
    )
{
    PPORT_RANGE Range;

    ASSERT(RangeId < NumPortRanges);

    Range = &PortRanges[RangeId];

    ASSERT(Range->InUse);
    
    return Range;
}


//
// Returns TRUE when RangeId has been set.  Overlapping ranges are
// allowed.
//
BOOLEAN
HalpLookupPortRange(
    IN BOOLEAN IsSparse,        // _TRS
    IN BOOLEAN PrimaryIsMmio,   // FALSE for I/O port space, _TTP
    IN PHYSICAL_ADDRESS PhysBaseAddr,
    IN ULONG Length,
    OUT PUSHORT RangeId
    )
{
    BOOLEAN FoundMatch = FALSE;
    PPORT_RANGE Range;
    

    for (*RangeId = 0; *RangeId < NumPortRanges; *RangeId += 1) {

        Range = &PortRanges[*RangeId];


        if (! Range->InUse) {
            continue;
        }

        
        if ((Range->PrimaryIsMmio == PrimaryIsMmio) &&
            (Range->IsSparse == IsSparse)) {

            if (! PrimaryIsMmio) {
                //
                // Port space on the primary side.  Sparseness doesn't
                // make sense for primary side port space.  Because
                // there is only one primary side port space, which is
                // shared by all I/O bridges, don't check the base
                // address.
                //

                ASSERT(! IsSparse);

                FoundMatch = TRUE;
                break;
            }

            
            if ((Range->PhysBaseAddr.QuadPart == PhysBaseAddr.QuadPart) &&
                (Range->Length == Length)) {
                
                FoundMatch = TRUE;
                break;
            }
        }
    }


    //
    // A matching range was not found.
    //
    return FoundMatch;
}


NTSTATUS
HalpQueryAllocatePortRange(
    IN BOOLEAN IsSparse,
    IN BOOLEAN PrimaryIsMmio,
    IN PVOID VirtBaseAddr OPTIONAL,
    IN PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
    IN ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
    OUT PUSHORT NewRangeId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    
    if (! HalpLookupPortRange(IsSparse,
                              PrimaryIsMmio,
                              PhysBaseAddr,
                              Length,
                              NewRangeId)) {
        
        Status = HalpAddPortRange(IsSparse,
                                  PrimaryIsMmio,
                                  NULL,
                                  PhysBaseAddr,
                                  Length,
                                  NewRangeId);
    }

    
    return Status;
}

UINT_PTR
HalpGetPortVirtualAddress(
   UINT_PTR Port
   )
{

/*++

Routine Description:

   This routine gives 32 bit virtual address for the I/O Port specified.

Arguements:

   PORT - Supplies PORT address of the I/O PORT.

Returned Value:

   UINT_PTR - Virtual address value.

--*/

    PPORT_RANGE PortRange;
    
    //
    // Upper 16 bits of the port handle are the range id.
    //
    USHORT RangeId = (USHORT)((((ULONG)Port) >> 16) & 0xffff);

    USHORT OffsetInRange = (USHORT)(Port & 0xffff);

    ULONG VirtOffset;

    UINT_PTR VirtualPort = 0;


#if 0
    {
        BOOLEAN isUart = FALSE;
        BOOLEAN isVGA = FALSE;


        if (RangeId == 0) {
            if ((OffsetInRange >= 0x3b0) && (OffsetInRange <= 0x3df)) {
                isVGA = TRUE;
            }
            
            if ((OffsetInRange >= 0x2f8) && (OffsetInRange <= 0x2ff)) {
                isUart = TRUE;
            }
            
            if ((OffsetInRange >= 0x3f8) && (OffsetInRange <= 0x3ff)) {
                isUart = TRUE;
            }

            if (!isVGA && !isUart) {
                static UINT32 numRaw = 0;
                InterlockedIncrement(&numRaw);
            }
        } else {
            static UINT32 numUnTra = 0;
            InterlockedIncrement(&numUnTra);
        }
    }
#endif // #if DBG


    PortRange = HalpGetPortRange(RangeId);

    return GetVirtualPort(PortRange, OffsetInRange);
}



UCHAR
READ_PORT_UCHAR(
    PUCHAR Port
    )
{

/*++

Routine Description:

   Reads a byte location from the PORT

Arguements:

   PORT - Supplies the PORT address to read from

Return Value:

   UCHAR - Returns the byte read from the PORT specified.


--*/

    UINT_PTR VirtualPort;
    UCHAR LoadData;

    KIRQL OldIrql;

    
#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_UCHAR(%#x)\n",Port);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Need to ensure load and mfa are not preemptable
    //

    __mf();
    
    OldIrql = KeGetCurrentIrql();
    
    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    

    LoadData = *(volatile UCHAR *)VirtualPort;
    __mfa();
    
    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }

    return (LoadData);
}



USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )
{

/*++

Routine Description:

   Reads a word location (16 bit unsigned value) from the PORT

Arguements:

   PORT - Supplies the PORT address to read from.

Returned Value:

   USHORT - Returns the 16 bit unsigned value from the PORT specified.

--*/

    UINT_PTR VirtualPort;
    USHORT LoadData;

    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_USHORT(%#x)\n",Port);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Need to ensure load and mfa are not preemptable
    //
    __mf();

    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    
    LoadData = *(volatile USHORT *)VirtualPort;
    __mfa();
    
    if (OldIrql < DISPATCH_LEVEL) {
         KeLowerIrql (OldIrql);
    }

    return (LoadData);
}


ULONG
READ_PORT_ULONG (
    PULONG Port
    )
{

/*++

   Routine Description:

      Reads a longword location (32bit unsigned value) from the PORT.

   Arguements:

     PORT - Supplies PORT address to read from.

   Returned Value:

     ULONG - Returns the 32 bit unsigned value (ULONG) from the PORT specified.

--*/

    UINT_PTR VirtualPort;
    ULONG LoadData;

    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_ULONG(%#x)\n",Port);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Need to ensure load and mfa are not preemptable
    //
    __mf();

    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    
    LoadData = *(volatile ULONG *)VirtualPort;
    __mfa();

    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
    
    return (LoadData);
}


ULONG
READ_PORT_ULONG_SPECIAL (
    PULONG Port
    )
{

/*++

   Routine Description:

      Reads a longword location (32bit unsigned value) from the PORT.
      For A0 bug 2173. Does not enable/disable interrupts. Called from first level interrupt
      handler.

   Arguements:

     PORT - Supplies PORT address to read from.

   Returned Value:

     ULONG - Returns the 32 bit unsigned value (ULONG) from the PORT specified.

--*/

    UINT_PTR VirtualPort;
    ULONG LoadData;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_ULONG(%#x)\n",Port);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);
    __mf();
    LoadData = *(volatile ULONG *)VirtualPort;
    __mfa();

    return (LoadData);
}



VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )
{

/*++

   Routine Description:

     Reads multiple bytes from the specified PORT address into the
     destination buffer.

   Arguements:

     PORT - The address of the PORT to read from.

     Buffer - A pointer to the buffer to fill with the data read from the PORT.

     Count - Supplies the number of bytes to read.

   Return Value:

     None.

--*/


    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_BUFFER_UCHAR(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort =   HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    __mf();

    for (i=0; i<Count; i++) {
        *Buffer++ = *(volatile UCHAR *)VirtualPort;
        __mfa();
    }


    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }
}



VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )
{

/*++

    Routine Description:

      Reads multiple words (16bits) from the speicified PORT address into
      the destination buffer.

    Arguements:

      Port - Supplies the address of the PORT to read from.

      Buffer - A pointer to the buffer to fill with the data
               read from the PORT.

      Count  - Supplies the number of words to read.

--*/

    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_BUFFER_USHORT(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    __mf();

    for (i=0; i<Count; i++) {
        *Buffer++ = *(volatile USHORT *)VirtualPort;
        __mfa();
    }


    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }
}


VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )
{

 /*++

    Routine Description:

      Reads multiple longwords (32bits) from the speicified PORT
      address into the destination buffer.

    Arguements:

      Port - Supplies the address of the PORT to read from.

      Buffer - A pointer to the buffer to fill with the data
               read from the PORT.

      Count  - Supplies the number of long words to read.

--*/

    UINT_PTR VirtualPort;
    PULONG ReadBuffer = Buffer;
    ULONG ReadCount;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_BUFFER_ULONG(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    __mf();

    for (i=0; i<Count; i++) {
        *Buffer++ = *(volatile ULONG *)VirtualPort;
        __mfa();
    }

    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }
}

VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR  Value
    )
{

/*++

   Routine Description:

      Writes a byte to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.

      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/

    UINT_PTR VirtualPort;
    KIRQL     OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_UCHAR(%#x,%#x)\n",Port,Value);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

   //
   // Need to ensure load and mfa are not preemptable
   //

    __mf();
 
    OldIrql = KeGetCurrentIrql();
     
    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
           
    *(volatile UCHAR *)VirtualPort = Value;
    __mf();
    __mfa();
    
    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}

VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT  Value
    )
{

/*++

   Routine Description:

      Writes a 16 bit SHORT Integer to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.

      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/

    UINT_PTR VirtualPort;
    KIRQL     OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_USHORT(%#x,%#x)\n",Port,Value);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Need to ensure load and mfa are not preemptable
    //

    __mf();

    OldIrql = KeGetCurrentIrql();
    
    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    *(volatile USHORT *)VirtualPort = Value;
    __mf();
    __mfa();
    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}

VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG  Value
    )
{

/*++

   Routine Description:

      Writes a 32 bit Long Word to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.

      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/

    UINT_PTR VirtualPort;
    KIRQL     OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_ULONG(%#x,%#x)\n",Port,Value);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);
        
    //
    // Need to ensure load and mfa are not preemptable
    //
    __mf();

    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    *(volatile ULONG *)VirtualPort = Value;
    __mf();
    __mfa();
    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}


VOID
WRITE_PORT_ULONG_SPECIAL (
    PULONG Port,
    ULONG  Value
    )
{

/*++

   Routine Description:

      Writes a 32 bit Long Word to the Port specified.
      Assumes context switch is not possible. Used for A0 workaround.
   Arguements:

      Port - The port address of the I/O Port.

      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/

    UINT_PTR VirtualPort;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_ULONG(%#x,%#x)\n",Port,Value);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);
    *(volatile ULONG *)VirtualPort = Value;
    __mf();
    __mfa();

}



VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple bytes from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of bytes to write.

   Return Value:

     None.

--*/


    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_BUFFER_UCHAR(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    for (i=0; i<Count; i++) {
        *(volatile UCHAR *)VirtualPort = *Buffer++;
        __mfa();
    }

    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    __mf();
}


VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple 16bit short integers from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of (16 bit) words to write.

   Return Value:

     None.

--*/


    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_BUFFER_USHORT(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    for (i=0; i<Count; i++) {
        *(volatile USHORT *)VirtualPort = *Buffer++;
        __mfa();
    }


    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    __mf();
}

VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple 32bit long words from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of (32 bit) long words to write.

   Return Value:

     None.

--*/


    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_BUFFER_ULONG(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);


    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    for (i=0; i<Count; i++) {
        *(volatile ULONG *)VirtualPort = *Buffer++;
        __mfa();
    }


    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    __mf();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64kd.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64kd copied from simkd.c

Abstract:

    Kernel debug com support.

Author:

    14-Apr-1995

    Bernard Lint, M. Jayakumar

Environment:

    Kernel mode

Revision History:

--*/
#include "halp.h"
#include "stdio.h"

//
// Timeout_count 1024 * 200 
//
#define TIMEOUT_COUNT  2     

#define GET_RETRY_COUNT  1024
#define IA64_MSG_DEBUG_ENABLE         "Kernel Debugger Using: COM%x (Port 0x%x, Baud Rate %d)\n"
#define IA64_MSG2_DEBUG_ENABLE        "Kernel Debugger Using named pipe: COM%x (Port 0x%x, Baud Rate %d)\n"

PUCHAR KdComPortInUse=NULL;


BOOLEAN
KdPortInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    BOOLEAN Initialize
    )

/*++

Routine Description:

    This routine initialize a com port to support kernel debug.

Arguments:

    DebugParameters - Supplies a pointer a structure which optionally
                      sepcified the debugging port information.

    LoaderBlock - supplies a pointer to the loader parameter block.

    Initialize - Specifies a boolean value that determines whether the
                 debug port is initialized or just the debug port parameters
                 are captured.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PUCHAR PortAddress = NULL;
    ULONG Com = 0;
    UCHAR DebugMessage[80];
    PHYSICAL_ADDRESS LPDebugParameters;


    if (Initialize) {
        LPDebugParameters = MmGetPhysicalAddress (DebugParameters);
        if ( !SscKdInitialize((PVOID) LPDebugParameters.QuadPart, (SSC_BOOL)Initialize )) { 

        // SscKd initialized sucessfully

        Com = DebugParameters->CommunicationPort;

            //
            // initialize port struct. if not named-pipe
            //
            if ( Com != 0 ) {   
 
                //
                // set port address to default value.
                //

                if (PortAddress == NULL) {
                    switch (Com) {
                    case 1:
                       PortAddress = (PUCHAR)0x3f8;
                       break;
                    case 2:
                       PortAddress = (PUCHAR)0x2f8;
                       break;
                    case 3:
                       PortAddress = (PUCHAR)0x3e8;
                       break;
                    case 4:
                       PortAddress = (PUCHAR)0x2e8;
                    }
                }

                KdComPortInUse= PortAddress;

                sprintf(
                    DebugMessage, 
                    IA64_MSG_DEBUG_ENABLE,
                    Com, 
                    PtrToUlong(PortAddress), 
                    DebugParameters->BaudRate
                    );

                HalDisplayString("\n");
                HalDisplayString(DebugMessage);
            }

            //
            // port = 0, named-pipe
            //
            
            else {   
                sprintf(
                    DebugMessage,
                    IA64_MSG2_DEBUG_ENABLE,
                    Com,
                    PtrToUlong(PortAddress), 
                    DebugParameters->BaudRate
                    );
                HalDisplayString("\n");
                HalDisplayString(DebugMessage);
            }
            return(TRUE);
        }
        //
        // SscKdinitialize() failed.
        //  

        else {
            
            return(FALSE);
        
        }
    }

    //
    // By pass. do not initialize
    //
    else { 
        return(FALSE);
    }
}

ULONG
KdPortGetByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it.

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
    necessary multiprocessor synchronization has been performed before this
    routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
    kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    PHYSICAL_ADDRESS LPInput;
    UCHAR DebugMessage[80];
    ULONG   limitcount, status;

    LPInput = MmGetPhysicalAddress (Input);
    limitcount = GET_RETRY_COUNT;

    while (limitcount != 0) {
        limitcount--;

        status = SscKdPortGetByte((PVOID)LPInput.QuadPart);
        if (status == CP_GET_SUCCESS) {
#ifdef KDDBG
            sprintf(DebugMessage,"%02x ", *Input);
            HalDisplayString(DebugMessage);
#endif
            return(CP_GET_SUCCESS);
        }
#ifdef KDDBG
        else {
            HalDisplayString(".");
        }
#endif
    }
    return status;
}

ULONG
KdPortPollByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it if one is available.

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
    kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    PHYSICAL_ADDRESS LPInput;
    UCHAR DebugMessage[80];
    ULONG   limitcount, status;
    
    LPInput = MmGetPhysicalAddress (Input);
    limitcount = TIMEOUT_COUNT;

    while (limitcount != 0) {
        limitcount--;

        status = SscKdPortGetByte((PVOID)LPInput.QuadPart);
        if (status == CP_GET_ERROR)
            return(CP_GET_ERROR);
        if (status == CP_GET_SUCCESS) {
#ifdef KDDBG
            sprintf(DebugMessage, "%02x ", *Input);
            HalDisplayString(DebugMessage);
#endif
            return(CP_GET_SUCCESS);
        }
#ifdef KDDBG
        HalDisplayString(".");
#endif
    }
    return (CP_GET_NODATA);
}

VOID
KdPortPutByte (
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the debug port.  
    
    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
#ifdef KDDBG
    UCHAR DebugMessage[80];

    sprintf(DebugMessage, "%02x-", Output);
    HalDisplayString(DebugMessage);
#endif
    SscKdPortPutByte(Output);
}

VOID
KdPortRestore (
    VOID
    )

/*++

Routine Description:

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/

{

}

VOID
KdPortSave (
    VOID
    )

/*++

Routine Description:

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64lock.c ===
/*++

Module Name:

    i64lock.c copied from ixlock.asm

Abstract:

    This module contains the lock routines.

Author:

    Bernard Lint,   M. Jayakumar

Revision History:

    Bernard Lint 6-Jun-1995: IA64 version based on MIPS version.
	Todd Kjos    1-Jun-1998: Added versions of HighLevelLock services.

--*/



#include "halp.h"

ULONG
HalpAcquireHighLevelLock (
    PKSPIN_LOCK Lock
)

/*++ 

Routine Description:

	Turns off interrupts and acquires a spinlock.  Note: Interrupts MUST
	be enabled on entry.

Arguments:

	Lock to acquire

Return Value:

	Previous IRQL

--*/

{
    BOOLEAN Enabled;
    KIRQL   OldLevel;

    ASSERT(sizeof(ULONG) >= sizeof(KIRQL));
    KeRaiseIrql(HIGH_LEVEL, &OldLevel);
    Enabled = HalpDisableInterrupts();
    ASSERT(Enabled);
    KiAcquireSpinLock(Lock);
    return((ULONG)OldLevel);
}


VOID
HalpReleaseHighLevelLock ( 
    PKSPIN_LOCK Lock,
    ULONG       OldLevel
)
/*++ 

Routine Description:

	Releases a spinlock and turns interrupts back on

Arguments:

	Lock - Lock to release
	OldLevel - Context returned by HalpAcquireHighLevelLock

Return Value:

	None

--*/


/*++

Routine Description:

Arguments:  

Return Value:

--*/

{
    KiReleaseSpinLock(Lock);
    HalpEnableInterrupts();
    KeLowerIrql((KIRQL)OldLevel);

}


VOID
HalpSerialize ( )

/*++

Routine Description:

Arguements: 

Return Value:

--*/
{
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64prfls.s ===
//++
// TITLE ("Performance Monitor Control & Data Register Accesses")
//
//
//
// Copyright (c) 1995  Intel Corporation
//
// Module Name:
//
//    i64prfls.s 
//
// Abstract:
//
//    This module implements Profiling.
//
// Author:
//
//    Bernard Lint, M. Jayakumar 1 Sep '99
//
// Environment:
//
//    Kernel mode
//
// Revision History:
//
//--

#include "ksia64.h"

        .file "i64prfls.s"


//
// The following functions are defined until the compiler supports 
// the intrinsics __setReg() and __getReg() for the CV_IA64_PFCx, 
// CV_IA64_PFDx and CV_IA64_SaPMV registers.
// Anyway, these functions might stay for a while, the compiler
// having no consideration for micro-architecture specific 
// number of PMCs/PMDs.
//

        LEAF_ENTRY(HalpFreezeProfileCounting)
        rsm         (1 << PSR_UP) | (1 << PSR_PP)
        LEAF_RETURN
        LEAF_EXIT(HalpFreezeProfileCounting)

        LEAF_ENTRY(HalpUnFreezeProfileCounting)
        ssm         (1 << PSR_UP) | (1 << PSR_PP)
        LEAF_RETURN
        LEAF_EXIT(HalpUnFreezeProfileCounting)

        LEAF_ENTRY(HalpReadPerfMonVectorReg)
        LEAF_SETUP(0,0,0,0)
        mov         v0 = cr.pmv
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpReadPerfMonVectorReg)

        LEAF_ENTRY(HalpWritePerfMonVectorReg)
        LEAF_SETUP(1,0,0,0)
        mov         cr.pmv = a0
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpWritePerfMonVectorReg)

        LEAF_ENTRY(HalpWritePerfMonCnfgReg)
        LEAF_SETUP(2,0,0,0)
        rPMC        = t15
        mov         rPMC = a0
        ;;
        mov         pmc[rPMC] = a1 
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpWritePerfMonCnfgReg)

        LEAF_ENTRY(HalpClearPerfMonCnfgOverflows)
        LEAF_SETUP(4,0,0,0)
        rPMC0       = t0
        rPMC1       = t1
        rPMC2       = t2
        rPMC3       = t3
        rPMC0val    = t4
        rPMC1val    = t5
        rPMC2val    = t6
        rPMC3val    = t7
        // Thierry - FIXFIX 03/4/2002:
        // Still need tuning to streamline SCRAB.
        mov         rPMC3 = 3
        mov         rPMC2 = 2
        ;;
        mov         rPMC3val = pmc[rPMC3]
        mov         rPMC2val = pmc[rPMC2]
        mov         rPMC1 = 1
        mov         rPMC0 = 0
        ;;
        mov         rPMC1val = pmc[rPMC1]
        mov         rPMC0val = pmc[rPMC0]
        and         rPMC3val = rPMC3val, a3
        ;;
        mov         pmc[rPMC3] = rPMC3val
        and         rPMC2val = rPMC2val, a2
        ;;
        mov         pmc[rPMC2] = rPMC2val
        and         rPMC1val = rPMC1val, a1
        ;;
        mov         pmc[rPMC1] = rPMC1val
        and         rPMC0val = rPMC0val, a0
        ;;
        mov         pmc[rPMC0] = rPMC0val
        LEAF_RETURN
        LEAF_EXIT(HalpClearPerfMonCnfgOverflows)

        LEAF_ENTRY(HalpReadPerfMonCnfgReg)
        LEAF_SETUP(1,0,0,0)
        rPMC        = t15
        mov         rPMC = a0
        ;;
        mov         v0 = pmc[rPMC]  
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpReadPerfMonCnfgReg)

        LEAF_ENTRY(HalpWritePerfMonDataReg)
        LEAF_SETUP(2,0,0,0)
        rPMD    = t15
        mov     rPMD = a0
        ;;
        mov     pmd[rPMD] = a1
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpWritePerfMonDataReg)

        LEAF_ENTRY(HalpReadPerfMonDataReg)
        LEAF_SETUP(1,0,0,0)
        rPMD        = t15
        mov         rPMD = a0
        ;;
        mov         v0 = pmd[rPMD] 
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpReadPerfMonDataReg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64perfc.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64perfc.c copied from  simperfc.c

Abstract:

    This module implements the routines to support performance counters.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "eisa.h"

//
// Define and initialize the 64-bit count of total system cycles used
// as the performance counter.
//

ULONGLONG HalpCycleCount = 0;

BOOLEAN HalpITCCalibrate = TRUE; // XXTF

extern ULONGLONG HalpITCFrequency;

extern ULONGLONG HalpClockCount;

#if 0

VOID
HalpCheckPerformanceCounter(
    VOID
    )

Routine Description:

    This function is called every system clock interrupt in order to
    check for wrap of the performance counter.  The function must handle
    a wrap if it is detected.

    N.B. - This function was from the Alpha HAL.
           This function must be called at CLOCK_LEVEL.

Arguments:

    None.

Return Value:

    None.

{

    return;

} // HalpCheckPerformanceCounter()

#endif // 0


LARGE_INTEGER
KeQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency.

Arguments:

    PerformanceFrequency - optionally, supplies the address
    of a variable to receive the performance counter frequency.

Return Value:

    Current value of the performance counter will be returned.

--*/

{
    LARGE_INTEGER   result;

    if (ARGUMENT_PRESENT(PerformanceFrequency)) {

       PerformanceFrequency->QuadPart = HalpITCFrequency;
    }

    result.QuadPart = HalpReadITC();

    return result;

} // KeQueryPerformanceCounter()



VOID
HalCalibratePerformanceCounter (
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    )

/*++

Routine Description:

    This routine sets the performance counter value for the current
    processor to the specified valueo.
    The reset is done such that the resulting value is closely
    synchronized with other processors in the configuration.

Arguments:

    Number - Supplies a pointer to count of the number of processors in
    the configuration.

Return Value:

    None.

--*/
{
    KSPIN_LOCK Lock;
    KIRQL      OldIrql;

    if ( HalpITCCalibrate )   {

        //
        // Raise IRQL to HIGH_LEVEL, decrement the number of processors, and
        // wait until the number is zero.
        //

        KeInitializeSpinLock(&Lock);
        KeRaiseIrql(HIGH_LEVEL, &OldIrql);

        PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] = NewCount + HalpClockCount;
        HalpWriteITM( PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] );

        if (ExInterlockedDecrementLong((PLONG)Number, &Lock) != RESULT_ZERO) {
            do {
            } while (*((LONG volatile *)Number) !=0);
        }

        //
        // Write the compare register with defined current ITM value,
        // and set the performance counter for the current processor
        // with the passed count.
        //

        HalpWriteITC( NewCount );

        //
        // Restore IRQL to its previous value and return.
        //

        KeLowerIrql(OldIrql);

    } else {

        *Number = 0;

    }

    return;

} // HalCalibratePerformanceCounter()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64sapic.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    i64sapic.c

Abstract:

    Implements I/O Sapic functionality

Author:

    Todd Kjos (HP) (v-tkjos) 1-Jun-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "iosapic.h"

#include <ntacpi.h>

VOID
IoSapicMaskEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    );

VOID
IoSapicSetEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    );

VOID
IoSapicEnableEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    );

//
// Method structure for control of IO Sapic Hardware
//
INTR_METHODS HalpIoSapicMethods = {
    IoSapicMaskEntry,
    IoSapicSetEntry,
    IoSapicEnableEntry
};

VOID
HalpInti2InterruptController (
    IN  ULONG   InterruptInput,
    OUT PIO_INTR_CONTROL *InterruptController,
    OUT PULONG  ControllerInti
    )
/*++

Routine Description:

    Convert InterruptInput to an interrupt controller
    structure and input number

Arguments:

   InterruptInput -  System Global Interrupt Input

   InterruptController - Pointer to Interupt controller structure

   ControllerInti - Redirection Table Entry on this interrupt controller

Return Value:

--*/
{
    PIO_INTR_CONTROL IoUnit;

    for (IoUnit=HalpIoSapicList; IoUnit; IoUnit=IoUnit->flink) {

        if (InterruptInput <= IoUnit->IntiMax) {

            if (IoUnit->IntiBase > InterruptInput) {
                //
                // If there are holes in the list of Global System Vectors AND
                // someone specifies one of the non-existant GSVs, make sure we
                // return an error rather than getting horribly confused about
                // which IOAPIC contains the Inti.
                //
                IoUnit = NULL;
            }
            break;
        }
    }

    *InterruptController = IoUnit;

    if (IoUnit) {

        *ControllerInti = InterruptInput-IoUnit->IntiBase;
    }
}


BOOLEAN
HalpGetSapicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PULONG Inti,
    OUT PKAFFINITY InterruptAffinity
    )
/*++

Routine Description:

    This procedure gets a "Inti" describing the requested interrupt

Arguments:

    BusType - The Bus type as known to the IO subsystem

    BusNumber - The number of the Bus we care for

    BusInterruptLevel - IRQ on the Bus


Return Value:

    TRUE if AcpiInti found; otherwise FALSE.

    Inti - Global system interrupt input

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController(BusInterruptLevel, &IoUnit, &RteNumber);

    // Make sure Inti is not out of range
    if (IoUnit == NULL)  {

        return FALSE;
    }

    // It's in range, just give back the same value as was passed in
    *Inti = BusInterruptLevel;

    //
    // The Interrupt affinity is the intersection of the global affinity mask
    // (HalpDefaultInterruptAffinity) and any additional restrictions due to the
    // location of the Io Sapic (IoUnit->InterruptAffinity).
    //
    *InterruptAffinity = IoUnit->InterruptAffinity & HalpDefaultInterruptAffinity;
    return(TRUE);
}

ULONG
HalpINTItoVector(
    ULONG   Inti
)
    // Returns the Vector associated with this global interrupt input
    // Vector is node and IDT entry
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController( Inti, &IoUnit, &RteNumber );

    ASSERT(IoUnit);

    return (IoUnit->Inti[RteNumber].GlobalVector);
}

VOID
HalpSetINTItoVector(
    ULONG   Inti,
    ULONG   Vector
)
    // Sets the vector for this global interrupt input
    // Vector is node and IDT entry
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController( Inti, &IoUnit, &RteNumber );

    ASSERT(IoUnit);

    // .Vector (IDTEntry) is set in SetRedirEntry
    IoUnit->Inti[RteNumber].GlobalVector =  Vector;
}

VOID
HalpSetRedirEntry (
    IN ULONG InterruptInput,
    IN ULONG Entry,
    IN USHORT ThisCpuApicID
    )
/*++

Routine Description:

    This procedure sets a IO Unit Redirection Table Entry

    Must be called with the HalpAccountingLock held

Arguments:

Return Value:

    None.

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController( InterruptInput, &IoUnit, &RteNumber );

    ASSERT(IoUnit);
    ASSERT(IoUnit->Inti[RteNumber].GlobalVector);
    ASSERT((UCHAR)(IoUnit->Inti[RteNumber].GlobalVector) == (UCHAR)Entry);

    IoUnit->Inti[RteNumber].Vector = Entry;
    IoUnit->Inti[RteNumber].Destination = ThisCpuApicID << 16;

    IoUnit->FreeVectors[Entry >> 4] &= ~(1 << (Entry & 0x0F));

    IoUnit->IntrMethods->SetEntry(IoUnit, RteNumber);
}

VOID
HalpWriteRedirEntry (
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags,
    IN ULONG  InterruptType
    )
{
    ULONG rteNumber;
    PIO_INTR_CONTROL ioUnit;

    HalpInti2InterruptController( GlobalInterrupt, &ioUnit, &rteNumber );

    ASSERT(ioUnit);

    ioUnit->Inti[rteNumber].Vector = SapicVector;

    //
    // Set the delivery mode
    //

    switch (InterruptType) {
    case PLATFORM_INT_PMI:
        ioUnit->Inti[rteNumber].Vector &= ~INT_TYPE_MASK;   // first clear the field
        ioUnit->Inti[rteNumber].Vector |= DELIVER_SMI;
        break;

    case PLATFORM_INT_CPE:
        ioUnit->Inti[rteNumber].Vector &= ~INT_TYPE_MASK;   // first clear the field
        ioUnit->Inti[rteNumber].Vector |= DELIVER_LOW_PRIORITY;
        break;

    case PLATFORM_INT_INIT:
        ioUnit->Inti[rteNumber].Vector &= ~INT_TYPE_MASK;   // first clear the field
        ioUnit->Inti[rteNumber].Vector |= DELIVER_INIT;
        break;
    }

    //
    // So we honor the flags passed into this function.
    //

    if (IS_LEVEL_TRIGGERED_MPS(Flags)) {
        ioUnit->Inti[rteNumber].Vector |= LEVEL_TRIGGERED;
    } else {
        ioUnit->Inti[rteNumber].Vector &= ~LEVEL_TRIGGERED;
    }

    if (IS_ACTIVE_LOW_MPS(Flags)) {
        ioUnit->Inti[rteNumber].Vector |= ACTIVE_LOW;
    } else {
        ioUnit->Inti[rteNumber].Vector &= ~ACTIVE_LOW;
    }

    ioUnit->Inti[rteNumber].Destination = DestinationCPU << 16;

    ioUnit->FreeVectors[SapicVector >> 4] &= ~(1 << (SapicVector & 0x0F));

    ioUnit->IntrMethods->SetEntry(ioUnit, rteNumber);

} // HalpWriteRedirEntry()

VOID
HalpGetRedirEntry (
    IN ULONG  InterruptInput,
    IN PULONG Entry,
    IN PULONG Destination
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController( InterruptInput,&IoUnit,&RteNumber );

    ASSERT(IoUnit);

    *Entry = IoUnit->Inti[RteNumber].Vector;
    *Destination = IoUnit->Inti[RteNumber].Destination;
}

VOID
HalpGetFreeVectors(
    IN  ULONG InterruptInput,
    OUT PUSHORT *FreeVectors
    )
{
    ULONG rteNumber;
    PIO_INTR_CONTROL ioUnit;

    HalpInti2InterruptController( InterruptInput, &ioUnit, &rteNumber );

    ASSERT(ioUnit);

    *FreeVectors = ioUnit->FreeVectors;
}

VOID
HalpSetVectorAllocated(
    IN  ULONG InterruptInput,
    IN  UCHAR Vector
    )
{
    ULONG rteNumber;
    PIO_INTR_CONTROL ioUnit;

    HalpInti2InterruptController( InterruptInput, &ioUnit, &rteNumber );

    ASSERT(ioUnit);

    ioUnit->FreeVectors[Vector >> 4] &= ~(1 << (Vector & 0xF));
}

VOID
HalpEnableRedirEntry(
    IN ULONG InterruptInput
    )
/*++

Routine Description:

    This procedure enables a IO Unit Redirection Table Entry
    by setting the mask bit in the Redir Entry.

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController( InterruptInput, &IoUnit, &RteNumber );

    ASSERT(IoUnit);

    IoUnit->IntrMethods->EnableEntry(IoUnit, RteNumber);
}

VOID
HalpDisableRedirEntry(
    IN ULONG InterruptInput
    )
/*++

Routine Description:

    This procedure disables a IO Unit Redirection Table Entry
    by setting the mask bit in the Redir Entry.

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController( InterruptInput, &IoUnit, &RteNumber );

    ASSERT(IoUnit);

    IoUnit->IntrMethods->MaskEntry(IoUnit, RteNumber);
}


VOID
IoSapicMaskEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    )
{
    PIO_SAPIC_REGS IoSapicPtr = IoUnit->RegBaseVirtual;

    IoSapicPtr->RegisterSelect = RteNumber * 2 + IO_REDIR_00_LOW;
    IoSapicPtr->RegisterWindow |= INTERRUPT_MASKED;

    HalDebugPrint(( HAL_VERBOSE, "HAL: IoSapicMaskEntry - %d [%#p]: Dest=%#x  Vec=%#x\n",
                    RteNumber,IoSapicPtr,
                    IoUnit->Inti[RteNumber].Destination,
                    IoUnit->Inti[RteNumber].Vector
                 ));
}


VOID
IoSapicEnableEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    )
{
    PIO_SAPIC_REGS IoSapicPtr = IoUnit->RegBaseVirtual;

    IoSapicPtr->RegisterSelect = RteNumber * 2 + IO_REDIR_00_LOW;
    IoSapicPtr->RegisterWindow &= (~INTERRUPT_MASKED);

    HalDebugPrint(( HAL_VERBOSE, "HAL: IoSapicEnableEntry: %d [%#p]: Dest=%#x  Vec=%#x\n",
             RteNumber, IoSapicPtr,
             IoUnit->Inti[RteNumber].Destination,
             IoUnit->Inti[RteNumber].Vector
             ));
}

VOID
IoSapicSetEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    )
{
    PIO_SAPIC_REGS IoSapicPtr = IoUnit->RegBaseVirtual;
    ULONG  RedirRegister;
    PULONG_PTR EoiValue;
    USHORT ApicId;

    // Only SetEntry sets the eoi table because set entry is the only
    // one that sets the destination CPU.

    EoiValue = (PULONG_PTR)(IoUnit->Inti[RteNumber].Vector & LEVEL_TRIGGERED ? &IoSapicPtr->Eoi : 0 );

    ApicId = (USHORT)((IoUnit->Inti[RteNumber].Destination & SAPIC_XID_MASK) >> SAPIC_XID_SHIFT);

    HalpWriteEOITable(
        IoUnit->Inti[RteNumber].Vector & INT_VECTOR_MASK,
        EoiValue,
        HalpGetProcessorNumberByApicId(ApicId));

    RedirRegister = RteNumber * 2 + IO_REDIR_00_LOW;

    IoSapicPtr->RegisterSelect = RedirRegister+1;
    IoSapicPtr->RegisterWindow = IoUnit->Inti[RteNumber].Destination;
    IoSapicPtr->RegisterSelect = RedirRegister;
    IoSapicPtr->RegisterWindow = IoUnit->Inti[RteNumber].Vector; // Enable

    HalDebugPrint(( HAL_VERBOSE, "HAL: IoSapicSetEntry: %d [%#p]: Dest=%#x  Vec=%#x  Eoi=%#p\n",
             RteNumber, IoSapicPtr,
             IoUnit->Inti[RteNumber].Destination,
             IoUnit->Inti[RteNumber].Vector,
             EoiValue
             ));

}

BOOLEAN
HalpIsActiveLow(
    ULONG Inti
    )
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    return( (IoUnit->Inti[RteNumber].Vector & ACTIVE_LOW) == ACTIVE_LOW);
}

BOOLEAN
HalpIsLevelTriggered(
    ULONG Inti
    )
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);
    return( (IoUnit->Inti[RteNumber].Vector & LEVEL_TRIGGERED) == LEVEL_TRIGGERED);
}

VOID
HalpSetPolarity(
    ULONG Inti,
    BOOLEAN ActiveLow
    )
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);
    if (ActiveLow) {
        IoUnit->Inti[RteNumber].Vector |= ACTIVE_LOW;
    } else {
        IoUnit->Inti[RteNumber].Vector &= ~ACTIVE_LOW;
    }
}

VOID
HalpSetLevel(
    ULONG Inti,
    BOOLEAN LevelTriggered
    )
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);
    if (LevelTriggered) {
        IoUnit->Inti[RteNumber].Vector |= LEVEL_TRIGGERED;
    } else {
        IoUnit->Inti[RteNumber].Vector &= ~LEVEL_TRIGGERED;
    }
}

VOID
HalpSpuriousHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME        TrapFrame
    )

/*++
    Routine Description:

        Spurious Interrupt handler. Dummy return or we can count number of
        occurance of spurious interrupts. Right now, we will do a dummy return.

    Arguements:


    Return Parameters:

--*/


{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64prfle.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    i64prfle.c

Abstract:


    This module implements the IA64 Hal Profiling using the performance
    counters within the core of the first IA64 Processor Merced, aka Itanium.  
    This module is appropriate for all machines based on microprocessors using
    the Merced core.
    
    With the information known at this development time, this module tries to 
    consider the future IA64 processor cores by encapsulating the differences 
    in specific micro-architecture data structures. 
    
    Furthermore, with the implementation of the new NT ACPI Processor driver, this
    implementation will certainly change in the coming months.
    
    N.B. - This module assumes that all processors in a multiprocessor
           system are running the microprocessor at the same clock speed.
           
Author:

    Thierry Fevrier 08-Feb-2000

Environment:

    Kernel mode only.

Revision History:

    02-2002: Thierry for McKinley support.

--*/

#include "halp.h"

//
// Assumptions for the current implementation - 02/08/2000 :
// These assumptions will be re-evaluated and worked out if required.
//
//  - Respect and satisfy as much possible the Profiling Sources interface
//    already defined by NT and HAL.
//
//  - All processors in a multiprocessor system are running the microprocessor 
//    at the same invariant clock speed.
//     
//  - All processors are configured with the same set of profiling counters. 
//    XXTF - 04/01/2000 - This assumption is being re-worked and will disappear.
//
//  - Profiling is based on the processor monitored events and if possible 
//    on derived events.
//
//  - A monitored event can only be enabled on one performance counter at a time. 
//

//
// IA64 performance counters defintions:
//      - event counters
//      - EARS
//      - BTBs
//      - ...
//

#include "ia64prof.h"
#include "merced.h"
#include "mckinley.h"

//
// HALIA64 Processor PMC Reset definitions:
//
//
// PMC Reset value:
// Reg.   Field         Bits                        
// PMC*   .plm       -  3: 0 - Privilege Mask       - 0 (Disable Counter)
// PMC*   .ev        -     4 - External Visibility  - 0 (Disabled)
// PMC*   .oi        -     5 - Overflow Interrupt   - 0 (Disabled)
// PMC*   .pm        -     6 - Privilege Monitor    - 0 (user monitor)
// PMC*   .ig        -     7 - Ignored              - 0
// PMC*   .es        - 14: 8 - Event Select         - 0 (Warning - 0x0 = Real Event)
// PMC*   .ig        -    15 - Ignored              - 0
// PMC*   .umask     - 19:16 - Unit Mask            - 0 (event specific. ok for .es=0)
// PMC4,5 .threshold - 22:20 - Threshold            - 0 (multi-occurence events threshold)
// PMC4   .pmu       -    23 - enable PMU           - 1 
// PMC5   .ig        -    23 - Ignored              - 0
// PMC6,7 .threshold - 21:20 - Threshold            - 0 (multi-occurence events threshold)
// PMC6,7 .ig        - 23:22 - Ignored              - 0
// PMC*   .ism       - 25:24 - Instruction Set Mask - 0 (IA64 & IA32 sets - 11:disables monitoring)
// PMC*   .ig        - 63:26 - Ignored
//                                                  ===
//                                                  HALP_PMC_RESET
//                                                  HALP_PMC4_RESET
//

#define HALP_PMC_RESET  0x0000000000000000ui64
#define HALP_PMC4_RESET 0x0000000000800000ui64   // PMC4.pmu{bit23} enabled.

//
// HALIA64 Processor PMC Clear Status Masks:
//
// Note - FIXFIX - Merced, McKinley specific definitions.
// 

#define HALP_PMC0_CLEAR_STATUS_MASK 0xFFFFFFFFFFFFFF0Eui64
#define HALP_PMC1_CLEAR_STATUS_MASK 0xFFFFFFFFFFFFFFFFui64
#define HALP_PMC2_CLEAR_STATUS_MASK 0xFFFFFFFFFFFFFFFFui64
#define HALP_PMC3_CLEAR_STATUS_MASK 0xFFFFFFFFFFFFFFFFui64

////////////////
//
// HALIA64 Profile IA64 MicroArchitecture NameSpace
//

extern HALP_PROFILE_MAPPING HalpMercedProfileMapping[];
extern HALP_PROFILE_MAPPING HalpMcKinleyProfileMapping[];

#define HalpMercedPerfMonDataMaximumCount   ((((ULONGLONG)1)<<32)-1)
#define HalpMcKinleyPerfMonDataMaximumCount ((((ULONGLONG)1)<<47)-1)

typedef enum _HALP_PROFILE_MICROARCHITECTURE {
    HALP_PROFILE_IA64_MERCED   = 0x0,
    HALP_PROFILE_IA64_MCKINLEY = 0x1,
} HALP_PROFILE_MICROARCHITECTURE;

struct _HALP_PROFILE_INFO {
    HALP_PROFILE_MICROARCHITECTURE   ProfileMicroArchitecture;
    BOOLEAN                          ProfilePerfMonCnfg0FreezeBitInterrupt;
    BOOLEAN                          ProfileSpare0;
    USHORT                           ProfilePerfMonGenericPairs;
    HALP_PROFILE_MAPPING            *ProfileMapping;
    ULONG                            ProfileSourceMaximum;
    ULONG                            ProfileSourceDerivedEventMinimum;
    ULONGLONG                        ProfilePerfMonDataMaximumCount;
    ULONGLONG                        ProfilePerfMonCnfg0ClearStatusMask;
    ULONGLONG                        ProfilePerfMonCnfg1ClearStatusMask;
    ULONGLONG                        ProfilePerfMonCnfg2ClearStatusMask;
    ULONGLONG                        ProfilePerfMonCnfg3ClearStatusMask;
} HalpProfileInfo = {
//
// Default IA64 Profiling to McKinley-core 
//
// Note that different models in a family might have different PMU implementations.
//
    HALP_PROFILE_IA64_MCKINLEY,
    TRUE,
    0,
    NUMBER_OF_PERFMON_REGISTER_PAIRS,
    HalpMcKinleyProfileMapping,
    ProfileMcKinleyMaximum,
    ProfileMcKinleyDerivedEventMinimum,
    HalpMcKinleyPerfMonDataMaximumCount,
    HALP_PMC0_CLEAR_STATUS_MASK,
    HALP_PMC1_CLEAR_STATUS_MASK,
    HALP_PMC2_CLEAR_STATUS_MASK,
    HALP_PMC3_CLEAR_STATUS_MASK
};

#define HalpProfileIA64MicroArchitecture   HalpProfileInfo.ProfileMicroArchitecture
#define HalpProfileMapping                 HalpProfileInfo.ProfileMapping

#define HalpProfileIA64Maximum             HalpProfileInfo.ProfileSourceMaximum
#define HalpProfileIA64DerivedEventMinimum HalpProfileInfo.ProfileSourceDerivedEventMinimum

#define HalpPerfMonGenericPairs            HalpProfileInfo.ProfilePerfMonGenericPairs
#define HalpPerfMonDataMaximumCount        HalpProfileInfo.ProfilePerfMonDataMaximumCount
#define HalpPerfMonCnfg0FreezeBitInterrupt HalpProfileInfo.ProfilePerfMonCnfg0FreezeBitInterrupt
#define HalpPerfMonCnfg0ClearStatusMask    HalpProfileInfo.ProfilePerfMonCnfg0ClearStatusMask
#define HalpPerfMonCnfg1ClearStatusMask    HalpProfileInfo.ProfilePerfMonCnfg1ClearStatusMask
#define HalpPerfMonCnfg2ClearStatusMask    HalpProfileInfo.ProfilePerfMonCnfg2ClearStatusMask
#define HalpPerfMonCnfg3ClearStatusMask    HalpProfileInfo.ProfilePerfMonCnfg3ClearStatusMask

//
// End of HALIA64 Profile IA64 MicroArchitecture NameSpace
//
////////////////

//
// HALIA64 Profile Source Mapping macros:
//

#define HalpDisactivateProfileSource( _ProfileSource ) ((_ProfileSource)  = HalpProfileIA64Maximum)
#define HalpIsProfileSourceActive( _ProfileSource )    ((_ProfileSource) != HalpProfileIA64Maximum)           
#define HalpIsProfileMappingInvalid( _ProfileMapping ) \
            (!(_ProfileMapping) || ((_ProfileMapping)->Supported == FALSE))

// HalpIsProfileSourceDerivedEvent assumes ProfileMapping is valid and supported.

#define HalpIsProfileSourceDerivedEvent( _ProfileSource, _ProfileMapping ) \
            (((_ProfileSource) >= (KPROFILE_SOURCE)HalpProfileIA64DerivedEventMinimum) ||   \
             ((_ProfileMapping)->Event >= 0x100))

VOID
HalpSetProfileMicroArchitecture(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

   This function sets the HAL Profile MicroArchitecture namespace.

Arguments:

   None.

Return Value:

   None.

--*/
{
   ULONGLONG cpuFamily;
   PIA64_PERFMON_INFO perfMonInfo;
   USHORT    genericPairs;

   cpuFamily   =  ((LoaderBlock->u.Ia64.ProcessorConfigInfo.CpuId3) >> 24) & 0xff;
   perfMonInfo =  &LoaderBlock->u.Ia64.ProcessorConfigInfo.PerfMonInfo;

   HalpPerfMonDataMaximumCount =
        ((((ULONGLONG)1)<<(perfMonInfo->ImplementedCounterWidth))-1);
   genericPairs = HalpPerfMonGenericPairs = (USHORT) perfMonInfo->PerfMonGenericPairs;
#if 0
// 03/2002 FIXFIX ToBeTested.
   HalpPerfMonCnfg3ClearStatusMask = (genericPairs > 192) ? ((ULONGLONG)-1) << (genericPairs - 192)
                                                          : HALP_PMC3_CLEAR_STATUS_MASK; 
   HalpPerfMonCnfg2ClearStatusMask = (genericPairs > 128) ? ((ULONGLONG)-1) << (genericPairs - 128)
                                                          : HALP_PMC2_CLEAR_STATUS_MASK; 
   HalpPerfMonCnfg1ClearStatusMask = (genericPairs >  64) ? ((ULONGLONG)-1) << (genericPairs -  64)
                                                          : HALP_PMC1_CLEAR_STATUS_MASK; 
   HalpPerfMonCnfg0ClearStatusMask = (genericPairs >   4) ? ((((ULONGLONG)-1) << (genericPairs + 4)) | 0x0E)
                                                          : HALP_PMC0_CLEAR_STATUS_MASK; 
#else 
   HalpPerfMonCnfg3ClearStatusMask = HALP_PMC3_CLEAR_STATUS_MASK;
   HalpPerfMonCnfg2ClearStatusMask = HALP_PMC2_CLEAR_STATUS_MASK;
   HalpPerfMonCnfg1ClearStatusMask = HALP_PMC1_CLEAR_STATUS_MASK;
   HalpPerfMonCnfg0ClearStatusMask = HALP_PMC0_CLEAR_STATUS_MASK;
   if ( genericPairs > 192 )    {
       HalpPerfMonCnfg3ClearStatusMask = ((ULONGLONG)-1) << (genericPairs - 192);
   }
   else if ( genericPairs > 128 )   {
       HalpPerfMonCnfg2ClearStatusMask = ((ULONGLONG)-1) << (genericPairs - 128);
   }
   else if ( genericPairs > 64 )    {
       HalpPerfMonCnfg1ClearStatusMask = ((ULONGLONG)-1) << (genericPairs - 64);
   }
   else {
       HalpPerfMonCnfg0ClearStatusMask = ((((ULONGLONG)-1) << (genericPairs + 4)) | 0x0E);
   }
#endif 

   //
   // HALIA64 SW default profile microarchitecture is McKinley.
   //

   if (cpuFamily == 0x7) {  // Merced
       HalpProfileIA64MicroArchitecture   = HALP_PROFILE_IA64_MERCED;
       HalpProfileIA64Maximum             = ProfileMercedMaximum;
       HalpProfileMapping                 = HalpMercedProfileMapping;
       HalpProfileIA64DerivedEventMinimum = ProfileMercedDerivedEventMinimum;

       HalpPerfMonCnfg0FreezeBitInterrupt = FALSE;
   }

//
// XXTF FIXFIX - 03/02
// ASSERTMSG assertions are missing to correlate HALIA64 defaults and OSLOADER PERFMON_INFO data.
//

   return;

} // HalpSetProfileMicroArchitecture()

VOID
HalpEnableProfileCounting (
   VOID
   )
/*++

Routine Description:

   This function enables the profile counters to increment.
   This function is the counterpart of HalpDisableProfileCounting().

Arguments:

   None.

Return Value:

   None.

--*/
{
    ULONGLONG Data, ClearStatusMask;

    //
    // Clear PMC0.fr - bit 0.
    // Clear PMCO,1,2,3 OverFlow Bits.
    //

    HalpClearPerfMonCnfgOverflows( HalpPerfMonCnfg0ClearStatusMask,
                                   HalpPerfMonCnfg1ClearStatusMask,
                                   HalpPerfMonCnfg2ClearStatusMask,
                                   HalpPerfMonCnfg3ClearStatusMask );

    if ( HalpPerfMonCnfg0FreezeBitInterrupt )   {
        HalpUnFreezeProfileCounting();
    }

    return;

} // HalpEnableProfileCounting()

VOID
HalpDisableProfileCounting (
   VOID
   )
/*++

Routine Description:

   This function disables the profile counters to increment.
   This function is the counterpart of HalpEnableProfileCounting().

Arguments:

   None.

Return Value:

   None.

--*/
{

   if ( HalpPerfMonCnfg0FreezeBitInterrupt )   {
       HalpFreezeProfileCounting();
   }
   else   {
       HalpWritePerfMonCnfgReg0( HalpReadPerfMonCnfgReg0() | 0x1 );
   }

   return;

} // HalpDisableProfileCounting()

VOID
HalpSetupProfilingPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
  )
/*++

Routine Description:

   This function is called at HalInitSystem - phase 0 time to set
   the initial state of processor and profiling os subsystem with 
   regards to the profiling functionality.

Arguments:

   None.

Return Value:

   None.

Implementation Note:

   Executed at Phase 0 on Monarch processor.

--*/
{

   // Set the Profile MicroArchitecture namespace based on 
   // the monarch processor.

   HalpSetProfileMicroArchitecture( LoaderBlock );

   return;

} // HalpSetupProfilingPhase0()

VOID
HalpSetProfileCounterInterval (
     IN ULONG    Counter,
     IN LONGLONG NextCount
     )
/*++

Routine Description:

    This function preloads the specified counter with a count value
    of 2^IMPL_BITS - NextCount. 

Arguments:

    Counter   - Supplies the performance counter register number.

    NextCount - Supplies the value to preload in the monitor. 
                An external interruption will be generated after NextCount.

Return Value:

    None.
    
--*/
{
   
    LONGLONG Count;

// if ( (Counter < 4) || (Counter > 7) ) return;

    Count = (HalpPerfMonDataMaximumCount + 1) - NextCount;
    if ( (ULONGLONG)Count >= HalpPerfMonDataMaximumCount )   {
        Count = 0;
    }
    HalpWritePerfMonDataReg( Counter, (ULONGLONG)Count ); 

    return;

} // HalpSetProfileCounterInterval()

VOID
HalpSetProfileCounterPrivilegeLevelMask(
     IN ULONG    Counter,
     IN ULONG    Mask
     )
/*++

Routine Description:

    This function set the profile counter privilege level mask.

Arguments:

    Counter   - Supplies the performance counter register number.

    Mask      - Supplies the privilege level mask to program the PMC with.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, plmMask;

// if ( (Counter < 4) || (Counter > 7) ) return;

   plmMask = Mask & 0xF;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~0xF;
   data |= plmMask;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterPrivilegeLevelMask()

VOID
HalpEnableProfileCounterOverflowInterrupt (
     IN ULONG    Counter
     )
/*++

Routine Description:

    This function enables the delivery of an overflow interrupt for 
    the specified profile counter.

Arguments:

    Counter   - Supplies the performance counter register number.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, mask;

// if ( (Counter < 4) || (Counter > 7) ) return;

   mask = 1<<5;
   data = HalpReadPerfMonCnfgReg( Counter );
   data |= mask;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpEnableProfileCounterOverflowInterrupt()

VOID
HalpDisableProfileCounterOverflowInterrupt (
     IN ULONG    Counter
     )
/*++

Routine Description:

    This function disables the delivery of an overflow interrupt for 
    the specified profile counter.

Arguments:

    Counter   - Supplies the performance counter register number.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, mask;

// if ( (Counter < 4) || (Counter > 7) ) return;

   mask = 1<<5;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~mask;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpDisableProfileCounterOverflowInterrupt()

VOID
HalpEnableProfileCounterPrivilegeMonitor(
     IN ULONG    Counter
     )
/*++

Routine Description:

    This function enables the profile counter as privileged monitor.

Arguments:

    Counter   - Supplies the performance counter register number.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, pm;

// if ( (Counter < 4) || (Counter > 7) ) return;

   pm = 1<<6;
   data = HalpReadPerfMonCnfgReg( Counter );
   data |= pm;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpEnableProfileCounterPrivilegeMonitor()

VOID
HalpDisableProfileCounterPrivilegeMonitor(
     IN ULONG    Counter
     )
/*++

Routine Description:

    This function disables the profile counter as privileged monitor.

Arguments:

    Counter   - Supplies the performance counter register number.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, pm;

// if ( (Counter < 4) || (Counter > 7) ) return;

   pm = 1<<6;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~pm;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpDisableProfileCounterPrivilegeMonitor()

VOID
HalpSetProfileCounterEvent(
     IN ULONG    Counter,
     IN ULONG    Event
     )
/*++

Routine Description:

    The function specifies the monitor event for the profile counter.

Arguments:

    Counter   - Supplies the performance counter register number.

    Event     - Supplies the monitor event code.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, es;

// if ( (Counter < 4) || (Counter > 7) ) return;

   es = (Event & 0x7F) << 8;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~(0x7F << 8);
   data |= es;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterEvent()

VOID
HalpSetProfileCounterUmask(
     IN ULONG    Counter,
     IN ULONG    Umask
     )
/*++

Routine Description:

    This function sets the event specific umask value for the profile 
    counter.

Arguments:

    Counter   - Supplies the performance counter register number.

    Umask     - Supplies the event specific umask value.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, um;

// if ( (Counter < 4) || (Counter > 7) ) return;

   um = (Umask & 0xF) << 16;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~(0xF << 16);
   data |= um;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterUmask()

VOID
HalpSetProfileCounterThreshold(
     IN ULONG    Counter,
     IN ULONG    Threshold
     )
/*++

Routine Description:

    This function sets the profile counter threshold.

Arguments:

    Counter   - Supplies the performance counter register number.

    Threshold - Supplies the desired threshold. 
                This is related to multi-occurences events.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, reset, th;

   switch( Counter )    {
    case 4:
    case 5:
        Threshold &= 0x7;
        reset = ~(0x7 << 20);
        break;

    case 6:
    case 7:
        Threshold &= 0x3;
        reset = ~(0x3 << 20);
        break;

    default:
        return;
   }
   
   th = Threshold << 20;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= reset;
   data |= th;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterThreshold()

VOID
HalpSetProfileCounterInstructionSetMask(
     IN ULONG    Counter,
     IN ULONG    Mask
     )
/*++

Routine Description:

    This function sets the instruction set mask for the profile counter.

Arguments:

    Counter   - Supplies the performance counter register number.

    Mask      - Supplies the instruction set mask.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, ismMask;

// if ( (Counter < 4) || (Counter > 7) ) return;

   ismMask = (Mask & 0x3) << 24;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~(0x3 << 24);
   data |= ismMask;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterInstructionSetMask()

ULONGLONG
HalpSetProfileCounterConfiguration(
     IN ULONG    Counter,
     IN ULONG    PrivilegeMask,
     IN ULONG    EnableOverflowInterrupt,
     IN ULONG    EnablePrivilegeMonitor,
     IN ULONG    Event,
     IN ULONG    Umask,
     IN ULONG    Threshold,
     IN ULONG    InstructionSetMask
     )
/*++  

Function Description: 

    This function sets the profile counter with the specified parameters.

Arguments:

    IN ULONG Counter - 

    IN ULONG PrivilegeMask - 

    IN ULONG EnableOverflowInterrupt - 

    IN ULONG EnablePrivilegeMonitor - 

    IN ULONG Event - 

    IN ULONG Umask - 

    IN ULONG Threshold - 

    IN ULONG InstructionSetMask - 

Return Value:

    VOID 

Algorithm:

    ToBeSpecified

In/Out Conditions:

    ToBeSpecified

Globals Referenced:

    ToBeSpecified

Exception Conditions:

    ToBeSpecified

MP Conditions:

    ToBeSpecified

Notes:

    This function is a kind of combo of the different profile counter APIs.
    It was created to provide speed.

ToDo List:

    - Setting the threshold is not yet supported.

Modification History:

    3/16/2000  TF  Initial version

--*/
{
   ULONGLONG data, plmMask, ismMask, es, um, th;

// if ( (Counter < 4) || (Counter > 7) ) return;

   plmMask = (PrivilegeMask & 0xF);
   es      = (Event & 0x7F) << 8;
   um = (Umask & 0xF) << 16;
// XXTF - ToBeDone - Threshold not supported yet.
   ismMask = (InstructionSetMask & 0x3) << 24;

   data = HalpReadPerfMonCnfgReg( Counter );

HalDebugPrint(( HAL_PROFILE, "HalpSetProfileCounterConfiguration: Counter = %ld Read    = 0x%I64x\n", Counter, data ));

   data &= ~( (0x3 << 24) | (0xF << 16) | (0x7F << 8) | 0xF );
   data |= ( plmMask | es | um | ismMask );
   data = EnableOverflowInterrupt ? (data | (1<<5)) : (data & ~(1<<5));
   data = EnablePrivilegeMonitor  ? (data | (1<<6)) : (data & ~(1<<6));
   
   HalpWritePerfMonCnfgReg( Counter, data );

HalDebugPrint(( HAL_PROFILE, "HalpSetProfileCounterConfiguration: Counter = %ld Written = 0x%I64x\n", Counter, data ));

   return data;
   
} // HalpSetProfileCounterConfiguration()

BOOLEAN
HalpIsProfileSourceEventEnabled(
    IN ULONG Event
    )
{
#define HalpProfileCnfgEvent( _Cnfg ) ((ULONG)((_Cnfg)>>8) & 0x7F)

    if ( HalpProfileCnfg4 && (HalpProfileCnfgEvent(HalpProfileCnfg4) == Event))   {
         return TRUE;
    }
    if ( HalpProfileCnfg5 && (HalpProfileCnfgEvent(HalpProfileCnfg5) == Event))   {
         return TRUE;
    }
    if ( HalpProfileCnfg6 && (HalpProfileCnfgEvent(HalpProfileCnfg6) == Event))   {
         return TRUE;
    }
    if ( HalpProfileCnfg7 && (HalpProfileCnfgEvent(HalpProfileCnfg7) == Event))   {
         return TRUE;
    }
    return FALSE;

} // HalpIsProfileSourceEventEnabled()

PHALP_PROFILE_MAPPING
HalpGetProfileMapping(
    IN KPROFILE_SOURCE Source
    )
/*++

Routine Description:

    Given a profile source, returns whether or not that source is
    supported.

Arguments:

    Source - Supplies the profile source

Return Value:

    ProfileMapping entry - Profile source is supported

    NULL - Profile source is not supported

--*/
{
    if ( (ULONG) Source > HalpProfileIA64Maximum )
    {
        return NULL;
    }

    return(&HalpProfileMapping[Source]);

} // HalpGetProfileMapping()

ULONG // == ProfileCounter
HalpApplyProfileSourceEventMaskPolicy(
    ULONG ProfileSourceEventMask
    )
{
    ULONG pmcd, set;
    ULONG eventMask = ProfileSourceEventMask;

    set = eventMask >> PMCD_MASK_SET_PMCD_SHIFT;
    if ( set ) {
        KPROFILE_SOURCE profileSource;
        PHALP_PROFILE_MAPPING profileMapping;

        pmcd = (eventMask >> PMCD_MASK_SET_PMCD_SHIFT) & PMCD_MASK_SET_PMCD;
        profileSource = HalpGetProfileSource( pmcd );
        if ( !HalpIsProfileSourceActive( profileSource ) )  {
            return pmcd;
        }
        profileMapping = HalpGetProfileMapping( profileSource );
        if ( ! HalpIsProfileMappingInvalid( profileMapping ) )   {
            ULONG sameSet = profileMapping->EventMask >> PMCD_MASK_SET_SHIFT;

ASSERTMSG( "HAL!HalpApplyProfileSourceEventMaskPolicy: non-derived events are supported!\n", !HalpIsProfileSourceDerivedEvent( profileSource, profileMapping ) );

            if ( sameSet == set )    {

                // We are doing one extra but considering the number of counter pairs, this is not a 
                // great performance impact.

                if ( (eventMask & PMCD_MASK_4) && !HalpIsProfileSourceActive( HalpProfileSource4 ) )   {
                    return 4;
                }
                if ( (eventMask & PMCD_MASK_6) && !HalpIsProfileSourceActive( HalpProfileSource6 ) )   {
                    return 6;
                }
                if ( (eventMask & PMCD_MASK_7) && !HalpIsProfileSourceActive( HalpProfileSource7 ) )   {
                    return 7;
                }
                if ( (eventMask & PMCD_MASK_5) && !HalpIsProfileSourceActive( HalpProfileSource5 ) )   {
                    return 5;
                }
            }
        }
    }
    else  {
        if ( (eventMask & PMCD_MASK_4) && !HalpIsProfileSourceActive( HalpProfileSource4 ) )   {
            return 4;
        }
        if ( (eventMask & PMCD_MASK_5) && !HalpIsProfileSourceActive( HalpProfileSource5 ) )   {
            return 5;
        }
        if ( (eventMask & PMCD_MASK_6) && !HalpIsProfileSourceActive( HalpProfileSource6 ) )   {
            return 6;
        }
        if ( (eventMask & PMCD_MASK_7) && !HalpIsProfileSourceActive( HalpProfileSource7 ) )   {
            return 7;
        }
    }
    return 0; // invalid PMC-PMD pair number.

} // HalpApplyProfileSourceEventMaskPolicy()

NTSTATUS
HalpApplyProfileSourceEventPolicies(
    IN  PHALP_PROFILE_MAPPING ProfileMapping,
    IN  KPROFILE_SOURCE       ProfileSource,
    OUT PULONG                ProfileCounter,
    OUT HALP_PROFILE_MAPPING  ProfileDerivedMapping[]
    )
/*++

Routine Description:

    This function executes the different policies defined for the Event of the specified 
    Profile Source.

Arguments:

    ProfileMapping - Supplies the Profile Mapping entry.

    ProfileSource  - Supplies the Profile Source corresponding to the Profile Mapping entry.

    EventMask      - Supplies a pointer to an Event Mask variable.

    ProfileDerivedMapping - Supplies a HALP_PROFILE_MAPPING array of derived counters for the 
                            passed event if it is derived.

Return Value:
    
    STATUS_SUCCESS -

    STATUS_INVALID_PARAMETER -

    STATUS_UNSUCESSFUL -

Implementation Note:

    The profile counting is disabled when this function is entered.

--*/
{
    ULONG   pmcd; 
    BOOLEAN eventDerived;

    if ( ! ProfileMapping ) {
        return STATUS_INVALID_PARAMETER;
    }

ASSERTMSG( "HAL!HalpApplyProfileSourceEventPolicies: ProfileCounter is NULL!\n", ProfileCounter ) ; 
ASSERTMSG( "HAL!HalpApplyProfileSourceEventPolicies: ProfileDerivedMapping is NULL!\n", ProfileDerivedMapping ) ; 

    *ProfileCounter = 0;
    ProfileDerivedMapping[0].Supported = FALSE;
    eventDerived = FALSE;

    //
    // Is this ProfileSource a derived event?
    //
    // If this is the case:
    //      - We must get the policy applied to this source and apply it.
    //        As an example, it could be coupled to the CPU_CYCLE event.
    //        In that case, we would compute CPU_CYCLES interval for the 
    //        specified derived event interval, program the counter(s) and
    //        the CPU_CYCLES event.
    //

    eventDerived = HalpIsProfileSourceDerivedEvent( ProfileSource, ProfileMapping );
    if ( eventDerived )     {
        NTSTATUS status;
#if defined(HALP_PROFILE_DERIVED_EVENTS)
// DerivedEvent not implemented yet - FIXFIX 04/2002
        status = ProfileMapping->DerivedEventInitialize( ProfileMapping, 
                                                         ProfileSource, 
                                                         &cpuCycles
                                                       );
#else 
        status = STATUS_NOT_SUPPORTED;
#endif 
        if ( !NT_SUCCESS( status ) )  {
            return status;
        }
    }

    //
    // A specific event can be enabled only once at a time per PMU.
    // This also has to be imposed because of the ProfileSource aliases that 
    // could use identical events.
    //

    if ( HalpIsProfileSourceEventEnabled( ProfileMapping->Event ) )   {
        return STATUS_ALREADY_COMMITTED;
    }

    //
    // Apply EventMask policy for the Source and return the considered counter.
    //

    pmcd = HalpApplyProfileSourceEventMaskPolicy( ProfileMapping->EventMask );
    if ( !pmcd )   {
        return STATUS_UNSUCCESSFUL;
    }
    *ProfileCounter = pmcd;
    return STATUS_SUCCESS;

} // HalpApplyProfileSourceEventPolicies()

NTSTATUS
HalpProgramProfileMapping(
    PHALP_PROFILE_MAPPING ProfileMapping,
    KPROFILE_SOURCE       ProfileSource
    )
/*++

Routine Description:

    This function enables the profiling configuration for the event defined by the 
    specified Profile Mapping entry.

    This function is the counterpart of HalpDeProgramProfileMapping().

Arguments:

    ProfileMapping - Supplies the Profile Mapping entry.

    ProfileSource  - Supplies the Profile Source corresponding to the Profile Mapping entry.

Return Value:
    
    STATUS_SUCCESS -

    STATUS_INVALID_PARAMETER -

    STATUS_UNSUCESSFUL -

Implementation Note:

    The profile counting is disabled when this function is entered.

--*/
{
    HALP_PROFILE_MAPPING profileDerivedMapping[PROCESSOR_IA64_PERFCOUNTERS_PAIRS];
    ULONG     profileCounter = 0;
    ULONGLONG profileCounterConfig = 0;
    NTSTATUS  status;

    //
    // Apply the Profile Source policies defining the configuration of the 
    // the corresponding Event and determine if this event is a Derived Event for this
    // micro-architecture.
    //

    status = HalpApplyProfileSourceEventPolicies( ProfileMapping, ProfileSource, &profileCounter, profileDerivedMapping );
    if ( !NT_SUCCESS( status ) )   {
        return status;
    }
ASSERTMSG( "HAL!HalpProgramProfileMapping: profileCounter is 0!\n", profileCounter ) ; 

    //
    // Follow ProfileMapping attributes to configure PMU counter.
    //

    HalpSetProfileCounterInterval( profileCounter, ProfileMapping->Interval );   
    profileCounterConfig = HalpSetProfileCounterConfiguration( profileCounter, 
                                                               ProfileMapping->PrivilegeLevel, 
                                                               ProfileMapping->OverflowInterrupt, 
                                                               ProfileMapping->PrivilegeEnable,
                                                               ProfileMapping->Event,
                                                               ProfileMapping->UnitMask,
                                                               ProfileMapping->Threshold,
                                                               ProfileMapping->InstructionSetMask
                                                             );
    HalpSetProfileSource( profileCounter, ProfileSource, profileCounterConfig );

    return STATUS_SUCCESS;

} // HalpProgramProfileMapping()

VOID
HalpDeProgramProfileMapping(
    PHALP_PROFILE_MAPPING ProfileMapping,
    KPROFILE_SOURCE       ProfileSource
    )
/*++

Routine Description:

    This function disables the profiling configuration for the event defined by the 
    specified Profile Mapping entry.

    This function is the counterpart of HalpProgramProfileMapping().

Arguments:

    ProfileMapping - Supplies the Profile Mapping entry.

    ProfileSource  - Supplies the Profile Source corresponding to the Profile Mapping entry.

Return Value:
    
    STATUS_SUCCESS -

    STATUS_INVALID_PARAMETER -

    STATUS_UNSUCESSFUL -

--*/
{
    NTSTATUS status;
    ULONG    eventMask;
    ULONG    eventFailedSpeculativeCheckLoads;
    ULONG    eventALATOverflows;

    if ( ! ProfileMapping ) {
        return;
    }

    //
    // Is this ProfileSource a derived event?
    //
// XXTF - ToBeDone - Derived Event

    //
    // Validate the Profile Source as active.
    //

    if ( HalpProfileSource4 == ProfileSource )   {

        HalpProfileCnfg4 = HalpSetProfileCounterConfiguration( 4,
                                                               PMC_PLM_NONE,
                                                               PMC_DISABLE_OVERFLOW_INTERRUPT,
                                                               PMC_DISABLE_PRIVILEGE_MONITOR,
                                                               0, // Event
                                                               0, // Umask
                                                               0, // Threshold
                                                               PMC_ISM_NONE
                                                             );

        HalpSetProfileCounterInterval( 4, 0 );
        HalpDisactivateProfileSource( HalpProfileSource4 ); 
        HalpProfilingRunning--;
        
    }
    else if ( HalpProfileSource5 == ProfileSource )   {

        HalpProfileCnfg5 = HalpSetProfileCounterConfiguration( 5,
                                                               PMC_PLM_NONE,
                                                               PMC_DISABLE_OVERFLOW_INTERRUPT,
                                                               PMC_DISABLE_PRIVILEGE_MONITOR,
                                                               0, // Event
                                                               0, // Umask
                                                               0, // Threshold
                                                               PMC_ISM_NONE
                                                             );

        HalpSetProfileCounterInterval( 5, 0 );
        HalpDisactivateProfileSource( HalpProfileSource5 ); 
        HalpProfilingRunning--;
        
    }
    else if ( HalpProfileSource6 == ProfileSource )   {

        HalpProfileCnfg6 = HalpSetProfileCounterConfiguration( 6,
                                                               PMC_PLM_NONE,
                                                               PMC_DISABLE_OVERFLOW_INTERRUPT,
                                                               PMC_DISABLE_PRIVILEGE_MONITOR,
                                                               0, // Event
                                                               0, // Umask
                                                               0, // Threshold
                                                               PMC_ISM_NONE
                                                             );

        HalpSetProfileCounterInterval( 6, 0 );
        HalpDisactivateProfileSource( HalpProfileSource6); 
        HalpProfilingRunning--;
        
    }
    else if ( HalpProfileSource7 == ProfileSource )   {

        HalpProfileCnfg7 = HalpSetProfileCounterConfiguration( 7,
                                                               PMC_PLM_NONE,
                                                               PMC_DISABLE_OVERFLOW_INTERRUPT,
                                                               PMC_DISABLE_PRIVILEGE_MONITOR,
                                                               0, // Event
                                                               0, // Umask
                                                               0, // Threshold
                                                               PMC_ISM_NONE
                                                             );

        HalpSetProfileCounterInterval( 7, 0 );
        HalpDisactivateProfileSource( HalpProfileSource7 ); 
        HalpProfilingRunning--;
    }

    return;

} // HalpDeProgramProfileMapping()

ULONG_PTR
HalpSetProfileInterruptHandler(
    IN ULONG_PTR ProfileInterruptHandler
    )
/*++

Routine Description:

    This function registers a per-processor Profiling Interrupt Handler.
    
Arguments:

    ProfileInterruptHandler - Interrupt Handler.

Return Value:

    (ULONG_PTR)STATUS_SUCCESS           - Successful registration.

    (ULONG_PTR)STATUS_ALREADY_COMMITTED - Cannot register an handler if profiling events are running.

    (ULONG_PTR)STATUS_PORT_ALREADY_SET  - An Profiling Interrupt Handler was already registred - not imposed currently.

Note:

    IT IS THE RESPONSIBILITY OF THE CALLER OF THIS ROUTINE TO ENSURE
    THAT NO PAGE FAULTS WILL OCCUR DURING EXECUTION OF THE PROVIDED
    FUNCTION OR ACCESS TO THE PROVIDED CONTEXT.
    A MINIMUM OF FUNCTION POINTER CHECKING WAS DONE IN HalSetSystemInformation PROCESSING.

--*/
{

    //
    // If profiling is already running, we do not allow the handler registration.
    //
    // This imposes that:
    //
    //  - if the default HAL profiling is running or a profiling with a registered interrupt
    //    handler is running, we cannot register an interrupt handler.
    //    In the last case, all the profiling events have to be stopped before a possible
    //    registration.
    //  
    // It should be also noticed that there is no ownership of profiling monitors implemented.
    // Meaning that if profiling is started, the registred handler will get the interrupts
    // generated by ALL the running monitor events if they are programmed to generate interrupts.
    // 

    if ( HalpProfilingRunning ) {

HalDebugPrint(( HAL_PROFILE, "HalpSetProfileInterruptHandler: Profiling already running\n" ));
        return((ULONG_PTR)(ULONG)(STATUS_ALREADY_COMMITTED));

    }

#if 0
//
// Thierry - 03/2000. ToBeVerified.
//
// In case, no profiling was started, there is currently no restriction in registering 
// another handler if one was already registered. 
//

    if ( HalpProfillingInterruptHandler )   {
        return((ULONG_PTR)(ULONG)(STATUS_PORT_ALREADY_SET));
    }

#endif // 0

    HalpProfilingInterruptHandler = (ULONGLONG)ProfileInterruptHandler;
    return((ULONG_PTR)(ULONG)(STATUS_SUCCESS));

} // HalpSetProfileInterruptHandler()

VOID 
HalpProfileInterrupt(
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )
/*++

Routine Description:

    Default PROFILE_VECTOR Interrupt Handler.
    This function is executed as the result of an interrupt from the
    internal microprocessor performance counters.  The interrupt
    may be used to signal the completion of a profile event.
    If profiling is current active, the function determines if the
    profile interval has expired and if so dispatches to the standard
    system routine to update the system profile time.  If profiling
    is not active then returns.

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/
{

    // 
    // Call registered per-processor Profiling Interrupt handler if it exists.
    // We will return immediately before doing any default profiling interrupt handling.
    // 

    if ( HalpProfilingInterruptHandler && 
         (*((PHAL_PROFILE_INTERRUPT_HANDLER)HalpProfilingInterruptHandler) != NULL) )   {
        (*((PHAL_PROFILE_INTERRUPT_HANDLER)HalpProfilingInterruptHandler))( TrapFrame ); 
        return;
    }

    //
    // Handle interrupt if profiling is enabled.
    // 

    if ( HalpProfilingRunning )   {

        //
        // Process every PMC/PMD pair overflow.
        //

// XXTF - FIXFIX - Merced specific.
        UCHAR pmc0, overflow;
        ULONG source;

        HalpProfilingInterrupts++;

        pmc0 = (UCHAR)HalpReadPerfMonCnfgReg0();
ASSERTMSG( "HAL!HalpProfileInterrupt PMC0 freeze bit is not set!\n", pmc0 & 0x1 );
        overflow = pmc0 & 0xF0;
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", overflow );
        if ( overflow & (1<<4) )  {
            source =  HalpProfileSource4;  // XXTF - IfFaster - Coud used pmc.es
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", source < HalpProfileIA64Maximum );
            KeProfileInterruptWithSource( TrapFrame, source );
            HalpSetProfileCounterInterval( 4, HalpProfileMapping[source].Interval );
//          XXTF - IfFaster - HalpWritePerfMonDataReg( 4, HalpProfileMapping[source].Interval );
//          XXTF - CodeWithReload - HalpWritePerfMonCnfgReg( 4, *PCRProfileCnfg4Reload );
        }
        if ( overflow & (1<<5) )  {
            source =  HalpProfileSource5;  // XXTF - IfFaster - Coud used pmc.es
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", source < HalpProfileIA64Maximum );
            KeProfileInterruptWithSource( TrapFrame, source );
            HalpSetProfileCounterInterval( 5, HalpProfileMapping[source].Interval );
//          XXTF - IfFaster - HalpWritePerfMonDataReg( 5, HalpProfileMapping[source].Interval );
//          XXTF - CodeWithReload - HalpWritePerfMonCnfgReg( 5, *PCRProfileCnfg5Reload );
        }
        if ( overflow & (1<<6) )  {
            source =  HalpProfileSource6;  // XXTF - IfFaster - Coud used pmc.es
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", source < HalpProfileIA64Maximum );
            KeProfileInterruptWithSource( TrapFrame, source );
            HalpSetProfileCounterInterval( 6, HalpProfileMapping[source].Interval );
//          XXTF - IfFaster - HalpWritePerfMonDataReg( 6, HalpProfileMapping[source].Interval );
//          XXTF - CodeWithReload - HalpWritePerfMonCnfgReg( 6, *PCRProfileCnfg6Reload );
        }
        if ( overflow & (1<<7) )  {
            source =  HalpProfileSource7;  // XXTF - IfFaster - Coud used pmc.es
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", source < HalpProfileIA64Maximum );
            KeProfileInterruptWithSource( TrapFrame, source );
            HalpSetProfileCounterInterval( 7, HalpProfileMapping[source].Interval );
//          XXTF - IfFaster - HalpWritePerfMonDataReg( 6, HalpProfileMapping[source].Interval );
//          XXTF - CodeWithReload - HalpWritePerfMonCnfgReg( 7, *PCRProfileCnfg7Reload );
        }

        //
        // Clear pmc0.fr and overflow bits.
        // 

        HalpEnableProfileCounting();

    }
    else   {

        HalpProfilingInterruptsWithoutProfiling++;

    }

    return;

} // HalpProfileInterrupt()

NTSTATUS
HalSetProfileSourceInterval(
    IN KPROFILE_SOURCE  ProfileSource,
    IN OUT ULONG_PTR   *Interval
    )
/*++

Routine Description:

    Sets the profile interval for a specified profile source

Arguments:

    ProfileSource - Supplies the profile source

    Interval - Supplies the specified profile interval
               Returns the actual profile interval

             - if ProfileSource is ProfileTime, Interval is in 100ns units.

Return Value:

    NTSTATUS

--*/
{
    ULONGLONG countEvents;
    PHALP_PROFILE_MAPPING profileMapping;

    profileMapping = HalpGetProfileMapping(ProfileSource);
    if ( profileMapping == NULL )   {
        return( STATUS_NOT_IMPLEMENTED );
    }
    if ( profileMapping->Supported == FALSE )   {
        return( STATUS_NOT_SUPPORTED );
    }

    //
    // Fill in the profile source value.
    //

    profileMapping->ProfileSource = ProfileSource;

HalDebugPrint(( HAL_PROFILE, "HalSetProfileSourceInterval: ProfileSource = %ld IN  Desired Interval = 0x%Ix\n", ProfileSource, *Interval ));

    countEvents = (ULONGLONG)*Interval;
    if ( (ProfileSource == ProfileTime) && countEvents ) {
        //
        // Convert the clock tick period (in 100ns units) into a cycle count period
        //
        countEvents = (ULONGLONG)(countEvents * HalpITCTicksPer100ns); 
    } 

HalDebugPrint(( HAL_PROFILE, "HalSetProfileSourceInterval: countEvent = 0x%I64x\n", countEvents ));

    //
    // Check to see if the desired Interval is reasonable, if not adjust it.
    //
    // A specific case for desired Interval == 0, this resets the ProfileMapping entry Interval
    // field and will make the event increment the PMD up to overflow bit if the Events generating
    // caller is killed or does not stop the interrupts for any reason.
    // Again, this is to avoid hanging the system with PMU interrupts.
    //

    if ( countEvents )   {
        if ( countEvents > profileMapping->IntervalMax )  {
            countEvents = profileMapping->IntervalMax;
        }
        else if ( countEvents < profileMapping->IntervalMin )   {
            countEvents = profileMapping->IntervalMin;
        }
    }
    profileMapping->Interval = countEvents;

HalDebugPrint(( HAL_PROFILE, "HalSetProfileSourceInterval: CurrentInterval = 0x%I64x\n", profileMapping->Interval ));

    if ( (ProfileSource == ProfileTime) && countEvents ) {
        //
        // Convert cycle count back into 100ns clock ticks
        //

        countEvents = (ULONGLONG)(countEvents / HalpITCTicksPer100ns);
    }
    *Interval = (ULONG_PTR)countEvents;

HalDebugPrint(( HAL_PROFILE, "HalSetProfileSourceInterval: ProfileSource = %ld OUT *Interval = 0x%Ix\n", ProfileSource, *Interval ));   

    return STATUS_SUCCESS;

} // HalSetProfileSourceInterval()

ULONG_PTR
HalSetProfileInterval (
    IN ULONG_PTR Interval
    )

/*++

Routine Description:

    This routine sets the ProfileTime source interrupt interval.

Arguments:

    Interval - Supplies the desired profile interval in 100ns units.

Return Value:

    The actual profile interval.

--*/

{
    ULONG_PTR NewInterval;

    NewInterval = Interval;
    HalSetProfileSourceInterval(ProfileTime, &NewInterval);
    return(NewInterval);

} // HalSetProfileInterval()

VOID
HalStartProfileInterrupt (
    KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This routine turns on the profile interrupt.

    N.B. This routine must be called at PROFILE_LEVEL on each processor.


Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOLEAN               disabledProfileCounting;
    NTSTATUS              status;
    PHALP_PROFILE_MAPPING profileMapping;

    //
    // Get the Hal profile mapping entry associated with the specified source.
    //

    profileMapping = HalpGetProfileMapping( ProfileSource );
    if ( HalpIsProfileMappingInvalid( profileMapping ) )  {
HalDebugPrint(( HAL_PROFILE, "HalStartProfileInterrupt: invalid source = %ld\n", ProfileSource ));
        return;
    }

    //
    // Disable the profile counting if enabled.
    //
    
    disabledProfileCounting = FALSE;
    if ( HalpProfilingRunning && !(HalpReadPerfMonCnfgReg0() & 0x1) )   {
        HalpDisableProfileCounting();
        disabledProfileCounting = TRUE;
    }

    //
    // Obtain and initialize an available PMC register that supports this event.
    // We may enable more than one event.
    // If the initialization failed, we return immediately. 
    //
    // XXTF - FIXFIX - is there a way to 
    //     * notify the caller for the failure and the reason of the failure. or
    //     * modify the API. or
    //     * define a new API.
    //

    status = HalpProgramProfileMapping( profileMapping, ProfileSource );   
    if ( !NT_SUCCESS(status) )  {
HalDebugPrint(( HAL_PROFILE, "HalStartProfileInterrupt: HalpProgramProfileMapping failed.\n" ));
        if ( disabledProfileCounting )  {
            HalpEnableProfileCounting();        
        }
        return;
    }

    //
    // Notify the profiling as active. 
    // before enabling the selected pmc overflow interrupt and unfreezing the counters.
    //

    HalpProfilingRunning++;
    HalpEnableProfileCounting();

    return;

} // HalStartProfileInterrupt()

VOID
HalStopProfileInterrupt (
    KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This routine turns off the profile interrupt.

    N.B. This routine must be called at PROFILE_LEVEL on each processor.


Arguments:

    ProfileSource - Supplies the Profile Source to stop.

Return Value:

    None.

--*/
{
    PHALP_PROFILE_MAPPING profileMapping;

    //
    // Get the Hal profile mapping entry associated with the specified profile source.
    //

    profileMapping = HalpGetProfileMapping( ProfileSource );
    if ( HalpIsProfileMappingInvalid( profileMapping ) )  {
HalDebugPrint(( HAL_PROFILE, "HalStopProfileInterrupt: invalid source = %ld\n", ProfileSource ));
        return;
    }

    //
    // Get and disable an available PMC register that supports this event.
    // We might disable more than one event.
    // If the initialization failed, we return immediately.
    //
    // XXTF - FIXFIX - is there a way to
    //     * notify the caller for the failure and the reason of the failure. or
    //     * modify the API. or
    //     * define a new API.
    //

    HalpDeProgramProfileMapping( profileMapping, ProfileSource );

    return;

} // HalStopProfileInterrupt()

VOID
HalpResetProcessorDependentPerfMonCnfgRegs(
    ULONGLONG DefaultValue
    )
/*++

Routine Description:

    This routine initializes the processor dependent performance configuration
    registers.

Arguments:

    DefaultValue - default value used to initialize IA64 generic PMCs.

Return Value:

    None.

--*/
{

    // XXTF - 02/08/2000
    // For now, there is no initialization for processor dependent performance
    // configuration registers.
    return;

} // HalpResetProcessorDependentPerfMonCnfgRegs()

VOID
HalpResetPerfMonCnfgRegs(
    VOID
    )
/*++

Routine Description:

    This routine initializes the IA64 architected performance configuration
    registers and calls the micro-architecture specific initialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG pmc;
    ULONGLONG value;

    value = HALP_PMC4_RESET;
    pmc   = 4;
    HalpWritePerfMonCnfgReg( pmc, value );

    value = HALP_PMC_RESET;
    for ( pmc = 5; pmc < 8; pmc++ ) {
       HalpWritePerfMonCnfgReg( pmc, value );
    }

    HalpResetProcessorDependentPerfMonCnfgRegs( value );

    return;

} // HalpResetPerfMonCnfgRegs()

VOID
HalpEnablePMU(
    VOID
    )
/*++

Routine Description:

    This routine enables the processor Performance Monitoring Unit.

    Called from HalInitializeProfiling at phase 1 on every processor.

Arguments:

    Number - Supplies the processor number.

Return Value:

    None.

Implementation Notes:

    Starting with McKinley, in order to use any of the PMU features, 
    a 1 should be written to the PMC4.23 bit. This controls the clocks
    to all PMDs and all PMCs (with the exception of PMC4) and other 
    non-critical circuitry. This bit powers up as 1 and must be written
    as 1, otherwise the PMU will not function correctly.

--*/
{
    HalpWritePerfMonCnfgReg( 4, HALP_PMC4_RESET );
} // HalpEnablePMU()

VOID
HalpInitializeProfiling (
    ULONG Number
    )
/*++

Routine Description:

    This routine is called during initialization to initialize profiling
    for each processor in the system.

    Called from HalInitSystem at phase 1 on every processor.

Arguments:

    Number - Supplies the processor number.

Return Value:

    None.

--*/
{

    //
    // Enable IA64 Processor PMU
    //

    HalpEnablePMU();

    //
    // Disable processor profile counting.
    //

    HalpDisableProfileCounting();

    //
    // If BSP processor, initialize the ProfileTime Interval entries.
    //
    // Assumes HalpITCTicksPer100ns has been initialized.

    if ( Number == 0 )  {
        ULONGLONG interval;
        ULONGLONG count;
        PHALP_PROFILE_MAPPING profile;

        profile = &HalpProfileMapping[ProfileTime]; 

        interval = DEFAULT_PROFILE_INTERVAL;
        count = (ULONGLONG)(interval * HalpITCTicksPer100ns);
        profile->IntervalDef = count;

        interval = MAXIMUM_PROFILE_INTERVAL;
        count = (ULONGLONG)(interval * HalpITCTicksPer100ns);
        profile->IntervalMax = count;

        interval = MINIMUM_PROFILE_INTERVAL;
        count = (ULONGLONG)(interval * HalpITCTicksPer100ns);
        profile->IntervalMin = count;
    }

    //
    // ToBeDone - checkpoint for default processor.PSR fields for
    //            performance monitoring.
    //

    //
    // Resets the processor performance configuration registers.
    //

    HalpResetPerfMonCnfgRegs();

    //
    // Initialization of the Per processor profiling data.
    //

    HalpProfilingRunning = 0;
    HalpDisactivateProfileSource( HalpProfileSource4 );
    HalpDisactivateProfileSource( HalpProfileSource5 );
    HalpDisactivateProfileSource( HalpProfileSource6 );
    HalpDisactivateProfileSource( HalpProfileSource7 );

    //
    // XXTF 02/08/2000:
    // Different performance vectors are considered:
    //  - Profiling (default) -> PROFILE_VECTOR
    //  - Tracing             -> PERF_VECTOR    [PMUTRACE_VECTOR]
    //
    // Set default Performance vector to Profiling.
    //

    ASSERTMSG( "HAL!HalpInitializeProfiler PROFILE_VECTOR handler != HalpProfileInterrupt\n",
               PCR->InterruptRoutine[PROFILE_VECTOR] == (PKINTERRUPT_ROUTINE)HalpProfileInterrupt );

    HalpWritePerfMonVectorReg( PROFILE_VECTOR );
    
    return;

} // HalpInitializeProfiling()

NTSTATUS
HalpProfileSourceInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    )
/*++

Routine Description:

    Returns the HAL_PROFILE_SOURCE_INFORMATION or 
    HAL_PROFILE_SOURCE_INFORMATION_EX for this processor.

Arguments:

    Buffer - output buffer
    BufferLength - length of buffer on input
    ReturnedLength - The length of data returned

Return Value:

    STATUS_SUCCESS          - successful return.
    STATUS_BUFFER_TOO_SMALL - passed buffer size is invalid
                              The ReturnedLength contains the buffersize mininum
    STATUS_NOT_IMPLEMENTED  - specified source is not implemented
    STATUS_NOT_SUPPORTED    - specified source is not supported

--*/
{
   PHALP_PROFILE_MAPPING    profileMapping;
   NTSTATUS                 status = STATUS_SUCCESS;
   KPROFILE_SOURCE          source;

   if ( (BufferLength != sizeof(HAL_PROFILE_SOURCE_INFORMATION)) && 
        (BufferLength <  sizeof(HAL_PROFILE_SOURCE_INFORMATION_EX)) )
   {
       status = STATUS_INFO_LENGTH_MISMATCH;
       return status;
   }
         
   source = ((PHAL_PROFILE_SOURCE_INFORMATION)Buffer)->Source;
   profileMapping = HalpGetProfileMapping( source );

   //
   // return a different status error if the source is not supported or invalid.
   //

   if ( profileMapping == NULL )    {
       status = STATUS_NOT_IMPLEMENTED;
       return status;
   }
   if ( profileMapping->Supported == FALSE )   {
       status = STATUS_NOT_SUPPORTED;
   }

   //
   // Fill in the profile source value.
   //

   profileMapping->ProfileSource = source;

   //
   // and Fill in the information.
   //

   if ( BufferLength == sizeof(HAL_PROFILE_SOURCE_INFORMATION) )    {

        PHAL_PROFILE_SOURCE_INFORMATION    sourceInfo;

        // 
        // HAL_PROFILE_SOURCE_INFORMATION buffer.
        //

        sourceInfo   = (PHAL_PROFILE_SOURCE_INFORMATION)Buffer;
        sourceInfo->Supported = profileMapping->Supported;
        if ( sourceInfo->Supported )    {

            //
            //  For ProfileTime, we convert cycle count back into 100ns clock ticks.
            //

            if ( profileMapping->ProfileSource == ProfileTime  )   {
                sourceInfo->Interval = (ULONG) (profileMapping->Interval / HalpITCTicksPer100ns);
            }
            else  {
                sourceInfo->Interval = (ULONG) profileMapping->Interval;
            }

        }

        if ( ReturnedLength )   {
            *ReturnedLength = sizeof(HAL_PROFILE_SOURCE_INFORMATION);
        }

   }
   else   {

        PHAL_PROFILE_SOURCE_INFORMATION_EX sourceInfoEx;

        // 
        // HAL_PROFILE_SOURCE_INFORMATION_EX buffer.
        //

        sourceInfoEx = (PHAL_PROFILE_SOURCE_INFORMATION_EX)Buffer;
        sourceInfoEx->Supported = profileMapping->Supported;
        if ( sourceInfoEx->Supported )    {

            //
            //  For ProfileTime, we convert cycle count back into 100ns clock ticks.
            //

            if ( profileMapping->ProfileSource == ProfileTime  )   {
                sourceInfoEx->Interval = 
                            (ULONG_PTR) (profileMapping->Interval / HalpITCTicksPer100ns);
            }
            else  {
                sourceInfoEx->Interval = (ULONG_PTR) profileMapping->Interval;
            }

            sourceInfoEx->DefInterval = (ULONG_PTR) profileMapping->IntervalDef;
            sourceInfoEx->MaxInterval = (ULONG_PTR) profileMapping->IntervalMax;
            sourceInfoEx->MinInterval = (ULONG_PTR) profileMapping->IntervalMin;
        }

        if ( ReturnedLength )   {
            *ReturnedLength = sizeof(HAL_PROFILE_SOURCE_INFORMATION_EX);
        }
   }

   return status;

} // HalpProfileSourceInformation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64pcibus.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    i64pcibus.c

Abstract:

    Get/Set bus data routines for the PCI bus

Author:

    Ken Reneris (kenr) 14-June-1994
    Chris Hyser (chrish@fc.hp.com) 1-Feb-98

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "i64fw.h"

//
// Prototypes
//
ULONG
HalpGetPCIData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignPCISlotResources(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

VOID
HalpInitializePciBus(
    VOID
    );

BOOLEAN
HalpIsValidPCIDevice(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

BOOLEAN
HalpValidPCISlot(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );


//
// PCI Configuration Space Accessor types
//
typedef enum {
    PCI_READ,
    PCI_WRITE
} PCI_ACCESS_TYPE;

VOID
HalpPCIConfig(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    IN PCI_ACCESS_TYPE Acctype
    );


#if DBG
#if !defined(NO_LEGACY_DRIVERS)
VOID
HalpTestPci(
    ULONG
    );
#endif
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitializePciBus)
#pragma alloc_text(INIT,HalpAllocateAndInitPciBusHandler)
#pragma alloc_text(INIT,HalpIsValidPCIDevice)
#pragma alloc_text(PAGE,HalpAssignPCISlotResources)
#endif


ULONG
HalpGetPCIData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the PCI bus data for a specified PCI "slot". This
    function is called on behalf of

Arguments:

    BusHandler - An encapsulation of data and manipulation functions specific to
                 this bus.

    RootHandler - ???

    Slot - A PCI "slot" description (ie bus number, device number and function
           number.)

    Buffer - A pointer to the space to store the data.

    Offset - The byte offset into the configuration space for this PCI "slot".

    Length - Supplies a count in bytes of the maximum amount to return. (ie
             equal or less than the size of the Buffer.)

Return Value:

    Returns the amount of data stored into the buffer.

    If this PCI slot has never been set, then the configuration information
    returned is zeroed.

--*/
{
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;
    ULONG               i, bit;

    if (Length > sizeof(PCI_COMMON_CONFIG))
        Length = sizeof(PCI_COMMON_CONFIG);

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG)iBuffer;

    //
    // If the requested offset does not lie in the PCI onfiguration space common
    // header, we will read the vendor ID from the common header to ensure this
    // is a valid device. Note: The common header is from 0 to
    // PCI_COMMON_HEADER_LENGTH inclusive. We know Offset is > 0 because it is
    // unsigned.
    //
    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // No data was requested from the common header. Verify the PCI device
        // exists, then continue in the device specific area.
        //
        HalpReadPCIConfig(BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID)
            return(0);

    } else {

        //
        // Caller requested at least some data within the common header. Read
        // the whole header, effect the fields we need to and then copy the
        // user's requested bytes from the header
        //
        BusData = (PPCIPBUSDATA)BusHandler->BusData;

        //
        // Read this PCI devices slot data
        //
        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig(BusHandler, Slot, PciData, 0, Len);

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            PciData->VendorID = PCI_INVALID_VENDORID;
            Len = 2;       // only return invalid id

        } else {
            BusData->CommonData.Pin2Line(BusHandler, RootHandler, Slot, PciData);
        }

        //
        // Copy whatever data overlaps into the callers buffer
        //
        if (Len < Offset)
            return(0);

        Len -= Offset;
        if (Len > Length)
            Len = Length;

        RtlMoveMemory(Buffer, iBuffer + Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and read from it.
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //
            HalpReadPCIConfig(BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return(Len);
}

ULONG
HalpSetPCIData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function sets the PCI bus data for a specified PCI "slot".

Arguments:

    BusHandler - An encapsulation of data and manipulation functions specific to
                 this bus.

    RootHandler - ???

    Slot - A PCI "slot" description (ie bus number, device number and function
           number.)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer. ???

--*/
{
    PPCI_COMMON_CONFIG  PciData, PciData2;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    UCHAR               iBuffer2[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len, cnt;

    if (Length > sizeof(PCI_COMMON_CONFIG))
        Length = sizeof(PCI_COMMON_CONFIG);

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG)iBuffer;
    PciData2 = (PPCI_COMMON_CONFIG)iBuffer2;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue in
        // the device specific area.
        //
        HalpReadPCIConfig(BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID)
            return(0);

    } else {

        //
        // Caller requested to set at least some data within the
        // common header.
        //
        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig(BusHandler, Slot, PciData, 0, Len);

        //
        // return error if no device or header type unknown
        //
        if (PciData->VendorID == PCI_INVALID_VENDORID ||
            PCI_CONFIG_TYPE(PciData) != PCI_DEVICE_TYPE)
            return(0);


        //
        // Set this device as configured
        //
        BusData = (PPCIPBUSDATA)BusHandler->BusData;
#if DBG1
        cnt = PciBitIndex(Slot.u.bits.DeviceNumber, Slot.u.bits.FunctionNumber);
        RtlSetBits(&BusData->DeviceConfigured, cnt, 1);
#endif
        //
        // Copy COMMON_HDR values to buffer2, then overlay callers changes.
        //
        RtlMoveMemory(iBuffer2, iBuffer, Len);
        BusData->CommonData.Pin2Line(BusHandler, RootHandler, Slot, PciData2);

        Len -= Offset;
        if (Len > Length)
            Len = Length;

        RtlMoveMemory(iBuffer2+Offset, Buffer, Len);

        //
        // in case interrupt line or pin was edited
        //
        BusData->CommonData.Line2Pin(BusHandler, RootHandler, Slot, PciData2, PciData);

#if DBG1
        //
        // Verify R/O fields haven't changed
        //
        if (PciData2->VendorID   != PciData->VendorID       ||
            PciData2->DeviceID   != PciData->DeviceID       ||
            PciData2->RevisionID != PciData->RevisionID     ||
            PciData2->ProgIf     != PciData->ProgIf         ||
            PciData2->SubClass   != PciData->SubClass       ||
            PciData2->BaseClass  != PciData->BaseClass      ||
            PciData2->HeaderType != PciData->HeaderType     ||
            PciData2->BaseClass  != PciData->BaseClass      ||
            PciData2->u.type0.MinimumGrant   != PciData->u.type0.MinimumGrant   ||
            PciData2->u.type0.MaximumLatency != PciData->u.type0.MaximumLatency) {
                HalDebugPrint(( HAL_INFO, "HAL: PCI SetBusData - Read-Only configuration value changed\n" ));
        }
#endif
        //
        // Set new PCI configuration
        //
        HalpWritePCIConfig(BusHandler, Slot, iBuffer2+Offset, Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and write it
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //
            HalpWritePCIConfig(BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return(Len);
}


NTSTATUS
HalpAssignPCISlotResources(
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *pAllocatedResources
    )
/*++

Routine Description:

    Reads the targeted device to determine it's required resources.
    Calls IoAssignResources to allocate them.
    Sets the targeted device with it's assigned resoruces
    and returns the assignments to the caller.

    Note: This function assumes all of a PCI "slots" resources as indicated by
    it's configuration space are REQUIRED.

Arguments:

Return Value:

    STATUS_SUCCESS or error

--*/
{
    NTSTATUS                        status;
    PUCHAR                          WorkingPool;
    PPCI_COMMON_CONFIG              PciData, PciOrigData, PciData2;
    PCI_SLOT_NUMBER                 PciSlot;
    PPCIPBUSDATA                    BusData;
    PIO_RESOURCE_REQUIREMENTS_LIST  CompleteList;
    PIO_RESOURCE_DESCRIPTOR         Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    ULONG                           BusNumber;
    ULONG                           i, j, m, length, memtype;
    ULONG                           NoBaseAddress, RomIndex, Option;
    PULONG                          BaseAddress[PCI_TYPE0_ADDRESSES + 1];
    PULONG                          OrigAddress[PCI_TYPE0_ADDRESSES + 1];
    BOOLEAN                         Match, EnableRomBase, RequestedInterrupt;


    *pAllocatedResources = NULL;
    PciSlot = *((PPCI_SLOT_NUMBER) &Slot);
    BusNumber = BusHandler->BusNumber;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Allocate some pool for working space
    //
    i = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
        sizeof(IO_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2) * 2 +
        PCI_COMMON_HDR_LENGTH * 3;

    WorkingPool = (PUCHAR)ExAllocatePool(PagedPool, i);
    if (!WorkingPool)
        return(STATUS_INSUFFICIENT_RESOURCES);

    //
    // Zero initialize pool, and get pointers into memory
    //

    RtlZeroMemory(WorkingPool, i);
    CompleteList = (PIO_RESOURCE_REQUIREMENTS_LIST)WorkingPool;
    PciData     = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 3);
    PciData2    = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 2);
    PciOrigData = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 1);

    //
    // Read the PCI device's configuration
    //
    HalpReadPCIConfig(BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        ExFreePool(WorkingPool);
        return(STATUS_NO_SUCH_DEVICE);
    }

    //
    // For now since there's not PnP support in the OS, if the BIOS hasn't
    // enable a VGA device don't allow it to get enabled via this interface.
    //
    if ((PciData->BaseClass == 0 && PciData->SubClass == 1) ||
        (PciData->BaseClass == 3 && PciData->SubClass == 0)) {

        if ((PciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) == 0) {
            ExFreePool (WorkingPool);
            return(STATUS_DEVICE_NOT_CONNECTED);
        }
    }

    //
    // Make a copy of the device's current settings
    //
    RtlMoveMemory(PciOrigData, PciData, PCI_COMMON_HDR_LENGTH);

    //
    // Initialize base addresses base on configuration data type
    //
    switch (PCI_CONFIG_TYPE(PciData)) {
        case 0 :
            NoBaseAddress = PCI_TYPE0_ADDRESSES+1;
            for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type0.BaseAddresses[j];
                OrigAddress[j] = &PciOrigData->u.type0.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type0.ROMBaseAddress;
            OrigAddress[j] = &PciOrigData->u.type0.ROMBaseAddress;
            RomIndex = j;
            break;

        case 1:
            NoBaseAddress = PCI_TYPE1_ADDRESSES+1;
            for (j=0; j < PCI_TYPE1_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type1.BaseAddresses[j];
                OrigAddress[j] = &PciOrigData->u.type1.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type1.ROMBaseAddress;
            OrigAddress[j] = &PciOrigData->u.type1.ROMBaseAddress;
            RomIndex = j;
            break;

        default:
            ExFreePool (WorkingPool);
            return(STATUS_NO_SUCH_DEVICE);
    }

    //
    // If the BIOS doesn't have the device's ROM enabled, then we won't enable
    // it either.  Remove it from the list.
    //
    EnableRomBase = TRUE;
    if (!(*BaseAddress[RomIndex] & PCI_ROMADDRESS_ENABLED)) {
        ASSERT (RomIndex+1 == NoBaseAddress);
        EnableRomBase = FALSE;
        NoBaseAddress -= 1;
    }

    //
    // Set resources to all bits on to see what type of resources are required.
    //
    for (j=0; j < NoBaseAddress; j++)
        *BaseAddress[j] = 0xFFFFFFFF;

    PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
    *BaseAddress[RomIndex] &= ~PCI_ROMADDRESS_ENABLED;
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // note type0 & type1 overlay ROMBaseAddress, InterruptPin, and InterruptLine
    //
    BusData->CommonData.Pin2Line (BusHandler, RootHandler, PciSlot, PciData);

    //
    // Build an IO_RESOURCE_REQUIREMENTS_LIST for the PCI device
    //
    CompleteList->InterfaceType = PCIBus;
    CompleteList->BusNumber = BusNumber;
    CompleteList->SlotNumber = Slot;
    CompleteList->AlternativeLists = 1;

    CompleteList->List[0].Version = 1;
    CompleteList->List[0].Revision = 1;

    Descriptor = CompleteList->List[0].Descriptors;

    //
    // If PCI device has an interrupt resource, add it
    //
    RequestedInterrupt = FALSE;
    if (PciData->u.type0.InterruptPin  &&
        PciData->u.type0.InterruptLine != (0 ^ IRQXOR)  &&
        PciData->u.type0.InterruptLine != (0xFF ^ IRQXOR)) {

        RequestedInterrupt = TRUE;
        CompleteList->List[0].Count++;

        Descriptor->Option = 0;
        Descriptor->Type   = CmResourceTypeInterrupt;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags  = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        // Fill in any vector here - we'll pick it back up in
        // HalAdjustResourceList and adjust it to it's allowed settings
        Descriptor->u.Interrupt.MinimumVector = 0;
        Descriptor->u.Interrupt.MaximumVector = 0xff;
        Descriptor++;
    }

    //
    // Add a memory/port resoruce for each PCI resource
    //

    // Clear ROM reserved bits

    *BaseAddress[RomIndex] &= ~0x7FF;

    for (j=0; j < NoBaseAddress; j++) {
        if (*BaseAddress[j]) {
            i = *BaseAddress[j];

            //
            // scan for first set bit, that's the length & alignment
            //
            length = 1 << (i & PCI_ADDRESS_IO_SPACE ? 2 : 4);
            while (!(i & length) && length)
                length <<= 1;

            //
            // scan for last set bit, that's the maxaddress + 1
            //
            for (m = length; i & m; m <<= 1) ;
            m--;

            //
            // check for hosed PCI configuration requirements
            //
            if (length & ~m) {
#if DBG
                HalDebugPrint(( HAL_INFO, "HAL: PCI - defective device! Bus %d, Slot %d, Function %d\n",
                    BusNumber,
                    PciSlot.u.bits.DeviceNumber,
                    PciSlot.u.bits.FunctionNumber
                    ));

                HalDebugPrint(( HAL_INFO, "HAL: PCI - BaseAddress[%d] = %08lx\n", j, i ));
#endif
                //
                // The device is in error - punt.  don't allow this
                // resource any option - it either gets set to whatever
                // bits it was able to return, or it doesn't get set.
                //

                if (i & PCI_ADDRESS_IO_SPACE) {
                    m = i & ~0x3;
                    Descriptor->u.Port.MinimumAddress.LowPart = m;
                } else {
                    m = i & ~0xf;
                    Descriptor->u.Memory.MinimumAddress.LowPart = m;
                }

                m += length;    // max address is min address + length
            }

            //
            // Add requested resource
            //
            Descriptor->Option = 0;
            if (i & PCI_ADDRESS_IO_SPACE) {
                memtype = 0;

                if (!Is64BitBaseAddress(i)  &&
                    PciOrigData->Command & PCI_ENABLE_IO_SPACE) {

                    //
                    // The IO range is/was already enabled at some location, add that
                    // as it's preferred setting.
                    //
                    Descriptor->Type = CmResourceTypePort;
                    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                    Descriptor->Flags = CM_RESOURCE_PORT_IO;
                    Descriptor->Option = IO_RESOURCE_PREFERRED;

                    Descriptor->u.Port.Length = length;
                    Descriptor->u.Port.Alignment = length;
                    Descriptor->u.Port.MinimumAddress.LowPart = *OrigAddress[j] & ~0x3;
                    Descriptor->u.Port.MaximumAddress.LowPart =
                        Descriptor->u.Port.MinimumAddress.LowPart + length - 1;

                    CompleteList->List[0].Count++;
                    Descriptor++;

                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                }

                //
                // Add this IO range
                //
                Descriptor->Type = CmResourceTypePort;
                Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                Descriptor->Flags = CM_RESOURCE_PORT_IO;

                Descriptor->u.Port.Length = length;
                Descriptor->u.Port.Alignment = length;
                Descriptor->u.Port.MaximumAddress.LowPart = m;

            } else {

                memtype = i & PCI_ADDRESS_MEMORY_TYPE_MASK;

                Descriptor->Flags  = CM_RESOURCE_MEMORY_READ_WRITE;
                if (j == RomIndex) {
                    // this is a ROM address
                    Descriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                }

                if (i & PCI_ADDRESS_MEMORY_PREFETCHABLE) {
                    Descriptor->Flags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
                }

                if (!Is64BitBaseAddress(i)  &&
                    (j == RomIndex  ||
                     PciOrigData->Command & PCI_ENABLE_MEMORY_SPACE)) {

                    //
                    // The memory range is/was already enabled at some location, add that
                    // as it's preferred setting.
                    //
                    Descriptor->Type = CmResourceTypeMemory;
                    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                    Descriptor->Option = IO_RESOURCE_PREFERRED;

                    Descriptor->u.Port.Length = length;
                    Descriptor->u.Port.Alignment = length;
                    Descriptor->u.Port.MinimumAddress.LowPart = *OrigAddress[j] & ~0xF;
                    Descriptor->u.Port.MaximumAddress.LowPart =
                        Descriptor->u.Port.MinimumAddress.LowPart + length - 1;

                    CompleteList->List[0].Count++;
                    Descriptor++;

                    Descriptor->Flags = Descriptor[-1].Flags;
                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                }

                //
                // Add this memory range
                //
                Descriptor->Type = CmResourceTypeMemory;
                Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

                Descriptor->u.Memory.Length = length;
                Descriptor->u.Memory.Alignment = length;
                Descriptor->u.Memory.MaximumAddress.LowPart = m;

                if (memtype == PCI_TYPE_20BIT && m > 0xFFFFF) {
                    // limit to 20 bit address
                    Descriptor->u.Memory.MaximumAddress.LowPart = 0xFFFFF;
                }
            }

            CompleteList->List[0].Count++;
            Descriptor++;


            if (Is64BitBaseAddress(i)) {
                //
                // Eventually we may want to do some work here for 64-bit
                // configs...
                //
                // skip upper half of 64 bit address since this processor
                // only supports 32 bits of address space
                //
                j++;
            }
        }
    }

    CompleteList->ListSize = (ULONG)
            ((PUCHAR) Descriptor - (PUCHAR) CompleteList);

    //
    // Restore the device settings as we found them, enable memory
    // and io decode after setting base addresses.  This is done in
    // case HalAdjustResourceList wants to read the current settings
    // in the device.
    //
    HalpWritePCIConfig (
        BusHandler,
        PciSlot,
        &PciOrigData->Status,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Status),
        PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
        );

    HalpWritePCIConfig (
        BusHandler,
        PciSlot,
        PciOrigData,
        0,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
        );

    //
    // Have the IO system allocate resource assignments
    //
    status = IoAssignResources (
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                CompleteList,
                pAllocatedResources
            );

    if (!NT_SUCCESS(status)) {
        goto CleanUp;
    }

    //
    // Slurp the assigments back into the PciData structure and perform them
    //
    CmDescriptor = (*pAllocatedResources)->List[0].PartialResourceList.PartialDescriptors;

    //
    // If PCI device has an interrupt resource then that was passed in as the
    // first requested resource
    //
    if (RequestedInterrupt) {
        PciData->u.type0.InterruptLine = (UCHAR) CmDescriptor->u.Interrupt.Vector;
        BusData->CommonData.Line2Pin (BusHandler, RootHandler, PciSlot, PciData, PciOrigData);
        CmDescriptor++;
    }

    //
    // Pull out resources in the order they were passed to IoAssignResources
    //
    for (j=0; j < NoBaseAddress; j++) {
        i = *BaseAddress[j];
        if (i) {
            if (i & PCI_ADDRESS_IO_SPACE) {
                *BaseAddress[j] = CmDescriptor->u.Port.Start.LowPart;
            } else {
                *BaseAddress[j] = CmDescriptor->u.Memory.Start.LowPart;
            }
            CmDescriptor++;
        }

        if (Is64BitBaseAddress(i)) {
            // skip upper 32 bits
            j++;
        }
    }

    //
    // Turn off decodes, then set new addresses
    //
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Read configuration back and verify address settings took
    //
    HalpReadPCIConfig(BusHandler, PciSlot, PciData2, 0, PCI_COMMON_HDR_LENGTH);

    Match = TRUE;
    if (PciData->u.type0.InterruptLine  != PciData2->u.type0.InterruptLine ||
        PciData->u.type0.InterruptPin   != PciData2->u.type0.InterruptPin  ||
        PciData->u.type0.ROMBaseAddress != PciData2->u.type0.ROMBaseAddress) {
            Match = FALSE;
    }

    for (j=0; j < NoBaseAddress; j++) {
        if (*BaseAddress[j]) {
            if (*BaseAddress[j] & PCI_ADDRESS_IO_SPACE) {
                i = (ULONG) ~0x3;
            } else {
                i = (ULONG) ~0xF;
            }

            if (( (*BaseAddress[j]) & i) !=
                 (*((PULONG) ((PUCHAR) BaseAddress[j] -
                             (PUCHAR) PciData +
                             (PUCHAR) PciData2)) & i)) {

                    Match = FALSE;
            }

            if (Is64BitBaseAddress(*BaseAddress[j])) {
                //
                // Eventually we may want to do something with the upper
                // 32 bits
                //
                j++;
            }
        }
    }

    if (!Match) {
        HalDebugPrint(( HAL_INFO, "HAL: PCI - defective device! Bus %d, Slot %d, Function %d\n",
            BusNumber,
            PciSlot.u.bits.DeviceNumber,
            PciSlot.u.bits.FunctionNumber
            ));
        status = STATUS_DEVICE_PROTOCOL_ERROR;
        goto CleanUp;
    }

    //
    // Settings took - turn on the appropiate decodes
    //
    if (EnableRomBase  &&  *BaseAddress[RomIndex]) {

        //
        // A rom address was allocated and should be enabled
        //
        *BaseAddress[RomIndex] |= PCI_ROMADDRESS_ENABLED;
        HalpWritePCIConfig(
            BusHandler,
            PciSlot,
            BaseAddress[RomIndex],
            (ULONG) ((PUCHAR) BaseAddress[RomIndex] - (PUCHAR) PciData),
            sizeof (ULONG)
            );
    }

    //
    // Enable IO, Memory, and BUS_MASTER decodes
    // (use HalSetBusData since valid settings now set)
    //
    PciData->Command |= PCI_ENABLE_IO_SPACE |
                        PCI_ENABLE_MEMORY_SPACE |
                        PCI_ENABLE_BUS_MASTER;

    HalSetBusDataByOffset(
        PCIConfiguration,
        BusHandler->BusNumber,
        PciSlot.u.AsULONG,
        &PciData->Command,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
        sizeof (PciData->Command)
        );

CleanUp:
    if (!NT_SUCCESS(status)) {

        //
        // Failure, if there are any allocated resources free them
        //
        if (*pAllocatedResources) {
            IoAssignResources(
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                NULL,
                NULL
                );

            ExFreePool(*pAllocatedResources);
            *pAllocatedResources = NULL;
        }

        //
        // Restore the device settings as we found them, enable memory
        // and io decode after setting base addresses
        //
        HalpWritePCIConfig(
            BusHandler,
            PciSlot,
            &PciOrigData->Status,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Status),
            PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
            );

        HalpWritePCIConfig(
            BusHandler,
            PciSlot,
            PciOrigData,
            0,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Status)
            );
    }

    ExFreePool(WorkingPool);
    return(status);
}

BOOLEAN
HalpValidPCISlot(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
/*++

Routine Description:

    The function validates the information specifying a PCI "slot".

Arguments:

    BusHandler - An encapsulation of data and manipulation functions specific to
                 this bus.

    Slot - A PCI "slot" description (ie bus number, device number and function
           number.)

Return Value:

    Returns TRUE if "slot" valid, otherwise FALSE.

--*/

{
    PCI_SLOT_NUMBER                 Slot2;
    PPCIPBUSDATA                    BusData;
    UCHAR                           HeaderType;
    ULONG                           i;

    BusData = (PPCIPBUSDATA)BusHandler->BusData;

    if (Slot.u.bits.Reserved != 0)
        return(FALSE);

    if (Slot.u.bits.DeviceNumber >= BusData->MaxDevice)
        return(FALSE);

    if (Slot.u.bits.FunctionNumber == 0)
        return(TRUE);

    //
    // Read DeviceNumber, Function zero, to determine if the
    // PCI supports multifunction devices
    //
    Slot.u.bits.FunctionNumber = 0;

    HalpPCIConfig(
        BusHandler,
        Slot,
        &HeaderType,
        FIELD_OFFSET(PCI_COMMON_CONFIG, HeaderType),
        sizeof(UCHAR),
        PCI_READ
        );

    //
    // FALSE if this device doesn't exist or doesn't support MULTIFUNCTION types
    //
    if (!(HeaderType & PCI_MULTIFUNCTION) || HeaderType == 0xFF)
        return(FALSE);

    return(TRUE);
}

//
// This table is used to determine correct access size to PCI configuration
// space given (offset % 4) and (length % 4).
//
// usage: PCIDeref[offset%4][length%4];
//
// Key:
//     4 - implies a ULONG access and is the number of bytes returned
//     1 - implies a UCHAR access and is the number of bytes returned
//     2 - implies a USHORT access and is the number of bytes returned
//
UCHAR PCIDeref[4][4] = {{4,1,2,2}, {1,1,1,1}, {2,1,2,2}, {1,1,1,1}};
#define SIZEOF_PARTIAL_INFO_HEADER FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)

VOID
HalpPCIConfig(
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN OUT PUCHAR       Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN PCI_ACCESS_TYPE  AccType
    )
{
    KIRQL Irql;
    ULONG Size;
    ULONG SALFunc;
    ULONG CfgAddr;
    ULONG WriteVal;
    SAL_PAL_RETURN_VALUES RetVals;
    SAL_STATUS Stat;

    //
    // Generate a PCI configuration address
    //
    CfgAddr = (BusHandler->BusNumber      << 16) |
              (Slot.u.bits.DeviceNumber   << 11) |
              (Slot.u.bits.FunctionNumber << 8);

    //
    // SAL or HalpSalCall will do whatever locking required.
    //

    while (Length) {

        Size = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];

        //
        // Set up input parameters
        //
        if (AccType == PCI_READ) {
            SALFunc = SAL_PCI_CONFIG_READ;
            WriteVal = 0;

        } else {

            switch (Size) {
                case 4: WriteVal = *((ULONG UNALIGNED *)Buffer); break;
                case 2: WriteVal = *((USHORT UNALIGNED *)Buffer); break;
                case 1: WriteVal = *Buffer; break;
            }

            SALFunc = SAL_PCI_CONFIG_WRITE;
        }

        //
        // Make SAL call
        //
        Stat = HalpSalCall(SALFunc, CfgAddr | Offset, Size, WriteVal, 0, 0, 0, 0, &RetVals);

        //
        // Retrieve SAL return data
        //
        if (AccType == PCI_READ) {
            switch (Size) {
                case 4: *((ULONG UNALIGNED *)Buffer) = (ULONG)RetVals.ReturnValues[1]; break;
                case 2: *((USHORT UNALIGNED *)Buffer) = (USHORT)RetVals.ReturnValues[1]; break;
                case 1: *Buffer = (UCHAR)RetVals.ReturnValues[1]; break;
            }
        }

        Offset += Size;
        Buffer += Size;
        Length -= Size;
    }
}


VOID
HalpReadPCIConfig(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    //
    // If request for an invalid slot, fill return buffer with -1
    //
    if (!HalpValidPCISlot(BusHandler, Slot)) {
        RtlFillMemory(Buffer, Length, (UCHAR)-1);
        return;
    }

    HalpPCIConfig(BusHandler, Slot, Buffer, Offset, Length, PCI_READ);
}

VOID
HalpWritePCIConfig(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    //
    // If request for an invalid slot, do nothing
    //
    if (!HalpValidPCISlot(BusHandler, Slot))
        return;

    HalpPCIConfig(BusHandler, Slot, Buffer, Offset, Length, PCI_WRITE);
}


BOOLEAN
HalpIsValidPCIDevice(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
/*++

Routine Description:

    Reads the device configuration data for the given slot and
    returns TRUE if the configuration data appears to be valid for
    a PCI device; otherwise returns FALSE.

Arguments:

    BusHandler  - Bus to check
    Slot        - Slot to check

--*/

{
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    ULONG               i, j;

    PciData = (PPCI_COMMON_CONFIG)iBuffer;

    //
    // Read device common header.
    //
    HalpReadPCIConfig(BusHandler, Slot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Valid device header?
    //
    if (PciData->VendorID == PCI_INVALID_VENDORID  ||
        PCI_CONFIG_TYPE(PciData) != PCI_DEVICE_TYPE) {
        return(FALSE);
    }

    //
    // Check fields for reasonable values.
    //

    //
    // Do these values make sense for IA64
    //
    if ((PciData->u.type0.InterruptPin && PciData->u.type0.InterruptPin > 4) ||
        (PciData->u.type0.InterruptLine & 0x70)) {
        return(FALSE);
    }

    for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
        j = PciData->u.type0.BaseAddresses[i];

        if (j & PCI_ADDRESS_IO_SPACE) {
            if (j > 0xffff) {
                // IO port > 64k?
                return(FALSE);
            }
        } else {
            if (j > 0xf  &&  j < 0x80000) {
                // Mem address < 0x8000h?
                return(FALSE);
            }
        }

        if (Is64BitBaseAddress(j))
            i++;
    }

    //
    // Guess it's a valid device..
    //
    return(TRUE);
}

#if !defined(NO_LEGACY_DRIVERS)

#if DBG
VOID
HalpTestPci (ULONG flag2)
{
    PCI_SLOT_NUMBER     SlotNumber;
    PCI_COMMON_CONFIG   PciData, OrigData;
    ULONG               i, f, j, k, bus;
    BOOLEAN             flag;


    if (!flag2) {
        return ;
    }

    DbgBreakPoint ();
    SlotNumber.u.bits.Reserved = 0;

    //
    // Read every possible PCI Device/Function and display it's
    // default info.
    //
    // (note this destories it's current settings)
    //

    flag = TRUE;
    for (bus = 0; flag; bus++) {

        for (i = 0; i < PCI_MAX_DEVICES; i++) {
            SlotNumber.u.bits.DeviceNumber = i;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                SlotNumber.u.bits.FunctionNumber = f;

                //
                // Note: This is reading the DeviceSpecific area of
                // the device's configuration - normally this should
                // only be done on device for which the caller understands.
                // I'm doing it here only for debugging.
                //

                j = HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

                if (j == 0) {
                    // out of buses
                    flag = FALSE;
                    break;
                }

                if (j < PCI_COMMON_HDR_LENGTH) {
                    continue;
                }

                HalSetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    1
                    );

                HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

                HalDebugPrint(( HAL_INFO, "HAL: PCI Bus %d Slot %2d %2d  ID:%04lx-%04lx  Rev:%04lx",
                    bus, i, f, PciData.VendorID, PciData.DeviceID,
                    PciData.RevisionID ));


                if (PciData.u.type0.InterruptPin) {
                    HalDebugPrint(( HAL_INFO, "  IntPin:%x", PciData.u.type0.InterruptPin ));
                }

                if (PciData.u.type0.InterruptLine) {
                    HalDebugPrint(( HAL_INFO, "  IntLine:%x", PciData.u.type0.InterruptLine ));
                }

                if (PciData.u.type0.ROMBaseAddress) {
                        HalDebugPrint(( HAL_INFO, "  ROM:%08lx", PciData.u.type0.ROMBaseAddress ));
                }

                HalDebugPrint(( HAL_INFO, "\nHAL:    Cmd:%04x  Status:%04x  ProgIf:%04x  SubClass:%04x  BaseClass:%04lx\n",
                    PciData.Command, PciData.Status, PciData.ProgIf,
                     PciData.SubClass, PciData.BaseClass ));

                k = 0;
                for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                    if (PciData.u.type0.BaseAddresses[j]) {
                        HalDebugPrint(( HAL_INFO, "  Ad%d:%08lx", j, PciData.u.type0.BaseAddresses[j] ));
                        k = 1;
                    }
                }

                if (k) {
                    HalDebugPrint(( HAL_INFO, "\n" ));
                }

                if (PciData.VendorID == 0x8086) {
                    // dump complete buffer
                    HalDebugPrint(( HAL_INFO, "HAL: Command %x, Status %x, BIST %x\n",
                        PciData.Command, PciData.Status,
                        PciData.BIST
                        ));

                    HalDebugPrint(( HAL_INFO, "HAL: CacheLineSz %x, LatencyTimer %x",
                        PciData.CacheLineSize, PciData.LatencyTimer
                        ));

                    for (j=0; j < 192; j++) {
                        if ((j & 0xf) == 0) {
                            HalDebugPrint(( HAL_INFO, "\n%02x: ", j + 0x40 ));
                        }
                        HalDebugPrint(( HAL_INFO, "%02x ", PciData.DeviceSpecific[j] ));
                    }
                    HalDebugPrint(( HAL_INFO, "\n" ));
                }

                //
                // Next
                //

                if (k) {
                    HalDebugPrint(( HAL_INFO, "\n\n" ));
                }
            }
        }
    }
    DbgBreakPoint ();
}

#endif

#endif // NO_LEGACY_DRIVERS

//------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64sysbus.c ===
/*++


Copyright (c) 1998  Microsoft Corporation

Module Name:

    i64sysbus.c

Abstract:

Author:

   Todd Kjos (HP) (v-tkjos) 1-Jun-1998
   Based on halacpi\i386\pmbus.c and halmps\i386\mpsysbus.c

Environment:

   Kernel Mode Only

Revision History:


--*/

#include "halp.h"
#include "iosapic.h"
#include <ntacpi.h>

#define HalpInti2BusInterruptLevel(Inti) Inti

KAFFINITY HalpDefaultInterruptAffinity = 0;

extern ULONG HalpPicVectorRedirect[];
extern ULONG HalpPicVectorFlags[];

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

VOID
HalpSetCPEVectorState(
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags
    );

VOID
HalpUpdateVectorAllocationInfo(
    IN ULONG    Processor,
    IN ULONG    IDTEntry
    );

#define MAX_FREE_IRQL       11
#define MIN_FREE_IRQL       3
#define MAX_FREE_IDTENTRY   0xbf
#define MIN_FREE_IDTENTRY   0x30

#define VECTOR_TO_IRQL(v)       ((KIRQL)((UCHAR)(v) >> 4))
#define VECTOR_TO_IDTENTRY(v)   ((UCHAR)(v))
#define VECTOR_TO_PROCESSOR(v)  (((v) >> 8) - 1)
#define VECTOR_TO_AFFINITY(v)   ((KAFFINITY)1 << VECTOR_TO_PROCESSOR(v))

//
// Bit array of free Vectors
//
USHORT HalpCpuFreeVectors[HAL_MAXIMUM_PROCESSOR][16];
//
// Number of allocated vectors per CPU
//
UCHAR HalpCpuAllocatedVectorCount[HAL_MAXIMUM_PROCESSOR];
//
// Number of allocated vectors per IRQL per CPU
//
UCHAR HalpCpuAllocatedIrqlCount[HAL_MAXIMUM_PROCESSOR][MAX_FREE_IRQL - MIN_FREE_IRQL + 1];
//
// Map from Vector to Inti
//
ULONG HalpVectorToINTI[HAL_MAXIMUM_PROCESSOR * 256];
//
// Special Inti tokens for HalpVectorToINTI
//
#define UNALLOCATED_VECTOR          ~0UL
#define INTERNAL_SYSTEM_INTERRUPT   ~1UL


extern KSPIN_LOCK HalpIoSapicLock;
extern BUS_HANDLER HalpFakePciBusHandler;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,   HalpSetInternalVector)
#pragma alloc_text(INIT,   HalpInitInterruptTables)
#pragma alloc_text(PAGELK, HalpGetSystemInterruptVector)
#pragma alloc_text(PAGE, HaliSetVectorState)
#pragma alloc_text(PAGE, HalpSetCPEVectorState)
#pragma alloc_text(PAGE, HalIrqTranslateResourceRequirementsRoot)
#pragma alloc_text(PAGE, HalTranslatorReference)
#pragma alloc_text(PAGE, HalTranslatorDereference)
#pragma alloc_text(PAGE, HaliIsVectorValid)
#endif

VOID
HalpInitInterruptTables(
    VOID
    )
{
    int index;

    // Initialize the vector to INTi table

    for (index = 0; index < (HAL_MAXIMUM_PROCESSOR * 256); index++) {

        if (index < HAL_MAXIMUM_PROCESSOR)
        {
            RtlFillMemory( &HalpCpuFreeVectors[index][0],
                           MIN_FREE_IRQL * sizeof(USHORT),
                           0x00
                           );

            RtlFillMemory( &HalpCpuFreeVectors[index][MIN_FREE_IRQL],
                           (MAX_FREE_IRQL - MIN_FREE_IRQL + 1) * sizeof(USHORT),
                           0xFF
                           );

            RtlFillMemory( &HalpCpuFreeVectors[index][MAX_FREE_IRQL + 1],
                           (16 - MAX_FREE_IRQL) * sizeof(USHORT),
                           0x00
                           );
        }

        HalpVectorToINTI[index] = UNALLOCATED_VECTOR;
    }
}

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PUINT_PTR Context,
    IN BOOLEAN NextBus
    )

/*++

Routine Description:

    This routine performs a very similar function to HalTranslateBusAddress
    except that InterfaceType and BusNumber are not known by the caller.
    This function will walk all busses known by the HAL looking for a
    valid translation for the input BusAddress of type AddressSpace.

    This function is recallable using the input/output Context parameter.
    On the first call to this routine for a given translation the UINT_PTR
    Context should be NULL.  Note:  Not the address of it but the contents.

    If the caller decides the returned translation is not the desired
    translation, it calls this routine again passing Context in as it
    was returned on the previous call.  This allows this routine to
    traverse the bus structures until the correct translation is found
    and is provided because on multiple bus systems, it is possible for
    the same resource to exist in the independent address spaces of
    multiple busses.

Arguments:

    BusAddress          Address to be translated.
    AddressSpace        0 = Memory
                        1 = IO (There are other possibilities).
                        N.B. This argument is a pointer, the value
                        will be modified if the translated address
                        is of a different address space type from
                        the untranslated bus address.
    TranslatedAddress   Pointer to where the translated address
                        should be stored.
    Context             Pointer to a UINT_PTR. On the initial call,
                        for a given BusAddress, it should contain
                        0.  It will be modified by this routine,
                        on subsequent calls for the same BusAddress
                        the value should be handed in again,
                        unmodified by the caller.
    NextBus             FALSE if we should attempt this translation
                        on the same bus as indicated by Context,
                        TRUE if we should be looking for another
                        bus.

Return Value:

    TRUE    if translation was successful,
    FALSE   otherwise.

--*/

{
    //
    // First, make sure the context parameter was supplied and is
    // being used correctly.  This also ensures that the caller
    // doesn't get stuck in a loop looking for subsequent translations
    // for the same thing.  We won't succeed the same translation twice
    // unless the caller reinits the context.
    //

    if ((!Context) || (*Context && (NextBus == TRUE))) {
        return FALSE;
    }
    *Context = 1;

    //
    // PC/AT (halx86) case is simplest, there is no translation.
    //

    *TranslatedAddress = BusAddress;
    return TRUE;
}


BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    BOOLEAN             status;
    PSUPPORTED_RANGE    pRange;

    status  = FALSE;

    switch (*AddressSpace) {
    case 0:
        // verify memory address is within buses memory limits
        pRange = &BusHandler->BusAddresses->Memory;
        while (!status  &&  pRange) {
            status = BusAddress.QuadPart >= pRange->Base &&
                     BusAddress.QuadPart <= pRange->Limit;
            pRange = pRange->Next;
        }

        pRange = &BusHandler->BusAddresses->PrefetchMemory;
        while (!status  &&  pRange) {
            status = BusAddress.QuadPart >= pRange->Base &&
                     BusAddress.QuadPart <= pRange->Limit;

            pRange = pRange->Next;
        }
        break;

    case 1:
        // verify IO address is within buses IO limits
        pRange = &BusHandler->BusAddresses->IO;
        while (!status  &&  pRange) {
            status = BusAddress.QuadPart >= pRange->Base &&
                     BusAddress.QuadPart <= pRange->Limit;

            pRange = pRange->Next;
        }
        break;

    default:
        status = FALSE;
        break;
    }

    if (status) {
        TranslatedAddress->LowPart = BusAddress.LowPart;
        TranslatedAddress->HighPart = BusAddress.HighPart;
    }

    return status;
}


UCHAR
HalpAllocateVectorIrqlOffset(
    IN ULONG Processor,
    IN KIRQL Irql,
    IN PUSHORT PreferredVectors
    )
{
    USHORT  cpuFree = HalpCpuFreeVectors[Processor][Irql];
    ULONG   index;

    //
    // We've found one less busy, we shouldn't need to look any further
    //

    if (PreferredVectors != NULL) {

        cpuFree &= PreferredVectors[Irql];
    }

    for (index = 0; index < 16; index++) {

        if (cpuFree & (1 << index)) {

            return (UCHAR)((Irql << 4) | index);
        }
    }

    return 0;
}

UCHAR
HalpAllocateVectorIrql(
    IN ULONG Processor,
    IN PUSHORT PreferredVectors
    )
{
    KIRQL   irql;
    UCHAR   vector;

    //
    // Now Find the least busy IRQL
    //
    for (irql = MAX_FREE_IRQL - 1; irql >= MIN_FREE_IRQL; irql--) {

        if (HalpCpuAllocatedIrqlCount[Processor][irql - MIN_FREE_IRQL] <
            HalpCpuAllocatedIrqlCount[Processor][MAX_FREE_IRQL - MIN_FREE_IRQL]) {

            vector = HalpAllocateVectorIrqlOffset(Processor, irql, PreferredVectors);

            if (vector != 0) {
                return vector;
            }
        }
    }

    for (irql = MAX_FREE_IRQL; irql >= MIN_FREE_IRQL; irql--) {

        if (HalpCpuAllocatedIrqlCount[Processor][irql - MIN_FREE_IRQL] >=
            HalpCpuAllocatedIrqlCount[Processor][MAX_FREE_IRQL - MIN_FREE_IRQL]) {

            vector = HalpAllocateVectorIrqlOffset(Processor, irql, PreferredVectors);

            if (vector != 0) {
                return vector;
            }
        }
    }

    return 0;
}

ULONG
HalpAllocateVectorCpu(
    IN KAFFINITY    Affinity,
    IN PUSHORT      PreferredVectors
    )
{
    ULONG       cpu, selectedCpu;
    UCHAR       IDTEntry;
    KAFFINITY   cpuList;

    //
    // Find the least busy CPU
    //
    IDTEntry = 0;
    selectedCpu = ~0UL;

    cpuList = Affinity & HalpActiveProcessors;

    for (cpu = 0; cpuList != 0; cpuList >>= 1, cpu++) {

        if (cpuList & 1) {

            if (selectedCpu == ~0UL) {

                selectedCpu = cpu;
                continue;
            }

            if (HalpCpuAllocatedVectorCount[cpu] <
                HalpCpuAllocatedVectorCount[selectedCpu]) {

                //
                // We've found one less busy, we shouldn't need to look any further
                //
                IDTEntry = HalpAllocateVectorIrql(cpu, PreferredVectors);

                if (IDTEntry != 0) {
                    return ((cpu + 1) << 8) | IDTEntry;
                }
            }
        }
    }

    cpuList = Affinity & HalpActiveProcessors;

    for (cpu = 0; cpuList != 0; cpuList >>= 1, cpu++) {

        if (cpuList & 1) {

            if (HalpCpuAllocatedVectorCount[cpu] >=
                HalpCpuAllocatedVectorCount[selectedCpu]) {

                //
                // We've found one less busy, we shouldn't need to look any further
                //
                IDTEntry = HalpAllocateVectorIrql(cpu, PreferredVectors);

                if (IDTEntry != 0) {
                    return ((cpu + 1) << 8) | IDTEntry;
                }
            }
        }
    }

    return 0;
}

ULONG
HalpAllocateSystemInterruptVector(
    IN     ULONG Interrupt,
    IN OUT PKIRQL Irql,
    IN OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    This function allocates a system interrupt vector that reflects
    the maximum specified affinity and priority allocation policy.  A
    system interrupt vector is returned along with the IRQL and a
    modified affinity.

    NOTE: HalpIoSapicLock must already have been taken at HIGH_LEVEL.

Arguments:

    Irql - Returns the system request priority.

    Affinity - What is passed in represents the maximum affinity that
    can be returned.  Returned value represents that affinity
    constrained by the node chosen.

Return Value:

    Returns the system interrupt vector

--*/
{
    ULONG   SystemVector;
    PUSHORT preferredVectors = NULL;

    if (HalpMaxProcsPerCluster == 0)  {

        SystemVector = HalpAllocateVectorIrql(0, NULL);

    } else {

        if (Interrupt != INTERNAL_SYSTEM_INTERRUPT) {

            HalpGetFreeVectors(Interrupt, &preferredVectors);
        }

        SystemVector = HalpAllocateVectorCpu(*Affinity, preferredVectors);
    }

    if (SystemVector == 0) {
        return 0;
    }

    if (preferredVectors != NULL) {

        HalpSetVectorAllocated(Interrupt, VECTOR_TO_IDTENTRY(SystemVector));
    }

    //
    // Now form the vector for the kernel.

    ASSERT(VECTOR_TO_IDTENTRY(SystemVector) <= MAX_FREE_IDTENTRY);
    ASSERT(VECTOR_TO_IDTENTRY(SystemVector) >= MIN_FREE_IDTENTRY);

    *Irql = VECTOR_TO_IRQL(SystemVector);
    ASSERT(*Irql <= MAX_FREE_IRQL);

    if (HalpMaxProcsPerCluster != 0)  {
        *Affinity = VECTOR_TO_AFFINITY(SystemVector);
    }

    HalpUpdateVectorAllocationInfo( VECTOR_TO_PROCESSOR(SystemVector),
                                    VECTOR_TO_IDTENTRY(SystemVector));

    HalpVectorToINTI[SystemVector] = Interrupt;

    HalDebugPrint(( HAL_VERBOSE, "HAL: SystemVector %x  Irql %x\n", SystemVector, *Irql));

    return SystemVector;
}


ULONG
HalpGetSystemInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

    This function returns the system interrupt vector and IRQL
    corresponding to the specified bus interrupt level and/or
    vector.  The system interrupt vector and IRQL are suitable
    for use in a subsequent call to KeInitializeInterrupt.

Arguments:

    InterruptLevel - Supplies the bus specific interrupt level.

    InterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG           SystemVector, SapicInti;
    ULONG           OldLevel;
    BOOLEAN         Found;
    PVOID           LockHandle;
    ULONG           Node;
    KAFFINITY       SapicAffinity;


    UNREFERENCED_PARAMETER( InterruptVector );

    *Affinity = HalpDefaultInterruptAffinity;

    //
    // Find closest child bus to this handler
    //

    if (RootHandler != BusHandler) {
        while (RootHandler->ParentHandler != BusHandler) {
            RootHandler = RootHandler->ParentHandler;
        }
    }

    //
    // Find Interrupt's Sapic Inti connection
    //

    Found = HalpGetSapicInterruptDesc (
                RootHandler->InterfaceType,
                RootHandler->BusNumber,
                InterruptLevel,
                &SapicInti,
                &SapicAffinity
                );

    if (!Found) {
        return 0;
    }

    HalDebugPrint(( HAL_VERBOSE, "HAL: type %x  Level: %x  gets inti: %x Sapicaffinity: %p\n",
                    RootHandler->InterfaceType,
                    InterruptLevel,
                    SapicInti,
                    SapicAffinity));
    //
    // If device interrupt vector mapping is not already allocated,
    // then do it now
    //

    SystemVector = 0;

    if (!HalpINTItoVector(SapicInti)) {

        //
        // Vector is not allocated - synchronize and check again
        //

        LockHandle = MmLockPagableCodeSection(&HalpGetSystemInterruptVector);
        OldLevel = HalpAcquireHighLevelLock(&HalpIoSapicLock);
        if (!HalpINTItoVector(SapicInti)) {

            //
            // Still not allocated
            //

            HalDebugPrint(( HAL_VERBOSE, "HAL: vector is not allocated\n"));

            SystemVector = HalpAllocateSystemInterruptVector(SapicInti, Irql, Affinity);

            HalpSetINTItoVector(SapicInti, SystemVector);

        }

        HalpReleaseHighLevelLock(&HalpIoSapicLock, OldLevel);
        MmUnlockPagableImageSection(LockHandle);
    }

    if (SystemVector == 0 && (SystemVector = HalpINTItoVector(SapicInti)) != 0) {

        //
        // Return this SapicInti's system vector & irql
        //

        *Irql = VECTOR_TO_IRQL(SystemVector);

        if (HalpMaxProcsPerCluster != 0) {
            *Affinity = VECTOR_TO_AFFINITY(SystemVector);
        }
    }

    HalDebugPrint(( HAL_VERBOSE, "HAL: SystemVector: %x\n",
                    SystemVector));

    ASSERT(HalpVectorToINTI[SystemVector] == (USHORT) SapicInti);

    HalDebugPrint(( HAL_VERBOSE, "HAL: HalpGetSystemInterruptVector - In  Level 0x%x, In  Vector 0x%x\n",
                    InterruptLevel, InterruptVector ));
    HalDebugPrint(( HAL_VERBOSE, "HAL:                                Out Irql  0x%x, Out System Vector 0x%x\n",
                    *Irql, SystemVector ));

    return SystemVector;
}

BOOLEAN
HalpIsInternalInterruptVector(
    ULONG SystemVector
    )
/*++

Routine Description:

    This function returns whether or not the vector specified is an
    internal vector i.e. one not connected to the IOAPIC

Arguments:

    System Vector - specifies an interrupt vector

Return Value:

    BOOLEAN - TRUE indicates that the vector is internal.

--*/
{
    return HalpVectorToINTI[SystemVector] == INTERNAL_SYSTEM_INTERRUPT;
}

NTSTATUS
HalpReserveCrossPartitionInterruptVector(
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    IN OUT PKAFFINITY Affinity,
    OUT PUCHAR HardwareVector
    )
/*++

Routine Description:

    This function returns the system interrupt vector, IRQL, and
    corresponding to the specified bus interrupt level and/or
    vector.  The system interrupt vector and IRQL are suitable
    for use in a subsequent call to KeInitializeInterrupt.

Arguments:

    Vector - specifies an interrupt vector that can be passed to
    IoConnectInterrupt.

    Irql - specifies the irql that should be passed to IoConnectInterrupt

    Affinity - should be set to the requested maximum affinity.  On
    return, it will reflect the actual affinity that should be
    specified in IoConnectInterrupt.

    HardwareVector - this is the hardware vector to be used by a
    remote partition to target this interrupt vector.

Return Value:

    NTSTATUS

--*/
{
    ULONG OldLevel;

    OldLevel = HalpAcquireHighLevelLock(&HalpIoSapicLock);

    *Vector = HalpAllocateSystemInterruptVector(INTERNAL_SYSTEM_INTERRUPT, Irql, Affinity);

    HalpReleaseHighLevelLock(&HalpIoSapicLock, OldLevel);

    *HardwareVector = VECTOR_TO_IDTENTRY(*Vector);

    return STATUS_SUCCESS;
}


//
// This section implements a "translator," which is the PnP-WDM way
// of doing the same thing that the first part of this file does.
//
VOID
HalTranslatorReference(
    PVOID Context
    )
{
    return;
}

VOID
HalTranslatorDereference(
    PVOID Context
    )
{
    return;
}

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function takes a CM_PARTIAL_RESOURCE_DESCRIPTOR and translates
    it to an IO-bus-relative from a Processor-bus-relative form, or the other
    way around.  In this x86-specific example, an IO-bus-relative form is the
    ISA IRQ and the Processor-bus-relative form is the IDT entry and the
    associated IRQL.

    N.B.  This funtion has an associated "Direction."  These are not exactly
          reciprocals.  This has to be the case because the output from
          HalIrqTranslateResourceRequirementsRoot will be used as the input
          for the ParentToChild case.

          ChildToParent:

            Level  (ISA IRQ)        -> IRQL
            Vector (ISA IRQ)        -> x86 IDT entry
            Affinity (not refereced)-> KAFFINITY

          ParentToChild:

            Level (not referenced)  -> (ISA IRQ)
            Vector (IDT entry)      -> (ISA IRQ)
            Affinity                -> 0xffffffff

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    Direction   - direction of translation (parent to child or child to parent)

    AlternativesCount   - unused

    Alternatives        - unused

    PhysicalDeviceObject- unused

    Target      - translated descriptor

Return Value:

    status

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PBUS_HANDLER    bus;
    KAFFINITY       affinity;
    KIRQL           irql;
    ULONG           vector, inti;
    BUS_HANDLER     fakeIsaBus;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    switch (Direction) {
    case TranslateChildToParent:


        RtlCopyMemory(&fakeIsaBus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        fakeIsaBus.InterfaceType = Isa;
        fakeIsaBus.ParentHandler = &fakeIsaBus;
        bus = &fakeIsaBus;

        //
        // Copy everything
        //
        *Target = *Source;
        affinity = Source->u.Interrupt.Affinity;

        //
        // Translate the IRQ
        //

        vector = HalpGetSystemInterruptVector(bus,
                                              bus,
                                              Source->u.Interrupt.Level,
                                              Source->u.Interrupt.Vector,
                                              &irql,
                                              &affinity);

        Target->u.Interrupt.Level  = irql;
        Target->u.Interrupt.Vector = vector;
        Target->u.Interrupt.Affinity = affinity;

        if (NT_SUCCESS(status)) {
            status = STATUS_TRANSLATION_COMPLETE;
        }

        break;

    case TranslateParentToChild:

        //
        // Copy everything
        //
        *Target = *Source;

        //
        // There is no inverse to HalpGetSystemInterruptVector, so we
        // just do what that function would do.
        //

        ASSERT(HalpVectorToINTI[Source->u.Interrupt.Vector] != UNALLOCATED_VECTOR);

        inti = HalpVectorToINTI[Source->u.Interrupt.Vector];

        Target->u.Interrupt.Level = Target->u.Interrupt.Vector =
            HalpInti2BusInterruptLevel(inti);

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes an IO_RESOURCE_DESCRIPTOR and translates
    it from an IO-bus-relative to a Processor-bus-relative form.  In this
    x86-specific example, an IO-bus-relative form is the ISA IRQ and the
    Processor-bus-relative form is the IDT entry and the associated IRQL.
    This is essentially a PnP form of HalGetInterruptVector.

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    PhysicalDeviceObject- unused

    TargetCount - 1

    Target      - translated descriptor

Return Value:

    status

--*/
{
    PBUS_HANDLER    bus;
    KAFFINITY       affinity;
    KIRQL           irql;
    ULONG           vector;
    BOOLEAN         success = TRUE;
    BUS_HANDLER     fakeIsaBus;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    RtlCopyMemory(&fakeIsaBus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
    fakeIsaBus.InterfaceType = Isa;
    fakeIsaBus.ParentHandler = &fakeIsaBus;
    bus = &fakeIsaBus;

    //
    // The interrupt requirements were obtained by calling HalAdjustResourceList
    // so we don't need to call it again.
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *TargetCount = 1;

    //
    // Copy the requirement unchanged
    //

    **Target = *Source;

    //
    // Perform the translation of the minimum & maximum
    //

    vector = HalpGetSystemInterruptVector(bus,
                                          bus,
                                          Source->u.Interrupt.MinimumVector,
                                          Source->u.Interrupt.MinimumVector,
                                          &irql,
                                          &affinity);

    if (!vector) {
        success = FALSE;
    }

    (*Target)->u.Interrupt.MinimumVector = vector;

    vector = HalpGetSystemInterruptVector(bus,
                                          bus,
                                          Source->u.Interrupt.MaximumVector,
                                          Source->u.Interrupt.MaximumVector,
                                          &irql,
                                          &affinity);

    if (!vector) {
        success = FALSE;
    }

    (*Target)->u.Interrupt.MaximumVector = vector;

    if (!success) {

        ExFreePool(*Target);
        *TargetCount = 0;
    }

    return STATUS_TRANSLATION_COMPLETE;
}

// These defines come from the MPS 1.4 spec, section 4.3.4
#define PO_BITS                     3
#define POLARITY_HIGH               1
#define POLARITY_LOW                3
#define POLARITY_CONFORMS_WITH_BUS  0
#define EL_BITS                     0xc
#define EL_BIT_SHIFT                2
#define EL_EDGE_TRIGGERED           4
#define EL_LEVEL_TRIGGERED          0xc
#define EL_CONFORMS_WITH_BUS        0

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    )
{
    BOOLEAN found;
    ULONG inti;
    ULONG picVector;
    KAFFINITY affinity;

    PAGED_CODE();

    found = HalpGetSapicInterruptDesc( 0, 0, Vector, &inti, &affinity);

    if (!found) {
        KeBugCheckEx(ACPI_BIOS_ERROR,
                     0x10007,
                     Vector,
                     0,
                     0);
    }

    // ASSERT(HalpIntiInfo[inti].Type == INT_TYPE_INTR);

    //
    // Vector is already translated through
    // the PIC vector redirection table.  We need
    // to make sure that we are honoring the flags
    // in the redirection table.  So look in the
    // table here.
    //

    for (picVector = 0; picVector < PIC_VECTORS; picVector++) {

        if (HalpPicVectorRedirect[picVector] == Vector) {

            //
            // Found this vector in the redirection table.
            //

            if (HalpPicVectorFlags[picVector] != 0) {

                //
                // And the flags say something other than "conforms
                // to bus."  So we honor the flags from the table.
                //
                switch ((UCHAR)(HalpPicVectorFlags[picVector] & EL_BITS) ) {

                case EL_EDGE_TRIGGERED:   HalpSetLevel(inti, FALSE);  break;

                case EL_LEVEL_TRIGGERED:  HalpSetLevel(inti, TRUE); break;

                default: // do nothing
                    break;
                }

                switch ((UCHAR)(HalpPicVectorFlags[picVector] & PO_BITS)) {

                case POLARITY_HIGH: HalpSetPolarity(inti, FALSE); break;

                case POLARITY_LOW:  HalpSetPolarity(inti, TRUE);  break;

                default: // do nothing
                    break;
                }

                return;
            }
        }
    }

    //
    // This vector is not covered in the table, or it "conforms to bus."
    // So we honor the flags passed into this function.
    //

    HalpSetLevel(inti, IS_LEVEL_TRIGGERED(Flags) != FALSE);

    HalpSetPolarity(inti, IS_ACTIVE_LOW(Flags) != FALSE);
}


VOID
HalpSetInternalVector(
    IN ULONG    InternalVector,
    IN PHAL_INTERRUPT_ROUTINE HalInterruptServiceRoutine
    )
/*++

Routine Description:

    Used at init time to set IDT vectors for internal use.

--*/
{
    //
    // Remember this vector so it's reported as Hal internal usage
    //

    HalpRegisterVector( InternalUsage, InternalVector, InternalVector, (KIRQL)(InternalVector >> 4) );

    HalpUpdateVectorAllocationInfo(PCR->Prcb->Number, InternalVector);

    //
    // Connect the IDT
    //

    HalpSetHandlerAddressToVector(InternalVector, HalInterruptServiceRoutine);
}

VOID
HalpUpdateVectorAllocationInfo(
    IN ULONG    Processor,
    IN ULONG    IDTEntry
    )
{
    KIRQL   irql = (KIRQL)(IDTEntry >> 4);

    if (IDTEntry >= MIN_FREE_IDTENTRY && IDTEntry <= MAX_FREE_IDTENTRY) {

        if (HalpMaxProcsPerCluster == 0) {

            if (!(HalpCpuFreeVectors[0][irql] & (1 << (IDTEntry & 0x0F)))) {

                return;
            }

            Processor = 0;
        }

        HalpCpuFreeVectors[Processor][irql] &= ~(1 << (IDTEntry & 0x0F));

        HalpCpuAllocatedVectorCount[Processor]++;

        HalpCpuAllocatedIrqlCount[Processor][irql - MIN_FREE_IRQL]++;
    }
}


VOID
HalpSetCPEVectorState(
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags
    )
{
    BOOLEAN found;
    ULONG SapicInti;
    KAFFINITY affinity;

    PAGED_CODE();

    found = HalpGetSapicInterruptDesc( 0, 0, GlobalInterrupt, &SapicInti, &affinity);

    if ( found ) {

        HalpWriteRedirEntry( GlobalInterrupt, SapicVector, DestinationCPU, Flags, PLATFORM_INT_CPE );

    }
    else    {

        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpSetCPEVectorState - Could not find interrupt input for SAPIC interrupt %ld\n",
                        GlobalInterrupt ));

    }

    return;

} // HalpSetCPEVectorState()

BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    )
{
    BOOLEAN found;
    ULONG   inti;
    KAFFINITY affinity;

    PAGED_CODE();

    return HalpGetSapicInterruptDesc( 0, 0, Vector, &inti, &affinity);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\i64sxint.c ===
//

/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64sxint.c copied from simsxint.c

Abstract:

    This module implements the routines to manage the
    system interrupt and IRQL.

Author:

    William K. Cheung (wcheung) 14-Apr-1995
    Bernard Lint
    M. Jayakumar (Muthurajan.Jayakumar@intel.com)
Environment:

    Kernel mode

Revision History:

   Todd Kjos (HP) (v-tkjos) 1-Jun-1998 : Added I/O Sapic support

   Thierry Fevrier (HP) (v-thief) 8-Feb-2000 : Profiling support

--*/

#include "halp.h"
#include "iosapic.h"

VOID HalpInitLINT(VOID);

extern KSPIN_LOCK HalpIoSapicLock;
extern PULONG_PTR *HalEOITable[];
PULONG_PTR HalpEOITableP0[MAX_INTR_VECTOR];


VOID
HalpInitializeInterrupts (
    VOID
    )
/*++

Routine Description:

    This function initializes interrupts for an IA64 system.

Arguments:

    None.

Return Value:

    None.

Note:

    In KiInitializeKernel(), PCR.InterruptRoutine[] entries have been first initialized
    with the Unexpected Interrupt code then entries index-0, APC_VECTOR, DISPATCH_VECTOR
    have been initialized with their respective interrupt handlers.

--*/
{

    //
    // Turn off LINT0 LINT1 (disable 8259)
    //
    // We used to call HalpInitLINT here.  However it was unnecessary since we
    // already called it in HalInitializeProcessor.  Also it meant that if a
    // CPE occurred prior to this point we would lose it.

    //
    // interval timer interrupt; 10ms by default
    //

    HalpInitializeClockInterrupts();

    //
    // Initialize SpuriousInterrupt
    //

    HalpSetInternalVector(SAPIC_SPURIOUS_VECTOR, HalpSpuriousHandler);


    //
    // Initialize CMCI Interrupt
    //
    // Note that it is possible that HAL_CMC_PRESENT is not set.
    // With the current implementation, we always connect the vector to the ISR.
    //

    HalpSetInternalVector(CMCI_VECTOR, HalpCMCIHandler);

    //
    // Initialize CPEI Interrupt
    //
    // Note that it is possible that HAL_CPE_PRESENT is not set.
    // With the current implementation, we always connect the vector to the ISR.
    //

    HalpSetInternalVector(CPEI_VECTOR, HalpCPEIHandler);

    //
    // Initialiaze MC Rendezvous Interrupt
    //

    HalpSetInternalVector(MC_RZ_VECTOR, HalpMcRzHandler);

    //
    // Initialize MC Wakeup Interrupt
    //

    HalpSetInternalVector(MC_WKUP_VECTOR, HalpMcWkupHandler);

    //
    // IPI Interrupt
    //

    HalpSetInternalVector(IPI_VECTOR, HalpIpiInterruptHandler);

    //
    // profile timer interrupt; turned off initially
    //

    HalpSetInternalVector(PROFILE_VECTOR, HalpProfileInterrupt);

    //
    // Performance monitor interrupt
    //

    HalpSetInternalVector(PERF_VECTOR, HalpPerfInterrupt);

} // HalpInitializeInterrupts()

VOID
HalpInitEOITable(
    VOID
    )
{
    USHORT Index;
    ULONG ProcessorNumber;

    // Allocate and Initialize EOI table on current processor

    ProcessorNumber = PCR->Prcb->Number;

    if (ProcessorNumber == 0) {
       HalEOITable[ProcessorNumber] = HalpEOITableP0;
    } else {
       HalEOITable[ProcessorNumber] = ExAllocatePool(NonPagedPool,
                                                     MAX_INTR_VECTOR*sizeof(HalEOITable[0]));
    }

    // For kernel access to eoi table

    PCR->EOITable = HalEOITable[ProcessorNumber];

    for (Index=0; Index < MAX_INTR_VECTOR; Index++) {
       HalEOITable[ProcessorNumber][Index] = 0;
    }
}


VOID
HalpWriteEOITable(
    IN ULONG     Vector,
    IN PULONG_PTR EoiAddress,
    IN ULONG Number
    )
/*++

Routine Description:

    This routine updates the EOI table for a processor

Arguments:

    Vector - Entry to update (IDT entry)

    EoiAddress - Address to write (SAPIC address)

    Number - Logical (NT) processor number

Return Value:

    None

--*/

{

    if (HalEOITable != NULL && HalEOITable[Number] != NULL) {
        HalEOITable[Number][Vector] = EoiAddress;
    }

}


BOOLEAN
HalEnableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This routine enables the specified system interrupt.

    N.B. This routine assumes that the caller has provided any required
         synchronization to enable a system interrupt.

Arguments:

    Vector - Supplies the vector of the system interrupt that is enabled.

    Irql - Supplies the IRQL of the interrupting source.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or
                    Latched.

Return Value:

    TRUE if the system interrupt was enabled

--*/

{
    ULONG Entry, Destination;
    ULONG OldLevel;
    ULONG Inti;
    ULONG LevelAndPolarity;
    USHORT ThisCpuApicID;
    ULONG InterruptType;
    BOOLEAN RetVal = TRUE;
    UCHAR IDTEntry;

    ASSERT(Vector < (ULONG)((1+HAL_MAXIMUM_PROCESSOR)*0x100-1));
    ASSERT(Irql <= HIGH_LEVEL);

    HalDebugPrint(( HAL_VERBOSE, "HAL: HalpEnableSystemInterrupt - INTI=0x%x  Vector=0x%x  IRQL=0x%x\n",
             HalpVectorToINTI[Vector],
             Vector,
             Irql ));

    if ( (Inti = HalpVectorToINTI[Vector]) == ~0UL ) {

        return FALSE;
    }

    if (HalpIsInternalInterruptVector(Vector)) {

        //
        // There is no external device associated with this interrupt,
        // but it might be an internal interrupt i.e. one that never
        // involves the IOSAPIC.
        //
        return TRUE;
    }

    // Make sure the passed-in level matches our settings...
    if ((InterruptMode == LevelSensitive && !HalpIsLevelTriggered(Inti)) ||
       (InterruptMode != LevelSensitive && HalpIsLevelTriggered(Inti)) ) {

      // It doesn't match!
      HalDebugPrint(( HAL_INFO, "HAL: HalpEnableSystemInterrupt - Warning device interrupt mode overridden\n"));
    }

    LevelAndPolarity =
        (HalpIsLevelTriggered(Inti) ? LEVEL_TRIGGERED : EDGE_TRIGGERED) |
        (HalpIsActiveLow(Inti)      ? ACTIVE_LOW      : ACTIVE_HIGH);

    //
    // Block interrupts and synchronize until we're done
    //
    OldLevel = HalpAcquireHighLevelLock (&HalpIoSapicLock);

    ThisCpuApicID = (USHORT)KeGetPcr()->HalReserved[PROCESSOR_ID_INDEX];

    // Get Interrupt type
    HalpGetRedirEntry(Inti,&Entry,&Destination);

    InterruptType = Entry & INT_TYPE_MASK;
    IDTEntry = HalVectorToIDTEntry(Vector);

    switch (InterruptType) {
    case DELIVER_FIXED:
    case DELIVER_LOW_PRIORITY:
        //
        // Normal external interrupt...
        // Enable the interrupt in the I/O SAPIC redirection table
        //
        if (IDTEntry < 16) {
            // Reserved vectors: Extint, NMI, IntelReserved
            // No vectors in this range can be assigned
            ASSERT(0);
            RetVal = FALSE;
            break;
        }

        //
        // All external interrupts are delivered as Fixed interrupts
        // without the "redirectable" bit set (aka Lowest Priority).  This
        // disallows hardware to redirect the interrupts using the XTP mechanism.
        //

        Entry = (ULONG)IDTEntry | LevelAndPolarity;

        HalpSetRedirEntry ( Inti, Entry, ThisCpuApicID );
        break;

    case DELIVER_EXTINT:
        //
        // This is an interrupt that uses the IO Sapic to route PIC
        // events.  This configuration is not supported in IA64.
        //
        ASSERT(0);
        RetVal = FALSE;
        break;

    default:
        HalDebugPrint(( HAL_ERROR, "HAL: HalEnableSystemInterrupt - Unknown Interrupt Type: %d\n",
                 InterruptType));
        RetVal = FALSE;
        break;
    } // switch (InterruptType)

   HalpReleaseHighLevelLock (&HalpIoSapicLock, OldLevel);
   return(RetVal);
}

VOID
HalDisableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine disables the specified system interrupt.

    In the simulation environment, this function does nothing and returns.

    N.B. This routine assumes that the caller has provided any required
        synchronization to disable a system interrupt.

Arguments:

    Vector - Supplies the vector of the system interrupt that is disabled.

    Irql - Supplies the IRQL of the interrupting source.

Return Value:

    None.

--*/

{
    ULONG Entry, Destination;
    ULONG OldLevel;
    ULONG Inti;
    ULONG LevelAndPolarity;
    ULONG ThisCpuApicID;
    ULONG InterruptType;

    ASSERT(Vector < (1+HAL_MAXIMUM_PROCESSOR)*0x100-1);
    ASSERT(Irql <= HIGH_LEVEL);

    HalDebugPrint(( HAL_INFO, "HAL: HalpDisableSystemInterrupt: INTI=%x  Vector=%x  IRQL=%x\n",
             HalpVectorToINTI[Vector],
             Vector,
             Irql));

    if ( (Inti = HalpVectorToINTI[Vector]) == (ULONG)-1 ) {
        //
        // There is no external device associated with this interrupt
        //
        return;
    }

    //
    // Block interrupts and synchronize until we're done
    //
    OldLevel = HalpAcquireHighLevelLock(&HalpIoSapicLock);

    ThisCpuApicID = (USHORT)KeGetPcr()->HalReserved[PROCESSOR_ID_INDEX];

    // Get Interrupt Type and Destination
    HalpGetRedirEntry(Inti, &Entry, &Destination);

    if (ThisCpuApicID != Destination) {
        // The interrupt is not enabled on this Cpu
        HalpReleaseHighLevelLock (&HalpIoSapicLock, OldLevel);
        return;
    }

    InterruptType = Entry & INT_TYPE_MASK;

    switch (InterruptType) {
    case DELIVER_FIXED:
        //
        // Normal external interrupt...
        // Disable the interrupt in the I/O SAPIC redirection table
        //
        if (Vector < 16) {
            // Reserved vectors: Extint, NMI, IntelReserved
            // No vectors in this range can be assigned
            ASSERT(0);
            break;
        }

        HalpDisableRedirEntry (Inti);
        break;

    case DELIVER_EXTINT:
        //
        // This is an interrupt that uses the IO Sapic to route PIC
        // events.  This configuration is not supported in IA64.
        //
        ASSERT(0);
        break;

    default:
        HalDebugPrint(( HAL_INFO, "HAL: HalDisableSystemInterrupt - Unknown Interrupt Type: %d\n",
                      InterruptType ));
        break;
    } // switch (InterruptType)

    HalpReleaseHighLevelLock (&HalpIoSapicLock, OldLevel);
}


ULONG
HalpGetProcessorNumberByApicId(
    USHORT ApicId
    )
/*++

Routine Description:

    This routine returns the logical processor number for a given
    physical processor id (extended local sapic id)

Arguments:

    ApicId -- Extended ID of processor (16 bit id)

Return Value:

    Logical (NT) processor number

--*/

{
    ULONG index;

    for (index = 0; index < HalpMpInfo.ProcessorCount; index++) {

        if (ApicId == HalpProcessorInfo[index].LocalApicID) {

            return HalpProcessorInfo[index].NtProcessorNumber;
        }
    }

    ASSERT (index < HalpMpInfo.ProcessorCount);

    //
    // Note: The previous code returned an invalid index (HalpMpInfo.ProcessorCount
    // which is 1 greater than the number of processors) we should probably
    // just bugcheck here.
    //

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ia64prof.h ===
#ifndef IA64PROF_H_INCLUDED
#define IA64PROF_H_INCLUDED

/*++

Copyright (c) 1989-2000  Microsoft Corporation

Component Name:

    IA64 Profiling

Module Name:

    ia64prof.h

Abstract:

    This header file presents the IA64 specific profiling definitions 

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    ToBeSpecified

Revision History:

    3/15/2000 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

//
// Warning: The definition of HALPROFILE_PCR should match the HalReserved[] type definition
//          and the PROCESSOR_PROFILING_INDEX based indexes.
//

//
// IA64 Generic - Number of PMCs / PMDs pairs.
//

#define PROCESSOR_IA64_PERFCOUNTERS_PAIRS  4

typedef struct _HALPROFILE_PCR {
    ULONGLONG ProfilingRunning;
    ULONGLONG ProfilingInterruptHandler;    
    ULONGLONG ProfilingInterrupts;                  // XXTF - DEBUG
    ULONGLONG ProfilingInterruptsWithoutProfiling;  // XXTF - DEBUG
    ULONGLONG ProfileSource [ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
    ULONGLONG PerfCnfg      [ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
    ULONGLONG PerfData      [ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
    ULONGLONG PerfCnfgReload[ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
    ULONGLONG PerfDataReload[ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
} HALPROFILE_PCR, *PHALPROFILE_PCR;

#define HALPROFILE_PCR  ( (PHALPROFILE_PCR)(&(PCR->HalReserved[PROCESSOR_PROFILING_INDEX])) )

//
// Define space in the HAL-reserved part of the PCR structure for each
// performance counter's interval count
//
// Note that i64prfs.s depends on these positions in the PCR.
//

//
// Per-Processor Profiling Status
//

#define HalpProfilingRunning          HALPROFILE_PCR->ProfilingRunning

//
// Per-Processor registered Profiling Interrupt Handler
//

#define HalpProfilingInterruptHandler HALPROFILE_PCR->ProfilingInterruptHandler

//
// Per-Processor Profiling Interrupts Status
//

#define HalpProfilingInterrupts                  HALPROFILE_PCR->ProfilingInterrupts
#define HalpProfilingInterruptsWithoutProfiling  HALPROFILE_PCR->ProfilingInterruptsWithoutProfiling

//
// Define the currently selected profile source for each counter
//
// FIXFIX - Merced Specific.

#define HalpProfileSource4     (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[0]  // PMC4
#define HalpProfileSource5     (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[1]  // PMC5
#define HalpProfileSource6     (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[2]  // PMC6
#define HalpProfileSource7     (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[3]  // PMC7

__inline
VOID
HalpSetProfileSource( 
    ULONG           Pmcd,
    KPROFILE_SOURCE ProfileSource,
    ULONGLONG       ProfileSourceConfig
    )
{
    ULONG pmcdIdx;
ASSERTMSG("HAL!HalpSetProfileSource: invalid Pmcd!\n", ((Pmcd >= 4) && ((Pmcd <= 7))));
    pmcdIdx = Pmcd - PROCESSOR_IA64_PERFCOUNTERS_PAIRS;    
    (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[pmcdIdx] = ProfileSource;
    (KPROFILE_SOURCE)HALPROFILE_PCR->PerfCnfg[pmcdIdx]      = ProfileSourceConfig;

} // HalpSetProfileSource()

__inline
KPROFILE_SOURCE
HalpGetProfileSource(
    ULONG   Pmcd
    )
{
    ULONG pmcdIdx;
ASSERTMSG("HAL!HalpGetProfileSource: invalid Pmcd!\n", ((Pmcd >= 4) && ((Pmcd <= 7))));
    pmcdIdx = Pmcd - PROCESSOR_IA64_PERFCOUNTERS_PAIRS;    
    return (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[pmcdIdx];

} // HalpGetProfileSource()
            
#define HalpProfileCnfg4       (ULONGLONG)HALPROFILE_PCR->PerfCnfg[0]
#define HalpProfileCnfg5       (ULONGLONG)HALPROFILE_PCR->PerfCnfg[1]
#define HalpProfileCnfg6       (ULONGLONG)HALPROFILE_PCR->PerfCnfg[2]
#define HalpProfileCnfg7       (ULONGLONG)HALPROFILE_PCR->PerfCnfg[3]

#define PCRProfileData4        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfData[0])) )
#define PCRProfileData5        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfData[1])) )
#define PCRProfileData6        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfData[2])) )
#define PCRProfileData7        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfData[3])) )

#define PCRProfileCnfg4Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[0])) )
#define PCRProfileCnfg5Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[1])) )
#define PCRProfileCnfg6Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[2])) )
#define PCRProfileCnfg7Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[3])) )

#define PCRProfileData4Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[0])) )
#define PCRProfileData5Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfDataReload[1])) )
#define PCRProfileData6Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfDataReload[2])) )
#define PCRProfileData7Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfDataReload[3])) )

//
// IA64 Monitored Events have 
//

typedef enum _PMCD_SOURCE_MASK {
// FIXFIX - 04/2002: First implementation uses defines.
//                 : We should use ULONG union and bit fields for next version.
    PMCD_MASK_4    = 0x1,
    PMCD_MASK_5    = 0x2,
    PMCD_MASK_6    = 0x4,
    PMCD_MASK_7    = 0x8,
    PMCD_MASK_45   = (PMCD_MASK_4 | PMCD_MASK_5),
    PMCD_MASK_67   = (PMCD_MASK_6 | PMCD_MASK_7),
    PMCD_MASK_4567 = (PMCD_MASK_4 | PMCD_MASK_5 | PMCD_MASK_6 | PMCD_MASK_7),
//
// Source Sets definitions:
//
    PMCD_MASK_SET             = 0xffff0000,
    PMCD_MASK_SET_SHIFT       = 0x10,
    PMCD_MASK_SET_PMCD        = 0xff,
    PMCD_MASK_SET_PMCD_SHIFT  = 0x10,
    PMCD_MASK_SET_PMCD_4      = (4 << PMCD_MASK_SET_PMCD_SHIFT),
    PMCD_MASK_SET_PMCD_5      = (5 << PMCD_MASK_SET_PMCD_SHIFT),
    PMCD_MASK_SET_PMCD_6      = (6 << PMCD_MASK_SET_PMCD_SHIFT),
    PMCD_MASK_SET_PMCD_7      = (7 << PMCD_MASK_SET_PMCD_SHIFT),
    PMCD_MASK_SET_DATA_SHIFT  = 0x18,
    PMCD_MASK_SET_L0D_CACHE_0 = ((1  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_5),
    PMCD_MASK_SET_L0D_CACHE_1 = ((2  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_5), 
    PMCD_MASK_SET_L0D_CACHE_2 = ((3  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_5),
    PMCD_MASK_SET_L0D_CACHE_3 = ((4  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_5),
    PMCD_MASK_SET_L0D_CACHE_4 = ((5  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_5),
    PMCD_MASK_SET_L0D_CACHE_5 = ((6  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_5),
    PMCD_MASK_SET_L1_CACHE_0  = ((7  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_4),
    PMCD_MASK_SET_L1_CACHE_1  = ((8  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_4), 
    PMCD_MASK_SET_L1_CACHE_2  = ((9  << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_4),
    PMCD_MASK_SET_L1_CACHE_3  = ((10 << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_4),
    PMCD_MASK_SET_L1_CACHE_4  = ((11 << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_4),
    PMCD_MASK_SET_L1_CACHE_5  = ((12 << PMCD_MASK_SET_DATA_SHIFT) | PMCD_MASK_SET_PMCD_4),
} PMCD_SOURCE_MASK;

//
// Define the mapping between possible profile sources and the
// CPU-specific settings for the IA64 specific Event Counters.
//

typedef struct _HALP_PROFILE_MAPPING {
    BOOLEAN   Supported;
    ULONG     Event;
    ULONG     ProfileSource;
    ULONG     EventMask;
    ULONGLONG Interval;
    ULONGLONG IntervalDef;           // Default or Desired Interval
    ULONGLONG IntervalMax;           // Maximum Interval
    ULONGLONG IntervalMin;           // Maximum Interval
    UCHAR     PrivilegeLevel;        // Current            Privilege Level
    UCHAR     PrivilegeLevelDef;     // Default or Desired Privilege Level
    UCHAR     OverflowInterrupt;     // Current            Overflow Interrupt state
    UCHAR     OverflowInterruptDef;  // Default or Desired Overflow Interrupt state
    UCHAR     PrivilegeEnable;       // Current            Privilege Enable state
    UCHAR     PrivilegeEnableDef;    // Default or Desired Privilege Enable state
    UCHAR     UnitMask;              // Current            Event specific Unit Mask
    UCHAR     UnitMaskDef;           // Default or Desired Event specific Unit Mask
    UCHAR     Threshold;             // Current            Threshold
    UCHAR     ThresholdDef;          // Default or Desired Threshold for multi-occurence events.
    UCHAR     InstructionSetMask;    // Current            Instruction Set Mask
    UCHAR     InstructionSetMaskDef; // Default or Desired Instruction Set Mask
} HALP_PROFILE_MAPPING, *PHALP_PROFILE_MAPPING;

/////////////
//
// XXTF - ToBeDone - 02/08/2000.
// The following section should provide the IA64 PMC APIs.
// These should be considered as inline versions of the Halp*ProfileCounter*() 
// functions. This will allow user application to use standardized APIs to 
// program the performance monitor counters.
//

// HalpSetProfileCounterConfiguration()
// HalpSetProfileCounterPrivilegeLevelMask()

typedef enum _PMC_PLM_MASK {
    PMC_PLM_NONE = 0x0,
    PMC_PLM_0    = 0x1,
    PMC_PLM_1    = 0x2,
    PMC_PLM_2    = 0x4,
    PMC_PLM_3    = 0x8,
    PMC_PLM_ALL  = (PMC_PLM_3|PMC_PLM_2|PMC_PLM_1|PMC_PLM_0)
} PMC_PLM_MASK;

// HalpSetProfileCounterConfiguration()

typedef enum _PMC_NAMESPACE {
    PMC_DISABLE_OVERFLOW_INTERRUPT           = 0x0,
    PMC_ENABLE_OVERFLOW_INTERRUPT            = 0x1,
    PMC_DISABLE_PRIVILEGE_MONITOR            = 0x0,
    PMC_ENABLE_PRIVILEGE_MONITOR             = 0x1,
    PMC_UNIT_MASK_DEFAULT                    = 0x0,
    PMC_UNIT_MASK_RSEFILLS                   = 0x1,
    PMC_UNIT_MASK_INTANDFP_OPS               = 0x3,  // Ex: Specific umask for speculation events.
    PMC_UNIT_MASK_ALLTLBMISSES               = 0x3,  // Ex: Specific umask for tlb events.
    PMC_UNIT_MASK_L1TLBMISSES                = 0x1,  // Ex: Specific umask for tlb events.
    PMC_UNIT_MASK_L2TLBMISSES                = 0x2,  // Ex: Specific umask for tlb events.
    PMC_UNIT_MASK_IFETCH_BYPASS              = 0x2,  // Ex: Specific umask for inst. fetch cancels
    PMC_UNIT_MASK_IFETCH_STFILLWB            = 0x6,  // Ex: Specific umask for inst. fetch cancels
    PMC_UNIT_MASK_IFETCH_DATAREAD            = 0x7,  // Ex: Specific umask for inst. fetch cancels
    PMC_UNIT_MASK_L3ACCESS_ANY               = 0x9,  // Ex: Specific umask for L3 accesses cancels
    PMC_UNIT_MASK_L2_DATA_RDWR               = 0x3,  // Ex: Specific umask for L2 data references
    PMC_UNIT_MASK_L2_DATA_READ               = 0x1,  // Ex: Specific umask for L2 data references
    PMC_UNIT_MASK_L2_DATA_WRITE              = 0x2,  // Ex: Specific umask for L2 data references
    PMC_UNIT_MASK_L2_DATA_BYPASS_L1DTOL2A    = 0x0,  // Ex: Specific umask for L2 bypasses
    PMC_UNIT_MASK_L2_DATA_BYPASS_L1WTOL2I    = 0x1,  // Ex: Specific umask for L2 bypasses
    PMC_UNIT_MASK_L3_DATA_BYPASS_L1DTOL2A    = 0x2,  // Ex: Specific umask for L2 bypasses
    PMC_UNIT_MASK_L2_INST_BYPASS_L1DTOL2A    = 0x4,  // Ex: Specific umask for L2 bypasses
    PMC_UNIT_MASK_L2_INST_BYPASS_L1WTOL2I    = 0x5,  // Ex: Specific umask for L2 bypasses
    PMC_UNIT_MASK_L3_INST_BYPASS_L1DTOL2A    = 0x6,  // Ex: Specific umask for L2 bypasses
    PMC_UNIT_MASK_EVENT_SELECTED_LOSET       = 0x0,  
    PMC_UNIT_MASK_EVENT_SELECTED_HISET       = 0x8,  
    PMC_UNIT_MASK_L2_INT_LOADS               = 0x8,  // Ex: Specific umask for L2 operation types
    PMC_UNIT_MASK_L2_FP_LOADS                = 0x9,  // Ex: Specific umask for L2 operation types
    PMC_UNIT_MASK_L2_RMW_STORES              = 0xa,  // Ex: Specific umask for L2 operation types
    PMC_UNIT_MASK_L2_NON_RMW_STORES          = 0xb,  // Ex: Specific umask for L2 operation types
    PMC_UNIT_MASK_L2_NONLOADS_NONSTORES      = 0xc,  // Ex: Specific umask for L2 operation types
    PMC_UNIT_MASK_L3_READS_HITS              = 0xd,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_READS_MISSES            = 0xe,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_READS_IFETCH_REFERENCES = 0x7,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_READS_IFETCH_HITS       = 0x5,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_READS_IFETCH_MISSES     = 0x6,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_READS_DATA_HITS         = 0x9,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_READS_DATA_MISSES       = 0xa,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_READS_DATA_REFERENCES   = 0xb,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_WRITES_HITS             = 0xd,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_WRITES_MISSES           = 0xe,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_WRITES_DATA_REFERENCES  = 0x7,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_WRITES_DATA_HITS        = 0x5,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_WRITES_DATA_MISSES      = 0x6,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_WRITEBACK_HITS          = 0x9,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_WRITEBACK_MISSES        = 0xa,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_L3_WRITEBACK_REFERENCES    = 0xb,  // Ex: Specific umask for L3 reads
    PMC_UNIT_MASK_BUS_ANY                    = 0x3,  // Ex: Specific umask for BUS transactions
    PMC_UNIT_MASK_BUS_BYSELF                 = 0x2,  // Ex: Specific umask for BUS transactions
    PMC_UNIT_MASK_BUS_NONPRI_AGENT           = 0x1,  // Ex: Specific umask for BUS transactions
    PMC_UNIT_MASK_BUS_MEMORY_ALL             = 0xc,  // Ex: Specific umask for BUS transactions
    PMC_UNIT_MASK_BUS_MEMORY_128BYTE         = 0x4,  // Ex: Specific umask for BUS transactions
    PMC_UNIT_MASK_BUS_MEMORY_LTH_128BYTE     = 0x8,  // Ex: Specific umask for BUS transactions
    PMC_UNIT_MASK_BUS_MEMORY_READS_ALL       = 0xc,  // Ex: Specific umask for BUS reads
    PMC_UNIT_MASK_BUS_MEMORY_BIL             = 0x0,  // Ex: Specific umask for BUS reads
    PMC_UNIT_MASK_BUS_MEMORY_BRL             = 0x4,  // Ex: Specific umask for BUS reads
    PMC_UNIT_MASK_BUS_MEMORY_BRIL            = 0x8,  // Ex: Specific umask for BUS reads
    PMC_UNIT_MASK_BUS_WB_ALL                 = 0xf,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_WB_BYSELF              = 0xe,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_WB_NONPRI_AGENT        = 0xd,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_WB_BURST_ALL           = 0x7,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_WB_BURST_BYSELF        = 0x6,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_WB_BURST_NONPRI_AGENT  = 0x5,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_WB_ZEROBYTE_ALL        = 0x7,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_WB_ZEROBYTE_BYSELF     = 0x6,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_SNOOPS_ALL             = 0xf,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_SNOOPS_BYSELF          = 0xe,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_BUS_SNOOPS_NONPRI_AGENT    = 0xd,  // Ex: Specific umask for BUS writebacks
    PMC_UNIT_MASK_RSE_LOADS                  = 0x1,  // Ex: Specific umask for RSE accesses
    PMC_UNIT_MASK_RSE_STORES                 = 0x2,  // Ex: Specific umask for RSE accesses
    PMC_UNIT_MASK_RSE_LOAD_UNDERFLOWS        = 0x4,  // Ex: Specific umask for RSE accesses
    PMC_UNIT_MASK_ALL                        = 0xf,
    PMC_THRESHOLD_DEFAULT                    = 0x0,
} PMC_NAMESPACE;

// HalpSetProfileCounterConfiguration()
// HalpSetProfileCounterInstructionSetMask()

typedef enum _PMC_INSTRUCTION_SET_MASK {
    PMC_ISM_ALL  = 0x0,
    PMC_ISM_IA64 = 0x1,
    PMC_ISM_IA32 = 0x2,
    PMC_ISM_NONE = 0x3
} PMC_INSTRUCTION_SET_MASK;

//
////////////

/////////////
//
// The following section provides IA64 PMU Events Masks definitions.
// Microarchitectural definitions are defined in processor specific header file.
//

//
// BranchPathPrediction - Branch Path Mask 
//
// not really a mask, more a specification value.
//

typedef enum _BRANCH_PATH_RESULT_MASK {
    MISPRED_NT       = 0x0,
    MISPRED_TAKEN    = 0x1,
    OKPRED_NT        = 0x2,
    OKPRED_TAKEN     = 0x3,
} BRANCH_PATH_RESULT_MASK;

//
// BranchTakenDetail - Slot Unit Mask.
//

typedef enum _BRANCH_TAKEN_DETAIL_SLOT_MASK {
    INSTRUCTION_SLOT0  = 0x1,
    INSTRUCTION_SLOT1  = 0x2,
    INSTRUCTION_SLOT2  = 0x4,
    NOT_TAKEN_BRANCH   = 0x8
} BRANCH_TAKEN_DETAIL_SLOT_MASK;

//
// BranchMultiWayDetail   - Prediction OutCome Mask
//
// not really a mask, more a specification value.
//

typedef enum _BRANCH_DETAIL_PREDICTION_OUTCOME_MASK {
    ALL_PREDICTIONS    = 0x0,
    CORRECT_PREDICTION = 0x1,
    WRONG_PATH         = 0x2,
    WRONG_TARGET       = 0x3
} BRANCH_MWAY_DETAIL_PREDICTION_OUTCOME_MASK;

//
// BranchMultiWayDetail - Branch Path Mask
//
// not really a mask, more a specification value.
//

typedef enum _BRANCH_MWAY_DETAIL_BRANCH_PATH_MASK {
    NOT_TAKEN       = 0x0,
    TAKEN           = 0x1,
    ALL_PATH        = 0x2
} BRANCH_MWAY_DETAIL_BRANCH_PATH_MASK;

//
// INST_TYPE for:
//
// FailedSpeculativeCheckLoads
// AdvancedCheckLoads
// FailedAdvancedCheckLoads
// ALATOverflows
//

typedef enum _SPECULATION_EVENT_MASK {
    NONE    = 0x0,
    INTEGER = 0x1,
    FP      = 0x2,
    ALL     = 0x3
} SPECULATION_EVENT_MASK;

//
// CpuCycles - Executing Instruction Set
//

typedef enum _CPU_CYCLES_MODE_MASK {
    ALL_MODES = 0x0,
    IA64_MODE = 0x1,
    IA32_MODE = 0x2
} CPU_CYCLES_MODE_MASK;

//
////////////


#endif /* IA64PROF_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixhalt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixhalt.c

Abstract:

    Implements various ACPI utility functions.

Author:

	Todd Kjos (HP) (v-tkjos) 15-Jun-1998

	Based on i386 version by Jake Oshins (jakeo) 12-Feb-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include <inbv.h>

extern ULONG_PTR     KiBugCheckData[];
SLEEP_STATE_CONTEXT  HalpShutdownContext;


VOID
HaliHaltSystem (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine has crashed and is to be
        halted

    N.B.

        Will NOT return.

--*/
{
#ifndef IA64
    for (; ;) {
        HalpCheckPowerButton();
        HalpYieldProcessor();
    }
#else
	HalDebugPrint(( HAL_ERROR, "HAL: HaliHaltSystem called -- in tight loop\n" ));
	for (;;) {}
#endif
}


VOID
HalpCheckPowerButton (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine is spinning in the debugger,
    or has crashed and halted.

--*/
{
    USHORT                  Pm1Status, Pm1Control;
    SLEEP_STATE_CONTEXT     ShutdownContext;

    //
    // If there's been a bugcheck, or if the hal owns the display check
    // the fixed power button for an unconditional power off
    //

    if ((KiBugCheckData[0] || InbvCheckDisplayOwnership()) &&  HalpShutdownContext.AsULONG) {

        Pm1Status = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_evt_blk);
        if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
            Pm1Status |= (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1b_evt_blk);
        }

        //
        // If the fixed button has been pushed, power off the system
        //

        if (Pm1Status & PM1_PWRBTN_STS) {
            //
            // Only do this once
            //

            ShutdownContext = HalpShutdownContext;
            HalpShutdownContext.AsULONG = 0;

            //
            // Disable & eoi all wake events
            //

            AcpiEnableDisableGPEvents(FALSE);
            HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1a_evt_blk, Pm1Status);
            if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
                HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_evt_blk, Pm1Status);
            }

            //
            // Power off
            //

            Pm1Control = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk);
            Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | (ShutdownContext.bits.Pm1aVal << SLP_TYP_SHIFT) | SLP_EN);
            HalpWriteGenAddr (&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk, Pm1Control);

            if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
                Pm1Control = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk);
                Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | (ShutdownContext.bits.Pm1bVal << SLP_TYP_SHIFT) | SLP_EN);
                HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk, Pm1Control);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixisabus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixisabus.c

Abstract:

Author:

Environment:

Revision History:


--*/

#include "halp.h"

BOOLEAN
HalpTranslateIsaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpTranslateEisaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpTranslateSystemBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalIrqTranslateResourceRequirementsIsa)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesIsa)
#endif


NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
)
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourceRequirementsRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    PIO_RESOURCE_DESCRIPTOR modSource, target, rootTarget;
    NTSTATUS                status;
    BOOLEAN                 picSlaveDeleted = FALSE;
    BOOLEAN                 deleteResource;
    ULONG                   sourceCount = 0;
    ULONG                   targetCount = 0;
    ULONG                   resource;
    ULONG                   rootCount;
    ULONG                   invalidIrq;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    modSource = ExAllocatePoolWithTag(
                    NonPagedPool,

    //
    // we will have at most nine ranges when we are done
    //
                    sizeof(IO_RESOURCE_DESCRIPTOR) * 9,
                    HAL_POOL_TAG
                    );

    if (!modSource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modSource, sizeof(IO_RESOURCE_DESCRIPTOR) * 9);

    //
    // Is the PIC_SLAVE_IRQ in this resource?
    //
    if ((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_IRQ) &&
        (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_IRQ)) {

        //
        // Clip the maximum
        //

        if (Source->u.Interrupt.MinimumVector < PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                Source->u.Interrupt.MinimumVector;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                PIC_SLAVE_IRQ - 1;

            sourceCount++;
        }

        //
        // Clip the minimum
        //

        if (Source->u.Interrupt.MaximumVector > PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                Source->u.Interrupt.MaximumVector;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                PIC_SLAVE_IRQ + 1;

            sourceCount++;
        }

        //
        // In ISA machines, the PIC_SLAVE_IRQ is rerouted
        // to PIC_SLAVE_REDIRECT.  So find out if PIC_SLAVE_REDIRECT
        // is within this list. If it isn't we need to add it.
        //

        if (!((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_REDIRECT) &&
             (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_REDIRECT))) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector=PIC_SLAVE_REDIRECT;
            modSource[sourceCount].u.Interrupt.MaximumVector=PIC_SLAVE_REDIRECT;

            sourceCount++;
        }

    } else {

        *modSource = *Source;
        sourceCount = 1;
    }

    //
    // Now that the PIC_SLAVE_IRQ has been handled, we have
    // to take into account IRQs that may have been steered
    // away to the PCI bus.
    //
    // N.B.  The algorithm used below may produce resources
    // with minimums greater than maximums.  Those will
    // be stripped out later.
    //

    for (invalidIrq = 0; invalidIrq < PIC_VECTORS; invalidIrq++) {

        //
        // Look through all the resources, possibly removing
        // this IRQ from them.
        //
        for (resource = 0; resource < sourceCount; resource++) {

            deleteResource = FALSE;

            if (HalpPciIrqMask & (1 << invalidIrq)) {

                //
                // This IRQ belongs to the PCI bus.
                //

                if (!((HalpBusType == MACHINE_TYPE_EISA) &&
                      ((modSource[resource].Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)))) {

                    //
                    // And this resource is not an EISA-style,
                    // level-triggered interrupt.
                    //
                    // N.B.  Only the system BIOS truely knows
                    //       whether an IRQ on a PCI bus can be
                    //       shared with an IRQ on an ISA bus.
                    //       This code assumes that, in the case
                    //       that the BIOS set an EISA device to
                    //       the same interrupt as a PCI device,
                    //       the machine can actually function.
                    //
                    deleteResource = TRUE;
                }
            }

            if (deleteResource) {

                if (modSource[resource].u.Interrupt.MinimumVector == invalidIrq) {

                    modSource[resource].u.Interrupt.MinimumVector++;

                } else if (modSource[resource].u.Interrupt.MaximumVector == invalidIrq) {

                    modSource[resource].u.Interrupt.MaximumVector--;

                } else if ((modSource[resource].u.Interrupt.MinimumVector < invalidIrq) &&
                    (modSource[resource].u.Interrupt.MaximumVector > invalidIrq)) {

                    //
                    // Copy the current resource into a new resource.
                    //
                    modSource[sourceCount] = modSource[resource];

                    //
                    // Clip the current resource to a range below invalidIrq.
                    //
                    modSource[resource].u.Interrupt.MaximumVector = invalidIrq - 1;

                    //
                    // Clip the new resource to a range above invalidIrq.
                    //
                    modSource[sourceCount].u.Interrupt.MinimumVector = invalidIrq + 1;

                    sourceCount++;
                }
            }
        }
    }


    target = ExAllocatePoolWithTag(PagedPool,
                                   sizeof(IO_RESOURCE_DESCRIPTOR) * sourceCount,
                                   HAL_POOL_TAG
                                   );

    if (!target) {
        ExFreePool(modSource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now send each of these ranges through
    // HalIrqTranslateResourceRequirementsRoot.
    //

    for (resource = 0; resource < sourceCount; resource++) {

        //
        // Skip over resources that we have previously
        // clobbered (while deleting PCI IRQs.)
        //

        if (modSource[resource].u.Interrupt.MinimumVector >
            modSource[resource].u.Interrupt.MaximumVector) {

            continue;
        }

        status = HalIrqTranslateResourceRequirementsRoot(
                    Context,
                    &modSource[resource],
                    PhysicalDeviceObject,
                    &rootCount,
                    &rootTarget
                    );

        if (!NT_SUCCESS(status)) {
            ExFreePool(target);
            goto HalIrqTranslateResourceRequirementsIsaExit;
        }

        //
        // HalIrqTranslateResourceRequirementsRoot should return
        // either one resource or, occasionally, zero.
        //

        ASSERT(rootCount <= 1);

        if (rootCount == 1) {

            target[targetCount] = *rootTarget;
            targetCount++;
            ExFreePool(rootTarget);
        }
    }

    *TargetCount = targetCount;

    if (targetCount > 0) {

        *Target = target;

    } else {

        ExFreePool(target);
    }

    status = STATUS_TRANSLATION_COMPLETE;

HalIrqTranslateResourceRequirementsIsaExit:

    ExFreePool(modSource);
    return status;
}

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourcesRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    CM_PARTIAL_RESOURCE_DESCRIPTOR modSource;
    NTSTATUS    status;
    BOOLEAN     usePicSlave = FALSE;
    ULONG       i;


    modSource = *Source;

    if (Direction == TranslateChildToParent) {

        if (Source->u.Interrupt.Vector == PIC_SLAVE_IRQ) {
            modSource.u.Interrupt.Vector = PIC_SLAVE_REDIRECT;
            modSource.u.Interrupt.Level = PIC_SLAVE_REDIRECT;
        }
    }

    status = HalIrqTranslateResourcesRoot(
                Context,
                &modSource,
                Direction,
                AlternativesCount,
                Alternatives,
                PhysicalDeviceObject,
                Target);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (Direction == TranslateParentToChild) {

        //
        // Because the ISA interrupt controller is
        // cascaded, there is one case where there is
        // a two-to-one mapping for interrupt sources.
        // (On a PC, both 2 and 9 trigger vector 9.)
        //
        // We need to account for this and deliver the
        // right value back to the driver.
        //

        if (Target->u.Interrupt.Level == PIC_SLAVE_REDIRECT) {

            //
            // Search the Alternatives list.  If it contains
            // PIC_SLAVE_IRQ but not PIC_SLAVE_REDIRECT,
            // we should return PIC_SLAVE_IRQ.
            //

            for (i = 0; i < AlternativesCount; i++) {

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_REDIRECT) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_REDIRECT)) {

                    //
                    // The list contains, PIC_SLAVE_REDIRECT.  Stop
                    // looking.
                    //

                    usePicSlave = FALSE;
                    break;
                }

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_IRQ) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_IRQ)) {

                    //
                    // The list contains, PIC_SLAVE_IRQ.  Use it
                    // unless we find PIC_SLAVE_REDIRECT later.
                    //

                    usePicSlave = TRUE;
                }
            }

            if (usePicSlave) {

                Target->u.Interrupt.Level  = PIC_SLAVE_IRQ;
                Target->u.Interrupt.Vector = PIC_SLAVE_IRQ;
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixisa.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixisa.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    EISA/ISA specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91

Revision History:

--*/

#ifndef _IXISA_
#define _IXISA_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_ISA_MAP_BUFFER_SIZE      0x40000
#define MAXIMUM_MAP_BUFFER_SIZE          MAXIMUM_ISA_MAP_BUFFER_SIZE

//
// MAXIMUM_PCI_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for 32-bit PCI devices on a 64-bit system.
//

#define MAXIMUM_PCI_MAP_BUFFER_SIZE  (64 * 1024 * 1024)

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_SMALL_SIZE 0x10000

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_LARGE_SIZE 0x30000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

#define MAXIMUM_PCI_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card
//

#define MAXIMUM_PHYSICAL_ADDRESS 0xffffffff

//
// Define the scatter/gather flag for the Map Register Base.
//

#define NO_SCATTER_GATHER 0x00000001

//
// Define the copy buffer flag for the index.
//

#define COPY_BUFFER 0XFFFFFFFF

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    DMA_ADAPTER DmaHeader;
    struct _ADAPTER_OBJECT *MasterAdapter;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    ULONG CommittedMapRegisters;
    struct _WAIT_CONTEXT_BLOCK *CurrentWcb;
    KDEVICE_QUEUE ChannelWaitQueue;
    PKDEVICE_QUEUE RegisterWaitQueue;
    LIST_ENTRY AdapterQueue;
    KSPIN_LOCK SpinLock;
    PRTL_BITMAP MapRegisters;
    PUCHAR PagePort;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    USHORT DmaPortAddress;
    UCHAR AdapterMode;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN ScatterGather;
    BOOLEAN IgnoreCount;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN Dma64BitAddresses;
} ADAPTER_OBJECT;

ULONG 
HalGetDmaAlignment (
    PVOID Conext
    );

NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    );

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    );


NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapaterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );

NTSTATUS
HalpAllocateMapRegisters(
    IN PADAPTER_OBJECT DmaAdapter,
    IN ULONG NumberOfMapRegisters,
    IN ULONG BaseAddressCount,
    OUT PMAP_REGISTER_ENTRY MapRegisterArray
    );

PHYSICAL_ADDRESS
__inline
HalpGetAdapterMaximumPhysicalAddress(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine determines and returns the maximum physical address that
    can be accessed by the given adapter.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

Return Value:

    Returns the maximum physical address that can be accessed by this
        device.

--*/

{
    PHYSICAL_ADDRESS maximumAddress;

    //
    // Assume the device requires physical addresses 2GB.
    //

    maximumAddress.HighPart = 0;
    maximumAddress.LowPart = MAXIMUM_PHYSICAL_ADDRESS - 1;

    //
    // IoMapTransfer() is sometimes called with a NULL adapter object.  In
    // this case, assume the adapter is 32 bit.
    //

    if (AdapterObject == NULL) {
        return maximumAddress;
    }

    if (AdapterObject->MasterDevice) {

        if (AdapterObject->Dma64BitAddresses) {

            //
            // This device is a master and can handle 64 bit addresses.
            //

            maximumAddress.QuadPart = (ULONGLONG)-1;

        } else if(AdapterObject->Dma32BitAddresses) {

            //
            // This device is a master and can handle 32 bit addresses.
            //

            maximumAddress.LowPart = (ULONG)-1;
        }
    }

    return maximumAddress;
}


#endif // _IXISA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\iosapic.h ===
/*++

Module Name:

   iosapic.h

Abstract:

   This module contains the definitions used by HAL to manipulate
   the IO SAPIC interrupt controller and SAPIC-specific constants.

Author:

   Todd Kjos (v-tkjos) 1-30-98

Environment:

   Kernel mode only.

Revision History:

--*/

#define STATIC

#include "halp.h"
#include "acpitabl.h"

//
// MPS INTi Flags related macros:
//
// Warning: these definitions do not consider the POLARITY or EL comformity with bus.
//

#define IS_LEVEL_TRIGGERED_MPS(vectorFlags) \
    ((vectorFlags & EL_LEVEL_TRIGGERED) == EL_LEVEL_TRIGGERED)

#define IS_EDGE_TRIGGERED_MPS(vectorFlags) \
    ((vectorFlags & EL_EDGE_TRIGGERED) == EL_EDGE_TRIGGERED)

#define IS_ACTIVE_LOW_MPS(vectorFlags) \
    ((vectorFlags & POLARITY_LOW) == POLARITY_LOW)

#define IS_ACTIVE_HIGH_MPS(vectorFlags) \
    ((vectorFlags & POLARITY_HIGH) == POLARITY_HIGH)

typedef struct {
    ULONG GlobalVector;     // This is Node+IDT vector value seen by kernel
    ULONG Vector;           // Bits 31:0 of the Rte entry (IDT vector+polarity...)
    ULONG Destination;      // Bits 63:32 of Rte entry
} IOSAPICINTI, *PIOSAPICINTI;

typedef struct _INTR_METHODS INTR_METHODS, *PINTR_METHODS;

typedef struct _IO_INTR_CONTROL IO_INTR_CONTROL, *PIO_INTR_CONTROL;

typedef VOID (*PINTRMETHOD) (PIO_INTR_CONTROL,ULONG);
typedef volatile ULONG * (*PGETEOI) (PIO_INTR_CONTROL);

struct _INTR_METHODS {
    PINTRMETHOD MaskEntry;
    PINTRMETHOD SetEntry;
    PINTRMETHOD EnableEntry;
};

//
// External interrupt controller structure.
//
struct _IO_INTR_CONTROL {
    ULONG IntiBase;
    ULONG IntiMax;
    ULONG InterruptAffinity;
    PVOID RegBaseVirtual;
    PHYSICAL_ADDRESS RegBasePhysical;
    PINTR_METHODS IntrMethods;
    PIO_INTR_CONTROL flink;
    USHORT FreeVectors[16];
    IOSAPICINTI Inti[ANYSIZE_ARRAY];
};

extern struct _MPINFO HalpMpInfo;
extern PIO_INTR_CONTROL HalpIoSapicList;
extern INTR_METHODS HalpIoSapicMethods;

//
//  IO Unit definition
//
typedef struct {
    volatile ULONG RegisterSelect;  // Write register number to access register
    volatile ULONG Reserved1[3];
    volatile ULONG RegisterWindow;  // Data read/written here
    volatile ULONG Reserved2[3];
    volatile ULONG Reserved3[8];
    volatile ULONG Eoi;             // EOI register for level triggered interrupts
} IO_SAPIC_REGS, *PIO_SAPIC_REGS;

//
//  IO SAPIC Version Register
//

struct SapicVersion {
    UCHAR Version;              // either 0.x or 1.x
    UCHAR Reserved1;
    UCHAR MaxRedirEntries;      // Number of INTIs on unit
    UCHAR Reserved2;
};

typedef struct SapicVersion SAPIC_VERSION, *PSAPIC_VERSION;

BOOLEAN
HalpGetSapicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PULONG SapicInti,
    OUT PKAFFINITY InterruptAffinity
    );

VOID
HalpGetFreeVectors(
    IN  ULONG InterruptInput,
    OUT PUSHORT *FreeVectors
    );

VOID
HalpSetVectorAllocated(
    IN  ULONG InterruptInput,
    IN  UCHAR Vector
    );

VOID
HalpEnableRedirEntry(
    ULONG Inti
    );

VOID
HalpDisableRedirEntry(
    ULONG Inti
    );

VOID
HalpWriteRedirEntry (
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags,
    IN ULONG  InterruptType
    );

BOOLEAN
HalpIsActiveLow(
    ULONG Inti
    );

BOOLEAN
HalpIsLevelTriggered(
    ULONG Inti
    );

VOID
HalpSetPolarity(
    ULONG Inti,
    BOOLEAN ActiveLow
    );

VOID
HalpSetLevel(
    ULONG Inti,
    BOOLEAN LevelTriggered
    );

//
// I/O SAPIC defines
//

#define IO_REGISTER_SELECT      0x00000000
#define IO_REGISTER_WINDOW      0x00000010
#define IO_EOI_REGISTER         0x00000040

#define IO_ID_REGISTER          0x00000000  // Exists, but ignored by SAPIC
#define IO_VERS_REGISTER        0x00000001
#define IO_REDIR_00_LOW         0x00000010
#define IO_REDIR_00_HIGH        0x00000011

#define IO_MAX_REDIR_MASK       0x00FF0000
#define IO_VERSION_MASK         0x000000FF

#define SAPIC_ID_MASK           0xFF000000
#define SAPIC_ID_SHIFT          24
#define SAPIC_EID_MASK          0x00FF0000
#define SAPIC_EID_SHIFT         16
#define SAPIC_XID_MASK          0xFFFF0000
#define SAPIC_XID_SHIFT         16

#define INT_VECTOR_MASK         0x000000FF
#define DELIVER_FIXED           0x00000000
#define DELIVER_LOW_PRIORITY    0x00000100
#define DELIVER_SMI             0x00000200
#define DELIVER_NMI             0x00000400
#define DELIVER_INIT            0x00000500
#define DELIVER_EXTINT          0x00000700
#define INT_TYPE_MASK           0x00000700
#define ACTIVE_LOW              0x00002000
#define ACTIVE_HIGH             0x00000000
#define LEVEL_TRIGGERED         0x00008000
#define EDGE_TRIGGERED          0x00000000
#define INTERRUPT_MASKED        0x00010000
#define INTERRUPT_MOT_MASKED    0x00000000

#define MAX_INTR_VECTOR 256
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixhwsup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "halpnpp.h"
#include "mca.h"


#define HAL_WCB_DRIVER_BUFFER    1

typedef struct _HAL_WAIT_CONTEXT_BLOCK {
    ULONG Flags;
    PMDL Mdl;
    PMDL DmaMdl;
    PVOID MapRegisterBase;
    PVOID CurrentVa;
    ULONG Length;
    ULONG NumberOfMapRegisters;
    union {
        struct {
            WAIT_CONTEXT_BLOCK Wcb;
            PDRIVER_LIST_CONTROL DriverExecutionRoutine;
            PVOID DriverContext;
            PIRP CurrentIrp;
            PADAPTER_OBJECT AdapterObject;
            BOOLEAN WriteToDevice;
        };

        SCATTER_GATHER_LIST ScatterGather;
    };
} HAL_WAIT_CONTEXT_BLOCK, *PHAL_WAIT_CONTEXT_BLOCK;


IO_ALLOCATION_ACTION
HalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

static KSPIN_LOCK HalpReservedPageLock;
static PVOID      HalpReservedPages = NULL;
static PFN_NUMBER HalpReservedPageMdl[(sizeof(MDL)/sizeof(PFN_NUMBER)) + 2];

extern KEVENT HalpNewAdapter;

#define ACQUIRE_NEW_ADAPTER_LOCK()  \
{                                   \
    KeWaitForSingleObject (         \
        &HalpNewAdapter,            \
        WrExecutive,                \
        KernelMode,                 \
        FALSE,                      \
        NULL                        \
        );                          \
}

#define RELEASE_NEW_ADAPTER_LOCK()  \
    KeSetEvent (&HalpNewAdapter, 0, FALSE)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpAllocateMapRegisters)
#endif


VOID
HalpInitReservedPages(
    VOID
    )
/*++

Routine Description:

    Back pocket some PTEs so we can make forward progress during low
    memory conditions

Aruments:

    None

Reurn Value:

    None

--*/
{
    PMDL Mdl;

    HalpReservedPages = MmAllocateMappingAddress(PAGE_SIZE, HAL_POOL_TAG);

    ASSERT(HalpReservedPages);

    Mdl = (PMDL)&HalpReservedPageMdl;
    MmInitializeMdl(Mdl, NULL, PAGE_SIZE);
    Mdl->MdlFlags |= MDL_PAGES_LOCKED;

    KeInitializeSpinLock(&HalpReservedPageLock);
}


VOID
HalpCopyBufferMapSafe(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This routine copies the specific data between an unmapped user buffer
    and the map register buffer.  We will map and unmap each page of the
    transfer using our emergency reserved mapping

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
          being read or written.

    TranslationEntry - The address of the base map register that has been
                       allocated to the device driver for use in mapping
                       the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
                that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
             registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
                    to the device from memory (TRUE), or vice versa.

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    PCCHAR bufferAddress;
    PCCHAR mapAddress;
    ULONG bytesLeft;
    ULONG bytesThisCopy;
    ULONG bufferPageOffset;
    PTRANSLATION_ENTRY translationEntry;
    KIRQL Irql;
    PMDL ReserveMdl;
    MEMORY_CACHING_TYPE MCFlavor;
    PPFN_NUMBER SrcPFrame;
    PPFN_NUMBER ReservePFrame;

    //
    // Synchronize access to our reserve page data structures
    //
    KeAcquireSpinLock(&HalpReservedPageLock, &Irql);

    //
    // Get local copies of Length and TranslationEntry as they will be
    // decremented/incremented respectively
    //
    bytesLeft = Length;
    translationEntry = TranslationEntry;

    //
    // Find the PFN in our caller's MDL that describes the first page in
    // physical memory that we need to access
    //
    SrcPFrame = (PPFN_NUMBER)(Mdl + 1);
    SrcPFrame += (((UINT_PTR)CurrentVa - (UINT_PTR)MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT);

    //
    // Initialize our reserve MDL's StartVa and ByteOffset
    //
    ReserveMdl = (PMDL)&HalpReservedPageMdl;
    ReservePFrame = (PPFN_NUMBER)(ReserveMdl + 1);
    ReserveMdl->StartVa = (PVOID)PAGE_ALIGN(CurrentVa);
    ReserveMdl->ByteOffset = BYTE_OFFSET(CurrentVa);
    ReserveMdl->ByteCount = PAGE_SIZE - ReserveMdl->ByteOffset;

    //
    // Copy the data one translation entry at a time.
    //
    while (bytesLeft > 0) {

        //
        // Copy current source PFN into our reserve MDL
        //      
        *ReservePFrame = *SrcPFrame;

        //
        // Enumerate thru cache flavors until we get our reserve mapping
        //
        bufferAddress = NULL;
        for (MCFlavor = MmNonCached;
             MCFlavor < MmMaximumCacheType;
             MCFlavor++) {
            
            bufferAddress =
                MmMapLockedPagesWithReservedMapping(HalpReservedPages,
                                                    HAL_POOL_TAG,
                                                    ReserveMdl,
                                                    MCFlavor);
            if (bufferAddress != NULL) {
                break;
            }
        }
        
        //
        // Could not establish a reserve mapping, we're totally screwed!
        //
        if (bufferAddress == NULL) {
            KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                         PAGE_SIZE,
                         0xEF02,
                         (ULONG_PTR)__FILE__,
                         __LINE__
                         );
        }

        //
        // Find the buffer offset within the page
        //
        // N.B. bufferPageOffset can only be non-zero on the first iteration
        //
        bufferPageOffset = BYTE_OFFSET(bufferAddress);

        //
        // Copy from bufferAddress up to the next page boundary...
        //
        bytesThisCopy = PAGE_SIZE - bufferPageOffset;

        //
        // ...but no more than bytesLeft.
        //
        if (bytesThisCopy > bytesLeft) {
            bytesThisCopy = bytesLeft;
        }

        //
        // Calculate the base address of this translation entry and the
        // offset into it
        //
        mapAddress = (PCCHAR) translationEntry->VirtualAddress +
            bufferPageOffset;

        //
        // Copy up to one page
        //
        if (WriteToDevice) {
            RtlMoveMemory( mapAddress, bufferAddress, bytesThisCopy );

        } else {
            RtlMoveMemory( bufferAddress, mapAddress, bytesThisCopy );
        }

        //
        // Update locals and process the next translation entry
        //
        bytesLeft -= bytesThisCopy;
        translationEntry += 1;
        MmUnmapReservedMapping(HalpReservedPages, HAL_POOL_TAG, ReserveMdl);
        SrcPFrame++;
        ReserveMdl->ByteOffset = 0;
        (PCCHAR)ReserveMdl->StartVa += PAGE_SIZE;
        ReserveMdl->ByteCount = (PAGE_SIZE > bytesLeft) ? bytesLeft: PAGE_SIZE;
    }

    KeReleaseSpinLock(&HalpReservedPageLock, Irql);
}


VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine copies the specific data between the user's buffer and the
    map register buffer.  First a the user buffer is mapped if necessary, then
    the data is copied.  Finally the user buffer will be unmapped if
    necessary.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    TranslationEntry - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None.

--*/
{
    PCCHAR bufferAddress;
    PCCHAR mapAddress;
    ULONG bytesLeft;
    ULONG bytesThisCopy;
    ULONG bufferPageOffset;
    PTRANSLATION_ENTRY translationEntry;
    
    //
    // Get the system address of the MDL, if we run out of PTEs try safe
    // method
    //
    bufferAddress = MmGetSystemAddressForMdlSafe(Mdl, HighPagePriority);
    
    if (bufferAddress == NULL) {
                                                                 
        //
        // Our caller's buffer is unmapped, and the memory manager is out
        // of PTEs, try to use reserve page method
        //
        if (HalpReservedPages != NULL) {
            HalpCopyBufferMapSafe(Mdl,
                                  TranslationEntry,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice);
            return;
        }

        //
        // The DMA transfer cannot be completed, the system is now unstable
        //
        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     PAGE_SIZE,
                     0xEF01,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    //
    // Calculate the actual start of the buffer based on the system VA and
    // the current VA.
    //

    bufferAddress += (PCCHAR) CurrentVa - (PCCHAR) MmGetMdlVirtualAddress(Mdl);

    //
    // Get local copies of Length and TranslationEntry as they will be
    // decremented/incremented respectively.
    //

    bytesLeft = Length;
    translationEntry = TranslationEntry;

    //
    // Copy the data one translation entry at a time.
    //

    while (bytesLeft > 0) {

        //
        // Find the buffer offset within the page.
        //
        // N.B. bufferPageOffset can only be non-zero on the first iteration.
        // 

        bufferPageOffset = BYTE_OFFSET(bufferAddress);

        //
        // Copy from bufferAddress up to the next page boundary...
        //

        bytesThisCopy = PAGE_SIZE - bufferPageOffset;

        //
        // ...but no more than bytesLeft.
        //

        if (bytesThisCopy > bytesLeft) {
            bytesThisCopy = bytesLeft;
        }

        //
        // Calculate the base address of this translation entry and the
        // offset into it.
        //

        mapAddress = (PCCHAR) translationEntry->VirtualAddress +
            bufferPageOffset;

        //
        // Copy up to one page.
        // 

        if (WriteToDevice) {

            RtlMoveMemory( mapAddress, bufferAddress, bytesThisCopy );

        } else {

            RtlMoveMemory( bufferAddress, mapAddress, bytesThisCopy );

        }

        //
        // Update locals and process the next translation entry.
        //

        bytesLeft -= bytesThisCopy;
        bufferAddress += bytesThisCopy;
        translationEntry += 1;
    }
}

PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function allocates the memory for a common buffer and maps it so that
    it can be accessed by a master device and the CPU.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
                    device.

    Length - Supplies the length of the common buffer to be allocated.

    LogicalAddress - Returns the logical address of the common buffer.

    CacheEnable - Indicates whether the memeory is cached or not.

Return Value:

    Returns the virtual address of the common buffer.  If the buffer cannot be
    allocated then NULL is returned.

--*/

{
    PSINGLE_LIST_ENTRY virtualAddress;
    PHYSICAL_ADDRESS minPhysicalAddress;
    PHYSICAL_ADDRESS maxPhysicalAddress;
    PHYSICAL_ADDRESS logicalAddress;
    PHYSICAL_ADDRESS boundaryPhysicalAddress;
    ULONGLONG boundaryMask;

    UNREFERENCED_PARAMETER( CacheEnabled );

    //
    // Determine the maximum physical address that this adapter can handle.
    //

    minPhysicalAddress.QuadPart = 0;
    maxPhysicalAddress = HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

    //
    // Determine the boundary mask for this adapter.
    //

    if (AdapterObject->MasterDevice) {

        //
        // This is not an ISA system.  The buffer must not cross a 4GB boundary.
        // It is predicted that most adapters are incapable of reliably
        // transferring across a 4GB boundary.
        //

        boundaryPhysicalAddress.QuadPart = 0x0000000100000000;
        boundaryMask = 0xFFFFFFFF00000000;

    } else {

        //
        // Common buffer cannot cross a 64K boundary.
        //

        boundaryPhysicalAddress.QuadPart = 0x10000;
        boundaryMask = 0xFFFFFFFFFFFF0000;
    }

    HalDebugPrint((HAL_INFO, "Allocate common buffer below %p\n", maxPhysicalAddress));

    //
    // Allocate a contiguous buffer.
    //

    virtualAddress = MmAllocateContiguousMemorySpecifyCache(
                        Length,
                        minPhysicalAddress,
                        maxPhysicalAddress,
                        boundaryPhysicalAddress,
                        MmCached );

    if (virtualAddress != NULL) {

        //
        // Got a buffer, get the physical/logical address and see if it
        // meets our conditions.
        //
    
        logicalAddress = MmGetPhysicalAddress( virtualAddress );

#if DBG
        ASSERT (((logicalAddress.QuadPart ^
             (logicalAddress.QuadPart + Length - 1)) & boundaryMask) == 0);
#endif
    
        *LogicalAddress = logicalAddress;
    }

    return virtualAddress;
}



NTSTATUS
HalpAllocateMapRegisters(
    IN PADAPTER_OBJECT DmaAdapter,
    IN ULONG NumberOfMapRegisters,
    IN ULONG BaseAddressCount,
    OUT PMAP_REGISTER_ENTRY MapRegisterArray
    )
/*++

Routine Description:

    Allocates a chunk of map registers for use with MapTransfer/Flush,

    NOTE:  Caller is responsible to free map registers for each base
           address, same as when calling AllocateAdapterChannel if
           a driver's execution routine returns  DeallocateObject-
           KeepRegisters

           This routine must be called at IRQL <= PASSIVE_LEVEL

Arguments:

    DmaAdapter - Pointer to the dma adapter for this request

    NumberOfMapRegisters - Number of map registers per allocation

    BaseAddressCount - Number of base allocations

    MapRegisterArray - Pointer to a map register array to return base
                       addresses of allocations

Return Value:

    STATUS_SUCCESS or error

--*/
{
    KIRQL Irql;
    ULONG Index;
    ULONG MapRegisterNumber;
    PADAPTER_OBJECT MasterAdapter;

    PAGED_CODE();

    MasterAdapter = DmaAdapter->MasterAdapter;
   
    //
    // There shouldn't be any legacy adapters on _WIN64
    //
#if 0
    //
    // This routine directly munges the master adapter bitmap, and does not
    // deal with channels, or the legacy DMA hardware
    //
    if (DmaAdapter->LegacyAdapter) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }
#endif

    //
    // This adapter doesn't require map registers, or they are asking
    // for zero, set each BaseAddress to NULL
    //
    if (((BaseAddressCount * NumberOfMapRegisters) == 0) ||
        (!DmaAdapter->NeedsMapRegisters)) {

        for (Index = 0; Index < BaseAddressCount; Index++) {
            MapRegisterArray[Index].MapRegister = NULL;
        }

        return STATUS_SUCCESS;
    }

    //
    // If this request is too piggy, or if the adapter has no map
    // registers, fail this request
    //
    if (((NumberOfMapRegisters * BaseAddressCount) >
         (4 * MAXIMUM_PCI_MAP_REGISTER)) ||
        (DmaAdapter->MapRegistersPerChannel == 0)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Each individual allocation must not exceed the number of map
    // we returned from IoGetDmaAdapter
    //
    if (NumberOfMapRegisters > DmaAdapter->MapRegistersPerChannel) {
        return STATUS_INVALID_PARAMETER;
    }
  
    for (Index = 0; Index < BaseAddressCount; Index++) {

        MapRegisterNumber = (ULONG)-1;

        //
        // We need to lock the master adapter before we fondle its bitmap
        //
        KeAcquireSpinLock(&MasterAdapter->SpinLock, &Irql);
    
        //
        // This routine is meant to be called during init to allocate a wad
        // of map registers in one fell swoop, it's primary consumer is
        // NDIS, and it's primary purpose is to ease up map register
        // consumption, so, if there is already an adapter waiting for map
        // registers, then there are two possibilities, (1) a work item
        // has been queued to grow more translations, or (2) there are
        // none left and they are stuck waiting for a free, if it's the
        // latter then we are going to fail too, and if it's the former,
        // then our bid to allocate up to 64 map registers, out of
        // perhaps thousands, should not dramtically decrease the waiters
        // chances to have a reasonably sized request satisfied, moreover,
        // since this function is only used during init, we will not be
        // starving out other drivers during run time in low map register
        // situation, therfore, although it is rude for us to go back door
        // and allocate registers without checking and/or satifying any
        // requests made earlier during init, our cause is a noble one,
        // so we will ignore any queued requests
        //
        //if (IsListEmpty(&MasterAdapter->AdapterQueue)) {
        MapRegisterNumber = RtlFindClearBitsAndSet(
            MasterAdapter->MapRegisters,
            NumberOfMapRegisters,
            0
            );
        //}
        KeReleaseSpinLock(&MasterAdapter->SpinLock, Irql);
        
        if (MapRegisterNumber == -1) {
            BOOLEAN Allocated;
            ULONG BytesToGrow;

            //
            // HalpGrowMapBuffers() takes a byte count
            //
            BytesToGrow = (NumberOfMapRegisters * PAGE_SIZE) +
                INCREMENT_MAP_BUFFER_SIZE;
            
            //
            // We must own this lock in order to call the grow function
            //
            ACQUIRE_NEW_ADAPTER_LOCK();            
            Allocated = HalpGrowMapBuffers(MasterAdapter, BytesToGrow);
            RELEASE_NEW_ADAPTER_LOCK();
            
            if (Allocated) {
                
                //
                // Lock the master adapter before changing its bitmap
                //
                KeAcquireSpinLock(&MasterAdapter->SpinLock, &Irql);
    
                //
                // Again, we will ignore any queued requests (see note
                // above)
                //
                //if (IsListEmpty(&MasterAdapter->AdapterQueue)) {
                MapRegisterNumber = RtlFindClearBitsAndSet(
                    MasterAdapter->MapRegisters,
                    NumberOfMapRegisters,
                    0
                    );
                //}                
                KeReleaseSpinLock(&MasterAdapter->SpinLock, Irql);
                
                //
                // That's wierd!  We grew the bitmap, and still failed ?
                //
                if (MapRegisterNumber == -1) {
                    break;
                }
            
            //
            // We were unable to allocate additional translation
            // buffers
            //
            } else {
                break;
            }
        }

        //
        // Save the base address for these translation buffers
        //
        MapRegisterArray[Index].MapRegister =
            ((PTRANSLATION_ENTRY)MasterAdapter->MapRegisterBase +
             MapRegisterNumber);
    }

    //
    // Cleanup and fail, we couldn't allocate them all!
    //
    if (Index != BaseAddressCount) {

        while (Index > 0) {

            IoFreeMapRegisters(MasterAdapter,
                               MapRegisterArray[Index - 1].MapRegister,
                               NumberOfMapRegisters);
            Index--;
        }
        
        return STATUS_INSUFFICIENT_RESOURCES;
    }
 
    return STATUS_SUCCESS;
}



BOOLEAN
HalFlushCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    This function is called to flush any hardware adapter buffers when the
    driver needs to read data written by an I/O master device to a common
    buffer.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

    Length - Supplies the length of the common buffer. This should be the same
        value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
        must be the same value return by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
        must be the same value return by HalAllocateCommonBuffer.

Return Value:

    Returns TRUE if no errors were detected.  Otherwise, FALSE is returned.

--*/

{
    UNREFERENCED_PARAMETER( AdapterObject );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LogicalAddress );
    UNREFERENCED_PARAMETER( VirtualAddress );

    return(TRUE);

}

VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function frees a common buffer and all of the resources it uses.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

    Length - Supplies the length of the common buffer. This should be the same
        value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
        must be the same value returned by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
        must be the same value returned by HalAllocateCommonBuffer.

    CacheEnable - Indicates whether the memory is cached or not.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( AdapterObject );
    UNREFERENCED_PARAMETER( LogicalAddress );

    MmFreeContiguousMemorySpecifyCache(VirtualAddress,
                                       Length,
                                       MmCached);

}


NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    )
/*++

Routine Description:

    This routine calculates the size of the scatter/gather list that
    needs to be allocated for a given virtual address range or MDL.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PMDL TempMdl;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    PUCHAR MdlVa;
    NTSTATUS Status;
    ULONG PageOffset;

    if (ARGUMENT_PRESENT(Mdl)) {
        MdlVa = MmGetMdlVirtualAddress(Mdl);

        //
        // Calculate the number of required map registers.
        //

        TempMdl = Mdl;
        TransferLength = TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
        MdlLength = TransferLength;

        PageOffset = BYTE_OFFSET(CurrentVa);
        NumberOfMapRegisters = 0;

        //
        // The virtual address should fit in the first MDL.
        //

        ASSERT((ULONG)((PUCHAR)CurrentVa - MdlVa) <= TempMdl->ByteCount);

        //
        // Loop through the any chained MDLs accumulating the the required
        // number of map registers.
        //

        while (TransferLength < Length && TempMdl->Next != NULL) {

            NumberOfMapRegisters += (PageOffset + MdlLength + PAGE_SIZE - 1) >>
                                        PAGE_SHIFT;

            TempMdl = TempMdl->Next;
            PageOffset = TempMdl->ByteOffset;
            MdlLength = TempMdl->ByteCount;
            TransferLength += MdlLength;
        }

        if ((TransferLength + PAGE_SIZE) < (Length + PageOffset )) {
            ASSERT(TransferLength >= Length);
            return(STATUS_BUFFER_TOO_SMALL);
        }

        //
        // Calculate the last number of map registers based on the requested
        // length not the length of the last MDL.
        //

        ASSERT( TransferLength <= MdlLength + Length );

        NumberOfMapRegisters += (PageOffset + Length + MdlLength - TransferLength +
                                 PAGE_SIZE - 1) >> PAGE_SHIFT;


        if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

    } else {

        //
        // Determine the number of pages required to map the buffer described
        // by CurrentVa and Length.
        //

        NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length);
    }

    //
    // Calculate how much memory is required for the context structure.
    //

    ContextSize = NumberOfMapRegisters * sizeof( SCATTER_GATHER_ELEMENT ) +
                  sizeof( SCATTER_GATHER_LIST );

    //
    // If the adapter does not need map registers then most of this code
    // can be bypassed.  Just build the scatter/gather list and give it
    // to the caller.
    //

    if (AdapterObject->NeedsMapRegisters) {

        ContextSize += FIELD_OFFSET( HAL_WAIT_CONTEXT_BLOCK, ScatterGather );
        if (ContextSize < sizeof( HAL_WAIT_CONTEXT_BLOCK )) {
            ContextSize = sizeof( HAL_WAIT_CONTEXT_BLOCK );
        }
    }

    //
    // Return the list size.
    //

    *ScatterGatherListSize = ContextSize;
    if (pNumberOfMapRegisters) {
        *pNumberOfMapRegisters = NumberOfMapRegisters;
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
HalGetScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    )
{
    return (HalBuildScatterGatherList(AdapterObject,
                              DeviceObject,
                              Mdl,
                              CurrentVa,
                              Length,
                              ExecutionRoutine,
                              Context,
                              WriteToDevice,
                              NULL,
                              0
                              ));
}

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter
    object.  Next a scatter/gather list is built based on the MDL, the
    CurrentVa and the requested Length.  Finally the driver's execution
    function is called with the scatter/gather list.  The adapter is
    released when after the execution function returns.

    The scatter/gather list is allocated if a buffer is not passed and is 
    freed by calling PutScatterGatherList. If a buffer is passed its used instead
    and this buffer is not freed in PutScatterGatherList.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

    The data in the buffer cannot be accessed until the put scatter/gather function has been called.

--*/

{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PMDL TempMdl;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    PUCHAR MdlVa;
    NTSTATUS Status;
    PPFN_NUMBER PageFrame;
    ULONG PageOffset;

    if (!Mdl) {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // If the adapter does not need map registers then most of this code
    // can be bypassed.  Just build the scatter/gather list and give it
    // to the caller.
    //

    if (!AdapterObject->NeedsMapRegisters) {

        if (ScatterGatherBuffer) {

            //
            // Ensure that we at least have enough buffer length for the 
            // header.
            //

			if (ScatterGatherBufferLength < sizeof(SCATTER_GATHER_LIST)) {
                return (STATUS_BUFFER_TOO_SMALL);
            }

            ScatterGather = ScatterGatherBuffer;

        } else {

            Status = HalCalculateScatterGatherListSize(AdapterObject,
                                        Mdl,
                                        CurrentVa,
                                        Length,
                                        &ContextSize,
                                        &NumberOfMapRegisters
                                        );

            if (!NT_SUCCESS(Status)) {
                return (Status);
            }

            ScatterGather = ExAllocatePoolWithTag( NonPagedPool,
                                                   ContextSize,
                                                   HAL_POOL_TAG );
            if (ScatterGather == NULL) {
                return( STATUS_INSUFFICIENT_RESOURCES );
            }
        }

        MdlVa = MmGetMdlVirtualAddress(Mdl);

        ScatterGather->Reserved = 0;

        Element = ScatterGather->Elements;
        TempMdl = Mdl;
        TransferLength = Length;
        MdlLength = TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
        PageOffset = BYTE_OFFSET(CurrentVa);

        //
        // Calculate where to start in the MDL.
        //

        PageFrame = (PPFN_NUMBER)(TempMdl+1);
        PageFrame += ((UINT_PTR) CurrentVa - ((UINT_PTR) MdlVa & ~(PAGE_SIZE - 1)))
                        >> PAGE_SHIFT;

        //
        // Loop build the list for each MDL.
        //

        while (TransferLength >  0) {

            if (MdlLength > TransferLength) {

                MdlLength = TransferLength;
            }

            TransferLength -= MdlLength;

            //
            // Loop building the list for the elements within the MDL.
            //

            while (MdlLength > 0) {

                //
                // Ensure that we never step outside the length of our buffer.
                // We need to validate the length because we don't validate the length at the beginning
                // if the buffer was allocated by the caller.
                //
                if (ScatterGatherBuffer) {
                    if ((PUCHAR)Element > 
                        ((PUCHAR)ScatterGatherBuffer + ScatterGatherBufferLength - sizeof(SCATTER_GATHER_ELEMENT))) {
                        
                        return (STATUS_BUFFER_TOO_SMALL);
                    }
                }

                //
                // Compute the starting address of the transfer.
                //

                Element->Address.QuadPart =
                    (ULONGLONG)((*PageFrame << PAGE_SHIFT) + PageOffset);

                Element->Length = PAGE_SIZE - PageOffset;

                if (Element->Length  > MdlLength ) {

                    Element->Length  = MdlLength;
                }

                ASSERT( (ULONG) MdlLength >= Element->Length );
                MdlLength -= Element->Length;

                //
                // Combine contiguous pages.
                //

                if (Element != ScatterGather->Elements ) {

                    if (Element->Address.QuadPart ==
                        (Element - 1)->Address.QuadPart + (Element - 1)->Length) {

                        //
                        // If the previous page frame is contiguous with this one,
                        // but it crosses a 4GB boundary don't coalesce 
                        //

                        if (((*PageFrame ^ (*PageFrame - 1)) & 0xFFFFFFFFFFF00000UI64) == 0) {

                            //
                            // Add the new length to the old length.
                            //

                            (Element - 1)->Length += Element->Length;

                            //
                            // Reuse the current element.
                            //

                            Element--;
                        }
                    }
                }

                PageOffset = 0;
	
				
				Element++;


                PageFrame++;
            }


            if (TempMdl->Next == NULL) {

                //
                // There are a few cases where the buffer described by the MDL
                // is less than the transfer length.  This occurs when the
                // file system is transfering the last page of the file and
                // MM defines the MDL to be the file size and the file system
                // rounds the write up to a sector.  This extra should never
                // cross a page boundary.  Add this extra to the length of
                // the last element.
                //

                ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
                (Element - 1)->Length += TransferLength;

                break;
            }

            //
            // Advance to the next MDL.  Update the current VA and the MdlLength.
            //

            TempMdl = TempMdl->Next;
            PageOffset = MmGetMdlByteOffset(TempMdl);
            MdlLength = TempMdl->ByteCount;
            PageFrame = (PPFN_NUMBER)(TempMdl+1);

        }

        //
        // Set the number of elements actually used.
        //

        ScatterGather->NumberOfElements = (ULONG)(Element - ScatterGather->Elements);

        if (ScatterGatherBuffer) {
            ScatterGather->Reserved = HAL_WCB_DRIVER_BUFFER;
        }

        //
        // Call the driver with the scatter/gather list.
        //

        ExecutionRoutine( DeviceObject,
                          DeviceObject->CurrentIrp,
                          ScatterGather,
                          Context );
        
        return STATUS_SUCCESS;

    }

	Status = HalCalculateScatterGatherListSize(AdapterObject,
													Mdl,
													CurrentVa,
													Length,
													&ContextSize,
													&NumberOfMapRegisters 
													);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (ScatterGatherBuffer) {

        if (ScatterGatherBufferLength < ContextSize) {
            return (STATUS_BUFFER_TOO_SMALL);
        }

        WaitBlock = ScatterGatherBuffer;

    } else {
        WaitBlock = ExAllocatePoolWithTag(NonPagedPool, ContextSize, HAL_POOL_TAG);

        if (WaitBlock == NULL) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }


    if (ScatterGatherBuffer) {
        WaitBlock->Flags |= HAL_WCB_DRIVER_BUFFER;
    } else {
        WaitBlock->Flags = 0;
    }

    //
    // Save the interesting data in the wait block.
    //

    WaitBlock->Mdl = Mdl;
    WaitBlock->DmaMdl = NULL;
    WaitBlock->CurrentVa = CurrentVa;
    WaitBlock->Length = Length;
    WaitBlock->DriverExecutionRoutine = ExecutionRoutine;
    WaitBlock->DriverContext = Context;
    WaitBlock->AdapterObject = AdapterObject;
    WaitBlock->WriteToDevice = WriteToDevice;
    WaitBlock->NumberOfMapRegisters = NumberOfMapRegisters;

    WaitBlock->Wcb.DeviceContext = WaitBlock;
    WaitBlock->Wcb.DeviceObject = DeviceObject;
    WaitBlock->Wcb.CurrentIrp = DeviceObject->CurrentIrp;


    //
    // Call the HAL to allocate the adapter channel.
    // HalpAllocateAdapterCallback will fill in the scatter/gather list.
    //

    Status = HalAllocateAdapterChannel( AdapterObject,
                                        &WaitBlock->Wcb,
                                        NumberOfMapRegisters,
                                        HalpAllocateAdapterCallback );

    //
    // If HalAllocateAdapterChannel failed then free the wait block.
    //

    if (!NT_SUCCESS( Status)) {
        ExFreePool( WaitBlock );
    }

    return( Status );
}



VOID
HalPutScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This function frees the map registers allocated for the scatter gather list. It can also free the 
    scatter gather buffer and any associated MDLs.

Arguments:

    ScatterGather - The scatter gather buffer

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.
    

Return Value:

    Returns a success or error status.

--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    PTRANSLATION_ENTRY TranslationEntry;
    ULONG TransferLength;
    ULONG MdlLength;
    PMDL Mdl;
    PMDL tempMdl;
    PMDL nextMdl;
    PUCHAR CurrentVa;

    //
    // If the reserved field was empty then just free the list and return.
    //

    if (WaitBlock == NULL) {

        ASSERT(!AdapterObject->NeedsMapRegisters);
        ExFreePool( ScatterGather );
        return;

    }

    if (WaitBlock == (PVOID)HAL_WCB_DRIVER_BUFFER) {
        ASSERT(!AdapterObject->NeedsMapRegisters);
        return;
    }

    ASSERT( WaitBlock == CONTAINING_RECORD( ScatterGather, HAL_WAIT_CONTEXT_BLOCK, ScatterGather ));

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used mdl.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;

#if DBG
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    if (MmGetMdlVirtualAddress(Mdl) < (PVOID)((PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount )) {

        ASSERT( CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );
    }
#endif

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));
    TransferLength = WaitBlock->Length;

    TranslationEntry = WaitBlock->MapRegisterBase;

    //
    // Loop through the used MDLs, calling IoFlushAdapterBuffers.
    //

    while (TransferLength >  0) {

        //
        // Do not perform a flush for buffers of zero length.
        //

        if (MdlLength > 0) {

            if (MdlLength > TransferLength) {
    
                MdlLength = TransferLength;
            }
    
            TransferLength -= MdlLength;
    
            IoFlushAdapterBuffers(  AdapterObject,
                                    Mdl,
                                    TranslationEntry,
                                    CurrentVa,
                                    MdlLength,
                                    WriteToDevice );
    
    
    
    
            TranslationEntry += ADDRESS_AND_SIZE_TO_SPAN_PAGES( CurrentVa,
                                                                MdlLength );
        }

        if (Mdl->Next == NULL) {
            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
    }

    IoFreeMapRegisters( AdapterObject,
                        WaitBlock->MapRegisterBase,
                        WaitBlock->NumberOfMapRegisters
                        );

    if (WaitBlock->DmaMdl) {
        tempMdl = WaitBlock->DmaMdl;
        while (tempMdl) {
            nextMdl = tempMdl->Next;

            //
            // If the MDL was mapped by the driver unmap it here.
            //

            if (tempMdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) {
                MmUnmapLockedPages(tempMdl->MappedSystemVa, tempMdl);
            }
            IoFreeMdl(tempMdl);
            tempMdl = nextMdl;
        }
    }

    if (!(WaitBlock->Flags & HAL_WCB_DRIVER_BUFFER)) {
        ExFreePool( WaitBlock );
    }
}

IO_ALLOCATION_ACTION
HalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the adapter object and map registers are
    available for the data transfer. This routines saves the map register
    base away.  If all of the required bases have not been saved then it
    returns. Otherwise it routine builds the entire scatter/gather
    list by calling IoMapTransfer.  After the list is build it is passed to
    the driver.

Arguments:

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Irp - Supplies the map register offset assigned for this callback.

    MapRegisterBase - Supplies the map register base for use by the adapter
        routines.

    Context - Supplies a pointer to the xhal wait contorl block.

Return Value:

    Returns DeallocateObjectKeepRegisters.


--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = Context;
    ULONG TransferLength;
    LONG MdlLength;
    PMDL Mdl;
    PUCHAR CurrentVa;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    PTRANSLATION_ENTRY TranslationEntry = MapRegisterBase;
    PTRANSLATION_ENTRY NextEntry;
    PDRIVER_LIST_CONTROL DriverExecutionRoutine;
    PVOID DriverContext;
    PIRP CurrentIrp;
    PADAPTER_OBJECT AdapterObject;
    BOOLEAN WriteToDevice;

    //
    // Save the map register base.
    //

    WaitBlock->MapRegisterBase = MapRegisterBase;

    //
    // Save the data that will be over written by the scatter gather list.
    //

    DriverExecutionRoutine = WaitBlock->DriverExecutionRoutine;
    DriverContext = WaitBlock->DriverContext;
    CurrentIrp = WaitBlock->Wcb.CurrentIrp;
    AdapterObject = WaitBlock->AdapterObject;
    WriteToDevice = WaitBlock->WriteToDevice;

    //
    // Put the scatter gatther list after wait block. Add a back pointer to
    // the beginning of the wait block.
    //

    ScatterGather = &WaitBlock->ScatterGather;
    ScatterGather->Reserved = (UINT_PTR) WaitBlock;
    Element = ScatterGather->Elements;

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used MDL.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;

#if DBG
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    if (MmGetMdlVirtualAddress(Mdl) < (PVOID)((PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount )) {

        ASSERT( CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );
    }
#endif

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    TransferLength = WaitBlock->Length;

    //
    // Loop building the list for each MDL.
    //

    while (TransferLength >  0) {

        if ((ULONG) MdlLength > TransferLength) {

            MdlLength = TransferLength;
        }

        TransferLength -= MdlLength;

        NextEntry = TranslationEntry;
        if (MdlLength > 0) {

            NextEntry +=  ADDRESS_AND_SIZE_TO_SPAN_PAGES( CurrentVa,
                                                          MdlLength );

        }

        //
        // Loop building the list for the elments within an MDL.
        //

        while (MdlLength > 0) {

            Element->Length = MdlLength;
            Element->Address = IoMapTransfer( AdapterObject,
                                              Mdl,
                                              MapRegisterBase,
                                              CurrentVa,
                                              &Element->Length,
                                              WriteToDevice );

            ASSERT( (ULONG) MdlLength >= Element->Length );
            MdlLength -= Element->Length;
            CurrentVa += Element->Length;
            Element++;
        }

        if (Mdl->Next == NULL) {

            //
            // There are a few cases where the buffer described by the MDL
            // is less than the transfer length.  This occurs when the
            // file system transfering the last page of file and MM defines
            // the MDL to be the file size and the file system rounds the write
            // up to a sector.  This extra should never cross a page
            // boundary.  Add this extra to the length of the last element.
            //

            ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
            (Element - 1)->Length += TransferLength;

            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
        TranslationEntry = NextEntry;

    }

    //
    // Set the number of elements actually used.
    //

    ScatterGather->NumberOfElements = (ULONG)(Element - ScatterGather->Elements);

    //
    // Call the driver with the scatter/gather list.
    //

    DriverExecutionRoutine( DeviceObject,
                            CurrentIrp,
                            ScatterGather,
                            DriverContext );

    return( DeallocateObjectKeepRegisters );
}

VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, the kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{
    PKDEVICE_QUEUE_ENTRY Packet;
    PWAIT_CONTEXT_BLOCK Wcb;
    PADAPTER_OBJECT MasterAdapter;
    BOOLEAN Busy = FALSE;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;
    LONG MapRegisterNumber;

    //
    // Begin by getting the address of the master adapter.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Pull requests of the adapter's device wait queue as long as the
    // adapter is free and there are sufficient map registers available.
    //

    while( TRUE ) {

       //
       // Begin by checking to see whether there are any map registers that
       // need to be deallocated.  If so, then deallocate them now.
       //

       if (AdapterObject->NumberOfMapRegisters != 0) {
           IoFreeMapRegisters( AdapterObject,
                               AdapterObject->MapRegisterBase,
                               AdapterObject->NumberOfMapRegisters
                               );
       }

       //
       // Simply remove the next entry from the adapter's device wait queue.
       // If one was successfully removed, allocate any map registers that it
       // requires and invoke its execution routine.
       //

       Packet = KeRemoveDeviceQueue( &AdapterObject->ChannelWaitQueue );
       if (Packet == NULL) {

           //
           // There are no more requests - break out of the loop.
           //

           break;
       }

       Wcb = CONTAINING_RECORD( Packet,
            WAIT_CONTEXT_BLOCK,
            WaitQueueEntry );

       AdapterObject->CurrentWcb = Wcb;
       AdapterObject->NumberOfMapRegisters = Wcb->NumberOfMapRegisters;

        //
        // Check to see whether this driver wishes to allocate any map
        // registers.  If so, then queue the device object to the master
        // adapter queue to wait for them to become available.  If the driver
        // wants map registers, ensure that this adapter has enough total
        // map registers to satisfy the request.
        //

        if (Wcb->NumberOfMapRegisters != 0 &&
            AdapterObject->MasterAdapter != NULL) {

            //
            // Lock the map register bit map and the adapter queue in the
            // master adapter object. The channel structure offset is used as
            // a hint for the register search.
            //

            KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

            MapRegisterNumber = -1;

            if (IsListEmpty( &MasterAdapter->AdapterQueue)) {
               MapRegisterNumber = RtlFindClearBitsAndSet( MasterAdapter->MapRegisters,
                                                        Wcb->NumberOfMapRegisters,
                                                        0
                                                        );
            }
            if (MapRegisterNumber == -1) {

               //
               // There were not enough free map registers.  Queue this request
               // on the master adapter where it will wait until some registers
               // are deallocated.
               //

               InsertTailList( &MasterAdapter->AdapterQueue,
                               &AdapterObject->AdapterQueue
                               );
               Busy = 1;

            } else {

                AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                    MasterAdapter->MapRegisterBase + MapRegisterNumber);

                //
                // Set the no scatter/gather flag if scatter/gather is not
                // supported.
                //

                if (!AdapterObject->ScatterGather) {

                    AdapterObject->MapRegisterBase = (PVOID)
                        ((UINT_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

                }
            }

            KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        } else {

            AdapterObject->MapRegisterBase = NULL;
            AdapterObject->NumberOfMapRegisters = 0;

        }

        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now.
        //

        if (!Busy) {
            AdapterObject->CurrentWcb = Wcb;
            Action = Wcb->DeviceRoutine( Wcb->DeviceObject,
                Wcb->CurrentIrp,
                AdapterObject->MapRegisterBase,
                Wcb->DeviceContext );

            //
            // If the execution routine would like to have the adapter
            // deallocated, then release the adapter object.
            //

            if (Action == KeepObject) {

               //
               // This request wants to keep the channel a while so break
               // out of the loop.
               //

               break;

            }

            //
            // If the driver wants to keep the map registers then set the
            // number allocated to 0.  This keeps the deallocation routine
            // from deallocating them.
            //

            if (Action == DeallocateObjectKeepRegisters) {
                AdapterObject->NumberOfMapRegisters = 0;
            }

        } else {

           //
           // This request did not get the requested number of map registers so
           // break out of the loop.
           //

           break;
        }
    }
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

    If NumberOfMapRegisters != 0, this routine deallocates the map registers
    for the adapter.

    If there are any queued adapters waiting then an attempt is made to allocate
    the next entry.

Arguments:

    AdapterObject - The adapter object where the map registers should be
        returned to.

    MapRegisterBase - The map register base of the registers to be deallocated.

    NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

    None

--+*/
{
    PADAPTER_OBJECT MasterAdapter;
    LONG MapRegisterNumber;
    PWAIT_CONTEXT_BLOCK Wcb;
    PLIST_ENTRY Packet;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;

    //
    // Begin by getting the address of the master adapter.
    //

    if (AdapterObject->MasterAdapter != NULL && MapRegisterBase != NULL) {

        MasterAdapter = AdapterObject->MasterAdapter;

    } else {

        //
        // There are no map registers to return.
        //

        return;
    }

    if (NumberOfMapRegisters != 0) {

        //
        // Strip the no scatter/gather flag.
        //
        
        MapRegisterBase = (PVOID) ((UINT_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);
        
        MapRegisterNumber = (LONG)((PTRANSLATION_ENTRY) MapRegisterBase -
             (PTRANSLATION_ENTRY) MasterAdapter->MapRegisterBase);
        
        //
        // Acquire the master adapter spinlock which locks the adapter queue and the
        // bit map for the map registers.
        //
        
        KeAcquireSpinLock(&MasterAdapter->SpinLock, &Irql);
        
        //
        // Return the registers to the bit map.
        //
        
        RtlClearBits( MasterAdapter->MapRegisters,
                      MapRegisterNumber,
                      NumberOfMapRegisters
                      );

    } else {

        KeAcquireSpinLock(&MasterAdapter->SpinLock, &Irql);
    }
   

    //
    // Process any requests waiting for map registers in the adapter queue.
    // Requests are processed until a request cannot be satisfied or until
    // there are no more requests in the queue.
    //

    while(TRUE) {

        if ( IsListEmpty(&MasterAdapter->AdapterQueue) ){
            break;
        }

        Packet = RemoveHeadList( &MasterAdapter->AdapterQueue );
        AdapterObject = CONTAINING_RECORD( Packet,
                                         ADAPTER_OBJECT,
                                         AdapterQueue
                                         );
        Wcb = AdapterObject->CurrentWcb;

        //
        // Attempt to allocate map registers for this request. Use the previous
        // register base as a hint.
        //

        MapRegisterNumber = RtlFindClearBitsAndSet( MasterAdapter->MapRegisters,
                                               AdapterObject->NumberOfMapRegisters,
                                               MasterAdapter->NumberOfMapRegisters
                                               );

        if (MapRegisterNumber == -1) {

            //
            // There were not enough free map registers.  Put this request back on
            // the adapter queue where is came from.
            //

            InsertHeadList( &MasterAdapter->AdapterQueue,
                         &AdapterObject->AdapterQueue
                         );

            break;

        }

        KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        AdapterObject->MapRegisterBase = (PVOID) ((PTRANSLATION_ENTRY)
                         MasterAdapter->MapRegisterBase + MapRegisterNumber);

        //
        // Set the no scatter/gather flag if scatter/gather not
        // supported.
        //

        if (!AdapterObject->ScatterGather) {

            AdapterObject->MapRegisterBase = (PVOID)
                   ((UINT_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

        }

        //
        // Invoke the driver's execution routine now.
        //

        Action = Wcb->DeviceRoutine( Wcb->DeviceObject,
                                     Wcb->CurrentIrp,
                                     AdapterObject->MapRegisterBase,
                                     Wcb->DeviceContext );

        //
        // If the driver wishes to keep the map registers then set the number
        // allocated to zero and set the action to deallocate object.
        //

        if (Action == DeallocateObjectKeepRegisters) {
            AdapterObject->NumberOfMapRegisters = 0;
            Action = DeallocateObject;
        }

        //
        // If the driver would like to have the adapter deallocated,
        // then deallocate any map registers allocated and then release
        // the adapter object.
        //

        if (Action == DeallocateObject) {

            //
            // The map registers registers are deallocated here rather than in
            // IoFreeAdapterChannel.  This limits the number of times
            // this routine can be called recursively possibly overflowing
            // the stack.  The worst case occurs if there is a pending
            // request for the adapter that uses map registers and whos
            // excution routine decallocates the adapter.  In that case if there
            // are no requests in the master adapter queue, then IoFreeMapRegisters
            // will get called again.
            //

            if (AdapterObject->NumberOfMapRegisters != 0) {

                //
                // Deallocate the map registers and clear the count so that
                // IoFreeAdapterChannel will not deallocate them again.
                //

                KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql);

                RtlClearBits( MasterAdapter->MapRegisters,
                           MapRegisterNumber,
                           AdapterObject->NumberOfMapRegisters
                           );

                AdapterObject->NumberOfMapRegisters = 0;

                KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );
            }

            IoFreeAdapterChannel( AdapterObject );
        }

        KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql);

    }

    KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );
}

VOID
HalPutDmaAdapter(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    This routine frees the DMA adapter.

Arguments:

    AdapterObject - Supplies a pointer to the DMA adapter to be freed.

Return Value:

    None.


--*/
{

    ASSERT( AdapterObject->ChannelNumber == 0xFF );

    //
    // This adapter can be freed if the channel number is zero and
    // it is not the channel zero adapter.
    //

    if ( AdapterObject->ChannelNumber == 0xFF ) {

        ObDereferenceObject( AdapterObject );
    }
}

struct _DMA_ADAPTER *
HaliGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function is a wrapper for HalGetAdapter.  Is is called through
    the HAL dispatch table.

Arguments:

    Context - Unused.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );

}

NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    )
/*++

Routine Description:

    This function builds an MDL from the scatter gather list. This is so if a driver wants to 
    construct a virtual address for the DMA buffer and write to it. The target MDL is freed when the 
    caller calls HalPutScatterGatherList.

Arguments:

    ScatterGather - The scatter gather buffer from which to build the MDL.

    OriginalMdl  - The MDL used to build the scatter gather list (using HalGet or HalBuild API)
    
    TargetMdl - Returns the new MDL in this.
    

Return Value:

    Returns a success or error status.

--*/
{
    PMDL    tempMdl;
    PMDL    newMdl;
    PMDL    targetMdl;
    PMDL    prevMdl;
    PMDL    nextMdl;
    CSHORT  mdlFlags;
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    ULONG    i,j;
    PSCATTER_GATHER_ELEMENT element;
    PPFN_NUMBER  pfnArray;
    PFN_NUMBER  pageFrame;
    ULONG   nPages;

    if (!OriginalMdl) {
        return  STATUS_INVALID_PARAMETER;
    }

    if (!AdapterObject->NeedsMapRegisters) {
        *TargetMdl = OriginalMdl;
        return STATUS_SUCCESS;
    }

    //
    // If this API is called more than once 
    if (WaitBlock && WaitBlock->DmaMdl) {
        return (STATUS_NONE_MAPPED);
    }

    //
    // Allocate a chain of target MDLs
    //

    prevMdl = NULL;
    targetMdl = NULL;

    for (tempMdl = OriginalMdl; tempMdl; tempMdl = tempMdl->Next) {

        PVOID va;
        ULONG byteCount;

        if(tempMdl == OriginalMdl) {
            va = WaitBlock->CurrentVa;
            byteCount = MmGetMdlByteCount(tempMdl);
        } else {
            va = MmGetMdlVirtualAddress(tempMdl);
            byteCount = MmGetMdlByteCount(tempMdl);
        }

        newMdl = IoAllocateMdl(va, byteCount, FALSE, FALSE, NULL);

        
        if (!newMdl) {

            //
            // Clean up previous allocated MDLs
            //

            tempMdl = targetMdl;
            while (tempMdl) {
                nextMdl = tempMdl->Next;
                IoFreeMdl(tempMdl);
                tempMdl = nextMdl;
            }

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        if (!prevMdl) {
            prevMdl = newMdl;
            targetMdl = newMdl;
        } else {
            prevMdl->Next = newMdl;
            prevMdl = newMdl;
        }
    }


    tempMdl = OriginalMdl;

    element = ScatterGather->Elements;
    for (tempMdl = targetMdl; tempMdl; tempMdl = tempMdl->Next) {

        targetMdl->MdlFlags |= MDL_PAGES_LOCKED;
        pfnArray = MmGetMdlPfnArray(tempMdl);

        for (i = 0; i < ScatterGather->NumberOfElements; i++, element++) {
            nPages = BYTES_TO_PAGES(BYTE_OFFSET(element->Address.QuadPart) + element->Length);

            pageFrame = (ULONG)(element->Address.QuadPart >> PAGE_SHIFT);
            for (j = 0; j < nPages; j++) {
                *pfnArray = pageFrame + j;
                pfnArray++;
                ASSERT((PVOID)pfnArray <= (PVOID)((PCHAR)tempMdl + tempMdl->Size));
            }
        }
    }

    *TargetMdl = targetMdl;
    if (WaitBlock) {
        WaitBlock->DmaMdl = targetMdl;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixinfo.c

Abstract:

Author:

    Ken Reneris (kenr)  08-Aug-1994

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HaliQuerySystemInformation)
#pragma alloc_text(PAGE,HaliSetSystemInformation)
#pragma alloc_text(INIT,HalInitSystemPhase2)

#endif

//
// NUMA Information.
//

extern PVOID HalpAcpiSrat;

NTSTATUS
HalpGetAcpiStaticNumaTopology(
    HAL_NUMA_TOPOLOGY_INTERFACE * NumaInfo
    );

NTSTATUS
HalpGenerateCMCInterrupt(
    VOID
    );

NTSTATUS
HaliQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    NTSTATUS    Status;
    PVOID       InternalBuffer;
    ULONG       Length, PlatformProperties;
    union {
        HAL_POWER_INFORMATION               PowerInf;
        HAL_PROCESSOR_SPEED_INFORMATION     ProcessorInf;
        HAL_ERROR_INFO                      ErrorInfo;
        HAL_DISPLAY_BIOS_INFORMATION        DisplayBiosInf;
        HAL_PLATFORM_INFORMATION            PlatformInfo;
    } U;

    BOOLEAN     bUseFrameBufferCaching;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    *ReturnedLength = 0;
    Length = 0;

    switch (InformationClass) {

        case HalFrameBufferCachingInformation:

            Status = HalpGetPlatformProperties(&PlatformProperties);
            if (NT_SUCCESS(Status) &&
                (PlatformProperties & HAL_PLATFORM_DISABLE_WRITE_COMBINING)) {
               if ( PlatformProperties & HAL_PLATFORM_ENABLE_WRITE_COMBINING_MMIO )   {
                   bUseFrameBufferCaching = TRUE;
               }
               else   {
                   bUseFrameBufferCaching = FALSE;
               }
            } else {

                //
                // Note - we want to return TRUE here to enable USWC in all
                // cases except in a "Shared Memory Cluster" machine.
                //

                Status = STATUS_SUCCESS;
                bUseFrameBufferCaching = TRUE;
            }
            InternalBuffer = &bUseFrameBufferCaching;
            Length = sizeof (BOOLEAN);
            break;

        case HalMcaLogInformation:
            Status = HalpGetMcaLog( Buffer, BufferSize, ReturnedLength );
            break;

        case HalCmcLogInformation:
            Status = HalpGetCmcLog( Buffer, BufferSize, ReturnedLength );
            break;

        case HalCpeLogInformation:
            Status = HalpGetCpeLog( Buffer, BufferSize, ReturnedLength );
            break;

        case HalErrorInformation:
            InternalBuffer = &U.ErrorInfo;
            if ( Buffer && (BufferSize > sizeof(U.ErrorInfo.Version)) )   {
                U.ErrorInfo.Version = ((PHAL_ERROR_INFO)Buffer)->Version;
                Status = HalpGetMceInformation(&U.ErrorInfo, &Length);
            }
            else    {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        case HalDisplayBiosInformation:
            InternalBuffer = &U.DisplayBiosInf;
            Length = sizeof(U.DisplayBiosInf);
            U.DisplayBiosInf = HalpGetDisplayBiosInformation ();
            break;

        case HalProcessorSpeedInformation:
            RtlZeroMemory (&U.ProcessorInf, sizeof(HAL_PROCESSOR_SPEED_INFORMATION));

            // U.ProcessorInf.MaximumProcessorSpeed = HalpCPUMHz;
            // U.ProcessorInf.CurrentAvailableSpeed = HalpCPUMHz;
            // U.ProcessorInf.ConfiguredSpeedLimit  = HalpCPUMHz;

            U.ProcessorInf.ProcessorSpeed = HalpCPUMHz;

            InternalBuffer = &U.ProcessorInf;
            Length = sizeof (HAL_PROCESSOR_SPEED_INFORMATION);
            break;

        case HalProfileSourceInformation:
            Status = HalpProfileSourceInformation (
                        Buffer,
                        BufferSize,
                        ReturnedLength);
            return Status;
            break;

        case HalNumaTopologyInterface:
            if (BufferSize == sizeof(HAL_NUMA_TOPOLOGY_INTERFACE)) {

                Status = STATUS_INVALID_LEVEL;

                if (HalpAcpiSrat) {
                    Status = HalpGetAcpiStaticNumaTopology(Buffer);
                    if (NT_SUCCESS(Status)) {
                        *ReturnedLength = sizeof(HAL_NUMA_TOPOLOGY_INTERFACE);
                    }
                    break;
                }

            } else {

                //
                // Buffer size is wrong, we could return valid data
                // if the buffer is too big,.... but instead we will
                // use this as an indication that we're not compatible
                // with the kernel.
                //

                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        case HalPartitionIpiInterface:

            //
            // Some platforms generate interrupts in remote partitions
            // as part of their shared memory implementation.  This is
            // accomplished by targetting an IPI at a processor/vector
            // in that remote partition.  Provide interfaces to enable
            // this but make them conditional on presence of IPPT
            // table and appropriate bit explicitly enabling this
            // functionality.  OEM is responsible for ensuring that an
            // interrupt isn't sent to a logical processor that isn't
            // present.
            //

            if (BufferSize >= sizeof(HAL_CROSS_PARTITION_IPI_INTERFACE)) {
                Status = HalpGetPlatformProperties(&PlatformProperties);
                if (NT_SUCCESS(Status) &&
                    (PlatformProperties & IPPT_ENABLE_CROSS_PARTITION_IPI)) {
                    Status = HalpGetCrossPartitionIpiInterface(Buffer);
                    if (NT_SUCCESS(Status)) {
                        *ReturnedLength = sizeof(HAL_CROSS_PARTITION_IPI_INTERFACE);
                    }
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                }
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        case HalPlatformInformation:
            //
            // Any platform information that must be exposed to the kernel.
            //

            if (BufferSize >= sizeof(HAL_PLATFORM_INFORMATION)) {
                Status = HalpGetPlatformProperties(&PlatformProperties);
                if (NT_SUCCESS(Status)) {
                    InternalBuffer = &U.PlatformInfo;
                    Length = sizeof(U.PlatformInfo);
                    U.PlatformInfo.PlatformFlags = PlatformProperties;
                }
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    //
    // If non-zero Length copy data to callers buffer
    //

    if (Length) {
        if (BufferSize < Length) {
            Length = BufferSize;
        }

        *ReturnedLength = Length;
        RtlCopyMemory (Buffer, InternalBuffer, Length);
    }

    return Status;

} // HaliQuerySystemInformation()

// BOOLEAN
// HalpIsFunctionPointerValid(
//      PVOID Va
//      )
//
// Return TRUE  if Function Pointer and Function are valid.
// Return TRUE  if Function Pointer is valid and Function is NULL.
// Return FALSE if Function Pointer is invalid or Function is not NULL but invalid.
//
#define HalpIsFunctionPointerValid( _Va ) ( MmIsAddressValid((PVOID)(_Va)) && ((*((PULONG_PTR)(_Va)) == 0) || MmIsAddressValid( *((PVOID *)(_Va)) )))

NTSTATUS
HaliSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
/*++

Routine Description:

    The function allows setting of various fields return by
    HalQuerySystemInformation.

Arguments:

    InformationClass - Information class of the request.

    BufferSize - Size of buffer supplied by the caller.

    Buffer - Supplies the data to be set.

Return Value:

    STATUS_SUCCESS or error.

--*/
{
    NTSTATUS    Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    switch (InformationClass) {

        case HalProfileSourceInterval:
            if (BufferSize == sizeof(HAL_PROFILE_SOURCE_INTERVAL)) {

                PHAL_PROFILE_SOURCE_INTERVAL sourceInterval =
                            (PHAL_PROFILE_SOURCE_INTERVAL)Buffer;

                Status = HalSetProfileSourceInterval(  sourceInterval->Source,
                                                      &sourceInterval->Interval
                                                    );
            }
            else  {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        case HalProfileSourceInterruptHandler:
            //
            // Register an Profiling Interrupt Handler.
            //

            Status = STATUS_INFO_LENGTH_MISMATCH;
            if (BufferSize == sizeof(ULONG_PTR)) {
                if ( !(HalpFeatureBits & HAL_PERF_EVENTS) ) {
                    Status = STATUS_NO_SUCH_DEVICE;
                }
                else if ( !HalpIsFunctionPointerValid(Buffer) ) {
                    Status = STATUS_INVALID_ADDRESS;
                }
                else  {
                    Status = (NTSTATUS)KiIpiGenericCall( HalpSetProfileInterruptHandler, *(PULONG_PTR)Buffer );
                }
            }
            break;

        case HalKernelErrorHandler:
            Status = HalpMceRegisterKernelDriver( (PKERNEL_ERROR_HANDLER_INFO) Buffer, BufferSize );
            break;

        case HalMcaRegisterDriver:
            Status = HalpMcaRegisterDriver(
                (PMCA_DRIVER_INFO) Buffer  // Info about registering driver
            );
            break;

        case HalCmcRegisterDriver:
            Status = HalpCmcRegisterDriver(
                (PCMC_DRIVER_INFO) Buffer  // Info about registering driver
            );
            break;

        case HalCpeRegisterDriver:
            Status = HalpCpeRegisterDriver(
                (PCPE_DRIVER_INFO) Buffer  // Info about registering driver
            );
            break;

        case HalMcaLog:  // Class requested by MS Machine Check Event Test Team.
            Status = HalpSetMcaLog( (PMCA_EXCEPTION) Buffer, BufferSize );
            break;

        case HalCmcLog:  // Class requested by MS Machine Check Event Test Team.
            Status = HalpSetCmcLog( (PCMC_EXCEPTION) Buffer, BufferSize );
            break;

        case HalCpeLog:  // Class requested by MS Machine Check Event Test Team.
            Status = HalpSetCpeLog( (PCPE_EXCEPTION) Buffer, BufferSize );
            break;

        case HalGenerateCmcInterrupt:
            Status = HalpGenerateCMCInterrupt();
            break;

        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    return Status;

} // HaliSetSystemInformation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixisasup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixisasup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "eisa.h"
#include "pci.h"

#include "pcip.h"


//
//Only take the prototype, don't instantiate
//
#include <wdmguid.h>

#include "halpnpp.h"

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE,HalGetAdapter)
        #pragma alloc_text(PAGE,HalpGetIsaIrqState)
#endif

//
// The HalpNewAdapter event is used to serialize allocations
// of new adapter objects, additions to the HalpEisaAdapter
// array, and some global values (MasterAdapterObject) and some
// adapter fields modified by HalpGrowMapBuffers.
// (AdapterObject->NumberOfMapRegisters is assumed not to be
// growable while this even is held)
//
// Note: We don't really need our own an event object for this.
//

KEVENT   HalpNewAdapter;


#define ACQUIRE_NEW_ADAPTER_LOCK()  \
{                                   \
    KeWaitForSingleObject (         \
        &HalpNewAdapter,            \
        WrExecutive,                \
        KernelMode,                 \
        FALSE,                      \
        NULL                        \
        );                          \
}

typedef struct _BUFFER_GROW_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PADAPTER_OBJECT AdapterObject;
    ULONG MapRegisterCount;
} BUFFER_GROW_WORK_ITEM, *PBUFFER_GROW_WORK_ITEM;


#define RELEASE_NEW_ADAPTER_LOCK()  \
    KeSetEvent (&HalpNewAdapter, 0, FALSE)

BOOLEAN NoMemoryAbove4Gb = FALSE;

VOID
HalpCopyBufferMap(
                 IN PMDL Mdl,
                 IN PTRANSLATION_ENTRY TranslationEntry,
                 IN PVOID CurrentVa,
                 IN ULONG Length,
                 IN BOOLEAN WriteToDevice
                 );

PHYSICAL_ADDRESS
HalpMapTransfer(
               IN PADAPTER_OBJECT AdapterObject,
               IN PMDL Mdl,
               IN PVOID MapRegisterBase,
               IN PVOID CurrentVa,
               IN OUT PULONG Length,
               IN BOOLEAN WriteToDevice
               );

VOID
HalpMapTransferHelper(
                     IN PMDL Mdl,
                     IN PVOID CurrentVa,
                     IN ULONG TransferLength,
                     IN PPFN_NUMBER PageFrame,
                     IN OUT PULONG Length
                     );


NTSTATUS
HalAllocateAdapterChannel(
                         IN PADAPTER_OBJECT AdapterObject,
                         IN PWAIT_CONTEXT_BLOCK Wcb,
                         IN ULONG NumberOfMapRegisters,
                         IN PDRIVER_CONTROL ExecutionRoutine
                         )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the adapter on the adapter's queue.  If the queue is already
    "busy", then the adapter has already been allocated, so the device object
    is simply placed onto the queue and waits until the adapter becomes free.

    Once the adapter becomes free (or if it already is), then the driver's
    execution routine is invoked.

    Also, a number of map registers may be allocated to the driver by specifying
    a non-zero value for NumberOfMapRegisters.  Then the map register must be
    allocated from the master adapter.  Once there are a sufficient number of
    map registers available, then the execution routine is called and the
    base address of the allocated map registers in the adapter is also passed
    to the driver's execution routine.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    Wcb - Supplies a wait context block for saving the allocation parameters.
        The DeviceObject, CurrentIrp and DeviceContext should be initalized.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/
{

    PADAPTER_OBJECT MasterAdapter;
    BOOLEAN Busy = FALSE;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;
    ULONG MapRegisterNumber;

    //
    // Begin by obtaining a pointer to the master adapter associated with this
    // request.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Initialize the device object's wait context block in case this device
    // must wait before being able to allocate the adapter.
    //

    Wcb->DeviceRoutine = ExecutionRoutine;
    Wcb->NumberOfMapRegisters = NumberOfMapRegisters;

    //
    // Allocate the adapter object for this particular device.  If the
    // adapter cannot be allocated because it has already been allocated
    // to another device, then return to the caller now;  otherwise,
    // continue.
    //

    if (!KeInsertDeviceQueue( &AdapterObject->ChannelWaitQueue,
                              &Wcb->WaitQueueEntry )) {

        //
        // Save the parameters in case there are not enough map registers.
        //

        AdapterObject->NumberOfMapRegisters = NumberOfMapRegisters;
        AdapterObject->CurrentWcb = Wcb;

        //
        // The adapter was not busy so it has been allocated.  Now check
        // to see whether this driver wishes to allocate any map registers.
        // Ensure that this adapter has enough total map registers
        // to satisfy the request.
        //

        if (NumberOfMapRegisters != 0 && AdapterObject->NeedsMapRegisters) {

            //
            // Lock the map register bit map and the adapter queue in the
            // master adapter object. The channel structure offset is used as
            // a hint for the register search.
            //

            if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
                AdapterObject->NumberOfMapRegisters = 0;
                IoFreeAdapterChannel(AdapterObject);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }

            KeAcquireSpinLock (&MasterAdapter->SpinLock, &Irql);

            MapRegisterNumber = (ULONG)-1;

            if (IsListEmpty( &MasterAdapter->AdapterQueue)) {

                HalDebugPrint((HAL_VERBOSE, "HAAC: FindClearBitsAndSet(%p,%d,0)\n",
                                           MasterAdapter->MapRegisters,
                                           NumberOfMapRegisters));

                MapRegisterNumber = RtlFindClearBitsAndSet(
                                                  MasterAdapter->MapRegisters,
                                                  NumberOfMapRegisters,
                                                  0
                                                  );

                HalDebugPrint((HAL_VERBOSE, "HAAC: MapRegisterNumber = 0x%x\n",
                                           MapRegisterNumber));
            }

            if (MapRegisterNumber == -1) {

                PBUFFER_GROW_WORK_ITEM bufferWorkItem;

                //
                // There were not enough free map registers.  Queue this request
                // on the master adapter where is will wait until some registers
                // are deallocated.
                //

                InsertTailList( &MasterAdapter->AdapterQueue,
                                &AdapterObject->AdapterQueue
                              );
                Busy = 1;

                //
                // Queue a work item to grow the map registers
                //

                bufferWorkItem = ExAllocatePool( NonPagedPool,
                                                 sizeof(BUFFER_GROW_WORK_ITEM) );
                if (bufferWorkItem != NULL) {

                    ExInitializeWorkItem( &bufferWorkItem->WorkItem,
                                          HalpGrowMapBufferWorker,
                                          bufferWorkItem );

                    bufferWorkItem->AdapterObject = AdapterObject;
                    bufferWorkItem->MapRegisterCount = NumberOfMapRegisters;

                    ExQueueWorkItem( &bufferWorkItem->WorkItem,
                                     DelayedWorkQueue );
                }

            } else {

                //
                // Calculate the map register base from the allocated map
                // register and base of the master adapter object.
                //

                AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                          MasterAdapter->MapRegisterBase + MapRegisterNumber);

                //
                // Set the no scatter/gather flag if scatter/gather not
                // supported.
                //

                if (!AdapterObject->ScatterGather) {

                    AdapterObject->MapRegisterBase = (PVOID)
                     ((UINT_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

                }
            }

            KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        } else {

            AdapterObject->MapRegisterBase = NULL;
            AdapterObject->NumberOfMapRegisters = 0;
        }

        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now.
        //

        if (!Busy) {

            AdapterObject->CurrentWcb = Wcb;
            Action = ExecutionRoutine( Wcb->DeviceObject,
                                       Wcb->CurrentIrp,
                                       AdapterObject->MapRegisterBase,
                                       Wcb->DeviceContext );

            //
            // If the driver would like to have the adapter deallocated,
            // then release the adapter object.
            //

            if (Action == DeallocateObject) {

                IoFreeAdapterChannel( AdapterObject );

            } else if (Action == DeallocateObjectKeepRegisters) {

                //
                // Set the NumberOfMapRegisters  = 0 in the adapter object.
                // This will keep IoFreeAdapterChannel from freeing the
                // registers. After this it is the driver's responsiblity to
                // keep track of the number of map registers.
                //

                AdapterObject->NumberOfMapRegisters = 0;
                IoFreeAdapterChannel(AdapterObject);

            }
        }
    }

    return (STATUS_SUCCESS);

}

NTSTATUS
HalRealAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by calling HalAllocateAdapterChannel which does all of
    the work.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    PWAIT_CONTEXT_BLOCK wcb;

    wcb = &DeviceObject->Queue.Wcb;

    wcb->DeviceObject = DeviceObject;
    wcb->CurrentIrp = DeviceObject->CurrentIrp;
    wcb->DeviceContext = Context;

    return( HalAllocateAdapterChannel( AdapterObject,
                                       wcb,
                                       NumberOfMapRegisters,
                                       ExecutionRoutine ) );
}

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called in the context of a work item from
    HalAllocateAdapterChannel() when it queues a map register allocation
    because map regiers are not available.

    Its purpose is to attempt to grow the map buffers for the adapter and,
    if successful, process queued adapter allocations.

Arguments:

    Context - Actually a pointer to a BUFFER_GROW_WORK_ITEM structure.

Return Value:

    None.

--*/

{
    PBUFFER_GROW_WORK_ITEM growWorkItem;
    PADAPTER_OBJECT masterAdapter;
    BOOLEAN allocated;
    ULONG bytesToGrow;
    KIRQL oldIrql;

    growWorkItem = (PBUFFER_GROW_WORK_ITEM)Context;
    masterAdapter = growWorkItem->AdapterObject->MasterAdapter;

    //
    // HalpGrowMapBuffers() takes a byte count
    //

    bytesToGrow = growWorkItem->MapRegisterCount * PAGE_SIZE +
                  INCREMENT_MAP_BUFFER_SIZE;

    ACQUIRE_NEW_ADAPTER_LOCK();

    allocated = HalpGrowMapBuffers( masterAdapter,
                                    bytesToGrow );

    RELEASE_NEW_ADAPTER_LOCK();

    if (allocated != FALSE) {

        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

        //
        // The map buffers were grown.  It is likely that someone is waiting
        // in the adapter queue, so try to get things started.
        //
        // The code in IoFreeMapRegisters() does this, and it turns out
        // we can safely get it to do this work for us by freeing 0
        // map registers at a bogus (but non-NULL) register base.
        //

        IoFreeMapRegisters( growWorkItem->AdapterObject,
                            (PVOID)2,
                            0 );

        KeLowerIrql( oldIrql );

    }

    ExFreePool( growWorkItem );
}



PVOID
HalAllocateCrashDumpRegisters(
                             IN PADAPTER_OBJECT AdapterObject,
                             IN PULONG NumberOfMapRegisters
                             )
/*++

Routine Description:

    This routine is called during the crash dump disk driver's initialization
    to allocate a number map registers permanently.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.
    NumberOfMapRegisters - Number of map registers requested. This field
        will be updated to reflect the actual number of registers allocated
        when the number is less than what was requested.

Return Value:

    Returns STATUS_SUCESS if map registers allocated.

--*/
{
    PADAPTER_OBJECT MasterAdapter;
    ULONG MapRegisterNumber;

    //
    // Begin by obtaining a pointer to the master adapter associated with this
    // request.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Check to see whether this driver needs to allocate any map registers.
    //

    if (AdapterObject->NeedsMapRegisters) {

        //
        // Ensure that this adapter has enough total map registers to satisfy
        // the request.
        //

        if (*NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
            AdapterObject->NumberOfMapRegisters = 0;
            return NULL;
        }

        //
        // Attempt to allocate the required number of map registers w/o
        // affecting those registers that were allocated when the system
        // crashed.
        //

        MapRegisterNumber = (ULONG)-1;

        MapRegisterNumber = RtlFindClearBitsAndSet(
                                                  MasterAdapter->MapRegisters,
                                                  *NumberOfMapRegisters,
                                                  0
                                                  );

        if (MapRegisterNumber == (ULONG)-1) {

            //
            // Not enough free map registers were found, so they were busy
            // being used by the system when it crashed.  Force the appropriate
            // number to be "allocated" at the base by simply overjamming the
            // bits and return the base map register as the start.
            //

            RtlSetBits(
                      MasterAdapter->MapRegisters,
                      0,
                      *NumberOfMapRegisters
                      );
            MapRegisterNumber = 0;

        }

        //
        // Calculate the map register base from the allocated map
        // register and base of the master adapter object.
        //

        AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                      MasterAdapter->MapRegisterBase + MapRegisterNumber);

        //
        // Set the no scatter/gather flag if scatter/gather not
        // supported.
        //

        if (!AdapterObject->ScatterGather) {

            AdapterObject->MapRegisterBase = (PVOID)
                 ((UINT_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

        }

    } else {

        AdapterObject->MapRegisterBase = NULL;
        AdapterObject->NumberOfMapRegisters = 0;
    }

    return AdapterObject->MapRegisterBase;
}

PADAPTER_OBJECT
HalGetAdapter(
             IN PDEVICE_DESCRIPTION DeviceDescriptor,
             OUT PULONG NumberOfMapRegisters
             )

/*++

Routine Description:

    This function returns the appropriate adapter object for the device defined
    in the device description structure.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adapter object or NULL if an adapter could not
    be created.

--*/

{
    PADAPTER_OBJECT adapterObject;
    PVOID adapterBaseVa;
    UCHAR adapterMode;
    ULONG numberOfMapRegisters;
    ULONG maximumLength;

    PAGED_CODE();

    HalDebugPrint((HAL_VERBOSE, "HGA: IN DeviceDescriptor %p\n",
                                DeviceDescriptor));

    HalDebugPrint((HAL_VERBOSE, "HGA: IN NumberOfMapregisters %p\n",
                                NumberOfMapRegisters));

    //
    // Make sure this is the correct version.
    //

    if (DeviceDescriptor->Version > DEVICE_DESCRIPTION_VERSION2) {
        return ( NULL );
    }

#if DBG
    if (DeviceDescriptor->Version >= DEVICE_DESCRIPTION_VERSION1) {
            ASSERT (DeviceDescriptor->Reserved1 == FALSE);
    }
#endif

    //
    // Limit the maximum length to 2 GB this is done so that the BYTES_TO_PAGES
    // macro works correctly.
    //

    maximumLength = DeviceDescriptor->MaximumLength & 0x7fffffff;

    if (DeviceDescriptor->InterfaceType == PCIBus &&
        DeviceDescriptor->Master != FALSE &&
        DeviceDescriptor->ScatterGather != FALSE) {

        //
        // This device can handle 32 bits, even if the caller forgot to
        // set Dma32BitAddresses.
        //

        DeviceDescriptor->Dma32BitAddresses = TRUE;
    }

    //
    // Determine the number of map registers for this device.
    //

    if (DeviceDescriptor->ScatterGather &&

       (NoMemoryAbove4Gb ||
        DeviceDescriptor->Dma64BitAddresses)) {

        //
        // Since the device support scatter/Gather then map registers are not
        // required.
        //

        numberOfMapRegisters = 0;

    } else {

        //
        // Determine the number of map registers required based on the maximum
        // transfer length, up to a maximum number.
        //

        numberOfMapRegisters = BYTES_TO_PAGES(maximumLength) + 1;

        if (numberOfMapRegisters > MAXIMUM_PCI_MAP_REGISTER) {
            numberOfMapRegisters = MAXIMUM_PCI_MAP_REGISTER;
        }
    }

    HalDebugPrint((HAL_VERBOSE, "HGA: Number of map registers needed = %x\n",
                                numberOfMapRegisters));

    adapterBaseVa = NULL;

    //
    // Serialize before allocating a new adapter
    //

    ACQUIRE_NEW_ADAPTER_LOCK();

    //
    // Allocate an adapter object.
    //

    adapterObject =
        (PADAPTER_OBJECT) HalpAllocateAdapter( numberOfMapRegisters,
                                                     adapterBaseVa,
                                                     NULL);
    if (adapterObject == NULL) {
        RELEASE_NEW_ADAPTER_LOCK();
        return (NULL);
    }

    //
    // Set the maximum number of map registers for this channel bus on
    // the number requested and the type of device.
    //

    if (numberOfMapRegisters) {

        //
        // The speicified number of registers are actually allowed to be
        // allocated.
        //

        adapterObject->MapRegistersPerChannel = numberOfMapRegisters;

        //
        // Increase the commitment for the map registers.
        //
        // Master I/O devices use several sets of map registers double
        // their commitment.
        //

        MasterAdapterObject->CommittedMapRegisters += numberOfMapRegisters * 2;

        //
        // If the committed map registers is signicantly greater than the
        // number allocated then grow the map buffer.
        //

        if (MasterAdapterObject->CommittedMapRegisters >
            MasterAdapterObject->NumberOfMapRegisters  ) {

            HalpGrowMapBuffers(
                MasterAdapterObject,
                INCREMENT_MAP_BUFFER_SIZE
                );
        }

        adapterObject->NeedsMapRegisters = TRUE;

    } else {

        //
        // No real map registers were allocated.  If this is a master
        // device, then the device can have as may registers as it wants.
        //

        adapterObject->NeedsMapRegisters = FALSE;

        adapterObject->MapRegistersPerChannel =
                        BYTES_TO_PAGES( maximumLength ) + 1;

    }
    RELEASE_NEW_ADAPTER_LOCK();

    adapterObject->IgnoreCount = FALSE;
    if (DeviceDescriptor->Version >= DEVICE_DESCRIPTION_VERSION1) {

        //
        // Move version 1 structure flags.
        // IgnoreCount is used on machines where the DMA Counter
        // is broken.  (Namely PS/1 model 1000s).  Setting this
        // bit informs the hal not to rely on the DmaCount to determine
        // how much data was DMAed.
        //

        adapterObject->IgnoreCount = DeviceDescriptor->IgnoreCount;
    }

    adapterObject->Dma32BitAddresses = DeviceDescriptor->Dma32BitAddresses;
    adapterObject->Dma64BitAddresses = DeviceDescriptor->Dma64BitAddresses;
    adapterObject->ScatterGather = DeviceDescriptor->ScatterGather;
    *NumberOfMapRegisters = adapterObject->MapRegistersPerChannel;
    adapterObject->MasterDevice = TRUE;

    HalDebugPrint((HAL_VERBOSE, "HGA: OUT adapterObject = %p\n",
                                adapterObject));
    HalDebugPrint((HAL_VERBOSE, "HGA: OUT NumberOfMapRegisters = %d\n",
                                *NumberOfMapRegisters));

    return (adapterObject);
}


PHYSICAL_ADDRESS
IoMapTransfer(
             IN PADAPTER_OBJECT AdapterObject,
             IN PMDL Mdl,
             IN PVOID MapRegisterBase,
             IN PVOID CurrentVa,
             IN OUT PULONG Length,
             IN BOOLEAN WriteToDevice
             )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    ULONG transferLength;
    PHYSICAL_ADDRESS returnAddress;
    PPFN_NUMBER pageFrame;
    ULONG pageOffset;

    //
    // If the adapter is a 32-bit bus master, take the fast path,
    // otherwise call HalpMapTransfer for the slow path
    //

    if (MapRegisterBase == NULL) {

        pageOffset = BYTE_OFFSET(CurrentVa);

        //
        // Calculate how much of the transfer is contiguous
        //
        transferLength = PAGE_SIZE - pageOffset;
        pageFrame = (PPFN_NUMBER)(Mdl+1);
        pageFrame += (((UINT_PTR) CurrentVa - (UINT_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT);

        //
        // Compute the starting address of the transfer
        //

        returnAddress.QuadPart = (*pageFrame << PAGE_SHIFT) + pageOffset;

        //
        // If the transfer is not completely contained within
        // a page, call the helper to compute the appropriate
        // length.
        //
        if (transferLength < *Length) {
                HalpMapTransferHelper(Mdl, CurrentVa, transferLength, pageFrame, Length);
        }
        return (returnAddress);
    }

    return (HalpMapTransfer(AdapterObject,
                            Mdl,
                            MapRegisterBase,
                            CurrentVa,
                            Length,
                            WriteToDevice));

}


VOID
HalpMapTransferHelper(
                     IN PMDL Mdl,
                     IN PVOID CurrentVa,
                     IN ULONG TransferLength,
                     IN PPFN_NUMBER PageFrame,
                     IN OUT PULONG Length
                     )

/*++

Routine Description:

    Helper routine for bus master transfers that cross a page
    boundary.  This routine is separated out from the IoMapTransfer
    fast path in order to minimize the total instruction path
    length taken for the common network case where the entire
    buffer being mapped is contained within one page.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    TransferLength = Supplies the current transferLength

    PageFrame - Supplies a pointer to the starting page frame of the transfer

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

Return Value:

    None.  *Length will be updated

--*/

{
    PFN_NUMBER thisPageFrame;
    PFN_NUMBER nextPageFrame;

    do {

        thisPageFrame = *PageFrame;
        PageFrame += 1;
        nextPageFrame = *PageFrame;

        if ((thisPageFrame + 1) != nextPageFrame) {

            //
            // The next page frame is not contiguous with this one,
            // so break the transfer here.
            //

            break;
        }

        if (((thisPageFrame ^ nextPageFrame) & 0xFFFFFFFFFFF80000i64) != 0) {

            //
            // The next page frame is contiguous with this one,
            // but it crosses a 4GB boundary, another reason to
            // break the transfer.
            //

            break;
        }

        TransferLength += PAGE_SIZE;

    } while ( TransferLength < *Length );


    //
    // Limit the Length to the maximum TransferLength.
    //

    if (TransferLength < *Length) {
        *Length = TransferLength;
    }
}


PHYSICAL_ADDRESS
HalpMapTransfer(
               IN PADAPTER_OBJECT AdapterObject,
               IN PMDL Mdl,
               IN PVOID MapRegisterBase,
               IN PVOID CurrentVa,
               IN OUT PULONG Length,
               IN BOOLEAN WriteToDevice
               )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    BOOLEAN useBuffer;
    ULONG transferLength;
    PHYSICAL_ADDRESS logicalAddress;
    PHYSICAL_ADDRESS returnAddress;
    ULONG index;
    PPFN_NUMBER pageFrame;
    PTRANSLATION_ENTRY translationEntry;
    ULONG pageOffset;
    PHYSICAL_ADDRESS maximumPhysicalAddress;

    pageOffset = BYTE_OFFSET(CurrentVa);

    //
    // Calculate how much of the transfer is contiguous.
    //

    transferLength = PAGE_SIZE - pageOffset;
    pageFrame = (PPFN_NUMBER)(Mdl+1);
    pageFrame += (((UINT_PTR)CurrentVa - (UINT_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT);

    logicalAddress.QuadPart = (*pageFrame << PAGE_SHIFT) + pageOffset;

    // Find a run of contiguous pages in the buffer

    while ( transferLength < *Length ) {

        if (*pageFrame + 1 != *(pageFrame + 1)) {
            break;
        }

        transferLength += PAGE_SIZE;
        pageFrame++;

    }

    //
    // Limit the transferLength to the requested Length.
    //

    transferLength = transferLength > *Length ? *Length : transferLength;

    ASSERT(MapRegisterBase != NULL);

    //
    // Strip no scatter/gather flag.
    //

    translationEntry = (PTRANSLATION_ENTRY) ((UINT_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

    if ((UINT_PTR) MapRegisterBase & NO_SCATTER_GATHER
        && transferLength < *Length) {

        logicalAddress.QuadPart = translationEntry->PhysicalAddress + pageOffset;
        translationEntry->Index = COPY_BUFFER;
        index = 0;
        transferLength = *Length;
        useBuffer = TRUE;

    } else {

        //
        // If there are map registers, then update the index to indicate
        // how many have been used.
        //

        useBuffer = FALSE;
        index = translationEntry->Index;
        translationEntry->Index += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                                                 CurrentVa,
                                                                 transferLength
                                                                 );
        //
        // PeterJ added the following to catch drivers which don't call
        // IoFlushAdapterBuffers.   Calling IoMapTransfer repeatedly
        // without calling IoFlushAdapterBuffers will run you out of
        // map registers,....  Some PCI device drivers think they can
        // get away with this because they do 32 bit direct transfers.
        // Try plugging one of these into a system with > 4GB and see
        // what happens to you.
        //

        //ASSERT(translationEntry->Index < AdapterObject->NumberOfMapRegisters);
    }

    //
    // It must require memory to be within the adapter's address range.  If the
    // logical address is greater than that which the adapter can directly
    // access then map registers must be used
    //

    maximumPhysicalAddress =
        HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

    if ((ULONGLONG)(logicalAddress.QuadPart + transferLength - 1) >
        (ULONGLONG)maximumPhysicalAddress.QuadPart) {

        logicalAddress.QuadPart = (translationEntry + index)->PhysicalAddress +
                                  pageOffset;
        useBuffer = TRUE;

        if ((UINT_PTR) MapRegisterBase & NO_SCATTER_GATHER) {

            translationEntry->Index = COPY_BUFFER;
            index = 0;

        }

    }

    //
    // Copy the data if necessary.
    //

    if (useBuffer  &&  WriteToDevice) {
        HalpCopyBufferMap(
                         Mdl,
                         translationEntry + index,
                         CurrentVa,
                         transferLength,
                         WriteToDevice
                         );
    }

    //
    // Return the length.
    //

    *Length = transferLength;

    //
    // Return the logical address to transfer to.
    //

    returnAddress = logicalAddress;

    //
    // If no adapter was specificed then there is no more work to do so
    // return.
    //

    ASSERT(AdapterObject == NULL || AdapterObject->MasterDevice);

    return (returnAddress);
}

BOOLEAN
IoFlushAdapterBuffers(
                     IN PADAPTER_OBJECT AdapterObject,
                     IN PMDL Mdl,
                     IN PVOID MapRegisterBase,
                     IN PVOID CurrentVa,
                     IN ULONG Length,
                     IN BOOLEAN WriteToDevice
                     )

/*++

Routine Description:

    This routine flushes the DMA adapter object buffers.  For the Jazz system
    its clears the enable flag which aborts the dma.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
        buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
        or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
        where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
        the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    PTRANSLATION_ENTRY translationEntry;
    PPFN_NUMBER pageFrame;
    ULONG transferLength;
    ULONG partialLength;
    PHYSICAL_ADDRESS maximumPhysicalAddress;
    ULONGLONG maximumPhysicalPage;

    ASSERT(AdapterObject == NULL || AdapterObject->MasterDevice);

    if (MapRegisterBase == NULL) {
        return (TRUE);
    }

    //
    // Determine if the data needs to be copied to the orginal buffer.
    // This only occurs if the data tranfer is from the device, the
    // MapReisterBase is not NULL and the transfer spans a page.
    //

    if (!WriteToDevice) {

        //
        // Strip no scatter/gather flag.
        //

        translationEntry = (PTRANSLATION_ENTRY) ((UINT_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

        //
        // If this is not a master device, then just transfer the buffer.
        //

        if ((UINT_PTR) MapRegisterBase & NO_SCATTER_GATHER) {

            if (translationEntry->Index == COPY_BUFFER) {

                //
                // The adapter does not support scatter/gather copy the buffer.
                //

                HalpCopyBufferMap(
                                 Mdl,
                                 translationEntry,
                                 CurrentVa,
                                 Length,
                                 WriteToDevice
                                 );

            }

        } else {

            //
            // Cycle through the pages of the transfer to determine if there
            // are any which need to be copied back.
            //

            maximumPhysicalAddress =
                HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

            maximumPhysicalPage = (maximumPhysicalAddress.QuadPart >> PAGE_SHIFT);

            transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
            partialLength = transferLength;
            pageFrame = (PPFN_NUMBER)(Mdl+1);
            pageFrame += (((UINT_PTR) CurrentVa - (UINT_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT);

            while ( transferLength <= Length ) {

                if (*pageFrame > maximumPhysicalPage) {

                    HalpCopyBufferMap(
                                     Mdl,
                                     translationEntry,
                                     CurrentVa,
                                     partialLength,
                                     WriteToDevice
                                     );

                }

                (PCCHAR) CurrentVa += partialLength;
                partialLength = PAGE_SIZE;

                //
                // Note that transferLength indicates the amount which will be
                // transfered after the next loop; thus, it is updated with the
                // new partial length.
                //

                transferLength += partialLength;
                pageFrame++;
                translationEntry++;
            }

            //
            // Process the any remaining residue.
            //

            partialLength = Length - transferLength + partialLength;
            if (partialLength && *pageFrame > maximumPhysicalPage) {

                HalpCopyBufferMap(
                                 Mdl,
                                 translationEntry,
                                 CurrentVa,
                                 partialLength,
                                 WriteToDevice
                                 );

            }
        }
    }

    //
    // Strip no scatter/gather flag.
    //

    translationEntry = (PTRANSLATION_ENTRY) ((UINT_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

    //
    // Clear index in map register.
    //

    translationEntry->Index = 0;

    return TRUE;
}

ULONG
HalReadDmaCounter(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    This function reads the DMA counter and returns the number of bytes left
    to be transfered.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object to be read.

Return Value:

    Returns the number of bytes still be be transfered.

--*/

{
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixsleep.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixsleep.h

Abstract:

    This file has all the common headers used
    for saving and restoring context for multiple
    processors.

Author:

    Jake Oshins (jakeo) March 25, 1998

Revision History:

--*/

VOID
HalpSavePicState(
    VOID
    );

VOID
HalpRestorePicState(
    VOID
    );

VOID
HalpRestoreTempPicState(
    VOID
    );

VOID
HalpSaveProcessorStateAndWait(
    IN PKPROCESSOR_STATE ProcessorState,
    IN volatile PULONG   Count
    );

extern PVOID HalpResumeContext;
extern PKPROCESSOR_STATE HalpHiberProcState;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixphwsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixphwsup.c

Abstract:

    This module contains the HalpXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would normally reside in the internal.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "halp.h"
#include "mca.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpAllocateAdapter)
#pragma alloc_text(PAGELK,HalpGrowMapBuffers)
#endif


//
// Some devices require a physically contiguous data buffer for DMA transfers.
// Map registers are used to give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//

PADAPTER_OBJECT MasterAdapterObject;

#define ADAPTER_BASE_MASTER    ((PVOID)-1)

//
// Map buffer prameters.  These are initialized in HalInitSystem.
//

PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
ULONG HalpMapBufferSize;

//
// Define DMA operations structure.
//

DMA_OPERATIONS HalpDmaOperations = {
    sizeof(DMA_OPERATIONS),
    (PPUT_DMA_ADAPTER) HalPutDmaAdapter,
    (PALLOCATE_COMMON_BUFFER) HalAllocateCommonBuffer,
    (PFREE_COMMON_BUFFER) HalFreeCommonBuffer,
    (PALLOCATE_ADAPTER_CHANNEL) HalRealAllocateAdapterChannel,
    (PFLUSH_ADAPTER_BUFFERS) IoFlushAdapterBuffers,
    (PFREE_ADAPTER_CHANNEL) IoFreeAdapterChannel,
    (PFREE_MAP_REGISTERS) IoFreeMapRegisters,
    (PMAP_TRANSFER) IoMapTransfer,
    (PGET_DMA_ALIGNMENT) HalGetDmaAlignment,
    (PREAD_DMA_COUNTER) HalReadDmaCounter,
    (PGET_SCATTER_GATHER_LIST) HalGetScatterGatherList,
    (PPUT_SCATTER_GATHER_LIST) HalPutScatterGatherList,
    (PCALCULATE_SCATTER_GATHER_LIST_SIZE)HalCalculateScatterGatherListSize,
    (PBUILD_SCATTER_GATHER_LIST) HalBuildScatterGatherList,
    (PBUILD_MDL_FROM_SCATTER_GATHER_LIST) HalBuildMdlFromScatterGatherList
    };



BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    )
/*++

Routine Description:

    This function attempts to allocate additional map buffers for use by I/O
    devices.  The map register table is updated to indicate the additional
    buffers.

    Caller owns the HalpNewAdapter event

Arguments:

    AdapterObject - Supplies the adapter object for which the buffers are to be
        allocated.

    Amount - Indicates the size of the map buffers which should be allocated.

Return Value:

    TRUE is returned if the memory could be allocated.

    FALSE is returned if the memory could not be allocated.

--*/
{
    ULONG MapBufferPhysicalAddress;
    PVOID MapBufferVirtualAddress;
    PTRANSLATION_ENTRY TranslationEntry;
    LONG NumberOfPages;
    LONG i;
    PHYSICAL_ADDRESS physicalAddressMinimum;
    PHYSICAL_ADDRESS physicalAddressMaximum;
    PHYSICAL_ADDRESS boundaryAddress;
    KIRQL Irql;
    PVOID CodeLockHandle;
    ULONG maximumBufferPages;
    ULONG bytesToAllocate;

    PAGED_CODE();

    boundaryAddress.QuadPart = 0;

    NumberOfPages = BYTES_TO_PAGES(Amount);

    //
    // Make sure there is room for the additional pages.  The maximum number of
    // slots needed is equal to NumberOfPages + Amount / 64K + 1.
    //

    maximumBufferPages = BYTES_TO_PAGES(MAXIMUM_PCI_MAP_BUFFER_SIZE);

    i = maximumBufferPages - (NumberOfPages +
        (NumberOfPages * PAGE_SIZE) / 0x10000 + 1 +
        AdapterObject->NumberOfMapRegisters);

    if (i < 0) {

        //
        // Reduce the allocation amount so it will fit.
        //

        NumberOfPages += i;
    }

    if (NumberOfPages <= 0) {

        //
        // No more memory can be allocated.
        //

        return(FALSE);
    }

    HalDebugPrint((HAL_VERBOSE, "HGMB: NumberOfPages = %d\n",
                                NumberOfPages));

    if (AdapterObject->NumberOfMapRegisters == 0  && HalpMapBufferSize) {

        NumberOfPages = BYTES_TO_PAGES( HalpMapBufferSize );

        //
        // Since this is the initial allocation, use the buffer allocated by
        // HalInitSystem rather than allocating a new one.
        //

        MapBufferPhysicalAddress = HalpMapBufferPhysicalAddress.LowPart;

        //
        // Map the buffer for access.
        //
        HalDebugPrint((HAL_VERBOSE, "HGMB: MapBufferPhys = %p\n",
                                    HalpMapBufferPhysicalAddress));
        HalDebugPrint((HAL_VERBOSE, "HGMB: MapBufferSize = 0x%x\n",
                                    HalpMapBufferSize));


        MapBufferVirtualAddress = MmMapIoSpace(
            HalpMapBufferPhysicalAddress,
            HalpMapBufferSize,
            TRUE                                // Cache enable.
            );

        if (MapBufferVirtualAddress == NULL) {

            //
            // The buffer could not be mapped.
            //

            HalpMapBufferSize = 0;
            return(FALSE);
        }


    } else {

        //
        // Allocate the map buffers. Restrict to 32-bit range
        // (TRANSLATION_ENTRY is 32-bit)
        //

        physicalAddressMinimum.QuadPart = 0;

        physicalAddressMaximum.LowPart = 0xFFFFFFFF;
        physicalAddressMaximum.HighPart = 0;

        bytesToAllocate = NumberOfPages * PAGE_SIZE;

        MapBufferVirtualAddress =
                MmAllocateContiguousMemorySpecifyCache( bytesToAllocate,
                                                        physicalAddressMinimum,
                                                        physicalAddressMaximum,
                                                        boundaryAddress,
                                                        MmCached );

        if (MapBufferVirtualAddress == NULL) {
            //
            // The allocation attempt failed.
            //

            return FALSE;
        }

        //
        // Get the physical address of the map base.
        //

        MapBufferPhysicalAddress = 
            MmGetPhysicalAddress(MapBufferVirtualAddress).LowPart;

        HalDebugPrint((HAL_VERBOSE, "HGMB: MapBufferVa = %p\n",
                                    MapBufferVirtualAddress));

        HalDebugPrint((HAL_VERBOSE, "HGMB: MapBufferPhysAddr = %p\n",
                                    MapBufferPhysicalAddress));
    }

    //
    // Initialize the map registers where memory has been allocated.
    // Serialize with master adapter object.
    //

    CodeLockHandle = MmLockPagableCodeSection (&HalpGrowMapBuffers);
    KeAcquireSpinLock( &AdapterObject->SpinLock, &Irql );

    TranslationEntry = ((PTRANSLATION_ENTRY) AdapterObject->MapRegisterBase) +
        AdapterObject->NumberOfMapRegisters;

    for (i = 0; (LONG) i < NumberOfPages; i++) {

        //
        // Make sure the perivous entry is physically contiguous with the next
        // entry 
        //

        if (TranslationEntry != AdapterObject->MapRegisterBase &&
            (((TranslationEntry - 1)->PhysicalAddress + PAGE_SIZE) !=
            MapBufferPhysicalAddress)) {

            //
            // An entry needs to be skipped in the table.  This entry will
            // remain marked as allocated so that no allocation of map
            // registers will cross this bountry.
            //

            TranslationEntry++;
            AdapterObject->NumberOfMapRegisters++;
        }

        //
        // Clear the bits where the memory has been allocated.
        //

        HalDebugPrint((HAL_VERBOSE, "HGMB: ClearBits (%p, 0x%x, 0x%x\n",
                      AdapterObject->MapRegisters,
                      (ULONG)(TranslationEntry - (PTRANSLATION_ENTRY)AdapterObject->MapRegisterBase),
                      1));

        RtlClearBits(
            AdapterObject->MapRegisters,
            (ULONG)(TranslationEntry - (PTRANSLATION_ENTRY)
                                         AdapterObject->MapRegisterBase),
            1
            );

        TranslationEntry->VirtualAddress = MapBufferVirtualAddress;
        TranslationEntry->PhysicalAddress = MapBufferPhysicalAddress;
        TranslationEntry++;
        (PCCHAR) MapBufferVirtualAddress += PAGE_SIZE;
        MapBufferPhysicalAddress += PAGE_SIZE;

    }

    //
    // Remember the number of pages that were allocated.
    //

    AdapterObject->NumberOfMapRegisters += NumberOfPages;

    //
    // Release master adapter object.
    //

    KeReleaseSpinLock( &AdapterObject->SpinLock, Irql );
    MmUnlockPagableImageSection (CodeLockHandle);
    return(TRUE);
}

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    phyically contiguous memory pages.

    Caller owns the HalpNewAdapter event


Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
        channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the the DMA controller.

    ChannelNumber - Unused.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{

    PADAPTER_OBJECT AdapterObject;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Size;
    ULONG BitmapSize;
    HANDLE Handle;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(ChannelNumber);

    PAGED_CODE();

    HalDebugPrint((HAL_VERBOSE, "HAA: MapRegistersPerChannel = %d\n",
                      MapRegistersPerChannel));

    HalDebugPrint((HAL_VERBOSE, "HAA: BaseVa = %p\n",
                      AdapterBaseVa));

    //
    // Initalize the master adapter if necessary.
    //

    if (MasterAdapterObject == NULL && AdapterBaseVa != (PVOID) -1 &&
        MapRegistersPerChannel) {

       MasterAdapterObject = HalpAllocateAdapter(
                                          MapRegistersPerChannel,
                                          (PVOID) -1,
                                          NULL
                                          );

       HalDebugPrint((HAL_VERBOSE, "HAA: MasterAdapterObject = %p\n",
                      MasterAdapterObject));

       //
       // If we could not allocate the master adapter then give up.
       //

       if (MasterAdapterObject == NULL) {
          return(NULL);
       }
    }

    //
    // Begin by initializing the object attributes structure to be used when
    // creating the adapter object.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                OBJ_PERMANENT | OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL
                              );

    //
    // Determine the size of the adapter object. If this is the master object
    // then allocate space for the register bit map; otherwise, just allocate
    // an adapter object.
    //

    if (AdapterBaseVa == (PVOID) -1) {

       //
       // Allocate a bit map large enough MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE
       // of map register buffers.
       //

       BitmapSize = (((sizeof( RTL_BITMAP ) +
            ((( MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE ) + 7) >> 3)) + 3) & ~3);

       Size = sizeof( ADAPTER_OBJECT ) + BitmapSize;

    } else {

       Size = sizeof( ADAPTER_OBJECT );

    }

    //
    // Now create the adapter object.
    //

    Status = ObCreateObject( KernelMode,
                             *IoAdapterObjectType,
                             &ObjectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             Size,
                             0,
                             0,
                             (PVOID *)&AdapterObject );

    //
    // Reference the object.
    //

    if (NT_SUCCESS(Status)) {

        Status = ObReferenceObjectByPointer(
            AdapterObject,
            FILE_READ_DATA | FILE_WRITE_DATA,
            *IoAdapterObjectType,
            KernelMode
            );

    }

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the the object table.
    //

    if (NT_SUCCESS( Status )) {

        RtlZeroMemory (AdapterObject, sizeof (ADAPTER_OBJECT));

        Status = ObInsertObject( AdapterObject,
                                 NULL,
                                 FILE_READ_DATA | FILE_WRITE_DATA,
                                 0,
                                 (PVOID *) NULL,
                                 &Handle );

        if (NT_SUCCESS( Status )) {

            ZwClose( Handle );

            //
            // Initialize the adapter object itself.
            //

            AdapterObject->DmaHeader.Version = IO_TYPE_ADAPTER;
            AdapterObject->DmaHeader.Size = (USHORT) Size;
            AdapterObject->MapRegistersPerChannel = 1;
            AdapterObject->AdapterBaseVa = AdapterBaseVa;
            AdapterObject->ChannelNumber = 0xff;
            AdapterObject->DmaHeader.DmaOperations = &HalpDmaOperations;


            if (MapRegistersPerChannel) {

                AdapterObject->MasterAdapter = MasterAdapterObject;

            } else {

                AdapterObject->MasterAdapter = NULL;

            }

            //
            // Initialize the channel wait queue for this
            // adapter.
            //

            KeInitializeDeviceQueue( &AdapterObject->ChannelWaitQueue );

            //
            // If this is the MasterAdatper then initialize register bit map,
            // AdapterQueue and the spin lock.
            //

            if ( AdapterBaseVa == (PVOID) -1 ) {

               KeInitializeSpinLock( &AdapterObject->SpinLock );

               InitializeListHead( &AdapterObject->AdapterQueue );

               AdapterObject->MapRegisters = (PVOID) ( AdapterObject + 1);

               HalDebugPrint((HAL_VERBOSE, "HAA: InitBitMap(%p, %p, 0x%x\n",
                   AdapterObject->MapRegisters,
                   (PULONG)(((PCHAR)(AdapterObject->MapRegisters)) + 
                       sizeof( RTL_BITMAP )),
                   ( MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE )));

               RtlInitializeBitMap ( 
                   AdapterObject->MapRegisters,
                   (PULONG)(((PCHAR)(AdapterObject->MapRegisters)) + 
                       sizeof( RTL_BITMAP )),
                   ( MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE )
                                    );
               //
               // Set all the bits in the memory to indicate that memory
               // has not been allocated for the map buffers
               //

               RtlSetAllBits( AdapterObject->MapRegisters );
               AdapterObject->NumberOfMapRegisters = 0;
               AdapterObject->CommittedMapRegisters = 0;

               //
               // ALlocate the memory map registers.
               //

               AdapterObject->MapRegisterBase = ExAllocatePoolWithTag(
                    NonPagedPool,
                    (MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE) *
                        sizeof(TRANSLATION_ENTRY),
                    HAL_POOL_TAG
                    );

               if (AdapterObject->MapRegisterBase == NULL) {

                   ObDereferenceObject( AdapterObject );
                   AdapterObject = NULL;
                   return(NULL);

               }

               //
               // Zero the map registers.
               //

               RtlZeroMemory(
                    AdapterObject->MapRegisterBase,
                    (MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE) *
                        sizeof(TRANSLATION_ENTRY)
                    );

               if (!HalpGrowMapBuffers(
                        AdapterObject, 
                        INITIAL_MAP_BUFFER_LARGE_SIZE
                                       )
                  )
               {

                   //
                   // If no map registers could be allocated then free the
                   // object.
                   //

                   ObDereferenceObject( AdapterObject );
                   AdapterObject = NULL;
                   return(NULL);

               }
           }

        } else {

            //
            // An error was incurred for some reason.  Set the return value
            // to NULL.
            //

            AdapterObject = (PADAPTER_OBJECT) NULL;
        }
    } else {

        AdapterObject = (PADAPTER_OBJECT) NULL;

    }


    return AdapterObject;

}

ULONG
HalGetDmaAlignment (
    PVOID Conext
    )
{
    return HalGetDmaAlignmentRequirement();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixreboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixreboot.c

Abstract:

    Provides the interface to the firmware for x86.  Since there is no
    firmware to speak of on x86, this is just reboot support.

Author:

    John Vert (jvert) 12-Aug-1991

Revision History:

--*/
#include "halp.h"

//
// Defines to let us diddle the CMOS clock and the keyboard
//

#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64

//
// Private function prototypes
//

VOID
HalpReboot (
    VOID
    );

VOID
HalpReboot (
    VOID
    )

/*++

Routine Description:

    This procedure resets the CMOS clock to the standard timer settings
    so the bios will work, and then issues a reset command to the keyboard
    to cause a warm boot.

    It is very machine dependent, this implementation is intended for
    PC-AT like machines.

    This code copied from the "old debugger" sources.

    N.B.

        Will NOT return.

--*/

{
    UCHAR   Scratch;
    PUSHORT   Magic;
    EFI_STATUS  status;


    //
    // Disable IA64 Errror Handling 
    //

    HalpMCADisable();

    //
    // Instead of the previous code we will use Efi's reset proc (RESET_TYPE = cold boot). 
    //

    status =  HalpCallEfi (
                  EFI_RESET_SYSTEM_INDEX,
                  (ULONGLONG)EfiResetCold,
                  EFI_SUCCESS, 
                  0,           
                  0,
                  0,
                  0,
                  0,
                  0
                  );
     

    HalDebugPrint(( HAL_INFO, "HAL: HalpReboot - returned from HalpCallEfi: %I64X\n", status ));
    
   
    //
    // If we return, send the reset command to the keyboard controller
    //

    WRITE_PORT_UCHAR(KEYBPORT, RESET);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixthrotl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixthrotl.c

Abstract:

    This module implements the code for throttling the processors

Author:

    Jake Oshins (jakeo) 17-July-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "pci.h"


VOID
FASTCALL
HalProcessorThrottle (
    IN UCHAR Throttle
    )
/*++

Routine Description:

    This function limits the speed of the processor.

Arguments:

    (ecx) = Throttle setting

Return Value:

    none

--*/
{
	HalDebugPrint(( HAL_ERROR, "HAL: HalProcessorThrottle - Throttle not yet supported for IA64" ));
    KeBugCheck(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixmca.c ===
/*++

Module Name:

    ixmca.c

Abstract:

    HAL component of the Machine Check Architecture.
    All exported MCA functionality is present in this file.

Author:

    Srikanth Kambhatla (Intel)

Revision History:

    Anil Aggarwal (Intel)
        Changes incorporated as per design review with Microsoft

--*/

#include <bugcodes.h>
#include <halp.h>

#include "check.h"
#include "osmca.h"

//
// Default MCA Bank configuration
//

#define MCA_DEFAULT_BANK_CONF       0xFFFFFFFFFFFFFFFF

//
// Bogus define for -1 sal status return
// to get around the bugcheck on bad status
//
#define SAL_STATUS_BOGUS_RETURN   -1I64

//
// MCA architecture related defines
//

#define MCA_NUM_REGS        4
#define MCA_CNT_MASK        0xFF
#define MCG_CTL_PRESENT     0x100

#define MCE_VALID           0x01

//
// MSR register addresses for MCA
//

#define MCG_CAP             0x179
#define MCG_STATUS          0x17a
#define MCG_CTL             0x17b
#define MC0_CTL             0x400
#define MC0_STATUS          0x401
#define MC0_ADDR            0x402
#define MC0_MISC            0x403

#define PENTIUM_MC_ADDR     0x0
#define PENTIUM_MC_TYPE     0x1

//
// Writing all 1's to MCG_CTL register enables logging.
//
#define MCA_MCGCTL_ENABLE_LOGGING      0xffffffff

//
// Bit interpretation of MCG_STATUS register
//
#define MCG_MC_INPROGRESS       0x4
#define MCG_EIP_VALID           0x2
#define MCG_RESTART_EIP_VALID   0x1

//
// For the function that reads the error reporting bank log, the type of error we
// are interested in
//
#define MCA_GET_ANY_ERROR               0x1
#define MCA_GET_NONRESTARTABLE_ERROR    0x2


//
// Defines for the size of TSS and the initial stack to operate on
//

#define MINIMUM_TSS_SIZE 0x68
#if DBG

//
// If we use DbgPrint, we need bigger stack
//

#define MCA_EXCEPTION_STACK_SIZE 0x1000
#else
#define MCA_EXCEPTION_STACK_SIZE 0x100
#endif // DBG

//
// Global Variables
//

extern KAFFINITY      HalpActiveProcessors;

// pmdata.c: CPE definitions.
extern ULONG          HalpMaxCPEImplemented;

extern UCHAR        MsgCMCPending[];
extern UCHAR        MsgCPEPending[];
extern WCHAR        rgzSessionManager[];
extern WCHAR        rgzEnableMCA[];
extern WCHAR        rgzEnableCMC[];
extern WCHAR        rgzEnableCPE[];
extern WCHAR        rgzNoMCABugCheck[];
extern WCHAR        rgzEnableMCEOemDrivers[];
extern WCHAR        rgzCMCThresholdCount[];
extern WCHAR        rgzCMCThresholdTime[];
extern WCHAR        rgzCPEThresholdCount[];
extern WCHAR        rgzCPEThresholdTime[];

//
// Internal prototypes
//

NTSTATUS
HalpMcaReadProcessorException (
    OUT PMCA_EXCEPTION  Exception,
    IN BOOLEAN  NonRestartableOnly
    );


VOID
HalpMcaGetConfiguration (
    OUT PULONG  MCAEnabled,
    OUT PULONG  CMCEnabled,
    OUT PULONG  CPEEnabled,
    OUT PULONG  NoMCABugCheck,
    OUT PULONG  MCEOemDriversEnabled,
    OUT PULONG  CMCThresholdCount,
    OUT PULONG  CMCThresholdTime,
    OUT PULONG  CPEThresholdCount,
    OUT PULONG  CPEThresholdTime
    );

#define IsMceKernelQuery( _buffer ) \
    ( (((ULONG_PTR)(*((PULONG_PTR)Buffer))) == (ULONG_PTR)HALP_KERNEL_TOKEN) ? TRUE : FALSE )

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpMcaInit)
#pragma alloc_text(INIT, HalpMcaGetConfiguration)
#endif


VOID
HalpMcaInit (
    VOID
    )

/*++
    Routine Description:
        This routine is called to do the initialization of the HAL private
        IA64 ERROR management. Called at end of phase 1 from HalReportResourceUsage().

    Arguments:
        None

    Return Value:
        None
--*/
{
    ULONG MCAEnabled, CMCEnabled, CPEEnabled, NoMCABugCheck, MCEOemDriversEnabled;
    ULONG CMCThresholdCount, CMCThresholdTime;
    ULONG CPEThresholdCount, CPEThresholdTime;
    LARGE_INTEGER TicksPerSecond;

    C_ASSERT( HALP_CMC_MINIMUM_POLLING_INTERVAL > 1 );
    C_ASSERT( HALP_CPE_MINIMUM_POLLING_INTERVAL > 1 );

    //
    // If the default HAL features do not support IA64 Errors handling -
    // defined as the inclusion of MCA, CMC, CPE handling - we return immediately.
    //

    if ( (!(HalpFeatureBits & HAL_MCA_PRESENT)) &&
         (!(HalpFeatureBits & HAL_CMC_PRESENT)) &&
         (!(HalpFeatureBits & HAL_CPE_PRESENT)) )   {
        return;
    }

    //
    // Gather regisry settings for IA64 Errors handling.
    //

    HalpMcaGetConfiguration( &MCAEnabled, &CMCEnabled, &CPEEnabled,
                             &NoMCABugCheck, &MCEOemDriversEnabled,
                             &CMCThresholdCount, &CMCThresholdTime,
                             &CPEThresholdCount, &CPEThresholdTime);

    //
    //
    //

    if ( HalpFeatureBits & HAL_MCA_PRESENT )    {

        if ( !MCAEnabled )  {

            //
            // Registry setting has disabled MCA handling.
            //
            // Thierry 08/00: We ignore this registry setting.
            //

            HalDebugPrint(( HAL_INFO, "HAL: MCA handling is disabled via registry.\n" ));
            HalDebugPrint(( HAL_INFO, "HAL: Disabling MCA handling is ignored currently...\n" ));

        }

        if ( NoMCABugCheck )    {

             //
             // Flag HalpMcaInfo, so HalpMcaBugCheck will not call KeBugCheckEx().
             //

             HalpMcaInfo.NoBugCheck++;
        }

        //
        // Execute other required MCA initialization here...
        //

    }
    else {
        HalDebugPrint(( HAL_INFO, "HAL: MCA handling is disabled.\n" ));
    }

    //
    // At this time of the HAL initialization, the default HAL CMC model is initialized as:
    //    - non-present               if SAL reported invalid CMC max log sizes.
    //    - present & interrupt-based if SAL reported valid   CMC max log sizes.
    //

    KeQueryPerformanceCounter(&TicksPerSecond);

    if ( HalpFeatureBits & HAL_CMC_PRESENT )    {

        if ( CMCEnabled )  {

            if ( (CMCEnabled == HAL_CMC_INTERRUPTS_BASED) || (CMCEnabled == (ULONG)1) )   {

                //
                // In this case, we do not change the default HAL CMC handling.
                //

                if (CMCThresholdCount == 1)
                {
                    //
                    // At a minimum we need to track receiving 2 in a row.
                    //
                    CMCThresholdCount = 2;
                }
                HalpCmcInfo.ThresholdMaximum = CMCThresholdCount;

                //
                // ThresholdTime is in units of 100ns (1ns = 10-9 sec)
                //
                HalpCmcInfo.ThresholdTime.QuadPart = (CMCThresholdTime *
                                                      TicksPerSecond.QuadPart);

            }
            else  {

                //
                // Registry setting enables CMC Polling mode.
                // Polling interval is registry specified value with mininum value
                // checked with HAL_CMC_MINIMUM_POLLING_INTERVAL.
                //

                if ( CMCEnabled < HALP_CMC_MINIMUM_POLLING_INTERVAL )   {
                    CMCEnabled = HALP_CMC_MINIMUM_POLLING_INTERVAL;
                }

                HalDebugPrint(( HAL_INFO, "HAL: CMC Polling mode enabled via registry.\n" ));
                HalpCMCDisableForAllProcessors();
                HalpCmcInfo.Stats.PollingInterval = CMCEnabled;

            }

        }
        else   {

            //
            // Registry setting has disabled CMC handling.
            //

            HalDebugPrint(( HAL_INFO, "HAL: CMC handling is disabled via registry.\n" ));
            HalpCMCDisableForAllProcessors();
            HalpFeatureBits &= ~HAL_CMC_PRESENT;

        }

        //
        // Execute other required CMC initialization here...
        //

    }
    else  {
        HalDebugPrint(( HAL_INFO, "HAL: CMC handling is disabled.\n" ));
    }

    //
    // At this time of the HAL initialization, the default HAL CPE model is initialized as:
    //    - non-present               if SAL reported invalid CPE max log sizes.
    //    - present & interrupt-based if SAPIC Platform Interrupt Sources exist.
    //    - present & polled-based    if there is no SAPIC Platform Interrupt Source.
    //                                Polling interval is: HALP_CPE_DEFAULT_POLLING_INTERVAL.
    //

    if ( HalpFeatureBits & HAL_CPE_PRESENT )    {

        if ( CPEEnabled )   {

            if ( (CPEEnabled == HAL_CPE_INTERRUPTS_BASED) || (CPEEnabled == (ULONG)1) )   {

                //
                // In this case, we do not change the default HAL CPE handling.
                //

                if ( HalpMaxCPEImplemented == 0 )   {

                    HalDebugPrint(( HAL_INFO, "HAL: registry setting enabling CPE interrupt mode but no platform interrupt sources.\n" ));

                } else {
                    if (CPEThresholdCount == 1)
                    {
                        //
                        // At a minimum we need to track receiving 2 in a row
                        //
                        CPEThresholdCount = 2;
                    }
                    HalpCpeInfo.ThresholdMaximum = CPEThresholdCount;

                    //
                    // ThresholdTime is in units of 100ns (1ns = 10-9 sec)
                    //
                    HalpCpeInfo.ThresholdTime.QuadPart = (CPEThresholdTime *
                                                          TicksPerSecond.QuadPart);
                }
            }
            else  {

                //
                // Registry setting enables CPE Polling mode.
                // Polling interval is registry specified value with mininum value
                // checked with HAL_CPE_MINIMUM_POLLING_INTERVAL.
                //

                if ( CPEEnabled < HALP_CPE_MINIMUM_POLLING_INTERVAL )   {
                    CPEEnabled = HALP_CPE_MINIMUM_POLLING_INTERVAL;
                }

                HalDebugPrint(( HAL_INFO, "HAL: CPE Polling mode enabled via registry.\n" ));
                HalpCPEDisable();
                HalpCpeInfo.Stats.PollingInterval = CPEEnabled;

            }

        }
        else  {

            //
            // Registry setting has disabled CPE handling.
            //

            HalDebugPrint(( HAL_INFO, "HAL: CPE handling is disabled via registry.\n" ));
            HalpCPEDisable();
            HalpFeatureBits &= ~HAL_CPE_PRESENT;
            HalpCpeInfo.Stats.PollingInterval = HAL_CPE_DISABLED;

        }

        //
        // Execute other required CPE initialization here...
        //

    }
    else  {
        HalDebugPrint(( HAL_INFO, "HAL: CPE handling is disabled.\n" ));
    }

    //
    // 06/09/01: OEM MCE Drivers registration is disabled by default in the HAL and
    //           should be enabled using the registry. See HalpMcaGetConfiguration().
    //           This was decided by the MS IA64 MCA Product Manager for Windows XP,
    //           after consideration of the IA64 platforms FWs and little testing done
    //           on this path.
    //

    if ( MCEOemDriversEnabled ) {
        HalpFeatureBits |= HAL_MCE_OEMDRIVERS_ENABLED;
        HalDebugPrint(( HAL_INFO, "HAL: OEM MCE Drivers registration enabled via registry.\n" ));
    }

    //
    // Initialize HALP_INFO required members.
    // This is done regardless of the enabled set of features.
    //

    HalpInitializeMceMutex();
    HalpInitializeMcaInfo();
    HalpInitializeInitMutex();
    HalpInitializeCmcInfo();
    HalpInitializeCpeInfo();

    return;

} // HalpMcaInit()

NTSTATUS
HalpMceRegisterKernelDriver(
    IN PKERNEL_ERROR_HANDLER_INFO DriverInfo,
    IN ULONG                      InfoSize
    )
/*++
    Routine Description:
        This routine is called by the kernel (via HalSetSystemInformation)
        to register its presence. This is mostly for WMI callbacks registration.

    Arguments:
        DriverInfo: Contains kernel info about the callbacks and associated objects.

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.

    Implementation Notes:
        - the current implementation assumes the kernel registers its callbacks
          earlier than a driver will. The current kernel registration is done by
          WMI and should be done at WMI-Phase 0.
        - the registrations do not consider if the HAL supports or not the MCA,CMC,CPE
          functionalities. It simply registers the callbacks if no other callback was
          registered before. This allows us to allow some flexibility if a machine event
          functionality is enabled AFTER the hal initialization (e.g. HalpGetFeatureBits())
          through the mean of a registry key or driver event, for example.

--*/

{
    NTSTATUS status;
    NTSTATUS statusMcaRegistration;
    NTSTATUS statusCmcRegistration;
    NTSTATUS statusCpeRegistration;

    PAGED_CODE();

    if ( !DriverInfo )  {
        status = STATUS_INVALID_PARAMETER;
        return status;
    }

    //
    // Backward compatibility only.
    //

    if ( DriverInfo->Version && (DriverInfo->Version > KERNEL_ERROR_HANDLER_VERSION) )  {
        status = STATUS_REVISION_MISMATCH;
        return status;
    }

    statusMcaRegistration = statusCmcRegistration = statusCpeRegistration = STATUS_UNSUCCESSFUL;

    //
    // Acquire HAL-wide mutex for MCA/CMC/CPE operations.
    //


    //
    // Register Kernel MCA notification.
    //

    HalpAcquireMcaMutex();
    if ( !HalpMcaInfo.KernelDelivery ) {
        HalpMcaInfo.KernelDelivery = DriverInfo->KernelMcaDelivery;
        statusMcaRegistration = STATUS_SUCCESS;
    }
    HalpReleaseMcaMutex();

    //
    // Register Kernel CMC notification.
    //

    HalpAcquireCmcMutex();
    if ( !HalpCmcInfo.KernelDelivery ) {
        HalpCmcInfo.KernelDelivery = DriverInfo->KernelCmcDelivery;
        statusCmcRegistration = STATUS_SUCCESS;
    }
    HalpReleaseCmcMutex();

    //
    // Register Kernel CPE notification.
    //

    HalpAcquireCpeMutex();
    if ( !HalpCpeInfo.KernelDelivery ) {
        HalpCpeInfo.KernelDelivery = DriverInfo->KernelCpeDelivery;
        statusCpeRegistration = STATUS_SUCCESS;
    }
    HalpReleaseCpeMutex();

    //
    // Register Kernel MCE notification.
    //

    HalpAcquireMceMutex();
    if ( !HalpMceKernelDelivery )    {
        HalpMceKernelDelivery = DriverInfo->KernelMceDelivery;
    }
    HalpReleaseMceMutex();

    //
    // If Kernel-WMI MCA registration was sucessful and we have Previous logs, notify the
    // Kernel-WMI component before returning.
    //

    if ( (statusMcaRegistration == STATUS_SUCCESS) && HalpMcaInfo.Stats.McaPreviousCount )  {
        InterlockedExchange( &HalpMcaInfo.DpcNotification, 1 );
    }

    //
    // return status determined by the success of the different registrations.
    //
    // Note: the 'OR'ing is valid because STATUS_SUCCESS and STATUS_UNSUCCESSFUL are only used.
    //

    status = (NTSTATUS)(statusMcaRegistration | statusCmcRegistration | statusCpeRegistration);
    return status;

} // HalpMceRegisterKernelDriver()

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO DriverInfo
    )
/*++
    Routine Description:
        This routine is called by the driver (via HalSetSystemInformation)
        to register its presence. Only one driver can be registered at a time.

    Arguments:
        DriverInfo: Contains info about the callback routine and the DeviceObject

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.
--*/

{
    NTSTATUS    status;

    PAGED_CODE();

    status = STATUS_UNSUCCESSFUL;

    if ( (HalpFeatureBits & (HAL_MCE_OEMDRIVERS_ENABLED | HAL_MCA_PRESENT)) !=
         (HAL_MCE_OEMDRIVERS_ENABLED | HAL_MCA_PRESENT) )  {

        return STATUS_UNSUCCESSFUL;
    }

    if (DriverInfo->DpcCallback != NULL) {

        HalpAcquireMcaMutex();

        //
        // Register driver
        //

        if ( !HalpMcaInfo.DriverInfo.DpcCallback ) {

            //
            // Initialize the DPC object
            //

            KeInitializeDpc(
                &HalpMcaInfo.DriverDpc,
                DriverInfo->DpcCallback,
                DriverInfo->DeviceContext
                );

            //
            // register driver
            //

            HalpMcaInfo.DriverInfo.ExceptionCallback = DriverInfo->ExceptionCallback;
            HalpMcaInfo.DriverInfo.DpcCallback       = DriverInfo->DpcCallback;
            HalpMcaInfo.DriverInfo.DeviceContext     = DriverInfo->DeviceContext;
            status = STATUS_SUCCESS;
        }

        HalpReleaseMcaMutex();
    }
    else  {

        //
        // Deregistring the callbacks is the only allowed operation.
        //

        HalpAcquireMcaMutex();

        if (HalpMcaInfo.DriverInfo.DeviceContext == DriverInfo->DeviceContext) {
            HalpMcaInfo.DriverInfo.ExceptionCallback = NULL;
            HalpMcaInfo.DriverInfo.DpcCallback = NULL;
            HalpMcaInfo.DriverInfo.DeviceContext = NULL;
            status = STATUS_SUCCESS;
        }

        HalpReleaseMcaMutex();

    }

    return status;

} // HalpMcaRegisterDriver()

NTSTATUS
HalpCmcRegisterDriver(
    IN PCMC_DRIVER_INFO DriverInfo
    )
/*++
    Routine Description:
        This routine is called by the driver (via HalSetSystemInformation)
        to register its presence. Only one driver can be registered at a time.

    Arguments:
        DriverInfo: Contains info about the callback routine and the DeviceObject

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.
--*/

{
    NTSTATUS    status;

    PAGED_CODE();

    status = STATUS_UNSUCCESSFUL;

    if ( (HalpFeatureBits & (HAL_MCE_OEMDRIVERS_ENABLED | HAL_CMC_PRESENT)) !=
         (HAL_MCE_OEMDRIVERS_ENABLED | HAL_CMC_PRESENT) )  {

        return STATUS_UNSUCCESSFUL;
    }

    if (DriverInfo->DpcCallback != NULL) {

        HalpAcquireCmcMutex();

        //
        // Register driver
        //

        if ( !HalpCmcInfo.DriverInfo.DpcCallback ) {

            //
            // Initialize the DPC object
            //

            KeInitializeDpc(
                &HalpCmcInfo.DriverDpc,
                DriverInfo->DpcCallback,
                DriverInfo->DeviceContext
                );

            //
            // register driver
            //

            HalpCmcInfo.DriverInfo.ExceptionCallback = DriverInfo->ExceptionCallback;
            HalpCmcInfo.DriverInfo.DpcCallback = DriverInfo->DpcCallback;
            HalpCmcInfo.DriverInfo.DeviceContext = DriverInfo->DeviceContext;
            status = STATUS_SUCCESS;
        }

        HalpReleaseCmcMutex();

    } else {

        //
        // Deregistring the callbacks is the only allowed operation.
        //

        HalpAcquireCmcMutex();

        if (HalpCmcInfo.DriverInfo.DeviceContext == DriverInfo->DeviceContext) {
            HalpCmcInfo.DriverInfo.ExceptionCallback = NULL;
            HalpCmcInfo.DriverInfo.DpcCallback = NULL;
            HalpCmcInfo.DriverInfo.DeviceContext = NULL;
            status = STATUS_SUCCESS;
        }

        HalpReleaseCmcMutex();

    }

    return status;

} // HalpCmcRegisterDriver()

NTSTATUS
HalpCpeRegisterDriver(
    IN PCPE_DRIVER_INFO DriverInfo
    )
/*++
    Routine Description:
        This routine is called by the driver (via HalSetSystemInformation)
        to register its presence. Only one driver can be registered at a time.

    Arguments:
        DriverInfo: Contains info about the callback routine and the DeviceObject

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.
--*/

{
    NTSTATUS    status;

    PAGED_CODE();

    status = STATUS_UNSUCCESSFUL;

    if ( (HalpFeatureBits & (HAL_MCE_OEMDRIVERS_ENABLED | HAL_CPE_PRESENT)) !=
         (HAL_MCE_OEMDRIVERS_ENABLED | HAL_CPE_PRESENT) )  {

        return STATUS_UNSUCCESSFUL;
    }

    if (DriverInfo->DpcCallback != NULL) {

        HalpAcquireCpeMutex();

        //
        // Register driver
        //

        if ( !HalpCpeInfo.DriverInfo.DpcCallback ) {

            //
            // Initialize the DPC object
            //

            KeInitializeDpc(
                &HalpCpeInfo.DriverDpc,
                DriverInfo->DpcCallback,
                DriverInfo->DeviceContext
                );

            //
            // register driver
            //

            HalpCpeInfo.DriverInfo.ExceptionCallback = DriverInfo->ExceptionCallback;
            HalpCpeInfo.DriverInfo.DpcCallback = DriverInfo->DpcCallback;
            HalpCpeInfo.DriverInfo.DeviceContext = DriverInfo->DeviceContext;
            status = STATUS_SUCCESS;
        }

        HalpReleaseCpeMutex();
    } else {

        //
        // Deregistring the callbacks is the only allowed operation.
        //

        HalpAcquireCpeMutex();

        if (HalpCpeInfo.DriverInfo.DeviceContext == DriverInfo->DeviceContext) {
            HalpCpeInfo.DriverInfo.ExceptionCallback = NULL;
            HalpCpeInfo.DriverInfo.DpcCallback = NULL;
            HalpCpeInfo.DriverInfo.DeviceContext = NULL;
            status = STATUS_SUCCESS;
        }

        HalpReleaseCpeMutex();

    }

    return status;

} // HalpCpeRegisterDriver()

VOID
HalpSaveMceLog(
    IN PHALP_MCELOGS_HEADER LogsHeader,
    IN PERROR_RECORD_HEADER Record,
    IN ULONG                RecordLength
    )
{
    PSINGLE_LIST_ENTRY entry, previousEntry;
    PERROR_RECORD_HEADER  savedLog;

    if ( LogsHeader->Count >= LogsHeader->MaxCount )    {
        LogsHeader->Overflow++;
        return;
    }

    entry = ExAllocatePoolWithTag( PagedPool, RecordLength + sizeof(*entry), LogsHeader->Tag );
    if ( !entry )   {
        LogsHeader->AllocateFails++;
        return;
    }
    entry->Next = NULL;

    previousEntry = &LogsHeader->Logs;
    while( previousEntry->Next != NULL )    {
        previousEntry = previousEntry->Next;
    }
    previousEntry->Next = entry;

    savedLog = HalpMceLogFromListEntry( entry );
    RtlCopyMemory( savedLog, Record, RecordLength );

    LogsHeader->Count++;

    return;

} // HalpSaveMceLog()

PSINGLE_LIST_ENTRY
HalpGetSavedMceLog(
    PHALP_MCELOGS_HEADER  LogsHeader,
    PSINGLE_LIST_ENTRY   *LastEntry
    )
{
    PSINGLE_LIST_ENTRY entry, previousEntry;

    ASSERTMSG( "HAL!HalpGetSavedMceLog: LogsHeader->Count = 0!\n", LogsHeader->Count );

    entry      = NULL;
    *LastEntry = previousEntry = &LogsHeader->Logs;
    while( previousEntry->Next )  {
        entry = previousEntry;
        previousEntry = previousEntry->Next;
    }
    if ( entry )    {
        *LastEntry = entry;
        return( previousEntry );
    }
    return( NULL );

} // HalpGetSavedMceLog()

NTSTATUS
HalpGetFwMceLog(
    ULONG                MceType,
    PERROR_RECORD_HEADER Record,
    PHALP_MCELOGS_STATS  MceLogsStats,
    BOOLEAN              DoClearLog
    )
{
    NTSTATUS              status;
    SAL_PAL_RETURN_VALUES rv;
    LONGLONG              salStatus;
    PERROR_RECORD_HEADER  log;


    //
    // Get the currently pending Machine Check Event log.
    //
    log = Record;
    rv = HalpGetStateInfo( MceType, log );
    salStatus = rv.ReturnValues[0];
    if ( salStatus < 0 )    {

        //
        // SAL_GET_STATE_INFO failed.
        //
        if ( salStatus == SAL_STATUS_NO_INFORMATION_AVAILABLE || salStatus == SAL_STATUS_BOGUS_RETURN) {
            return ( STATUS_NOT_FOUND );
        }

        MceLogsStats->GetStateFails++;
        if ( HalpMceKernelDelivery )    {
            HalpMceKernelDelivery(
                   HalpMceDeliveryArgument1( KERNEL_MCE_OPERATION_GET_STATE_INFO, MceType ),
                   MceNotification,
                   (PVOID)(ULONG_PTR)salStatus );
        }

        return( STATUS_UNSUCCESSFUL );
    }

    status = STATUS_SUCCESS;

    if ( DoClearLog )   {
        static ULONGLONG currentClearedLogCount = 0UI64;

        rv = HalpClearStateInfo( MceType );
        salStatus = rv.ReturnValues[0];
        if ( salStatus < 0 )  {

            //
            // SAL_CLEAR_STATE_INFO failed.
            //
            // We do not modify the status of the log collection. It is still sucessful.
            //

            if ( MceType == MCA_EVENT ) {

                //
                // Current consideration for this implementation - 08/2000:
                // if clearing the MCA log event fails, we assume that FW has a real
                // problem; Continuing will be dangerous. We bugcheck.
                //

                HalpMcaKeBugCheckEx( HAL_BUGCHECK_MCA_CLEAR_STATEINFO, (PMCA_EXCEPTION)log,
                                                                       HalpMcaInfo.Stats.MaxLogSize,
                                                                       salStatus );
                // no-return
            }
            else  {

                //
                // The SAL CLEAR_STATE_INFO interface failed.
                // However, we consider that for this event type, it is not worth bugchecking
                // the system. We clearly flag it and notify the kernel-WMI if the callback was
                // registered.
                //

                MceLogsStats->ClearStateFails++;
                if ( HalpMceKernelDelivery )    {
                    HalpMceKernelDelivery(
                        HalpMceDeliveryArgument1( KERNEL_MCE_OPERATION_CLEAR_STATE_INFO, MceType ),
                        MceNotification,
                        (PVOID)(ULONG_PTR)salStatus );
                }
            }
        }
        else if ( salStatus == SAL_STATUS_SUCCESS_MORE_RECORDS )    {
            status = STATUS_MORE_ENTRIES;
        }

        //
        // We are saving the record id. This is a unique monotically increasing ID.
        // This is mostly to check that we are not getting the same log because of
        // SAL_CLEAR_STATE_INFO failure. Note that we have tried to clear it again.
        //

        if ( currentClearedLogCount && (log->Id == MceLogsStats->LogId) ) {
            status = STATUS_ALREADY_COMMITTED;
        }
        MceLogsStats->LogId = log->Id;
        currentClearedLogCount++;

    }

    //
    // Last sanity check on the record. This is to help the log saving processing and the
    // detection of invalid records.
    //

    if ( log->Length < sizeof(*log) ) { // includes Length == 0.
        status = STATUS_BAD_DESCRIPTOR_FORMAT;
    }

    return( status );

} // HalpGetFwMceLog()

NTSTATUS
HalpGetMcaLog (
    OUT PMCA_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    )
/*++

Routine Description:

    This function is called by HaliQuerySysteminformation for the HalMcaLogInformation class.
    It provides a MCA log to the caller.

Arguments:

    Buffer        : Buffer into which the error is reported
    BufferSize    : Size of the passed buffer
    ReturnedLength: Length of the log.

Return Value:

    Success or failure

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;

    PAGED_CODE();

    //
    // If MCA is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_MCA_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Assertions for the HAL MCA implementation.
    //

    ASSERTMSG( "HAL!HalpGetMcaLog: ReturnedLength NULL!\n", ReturnedLength );
    ASSERTMSG( "HAL!HalpGetMcaLog: HalpMcaInfo.MaxLogSize 0!\n", HalpMcaInfo.Stats.MaxLogSize );
    ASSERTMSG( "HAL!HalpGetMcaLog: HalpMcaInfo.MaxLogSize < sizeof(ERROR_RECORD_HEADER)!\n",
                                    HalpMcaInfo.Stats.MaxLogSize >= sizeof(ERROR_RECORD_HEADER) );

    //
    // Let's the caller know about its passed buffer size or the minimum required size.
    //

    maxLogSize = HalpMcaInfo.Stats.MaxLogSize;
    if ( BufferSize < maxLogSize )  {
        *ReturnedLength = maxLogSize;
        return( STATUS_INVALID_BUFFER_SIZE );
    }

    //
    // Determine if the caller is the kernel-WMI.
    //

    kernelQuery = IsMceKernelQuery( Buffer );
    logsHeader = ( kernelQuery ) ? &HalpMcaInfo.KernelLogs : &HalpMcaInfo.DriverLogs;

    //
    // Enable MP protection for MCA logs accesses
    //

    status = STATUS_NOT_FOUND;
    HalpAcquireMcaMutex();

    //
    // If saved logs exist, pop an entry.
    //

    if ( logsHeader->Count ) {
        PSINGLE_LIST_ENTRY entry, lastEntry;

        entry = HalpGetSavedMceLog( logsHeader, &lastEntry );
        if ( entry )  {
            PERROR_RECORD_HEADER savedLog;
            ULONG length;

            savedLog = HalpMceLogFromListEntry( entry );
            length   = savedLog->Length;
            if ( length <= BufferSize )  {
                ULONG logsCount;

                RtlCopyMemory( Buffer, savedLog, length );
                ExFreePoolWithTag( entry, logsHeader->Tag );
                lastEntry->Next = NULL;
                logsCount = (--logsHeader->Count);
                HalpReleaseMcaMutex();
                *ReturnedLength = length;
                if ( logsCount )   {
                   return( STATUS_MORE_ENTRIES );
                }
                else   {
                   return( STATUS_SUCCESS );
                }
            }
            else   {
                HalpReleaseMcaMutex();
                *ReturnedLength = length;
                return( STATUS_INVALID_BUFFER_SIZE );
            }
        }
    }

    //
    // Initalize local log pointer after memory allocation if required.
    //

    if ( kernelQuery ) {
        log = (PERROR_RECORD_HEADER)Buffer;
    }
    else  {

        //
        // The OEM CMC driver HAL interface does not require the CMC driver memory
        // for the log buffer to be allocated from NonPagedPool.
        // Also, MM does not export memory pool type checking APIs.
        // It is safer to allocate in NonPagedPool and pass this buffer to the SAL.
        // If the SAL interface is sucessful, we will copy the buffer to the caller's buffer.
        //

        log = ExAllocatePoolWithTag( NonPagedPool, maxLogSize, 'TacM' );
        if ( log == NULL ) {
            HalpReleaseMcaMutex();
            return( STATUS_NO_MEMORY );
        }
    }

    //
    // We did not have any saved log, check if we have notified that FW has logs from
    // previous MCAs or corrected MCAs.
    //

    activeProcessors = HalpActiveProcessors;
    for (currentAffinity = 1; activeProcessors; currentAffinity <<= 1) {

        if (activeProcessors & currentAffinity) {

            activeProcessors &= ~currentAffinity;
            KeSetSystemAffinityThread(currentAffinity);

            status = HalpGetFwMceLog( MCA_EVENT, log, &HalpMcaInfo.Stats, HALP_FWMCE_DO_CLEAR_LOG );
            if ( NT_SUCCESS( status ) ||
                 ( (status != STATUS_NOT_FOUND) && (status != STATUS_ALREADY_COMMITTED) ) ) {
                break;
            }
        }
    }

    if ( NT_SUCCESS( status ) ) {
        ULONG length = log->Length; // Note: Length was checked in HalpGetMceLog().

        if ( kernelQuery ) {
            if ( HalpMcaInfo.DriverInfo.DpcCallback )   {
                HalpSaveMceLog( &HalpMcaInfo.DriverLogs, log, length );
            }
        }
        else  {
            RtlCopyMemory( Buffer, log, length );
            if ( HalpMcaInfo.KernelDelivery )   {
                HalpSaveMceLog( &HalpMcaInfo.KernelLogs, log, length );
            }
        }
        *ReturnedLength = length;
    }

    //
    // Restore threads affinity, release mutex.
    //

    KeRevertToUserAffinityThread();
    HalpReleaseMcaMutex();

    //
    // If the caller is not the Kernel-WMI, free the allocated NonPagedPool log.
    //

    if ( !kernelQuery ) {
        ExFreePoolWithTag( log, 'TacM' );
    }

    return status;

} // HalpGetMcaLog()

NTSTATUS
HalpGetCmcLog (
    OUT PCMC_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    )
/*++

Routine Description:

   This function is called by HaliQuerySysteminformation for the HalCmcLogInformation class.
   It provides a CMC log to the caller.

Arguments:

   Buffer        : Buffer into which the error is reported
   BufferSize    : Size of the passed buffer
   ReturnedLength: Length of the log. This pointer was validated by caller.

Return Value:

   Success or failure

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;

    PAGED_CODE();

    //
    // If CMC is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_CMC_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Assertions for the HAL CMC implementation.
    //

    ASSERTMSG( "HAL!HalpGetCmcLog: ReturnedLength NULL!\n", ReturnedLength );
    ASSERTMSG( "HAL!HalpGetCmcLog: HalpCmcInfo.MaxLogSize 0!\n", HalpCmcInfo.Stats.MaxLogSize );
    ASSERTMSG( "HAL!HalpGetCmcLog: HalpCmcInfo.MaxLogSize < sizeof(ERROR_RECORD_HEADER)!\n",
                                    HalpCmcInfo.Stats.MaxLogSize >= sizeof(ERROR_RECORD_HEADER) );

    //
    // Let's the caller know about its passed buffer size or the minimum required size.
    //

    maxLogSize = HalpCmcInfo.Stats.MaxLogSize;
    if ( BufferSize < maxLogSize )  {
        *ReturnedLength = maxLogSize;
        return( STATUS_INVALID_BUFFER_SIZE );
    }

    //
    // Determine if the caller is the kernel-WMI.
    //

    kernelQuery = IsMceKernelQuery( Buffer );
    logsHeader = ( kernelQuery ) ? &HalpCmcInfo.KernelLogs : &HalpCmcInfo.DriverLogs;

    //
    // Enable MP protection for CMC logs accesses
    //

    status = STATUS_NOT_FOUND;
    HalpAcquireCmcMutex();

    //
    // If saved logs exist, pop an entry.
    //

    if ( logsHeader->Count ) {
        PSINGLE_LIST_ENTRY entry, lastEntry;

        entry = HalpGetSavedMceLog( logsHeader, &lastEntry );
        if ( entry )  {
            PERROR_RECORD_HEADER savedLog;
            ULONG length;

            savedLog = HalpMceLogFromListEntry( entry );
            length   = savedLog->Length;
            if ( length <= BufferSize )  {
                ULONG logsCount;

                RtlCopyMemory( Buffer, savedLog, length );
                ExFreePoolWithTag( entry, logsHeader->Tag );
                lastEntry->Next = NULL;
                logsCount = (--logsHeader->Count);
                HalpReleaseCmcMutex();
                *ReturnedLength = length;
                if ( logsCount )   {
                   return( STATUS_MORE_ENTRIES );
                }
                else   {
                   return( STATUS_SUCCESS );
                }
            }
            else   {
                HalpReleaseCmcMutex();
                *ReturnedLength = length;
                return( STATUS_INVALID_BUFFER_SIZE );
            }
        }
    }

    //
    // Initalize local log pointer after memory allocation if required.
    //

    if ( kernelQuery ) {
        log = (PERROR_RECORD_HEADER)Buffer;
    }
    else  {

        //
        // The OEM CMC driver HAL interface does not require the CMC driver memory
        // for the log buffer to be allocated from NonPagedPool.
        // Also, MM does not export memory pool type checking APIs.
        // It is safer to allocate in NonPagedPool and pass this buffer to the SAL.
        // If the SAL interface is sucessful, we will copy the buffer to the caller's buffer.
        //

        log = ExAllocatePoolWithTag( NonPagedPool, maxLogSize, 'TcmC' );
        if ( log == NULL ) {
            HalpReleaseCmcMutex();
            return( STATUS_NO_MEMORY );
        }
    }

    //
    // We did not have any saved log, migrate from 1 processor to another to collect
    // the FW logs.
    //

    activeProcessors = HalpActiveProcessors;
    for (currentAffinity = 1; activeProcessors; currentAffinity <<= 1) {

        if (activeProcessors & currentAffinity) {

            activeProcessors &= ~currentAffinity;
            KeSetSystemAffinityThread(currentAffinity);

            status = HalpGetFwMceLog( CMC_EVENT, log, &HalpCmcInfo.Stats, HALP_FWMCE_DO_CLEAR_LOG );
            if ( NT_SUCCESS( status ) ||
                 ( (status != STATUS_NOT_FOUND) && (status != STATUS_ALREADY_COMMITTED) ) ) {
                break;
            }
        }
    }

    if ( NT_SUCCESS( status ) ) {
        ULONG length = log->Length; // Note: Length was checked in HalpGetMceLog().

        if ( kernelQuery ) {
            if ( HalpCmcInfo.DriverInfo.DpcCallback )   {
                HalpSaveMceLog( &HalpCmcInfo.DriverLogs, log, length );
            }
        }
        else  {
            RtlCopyMemory( Buffer, log, length );
            if ( HalpCmcInfo.KernelDelivery )   {
                HalpSaveMceLog( &HalpCmcInfo.KernelLogs, log, length );
            }
        }
        *ReturnedLength = length;
    }

    //
    // Restore threads affinity, release mutex.
    //

    KeRevertToUserAffinityThread();
    HalpReleaseCmcMutex();

    //
    // If the caller is not the Kernel-WMI, free the allocated NonPagedPool log.
    //

    if ( !kernelQuery ) {
        ExFreePoolWithTag( log, 'TcmC' );
    }

    return status;

} // HalpGetCmcLog()

NTSTATUS
HalpGetCpeLog (
    OUT PCPE_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    )
/*++

Routine Description:

    This function is called by HaliQuerySysteminformation for the HalCpeLogInformation class.
    It provides a CPE log to the caller.

Arguments:

    Buffer        : Buffer into which the error is reported
    BufferSize    : Size of the passed buffer
    ReturnedLength: Length of the log. This pointer was validated by caller.

Return Value:

    Success or failure

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;

    PAGED_CODE();

    //
    // If CPE is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_CPE_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Assertions for the HAL CPE implementation.
    //

    ASSERTMSG( "HAL!HalpGetCpeLog: ReturnedLength NULL!\n", ReturnedLength );
    ASSERTMSG( "HAL!HalpGetCpeLog: HalpCpeInfo.MaxLogSize 0!\n", HalpCpeInfo.Stats.MaxLogSize );
    ASSERTMSG( "HAL!HalpGetCpeLog: HalpCpeInfo.MaxLogSize < sizeof(ERROR_RECORD_HEADER)!\n",
                                 HalpCpeInfo.Stats.MaxLogSize >= sizeof(ERROR_RECORD_HEADER) );

    //
    // Let's the caller know about its passed buffer size or the minimum required size.
    //

    maxLogSize = HalpCpeInfo.Stats.MaxLogSize;
    if ( BufferSize < maxLogSize )  {
        *ReturnedLength = maxLogSize;
        return( STATUS_INVALID_BUFFER_SIZE );
    }

    //
    // Determine if the caller is the kernel-WMI.
    //

    kernelQuery = IsMceKernelQuery( Buffer );
    logsHeader = ( kernelQuery ) ? &HalpCpeInfo.KernelLogs : &HalpCpeInfo.DriverLogs;

    //
    // Enable MP protection for CPE logs accesses
    //

    status = STATUS_NOT_FOUND;
    HalpAcquireCpeMutex();

    //
    // If saved logs exist, pop an entry.
    //

    if ( logsHeader->Count ) {
        PSINGLE_LIST_ENTRY entry, lastEntry;

        entry = HalpGetSavedMceLog( logsHeader, &lastEntry );
        if ( entry )  {
            PERROR_RECORD_HEADER savedLog;
            ULONG length;

            savedLog = HalpMceLogFromListEntry( entry );
            length   = savedLog->Length;
            if ( length <= BufferSize )  {
                ULONG logsCount;

                RtlCopyMemory( Buffer, savedLog, length );
                ExFreePoolWithTag( entry, logsHeader->Tag );
                lastEntry->Next = NULL;
                logsCount = (--logsHeader->Count);
                HalpReleaseCpeMutex();
                *ReturnedLength = length;
                if ( logsCount )   {
                   return( STATUS_MORE_ENTRIES );
                }
                else   {
                   return( STATUS_SUCCESS );
                }
            }
            else   {
                HalpReleaseCpeMutex();
                *ReturnedLength = length;
                return( STATUS_INVALID_BUFFER_SIZE );
            }
        }
    }

    //
    // Initalize local log pointer after memory allocation if required.
    //

    if ( kernelQuery ) {
        log = (PERROR_RECORD_HEADER)Buffer;
    }
    else  {

        //
        // The OEM CPE driver HAL interface does not require the CPE driver memory
        // for the log buffer to be allocated from NonPagedPool.
        // Also, MM does not export memory pool type checking APIs.
        // It is safer to allocate in NonPagedPool and pass this buffer to the SAL.
        // If the SAL interface is sucessful, we will copy the buffer to the caller's buffer.
        //

        log = ExAllocatePoolWithTag( NonPagedPool, maxLogSize, 'TpeC' );
        if ( log == NULL ) {
            HalpReleaseCpeMutex();
            return( STATUS_NO_MEMORY );
        }
    }

    //
    // We did not have any saved log, migrate from 1 processor to another to collect
    // the FW logs.
    //

    activeProcessors = HalpActiveProcessors;
    for (currentAffinity = 1; activeProcessors; currentAffinity <<= 1) {

        if (activeProcessors & currentAffinity) {

            activeProcessors &= ~currentAffinity;
            KeSetSystemAffinityThread(currentAffinity);

            status = HalpGetFwMceLog( CPE_EVENT, log, &HalpCpeInfo.Stats, HALP_FWMCE_DO_CLEAR_LOG );
            if ( NT_SUCCESS( status ) ||
                 ( (status != STATUS_NOT_FOUND) && (status != STATUS_ALREADY_COMMITTED) ) ) {
                break;
            }
        }
    }

    if ( NT_SUCCESS( status ) ) {
        ULONG length = log->Length; // Note: Length was checked in HalpGetMceLog().

        if ( kernelQuery ) {
            if ( HalpCpeInfo.DriverInfo.DpcCallback )   {
                HalpSaveMceLog( &HalpCpeInfo.DriverLogs, log, length );
            }
        }
        else  {
            RtlCopyMemory( Buffer, log, length );
            if ( HalpCpeInfo.KernelDelivery )   {
                HalpSaveMceLog( &HalpCpeInfo.KernelLogs, log, length );
            }
        }
        *ReturnedLength = length;
    }

    //
    // Restore threads affinity, release mutex.
    //

    KeRevertToUserAffinityThread();
    HalpReleaseCpeMutex();

    //
    // If the caller is not the Kernel-WMI, free the allocated NonPagedPool log.
    //

    if ( !kernelQuery ) {
        ExFreePoolWithTag( log, 'TpeC' );
    }

    //
    // We've retrieved a log from the SAL and cleared it.  It should be safe
    // to reenable CPE interrupts if we are in interrupt mode.
    //

    if (HalpCpeInfo.Stats.PollingInterval == HAL_CPE_INTERRUPTS_BASED) {
        HalpCPEEnable();
    }

    return status;

} // HalpGetCpeLog()

VOID
HalpMcaGetConfiguration (
    OUT PULONG  MCAEnabled,
    OUT PULONG  CMCEnabled,
    OUT PULONG  CPEEnabled,
    OUT PULONG  NoMCABugCheck,
    OUT PULONG  MCEOemDriversEnabled,
    OUT PULONG  CMCThresholdCount,
    OUT PULONG  CMCThresholdTime,
    OUT PULONG  CPEThresholdCount,
    OUT PULONG  CPEThresholdTime
)

/*++

Routine Description:

    This routine returns the registry settings for the
    the IA64 Error - MCA, CMC, CPE - configuration information.

Arguments:

    MCAEnabled - Pointer to the MCAEnabled indicator.
                 0 = False, 1 = True (1 if value not present in Registry).

    CMCEnabled - Pointer to the CMCEnabled indicator.
                 0     = HAL CMC Handling should be disabled.
                         Registry value was (present and set to 0) or was not present.
                 -1|1  = HAL CMC Interrupt-based mode. See Note 1/ below.
                 Other = HAL CMC Polling mode and value is user-specified polling interval.

    CPEEnabled - Pointer to the CPEEnabled indicator.
                 0     = HAL CPE Handling should be disabled.
                         Registry value was (present and set to 0) or was not present.
                 -1|1  = HAL CPE Interrupt-based mode. See Note 1/ below.
                 Other = HAL CPE Polling mode and value is user-specified polling interval.

    NoMCABugCheck - Pointer to the MCA BugCheck indicator.
                 0 = Fatal MCA HAL processing calls the KeBugCheckEx path.
                 1 = Fatal MCA HAL processing does not call the KeBugCheckEx path.
                     The system stalls. This is useful for extreme error containment.
                 if not present = value is 0, e.g. HAL calls KeBugCheckEx for fatal MCA.

    MCEOemDriversEnabled - Pointer to the MCEOemDriversEnabled indicator.
                           0 = HAL OEM MCE Drivers registration is disabled.
                           1 = HAL OEM MCE Drivers registration is enabled.
                           If not present = value is 0, e.g. registration is disabled.

    CMCThresholdCount - Number of CMCs received within a time period
                        that will cause a switch from interrupt to
                        polled mode

    CMCThresholdTime - Number of seconds within which CMCThresholdCount
                       CMCs need to be received before a switch to
                       polled mode.


    CPEThresholdCount - Number of CPEs received within a time period
                        that will cause a switch from interrupt to
                        polled mode

    CPEThresholdTime - Number of seconds within which CPEThresholdCount
                       CPEs need to be received before a switch to
                       polled mode.


Return Value:

    None.

Notes:

  1/  HAL defines minimum values for polling intervals. These minima are defined > 1, as imposed
      by the C_ASSERTs in HalpMcaInit().

--*/

{

    RTL_QUERY_REGISTRY_TABLE    parameters[10];
    ULONG                       defaultDataCMC;
    ULONG                       defaultDataMCA;
    ULONG                       defaultDataCPE;
    ULONG                       defaultNoMCABugCheck;
    ULONG                       defaultMCEOemDriversEnabled;
    ULONG                       defaultCMCThresholdTime;
    ULONG                       defaultCMCThresholdCount;
    ULONG                       defaultCPEThresholdTime;
    ULONG                       defaultCPEThresholdCount;

    RtlZeroMemory(parameters, sizeof(parameters));
    defaultDataCMC = *CMCEnabled = 0;
    defaultDataMCA = *MCAEnabled = TRUE;
    defaultDataCPE = *CPEEnabled = 0;
    defaultNoMCABugCheck = *NoMCABugCheck = FALSE;
    defaultMCEOemDriversEnabled = FALSE;  // 06/09/01: default chosen by MS IA64 MCA PM.
    defaultCMCThresholdCount = 10;         // 10 CMCs
    defaultCMCThresholdTime = 60;         // 60 Seconds
    defaultCPEThresholdCount = 10;         // 10 CPEs
    defaultCPEThresholdTime = 60;         // 60 Seconds

    //
    // Gather all of the "user specified" information from
    // the registry.
    //

    parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name = rgzEnableCMC;
    parameters[0].EntryContext = CMCEnabled;
    parameters[0].DefaultType = REG_DWORD;
    parameters[0].DefaultData = &defaultDataCMC;
    parameters[0].DefaultLength = sizeof(ULONG);

    parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[1].Name = rgzEnableMCA;
    parameters[1].EntryContext =  MCAEnabled;
    parameters[1].DefaultType = REG_DWORD;
    parameters[1].DefaultData = &defaultDataMCA;
    parameters[1].DefaultLength = sizeof(ULONG);

    parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[2].Name = rgzEnableCPE;
    parameters[2].EntryContext =  CPEEnabled;
    parameters[2].DefaultType = REG_DWORD;
    parameters[2].DefaultData = &defaultDataCPE;
    parameters[2].DefaultLength = sizeof(ULONG);

    parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[3].Name = rgzNoMCABugCheck;
    parameters[3].EntryContext =  NoMCABugCheck;
    parameters[3].DefaultType = REG_DWORD;
    parameters[3].DefaultData = &defaultNoMCABugCheck;
    parameters[3].DefaultLength = sizeof(ULONG);

    parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[4].Name = rgzEnableMCEOemDrivers;
    parameters[4].EntryContext =  MCEOemDriversEnabled;
    parameters[4].DefaultType = REG_DWORD;
    parameters[4].DefaultData = &defaultMCEOemDriversEnabled;
    parameters[4].DefaultLength = sizeof(ULONG);

    parameters[5].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[5].Name = rgzCMCThresholdTime;
    parameters[5].EntryContext =  CMCThresholdTime;
    parameters[5].DefaultType = REG_DWORD;
    parameters[5].DefaultData = &defaultCMCThresholdTime;
    parameters[5].DefaultLength = sizeof(ULONG);

    parameters[6].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[6].Name = rgzCMCThresholdCount;
    parameters[6].EntryContext =  CMCThresholdCount;
    parameters[6].DefaultType = REG_DWORD;
    parameters[6].DefaultData = &defaultCMCThresholdCount;
    parameters[6].DefaultLength = sizeof(ULONG);

    parameters[7].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[7].Name = rgzCPEThresholdTime;
    parameters[7].EntryContext =  CPEThresholdTime;
    parameters[7].DefaultType = REG_DWORD;
    parameters[7].DefaultData = &defaultCPEThresholdTime;
    parameters[7].DefaultLength = sizeof(ULONG);

    parameters[8].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[8].Name = rgzCPEThresholdCount;
    parameters[8].EntryContext =  CPEThresholdCount;
    parameters[8].DefaultType = REG_DWORD;
    parameters[8].DefaultData = &defaultCPEThresholdCount;
    parameters[8].DefaultLength = sizeof(ULONG);


    RtlQueryRegistryValues(
        RTL_REGISTRY_CONTROL | RTL_REGISTRY_OPTIONAL,
        rgzSessionManager,
        parameters,
        NULL,
        NULL
        );

    return;

} // HalpMcaGetConfiguration()

NTSTATUS
HalpSetMcaLog (
    IN  PMCA_EXCEPTION  Buffer,
    IN  ULONG           BufferSize
    )
/*++

Routine Description:

   This function is called by HaliSetSysteminformation for the HalMcaLog class.
   It stores the passed MCA record in the HAL.
   This functionality was requested by the MS Test Team to validate the HAL/WMI/WMI consumer
   path with "well-known" logs.

Arguments:

   Buffer        : supplies the MCA log.
   BufferSize    : supplies the MCA log size.

Return Value:

   Success or failure

Implementation Notes:

    As requested by the WMI and Test Teams, there is mininum HAL processing for the record
    and no validation of the record contents.

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;
    KIRQL                 oldIrql;

    HALP_VALIDATE_LOW_IRQL()

    //
    // Check calling arguments.
    //

    if ( (Buffer == (PMCA_EXCEPTION)0) || (BufferSize == 0) )    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // If MCA is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_MCA_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Enable MP protection for MCA logs accesses
    //

    HalpAcquireMcaMutex();

    //
    // Save log on Kernel and Drivers Logs if enabled.
    //

    if ( HalpMcaInfo.KernelDelivery )   {
       HalpSaveMceLog( &HalpMcaInfo.KernelLogs, Buffer, BufferSize );
    }

    if ( HalpMcaInfo.DriverInfo.DpcCallback )   {
       HalpSaveMceLog( &HalpMcaInfo.DriverLogs, Buffer, BufferSize );
    }

    //
    // Let Kernel or OEM MCA driver know about it.
    //
    // There is no model other than INTERRUPTS_BASED for MCA at this date - 05/04/01.
    //

    if ( HalpMcaInfo.KernelDelivery || HalpMcaInfo.DriverInfo.DpcCallback ) {
        InterlockedExchange( &HalpMcaInfo.DpcNotification, 1 );
    }

    //
    // release mutex.
    //

    HalpReleaseMcaMutex();

    return( STATUS_SUCCESS );

} // HalpSetMcaLog()

NTSTATUS
HalpSetCmcLog (
    IN  PCMC_EXCEPTION  Buffer,
    IN  ULONG           BufferSize
    )
/*++

Routine Description:

   This function is called by HaliSetSysteminformation for the HalCmcLog class.
   It stores the passed CMC record in the HAL.
   This functionality was requested by the MS Test Team to validate the HAL/WMI/WMI consumer
   path with "well-known" logs.

Arguments:

   Buffer        : supplies the CMC log.
   BufferSize    : supplies the CMC log size.

Return Value:

   Success or failure

Implementation Notes:

    As requested by the WMI and Test Teams, there is mininum HAL processing for the record
    and no validation of the record contents.

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;
    KIRQL                 oldIrql;

    HALP_VALIDATE_LOW_IRQL()

    //
    // Check calling arguments.
    //

    if ( (Buffer == (PCMC_EXCEPTION)0) || (BufferSize == 0) )    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // If CMC is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_CMC_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Enable MP protection for CMC logs accesses
    //

    HalpAcquireCmcMutex();

    //
    // Save log on Kernel and Driver Logs if enabled.
    //

    if ( HalpCmcInfo.KernelDelivery )   {
       HalpSaveMceLog( &HalpCmcInfo.KernelLogs, Buffer, BufferSize );
    }

    if ( HalpCmcInfo.DriverInfo.DpcCallback )   {
       HalpSaveMceLog( &HalpCmcInfo.DriverLogs, Buffer, BufferSize );
    }

    //
    // If Interrupt based mode, call directly second-level handler at CMCI level.
    //

    if ( HalpCmcInfo.Stats.PollingInterval == HAL_CMC_INTERRUPTS_BASED )    {
        KeRaiseIrql(CMCI_LEVEL, &oldIrql);
        HalpCmcHandler();
        KeLowerIrql( oldIrql );
    }

    //
    // release mutex.
    //

    HalpReleaseCmcMutex();

    return( STATUS_SUCCESS );

} // HalpSetCmcLog()

NTSTATUS
HalpSetCpeLog (
    IN  PCPE_EXCEPTION  Buffer,
    IN  ULONG           BufferSize
    )
/*++

Routine Description:

   This function is called by HaliSetSysteminformation for the HalCpeLog class.
   It stores the passed CPE record in the HAL.
   This functionality was requested by the MS Test Team to validate the HAL/WMI/WMI consumer
   path with "well-known" logs.

Arguments:

   Buffer        : supplies the CPE log.
   BufferSize    : supplies the CPE log size.

Return Value:

   Success or failure

Implementation Notes:

    As requested by the WMI and Test Teams, there is mininum HAL processing for the record
    and no validation of the record contents.

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;
    KIRQL                 oldIrql;

    HALP_VALIDATE_LOW_IRQL()

    //
    // Check calling arguments.
    //

    if ( (Buffer == (PCPE_EXCEPTION)0) || (BufferSize == 0) )    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // If CPE is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_CPE_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Enable MP protection for CPE logs accesses
    //

    HalpAcquireCpeMutex();

    //
    // Save log on Kernel and Drivers Logs if enabled.
    //

    if ( HalpCpeInfo.KernelDelivery )   {
       HalpSaveMceLog( &HalpCpeInfo.KernelLogs, Buffer, BufferSize );
    }

    if ( HalpCpeInfo.DriverInfo.DpcCallback )   {
       HalpSaveMceLog( &HalpCpeInfo.DriverLogs, Buffer, BufferSize );
    }

    //
    // If Interrupt based mode, call directly second-level handler at CPEI level.
    //

    if ( HalpCpeInfo.Stats.PollingInterval == HAL_CPE_INTERRUPTS_BASED )    {
        KeRaiseIrql(CPEI_LEVEL, &oldIrql);
        HalpCpeHandler();
        KeLowerIrql( oldIrql );
    }

    //
    // release mutex.
    //

    HalpReleaseCpeMutex();

    return( STATUS_SUCCESS );

} // HalpSetCpeLog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixslpsup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixhibrnt.c

Abstract:

    This file provides the code that saves and restores
    state for traditional motherboard devices when the
    system goes into a sleep state that removes power.

Author:

    Jake Oshins (jakeo) May 6, 1997

Revision History:

--*/

#include "halp.h"

extern PVOID   HalpEisaControlBase;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliLocateHiberRanges)
#pragma alloc_text(PAGELK, HalpSaveDmaControllerState)
#pragma alloc_text(PAGELK, HalpSaveTimerState)
#ifdef PIC_SUPPORTED
#pragma alloc_text(PAGELK, HalpSavePicState)
#pragma alloc_text(PAGELK, HalpRestorePicState)
#endif
#pragma alloc_text(PAGELK, HalpRestoreDmaControllerState)
#pragma alloc_text(PAGELK, HalpRestoreTimerState)
#endif

#ifdef notyet



#define EISA_CONTROL (PUCHAR)&((PEISA_CONTROL) HalpEisaControlBase)


#endif // notyet


#ifdef PIC_SUPPORTED
VOID
HalpSavePicState(
    VOID
    )
{
#ifdef notyet
 //
 // Commented HalpMotherboardState and EISA_CONTROL********
 //

#ifdef notyet

    HalpMotherboardState.PicState.MasterMask =
    READ_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1);

#endif // notyet

#if defined(NEC_98)
#else
    HalpMotherboardState.PicState.MasterEdgeLevelControl =
        READ_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel);

    HalpMotherboardState.PicState.SlaveEdgeLevelControl =
        READ_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel);
#endif

#endif // notyet

}

VOID
HalpRestorePicState(
    VOID
    )
{

#ifdef notyet

    ULONG flags;
   
   
    // _asm {
    //       pushfd
    //        pop     flags
    //        cli
    //  }

    _disable();

#ifdef notyet
 
   HalpInitializePICs(FALSE);

//
// HalpMotherboardState,EISA_CONTROL and assembly instruction commented
//

    WRITE_PORT_UCHAR(
        EISA_CONTROL->Interrupt1ControlPort1,
        HalpMotherboardState.PicState.MasterMask
        );

   WRITE_PORT_UCHAR(
       EISA_CONTROL->Interrupt2ControlPort1,
       HalpMotherboardState.PicState.SlaveMask
       );

#endif // notyet

#if defined(NEC_98)
#else
     //
     // For halx86, the PCI interrupt vector programming 
     // is static, so this code can just restore everything.
     //
     HalpRestorePicEdgeLevelRegister();

#endif


   // _asm {
   //     push    flags
   //      popfd
   //   }
  
      

   }

   #ifndef NEC_98
   VOID
   HalpRestorePicEdgeLevelRegister(
       VOID
       )
   { 

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel,
                     HalpMotherboardState.PicState.MasterEdgeLevelControl);

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel,
                     HalpMotherboardState.PicState.SlaveEdgeLevelControl);
   }

#endif


#endif // notyet

}
#endif


VOID
HalpSaveDmaControllerState(
    VOID
    )
{
#ifdef notyet
 
#if defined(NEC_98)

#else
    HalpMotherboardState.DmaState.Dma1ExtendedModePort =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma1ExtendedModePort
            );

    HalpMotherboardState.DmaState.Dma2ExtendedModePort =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma2ExtendedModePort
            );

#endif // NEC_98


#ifdef notyet

    HalpMotherboardState.DmaState.Dma2ExtendedModePort =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma2ExtendedModePort
            );

    HalpMotherboardState.DmaState.Dma1Control.Mode =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma1BasePort.Mode
            );

    HalpMotherboardState.DmaState.Dma2Control.Mode =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma2BasePort.Mode
            );

   HalpMotherboardState.DmaState.Dma1Control.SingleMask =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma1BasePort.SingleMask
            );

   HalpMotherboardState.DmaState.Dma2Control.SingleMask =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma2BasePort.SingleMask
            );

#endif // notyet

#endif // notyet
}



VOID
HalpRestoreDmaControllerState(
    VOID
    )

{
#ifdef notyet
#if defined(NEC_98)
#else
    UCHAR   i;

    WRITE_PORT_UCHAR(
        EISA_CONTROL->Dma1ExtendedModePort,
        HalpMotherboardState.DmaState.Dma1ExtendedModePort
        );

    WRITE_PORT_UCHAR(
        EISA_CONTROL->Dma2ExtendedModePort,
        HalpMotherboardState.DmaState.Dma2ExtendedModePort
        );

    for (i = 0; i < (EISA_DMA_CHANNELS / 2); i++) {

        //
        // Check to see if the array has contains a value for this channel.
        //

        if ((HalpDmaChannelModes[i] & 0x3) == i) {

            WRITE_PORT_UCHAR(
                EISA_CONTROL->Dma1BasePort.Mode,
                HalpDmaChannelModes[i]
                );

            WRITE_PORT_UCHAR(
                EISA_CONTROL->Dma1BasePort.SingleMask,
                HalpDmaChannelMasks[i]
                );

        }

        if ((HalpDmaChannelModes[i + (EISA_DMA_CHANNELS / 2)] & 0x3) == i) {

            WRITE_PORT_UCHAR(
                EISA_CONTROL->Dma2BasePort.Mode,
                HalpDmaChannelModes[i + (EISA_DMA_CHANNELS / 2)]
                );

            WRITE_PORT_UCHAR(
                EISA_CONTROL->Dma2BasePort.SingleMask,
                HalpDmaChannelMasks[i]
                );

        }
    }
#endif

#endif // notyet 

}

VOID
HalpSaveTimerState(
    VOID
    )
{

}

VOID
HalpRestoreTimerState(
    VOID
    )
{
    HalpInitializeClock();
}

VOID
HaliLocateHiberRanges (
    IN PVOID MemoryMap
    )
{
  ;
    //
    // Mark the hal's data section as needed to be cloned
    //
    //
    // Commented PO_MEM_CLONE, PO_MEM_PAGE_ADDRESS and PO_MEM_DISCARD
    //

#ifdef notyet

    // PoSetHiberRange (
    //     MemoryMap,
    //     PO_MEM_CLONE,
    //     (PVOID) &HalpFeatureBits,
    //     0,
    //     'dlah'
    //     );

    //
    // Mark DMA buffer has not needing saved
    //

    // if (HalpMapBufferSize) {
    //     PoSetHiberRange (
    //         MemoryMap,
    //         PO_MEM_DISCARD | PO_MEM_PAGE_ADDRESS,
    //         (PVOID) (HalpMapBufferPhysicalAddress.LowPart >> PAGE_SHIFT),
    //         HalpMapBufferSize >> PAGE_SHIFT,
    //         'mlah'
    //         );
    //    }

#endif // notyet

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixpnpdrv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixpnpdrv.c

Abstract:

    Implements functionality necessary for the
    HAL to become a PnP-style device driver
    after system initialization.  This is done
    so that the HAL can enumerate the ACPI driver
    in the way that the PnP stuff expects.

Author:

    Jake Oshins (jakeo) 27-Jan-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "exboosts.h"
#include "wchar.h"

//
// Cause the GUID to be defined.
//

#include "initguid.h"
#include "wdmguid.h"
#include "halpnpp.h"

#if DBG
ULONG HalDebug = 0;
#endif

WCHAR   HalHardwareIdString[]  = L"acpi";

typedef enum {
    Hal = 0x80,
    AcpiDriver
} PDO_TYPE;

typedef enum {
    PdoExtensionType = 0xc0,
    FdoExtensionType
} EXTENSION_TYPE;

typedef struct _PDO_EXTENSION *PPDO_EXTENSION;
typedef struct _FDO_EXTENSION *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION{
    EXTENSION_TYPE                  ExtensionType;
    PPDO_EXTENSION                  Next;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    PFDO_EXTENSION                  ParentFdoExtension;
    PDO_TYPE                        PdoType;
    LONG                            InterfaceReferenceCount;
} PDO_EXTENSION, *PPDO_EXTENSION;

#define ASSERT_PDO_EXTENSION(x) ASSERT((x)->ExtensionType == PdoExtensionType );

typedef struct _FDO_EXTENSION{
    EXTENSION_TYPE        ExtensionType;
    PPDO_EXTENSION        ChildPdoList;
    PDEVICE_OBJECT        PhysicalDeviceObject;  // PDO passed into AddDevice()
    PDEVICE_OBJECT        FunctionalDeviceObject;
    PDEVICE_OBJECT        AttachedDeviceObject;
} FDO_EXTENSION, *PFDO_EXTENSION;

#define ASSERT_FDO_EXTENSION(x) ASSERT((x)->ExtensionType == FdoExtensionType );

INT_ROUTE_INTERFACE_STANDARD PciIrqRoutingInterface = {0};

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    );

NTSTATUS
HalpQueryResourceRequirements(
    PDEVICE_OBJECT DeviceObject,
    PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpQueryInterfaceFdo(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

#endif

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
);

VOID
HalpMaskAcpiInterrupt(
    VOID
    );

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    );

// from xxacpi.c
NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

//
//  Define the PNP interface functions.
//

VOID
HalPnpInterfaceReference(
    PVOID Context
    );

VOID
HalPnpInterfaceDereference(
    PVOID Context
    );

BOOLEAN
HalPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

struct _DMA_ADAPTER *
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

BOOLEAN
HalpFakeAcpiRegisters(
    VOID
    );

#define HAL_DRIVER_NAME  L"\\Driver\\ACPI_HAL"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliInitPnpDriver)
#pragma alloc_text(PAGE, HalpOpenRegistryKey)
#pragma alloc_text(PAGE, HalpDispatchPnp)
#pragma alloc_text(PAGE, HalpAddDevice)
#pragma alloc_text(PAGE, HalpDriverEntry)
#pragma alloc_text(PAGE, HalpQueryDeviceRelations)
#pragma alloc_text(PAGE, HalpQueryIdPdo)
#pragma alloc_text(PAGE, HalpQueryIdFdo)
#pragma alloc_text(PAGE, HalpQueryCapabilities)
#pragma alloc_text(PAGE, HalpQueryResources)
#pragma alloc_text(PAGE, HalpQueryResourceRequirements)
#pragma alloc_text(PAGE, HalpQueryInterface)
#ifdef WANT_IRQ_ROUTING
#pragma alloc_text(PAGE, HalpQueryInterfaceFdo)
#endif
#pragma alloc_text(PAGELK, HalpDispatchPower)
#pragma alloc_text(PAGE, HalpDispatchWmi)
#endif

PDRIVER_OBJECT HalpDriverObject;


NTSTATUS
HaliInitPnpDriver(
    VOID
    )
/*++

Routine Description:

    This routine starts the process of making the HAL into
    a "driver," which is necessary because we need to
    enumerate a Plug and Play PDO for the ACPI driver.

Arguments:

    DriverName - Unicode string that will be used for the
                 driver object.

Return Value:

    status

--*/
{

    UNICODE_STRING  DriverName;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitUnicodeString( &DriverName, HAL_DRIVER_NAME );

    Status = IoCreateDriver( &DriverName, HalpDriverEntry );

    ASSERT( NT_SUCCESS( Status ));

    return Status;

}

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    PnP Driver Object.  In this function, we need to remember the DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT detectedDeviceObject = NULL;
    ANSI_STRING    AKeyName;

    PAGED_CODE();

    //
    // File the pointer to our driver object away
    //
    HalpDriverObject = DriverObject;

    //
    // Fill in the driver object
    //
    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)HalpAddDevice;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = HalpDispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = HalpDispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = HalpDispatchWmi;

    status = IoReportDetectedDevice(DriverObject,
                                    InterfaceTypeUndefined,
                                    -1,
                                    -1,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    &detectedDeviceObject);

    ASSERT(detectedDeviceObject);
    if (!(NT_SUCCESS(status))) {
        return status;
    }

    HalpAddDevice(DriverObject,
                  detectedDeviceObject);

    return STATUS_SUCCESS;

}

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine handles AddDevice for an madeup PDO device.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{
    PDEVICE_OBJECT functionalDeviceObject;
    PDEVICE_OBJECT childDeviceObject;
    PDEVICE_OBJECT AttachedDevice;
    NTSTATUS       status;
    PFDO_EXTENSION FdoExtension;
    PPDO_EXTENSION PdoExtension;

    PAGED_CODE();

    //
    // We've been given the PhysicalDeviceObject.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(FDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &functionalDeviceObject     // store new device object here
                );

    if( !NT_SUCCESS( status )){

        DbgBreakPoint();
        return status;
    }

    //
    // Fill in the FDO extension
    //
    FdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;
    FdoExtension->ExtensionType = FdoExtensionType;
    FdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    FdoExtension->FunctionalDeviceObject = functionalDeviceObject;

    functionalDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);

    //
    // Now attach to the PDO we were given.
    //

    AttachedDevice = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                                 PhysicalDeviceObject );
    if(AttachedDevice == NULL){

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice( functionalDeviceObject );

        return STATUS_NO_SUCH_DEVICE;

    }

    FdoExtension->AttachedDeviceObject = AttachedDevice;

    //
    // Next, create a PDO for the ACPI driver.
    //
    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(PDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                FALSE,                      // not exclusive
                &childDeviceObject          // store new device object here
                );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Fill in the PDO extension
    //
    PdoExtension = (PPDO_EXTENSION)childDeviceObject->DeviceExtension;
    PdoExtension->ExtensionType = PdoExtensionType;
    PdoExtension->Next = NULL;
    PdoExtension->PhysicalDeviceObject = childDeviceObject;
    PdoExtension->ParentFdoExtension = FdoExtension;
    PdoExtension->PdoType = AcpiDriver;

    childDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);
    //
    // Record this as a child of the HAL
    //
    FdoExtension->ChildPdoList = PdoExtension;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpPassIrpFromFdoToPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    Given an FDO, pass the IRP to the next device object in the
    device stack.  This is the PDO if there are no lower level
    filters.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{

    PIO_STACK_LOCATION irpSp;       // our stack location
    PIO_STACK_LOCATION nextIrpSp;   // next guy's
    PFDO_EXTENSION     fdoExtension;

    //
    // Get the pointer to the device extension.
    //

    fdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Call the PDO driver with the request.
    //

    return IoCallDriver(fdoExtension->AttachedDeviceObject ,Irp);
}

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for madeup PDO device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG length;
    DEVICE_RELATION_TYPE relationType;
    EXTENSION_TYPE  extensionType;
    BOOLEAN passDown;
    PUCHAR objectTypeString;

    PAGED_CODE();

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    status = Irp->IoStatus.Status;
    switch (extensionType) {

    case PdoExtensionType:

        objectTypeString = "PDO";

        switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Start_Device Irp received\n",
                            objectTypeString ));

            //
            // If we get a start device request for a PDO, we simply
            // return success.
            //

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Stop_Device Irp received",
                            objectTypeString));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Cancel_Stop_Device Irp received",
                            objectTypeString ));

            status = STATUS_SUCCESS;
            break;


        case IRP_MN_STOP_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Stop_Device Irp received\n",
                            objectTypeString ));

            //
            // If we get a stop device request for a PDO, we simply
            // return success.
            //

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_RESOURCES:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Resources Irp received\n",
                            objectTypeString ));

            status = HalpQueryResources(DeviceObject,
                         (PCM_RESOURCE_LIST*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Resource_Requirements Irp received\n",
                           objectTypeString ));

            status = HalpQueryResourceRequirements(DeviceObject,
                         (PIO_RESOURCE_REQUIREMENTS_LIST*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Remove_device Irp for %p",
                            objectTypeString,
                            DeviceObject ));

            status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Cancel_Remove_device Irp for %p",
                            objectTypeString,
                            DeviceObject));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Remove_device Irp for PDO %p\n",
                            objectTypeString,
                            DeviceObject ));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Device_Relations Irp received\n",
                            objectTypeString ));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;


        case IRP_MN_QUERY_ID:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Id Irp received\n",
                            objectTypeString ));

            status = HalpQueryIdPdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_INTERFACE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Interface Irp received\n",
                            objectTypeString));

            status = HalpQueryInterface(
                         DeviceObject,
                         irpSp->Parameters.QueryInterface.InterfaceType,
                         irpSp->Parameters.QueryInterface.Version,
                         irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                         irpSp->Parameters.QueryInterface.Size,
                         irpSp->Parameters.QueryInterface.Interface,
                         (PULONG)&Irp->IoStatus.Information
                         );
            break;

        case IRP_MN_QUERY_CAPABILITIES:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Capabilities Irp received\n",
                            objectTypeString));

            status = HalpQueryCapabilities(DeviceObject,
                                           irpSp->Parameters.DeviceCapabilities.Capabilities);

            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            HalDebugPrint(( HAL_PNP, "HAL: DEVICE_USAGE Irp received\n" ));
            status = STATUS_SUCCESS;
            break;

        default:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Unsupported Irp (%d) received\n",
                            objectTypeString,
                            irpSp->MinorFunction));
            status = STATUS_NOT_SUPPORTED ;
            break;
        }

        break;  // end PDO cases

    case FdoExtensionType:

        objectTypeString = "FDO";
        passDown = TRUE;

        //
        // In case we don't touch this IRP, save the current status.
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Device_Relations Irp received\n",
                            objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;

#ifdef WANT_IRQ_ROUTING
        case IRP_MN_QUERY_INTERFACE:

            HalDebugPrint(( HAL_PNP, "(%s) Query_Interface Irp received",
                       objectTypeString));
            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Interface Irp received",
                            objectTypeString ));
            Status = HalpQueryInterfaceFdo(
                         DeviceObject,
                         irpSp->Parameters.QueryInterface.InterfaceType,
                         irpSp->Parameters.QueryInterface.Version,
                         irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                         irpSp->Parameters.QueryInterface.Size,
                         irpSp->Parameters.QueryInterface.Interface,
                         &Irp->IoStatus.Information
                         );
            break;

#endif

        case IRP_MN_QUERY_ID:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Id Irp received\n",
                            objectTypeString ));

            status = HalpQueryIdFdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        default:

            //
            // Ignore any PNP Irps unknown by the FDO but allow them
            // down to the PDO.
            //

            status = STATUS_NOT_SUPPORTED ;
            break;
        }

        if (passDown && (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED))) {

            //
            // Pass FDO IRPs down to the PDO.
            //
            // Set Irp status first.
            //
            if (status != STATUS_NOT_SUPPORTED) {

                Irp->IoStatus.Status = status;
            }

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Passing down Irp (%x)\n",
                            objectTypeString, irpSp->MinorFunction ));
            return HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
        }

        break;  // end FDO cases

    default:

        HalDebugPrint(( HAL_PNP, "HAL: Received IRP for unknown Device Object\n" ));
        status = STATUS_INVALID_DEVICE_REQUEST ;
        break;

    }

    //
    // Complete the Irp and return.
    //

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

    } else {

        status = Irp->IoStatus.Status ;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for madeup PDO device.
    Note: We don't actually handle any Power IRPs at this level so
    all we do is return the status from the incoming IRP.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;
    PIO_STACK_LOCATION irpSp;

    HalDebugPrint(( HAL_PNP, "HAL:  Power IRP for DevObj: %p\n", DeviceObject ));

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Simply store the appropriate status and complete the request.
    //

    Status = Irp->IoStatus.Status;

    PoStartNextPowerIrp(Irp);

    if (extensionType == FdoExtensionType) {

        switch (irpSp->MinorFunction) {
        case IRP_MN_SET_POWER:

            if (irpSp->Parameters.Power.Type == SystemPowerState) {

                if (irpSp->Parameters.Power.State.SystemState ==
                    PowerSystemWorking) {

                    HalpUnmaskAcpiInterrupt();

                } else {

                    HalpMaskAcpiInterrupt();
                }
            }

            //
            // Fall through.
            //

        case IRP_MN_QUERY_POWER:

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            //
            // Fall through.
            //

        default:

            Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
            break;
        }

    } else {

        switch (irpSp->MinorFunction) {
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            //
            // Fall through.
            //

        default:
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;
        }
    }

    return Status;
}

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    if (extensionType == FdoExtensionType) {
        Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
    } else {
        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description:

    This routine builds a DEVICE_RELATIONS structure that
    tells the PnP manager how many children we have.

Arguments:

    DeviceObject - FDO of ACPI_HAL

    RelationType - we only respond to BusRelations

    DeviceRelations - pointer to the structure

Return Value:

    status

--*/
{
    PFDO_EXTENSION  FdoExtension;
    PDEVICE_RELATIONS   relations = NULL;
    PDEVICE_OBJECT deviceObjectToReturn ;
    EXTENSION_TYPE  extensionType;
    NTSTATUS status ;

    PAGED_CODE();

    FdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;
    extensionType = FdoExtension->ExtensionType;
    status = STATUS_NOT_SUPPORTED ;

    switch(RelationType) {

        case BusRelations:

            if (extensionType == FdoExtensionType) {
                deviceObjectToReturn = FdoExtension->ChildPdoList->PhysicalDeviceObject ;
                status = STATUS_SUCCESS ;
            }
            break;

        case TargetDeviceRelation:

            if (extensionType == PdoExtensionType) {

                deviceObjectToReturn = DeviceObject ;
                status = STATUS_SUCCESS ;
            }
            break;
    }

    if (status == STATUS_NOT_SUPPORTED) {

        HalDebugPrint(( HAL_PNP, "HAL:  We don't support this kind of device relation\n" ));

    } else if (NT_SUCCESS(status)) {

        ASSERT(*DeviceRelations == 0);

        relations = ExAllocatePoolWithTag(
            PagedPool,
            sizeof(DEVICE_RELATIONS),
            HAL_POOL_TAG
            );

        if (!relations) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            relations->Count = 1;
            relations->Objects[0] = deviceObjectToReturn ;

            ObReferenceObject(relations->Objects[0]);
            *DeviceRelations = relations;
        }
    }

    return status ;
}

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned, currently ignored

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString;
    ULONG stringLen;
    static WCHAR AcpiHardwareIdString[] = L"ACPI_HAL\\PNP0C08\0*PNP0C08";
    static WCHAR AcpiCompatibleString[] = L"*PNP0C08";
    static WCHAR AcpiInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        switch (PdoExtension->PdoType) {
        case AcpiDriver:
            sourceString = AcpiHardwareIdString;
            stringLen = sizeof(AcpiHardwareIdString);
            break;

        default:
            return STATUS_NOT_SUPPORTED;

        }
        break;

    case BusQueryCompatibleIDs:
        return STATUS_NOT_SUPPORTED;
        break;

    case BusQueryInstanceID:
        sourceString = AcpiInstanceIdString;
        stringLen = sizeof(AcpiInstanceIdString);
        break;

    default:
        return STATUS_NOT_SUPPORTED;
    }

    idString = ExAllocatePoolWithTag(PagedPool,
                                     stringLen + sizeof(UNICODE_NULL),
                                     HAL_POOL_TAG);

    if (!idString) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(idString,
                  sourceString, stringLen);

    *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

    *BusQueryId = idString;

    return STATUS_SUCCESS;
}
NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    UNICODE_STRING String;
    WCHAR Buffer[16];
    NTSTATUS Status;
    PWCHAR widechar;
    static WCHAR HalInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        sourceString = HalHardwareIdString;
        widechar = (PWCHAR)&HalHardwareIdString;
        while (*widechar != 0) widechar++;
        stringLen =  (ULONG)((PUCHAR)widechar - ((PUCHAR)&HalHardwareIdString) + 2);

        break;

    case BusQueryInstanceID:

        sourceString = HalInstanceIdString;
        stringLen = sizeof(HalInstanceIdString);
        break;

    default:
        break;
    }
    if (sourceString) {

        //
        // Note that hardware IDs and compatible IDs must be terminated by
        // 2 NULLs.
        //

        idString = ExAllocatePoolWithTag(PagedPool,
                                         stringLen + sizeof(UNICODE_NULL),
                                         HAL_POOL_TAG);

        if (!idString) {
            HalDebugPrint(( HAL_PNP, "HalpQueryIdFdo: couldn't allocate pool\n" ));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(idString,
                      sourceString, stringLen);

        *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

        *BusQueryId = idString;

        return STATUS_SUCCESS;
    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    )
/*++

Routine Description:

    This routine fills in the DEVICE_CAPABILITIES structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    Capabilities - pointer to the structure to be filled in.

Return Value:

    status

--*/
{
    PAGED_CODE();

    ASSERT(Capabilities->Version == 1);
    if (Capabilities->Version != 1) {

        return STATUS_NOT_SUPPORTED;

    }

    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = TRUE;
    Capabilities->SilentInstall = TRUE;
    Capabilities->RawDeviceOK = FALSE;
    Capabilities->Address = 0xffffffff;
    Capabilities->UINumber = 0xffffffff;
    Capabilities->D1Latency = 0;
    Capabilities->D2Latency = 0;
    Capabilities->D3Latency = 0;

    //
    // Default S->D mapping
    //
    Capabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
    Capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
    Capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST requirements;
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PCM_RESOURCE_LIST cmResList;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    if (PdoExtension->PdoType == AcpiDriver) {

        //
        // The whole point behind creating a boot config for the
        // ACPI PDO is that the PnP Manager will not terminate
        // its algorithm that tries to reserve boot configs for
        // all of ACPI's children.  So it is not necessary that
        // ACPI have a complicated list of resources in its boot
        // config.  We'll be happy with just the IRQ.
        //
        // N.B.  At the time of this writing, it should also be
        // true that the IRQ is the only resource that the ACPI
        // claims anyhow.
        //

        status = HalpQueryAcpiResourceRequirements(&requirements);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        cmResList = ExAllocatePoolWithTag(PagedPool,
                                          sizeof(CM_RESOURCE_LIST),
                                          HAL_POOL_TAG);

        if (!cmResList) {
            ExFreePool(requirements);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(cmResList, sizeof(CM_RESOURCE_LIST));

        cmResList->Count = 1;
        cmResList->List[0].InterfaceType = PNPBus;
        cmResList->List[0].BusNumber     = -1;
        cmResList->List[0].PartialResourceList.Version = 1;
        cmResList->List[0].PartialResourceList.Revision = 1;
        cmResList->List[0].PartialResourceList.Count = 1;
        cmResList->List[0].PartialResourceList.PartialDescriptors[0].Type =
            CmResourceTypeInterrupt;

        ASSERT(requirements->AlternativeLists == 1);

        for (i = 0; i < requirements->List[0].Count; i++) {

            descriptor = &requirements->List[0].Descriptors[i];

            if (descriptor->Type == CmResourceTypeInterrupt) {

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].ShareDisposition =
                    descriptor->ShareDisposition;
                cmResList->List[0].PartialResourceList.PartialDescriptors[0].Flags =
                    descriptor->Flags;

                ASSERT(descriptor->u.Interrupt.MinimumVector ==
                       descriptor->u.Interrupt.MaximumVector);

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Level =
                    descriptor->u.Interrupt.MinimumVector;

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Vector =
                    descriptor->u.Interrupt.MinimumVector;

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Affinity = -1;

                *Resources = cmResList;

                ExFreePool(requirements);
                return STATUS_SUCCESS;
            }
        }

        ExFreePool(requirements);
        ExFreePool(cmResList);
        return STATUS_NOT_FOUND;

    } else {
        return STATUS_NOT_SUPPORTED;
    }
}


NTSTATUS
HalpQueryResourceRequirements(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_RESOURCE_REQUIREMENTS.

Arguments:

    DeviceObject - PDO of the child

    Requirements - pointer to be filled in with the devices
        resource requirements.

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    if (PdoExtension->PdoType == AcpiDriver) {

        return HalpQueryAcpiResourceRequirements(Requirements);

    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for a device.

Arguments:

    DeviceObject            - PDO of the child
    InterfaceType           - Pointer to the interface type GUID.
    Version                 - Supplies the requested interface version.
    InterfaceSpecificData   - This is context that means something based on the interface.
    Interface Buffer Size   - Supplies the length of a buffer for the interface structure.
    Interface               - Supplies a pointer where interference information should be returned.ointer to the supplied interface buffer.
    Length                  - The value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    PPDO_EXTENSION PdoExtension = (PPDO_EXTENSION)DeviceObject->DeviceExtension;
    CM_RESOURCE_TYPE resource = (CM_RESOURCE_TYPE)(INT_PTR)InterfaceSpecificData;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION(PdoExtension);

    if (IsEqualGUID(&GUID_BUS_INTERFACE_STANDARD, InterfaceType)) {

        PBUS_INTERFACE_STANDARD standard = (PBUS_INTERFACE_STANDARD)Interface;

        //
        // ASSERT we know about all of the fields in the structure.
        //

        ASSERT(sizeof(BUS_INTERFACE_STANDARD) == FIELD_OFFSET(BUS_INTERFACE_STANDARD, GetBusData) + sizeof(PGET_SET_DEVICE_DATA));

        *Length = sizeof(BUS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(BUS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  The only version this code knows about is 1.
        //

        standard->Size = sizeof(BUS_INTERFACE_STANDARD);
        standard->Version = HAL_BUS_INTERFACE_STD_VERSION;
        standard->Context = DeviceObject;

        standard->InterfaceReference = HalPnpInterfaceReference;
        standard->InterfaceDereference = HalPnpInterfaceDereference;
        standard->TranslateBusAddress = HalPnpTranslateBusAddress;
        standard->GetDmaAdapter = HalPnpGetDmaAdapter;
        standard->SetBusData = NULL;
        standard->GetBusData = NULL;

    } else if (IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType)) {

        PTRANSLATOR_INTERFACE translator = (PTRANSLATOR_INTERFACE)Interface;

        //
        // Common initialization.
        //

        if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {
            *Length = sizeof(TRANSLATOR_INTERFACE);
            return STATUS_BUFFER_TOO_SMALL;
        }

        switch ((CM_RESOURCE_TYPE)(INT_PTR)InterfaceSpecificData) {

        case CmResourceTypeInterrupt:

            translator->Size = sizeof(TRANSLATOR_INTERFACE);
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->Context = DeviceObject;
            translator->InterfaceReference = HalTranslatorReference;
            translator->InterfaceDereference = HalTranslatorDereference;
            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                HalIrqTranslateResourceRequirementsRoot;
            *Length = sizeof(TRANSLATOR_INTERFACE);

            break;

        default:
            return STATUS_NOT_SUPPORTED;
        }

    } else if (IsEqualGUID(&GUID_ACPI_REGS_INTERFACE_STANDARD, InterfaceType)) {

        //
        // ACPI register function interface.
        //

        PACPI_REGS_INTERFACE_STANDARD AcpiRegInterface =
          (PACPI_REGS_INTERFACE_STANDARD)Interface;

        if (!HalpFakeAcpiRegisters()) {
            return STATUS_NOT_FOUND;
        }

        DbgPrint("Faking ACPI registers\n");

        //
        // Common initialization.
        //
        *Length = sizeof(ACPI_REGS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(ACPI_REGS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        AcpiRegInterface->Size = sizeof(ACPI_REGS_INTERFACE_STANDARD);
        AcpiRegInterface->Context = NULL;
        AcpiRegInterface->InterfaceReference = HalTranslatorReference;
        AcpiRegInterface->InterfaceDereference = HalTranslatorDereference;

        //
        // Set the two ACPI register access routines.
        //

        AcpiRegInterface->ReadAcpiRegister = HalpReadAcpiRegister;
        AcpiRegInterface->WriteAcpiRegister = HalpWriteAcpiRegister;

    } else if (IsEqualGUID(&GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD,
                           InterfaceType)) {

        PHAL_PORT_RANGE_INTERFACE PortRanges = (PHAL_PORT_RANGE_INTERFACE)Interface;

        *Length = sizeof(HAL_PORT_RANGE_INTERFACE);

        if (InterfaceBufferSize < sizeof(HAL_PORT_RANGE_INTERFACE)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        PortRanges->Size = sizeof(HAL_PORT_RANGE_INTERFACE);
        PortRanges->Version = HAL_PORT_RANGE_INTERFACE_VERSION;
        PortRanges->Context = DeviceObject;
        PortRanges->InterfaceReference = HalPnpInterfaceReference;
        PortRanges->InterfaceDereference = HalPnpInterfaceDereference;

        PortRanges->QueryAllocateRange = HalpQueryAllocatePortRange;
        PortRanges->FreeRange = HalpFreePortRange;

    } else {

        //
        //  Unsupport bus interface type.
        //

        return STATUS_NOT_SUPPORTED ;
    }

    //
    // Bump the reference count.
    //

    InterlockedIncrement(&PdoExtension->InterfaceReferenceCount);

    return STATUS_SUCCESS;
}

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpQueryInterfaceFdo(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for
    a device.

Arguments:

    DeviceObject - FDO of the child

    InterfaceType - Pointer to the interface type GUID.

    Version - Supplies the requested interface version.

    InterfaceSpecificData - This is context that means something based on the
                            interface.

    InterfaceBufferSize - Supplies the length of the buffer for the interface
                          structure.

    Interface - Supplies a pointer where the interface informaiton should
        be returned.

    Length - Supplies the length of the buffer for the interface structure.
        This value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    NTSTATUS                status = STATUS_NOT_SUPPORTED;
    CM_RESOURCE_TYPE        resource = (CM_RESOURCE_TYPE)InterfaceSpecificData;

    PAGED_CODE();

    if (    resource == CmResourceTypeInterrupt &&
            IsPciIrqRoutingEnabled()) {

        if (IsEqualGUID(&GUID_ARBITER_INTERFACE_STANDARD, InterfaceType)) {

            status = HalpInitIrqArbiter(DeviceObject);

            if (NT_SUCCESS(status))
            {
                status = HalpFillInIrqArbiter(
                    DeviceObject,
                    InterfaceType,
                    Version,
                    InterfaceSpecificData,
                    InterfaceBufferSize,
                    Interface,
                    Length
                    );
            }
        }
        else if (IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType)) {

            PTRANSLATOR_INTERFACE   translator;

            *Length = sizeof(TRANSLATOR_INTERFACE);
            if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            translator = (PTRANSLATOR_INTERFACE)Interface;

            //
            // Fill in the common bits.
            //

            RtlZeroMemory(translator, sizeof (TRANSLATOR_INTERFACE));
            translator->Size = sizeof(TRANSLATOR_INTERFACE);
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->Context = DeviceObject;
            translator->InterfaceReference = HalTranslatorReference;
            translator->InterfaceDereference = HalTranslatorDereference;

            //
            // Set IRQ translator for PCI interrupts.
            //

            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                                            HalIrqTranslateResourceRequirementsRoot;

            status = STATUS_SUCCESS;

            HalDebugPrint(( HAL_PNP, "Providing Irq translator for FDO %p since Pci Irq Routing is enabled!", DeviceObject));
        }
    }

    return (status);
}

#endif

VOID
HalPnpInterfaceReference(
    PVOID Context
    )
/*++

Routine Description:

    This function increments the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    InterlockedIncrement( &PdoExtension->InterfaceReferenceCount );
}

VOID
HalPnpInterfaceDereference(
    PVOID Context
    )
/*++

Routine Description:

    This function decrements the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    LONG Result;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Result = InterlockedDecrement( &PdoExtension->InterfaceReferenceCount );

    ASSERT( Result >= 0 );
}

BOOLEAN
HalPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    This function is used to translate bus addresses from legacy drivers.  It really
    should never get called on an ACPI system as the PCI or ACPI driver should field
    these requests before it gets here.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    BusAddress - Supplies the orginal address to be translated.

    Length - Supplies the length of the range to be translated.

    AddressSpace - Points to the location of of the address space type such as
        memory or I/O port.  This value is updated by the translation.

    TranslatedAddress - Returns the translated address.

Return Value:

    Returns a boolean indicating if the operations was a success.

--*/
{
    HalDebugPrint(( HAL_PNP, "HAL: HalPnpTranslateBusAddress Called, BusAddress = %p\n", BusAddress ));

    *TranslatedAddress = BusAddress;

    return TRUE;
}

PDMA_ADAPTER
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );


    //
    //  Fill in the bus number.
    //

    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\ixusage.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixusage.c

Abstract:

Author:

    Ken Reneris (kenr)

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "kdcom.h"

//
// Array to remember hal's IDT usage
//

extern ADDRESS_USAGE  *HalpAddressUsageList;
extern IDTUsage        HalpIDTUsage[];
extern KAFFINITY HalpActiveProcessors;
extern ULONG HalDisableFirmwareMapper;

PUCHAR KdComPortInUse = NULL;

ADDRESS_USAGE HalpComIoSpace = {
    NULL, CmResourceTypePort, DeviceUsage,
    {
        0x2F8,  0x8,    // Default is 2F8 for COM2.  This will be changed.
        0, 0
    }
};

VOID
HalpGetResourceSortValue (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  pRCurLoc,
    OUT PULONG                          sortscale,
    OUT PLARGE_INTEGER                  sortvalue
    );

VOID
HalpMarkAcpiHal(
    VOID
    );

USHORT HalpComPortIrqMapping[5][2] = {
    {COM1_PORT, 4},
    {COM2_PORT, 3},
    {COM3_PORT, 4},
    {COM4_PORT, 3},
    {0,0}
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpRegisterVector)
#pragma alloc_text(INIT,HalpGetResourceSortValue)
#pragma alloc_text(INIT,HalpReportResourceUsage)
#pragma alloc_text(PAGE, HalpMarkAcpiHal)
#endif




VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    )
/*++

Routine Description:

    This registers an IDT vectors usage by the HAL.

Arguments:

Return Value:

--*/
{
#if DBG
    // There are only 0ff IDT entries...
    ASSERT (SystemInterruptVector <= MAXIMUM_IDTVECTOR  &&
            BusInterruptVector <= MAXIMUM_IDTVECTOR);
#endif

    //
    // Remember which vector the hal is connecting so it can be reported
    // later on
    //

    HalpIDTUsage[SystemInterruptVector].Flags = ReportFlags;
    HalpIDTUsage[SystemInterruptVector].Irql  = SystemIrql;
    HalpIDTUsage[SystemInterruptVector].BusReleativeVector = (UCHAR) BusInterruptVector;
}


VOID
HalpGetResourceSortValue (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  pRCurLoc,
    OUT PULONG                          sortscale,
    OUT PLARGE_INTEGER                  sortvalue
    )
/*++

Routine Description:

    Used by HalpReportResourceUsage in order to properly sort
    partial_resource_descriptors.

Arguments:

    pRCurLoc    - resource descriptor

Return Value:

    sortscale   - scaling of resource descriptor for sorting
    sortvalue   - value to sort on


--*/
{
    switch (pRCurLoc->Type) {
        case CmResourceTypeInterrupt:
            *sortscale = 0;
            *sortvalue = RtlConvertUlongToLargeInteger(
                        pRCurLoc->u.Interrupt.Level );
            break;

        case CmResourceTypePort:
            *sortscale = 1;
            *sortvalue = pRCurLoc->u.Port.Start;
            break;

        case CmResourceTypeMemory:
            *sortscale = 2;
            *sortvalue = pRCurLoc->u.Memory.Start;
            break;

        default:
            *sortscale = 4;
            *sortvalue = RtlConvertUlongToLargeInteger (0);
            break;
    }
}


VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PCM_RESOURCE_LIST               RawResourceList, TranslatedResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    pRFullDesc,      pTFullDesc;
    PCM_PARTIAL_RESOURCE_LIST       pRPartList,      pTPartList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pRCurLoc,        pTCurLoc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pRSortLoc,       pTSortLoc;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  RPartialDesc,    TPartialDesc;
    ULONG   i, j, k, ListSize, Count;
    ULONG   curscale, sortscale;
    UCHAR   pass, reporton;
    INTERFACE_TYPE  interfacetype;
    ULONG           CurrentIDT, CurrentElement;
    ADDRESS_USAGE   *CurrentAddress;
    LARGE_INTEGER   curvalue, sortvalue;

    //
    // Claim the debugger com port resource if it is in use
    //
    if (KdComPortInUse != NULL) {
        HalpComIoSpace.Element[0].Start = (ULONG)(ULONG_PTR)KdComPortInUse;
        HalpRegisterAddressUsage(&HalpComIoSpace);

        //
        // The debugger does not use any interrupts. However for consistent
        // behaviour between a machine with and without a debugger, we claim
        // an interrupt for the debugger if the debugger port address is one
        // for COM1-4.
        //

        for (i = 0; HalpComPortIrqMapping[i][0]; i++) {

            if ((PUCHAR)HalpComPortIrqMapping[i][0] == KdComPortInUse) {

                HalpRegisterVector( DeviceUsage | InterruptLatched,
                                    HalpComPortIrqMapping[i][1],
                                    HalpComPortIrqMapping[i][1] +
                                    PRIMARY_VECTOR_BASE,
                                    HIGH_LEVEL);
                break;
            }
        }
    }

    //
    // Allocate some space to build the resource structure
    //

    RawResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(
                                             NonPagedPool,
                                             PAGE_SIZE*2,
                                             HAL_POOL_TAG);
    TranslatedResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(
                                                    NonPagedPool,
                                                    PAGE_SIZE*2,
                                                    HAL_POOL_TAG);
    if (!RawResourceList || !TranslatedResourceList) {

        //
        // These allocations were critical.
        //

        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     PAGE_SIZE*4,
                     1,
                     (UINT_PTR)__FILE__,
                     __LINE__
                     );
    }

    //
    // This functions assumes unset fields are zero
    //

    RtlZeroMemory(RawResourceList, PAGE_SIZE*2);
    RtlZeroMemory(TranslatedResourceList, PAGE_SIZE*2);

    //
    // Initialize the lists
    //

    RawResourceList->List[0].InterfaceType = (INTERFACE_TYPE) -1;

    pRFullDesc = RawResourceList->List;
    pRCurLoc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) RawResourceList->List;
    pTCurLoc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) TranslatedResourceList->List;



    for(pass=0; pass < 2; pass++) {
        if (pass == 0) {
            //
            // First pass - build resource lists for resources reported
            // reported against device usage.
            //

            reporton = DeviceUsage & ~IDTOwned;
            interfacetype = DeviceInterfaceToUse;
        } else {

            //
            // Second pass = build reousce lists for resources reported
            // as internal usage.
            //

            reporton = InternalUsage & ~IDTOwned;
            interfacetype = Internal;
        }

        CurrentIDT = 0;
        CurrentElement = 0;
        CurrentAddress = HalpAddressUsageList;

        for (; ;) {
            if (CurrentIDT <= MAXIMUM_IDTVECTOR) {
                //
                // Check to see if CurrentIDT needs to be reported
                //

                if (!(HalpIDTUsage[CurrentIDT].Flags & reporton)) {
                    // Don't report on this one
                    CurrentIDT++;
                    continue;
                }

                //
                // Report CurrentIDT resource
                //

                RPartialDesc.Type = CmResourceTypeInterrupt;
                RPartialDesc.ShareDisposition = CmResourceShareDriverExclusive;
                RPartialDesc.Flags =
                    HalpIDTUsage[CurrentIDT].Flags & InterruptLatched ?
                    CM_RESOURCE_INTERRUPT_LATCHED :
                    CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                RPartialDesc.u.Interrupt.Vector = HalpIDTUsage[CurrentIDT].BusReleativeVector;
                RPartialDesc.u.Interrupt.Level = HalpIDTUsage[CurrentIDT].BusReleativeVector;
                RPartialDesc.u.Interrupt.Affinity = HalpActiveProcessors;

                RtlCopyMemory (&TPartialDesc, &RPartialDesc, sizeof TPartialDesc);
                TPartialDesc.u.Interrupt.Vector = CurrentIDT;
                TPartialDesc.u.Interrupt.Level = HalpIDTUsage[CurrentIDT].Irql;

                CurrentIDT++;

            } else {
                //
                // Check to see if CurrentAddress needs to be reported
                //

                if (!CurrentAddress) {
                    break;                  // No addresses left
                }

                if (!(CurrentAddress->Flags & reporton)) {
                    // Don't report on this list
                    CurrentElement = 0;
                    CurrentAddress = CurrentAddress->Next;
                    continue;
                }

                if (!CurrentAddress->Element[CurrentElement].Length) {
                    // End of current list, go to next list
                    CurrentElement = 0;
                    CurrentAddress = CurrentAddress->Next;
                    continue;
                }

                //
                // Report CurrentAddress
                //

                RPartialDesc.Type = (UCHAR) CurrentAddress->Type;
                RPartialDesc.ShareDisposition = CmResourceShareDriverExclusive;

                if (RPartialDesc.Type == CmResourceTypePort) {
                    i = 1;              // address space port
                    RPartialDesc.Flags = CM_RESOURCE_PORT_IO;
                } else {
                    i = 0;              // address space memory
                    RPartialDesc.Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                }

                // Notice: assuming u.Memory and u.Port have the same layout
                RPartialDesc.u.Memory.Start.HighPart = 0;
                RPartialDesc.u.Memory.Start.LowPart =
                    CurrentAddress->Element[CurrentElement].Start;

                RPartialDesc.u.Memory.Length =
                    CurrentAddress->Element[CurrentElement].Length;

                // translated address = Raw address
                RtlCopyMemory (&TPartialDesc, &RPartialDesc, sizeof TPartialDesc);
                HalTranslateBusAddress (
                    interfacetype,                  // device bus or internal
                    0,                              // bus number
                    RPartialDesc.u.Memory.Start,    // source address
                    &i,                             // address space
                    &TPartialDesc.u.Memory.Start ); // translated address

                if (RPartialDesc.Type == CmResourceTypePort  &&  i == 0) {
                    TPartialDesc.Flags = CM_RESOURCE_PORT_MEMORY;
                }

                CurrentElement++;
            }

            //
            // Include the current resource in the HALs list
            //

            if (pRFullDesc->InterfaceType != interfacetype) {
                //
                // Interface type changed, add another full section
                //

                RawResourceList->Count++;
                TranslatedResourceList->Count++;

                pRFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pRCurLoc;
                pTFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pTCurLoc;

                pRFullDesc->InterfaceType = interfacetype;
                pTFullDesc->InterfaceType = interfacetype;

                pRPartList = &pRFullDesc->PartialResourceList;
                pTPartList = &pTFullDesc->PartialResourceList;

                //
                // Bump current location pointers up
                //
                pRCurLoc = pRFullDesc->PartialResourceList.PartialDescriptors;
                pTCurLoc = pTFullDesc->PartialResourceList.PartialDescriptors;
            }


            pRPartList->Count++;
            pTPartList->Count++;
            RtlCopyMemory (pRCurLoc, &RPartialDesc, sizeof RPartialDesc);
            RtlCopyMemory (pTCurLoc, &TPartialDesc, sizeof TPartialDesc);

            pRCurLoc++;
            pTCurLoc++;
        }
    }

    ListSize = (ULONG) ( ((PUCHAR) pRCurLoc) - ((PUCHAR) RawResourceList) );

    //
    // The HAL's resource usage structures have been built
    // Sort the partial lists based on the Raw resource values
    //

    pRFullDesc = RawResourceList->List;
    pTFullDesc = TranslatedResourceList->List;

    for (i=0; i < RawResourceList->Count; i++) {

        pRCurLoc = pRFullDesc->PartialResourceList.PartialDescriptors;
        pTCurLoc = pTFullDesc->PartialResourceList.PartialDescriptors;
        Count = pRFullDesc->PartialResourceList.Count;

        for (j=0; j < Count; j++) {
            HalpGetResourceSortValue (pRCurLoc, &curscale, &curvalue);

            pRSortLoc = pRCurLoc;
            pTSortLoc = pTCurLoc;

            for (k=j; k < Count; k++) {
                HalpGetResourceSortValue (pRSortLoc, &sortscale, &sortvalue);

                if (sortscale < curscale ||
                    (sortscale == curscale &&
                     RtlLargeIntegerLessThan (sortvalue, curvalue)) ) {

                    //
                    // Swap the elements..
                    //

                    RtlCopyMemory (&RPartialDesc, pRCurLoc, sizeof RPartialDesc);
                    RtlCopyMemory (pRCurLoc, pRSortLoc, sizeof RPartialDesc);
                    RtlCopyMemory (pRSortLoc, &RPartialDesc, sizeof RPartialDesc);

                    // swap translated descriptor as well
                    RtlCopyMemory (&TPartialDesc, pTCurLoc, sizeof TPartialDesc);
                    RtlCopyMemory (pTCurLoc, pTSortLoc, sizeof TPartialDesc);
                    RtlCopyMemory (pTSortLoc, &TPartialDesc, sizeof TPartialDesc);

                    // get new curscale & curvalue
                    HalpGetResourceSortValue (pRCurLoc, &curscale, &curvalue);
                }

                pRSortLoc++;
                pTSortLoc++;
            }

            pRCurLoc++;
            pTCurLoc++;
        }

        pRFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pRCurLoc;
        pTFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pTCurLoc;
    }

    HalpMarkAcpiHal();

    //
    // Inform the IO system of our resources..
    //

    IoReportHalResourceUsage (
        HalName,
        RawResourceList,
        TranslatedResourceList,
        ListSize
    );

    ExFreePool (RawResourceList);
    ExFreePool (TranslatedResourceList);
}

VOID
HalpMarkAcpiHal(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    UNICODE_STRING unicodeString;
    HANDLE hCurrentControlSet, handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Open/create System\CurrentControlSet key.
    //

    RtlInitUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");
    status = HalpOpenRegistryKey (
                 &hCurrentControlSet,
                 NULL,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 FALSE
                 );
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\Pnp
    //

    RtlInitUnicodeString(&unicodeString, L"Control\\Pnp");
    status = HalpOpenRegistryKey (
                 &handle,
                 hCurrentControlSet,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 TRUE
                 );
    ZwClose(hCurrentControlSet);
    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&unicodeString, L"DisableFirmwareMapper");
    ZwSetValueKey(handle,
                  &unicodeString,
                  0,
                  REG_DWORD,
                  &HalDisableFirmwareMapper,
                  sizeof(HalDisableFirmwareMapper)
                  );
    ZwClose(handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\merced.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Component Name:

    HALIA64

Module Name:

    merced.c

Abstract:

    This file declares the data structures related to 
    the Merced [aka Itanium] Processor.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    ToBeSpecified

Revision History:

    3/15/2000 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

#include "halp.h"
#include "ia64prof.h"
#include "merced.h"

//
// Hal Profiling Mapping for the Merced Processor.
//

HALP_PROFILE_MAPPING 
HalpMercedProfileMapping[ ProfileMercedMaximum + 1 ] = {
    //
    // XXTF - ToBeValidated: - PMCD_MASKs 
    //                       - NumberOfTicks
    //                       - EventsCount
    //                       - Event Names
//
// HALP_PROFILE_MAPPING:           Sup.,   Event,                  Source, EventMask,      Interval, DefInt, MaxInt, MinInt, Plm, PlmDef, Ov, OvDef, Pm, PmDef, UnitMask, UnitMaskDef, Threshold, ThresholdDef, Ism, IsmDef
//
// NT KE architected Profile Sources:
/* ProfileTime                 */  {TRUE, MercedCpuCycles,              0, PMCD_MASK_4567, 0, PROFILE_TIME_MERCED_DEFAULT_INTERVAL, MAXIMUM_PROFILE_INTERVAL, MINIMUM_PROFILE_INTERVAL, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileAlignmentFixup       */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileTotalIssues          */  {TRUE, MercedInstRetired,            0, PMCD_MASK_45, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfilePipelineDry          */  {TRUE, MercedPipelineFlushes,        0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileLoadInstructions     */  {TRUE, MercedRetiredLoads,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfilePipelineFrozen       */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileBranchInstructions   */  {TRUE, MercedBranchInstructions,     0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileTotalNonissues       */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ? MercedNonIssue
/* ProfileDcacheMisses         */  {TRUE, MercedL1DataMisses,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileIcacheMisses         */  {TRUE, MercedL1InstMisses,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileCacheMisses          */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileBranchMispredictions */  {TRUE, MercedBranchMispredictDetail, 0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileStoreInstructions    */  {TRUE, MercedRetiredStores,          0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileFpInstructions       */  {FALSE /* FALSE until Derived Event are implemented */, MercedFPOperationsRetired,    0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileIntegerInstructions  */  {TRUE, MercedIntegerInstructions,    0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* Profile2Issue               */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* Profile3Issue               */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* Profile4Issue               */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileSpecialInstructions  */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileTotalCycles          */  {TRUE, MercedCpuCycles,              0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileIcacheIssues         */  {TRUE, MercedInstReferences,         0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileDcacheAccesses       */  {TRUE, MercedDataReferences,         0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMemoryBarrierCycles  */  {TRUE, MercedMemoryStallCycles,      0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileLoadLinkedIssues     */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileMaximum              */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // End of NT KE architected Profile Sources.
// NT IA64 Processor specific Profile Sources:
//      Merced Monitored Events:
/* ProfileMercedBranchMispredictStallCycles  */ {TRUE, MercedBranchMispredictStallCycles   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstAccessStallCycles        */ {TRUE, MercedInstAccessStallCycles         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedExecLatencyStallCycles       */	{TRUE, MercedExecLatencyStallCycles        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataAccessStallCycles        */ {TRUE, MercedDataAccessStallCycles         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedBranchStallCycles            */ {TRUE, MercedBranchStallCycles             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstFetchStallCycles         */ {TRUE, MercedInstFetchStallCycles          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedExecStallCycles              */ {TRUE, MercedExecStallCycles               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedMemoryStallCycles            */ {TRUE, MercedMemoryStallCycles             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedTaggedInstRetired            */ {TRUE, MercedTaggedInstRetired             ,0, PMCD_MASK_45, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstRetired                  */ {TRUE, MercedInstRetired                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedFPOperationsRetiredLow       */ {TRUE, MercedFPOperationsRetiredLow        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedFPOperationsRetiredHigh      */ {TRUE, MercedFPOperationsRetiredHigh       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedFPFlushesToZero              */ {TRUE, MercedFPFlushesToZero               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedSIRFlushes                   */ {TRUE, MercedSIRFlushes                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedBranchTakenDetail            */ {TRUE, MercedBranchTakenDetail             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedBranchMultiWayDetail         */ {TRUE, MercedBranchMultiWayDetail          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedBranchPathPrediction         */ {TRUE, MercedBranchPathPrediction          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedBranchMispredictDetail       */ {TRUE, MercedBranchMispredictDetail        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedBranchEvents                 */ {TRUE, MercedBranchEvents                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedCpuCycles                    */ {TRUE, MercedCpuCycles                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedISATransitions               */ {TRUE, MercedISATransitions                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedIA32InstRetired              */ {TRUE, MercedIA32InstRetired               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1InstReads                  */ {TRUE, MercedL1InstReads                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1InstFills                  */ {TRUE, MercedL1InstFills                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1InstMisses                 */ {TRUE, MercedL1InstMisses                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstEAREvents                */ {TRUE, MercedInstEAREvents                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1InstPrefetches             */ {TRUE, MercedL1InstPrefetches              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2InstPrefetches             */ {TRUE, MercedL2InstPrefetches              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstStreamingBufferLinesIn   */ {TRUE, MercedInstStreamingBufferLinesIn    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstTLBDemandFetchMisses     */ {TRUE, MercedInstTLBDemandFetchMisses      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstTLBHPWInserts            */ {TRUE, MercedInstTLBHPWInserts             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstDispersed                */ {TRUE, MercedInstDispersed                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedExplicitStops                */ {TRUE, MercedExplicitStops                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedImplicitStops                */ {TRUE, MercedImplicitStops                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstNOPRetired               */ {TRUE, MercedInstNOPRetired                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstPredicateSquashedRetired */ {TRUE, MercedInstPredicateSquashedRetired  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedRSELoadRetired               */ {TRUE, MercedRSELoadRetired                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedPipelineFlushes              */ {TRUE, MercedPipelineFlushes               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedCpuCPLChanges                */ {TRUE, MercedCpuCPLChanges                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedFailedSpeculativeCheckLoads  */ {TRUE, MercedFailedSpeculativeCheckLoads   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_INTANDFP_OPS, PMC_UNIT_MASK_INTANDFP_OPS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedAdvancedCheckLoads           */ {TRUE, MercedAdvancedCheckLoads            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_INTANDFP_OPS, PMC_UNIT_MASK_INTANDFP_OPS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedFailedAdvancedCheckLoads     */ {TRUE, MercedFailedAdvancedCheckLoads      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_INTANDFP_OPS, PMC_UNIT_MASK_INTANDFP_OPS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedALATOverflows                */ {TRUE, MercedALATOverflows                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_INTANDFP_OPS, PMC_UNIT_MASK_INTANDFP_OPS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedExternBPMPins03Asserted      */ {TRUE, MercedExternBPMPins03Asserted       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedExternBPMPins45Asserted      */ {TRUE, MercedExternBPMPins45Asserted       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataTCMisses                 */ {TRUE, MercedDataTCMisses                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataTLBMisses                */ {TRUE, MercedDataTLBMisses                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataTLBHPWInserts            */ {TRUE, MercedDataTLBHPWInserts             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataReferences               */ {TRUE, MercedDataReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1DataReads                  */ {TRUE, MercedL1DataReads                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedRSEAccesses                  */ {TRUE, MercedRSEAccesses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1DataReadMisses             */ {TRUE, MercedL1DataReadMisses              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1DataEAREvents              */ {TRUE, MercedL1DataEAREvents               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2References                 */ {TRUE, MercedL2References                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2DataReferences             */ {TRUE, MercedL2DataReferences              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2Misses                     */ {TRUE, MercedL2Misses                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1DataForcedLoadMisses       */ {TRUE, MercedL1DataForcedLoadMisses        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedRetiredLoads                 */ {TRUE, MercedRetiredLoads                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedRetiredStores                */ {TRUE, MercedRetiredStores                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedRetiredUncacheableLoads      */ {TRUE, MercedRetiredUncacheableLoads       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedRetiredUncacheableStores     */ {TRUE, MercedRetiredUncacheableStores      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedRetiredMisalignedLoads       */ {TRUE, MercedRetiredMisalignedLoads        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedRetiredMisalignedStores      */ {TRUE, MercedRetiredMisalignedStores       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2Flushes                    */ {TRUE, MercedL2Flushes                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2FlushesDetail              */ {TRUE, MercedL2FlushesDetail               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3References                 */ {TRUE, MercedL3References                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, 
/* ProfileMercedL3Misses                     */ {TRUE, MercedL3Misses                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, 
/* ProfileMercedL3Reads                      */ {TRUE, MercedL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3Writes                     */ {TRUE, MercedL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3LinesReplaced              */ {TRUE, MercedL3LinesReplaced               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
	//
	// 02/08/00 - Are missing: [at least]
	//      - Front-Side bus events,
	//      - IVE events,
	//      - Debug monitor events,
	//      - ...
	//
	//
//      Merced Derived Events:
//      ProfileMercedDerivedEventMinimum,
/* ProfileMercedRSEStallCycles              */ {TRUE, MercedRSEStallCycles                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedIssueLimitStallCycles       */ {TRUE, MercedIssueLimitStallCycles           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedTakenBranchStallCycles      */ {TRUE, MercedTakenBranchStallCycles          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedFetchWindowStallCycles      */ {TRUE, MercedFetchWindowStallCycles          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedIA64InstPerCycle            */ {TRUE, MercedIA64InstPerCycle                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedIA32InstPerCycle            */ {TRUE, MercedIA32InstPerCycle                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedAvgIA64InstPerTransition    */ {TRUE, MercedAvgIA64InstPerTransition        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedAvgIA32InstPerTransition    */ {TRUE, MercedAvgIA32InstPerTransition        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedAvgIA64CyclesPerTransition  */ {TRUE, MercedAvgIA64CyclesPerTransition      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedAvgIA32CyclesPerTransition  */ {TRUE, MercedAvgIA32CyclesPerTransition      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1InstReferences            */ {TRUE, MercedL1InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1InstMissRatio             */ {TRUE, MercedL1InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1DataReadMissRatio         */ {TRUE, MercedL1DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2MissRatio                 */ {TRUE, MercedL2MissRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2DataMissRatio             */ {TRUE, MercedL2DataMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2InstMissRatio             */ {TRUE, MercedL2InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2DataReadMissRatio         */ {TRUE, MercedL2DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2DataWriteMissRatio        */ {TRUE, MercedL2DataWriteMissRatio            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2InstFetchRatio            */ {TRUE, MercedL2InstFetchRatio                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2DataRatio                 */ {TRUE, MercedL2DataRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3MissRatio                 */ {TRUE, MercedL3MissRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3DataMissRatio             */ {TRUE, MercedL3DataMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3InstMissRatio             */ {TRUE, MercedL3InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3DataReadMissRatio         */ {TRUE, MercedL3DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3DataRatio                 */ {TRUE, MercedL3DataRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstReferences              */ {TRUE, MercedInstReferences                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstTLBMissRatio            */ {TRUE, MercedInstTLBMissRatio                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataTLBMissRatio            */ {TRUE, MercedDataTLBMissRatio                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataTCMissRatio             */ {TRUE, MercedDataTCMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstTLBEAREvents            */ {TRUE, MercedInstTLBEAREvents                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataTLBEAREvents            */ {TRUE, MercedDataTLBEAREvents                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedCodeDebugRegisterMatches    */ {TRUE, MercedCodeDebugRegisterMatches        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataDebugRegisterMatches    */ {TRUE, MercedDataDebugRegisterMatches        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedControlSpeculationMissRatio */ {TRUE, MercedControlSpeculationMissRatio     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedDataSpeculationMissRatio    */ {TRUE, MercedDataSpeculationMissRatio        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedALATCapacityMissRatio       */ {TRUE, MercedALATCapacityMissRatio           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1DataWayMispredicts        */ {TRUE, MercedL1DataWayMispredicts            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2InstReferences            */ {TRUE, MercedL2InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedInstFetches                 */ {TRUE, MercedInstFetches                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2DataReads                 */ {TRUE, MercedL2DataReads                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2DataWrites                */ {TRUE, MercedL2DataWrites                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3InstReferences            */ {TRUE, MercedL3InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3InstMisses                */ {TRUE, MercedL3InstMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3InstHits                  */ {TRUE, MercedL3InstHits                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3DataReferences            */ {TRUE, MercedL3DataReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3LoadReferences            */ {TRUE, MercedL3LoadReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3LoadMisses                */ {TRUE, MercedL3LoadMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3LoadHits                  */ {TRUE, MercedL3LoadHits                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3ReadReferences            */ {TRUE, MercedL3ReadReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3ReadMisses                */ {TRUE, MercedL3ReadMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3ReadHits                  */ {TRUE, MercedL3ReadHits                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3StoreReferences           */ {TRUE, MercedL3StoreReferences               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3StoreMisses               */ {TRUE, MercedL3StoreMisses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL3StoreHits                 */ {TRUE, MercedL3StoreHits                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2WriteBackReferences       */ {TRUE, MercedL2WriteBackReferences           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2WriteBackMisses           */ {TRUE, MercedL2WriteBackMisses               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2WriteBackHits             */ {TRUE, MercedL2WriteBackHits                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2WriteReferences           */ {TRUE, MercedL2WriteReferences               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2WriteMisses               */ {TRUE, MercedL2WriteMisses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL2WriteHits                 */ {TRUE, MercedL2WriteHits                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedBranchInstructions          */ {TRUE, MercedBranchInstructions              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedIntegerInstructions         */ {TRUE, MercedIntegerInstructions             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedL1DataMisses                */ {TRUE, MercedL1DataMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedFPOperationsRetired         */  {TRUE, MercedFPOperationsRetired            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMercedMaximum                     */ {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\miscs.s ===
//
//
// Module Name:  miscs.s
//
// Description:
//
//    miscellaneous assembly functions used by hal.
//
// Target Platform:
//
//    IA-64
//
// Reuse: None
//
//

#include "regia64.h"
#include "kxia64.h"

//++
// Name: HalpLockedIncrementUlong(Sync)
// 
// Routine Description:
//
//    Atomically increment a variable. 
//
// Arguments:
//
//    Sync:  Synchronization variable
//
// Return Value: NONE
//
//--


        LEAF_ENTRY(HalpLockedIncrementUlong)
        LEAF_SETUP(1,2,0,0)

        ARGPTR(a0)

        ;;
        fetchadd4.acq.nt1    t1 = [a0], 1
        ;;

        LEAF_RETURN
        LEAF_EXIT(HalpLockedIncrementUlong)

//++
// Name: HalpGetReturnAddress()
// 
// Routine Description:
//
//    Returns b0
//
// Arguments:
//
//    NONE
//
// Return Value: b0
//
//--


        LEAF_ENTRY(HalpGetReturnAddress)
        LEAF_SETUP(0,2,0,0)

        mov    v0 = b0
        ;;

        LEAF_RETURN
        LEAF_EXIT(HalpGetReturnAddress)

//++
// VOID
// HalSweepIcacheRange (
//     IN PVOID BaseAddress,
//     IN SIZE_T Length
//     )
//
//
// Routine Description:
//     This function sweeps the range of address in the I cache throughout the
//     system.
//
// Arguments:
//     BaseAddress - Supplies the starting virtual address of a range of
//        virtual addresses that are to be flushed from the data cache.
//  
//     Length - Supplies the length of the range of virtual addresses
//        that are to be flushed from the data cache.
// 
// 
// Return Value:
// 
//     None.
// 
// 
// PS: HalSweepIcacheRange just flushes the cache. It does not synchrnoize the
//  I-Fetch pipeline with the flush operation. To Achieve pipeline flush also,
//  one has to call KeSweepCacheRange.
//--

        .global CacheFlushStride

        LEAF_ENTRY(HalSweepIcacheRange)
        LEAF_SETUP(2,0,0,0)

	addl	r26=@gprel(CacheFlushStride),gp
	add	r29=r32, r33
	;;

	ld4	r30=[r26]
        ;;

	adds	r28=-1, r30
	;;

	andcm	r27=r32, r28
	;;

$L16123:
	// fc	 r27
	fc.i	 r27
	add	r27=r30, r27
        ;;

	cmp.ltu	p14,p15=r27, r29
  (p14)	br.cond.dptk.few $L16123
        ;;

	br.ret.sptk.few b0
        ;;

        LEAF_RETURN
        LEAF_EXIT(HalSweepIcacheRange)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\merced.h ===
#ifndef MERCED_H_INCLUDED
#define MERCED_H_INCLUDED

/*++

Copyright (c) 1989-2000  Microsoft Corporation

Component Name:

    HALIA64

Module Name:

    merced.h

Abstract:

    This header file presents IA64 Itanium [aka Merced] definitions.
    Like profiling definitions.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    ToBeSpecified

Revision History:

    3/15/2000 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

//
//  Merced Monitored Events:
//

typedef enum _MERCED_MONITOR_EVENT {
    MercedMonitoredEventMinimum         = 0x00,
    MercedBranchMispredictStallCycles   = 0x00,  //  "BRANCH_MISPRED_CYCLE"  
    MercedInstAccessStallCycles         = 0x01,  //  "INST_ACCESS_CYCLE"     
    MercedExecLatencyStallCycles        = 0x02,  //  "EXEC_LATENCY_CYCLE"
    MercedDataAccessStallCycles         = 0x03,  //  "DATA_ACCESS_CYCLE"
    MercedBranchStallCycles             = 0x04,  //  "BRANCH_CYCLE",       
    MercedInstFetchStallCycles          = 0x05,  //  "INST_FETCH_CYCLE",   
    MercedExecStallCycles               = 0x06,  //  "EXECUTION_CYCLE",    
    MercedMemoryStallCycles             = 0x07,  //  "MEMORY_CYCLE",       
    MercedTaggedInstRetired             = 0x08,  //  "IA64_TAGGED_INSTRS_RETIRED",   XXTF - ToBeDone: Set Event Qualification
    MercedInstRetired                   = 0x08,  //  "IA64_INSTS_RETIRED.u", 
    MercedFPOperationsRetiredLow        = 0x09,  //  "FP_OPS_RETIRED_LO",
    MercedFPOperationsRetiredHigh       = 0x0a,  //  "FP_OPS_RETIRED_HI",
    MercedFPFlushesToZero               = 0x0b,  //  "FP_FLUSH_TO_ZERO",     
    MercedSIRFlushes                    = 0x0c,  //  "FP_SIR_FLUSH",     
    MercedBranchTakenDetail             = 0x0d,  //  "BR_TAKEN_DETAIL",       // XXTF - ToBeDone - Slot specification[0,1,2,NO] + addresses range
    MercedBranchMultiWayDetail          = 0x0e,  //  "BR_MWAY_DETAIL",        // XXTF - ToBeDone - Not taken/Taken/all path + Prediction outcome + address range
    MercedBranchPathPrediction          = 0x0f,  //  "BR_PATH_PREDICTION",    // XXTF - ToBeDone - BRANCH_PATH_RESULT specification + address range
    MercedBranchMispredictDetail        = 0x10,  //  "BR_MISPREDICT_DETAIL",  // XXTF - ToBeDone - Prediction outcome specification + address range
    MercedBranchEvents                  = 0x11,  //  "BRANCH_EVENT",    
    MercedCpuCycles                     = 0x12,  //  "CPU_CYCLES",            // XXTF - ToBeDone - All/IA64/IA32
    MercedISATransitions                = 0x14,  //  "ISA_TRANSITIONS", 
    MercedIA32InstRetired               = 0x15,  //  "IA32_INSTR_RETIRED", 
    MercedL1InstReads                   = 0x20,  //  "L0I_READS",             // XXTF - ToBeDone - + address range
    MercedL1InstFills                   = 0x21,  //  "L0I_FILLS",             // XXTF - ToBeDone - + address range
    MercedL1InstMisses                  = 0x22,  //  "L0I_MISSES",            // XXTF - ToBeDone - + address range
    MercedInstEAREvents                 = 0x23,  //  "INSTRUCTION_EAR_EVENTS",  
    MercedL1InstPrefetches              = 0x24,  //  "L0I_IPREFETCHES",       // XXTF - ToBeDone - + address range
    MercedL2InstPrefetches              = 0x25,  //  "L1_INST_PREFETCHES",    // XXTF - ToBeDone - + address range  
    MercedInstStreamingBufferLinesIn    = 0x26,  //  "ISB_LINES_IN",          // XXTF - ToBeDone - + address range
    MercedInstTLBDemandFetchMisses      = 0x27,  //  "ITLB_MISSES_FETCH",     // XXTF - ToBeDone - + ??? address range + PMC.umask on L1ITLB/L2ITLB/ALL/NOTHING.
    MercedInstTLBHPWInserts             = 0x28,  //  "ITLB_INSERTS_HPW",      // XXTF - ToBeDone - + ??? address range  
    MercedInstDispersed                 = 0x2d,  //  "INST_DISPERSED",        
    MercedExplicitStops                 = 0x2e,  //  "EXPL_STOPBITS",    
    MercedImplicitStops                 = 0x2f,  //  "IMPL_STOPS_DISPERSED",    
    MercedInstNOPRetired                = 0x30,  //  "NOPS_RETIRED",     
    MercedInstPredicateSquashedRetired  = 0x31,  //  "PREDICATE_SQUASHED_RETIRED", 
    MercedRSELoadRetired                = 0x32,  //  "RSE_LOADS_RETIRED", 
    MercedPipelineFlushes               = 0x33,  //  "PIPELINE_FLUSH",    
    MercedCpuCPLChanges                 = 0x34,  //  "CPU_CPL_CHANGES",   
    MercedFailedSpeculativeCheckLoads   = 0x35,  //  "INST_FAILED_CHKS_RETIRED",   // XXTF - ToBeDone - INST_TYPE
    MercedAdvancedCheckLoads            = 0x36,  //  "ALAT_INST_CHKA_LDC",         // XXTF - ToBeDone - INST_TYPE
    MercedFailedAdvancedCheckLoads      = 0x37,  //  "ALAT_INST_FAILED_CHKA_LDC",  // XXTF - ToBeDone - INST_TYPE
    MercedALATOverflows                 = 0x38,  //  "ALAT_CAPACITY_MISS",         // XXTF - ToBeDone - INST_TYPE
    MercedExternBPMPins03Asserted       = 0x5e,  //  "EXTERN_BPM_PINS_0_TO_3",     
    MercedExternBPMPins45Asserted       = 0x5f,  //  "EXTERN_BPM_PINS_4_TO_5",     
    MercedDataTCMisses                  = 0x60,  //  "DTC_MISSES",            // XXTF - ToBeDone - + ??? address range
    MercedDataTLBMisses                 = 0x61,  //  "DTLB_MISSES",           // XXTF - ToBeDone - + ??? address range
    MercedDataTLBHPWInserts             = 0x62,  //  "DTLB_INSERTS_HPW",      // XXTF - ToBeDone - + ??? address range
    MercedDataReferences                = 0x63,  //  "DATA_REFERENCES_RETIRED", // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL1DataReads                   = 0x64,  //  "L1D_READS_RETIRED",       // XXTF - ToBeDone - + ibr, opcode, dbr                                       
    MercedRSEAccesses                   = 0x65,  //  "RSE_REFERENCES_RETIRED",     
    MercedL1DataReadMisses              = 0x66,  //  "L1D_READ_MISSES_RETIRED", // XXTF - ToBeDone - + ibr, opcode, dbr   
    MercedL1DataEAREvents               = 0x67,  //  "DATA_EAR_EVENTS",   
    MercedL2References                  = 0x68,  //  "L2_REFERENCES",           // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL2DataReferences              = 0x69,  //  "L2_DATA_REFERENCES",      // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL2Misses                      = 0x6a,  //  "L2_MISSES",               // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL1DataForcedLoadMisses        = 0x6b,  //  "L1D_READ_FORCED_MISSES_RETIRED", // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedRetiredLoads                  = 0x6c,  //  "LOADS_RETIRED",      
    MercedRetiredStores                 = 0x6d,  //  "STORES_RETIRED",     
    MercedRetiredUncacheableLoads       = 0x6e,  //  "UC_LOADS_RETIRED",   
    MercedRetiredUncacheableStores      = 0x6f,  //  "UC_STORES_RETIRED",  
    MercedRetiredMisalignedLoads        = 0x70,  //  "MISALIGNED_LOADS_RETIRED",       
    MercedRetiredMisalignedStores       = 0x71,  //  "MISALIGNED_STORES_RETIRED",      
    MercedL2Flushes                     = 0x76,  //  "L2_FLUSHES",              // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL2FlushesDetail               = 0x77,  //  "L2_FLUSH_DETAILS",        // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL3References                  = 0x7b,  //  "L3_REFERENCES",     
    MercedL3Misses                      = 0x7c,  //  "L3_MISSES",       
    MercedL3Reads                       = 0x7d,  //  "L3_READS",        
    MercedL3Writes                      = 0x7e,  //  "L3_WRITES",       
    MercedL3LinesReplaced               = 0x7f,  //  "L3_LINES_REPLACED",
//
// 02/08/00 - Are missing: [at least]
//      - Front-Side bus events,
//      - IVE events,
//      - Debug monitor events,
//      - ...
//
} MERCED_MONITOR_EVENT;

//
// Merced Derived Events:
//
// Assumption: MercedDerivedEventMinimum > MercedMonitoredEventMaximum.
//

typedef enum _MERCED_DERIVED_EVENT {
    MercedDerivedEventMinimum           = 0x100, /* > Maximum of Merced Monitored Event */
    MercedRSEStallCycles                = MercedDerivedEventMinimum, // XXTF - ToBeDone - (MercedMemoryStallCycles    - MercedDataStallAccessCycles)
    MercedIssueLimitStallCycles,        // XXTF - ToBeDone - (MercedExecStallCycles      - MercedExecLatencyStallCycles)
    MercedTakenBranchStallCycles,       // XXTF - ToBeDone - (MercedBranchStallCycles    - MercedBranchMispredictStallCycles)
    MercedFetchWindowStallCycles,       // XXTF - ToBeDone - (MercedInstFetchStallCycles - MercedInstAccessStallCycles)
    MercedIA64InstPerCycle,             // XXTF - ToBeDone - (IA64_INST_RETIRED.u        / CPU_CYCLES[IA64])
    MercedIA32InstPerCycle,             // XXTF - ToBeDone - (IA32_INSTR_RETIRED         / CPU_CYCLES[IA32])
    MercedAvgIA64InstPerTransition,     // XXTF - ToBeDone - (IA64_INST_RETIRED.u        / (ISA_TRANSITIONS * 2))
    MercedAvgIA32InstPerTransition,     // XXTF - ToBeDone - (IA32_INSTR_RETIRED         / (ISA_TRANSITIONS * 2))
    MercedAvgIA64CyclesPerTransition,   // XXTF - ToBeDone - (CPU_CYCLES[IA64]           / (ISA_TRANSITIONS * 2))
    MercedAvgIA32CyclesPerTransition,   // XXTF - ToBeDone - (CPU_CYCLES[IA32]           / (ISA_TRANSITIONS * 2))
    MercedL1InstReferences,             // XXTF - ToBeDone - (L1I_READS                  / L1I_IPREFETCHES) 
    MercedL1InstMissRatio,              // XXTF - ToBeDone - (L1I_MISSES                 / MercedL1InstReferences)
    MercedL1DataReadMissRatio,          // XXTF - ToBeDone - (L1D_READS_MISSES_RETIRED   / L1D_READS_RETIRED)
    MercedL2MissRatio,                  // XXTF - ToBeDone - (L2_MISSES                  / L2_REFERENCES)     
    MercedL2DataMissRatio,              // XXTF - ToBeDone - (L3_DATA_REFERENCES         / L2_DATA_REFERENCES)
    MercedL2InstMissRatio,              // XXTF - ToBeDone - (L3_DATA_REFERENCES         / L2_DATA_REFERENCES)
    MercedL2DataReadMissRatio,          // XXTF - ToBeDone - (L3_LOAD_REFERENCES.u       / L2_DATA_READS.u)     
    MercedL2DataWriteMissRatio,         // XXTF - ToBeDone - (L3_STORE_REFERENCES.u      / L2_DATA_WRITES.u)    
    MercedL2InstFetchRatio,             // XXTF - ToBeDone - (L1I_MISSES                 / L2_REFERENCES) 
    MercedL2DataRatio,                  // XXTF - ToBeDone - (L2_DATA_REFERENCES         / L2_REFERENCES) 
    MercedL3MissRatio,                  // XXTF - ToBeDone - (L3_MISSES                  / L2_MISSES)     
    MercedL3DataMissRatio,              // XXTF - ToBeDone - ((L3_LOAD_MISSES.u + L3_STORE_MISSES.u) / L3_REFERENCES.d)     
    MercedL3InstMissRatio,              // XXTF - ToBeDone - (L3_INST_MISSES.u           / L3_INST_REFERENCES.u)     
    MercedL3DataReadMissRatio,          // XXTF - ToBeDone - (L3_LOAD_REFERENCES.u       / L3_DATA_REFERENCES.d)     
    MercedL3DataRatio,                  // XXTF - ToBeDone - (L3_DATA_REFERENCES.d       / L3_REFERENCES)     
    MercedInstReferences,               // XXTF - ToBeDone - (L1I_READS)                                  
    MercedInstTLBMissRatio,             // XXTF - ToBeDone - (ITLB_MISSES_FETCH          / L1I_READS)     
    MercedDataTLBMissRatio,             // XXTF - ToBeDone - (DTLB_MISSES                / DATA_REFERENCES_RETIRED)
    MercedDataTCMissRatio,              // XXTF - ToBeDone - (DTC_MISSES                 / DATA_REFERENCES_RETIRED)
    MercedInstTLBEAREvents,             // XXTF - ToBeDone - (INSTRUCTION_EAR_EVENTS)
    MercedDataTLBEAREvents,             // XXTF - ToBeDone - (DATA_EAR_EVENTS)
    MercedCodeDebugRegisterMatches,     // XXTF - ToBeDone - (IA64_TAGGED_INSTRS_RETIRED)
    MercedDataDebugRegisterMatches,     // XXTF - ToBeDone - (LOADS_RETIRED              + STORES_RETIRED)
    MercedControlSpeculationMissRatio,  // XXTF - ToBeDone - (INST_FAILED_CHKS_RETIRED   / IA64_TAGGED_INSTRS_RETIRED[chk.s])
    MercedDataSpeculationMissRatio,     // XXTF - ToBeDone - (ALAT_INST_FAILED_CHKA_LDC  / ALAT_INST_CHKA_LDC)
    MercedALATCapacityMissRatio,        // XXTF - ToBeDone - (ALAT_CAPACITY_MISS         / IA64_TAGGED_INSTRS_RETIRED[ld.sa,ld.a,ldfp.a,ldfp.sa])
    MercedL1DataWayMispredicts,         // XXTF - ToBeDone - (EventCode: 0x33 / Umask: 0x2)
    MercedL2InstReferences,             // XXTF - ToBeDone - (L1I_MISSES                 + L2_INST_PREFETCHES)
    MercedInstFetches,                  // XXTF - ToBeDone - (L1I_MISSES)
    MercedL2DataReads,                  // XXTF - ToBeDone - (L2_DATA_REFERENCES/0x1)
    MercedL2DataWrites,                 // XXTF - ToBeDone - (L2_DATA_REFERENCES/0x2)
    MercedL3InstReferences,             // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3InstMisses,                 // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3InstHits,                   // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3DataReferences,             // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3LoadReferences,             // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3LoadMisses,                 // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3LoadHits,                   // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3ReadReferences,             // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3ReadMisses,                 // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3ReadHits,                   // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3StoreReferences,            // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3StoreMisses,                // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3StoreHits,                  // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteBackReferences,        // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteBackMisses,            // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteBackHits,              // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteReferences,            // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteMisses,                // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteHits,                  // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedBranchInstructions,           // XXTF - ToBeDone - (TAGGED_INSTR + opcode)
    MercedIntegerInstructions,          // XXTF - ToBeDone - (TAGGED_INSTR + opcode)
    MercedL1DataMisses,                 // XXTF - ToBeDone - 
    MercedFPOperationsRetired,          // XXTF - ToBeDone - ((FP_OPS_RETIRED_HI * 4) + FP_OPS_RETIRED_LO
} MERCED_DERIVED_EVENT;

typedef enum _KPROFILE_MERCED_SOURCE {
//
// Profile Merced Monitored Events:
//
    ProfileMercedMonitoredEventMinimum       = ProfileMaximum + 0x1,
	ProfileMercedBranchMispredictStallCycles = ProfileMercedMonitoredEventMinimum,
	ProfileMercedInstAccessStallCycles,
	ProfileMercedExecLatencyStallCycles,
	ProfileMercedDataAccessStallCycles,
	ProfileMercedBranchStallCycles,
	ProfileMercedInstFetchStallCycles,
	ProfileMercedExecStallCycles,
	ProfileMercedMemoryStallCycles,
	ProfileMercedTaggedInstRetired,
	ProfileMercedInstRetired,
	ProfileMercedFPOperationsRetiredLow,
	ProfileMercedFPOperationsRetiredHigh,
	ProfileMercedFPFlushesToZero,
	ProfileMercedSIRFlushes,
	ProfileMercedBranchTakenDetail,
	ProfileMercedBranchMultiWayDetail,
	ProfileMercedBranchPathPrediction,
	ProfileMercedBranchMispredictDetail,
	ProfileMercedBranchEvents,
	ProfileMercedCpuCycles,
	ProfileMercedISATransitions,
	ProfileMercedIA32InstRetired,
	ProfileMercedL1InstReads,
	ProfileMercedL1InstFills,
	ProfileMercedL1InstMisses,
	ProfileMercedInstEAREvents,
	ProfileMercedL1InstPrefetches,
	ProfileMercedL2InstPrefetches,
	ProfileMercedInstStreamingBufferLinesIn,
	ProfileMercedInstTLBDemandFetchMisses,
	ProfileMercedInstTLBHPWInserts,
	ProfileMercedInstDispersed,
	ProfileMercedExplicitStops,
	ProfileMercedImplicitStops,
	ProfileMercedInstNOPRetired,
	ProfileMercedInstPredicateSquashedRetired,
	ProfileMercedRSELoadRetired,
	ProfileMercedPipelineFlushes,
	ProfileMercedCpuCPLChanges,
	ProfileMercedFailedSpeculativeCheckLoads,
	ProfileMercedAdvancedCheckLoads,
	ProfileMercedFailedAdvancedCheckLoads,
	ProfileMercedALATOverflows,
	ProfileMercedExternBPMPins03Asserted,
	ProfileMercedExternBPMPins45Asserted,
	ProfileMercedDataTCMisses,
	ProfileMercedDataTLBMisses,
	ProfileMercedDataTLBHPWInserts,
	ProfileMercedDataReferences,
	ProfileMercedL1DataReads,
	ProfileMercedRSEAccesses,
	ProfileMercedL1DataReadMisses,
	ProfileMercedL1DataEAREvents,
	ProfileMercedL2References,
	ProfileMercedL2DataReferences,
	ProfileMercedL2Misses,
	ProfileMercedL1DataForcedLoadMisses,
	ProfileMercedRetiredLoads,
	ProfileMercedRetiredStores,
	ProfileMercedRetiredUncacheableLoads,
	ProfileMercedRetiredUncacheableStores,
	ProfileMercedRetiredMisalignedLoads,
	ProfileMercedRetiredMisalignedStores,
	ProfileMercedL2Flushes,
	ProfileMercedL2FlushesDetail,
	ProfileMercedL3References,
	ProfileMercedL3Misses,
	ProfileMercedL3Reads,
	ProfileMercedL3Writes,
	ProfileMercedL3LinesReplaced,
	//
	// 02/08/00 - Are missing: [at least]
	//      - Front-Side bus events,
	//      - IVE events,
	//      - Debug monitor events,
	//      - ...
	//
//
// Profile Merced Derived Events:
//
    ProfileMercedDerivedEventMinimum,
    ProfileMercedRSEStallCycles               = ProfileMercedDerivedEventMinimum,
    ProfileMercedIssueLimitStallCycles,
    ProfileMercedTakenBranchStallCycles,
    ProfileMercedFetchWindowStallCycles,
    ProfileMercedIA64InstPerCycle,
    ProfileMercedIA32InstPerCycle,
    ProfileMercedAvgIA64InstPerTransition,
    ProfileMercedAvgIA32InstPerTransition,
    ProfileMercedAvgIA64CyclesPerTransition,
    ProfileMercedAvgIA32CyclesPerTransition,
    ProfileMercedL1InstReferences,
    ProfileMercedL1InstMissRatio,
    ProfileMercedL1DataReadMissRatio,
    ProfileMercedL2MissRatio,
    ProfileMercedL2DataMissRatio,
    ProfileMercedL2InstMissRatio,
    ProfileMercedL2DataReadMissRatio,
    ProfileMercedL2DataWriteMissRatio,
    ProfileMercedL2InstFetchRatio,
    ProfileMercedL2DataRatio,
    ProfileMercedL3MissRatio,
    ProfileMercedL3DataMissRatio,
    ProfileMercedL3InstMissRatio,
    ProfileMercedL3DataReadMissRatio,
    ProfileMercedL3DataRatio,
    ProfileMercedInstReferences,
    ProfileMercedInstTLBMissRatio,
    ProfileMercedDataTLBMissRatio,
    ProfileMercedDataTCMissRatio,
    ProfileMercedInstTLBEAREvents,
    ProfileMercedDataTLBEAREvents,
    ProfileMercedCodeDebugRegisterMatches,
    ProfileMercedDataDebugRegisterMatches,
    ProfileMercedControlSpeculationMissRatio,
    ProfileMercedDataSpeculationMissRatio,
    ProfileMercedALATCapacityMissRatio,
    ProfileMercedL1DataWayMispredicts,
    ProfileMercedL2InstReferences,
    ProfileMercedInstFetches,
    ProfileMercedL2DataReads,
    ProfileMercedL2DataWrites,
    ProfileMercedL3InstReferences,
    ProfileMercedL3InstMisses,
    ProfileMercedL3InstHits,
    ProfileMercedL3DataReferences,
    ProfileMercedL3LoadReferences,
    ProfileMercedL3LoadMisses,
    ProfileMercedL3LoadHits,
    ProfileMercedL3ReadReferences,
    ProfileMercedL3ReadMisses,
    ProfileMercedL3ReadHits,
    ProfileMercedL3StoreReferences,
    ProfileMercedL3StoreMisses,
    ProfileMercedL3StoreHits,
    ProfileMercedL2WriteBackReferences,
    ProfileMercedL2WriteBackMisses,
    ProfileMercedL2WriteBackHits,
    ProfileMercedL2WriteReferences,
    ProfileMercedL2WriteMisses,
    ProfileMercedL2WriteHits,
    ProfileMercedBranchInstructions,
    ProfileMercedIntegerInstructions,
    ProfileMercedL1DataMisses,
    ProfileMercedFPOperationsRetired,
    ProfileMercedMaximum
} KPROFILE_MERCED_SOURCE, *PKPROFILE_MERCED_SOURCE;

#define PROFILE_TIME_MERCED_DEFAULT_INTERVAL      (10 * 1000 * 10) // 10 milliseconds

#endif /* MERCED_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\mckinley.c ===
/*++

Copyright (c) 1989-2002  Microsoft Corporation

Component Name:

    HALIA64

Module Name:

    mckinley.c

Abstract:

    This file declares the data structures related to 
    the McKinley Processor.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    Kernel mode.

Revision History:

    10/20/2001 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

#include "halp.h"
#include "ia64prof.h"
#include "mckinley.h"

//
// Hal Profiling Mapping for the McKinley Processor.
//

HALP_PROFILE_MAPPING 
HalpMcKinleyProfileMapping[ ProfileMcKinleyMaximum + 1 ] = {
    //
    // XXTF - ToBeValidated: - PMCD_MASKs 
    //                       - NumberOfTicks
    //                       - EventsCount
    //                       - Event Names
//
// HALP_PROFILE_MAPPING:           Sup.,   Event,                  Source, EventMask,      Interval, DefInt, MaxInt, MinInt, Plm, PlmDef, Ov, OvDef, Pm, PmDef, UnitMask, UnitMaskDef, Threshold, ThresholdDef, Ism, IsmDef
//
// NT KE architected Profile Sources:
/* ProfileTime                 */  {TRUE, McKinleyCpuCycles,              0, PMCD_MASK_4567, 0, PROFILE_TIME_MCKINLEY_DEFAULT_INTERVAL, MAXIMUM_PROFILE_INTERVAL, MINIMUM_PROFILE_INTERVAL, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileAlignmentFixup       */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileTotalIssues          */  {TRUE, McKinleyInstRetired,            0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfilePipelineDry          */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileLoadInstructions     */  {TRUE, McKinleyRetiredLoads,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfilePipelineFrozen       */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileBranchInstructions   */  {TRUE, McKinleyBranchInstructions,     0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileTotalNonissues       */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ? McKinleyNonIssue
/* ProfileDcacheMisses         */  {TRUE, McKinleyL1DataMisses,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileIcacheMisses         */  {TRUE, McKinleyL1InstMisses,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileCacheMisses          */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileBranchMispredictions */  {TRUE, McKinleyBranchMispredictDetail, 0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileStoreInstructions    */  {TRUE, McKinleyRetiredStores,          0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileFpInstructions       */  {TRUE, McKinleyFPOperationsRetired,    0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileIntegerInstructions  */  {TRUE, McKinleyIntegerInstructions,    0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* Profile2Issue               */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* Profile3Issue               */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* Profile4Issue               */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileSpecialInstructions  */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileTotalCycles          */  {TRUE, McKinleyCpuCycles,              0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileIcacheIssues         */  {TRUE, McKinleyInstReferences,         0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileDcacheAccesses       */ {TRUE, McKinleyDataReferencesSet1            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMemoryBarrierCycles  */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileLoadLinkedIssues     */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileMaximum              */  {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, // End of NT KE architected Profile Sources.
//
// NT IA64 Processor specific Profile Sources:
//      McKinley Monitored Events:
//
/* ProfileMcKinleyBackEndBubbles               */ {TRUE, McKinleyBackEndBubbles                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBackEndRSEBubbles            */ {TRUE, McKinleyBackEndRSEBubbles             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBackEndEXEBubbles            */	{TRUE, McKinleyBackEndEXEBubbles             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBackEndL0DAndFPUBubbles      */	{TRUE, McKinleyBackEndL0DAndFPUBubbles       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBackEndFlushBubbles          */ {TRUE, McKinleyBackEndFlushBubbles           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFrontEndBubbles              */ {TRUE, McKinleyFrontEndBubbles               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFrontEndLostBandwidth        */ {TRUE, McKinleyFrontEndLostBandwidth         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBackEndLostBandwidth         */ {TRUE, McKinleyBackEndLostBandwidth          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBackEndIdealLostBandwidth    */ {TRUE, McKinleyBackEndIdealLostBandwidth     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFPTrueSirStalls              */ {TRUE, McKinleyFPTrueSirStalls               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFPFalseSirStalls             */ {TRUE, McKinleyFPFalseSirStalls              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFPFailedFchkf                */ {TRUE, McKinleyFPFailedFchkf                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyTaggedInstRetired            */ {TRUE, McKinleyTaggedInstRetired             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstRetired                  */ {TRUE, McKinleyInstRetired                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFPOperationsRetired          */ {TRUE, McKinleyFPOperationsRetired           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFPFlushesToZero              */ {TRUE, McKinleyFPFlushesToZero               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBranchPathPrediction         */ {TRUE, McKinleyBranchPathPrediction          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBranchPathPrediction2        */ {TRUE, McKinleyBranchPathPrediction2         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBranchMispredictDetail       */ {TRUE, McKinleyBranchMispredictDetail        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBranchMispredictDetail2      */ {TRUE, McKinleyBranchMispredictDetail2       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBranchEventsWithEAR          */ {TRUE, McKinleyBranchEventsWithEAR           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBackEndBranchMispredictDetail*/ {TRUE, McKinleyBackEndBranchMispredictDetail ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyEncodedBranchMispredictDetail*/ {TRUE, McKinleyEncodedBranchMispredictDetail ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyCpuCycles                    */ {TRUE, McKinleyCpuCycles                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyISATransitions               */ {TRUE, McKinleyISATransitions                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyIA32InstRetired              */ {TRUE, McKinleyIA32InstRetired               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstReads                  */ {TRUE, McKinleyL1InstReads                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstFills                  */ {TRUE, McKinleyL1InstFills                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstMisses                 */ {TRUE, McKinleyL1InstMisses                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstEAREvents                */ {TRUE, McKinleyL1InstEAREvents               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstPrefetches             */ {TRUE, McKinleyL1InstPrefetches              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstStreamPrefetches       */ {TRUE, McKinleyL1InstStreamPrefetches        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstPrefetches             */ {TRUE, McKinleyL2InstPrefetches              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyISBBundlePairs               */ {TRUE, McKinleyISBBundlePairs               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstFetchRABHits           */ {TRUE, McKinleyL1InstFetchRABHits            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstFetchISBHits           */ {TRUE, McKinleyL1InstFetchISBHits            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstPrefetchStalls         */ {TRUE, McKinleyL1InstPrefetchStalls          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALL, PMC_UNIT_MASK_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstRABAlmostFull          */ {TRUE, McKinleyL1InstRABAlmostFull           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstRABFull                */ {TRUE, McKinleyL1InstRABFull                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstSnoops                 */ {TRUE, McKinleyL1InstSnoops                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstPurges                 */ {TRUE, McKinleyL1InstPurges                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstPVABOverflows          */ {TRUE, McKinleyL1InstPVABOverflows           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataReadsSet0              */ {TRUE, McKinleyL1DataReadsSet0               ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataTLBTransfersSet0       */ {TRUE, McKinleyL1DataTLBTransfersSet0        ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataTLBMissesSet0            */ {TRUE, McKinleyDataTLBMissesSet0             ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataReferencesSet1           */ {TRUE, McKinleyDataReferencesSet1            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataReadsSet1              */ {TRUE, McKinleyL1DataReadsSet1               ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataReadMissesSet1         */ {TRUE, McKinleyL1DataReadMissesSet1          ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataReadMissesByRSEFillsSet1    */ {TRUE, McKinleyL1DataReadMissesByRSEFillsSet1   ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_RSEFILLS, PMC_UNIT_MASK_RSEFILLS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataPortTaggedAccessesSet5 */ {TRUE, McKinleyL1DataPortTaggedAccessesSet5  ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_5), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataPortTaggedReturnsSet5  */ {TRUE, McKinleyL1DataPortTaggedAccessesSet5  ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_5), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyVHPTDataReferences           */ {TRUE, McKinleyVHPTDataReferences            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALL, PMC_UNIT_MASK_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataEAREvents                */ {TRUE, McKinleyDataEAREvents                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2OZQCancels0                */ {TRUE, McKinleyL2OZQCancels0                 ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2OZQCancels1                */ {TRUE, McKinleyL2OZQCancels1                 ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2OZQCancels2                */ {TRUE, McKinleyL2OZQCancels2                 ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstFetchCancels           */ {TRUE, McKinleyL2InstFetchCancels            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstFetchCancelsByBypass   */ {TRUE, McKinleyL2InstFetchCancelsByBypass    ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_IFETCH_BYPASS, PMC_UNIT_MASK_IFETCH_BYPASS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstFetchCancelsByDataRead */ {TRUE, McKinleyL2InstFetchCancelsByDataRead  ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_IFETCH_DATAREAD, PMC_UNIT_MASK_IFETCH_DATAREAD, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstFetchCancelsByStFillWb */ {TRUE, McKinleyL2InstFetchCancelsByStFillWb  ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_IFETCH_STFILLWB, PMC_UNIT_MASK_IFETCH_STFILLWB, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2OZQAcquires                */ {TRUE, McKinleyL2OZQAcquires                 ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2OZQReleases                */ {TRUE, McKinleyL2OZQReleases                 ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_0), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2CanceledL3Accesses         */ {TRUE, McKinleyL2CanceledL3Accesses          ,0, (PMCD_MASK_4|PMCD_MASK_SET_L1_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3ACCESS_ANY, PMC_UNIT_MASK_L3ACCESS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2References                 */ {TRUE, McKinleyL2References                  ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataReferences             */ {TRUE, McKinleyL2DataReferences              ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_DATA_RDWR, PMC_UNIT_MASK_L2_DATA_RDWR, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataReads                  */ {TRUE, McKinleyL2DataReads                   ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_DATA_READ, PMC_UNIT_MASK_L2_DATA_READ, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataWrites                 */ {TRUE, McKinleyL2DataWrites                  ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_DATA_WRITE, PMC_UNIT_MASK_L2_DATA_WRITE, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2TaggedAccesses             */ {TRUE, McKinleyL2TaggedAccesses              ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALL, PMC_UNIT_MASK_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2ForcedRecirculatedOperations */ {TRUE, McKinleyL2ForcedRecirculatedOperations ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_2), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2IssuedRecirculatedOZQAccesses */ {TRUE, McKinleyL2IssuedRecirculatedOZQAccesses  ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_2), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2SuccessfulRecirculatedOZQAccesses */ {TRUE, McKinleyL2SuccessfulRecirculatedOZQAccesses  ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_2), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2SynthesizedProbes          */ {TRUE, McKinleyL2SynthesizedProbes           ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_2), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataBypasses1              */ {TRUE, McKinleyL2Bypasses                    ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_3), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_DATA_BYPASS_L1DTOL2A, PMC_UNIT_MASK_L2_DATA_BYPASS_L1DTOL2A, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataBypasses2              */ {TRUE, McKinleyL2Bypasses                    ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_3), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_DATA_BYPASS_L1WTOL2I, PMC_UNIT_MASK_L2_DATA_BYPASS_L1WTOL2I, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3DataBypasses1              */ {TRUE, McKinleyL2Bypasses                    ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_3), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_DATA_BYPASS_L1DTOL2A, PMC_UNIT_MASK_L2_DATA_BYPASS_L1DTOL2A, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstBypasses1              */ {TRUE, McKinleyL2Bypasses                    ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_3), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_INST_BYPASS_L1DTOL2A, PMC_UNIT_MASK_L2_INST_BYPASS_L1DTOL2A, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstBypasses2              */ {TRUE, McKinleyL2Bypasses                    ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_3), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_INST_BYPASS_L1WTOL2I, PMC_UNIT_MASK_L2_INST_BYPASS_L1WTOL2I, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3InstBypasses1              */ {TRUE, McKinleyL2Bypasses                    ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_3), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_INST_BYPASS_L1DTOL2A, PMC_UNIT_MASK_L2_INST_BYPASS_L1DTOL2A, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2BadLinesSelected           */ {TRUE, McKinleyL2BadLinesSelected            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_3), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_EVENT_SELECTED_LOSET, PMC_UNIT_MASK_EVENT_SELECTED_LOSET, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2StoreSharedLineHits        */ {TRUE, McKinleyL2StoreSharedLineHits         ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_3), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_EVENT_SELECTED_LOSET, PMC_UNIT_MASK_EVENT_SELECTED_LOSET, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2IntegerLoads               */ {TRUE, McKinleyL2IssuedOperations            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_4), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_INT_LOADS, PMC_UNIT_MASK_L2_INT_LOADS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2FloatingPointLoads         */ {TRUE, McKinleyL2IssuedOperations            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_4), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_FP_LOADS, PMC_UNIT_MASK_L2_FP_LOADS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2ReadModifyWriteStores      */ {TRUE, McKinleyL2IssuedOperations            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_4), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_RMW_STORES, PMC_UNIT_MASK_L2_RMW_STORES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2NonReadModifyWriteStores   */ {TRUE, McKinleyL2IssuedOperations            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_4), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_NON_RMW_STORES, PMC_UNIT_MASK_L2_NON_RMW_STORES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2NonLoadsNonStores          */ {TRUE, McKinleyL2IssuedOperations            ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_4), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2_NONLOADS_NONSTORES, PMC_UNIT_MASK_L2_NONLOADS_NONSTORES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2IssuedRecirculatedInstFetches */ {TRUE, McKinleyL2IssuedRecirculatedInstFetches ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_4), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_EVENT_SELECTED_HISET, PMC_UNIT_MASK_EVENT_SELECTED_HISET, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2ReceivedRecirculatedInstFetches */ {TRUE, McKinleyL2ReceivedRecirculatedInstFetches ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_4), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_EVENT_SELECTED_HISET, PMC_UNIT_MASK_EVENT_SELECTED_HISET, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2TaggedDataReturns          */ {TRUE, McKinleyL2TaggedDataReturns           ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_4), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataFillBufferFull         */ {TRUE, McKinleyL2DataFillBufferFull          ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_5), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataVictimBufferFull       */ {TRUE, McKinleyL2DataVictimBufferFull        ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_5), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataOrderingCzarDataBufferFull */ {TRUE, McKinleyL2DataOrderingCzarDataBufferFull ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_5), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataOrderingCzarQueueFull  */ {TRUE, McKinleyL2DataOrderingCzarQueueFull   ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L1_CACHE_5), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2Misses                     */ {TRUE, McKinleyL2Misses                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3References                 */ {TRUE, McKinleyL3References                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, 
/* ProfileMcKinleyL3Misses                     */ {TRUE, McKinleyL3Misses                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }, 
/* ProfileMcKinleyL3Reads                      */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALL, PMC_UNIT_MASK_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3ReadHits                   */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_READS_HITS, PMC_UNIT_MASK_L3_READS_HITS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3ReadMisses                 */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_READS_MISSES, PMC_UNIT_MASK_L3_READS_MISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3InstFetchReferences        */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_READS_IFETCH_REFERENCES, PMC_UNIT_MASK_L3_READS_IFETCH_REFERENCES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3InstFetchHits              */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_READS_IFETCH_HITS, PMC_UNIT_MASK_L3_READS_IFETCH_HITS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3InstFetchMisses            */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_READS_IFETCH_MISSES, PMC_UNIT_MASK_L3_READS_IFETCH_MISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3LoadReferences             */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_READS_DATA_REFERENCES, PMC_UNIT_MASK_L3_READS_DATA_REFERENCES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3LoadHits                   */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_READS_DATA_HITS, PMC_UNIT_MASK_L3_READS_DATA_HITS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3LoadMisses                 */ {TRUE, McKinleyL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_READS_DATA_MISSES, PMC_UNIT_MASK_L3_READS_DATA_MISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3Writes                     */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALL, PMC_UNIT_MASK_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3WriteHits                  */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_WRITES_HITS, PMC_UNIT_MASK_L3_WRITES_HITS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3WriteMisses                */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_WRITES_MISSES, PMC_UNIT_MASK_L3_WRITES_MISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3StoreReferences            */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_WRITES_DATA_REFERENCES, PMC_UNIT_MASK_L3_WRITES_DATA_REFERENCES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3StoreHits                  */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_WRITES_DATA_HITS, PMC_UNIT_MASK_L3_WRITES_DATA_HITS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3StoreMisses                */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_WRITES_DATA_MISSES, PMC_UNIT_MASK_L3_WRITES_DATA_MISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3WriteBackReferences        */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_WRITEBACK_REFERENCES, PMC_UNIT_MASK_L3_WRITEBACK_REFERENCES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3WriteBackHits              */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_WRITEBACK_HITS, PMC_UNIT_MASK_L3_WRITEBACK_HITS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3WriteBackMisses            */ {TRUE, McKinleyL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L3_WRITEBACK_MISSES, PMC_UNIT_MASK_L3_WRITEBACK_MISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3ValidReplacedLines         */ {TRUE, McKinleyL3ValidReplacedLines          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataDebugRegisterMatches    */ {TRUE, McKinleyDataDebugRegisterMatches        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyCodeDebugRegisterMatches    */ {TRUE, McKinleyCodeDebugRegisterMatches        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataDebugRegisterFaults     */ {TRUE, McKinleyDataDebugRegisterFaults         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyCpuCPLChanges                */ {TRUE, McKinleyCpuCPLChanges                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleySerializationEvents          */ {TRUE, McKinleySerializationEvents           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyExternDPPins0To3Asserted     */ {TRUE, McKinleyExternDPPins0To3Asserted      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyExternDPPins4To5Asserted     */ {TRUE, McKinleyExternDPPins4To5Asserted      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstTLBReferences            */ {TRUE, McKinleyInstTLBReferences             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstTLBDemandFetchMisses     */ {TRUE, McKinleyInstTLBDemandFetchMisses      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALLTLBMISSES, PMC_UNIT_MASK_ALLTLBMISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstTLBDemandFetchMisses   */ {TRUE, McKinleyInstTLBDemandFetchMisses      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L1TLBMISSES, PMC_UNIT_MASK_L1TLBMISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstTLBDemandFetchMisses   */ {TRUE, McKinleyInstTLBDemandFetchMisses      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_L2TLBMISSES, PMC_UNIT_MASK_L2TLBMISSES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstTLBHPWInserts            */ {TRUE, McKinleyInstTLBHPWInserts             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataTLBReferencesSet1        */ {TRUE, McKinleyDataTLBReferencesSet1         ,0, (PMCD_MASK_4567|PMCD_MASK_SET_L0D_CACHE_1), 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataTLBHPWInserts            */ {TRUE, McKinleyDataTLBHPWInserts             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataTLBHPWRetiredInserts     */ {TRUE, McKinleyDataTLBHPWRetiredInserts      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusAllTransactions           */ {TRUE, McKinleyBusAll                        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusSelfTransactions          */ {TRUE, McKinleyBusAll                        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_BYSELF, PMC_UNIT_MASK_BUS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusNonPriorityAgentTransactions */ {TRUE, McKinleyBusAll                        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryTransactions        */ {TRUE, McKinleyBusMemoryTransactions         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_MEMORY_ALL, PMC_UNIT_MASK_BUS_MEMORY_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBurstTransactions   */ {TRUE, McKinleyBusMemoryTransactions         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_MEMORY_128BYTE, PMC_UNIT_MASK_BUS_MEMORY_128BYTE, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryPartialTransactions */ {TRUE, McKinleyBusMemoryTransactions         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_MEMORY_LTH_128BYTE, PMC_UNIT_MASK_BUS_MEMORY_LTH_128BYTE, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryReads               */ {TRUE, McKinleyBusMemoryReads                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_MEMORY_READS_ALL, PMC_UNIT_MASK_BUS_MEMORY_READS_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBRLTransactions     */ {TRUE, McKinleyBusMemoryReads                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_MEMORY_BRL, PMC_UNIT_MASK_BUS_MEMORY_BRL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBILTransactions     */ {TRUE, McKinleyBusMemoryReads                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_MEMORY_BIL, PMC_UNIT_MASK_BUS_MEMORY_BIL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBRILTransactions    */ {TRUE, McKinleyBusMemoryReads                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_MEMORY_BRIL, PMC_UNIT_MASK_BUS_MEMORY_BRIL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryDataReads           */ {TRUE, McKinleyBusMemoryDataReads            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_ANY, PMC_UNIT_MASK_BUS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryDataReadsBySelf     */ {TRUE, McKinleyBusMemoryDataReads            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_BYSELF, PMC_UNIT_MASK_BUS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryDataReadsByNonPriorityAgent */ {TRUE, McKinleyBusMemoryDataReads            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBRPReads            */ {TRUE, McKinleyBusMemoryBRPReads             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_ANY, PMC_UNIT_MASK_BUS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBRPReadsBySelf      */ {TRUE, McKinleyBusMemoryBRPReads             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_BYSELF, PMC_UNIT_MASK_BUS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBRPReadsByNonPriorityAgent */ {TRUE, McKinleyBusMemoryBRPReads             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusReadCpuLineHits           */ {TRUE, McKinleyBusReadCpuLineHits            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusReadCpuModifiedLineHits   */ {TRUE, McKinleyBusReadCpuModifiedLineHits    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusReadBILCpuModifiedLineHits */ {TRUE, McKinleyBusReadBILCpuModifiedLineHits ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusReadBRILorBILCpuModifiedLineHits */ {TRUE, McKinleyBusReadBRILorBILCpuModifiedLineHits ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusCpuModifiedLineHits       */ {TRUE, McKinleyBusCpuModifiedLineHits        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryWriteBacks          */ {TRUE, McKinleyBusMemoryWriteBacks           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_WB_ALL, PMC_UNIT_MASK_BUS_WB_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryWriteBacksBySelf    */ {TRUE, McKinleyBusMemoryWriteBacks           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_WB_BYSELF, PMC_UNIT_MASK_BUS_WB_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryWriteBacksByNonPriorityAgent */ {TRUE, McKinleyBusMemoryWriteBacks  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_WB_NONPRI_AGENT, PMC_UNIT_MASK_BUS_WB_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBurstWriteBacks     */ {TRUE, McKinleyBusMemoryWriteBacks           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_WB_BURST_ALL, PMC_UNIT_MASK_BUS_WB_BURST_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBurstWriteBacksBySelf */ {TRUE, McKinleyBusMemoryWriteBacks         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_WB_BURST_BYSELF, PMC_UNIT_MASK_BUS_WB_BURST_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryBurstWriteBacksByNonPriorityAgent */ {TRUE, McKinleyBusMemoryWriteBacks  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_WB_BURST_NONPRI_AGENT, PMC_UNIT_MASK_BUS_WB_BURST_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryZeroByteWriteBacks  */ {TRUE, McKinleyBusMemoryWriteBacks           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_WB_ZEROBYTE_ALL, PMC_UNIT_MASK_BUS_WB_ZEROBYTE_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryZeroByteWriteBacksBySelf */ {TRUE, McKinleyBusMemoryWriteBacks         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_WB_ZEROBYTE_BYSELF, PMC_UNIT_MASK_BUS_WB_ZEROBYTE_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryCurrentReads        */ {TRUE, McKinleyBusMemoryCurrentReads         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_ANY, PMC_UNIT_MASK_BUS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryCurrentReadsByNonPriorityAgent */ {TRUE, McKinleyBusMemoryCurrentReads ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusCpuModifiedLineHitSnoops  */ {TRUE, McKinleyBusCpuModifiedLineHitSnoops   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_SNOOPS_ALL, PMC_UNIT_MASK_BUS_SNOOPS_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusCpuModifiedLineHitSnoopsBySelf */ {TRUE, McKinleyBusCpuModifiedLineHitSnoops ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_SNOOPS_BYSELF, PMC_UNIT_MASK_BUS_SNOOPS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusSnoops                    */ {TRUE, McKinleyBusSnoops                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_SNOOPS_ALL, PMC_UNIT_MASK_BUS_SNOOPS_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusSnoopsBySelf              */ {TRUE, McKinleyBusSnoops                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_SNOOPS_BYSELF, PMC_UNIT_MASK_BUS_SNOOPS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusSnoopsByNonPriorityAgent  */ {TRUE, McKinleyBusSnoops                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_SNOOPS_NONPRI_AGENT, PMC_UNIT_MASK_BUS_SNOOPS_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusSnoopStallCycles          */ {TRUE, McKinleyBusSnoopStallCycles           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_SNOOPS_ALL, PMC_UNIT_MASK_BUS_SNOOPS_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusSnoopStallCyclesBySelf    */ {TRUE, McKinleyBusSnoopStallCycles           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_SNOOPS_BYSELF, PMC_UNIT_MASK_BUS_SNOOPS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusDataCycles                */ {TRUE, McKinleyBusDataCycles                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_ANY, PMC_UNIT_MASK_BUS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusSnoopResponses            */ {TRUE, McKinleyBusSnoopResponses             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusRequestQueueInserts       */ {TRUE, McKinleyBusRequestQueueInserts        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32IOTransactions        */ {TRUE, McKinleyBusIA32IOTransactions         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_ANY, PMC_UNIT_MASK_BUS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32IOTransactionsBySelf  */ {TRUE, McKinleyBusIA32IOTransactions         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_BYSELF, PMC_UNIT_MASK_BUS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32IOTransactionsByNonPriorityAgent  */ {TRUE, McKinleyBusIA32IOTransactions         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32IOReads               */ {TRUE, McKinleyBusIA32IOReads                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_ANY, PMC_UNIT_MASK_BUS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32IOReadsBySelf         */ {TRUE, McKinleyBusIA32IOReads                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_BYSELF, PMC_UNIT_MASK_BUS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32IOReadsByNonPriorityAgent */ {TRUE, McKinleyBusIA32IOReads            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_UNIT_MASK_BUS_NONPRI_AGENT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32LockTransactions      */ {TRUE, McKinleyBusIA32LockTransactions       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_ANY, PMC_UNIT_MASK_BUS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32LockTransactionsBySelf */ {TRUE, McKinleyBusIA32LockTransactions       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_BYSELF, PMC_UNIT_MASK_BUS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32LockCycles            */ {TRUE, McKinleyBusIA32LockCycles             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_ANY, PMC_UNIT_MASK_BUS_ANY, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusIA32LockCyclesBySelf      */ {TRUE, McKinleyBusIA32LockCycles             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_BUS_BYSELF, PMC_UNIT_MASK_BUS_BYSELF, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRSEAccesses                  */ {TRUE, McKinleyRSEAccesses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALL, PMC_UNIT_MASK_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRSELoads                     */ {TRUE, McKinleyRSEAccesses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_RSE_LOADS, PMC_UNIT_MASK_RSE_LOADS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRSEStores                    */ {TRUE, McKinleyRSEAccesses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_RSE_STORES, PMC_UNIT_MASK_RSE_STORES, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRSELoadUnderflowCycles       */ {TRUE, McKinleyRSELoadUnderflowCycles        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_RSE_LOAD_UNDERFLOWS, PMC_UNIT_MASK_RSE_LOAD_UNDERFLOWS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRSEOperations                */ {TRUE, McKinleyRSEOperations                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyTaggedInstructionsAtRotate   */ {TRUE, McKinleyTaggedInstructionsAtRotate    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstDispersed                */ {TRUE, McKinleyInstDispersed                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDispersalCyclesStalled       */ {TRUE, McKinleyDispersalCyclesStalled        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleySyllablesOvercount           */ {TRUE, McKinleySyllablesOvercount            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALL, PMC_UNIT_MASK_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleySyllablesNotDispersed        */ {TRUE, McKinleySyllablesNotDispersed         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_ALL, PMC_UNIT_MASK_ALL, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstNOPRetired               */ {TRUE, McKinleyInstNOPRetired                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstPredicateSquashedRetired */ {TRUE, McKinleyInstPredicateSquashedRetired  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFailedSpeculativeCheckLoads  */ {TRUE, McKinleyFailedSpeculativeCheckLoads   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_INTANDFP_OPS, PMC_UNIT_MASK_INTANDFP_OPS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyAdvancedCheckLoads           */ {TRUE, McKinleyAdvancedCheckLoads            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_INTANDFP_OPS, PMC_UNIT_MASK_INTANDFP_OPS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFailedAdvancedCheckLoads     */ {TRUE, McKinleyFailedAdvancedCheckLoads      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_INTANDFP_OPS, PMC_UNIT_MASK_INTANDFP_OPS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyALATOverflows                */ {TRUE, McKinleyALATOverflows                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_INTANDFP_OPS, PMC_UNIT_MASK_INTANDFP_OPS, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRetiredLoads                 */ {TRUE, McKinleyRetiredLoads                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRetiredStores                */ {TRUE, McKinleyRetiredStores                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRetiredUncacheableLoads      */ {TRUE, McKinleyRetiredUncacheableLoads       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRetiredUncacheableStores     */ {TRUE, McKinleyRetiredUncacheableStores      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRetiredMisalignedLoads       */ {TRUE, McKinleyRetiredMisalignedLoads        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRetiredMisalignedStores      */ {TRUE, McKinleyRetiredMisalignedStores       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
//
//      McKinley Derived Events:
//      ProfileMcKinleyDerivedEventMinimum,
//
/* ProfileMcKinleyRSEStallCycles              */ {TRUE, McKinleyRSEStallCycles                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyIssueLimitStallCycles       */ {TRUE, McKinleyIssueLimitStallCycles           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyTakenBranchStallCycles      */ {TRUE, McKinleyTakenBranchStallCycles          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyFetchWindowStallCycles      */ {TRUE, McKinleyFetchWindowStallCycles          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyIA64InstPerCycle            */ {TRUE, McKinleyIA64InstPerCycle                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyIA32InstPerCycle            */ {TRUE, McKinleyIA32InstPerCycle                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyAvgIA64InstPerTransition    */ {TRUE, McKinleyAvgIA64InstPerTransition        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyAvgIA32InstPerTransition    */ {TRUE, McKinleyAvgIA32InstPerTransition        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyAvgIA64CyclesPerTransition  */ {TRUE, McKinleyAvgIA64CyclesPerTransition      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyAvgIA32CyclesPerTransition  */ {TRUE, McKinleyAvgIA32CyclesPerTransition      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstReferences            */ {TRUE, McKinleyL1InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1InstMissRatio             */ {TRUE, McKinleyL1InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataReadMissRatio         */ {TRUE, McKinleyL1DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2MissRatio                 */ {TRUE, McKinleyL2MissRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataMissRatio             */ {TRUE, McKinleyL2DataMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstMissRatio             */ {TRUE, McKinleyL2InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataReadMissRatio         */ {TRUE, McKinleyL2DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataWriteMissRatio        */ {TRUE, McKinleyL2DataWriteMissRatio            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstFetchRatio            */ {TRUE, McKinleyL2InstFetchRatio                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2DataRatio                 */ {TRUE, McKinleyL2DataRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3MissRatio                 */ {TRUE, McKinleyL3MissRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3DataMissRatio             */ {TRUE, McKinleyL3DataMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3InstMissRatio             */ {TRUE, McKinleyL3InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3DataReadMissRatio         */ {TRUE, McKinleyL3DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3DataRatio                 */ {TRUE, McKinleyL3DataRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstReferences              */ {TRUE, McKinleyInstReferences                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL0DTLBMissRatio             */ {TRUE, McKinleyL0DTLBMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDTLBMissRatio               */ {TRUE, McKinleyDTLBMissRatio                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataTCMissRatio             */ {TRUE, McKinleyDataTCMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstTLBEAREvents            */ {TRUE, McKinleyInstTLBEAREvents                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataTLBEAREvents            */ {TRUE, McKinleyDataTLBEAREvents                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyControlSpeculationMissRatio */ {TRUE, McKinleyControlSpeculationMissRatio     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyDataSpeculationMissRatio    */ {TRUE, McKinleyDataSpeculationMissRatio        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyALATCapacityMissRatio       */ {TRUE, McKinleyALATCapacityMissRatio           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataWayMispredicts        */ {TRUE, McKinleyL1DataWayMispredicts            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2InstReferences            */ {TRUE, McKinleyL2InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyInstFetches                 */ {TRUE, McKinleyInstFetches                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3InstReferences            */ {TRUE, McKinleyL3InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3InstMisses                */ {TRUE, McKinleyL3InstMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3InstHits                  */ {TRUE, McKinleyL3InstHits                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3DataReferences            */ {TRUE, McKinleyL3DataReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL3ReadReferences            */ {TRUE, McKinleyL3ReadReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2WriteBackReferences       */ {TRUE, McKinleyL2WriteBackReferences           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2WriteBackMisses           */ {TRUE, McKinleyL2WriteBackMisses               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2WriteBackHits             */ {TRUE, McKinleyL2WriteBackHits                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2WriteReferences           */ {TRUE, McKinleyL2WriteReferences               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2WriteMisses               */ {TRUE, McKinleyL2WriteMisses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL2WriteHits                 */ {TRUE, McKinleyL2WriteHits                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBranchInstructions          */ {TRUE, McKinleyBranchInstructions              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyIntegerInstructions         */ {TRUE, McKinleyIntegerInstructions             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyL1DataMisses                */ {TRUE, McKinleyL1DataMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyISBLinesIn                  */ {TRUE, McKinleyISBLinesIn                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryCodeReads          */ {TRUE, McKinleyBusMemoryCodeReads              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusReadBILMemoryHits        */ {TRUE, McKinleyBusReadBILMemoryHits            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusReadBRILCpuModifiedLineHits */ {TRUE, McKinleyBusReadBRILCpuModifiedLineHits ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusReadBRILMemoryHits       */ {TRUE, McKinleyBusReadBRILMemoryHits           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusMemoryReadsOutstanding   */ {TRUE, McKinleyBusMemoryReadsOutstanding       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusLiveInOrderRequests      */ {TRUE, McKinleyBusLiveInOrderRequests          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusLiveDeferredRequests     */ {TRUE, McKinleyBusLiveDeferredRequests         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyBusLiveQueuedReadRequests   */ {TRUE, McKinleyBusLiveQueuedReadRequests       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRSEDirtyRegs                */ {TRUE, McKinleyRSEDirtyRegs                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyRSECurrentRegs              */ {TRUE, McKinleyRSECurrentRegs                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL },
/* ProfileMcKinleyMaximum                     */ {FALSE, 0,0,0,0,0,0, PMC_PLM_ALL, PMC_PLM_ALL, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_OVERFLOW_INTERRUPT, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_ENABLE_PRIVILEGE_MONITOR, PMC_UNIT_MASK_DEFAULT, PMC_UNIT_MASK_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_THRESHOLD_DEFAULT, PMC_ISM_ALL, PMC_ISM_ALL }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\mckinley.h ===
#ifndef MCKINLEY_H_INCLUDED
#define MCKINLEY_H_INCLUDED

/*++

Copyright (c) 1989-2002  Microsoft Corporation

Component Name:

    HALIA64

Module Name:

    mckinley.h

Abstract:

    This header file presents IA64 McKinley definitions.
    Like profiling definitions.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    Kernel mode.

Revision History:

    12/20/2001 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

//
//  McKinley Monitored Events:
//

typedef enum _MCKINLEY_MONITOR_EVENT { //         = 0x##,  // McKinley PMU ERS Event Name:
    McKinleyMonitoredEventMinimum                 = 0x00,
    McKinleyBackEndBubbles                        = 0x00,  //  "BACK_END_BUBBLE"         
    McKinleyBackEndRSEBubbles                     = 0x01,  //  "BE_RSE_BUBBLE"       
    McKinleyRSELoadUnderflowCycles                = 0x01,  //  "BE_RSE_BUBBLE.underflow" 
    McKinleyBackEndEXEBubbles                     = 0x02,  //  "BE_EXE_BUBBLE"  
    McKinleyFPTrueSirStalls                       = 0x03,  //  "FP_TRUE_SIRSTALL"  
    McKinleyBackEndFlushBubbles                   = 0x04,  //  "BE_FLUSH_BUBBLE",       
    McKinleyFPFalseSirStalls                      = 0x05,  //  "FP_FALSE_SIRSTALL",   
    McKinleyFPFailedFchkf                         = 0x06,  //  "FP_FAILED_FCHKF",    
    McKinleyISATransitions                        = 0x07,  //  "ISA_TRANSITIONS",  
    McKinleyInstRetired                           = 0x08,  //  "IA64_INSTS_RETIRED.u", 
    McKinleyTaggedInstRetired                     = 0x08,  //  "IA64_TAGGED_INSTRS_RETIRED", 
    McKinleyCodeDebugRegisterMatches              = 0x08,  //  "CODE_DEBUG_REGISTER_MATCHES", 
    McKinleyFPOperationsRetired                   = 0x09,  //  "FPOPS_RETIRED", // Weighted sum of all FP ops
    McKinleyFPFlushesToZero                       = 0x0b,  //  "FP_FLUSH_TO_ZERO",     
    McKinleyBranchEventsWithEAR                   = 0x11,  //  "BRANCH_EVENT,BRANCH_EAR_EVENTS",      
    McKinleyCpuCycles                             = 0x12,  //  "CPU_CYCLES",   
    McKinleyCpuCPLChanges                         = 0x13,  //  "CPU_CPL_CHANGES",   
    McKinleyRSEAccesses                           = 0x20,  //  "RSE_REFERENCES_RETIRED",     
    McKinleyRSEDirtyRegs0                         = 0x24,  //  "RSE_DIRTY_REGS0",     
    McKinleyRSECurrentRegs0                       = 0x26,  //  "RSE_CURRENT_REGS0",     
    McKinleyRSEDirtyRegs1                         = 0x28,  //  "RSE_DIRTY_REGS1",     
    McKinleyRSEDirtyRegs2                         = 0x29,  //  "RSE_DIRTY_REGS2",     
    McKinleyRSECurrentRegs1                       = 0x2a,  //  "RSE_CURRENT_REGS1",     
    McKinleyRSECurrentRegs2                       = 0x2b,  //  "RSE_CURRENT_REGS2",     
    McKinleyDataTLBHPWRetiredInserts              = 0x2c,  //  "DTLB_INSERTS_HPW_RETIRED",   
    McKinleyVHPTDataReferences                    = 0x2d,  //  "VHPT_DATA_REFERENCES",   
    McKinleyRSEOperations                         = 0x32,  //  "RSE_EVENT_RETIRED",  
    McKinleyL1InstReads                           = 0x40,  //  "L0I_READS",  
    McKinleyInstTLBReferences                     = 0x40,  //  "ITLB_REFERENCES",  
    McKinleyL1InstFills                           = 0x41,  //  "L0I_FILLS",      
    McKinleyL1InstMisses                          = 0x42,  //  "L0I_MISSES",    
    McKinleyL1InstEAREvents                       = 0x43,  //  "L0I_EAR_EVENTS",    
    McKinleyL1InstPrefetches                      = 0x44,  //  "L0I_IPREFETCHES",   
    McKinleyL2InstPrefetches                      = 0x45,  //  "L1_INST_PREFETCHES",   
    McKinleyISBBundlePairs                        = 0x46,  //  "ISB_BINPAIRS_IN",  
    McKinleyInstTLBDemandFetchMisses              = 0x47,  //  "ITLB_MISSES_FETCH", 
    McKinleyInstTLBHPWInserts                     = 0x48,  //  "ITLB_INSERTS_HPW",  
    McKinleyDispersalCyclesStalled                = 0x49,  //  "DISP_STALLED",        
    McKinleyL1InstSnoops                          = 0x4a,  //  "L0I_SNOOP",           
    McKinleyL1InstPurges                          = 0x4b,  //  "L0I_PURGE",           
    McKinleyTaggedInstructionsAtRotate            = 0x4c,  //  "TAGGED_INSTRUCTION_AT_ROTATE", 
    McKinleyInstDispersed                         = 0x4d,  //  "INST_DISPERSED",        
    McKinleySyllablesNotDispersed                 = 0x4e,  //  "SYLL_NOT_DISPERSED",    
    McKinleySyllablesOvercount                    = 0x4f,  //  "SYLL_OVERCOUNT",        
    McKinleyInstNOPRetired                        = 0x50,  //  "NOPS_RETIRED",     
    McKinleyInstPredicateSquashedRetired          = 0x51,  //  "PREDICATE_SQUASHED_RETIRED",  
    McKinleyDataDebugRegisterFaults               = 0x52,  //  "DATA_DEBUG_REGISTER_FAULTS", 
    McKinleySerializationEvents                   = 0x53,  //  "SERIALIZATION_EVENTS", 
    McKinleyBranchPathPrediction                  = 0x54,  //  "BR_PATH_PREDICTION",  
    McKinleyFailedSpeculativeCheckLoads           = 0x55,  //  "INST_FAILED_CHKS_RETIRED", 
    McKinleyAdvancedCheckLoads                    = 0x56,  //  "INST_CHKA_LDC_ALAT",  
    McKinleyFailedAdvancedCheckLoads              = 0x57,  //  "INST_FAILED_CHKA_LDC_ALAT", 
    McKinleyALATOverflows                         = 0x58,  //  "ALAT_CAPACITY_MISS",  
    McKinleyIA32InstRetired                       = 0x59,  //  "IA32_INSTR_RETIRED",  
    McKinleyBranchMispredictDetail                = 0x5b,  //  "BR_MIS_PREDICT_DETAIL",    
    McKinleyL1InstStreamPrefetches                = 0x5f,  //  "L0I_STRM_PREFETCHES",   
    McKinleyL1InstRABFull                         = 0x60,  //  "L0I_RAB_FULL",   
    McKinleyBackEndBranchMispredictDetail         = 0x61,  //  "BE_BR_MISPREDICT_DETAIL",  
    McKinleyEncodedBranchMispredictDetail         = 0x63,  //  "ENCBR_MISPREDICT_DETAIL",  
    McKinleyL1InstRABAlmostFull                   = 0x64,  //  "L0I_RAB_ALMOST_FULL",  
    McKinleyL1InstFetchRABHits                    = 0x65,  //  "L0I_FETCH_RAB_HIT",          
    McKinleyL1InstFetchISBHits                    = 0x66,  //  "L0I_FETCH_ISB_HIT",   
    McKinleyL1InstPrefetchStalls                  = 0x67,  //  "L0I_PREFETCH_STALL",  
    McKinleyBranchMispredictDetail2               = 0x68,  //  "BR_MIS_PREDICT_DETAIL2",    
    McKinleyL1InstPVABOverflows                   = 0x69,  //  "L0I_PVAB_OVERFLOW",  
    McKinleyBranchPathPrediction2                 = 0x6a,  //  "BR_PATH_PREDICTION2",  
    McKinleyFrontEndLostBandwidth                 = 0x70,  //  "FE_LOST_BW",  
    McKinleyFrontEndBubbles                       = 0x71,  //  "FE_BUBBLE",  
    McKinleyBackEndLostBandwidth                  = 0x72,  //  "BE_LOST_BW_DUE_TO_FE",  
    McKinleyBackEndIdealLostBandwidth             = 0x73,  //  "IDEAL_BE_LOST_BW_DUE_TO_FE",  
    McKinleyBusReadCpuLineHits                    = 0x80,  //  "BUS_RD_HIT",  
    McKinleyBusReadCpuModifiedLineHits            = 0x81,  //  "BUS_RD_HITM",  
    McKinleyBusReadBILCpuModifiedLineHits         = 0x82,  //  "BUS_RD_INVAL_HITM",  
    McKinleyBusReadBRILorBILCpuModifiedLineHits   = 0x83,  //  "BUS_RD_INVAL_HITM",  
    McKinleyBusCpuModifiedLineHits                = 0x84,  //  "BUS_HITM",  
    McKinleyBusCpuModifiedLineHitSnoops           = 0x85,  //  "BUS_SNOOPS_HITM",  
    McKinleyBusSnoops                             = 0x86,  //  "BUS_SNOOPS",  
    McKinleyBusAll                                = 0x87,  //  "BUS_ALL",  
    McKinleyBusDataCycles                         = 0x88,  //  "BUS_ALL",  
    McKinleyBusMemoryCurrentReads                 = 0x89,  //  "BUS_MEMORY_READ_CURRENT",  
    McKinleyBusMemoryTransactions                 = 0x8a,  //  "BUS_MEMORY",  
    McKinleyBusMemoryReads                        = 0x8b,  //  "BUS_MEM_READ",  
    McKinleyBusMemoryDataReads                    = 0x8c,  //  "BUS_RD_DATA",  
    McKinleyBusMemoryBRPReads                     = 0x8d,  //  "BUS_RD_PRTL",  
    McKinleyBusIA32LockCycles                     = 0x8e,  //  "BUS_LOCK_CYCLES",   
    McKinleyBusSnoopStallCycles                   = 0x8f,  //  "BUS_SNOOP_STALL_CYCLES",  
    McKinleyBusIA32IOTransactions                 = 0x90,  //  "BUS_IO",   
    McKinleyBusIA32IOReads                        = 0x91,  //  "BUS_RD_IO",   
    McKinleyBusMemoryWriteBacks                   = 0x92,  //  "BUS_WR_WB",   
    McKinleyBusIA32LockTransactions               = 0x93,  //  "BUS_LOCK",   
    McKinleyBusMemoryReadsOutstandingHi           = 0x94,  //  "BUS_MEM_READ_OUT_HI",  
    McKinleyBusMemoryReadsOutstandingLow          = 0x95,  //  "BUS_MEM_READ_OUT_LOW",  
    McKinleyBusSnoopResponses                     = 0x96,  //  "BUS_SNOOPQ_REQ",  
    McKinleyBusLiveInOrderRequestsLow             = 0x97,  //  "BUS_IOQ_LIVE_REQ_LO",  
    McKinleyBusLiveInOrderRequestsHi              = 0x98,  //  "BUS_IOQ_LIVE_REQ_HI",  
    McKinleyBusLiveDeferredRequestsLow            = 0x99,  //  "BUS_OOO_LIVE_REQ_LO",  
    McKinleyBusLiveDeferredRequestsHi             = 0x9a,  //  "BUS_OOO_LIVE_REQ_HI",  
    McKinleyBusLiveQueuedReadRequestsLow          = 0x9b,  //  "BUS_BRQ_LIVE_REQ_LO",  
    McKinleyBusLiveQueuedReadRequestsHi           = 0x9c,  //  "BUS_BRQ_LIVE_REQ_HI",  
    McKinleyBusRequestQueueInserts                = 0x9d,  //  "BUS_BRQ_REQ_INSERTED",   
    McKinleyExternDPPins0To3Asserted              = 0x9e,  //  "EXTERN_DP_PINS_0_TO_3",   
    McKinleyExternDPPins4To5Asserted              = 0x9f,  //  "EXTERN_DP_PINS_4_TO_5",   
    McKinleyL2OZQCancels0                         = 0xa0,  //  "L1_OZQ_CANCELS0",  
    McKinleyL2InstFetchCancels                    = 0xa1,  //  "L1_IFET_CANCELS",  
    McKinleyL2OZQAcquires                         = 0xa2,  //  "L1_OZQ_ACQUIRE",  
    McKinleyL2OZQReleases                         = 0xa3,  //  "L1_OZQ_ACQUIRE",  
    McKinleyL2InstFetchCancelsByBypass            = 0xa5,  //  "L1_IFET_CANCELS",  
    McKinleyL2OZQAcquiresAliasA6                  = 0xa6,  //  "L1_OZQ_ACQUIRE",  
    McKinleyL2OZQCancels2                         = 0xa8,  //  "L1_OZQ_CANCELS2",  
    McKinleyL2InstFetchCancelsByDataRead          = 0xa9,  //  "L1_IFET_CANCELS",  
    McKinleyL2OZQAcquiresAliasAA                  = 0xaa,  //  "L1_OZQ_ACQUIRE",  
    McKinleyL2OZQCancels1                         = 0xac,  //  "L1_OZQ_CANCELS1",  
    McKinleyL2InstFetchCancelsByStFillWb          = 0xad,  //  "L1_IFET_CANCELS",  
    McKinleyL2OZQAcquiresAliasAE                  = 0xae,  //  "L1_OZQ_ACQUIRE",  
    McKinleyL2CanceledL3Accesses                  = 0xb0,  //  "L1_L2ACCESS_CANCEL",  
    McKinleyL2References                          = 0xb1,  //  "L1_REFERENCES",  
    McKinleyL2DataReferences                      = 0xb2,  //  "L1_DATA_REFERENCES",  
    McKinleyL2DataReads                           = 0xb2,  //  "L1_DATA_REFERENCES.u[=xx01]",  
    McKinleyL2DataWrites                          = 0xb2,  //  "L1_DATA_REFERENCES.u[=xx10]",  
    McKinleyL2TaggedAccesses                      = 0xb3,  //  "TAGGED_L1_PORT", 
    McKinleyL2ForcedRecirculatedOperations        = 0xb4,  //  "L1_FORCE_RECIRC", 
    McKinleyL2IssuedRecirculatedOZQAccesses       = 0xb5,  //  "L1_ISSUED_RECIRC_OZQ_ACC", 
    McKinleyL2SuccessfulRecirculatedOZQAccesses   = 0xb6,  //  "L1_GOT_RECIRC_OZQ_ACC", 
    McKinleyL2SynthesizedProbes                   = 0xb7,  //  "L1_SYNTH_PROBES", 
    McKinleyL2Bypasses                            = 0xb8,  //  "L1_BYPASS", 
    McKinleyL2IssuedOperations                    = 0xb8,  //  "L1_OPS_ISSUED", 
    McKinleyL2BadLinesSelected                    = 0xb9,  //  "L1_BAD_LINES_SELECTED", 
    McKinleyL2IssuedRecirculatedInstFetches       = 0xb9,  //  "L1_ISSUED_RECIRC_IFETCH", 
    McKinleyL2StoreSharedLineHits                 = 0xba,  //  "L1_STORE_HIT_SHARED", 
    McKinleyL2ReceivedRecirculatedInstFetches     = 0xba,  //  "L1_GOT_RECIRC_IFETCH", 
    McKinleyL2TaggedDataReturns                   = 0xbb,  //  "TAGGED_L1_DATA_RETURN_PORT", 
    McKinleyL2DataOrderingCzarQueueFull           = 0xbc,  //  "L1_OZQ_FULL", 
    McKinleyL2DataOrderingCzarDataBufferFull      = 0xbd,  //  "L1_OZDB_FULL", 
    McKinleyL2DataVictimBufferFull                = 0xbe,  //  "L1_VICTIMB_FULL", 
    McKinleyL2DataFillBufferFull                  = 0xbf,  //  "L1_FILLB_FULL", 
    McKinleyL1DataTLBTransfersSet0                = 0xc0,  //  "L0DTLB_TRANSFER",  
    McKinleyDataTLBMissesSet0                     = 0xc1,  //  "DTLB_MISSES",  
    McKinleyL1DataReadsSet0                       = 0xc2,  //  "L0D_READS",  
    McKinleyL1DataReadsSet1                       = 0xc4,  //  "L0D_READS",  
    McKinleyDataReferencesSet1                    = 0xc5,  //  "DATA_REFERENCES", 
    McKinleyDataTLBReferencesSet1                 = 0xc5,  //  "DTLB_REFERENCES", 
    McKinleyL1DataReadMissesSet1                  = 0xc7,  //  "L0D_READ_MISSES", 
    McKinleyL1DataReadMissesByRSEFillsSet1        = 0xc7,  //  "L0D_READ_MISSES", 
    McKinleyDataEAREvents                         = 0xc8,  //  "DATA_EAR_EVENTS",    
    McKinleyDataTLBHPWInserts                     = 0xc9,  //  "DTLB_INSERTS_HPW",   
    McKinleyBackEndL0DAndFPUBubbles               = 0xca,  //  "BE_L0D_FPU_BUBBLE",       
    McKinleyL2Misses                              = 0x6b,  //  "L1_MISSES",    
    McKinleyDataDebugRegisterMatches              = 0xc6,  //  "DATA_DEBUG_REGISTER_MATCHES", 
    McKinleyRetiredLoads                          = 0xcd,  //  "LOADS_RETIRED",       
    McKinleyRetiredMisalignedLoads                = 0xce,  //  "MISALIGNED_LOADS_RETIRED",        
    McKinleyRetiredUncacheableLoads               = 0xcf,  //  "UC_LOADS_RETIRED",    
    McKinleyRetiredUncacheableStores              = 0xd0,  //  "UC_STORES_RETIRED",    
    McKinleyRetiredStores                         = 0xd1,  //  "STORES_RETIRED",      
    McKinleyRetiredMisalignedStores               = 0xd2,  //  "MISALIGNED_STORES_RETIRED",       
    McKinleyL1DataPortTaggedReturnsSet5           = 0xd5,  //  "TAGGED_L0_DATA_RETURN_PORT", 
    McKinleyL1DataPortTaggedAccessesSet5          = 0xd6,  //  "TAGGED_L0D_PORT", 
    McKinleyL3References                          = 0xdb,  //  "L2_REFERENCES",   
    McKinleyL3Misses                              = 0xdc,  //  "L2_MISSES",       
    McKinleyL3Reads                               = 0xdd,  //  "L2_READS",        
    McKinleyL3Writes                              = 0xde,  //  "L2_WRITES",       
    McKinleyL3ValidReplacedLines                  = 0xdf,  //  "L2_LINES_REPLACED", 
} MCKINLEY_MONITOR_EVENT;

//
// McKinley Derived Events:
//
// Assumption: McKinleyDerivedEventMinimum > McKinleyMonitoredEventMaximum.
//
// Implementation Status legend specified as: S:FIV where
//      - F: verified Formula or X for non-verified
//      - I: Implemented or X for non-implemented
//      - V: derived event validity verified or X for non-verified
//

typedef enum _MCKINLEY_DERIVED_EVENT {       // Implementation status = McKinley PMU ERS Event Name = Formula
    McKinleyDerivedEventMinimum              = 0x100, /* > Maximum of McKinley Monitored Event */
    McKinleyRSEStallCycles                   = McKinleyDerivedEventMinimum, // S:XXX - (McKinleyMemoryStallCycles    - McKinleyDataStallAccessCycles)
    McKinleyIssueLimitStallCycles,           // S:XXX = XXX = (McKinleyExecStallCycles      - McKinleyExecLatencyStallCycles)
    McKinleyTakenBranchStallCycles,          // S:XXX = (McKinleyBranchStallCycles    - McKinleyBranchMispredictStallCycles)
    McKinleyFetchWindowStallCycles,          // S:XXX = (McKinleyInstFetchStallCycles - McKinleyInstAccessStallCycles)
    McKinleyIA64InstPerCycle,                // S:XXX = (IA64_INST_RETIRED.u        / CPU_CYCLES[IA64])
    McKinleyIA32InstPerCycle,                // S:XXX = (IA32_INSTR_RETIRED         / CPU_CYCLES[IA32])
    McKinleyAvgIA64InstPerTransition,        // S:XXX = (IA64_INST_RETIRED.u        / (ISA_TRANSITIONS * 2))
    McKinleyAvgIA32InstPerTransition,        // S:XXX = (IA32_INSTR_RETIRED         / (ISA_TRANSITIONS * 2))
    McKinleyAvgIA64CyclesPerTransition,      // S:XXX = (CPU_CYCLES[IA64]           / (ISA_TRANSITIONS * 2))
    McKinleyAvgIA32CyclesPerTransition,      // S:XXX = (CPU_CYCLES[IA32]           / (ISA_TRANSITIONS * 2))
    McKinleyL1InstReferences,                // S:XXX = LOI_REFERENCES = L0I_READS + L0I_IPREFETCHES 
    McKinleyL1InstMissRatio,                 // S:XXX = (L1I_MISSES                 / McKinleyL1InstReferences)
    McKinleyL1DataReadMissRatio,             // S:XXX = (L1D_READS_MISSES_RETIRED   / L1D_READS_RETIRED)
    McKinleyL2MissRatio,                     // S:XXX = (L2_MISSES                  / L2_REFERENCES)     
    McKinleyL2DataMissRatio,                 // S:XXX = (L3_DATA_REFERENCES         / L2_DATA_REFERENCES)
    McKinleyL2InstMissRatio,                 // S:XXX = (L3_DATA_REFERENCES         / L2_DATA_REFERENCES)
    McKinleyL2DataReadMissRatio,             // S:XXX = (L3_LOAD_REFERENCES.u       / L2_DATA_READS.u)     
    McKinleyL2DataWriteMissRatio,            // S:XXX = (L3_STORE_REFERENCES.u      / L2_DATA_WRITES.u)    
    McKinleyL2InstFetchRatio,                // S:XXX = (L1I_MISSES                 / L2_REFERENCES) 
    McKinleyL2DataRatio,                     // S:XXX = (L2_DATA_REFERENCES         / L2_REFERENCES) 
    McKinleyL3MissRatio,                     // S:XXX = (L3_MISSES                  / L2_MISSES)     
    McKinleyL3DataMissRatio,                 // S:XXX = ((L3_LOAD_MISSES.u + L3_STORE_MISSES.u) / L3_REFERENCES.d)     
    McKinleyL3InstMissRatio,                 // S:XXX = (L3_INST_MISSES.u           / L3_INST_REFERENCES.u)     
    McKinleyL3DataReadMissRatio,             // S:XXX = (L3_LOAD_REFERENCES.u       / L3_DATA_REFERENCES.d)     
    McKinleyL3DataRatio,                     // S:XXX = (L3_DATA_REFERENCES.d       / L3_REFERENCES)     
    McKinleyInstReferences,                  // S:XXX = (L1I_READS)                                  
    McKinleyL0DTLBMissRatio,                 // S:FXX = L0DTLB_MISS_RATIO = (L0DTLB_MISSES  / L0D_READS)       
    McKinleyDTLBMissRatio,                   // S:FXX = DTLB_MISS_RATIO   = (DTLB_MISSES    / DATA_REFERENCES) 
    McKinleyDataTCMissRatio,                 // S:XXX = (DTC_MISSES                 / DATA_REFERENCES_RETIRED)
    McKinleyInstTLBEAREvents,                // S:XXX = (INSTRUCTION_EAR_EVENTS)
    McKinleyDataTLBEAREvents,                // S:XXX = (DATA_EAR_EVENTS)
    McKinleyControlSpeculationMissRatio,     // S:XXX = (INST_FAILED_CHKS_RETIRED   / IA64_TAGGED_INSTRS_RETIRED[chk.s])
    McKinleyDataSpeculationMissRatio,        // S:XXX = (ALAT_INST_FAILED_CHKA_LDC  / ALAT_INST_CHKA_LDC)
    McKinleyALATCapacityMissRatio,           // S:XXX = (ALAT_CAPACITY_MISS         / IA64_TAGGED_INSTRS_RETIRED[ld.sa,ld.a,ldfp.a,ldfp.sa])
    McKinleyL1DataWayMispredicts,            // S:XXX = (EventCode: 0x33 / Umask: 0x2)
    McKinleyL2InstReferences,                // S:FXX = L1_INST_REFERENCES = (L0I_MISSES + L1_INST_PREFETCHES)   
    McKinleyInstFetches,                     // S:XXX = (L1I_MISSES)
    McKinleyL3InstReferences,                // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL3InstMisses,                    // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL3InstHits,                      // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL3DataReferences,                // S:FXX = L2_DATA_REFERENCES = (L2_REFERENCES - L2_INST_REFERENCES)   
    McKinleyL3ReadReferences,                // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL2WriteBackReferences,           // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL2WriteBackMisses,               // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL2WriteBackHits,                 // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL2WriteReferences,               // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL2WriteMisses,                   // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyL2WriteHits,                     // S:XXX = (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    McKinleyBranchInstructions,              // S:XXX = (TAGGED_INSTR + opcode)
    McKinleyIntegerInstructions,             // S:XXX = (TAGGED_INSTR + opcode)
    McKinleyL1DataMisses,                    // S:XXX = 
    McKinleyISBLinesIn,                      // S:FXX = ISB_LINES_IN = (ISB_BUNPAIRS_IN/4)                                         
    McKinleyBusMemoryCodeReads,              // S:FXX = BUS_RD_INSTRUCTIONS      = (BUS_RD_ALL - BUS_RD_DATA)                      
    McKinleyBusReadBILMemoryHits,            // S:FXX = BUS_RD_INVAL_MEMORY      = (BUS_RD_INVAL - BUS_RD_INVAL_HITM)              
    McKinleyBusReadBRILCpuModifiedLineHits,  // S:FXX = BUS_RD_INVAL_BST_HIM     = (BUS_RD_INVAL_ALL_HITM - BUS_RD_INVAL_HITM)     
    McKinleyBusReadBRILMemoryHits,           // S:FXX = BUS_RD_INVAL_BST_MEMORY  = (BUS_RD_INVAL_BST - BUS_RD_INVAL_BST_HITM)      
    McKinleyBusMemoryReadsOutstanding,       // S:FXX = BUS_MEM_READ_OUTSTANDING = (BUS_MEM_READ_OUT_HI*8 + BUS_MEM_READ_OUT_LOW)  
    McKinleyBusLiveInOrderRequests,          // S:FXX = BUS_IOQ_LIVE_REQ         = (BUS_IOQ_LIVE_REQ_HI*4 + BUS_IOQ_LIVE_REQ_LO)   
    McKinleyBusLiveDeferredRequests,         // S:FXX = BUS_OOO_LIVE_REQ         = (BUS_OOO_LIVE_REQ_HI[4:3] | BUS_OOO_LIVE_REQ_LO[2:0]) 
    McKinleyBusLiveQueuedReadRequests,       // S:FXX = BUS_BRQ_LIVE_REQ         = (BUS_BRQ_LIVE_REQ_HI[4:3] | BUS_BRQ_LIVE_REQ_LO[2:0]) 
    McKinleyRSEDirtyRegs,                 // S:FXX = RSE_DIRTY_REGS = (64*RSE_DIRTY_REGS0[6]+8*RSE_DIRTY_REGS1[5:3]+REG_DIRTY_REGS2[2:0])
    McKinleyRSECurrentRegs,               // S:FXX = RSE_CURRENT_REGS = (64*RSE_CURRENT_REGS0[6]+8*RSE_DIRTY_REGS1[5:3]+REG_DIRTY_REGS2[2:0])
} MCKINLEY_DERIVED_EVENT;

typedef enum _KPROFILE_MCKINLEY_SOURCE {
//
// Profile McKinley Monitored Events:
//
    ProfileMcKinleyMonitoredEventMinimum       = ProfileMaximum + 0x1,
	ProfileMcKinleyBackEndBubbles              = ProfileMcKinleyMonitoredEventMinimum,
	ProfileMcKinleyBackEndRSEBubbles,
	ProfileMcKinleyBackEndEXEBubbles,
	ProfileMcKinleyBackEndL0DAndFPUBubbles,
	ProfileMcKinleyBackEndFlushBubbles,
	ProfileMcKinleyFrontEndBubbles,
	ProfileMcKinleyFrontEndLostBandwidth,
	ProfileMcKinleyBackEndLostBandwidth,
	ProfileMcKinleyBackEndIdealLostBandwidth,
	ProfileMcKinleyFPTrueSirStalls,
	ProfileMcKinleyFPFalseSirStalls,
	ProfileMcKinleyFPFailedFchkf,
	ProfileMcKinleyTaggedInstRetired,
	ProfileMcKinleyInstRetired,
	ProfileMcKinleyFPOperationsRetired,
	ProfileMcKinleyFPFlushesToZero,
	ProfileMcKinleyBranchPathPrediction,
	ProfileMcKinleyBranchPathPrediction2,
	ProfileMcKinleyBranchMispredictDetail,
	ProfileMcKinleyBranchMispredictDetail2,
	ProfileMcKinleyBranchEventsWithEAR,
    ProfileMcKinleyBackEndBranchMispredictDetail,
    ProfileMcKinleyEncodedBranchMispredictDetail,
	ProfileMcKinleyCpuCycles,
	ProfileMcKinleyISATransitions,
	ProfileMcKinleyIA32InstRetired,
	ProfileMcKinleyL1InstReads,
	ProfileMcKinleyL1InstFills,
	ProfileMcKinleyL1InstMisses,
	ProfileMcKinleyL1InstEAREvents,
	ProfileMcKinleyL1InstPrefetches,
	ProfileMcKinleyL1InstStreamPrefetches,
	ProfileMcKinleyL2InstPrefetches,
	ProfileMcKinleyISBBundlePairs,
	ProfileMcKinleyL1InstFetchRABHits,
	ProfileMcKinleyL1InstFetchISBHits,
	ProfileMcKinleyL1InstPrefetchStalls,
	ProfileMcKinleyL1InstRABAlmostFull,
	ProfileMcKinleyL1InstRABFull,
	ProfileMcKinleyL1InstSnoops,
	ProfileMcKinleyL1InstPurges,
	ProfileMcKinleyL1InstPVABOverflows,
	ProfileMcKinleyL1DataReadsSet0,
	ProfileMcKinleyL1DataTLBTransfersSet0,
	ProfileMcKinleyDataTLBMissesSet0,
	ProfileMcKinleyDataReferencesSet1,
	ProfileMcKinleyL1DataReadsSet1,
	ProfileMcKinleyL1DataReadMissesSet1,
	ProfileMcKinleyL1DataReadMissesByRSEFillsSet1,
	ProfileMcKinleyL1DataPortTaggedAccessesSet5,
	ProfileMcKinleyL1DataPortTaggedReturnsSet5,
	ProfileMcKinleyVHPTDataReferences,
	ProfileMcKinleyDataEAREvents, 
	ProfileMcKinleyL2OZQCancels0, 
	ProfileMcKinleyL2OZQCancels1, 
	ProfileMcKinleyL2OZQCancels2, 
	ProfileMcKinleyL2InstFetchCancels,
	ProfileMcKinleyL2InstFetchCancelsByBypass,
	ProfileMcKinleyL2InstFetchCancelsByDataRead,
	ProfileMcKinleyL2InstFetchCancelsByStFillWb,
	ProfileMcKinleyL2OZQAcquires, 
	ProfileMcKinleyL2OZQReleases, 
	ProfileMcKinleyL2CanceledL3Accesses, 
	ProfileMcKinleyL2References,
	ProfileMcKinleyL2DataReferences,
	ProfileMcKinleyL2DataReads,
	ProfileMcKinleyL2DataWrites,
	ProfileMcKinleyL2TaggedAccesses,
	ProfileMcKinleyL2ForcedRecirculatedOperations,
	ProfileMcKinleyL2IssuedRecirculatedOZQAccesses,
	ProfileMcKinleyL2SuccessfulRecirculatedOZQAccesses,
	ProfileMcKinleyL2SynthesizedProbes,
	ProfileMcKinleyL2DataBypasses1,
	ProfileMcKinleyL2DataBypasses2,
	ProfileMcKinleyL3DataBypasses1,
	ProfileMcKinleyL2InstBypasses1,
	ProfileMcKinleyL2InstBypasses2,
	ProfileMcKinleyL3InstBypasses1,
	ProfileMcKinleyL2BadLinesSelected,
	ProfileMcKinleyL2StoreSharedLineHits,
	ProfileMcKinleyL2IntegerLoads,
	ProfileMcKinleyL2FloatingPointLoads,
	ProfileMcKinleyL2ReadModifyWriteStores,
	ProfileMcKinleyL2NonReadModifyWriteStores,
	ProfileMcKinleyL2NonLoadsNonStores,
	ProfileMcKinleyL2IssuedRecirculatedInstFetches,
	ProfileMcKinleyL2ReceivedRecirculatedInstFetches,
	ProfileMcKinleyL2TaggedDataReturns,
	ProfileMcKinleyL2DataFillBufferFull,
	ProfileMcKinleyL2DataVictimBufferFull,
	ProfileMcKinleyL2DataOrderingCzarDataBufferFull,
	ProfileMcKinleyL2DataOrderingCzarQueueFull,
	ProfileMcKinleyL2Misses,
	ProfileMcKinleyL3References,
	ProfileMcKinleyL3Misses,
	ProfileMcKinleyL3Reads,
	ProfileMcKinleyL3ReadHits,
	ProfileMcKinleyL3ReadMisses,
	ProfileMcKinleyL3InstFetchReferences,
	ProfileMcKinleyL3InstFetchHits,
	ProfileMcKinleyL3InstFetchMisses,
	ProfileMcKinleyL3LoadReferences,
	ProfileMcKinleyL3LoadHits,
	ProfileMcKinleyL3LoadMisses,
	ProfileMcKinleyL3Writes,
	ProfileMcKinleyL3WriteHits,
	ProfileMcKinleyL3WriteMisses,
	ProfileMcKinleyL3StoreReferences,
	ProfileMcKinleyL3StoreHits,
	ProfileMcKinleyL3StoreMisses,
	ProfileMcKinleyL3WriteBackReferences,
	ProfileMcKinleyL3WriteBackHits,
	ProfileMcKinleyL3WriteBackMisses,
	ProfileMcKinleyL3ValidReplacedLines,
    ProfileMcKinleyDataDebugRegisterMatches,
    ProfileMcKinleyCodeDebugRegisterMatches,
    ProfileMcKinleyDataDebugRegisterFaults,
	ProfileMcKinleyCpuCPLChanges,
	ProfileMcKinleySerializationEvents,
	ProfileMcKinleyExternDPPins0To3Asserted,
	ProfileMcKinleyExternDPPins4To5Asserted,
	ProfileMcKinleyInstTLBReferences,
	ProfileMcKinleyInstTLBDemandFetchMisses,
	ProfileMcKinleyL1InstTLBDemandFetchMisses,
	ProfileMcKinleyL2InstTLBDemandFetchMisses,
	ProfileMcKinleyInstTLBHPWInserts,
	ProfileMcKinleyDataTLBReferencesSet1,
	ProfileMcKinleyDataTLBHPWInserts,
	ProfileMcKinleyDataTLBHPWRetiredInserts,
	ProfileMcKinleyBusAllTransactions,
	ProfileMcKinleyBusSelfTransactions,
	ProfileMcKinleyBusNonPriorityAgentTransactions,
	ProfileMcKinleyBusMemoryTransactions,
	ProfileMcKinleyBusMemoryBurstTransactions,
	ProfileMcKinleyBusMemoryPartialTransactions,
	ProfileMcKinleyBusMemoryReads,
	ProfileMcKinleyBusMemoryBRLTransactions,
	ProfileMcKinleyBusMemoryBILTransactions,
	ProfileMcKinleyBusMemoryBRILTransactions,
	ProfileMcKinleyBusMemoryDataReads,
	ProfileMcKinleyBusMemoryDataReadsBySelf,
	ProfileMcKinleyBusMemoryDataReadsByNonPriorityAgent,
	ProfileMcKinleyBusMemoryBRPReads,
	ProfileMcKinleyBusMemoryBRPReadsBySelf,
	ProfileMcKinleyBusMemoryBRPReadsByNonPriorityAgent,
	ProfileMcKinleyBusReadCpuLineHits,
	ProfileMcKinleyBusReadCpuModifiedLineHits,
	ProfileMcKinleyBusReadBILCpuModifiedLineHits,
	ProfileMcKinleyBusReadBRILorBILCpuModifiedLineHits,
	ProfileMcKinleyBusCpuModifiedLineHits,
	ProfileMcKinleyBusMemoryWriteBacks,
	ProfileMcKinleyBusMemoryWriteBacksBySelf,
	ProfileMcKinleyBusMemoryWriteBacksByNonPriorityAgent,
	ProfileMcKinleyBusMemoryBurstWriteBacks,
	ProfileMcKinleyBusMemoryBurstWriteBacksBySelf,
	ProfileMcKinleyBusMemoryBurstWriteBacksByNonPriorityAgent,
	ProfileMcKinleyBusMemoryZeroByteWriteBacks,
	ProfileMcKinleyBusMemoryZeroByteWriteBacksBySelf,
	ProfileMcKinleyBusMemoryCurrentReads,
	ProfileMcKinleyBusMemoryCurrentReadsByNonPriorityAgent,
	ProfileMcKinleyBusCpuModifiedLineHitSnoops,
	ProfileMcKinleyBusCpuModifiedLineHitSnoopsBySelf,
	ProfileMcKinleyBusSnoops,
	ProfileMcKinleyBusSnoopsBySelf,
	ProfileMcKinleyBusSnoopsByNonPriorityAgent,
	ProfileMcKinleyBusSnoopStallCycles,
	ProfileMcKinleyBusSnoopStallCyclesBySelf,
	ProfileMcKinleyBusDataCycles,
	ProfileMcKinleyBusSnoopResponses,
	ProfileMcKinleyBusRequestQueueInserts,
	ProfileMcKinleyBusIA32IOTransactions,
	ProfileMcKinleyBusIA32IOTransactionsBySelf,
	ProfileMcKinleyBusIA32IOTransactionsByNonPriorityAgent,
	ProfileMcKinleyBusIA32IOReads,
	ProfileMcKinleyBusIA32IOReadsBySelf,
	ProfileMcKinleyBusIA32IOReadsByNonPriorityAgent,
	ProfileMcKinleyBusIA32LockTransactions,
	ProfileMcKinleyBusIA32LockTransactionsBySelf,
	ProfileMcKinleyBusIA32LockCycles,
	ProfileMcKinleyBusIA32LockCyclesBySelf,
	ProfileMcKinleyRSEAccesses,
	ProfileMcKinleyRSELoads,
	ProfileMcKinleyRSEStores,
	ProfileMcKinleyRSELoadUnderflowCycles,
	ProfileMcKinleyRSEOperations,
	ProfileMcKinleyTaggedInstructionsAtRotate,
	ProfileMcKinleyInstDispersed,
	ProfileMcKinleyDispersalCyclesStalled,
	ProfileMcKinleySyllablesOvercount,
	ProfileMcKinleySyllablesNotDispersed,
	ProfileMcKinleyInstNOPRetired,
	ProfileMcKinleyInstPredicateSquashedRetired,
	ProfileMcKinleyFailedSpeculativeCheckLoads,
	ProfileMcKinleyAdvancedCheckLoads,
	ProfileMcKinleyFailedAdvancedCheckLoads,
	ProfileMcKinleyALATOverflows,
	ProfileMcKinleyRetiredLoads,
	ProfileMcKinleyRetiredStores,
	ProfileMcKinleyRetiredUncacheableLoads,
	ProfileMcKinleyRetiredUncacheableStores,
	ProfileMcKinleyRetiredMisalignedLoads,
	ProfileMcKinleyRetiredMisalignedStores,
//
// Profile McKinley Derived Events:
//
    ProfileMcKinleyDerivedEventMinimum,
    ProfileMcKinleyRSEStallCycles               = ProfileMcKinleyDerivedEventMinimum,
    ProfileMcKinleyIssueLimitStallCycles,
    ProfileMcKinleyTakenBranchStallCycles,
    ProfileMcKinleyFetchWindowStallCycles,
    ProfileMcKinleyIA64InstPerCycle,
    ProfileMcKinleyIA32InstPerCycle,
    ProfileMcKinleyAvgIA64InstPerTransition,
    ProfileMcKinleyAvgIA32InstPerTransition,
    ProfileMcKinleyAvgIA64CyclesPerTransition,
    ProfileMcKinleyAvgIA32CyclesPerTransition,
    ProfileMcKinleyL1InstReferences,
    ProfileMcKinleyL1InstMissRatio,
    ProfileMcKinleyL1DataReadMissRatio,
    ProfileMcKinleyL2MissRatio,
    ProfileMcKinleyL2DataMissRatio,
    ProfileMcKinleyL2InstMissRatio,
    ProfileMcKinleyL2DataReadMissRatio,
    ProfileMcKinleyL2DataWriteMissRatio,
    ProfileMcKinleyL2InstFetchRatio,
    ProfileMcKinleyL2DataRatio,
    ProfileMcKinleyL3MissRatio,
    ProfileMcKinleyL3DataMissRatio,
    ProfileMcKinleyL3InstMissRatio,
    ProfileMcKinleyL3DataReadMissRatio,
    ProfileMcKinleyL3DataRatio,
    ProfileMcKinleyInstReferences,
    ProfileMcKinleyL0DTLBMissRatio,
    ProfileMcKinleyDTLBMissRatio,
    ProfileMcKinleyDataTCMissRatio,
    ProfileMcKinleyInstTLBEAREvents,
    ProfileMcKinleyDataTLBEAREvents,
    ProfileMcKinleyControlSpeculationMissRatio,
    ProfileMcKinleyDataSpeculationMissRatio,
    ProfileMcKinleyALATCapacityMissRatio,
    ProfileMcKinleyL1DataWayMispredicts,
    ProfileMcKinleyL2InstReferences,
    ProfileMcKinleyInstFetches,
    ProfileMcKinleyL3InstReferences,
    ProfileMcKinleyL3InstMisses,
    ProfileMcKinleyL3InstHits,
    ProfileMcKinleyL3DataReferences,
    ProfileMcKinleyL3ReadReferences,
    ProfileMcKinleyL2WriteBackReferences,
    ProfileMcKinleyL2WriteBackMisses,
    ProfileMcKinleyL2WriteBackHits,
    ProfileMcKinleyL2WriteReferences,
    ProfileMcKinleyL2WriteMisses,
    ProfileMcKinleyL2WriteHits,
    ProfileMcKinleyBranchInstructions,
    ProfileMcKinleyIntegerInstructions,
    ProfileMcKinleyL1DataMisses,
	ProfileMcKinleyISBLinesIn,
	ProfileMcKinleyBusMemoryCodeReads,
	ProfileMcKinleyBusReadBILMemoryHits,
	ProfileMcKinleyBusReadBRILCpuModifiedLineHits,
	ProfileMcKinleyBusReadBRILMemoryHits,
	ProfileMcKinleyBusMemoryReadsOutstanding,
	ProfileMcKinleyBusLiveInOrderRequests,
	ProfileMcKinleyBusLiveDeferredRequests,
	ProfileMcKinleyBusLiveQueuedReadRequests,
	ProfileMcKinleyRSEDirtyRegs,
	ProfileMcKinleyRSECurrentRegs,
    ProfileMcKinleyMaximum
} KPROFILE_MCKINLEY_SOURCE, *PKPROFILE_MCKINLEY_SOURCE;

#define PROFILE_TIME_MCKINLEY_DEFAULT_INTERVAL      (10 * 1000 * 10) // 10 milliseconds

#endif /* MCKINLEY_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\oemmca.c ===
//###########################################################################
//**
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/oemmca.c_v   2.1   09 Mar 1999 10:30:24   smariset  $
// $Log:   I:/DEVPVCS/OSMCA/oemmca.c_v  $
// 
//    Rev 2.1   09 Mar 1999 10:30:24   smariset
// *.h consolidation
// 
//    Rev 2.0   Dec 11 1998 11:42:18   khaw
// Post FW 0.5 release sync-up
// 
//   Rev 1.5   29 Oct 1998 14:25:00   smariset
//Consolidated Sources
//
//   Rev 1.4   07 Aug 1998 13:47:50   smariset
// 
//
//   Rev 1.3   10 Jul 1998 11:04:22   smariset
//just checking in
//
//   Rev 1.2   08 Jul 1998 14:23:14   smariset
// 
//
//   Rev 1.1   02 Jul 1998 15:36:32   smariset
// 
//
//   Rev 1.0   02 Jul 1998 09:20:56   smariset
// 
//
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OEMMCA.C - Merced OS Machine Check Handler
//
// Description:
//    This module has OEM machine check handler
//
//      Contents:   OemMcaHndlr()          
//                  PlatMcaHndlr()      
//
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//
#include "halp.h"
#include "arc.h"
#include "i64fw.h"
#include "check.h"
#include "osmca.h"
#include "oemmca.h"

fptr  pOsGetErrLog=0;                          // global pointer for OEM MCA entry point

//++
// Name: OemMcaInit()
// 
// Routine Description:
//
//      This routine registers OEM MCA handler initialization
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemMcaInit(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};

    // register the OS_MCA call back handler 
    rv=HalpOemToOsMcaRegisterProc((fptr)OemMcaDispatch);

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemMcaDispatch()
// 
// Routine Description:
//
//      This is the OEM call back handler, which is only exported
//      to the OS_MCA for call back during MCA/CMC errors.  This
//      handler will dispatch to the appripriate CMC/MCA proc.
//
// Arguments On Entry:
//              arg0 = Error Event (MchkEvent/CmcEvent)
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemMcaDispatch(ULONGLONG eFlag)
{   
    SAL_PAL_RETURN_VALUES rv={0};

    if(eFlag==MchkEvent)
        rv=OemMcaHndlr();
    else
        rv=OemCmcHndlr();

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemCmcHndlr()
// 
// Routine Description:
//
//      This is the OsMca CMC Handler, which is called by
//      the CMC interrupt handler in virtual mode
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemCmcHndlr(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};
    PsiLog myPsiLog;

    if(pOsGetErrLog >0)
    {
        rv=HalpOsGetErrLog(0, CmcEvent, PROC_LOG, (ULONGLONG*)&myPsiLog, sizeof(PsiLog));
        rv=HalpOsGetErrLog(0, CmcEvent, PLAT_LOG, (ULONGLONG*)&myPsiLog, sizeof(PsiLog));
    }

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemMcaHndlr()
// 
// Routine Description:
//
//      This is the OsMca handler for firmware uncorrected errors
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure: 
//          Error Corrected/Not Corrected (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemMcaHndlr(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};

    rv=OemProcErrHndlr();
    rv=OemPlatErrHndlr();
    
    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////


//++
// Name: OemProcErrHndlr()
// 
// Routine Description:
//
//      This routine reads or writes data to NVM space
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemProcErrHndlr(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};
    PsiLog myPsiLog;

    // first let us get the error log
    if(pOsGetErrLog >0)
    {
        rv=HalpOsGetErrLog(0, MchkEvent, PROC_LOG, (ULONGLONG*)&myPsiLog, sizeof(PsiLog));
    }

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemPlatErrHndlr()
// 
// Routine Description:
//
//      This routine reads or writes data to NVM space
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemPlatErrHndlr(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};
    PsiLog myPsiLog;

    // first let us get the error log
    if(pOsGetErrLog >0)
    {
        rv=HalpOsGetErrLog(0, MchkEvent, PLAT_LOG, (ULONGLONG*)&myPsiLog, sizeof(PsiLog));
    }

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemMcaCb()
// 
// Routine Description:
//
//      The entry point to this procedure is registered with OsMca 
//      fw interface for call back to return the call back address of OS proc.
//
// Arguments On Entry:
//              arg0 = OS MCA call back handler entry point
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemMcaCb(fptr pOsHndlr)
{   
    SAL_PAL_RETURN_VALUES rv={0};
    
    pOsGetErrLog=pOsHndlr;

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\oemmca.h ===
//###########################################################################
//**
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/oemmca.h_v   2.0   Dec 11 1998 11:42:18   khaw  $
// $Log:   I:/DEVPVCS/OSMCA/oemmca.h_v  $
// 
//    Rev 2.0   Dec 11 1998 11:42:18   khaw
// Post FW 0.5 release sync-up
// 
//   Rev 1.3   07 Aug 1998 13:47:50   smariset
// 
//
//   Rev 1.2   10 Jul 1998 11:04:22   smariset
//just checking in
//
//   Rev 1.1   08 Jul 1998 14:23:14   smariset
// 
//
//   Rev 1.0   02 Jul 1998 09:20:56   smariset
// 
//
//
//*****************************************************************************//

// function prototypes
typedef (*fptr)(void);
SAL_PAL_RETURN_VALUES OemMcaInit(void);
SAL_PAL_RETURN_VALUES OemMcaDispatch(ULONGLONG);
SAL_PAL_RETURN_VALUES OemCmcHndlr(void);     
SAL_PAL_RETURN_VALUES OemMcaHndlr(void);
SAL_PAL_RETURN_VALUES OemProcErrHndlr(void);
SAL_PAL_RETURN_VALUES OemPlatErrHndlr(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\osinit.c ===
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// 
//             10 Jun 1999  Bugcheck  Bernard Lint
//                                    M. Jayakumar (Muthurajan.Jayakumar@intel.com)

///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OSINIT.C - Merced OS INIT Handler
//
// Description:
//    This module has OS INIT Event Handler Reference Code.
//
//      Contents:   HalpOsInitInit()          
//                  HalpInitHandler() 
//
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//  

#include "halp.h"
#include "nthal.h"
#include "arc.h"
#include "i64fw.h"
#include "check.h"
#include "inbv.h"
#include "osmca.h"


// i64fwasm.s: low-level protection data structures
extern KSPIN_LOCK HalpInitSpinLock;

//
// Temporary location for INIT_EXCEPTION definition.
//

typedef ERROR_RECORD_HEADER INIT_EXCEPTION, *PINIT_EXCEPTION;    // Init Event Record

HALP_INIT_INFO  HalpInitInfo;

volatile ULONG HalpOsInitInProgress = 0;

VOID
HalpInitBugCheck(
    ULONG           InitBugCheckType,
    PINIT_EXCEPTION InitLog,
    ULONGLONG       InitAllocatedLogSize,
    ULONGLONG       SalStatus
    )
//++
// Name: HalpInitBugCheck()
// 
// Routine Description:
//
//      This function is called to bugcheck the system in a case of a fatal INIT 
//      or fatal FW interface errors. The OS must guarantee as much as possible
//      error containment in this path.
//      With the current implementation, this function should be only called from
//      the OS_INIT path. 
//
// Arguments On Entry:
//      ULONG           InitBugCheckType
//      PINIT_EXCEPTION InitLog
//      ULONGLONG       InitAllocatedLogSize
//      ULONGLONG       SalStatus
//      
// Return:
//      None.
//
// Implementation notes: 
//      This code CANNOT [as default rules - at least entry and through fatal INITs handling]
//          - make any system call
//          - attempt to acquire any spinlock used by any code outside the INIT handler
//          - change the interrupt state. 
//      Passing data to non-INIT code must be done using manual semaphore instructions.
//      This code should minimize the path and the global or memory allocated data accesses.
//      This code should only access INIT-namespace structures.
//      This code is called under the MP protection of HalpInitSpinLock and with the flag
//      HalpOsInitInProgress set.
//
//--
{

    if ( HalpOsInitInProgress )   {

        //
        // Enable InbvDisplayString calls to make it through to bootvid driver.
        //

        if ( InbvIsBootDriverInstalled() ) {

            InbvAcquireDisplayOwnership();

            InbvResetDisplay();
            InbvSolidColorFill(0,0,639,479,4); // make the screen blue
            InbvSetTextColor(15);
            InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
            InbvEnableDisplayString(TRUE);     // enable display string
            InbvSetScrollRegion(0,0,639,479);  // set to use entire screen
        }

        HalDisplayString (MSG_INIT_HARDWARE_ERROR);
        HalDisplayString (MSG_HARDWARE_ERROR2);

//
// Thierry 09/2000:
//
//   - if desired, process the INIT log HERE...
//
//     and use HalDisplayString() to dump info for the field or hardware vendor.
//     The processing could be based on processor or platform independent record definitions.
//

        HalDisplayString( MSG_HALT );

        KeBugCheckEx( MACHINE_CHECK_EXCEPTION, (ULONG_PTR)InitBugCheckType,
                                               (ULONG_PTR)InitLog, 
                                               (ULONG_PTR)InitAllocatedLogSize,
                                               (ULONG_PTR)SalStatus );

    }

    if ( ((*KdDebuggerNotPresent) == FALSE) && ((*KdDebuggerEnabled) != FALSE) )    {
        KeEnterKernelDebugger();
    }

    while( TRUE ) {
          //
        ; // Simply sit here so the INIT HARDWARE ERROR screen does not get corrupted...
          //
    }

    // noreturn

} // HalpInitBugCheck()

ERROR_SEVERITY
HalpInitProcessLog(
    PINIT_EXCEPTION  InitLog
    )
//++
// Name: HalpInitProcessLog()
//
// Routine Description:
//
//      This function is called to process the INIT event log in the OS_INIT path.
//
// Arguments On Entry:
//      PINIT_EXCEPTION InitLog - Pointer to the INIT event log.
//
// Return:
//      ERROR_SEVERITY
//
// Implementation notes:
//      This code does not do anything right now.
//      Testing will allow to determine the right filtering depending on FW functionalities
//      and user requested operations like warm reset.
//
//--
{
    ERROR_SEVERITY initSeverity;

    initSeverity = InitLog->ErrorSeverity;
    switch( initSeverity )    {

        case ErrorFatal:
            break;

        case ErrorRecoverable:
            break;

        case ErrorCorrected:
            break;

        default:
            //
            // These ERRROR_SEVERITY values have no HAL INIT specific handling.
            // As specified by the SAL Specs July 2000, we should not get these values in this path.
            //
            break;
    }

    return( initSeverity );

} // HalpInitProcessLog()

//++
// Name: HalpInitHandler()
// 
// Routine Description:
//
//      This is the OsInit handler for firmware uncorrected errors
//      It is our option to run this in physical or virtual mode
//
// Arguments On Entry:
//              arg0 = Function ID
//
// Return:
//              rtn0=Success/Failure (0/!0)
//              rtn1=Alternate MinState Pointer if any else NULL
//--
SAL_PAL_RETURN_VALUES 
HalpInitHandler(
      ULONG64 RendezvousState, 
      PPAL_MINI_SAVE_AREA  Pmsa
      )
{   
    SAL_PAL_RETURN_VALUES rv;
    LONGLONG              salStatus;
    KIRQL                 oldIrql;
    PINIT_EXCEPTION       initLog;
    ULONGLONG             initAllocatedLogSize;
    PSAL_EVENT_RESOURCES  initResources;

    volatile KPCR * const pcr = KeGetPcr();
 
    //
    // Block various I/O interrupts.
    //

    KeRaiseIrql(SYNCH_LEVEL, &oldIrql);

    //
    // Enable interrupts so the debugger will work.
    //

    HalpEnableInterrupts();

    HalpAcquireMcaSpinLock(&HalpInitSpinLock);
    HalpOsInitInProgress++;

    //
    // Save OsToSal minimum state
    //

    initResources = pcr->OsMcaResourcePtr;
    initResources->OsToSalHandOff.SalReturnAddress = initResources->SalToOsHandOff.SalReturnAddress;
    initResources->OsToSalHandOff.SalGlobalPointer = initResources->SalToOsHandOff.SalGlobalPointer;

    //
    // update local variables with pre-initialized INIT log data.
    //

    initLog = (PINIT_EXCEPTION)(initResources->EventPool);
    initAllocatedLogSize = initResources->EventPoolSize;
    if ( !initLog || !initAllocatedLogSize )  {
        //
        // The following code should never happen or the implementation of the HAL INIT logs
        // pre-allocation failed miserably. This would be a development error.
        //
        HalpInitBugCheck( (ULONG_PTR)HAL_BUGCHECK_INIT_ASSERT, initLog,
                                                               initAllocatedLogSize,
                                                               (ULONGLONG)Pmsa );
    }

    //
    // Get the INIT logs
    //

    salStatus = (LONGLONG)0;
    while( salStatus >= 0 )  {
        ERROR_SEVERITY errorSeverity;

        rv = HalpGetStateInfo( INIT_EVENT, initLog );
        salStatus = rv.ReturnValues[0];
        switch( salStatus )    {

            case SAL_STATUS_SUCCESS:
                errorSeverity = HalpInitProcessLog( initLog );
                if ( errorSeverity == ErrorFatal )  {
                    //
                    // We are now going down with a MACHINE_CHECK_EXCEPTION.
                    // No return...
                    //

                    KeBugCheckEx( MANUALLY_INITIATED_CRASH, (ULONG_PTR) initLog, initAllocatedLogSize, salStatus, (ULONG_PTR) Pmsa );
                } 
                rv = HalpClearStateInfo( INIT_EVENT );
                if ( !SAL_SUCCESSFUL(rv) )  { 
                    //
                    // Current consideration for this implementation - 08/2000:
                    // if clearing the event fails, we assume that FW has a real problem;
                    // continuing will be dangerous. We bugcheck.
                    // 
                    HalpInitBugCheck( HAL_BUGCHECK_INIT_CLEAR_STATEINFO, initLog, 
                                                                         initAllocatedLogSize, 
                                                                         rv.ReturnValues[0] );
                }
                // SAL_STATUS_SUCCESS, SAL_STATUS_SUCCESS_MORE_RECORDS ... and
                // ErrorSeverity != ErrorFatal.
                break;

            case SAL_STATUS_NO_INFORMATION_AVAILABLE:
                //
                // The salStatus value will break the salStatus loop.
                //
                rv.ReturnValues[0] = SAL_STATUS_SUCCESS;
                break;

            case SAL_STATUS_SUCCESS_WITH_OVERFLOW:  
            case SAL_STATUS_INVALID_ARGUMENT:
            case SAL_STATUS_ERROR:
            case SAL_STATUS_VA_NOT_REGISTERED:
            default: // Thierry 08/00: WARNING - SAL July 2000 - v2.90.
                     // default includes possible unknown positive salStatus values.
                HalpInitBugCheck( HAL_BUGCHECK_INIT_GET_STATEINFO, initLog, 
                                                                   initAllocatedLogSize,
                                                                   salStatus );
                break;
        }

    }

    if (RendezvousState == 2) {

        KeBugCheckEx( MANUALLY_INITIATED_CRASH, 
                      (ULONG_PTR) initLog, 
                      initAllocatedLogSize, 
                      salStatus, 
                      (ULONG_PTR) Pmsa 
                      );

    } else {

        KeBugCheckEx( NMI_HARDWARE_FAILURE, 
                      (ULONG_PTR) initLog, 
                      initAllocatedLogSize, 
                      salStatus, 
                      (ULONG_PTR) Pmsa 
                      );

    }


    //
    // Currently 08/2000, we do not support the modification of the minstate.
    //

    initResources->OsToSalHandOff.MinStateSavePtr = initResources->SalToOsHandOff.MinStateSavePtr;
    initResources->OsToSalHandOff.Result          = rv.ReturnValues[0];
    initResources->OsToSalHandOff.NewContextFlag = 0; // continue the same context and NOT new

    //
    // Release INIT spinlock protecting OS_INIT resources.
    //

    HalpOsInitInProgress = 0;
    HalpReleaseMcaSpinLock(&HalpInitSpinLock);

    return(rv);

} // HalpInitHandler()

//EndProc//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\pcip.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

// #define SUBCLASSPCI 1

#include "..\..\halx86\i386\pcip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\pmbus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmbus.c

Abstract:

    Implements functions that were done in
    previous HALs by bus handlers.  Basically,
    these will be somewhat simplified versions
    since much of the code in the bus handlers
    has effectively been moved into bus 
    drivers in NT5.

Author:

    Jake Oshins (jakeo) 1-Dec-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

ULONG HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG HalpSetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

HalpGetEisaData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpGetSystemInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

BOOLEAN
HalpTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

extern BUS_HANDLER  HalpFakePciBusHandler;
extern ULONG        HalpMinPciBus;
extern ULONG        HalpMaxPciBus;
extern ULONG HalpPicVectorRedirect[];


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitNonBusHandler)
#pragma alloc_text(PAGE,HalpAssignSlotResources)

#if !defined(NO_LEGACY_DRIVERS)
#pragma alloc_text(PAGE,HalAssignSlotResources)
#endif

#endif

VOID
HalpInitNonBusHandler (
    VOID
    )
{
    HALPDISPATCH->HalPciTranslateBusAddress = HalpTranslateBusAddress;
    HALPDISPATCH->HalPciAssignSlotResources = HalpAssignSlotResources;
    HALPDISPATCH->HalFindBusAddressTranslation = HalpFindBusAddressTranslation;
}


#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
{
    return STATUS_SUCCESS;
}

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

#endif // NO_LEGACY_DRIVERS

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    PCI_SLOT_NUMBER slot;
    BUS_HANDLER bus;
    ULONG length;
    
    switch (BusDataType) {
    case PCIConfiguration:

        //
        // Hack.  If the bus is outside of the known PCI busses, return
        // a length of zero.
        //

        if ((BusNumber < HalpMinPciBus) || (BusNumber > HalpMaxPciBus)) {
            return 0;
        }

        RtlCopyMemory(&bus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        bus.BusNumber = BusNumber;
        slot.u.AsULONG = SlotNumber;
    
        length = HalpGetPCIData(&bus,
                                &bus,
                                slot,
                                Buffer,
                                Offset,
                                Length
                                );
        
        return length;

    case Cmos:
        return HalpGetCmosData(0, SlotNumber, Buffer, Length);

#ifdef EISA_SUPPORTED
    case EisaConfiguration:

        //
        // Fake a bus handler.
        //
        
        bus.BusNumber = 0;

        return HalpGetEisaData(&bus,
                               &bus,
                               SlotNumber,
                               Buffer,
                               Offset,
                               Length
                               );
#endif

    default:
        return 0;
    }
}

#if !defined(NO_LEGACY_DRIVERS)

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

#endif // NO_LEGACY_DRIVERS

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    PCI_SLOT_NUMBER slot;
    BUS_HANDLER bus;

    switch (BusDataType) {
    case PCIConfiguration:

        RtlCopyMemory(&bus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        bus.BusNumber = BusNumber;
        slot.u.AsULONG = SlotNumber;

        return HalpSetPCIData(&bus,
                              &bus,
                              slot,
                              Buffer,
                              Offset,
                              Length
                              );
    case Cmos:

        return HalpSetCmosData(0, SlotNumber, Buffer, Length);

    default:
        return 0;
    }
}

#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
{
    if (BusType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part 
        // of transitioning the HAL out of the bus 
        // management business.
        //
        return HALPDISPATCH->HalPciAssignSlotResources(RegistryPath,
                                                       DriverClassName,
                                                       DriverObject,
                                                       DeviceObject,
                                                       BusType,
                                                       BusNumber,
                                                       SlotNumber,
                                                       AllocatedResources);
    } else {

        return HalpAssignSlotResources(RegistryPath,
                                       DriverClassName,
                                       DriverObject,
                                       DeviceObject,
                                       BusType,
                                       BusNumber,
                                       SlotNumber,
                                       AllocatedResources);
    }
}

#endif // NO_LEGACY_DRIVERS

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    BUS_HANDLER busHand;
    
    PAGED_CODE();
    
    switch (BusType) {
    case PCIBus:

        //
        // Fake a bus handler.
        //
    
        RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        busHand.BusNumber = BusNumber;

        return HalpAssignPCISlotResources(&busHand,
                                          &busHand,
                                          RegistryPath,
                                          DriverClassName,
                                          DriverObject,
                                          DeviceObject,
                                          SlotNumber,
                                          AllocatedResources);

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
    
}

#if !defined(NO_LEGACY_DRIVERS)


ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    Dispatcher for GetInterruptVector

--*/
{
    BUS_HANDLER busHand;

    //
    // If this is an ISA vector, pass it through the ISA vector
    // redirection table.
    //

    if (InterfaceType == Isa) {

        ASSERT(BusInterruptVector < PIC_VECTORS);

        BusInterruptVector = HalpPicVectorRedirect[BusInterruptVector];
        BusInterruptLevel = HalpPicVectorRedirect[BusInterruptLevel];
    }
    
    //
    // Fake bus handlers.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
    
    busHand.BusNumber = BusNumber;
    busHand.InterfaceType = InterfaceType;
    busHand.ParentHandler = &busHand;
    
    return HalpGetSystemInterruptVector(&busHand,
                                        &busHand,
                                        BusInterruptLevel,
                                        BusInterruptVector,
                                        Irql,
                                        Affinity);
}

#endif // NO_LEGACY_DRIVERS


BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
{
    if (InterfaceType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part 
        // of transitioning the HAL out of the bus 
        // management business.
        //
        return HALPDISPATCH->HalPciTranslateBusAddress(InterfaceType,
                                                       BusNumber,
                                                       BusAddress,
                                                       AddressSpace,
                                                       TranslatedAddress);
    } else {
        return HalpTranslateBusAddress(InterfaceType,
                                       BusNumber,
                                       BusAddress,
                                       AddressSpace,
                                       TranslatedAddress);
    }
};

BOOLEAN
HalpTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    Dispatcher for TranslateBusAddress

--*/
{
   
    //*(&TranslatedAddress->QuadPart) = BusAddress.QuadPart;
    *(&TranslatedAddress->LowPart) = BusAddress.LowPart;
    *(&TranslatedAddress->HighPart) = BusAddress.HighPart;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\osinitchk.s ===
//###########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/osmchk.s_v   2.1   05 Mar 1999 12:59:42   smariset  $
// $Log:   I:/DEVPVCS/OSMCA/osmchk.s_v  $
//
//   Rev 2.0   Dec 11 1998 11:42:18   khaw
//Post FW 0.5 release sync-up
//
//   Rev 1.4   12 Oct 1998 14:05:20   smariset
//gp fix up work around
//
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OSINITCHK.S - Merced OS INIT Handler Dispatcher
//
// Description:
//    TEMPTEMP CHANGE THE DOC.
//    Merced OS INIT event handler Stub to OSINIT "C" frame work.  If
//    we find a TLB related error, we cannot switch to virtual mode in
//    the OS.  All TLB related errors will need system reboot after
//    storing the errors to a persistence storage media (HD or Flash).
//
//      HalpOsInitDispatch               - Main
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//

#include "ksia64.h"
#include "fwglobal.h"

        GLOBAL_FUNCTION(HalpOsInitDispatch)
        GLOBAL_FUNCTION(HalpInitHandler)
        GLOBAL_FUNCTION(HalpMcaHandler)

        .text
//++
// Name: HalpOsInitDispatch()
//
// Routine Description:
//
//      This is the OS Init call back handler, which is only exported
//      to the SAL for call back during MCA errors.  This
//      handler will dispatch to the appripriate Init. proc. This
//      proc will be called in physical mode.
//
//      Sets up virtual->physical address translation
//      0x00100000->0x00100000 in dtr1/itr1 for OS_INIT.
//
// Arguments:
//
//      None
//
// On entry:
//      This function is called:
//          - in physical mode for uncorrected or correctable MCA events,
//          - RSE enforced in lazy mode,
//          - Processor resources:
//      PSR.dt = 0, PSR.it = 0, PSR.rt = 0 - Physical mode.
//      PSR.ic = 0, PSR.i  = 0             - Interrupt resources collection and interrupt disabled.
//      PSR.mc = 1                         - Machine Checks masked
//      PSR.mfl = 0                        - low fp disabled.
//      GR1  : OS_MCA Global Pointer (GP) registered by OS: OS's GP.
//      GR2-7: Unspecified.
//      GR8  : Physical address of the PAL_PROC entrypoint.
//      GR9  : Physical address of the SAL_PROC entrypoint.
//      GR10 : Physical address value of the SAL Global Pointer: SAL's GP.
//      GR11 : Rendezvous state information, defined as:
//                0 - Rendezvous of other processors was not required by
//                    PAL_CHECK and as such was not done.
//                1 - All other processors in the system were successfully
//                    rendezvous using MC_RENDEZVOUS interrupt.
//                2 - All other processors in the system were successfully
//                    rendezvous using a combination of MC_RENDEZVOUS
//                    interrupt and INIT.
//               -1 - Rendezvous of other processors was required by PAL
//                    but was unsuccessful.
//      GR12 : Return address to a location within SAL_CHECK.
//      GR17 : Pointer to processor minimum state saved memory location.
//      GR18 : Processor state as defined below:
//          D0-D5:          Reserved
//          D6-D31:         As defined in PAL EAS
//          D60-D63:        As defined in PAL EAS
//          D32-D47:        Size in bytes of processor dynamic state
//          D48-D59:        Reserved.
//      GR19 : Return address to a location within PAL_CHECK.
//      BR0  : Unspecified.
//
// Return State:
//
//      Note  : The OS_MCA procedure may or may not return to SAL_CHECK
//              in the case of uncorrected machine checks.
//              If it returns to SAL, the runtime convention requires that
//              it sets appropriate values in the Min-State area pointed
//              to by GR12 for continuing execution at the interrupted
//              context or at a new context.
//              Furthermore, the OS_MCA procedure must restore the
//              processor state to the same state as on entry except as:
//      GR1-7  : Unspecified.
//      GR8    : Return status
//                0 [= SAL_STATUS_SUCCESS] - Error has been corrected
//                    by OS_MCA.
//               -1 - Error has not been corrected by OS_MCA and
//                    SAL must warm boot the system.
//               -2 - Error has not been corrected by OS_MCA and
//                    SAL must cold boot the system.
//               -3 - Error has not been corrected by OS_MCA and
//                    SAL must halt the system.
//      GR9    : Physical address value for SAL's GP.
//      GR10   : Context flag
//                0 - Return will be to the same context.
//                1 - Return will be to a   new  context.
//      GR11-21: Unspecified.
//      GR22   : Pointer to a structure containing new values of registers
//               in the Min-State Save area.
//               OS_MCA must supply this parameter even if it does not
//               change the register values in the Min-State Save areas.
//      GR23-31: Unspecified.
//      BR0    : Unspecified.
//      PSR.mc : May be either 0 or 1.
//--

       .proc   HalpOsInitDispatch;
HalpOsInitDispatch::

       .prologue
       .unwabi     @nt,  EXCEPTION_FRAME

      // aliases for known registers:

      rPalProcEntryPoint     = r8
      rSalProcEntryPoint     = r9
      rSalGlobalPointer      = r10
      rRendezVousResult      = r11
      rSalReturnAddress      = r12
      rProcMinStateSavePtr   = r17
      rProcStateParameter    = r18
      rPalCheckReturnAddress = r19
      rEventResources        = t22
      rPcrPhysicalAddress    = t6

    //
    // Use pt1, pt2 to inidcate if this is a INIT or MCA event.
    //

    cmp.ne pt1, pt2 = r0, r0
    br.sptk HalpOsCommonDispatch
    ;;

ALTERNATE_ENTRY(HalpOsMcaDispatch1)

     cmp.eq pt1, pt2 = r0, r0

HalpOsCommonDispatch::

    //
    // - Flag the processor as "InOsInit":
    //   KiPcr.InOsInit = 1
    //
    // - Update KiPcr.InitPTOM to point to TopOfMemory,
    //   Memory after Processor Minimum State Save area.
    //
    // - Update processor InitSalToOsHandOff
    //
    // - Update local rPcrInitStateDump before calling osInitProcStateDump.
    //

      mov    rEventResources = PcOsMcaResourcePtr
      movl   t21 = KiPcr
      ;;
      tpa    rPcrPhysicalAddress = t21           //  Calculate physical address of PCR
      mov    t19  = SerSalToOsHandOff
      mov    t1  = 0x1
      ;;
      add    t0 = rPcrPhysicalAddress, rEventResources
      sub    t21 = rPcrPhysicalAddress, t21
      add    t16  = TOM, rProcMinStateSavePtr
      ;;
(pt1) ld8    rEventResources = [t0], PcInOsMca-PcOsMcaResourcePtr
      mov    ar.ccv = r0  
      ;;
(pt2) ld8    rEventResources = [t0], PcInOsInit-PcOsMcaResourcePtr
      mov    t18  = SerPTOM
      add    t20  = 0x8,  t19
      ;;

    //
    // Save in preserved registers:
    //     - pointer to processor minimum state save area,
    //     - processor state parameter
    //     - PAL_CHECK return address.
    //   s0 [=r4] <- r17,
    //   s1 [=r5] <- r18,
    //   s2 [=r6] <- r19
    //

      SaveRs(rProcMinStateSavePtr, rProcStateParameter, rPalCheckReturnAddress)
      ;;
      cmpxchg1.acq t17 = [t0], t1, ar.ccv
      ;; 
      cmp.ne pt0, p0 = t17, r0
(pt0) br.dpnt iResetNow
      ;;
      add    rEventResources = rEventResources, t21          // Calculate the physical address of the OsMcaResources
      add    t21  = 0x10, t19
      ;;
      add    t18  = rEventResources, t18
      add    t19  = rEventResources, t19
      add    t20  = rEventResources, t20
      add    t21  = rEventResources, t21
      ;;
      ld8    t17  = [t16]
      st8    [t19] = rPalProcEntryPoint,  0x18
      add    t0 = SerStateDumpPhysical, rEventResources
      ;;
      st8    [t18] = t17
      st8    [t20] = rSalProcEntryPoint,  0x18
      st8    [t21] = rSalGlobalPointer,   0x18
      ;;
      st8    [t19] = rRendezVousResult
      st8    [t20] = rSalReturnAddress
      st8    [t21] = rProcMinStateSavePtr
      ld8    t0 = [t0]                                  // InitStateDump
      ;;

    //
    // Save processor state in data area:
    //
      br.dpnt     osInitProcStateDump
      ;;

osInitDoneDump:
        //
        // If we have a TLB error, we cannot enable translation
        //
        tbit.nz.unc pt0,p0=s1, 60  // PSP.tc=60
(pt0)   br.dpnt     iThyself
        ;;

    //
    // Initialize current sp and ar.bsp and ar.bspstore
    //
    //    KiPcr.InitStackFrame[0] = ar.rsc
    //    KiPcr.InitStackFrame[1] = ar.pfs
    //    KiPcr.InitStackFrame[2] = ar.ifs
    //    KiPcr.InitStackFrame[3] = ar.bspstore
    //    KiPcr.InitStackFrame[4] = ar.rnat
    //    ar.bspstore = t0 [=KiPcr.InitBspStore]
    //    KiPcr.InitStackFrame[5] = ar.bsp - KiPcr.InitBspStore
    //      [BUGBUG ?? : should be ar.bsptore=KiPcr.InitStackFrame[3]]
    //    sp = KiPcr.InitStack
    //

      movl   t21 = KiPcr + PcOsMcaResourcePtr
      ;;
      tpa    t0 = t21           //  Calculate physical address of PCR OsInitResourcePtr
      mov    t1 = SerStateDumpPhysical
      ;;
      sub    t16 = SerBackStore, t21
      sub    t1 = t1, t21
      ;;
      add    t16 = t0, t16
      add    t1 = t0, t1
      ld8    rEventResources = [t0], PcInitialBStore - PcOsMcaResourcePtr
      ;;
      add    t16 = rEventResources, t16   // Calculate physical address of the new BSP
      mov    t21 = t0                    // t21 now points to InitialBStore in the PCR
      ;;
      add    t1 = rEventResources, t1   // Calculate the physical address of State Dump physical pointer
      ld8    t3 = [t16], SerStack - SerBackStore // t3 contains the initial BSP.
      ;;
      ld8    t7 = [t1]                  // t7 now contain the physical address of the state dump area
      ;;                                // and the physical top of stack
      st8    [t21] = t3, PcInitialStack - PcInitialBStore  // Save the InitialBStore in the PCR
      ld8    t1 = [t16], SerBackStoreLimit - SerStack      // Get inital Init stack
      ;;
      st8    [t21] = t1, PcBStoreLimit - PcInitialStack
      ld8    t0 = [t16], SerStackLimit - SerBackStoreLimit
      ;;
      add    t1 = -STACK_SCRATCH_AREA-ThreadStateSaveAreaLength-TrapFrameLength-PalMiniSaveLength, t1
      add    t7 = -STACK_SCRATCH_AREA-ThreadStateSaveAreaLength-TrapFrameLength-PalMiniSaveLength, t7
      st8    [t21] = t0, PcStackLimit - PcBStoreLimit     // Save BStore limit
      ld8    t18 = [t16]
      ;;
      mov    sp = t1
      st8    [t21] = t18, PcCurrentIrql - PcStackLimit
      ;;
      ld1    t1 = [t21]

//
// Copy the PAL Mini-save area to the stack. It must be accessed non-cached.
// t7 contains the physical address for the trap frame.
// r4 contains the minium save area physical address.
//

      mov    t16 = ar.lc                                // Save lc
      mov    t0 = PalMiniSaveLength/8
      ;;
      add    t21 = ThreadStateSaveAreaLength+TrapFrameLength, t7        // Calculate stack physical address
                                                                        // of PAL mini save area is saved.
      dep    t17 = 1, r4, 63, 1                 // Non-cached address of PAL mini save area
      mov    ar.lc = t0
      ;;

iCopyMini:
      ld8    t0 = [t17],8
      ;;
      st8    [t21] = t0,8
      br.ctop.sptk.few  iCopyMini
      ;;
      mov    ar.lc = t16                        // Restore lc
      mov    ar.rsc = r0                        // put RSE in lazy mode and use kernel mode stores.
      ;;

//
// Generate a exception trap frame.
// t7 contains the physical address for the trap frame.
// t3 contains the initial BSP
//
     add     t17=TrOldIrql, t7
     add     t21 = ThreadStateSaveAreaLength+TrapFrameLength+PmsRsRSC, t7    // Calculate stack physical address
     cover                                                                   // of PAL mini save area of RSE.
     ;;
     st1     [t17] = t1, TrEOFMarker - TrOldIrql
     movl    t0 = KTRAP_FRAME_EOF | EXCEPTION_FRAME
     ;;
     st8     [t17] = t0
     mov     t1 = ar.bspstore
     ;;
     mov     t0 = ar.bsp
     ld8     t18 = [t21],PmsStIIP - PmsRsRSC
     add     t17 = TrRsBSP - TrEOFMarker, t17
     ;;
     dep     t3 = t1, t3, 0, 9                          // Adjust new BSPSTORE for NATs
     st8     [t17] = t0,TrRsBSPSTORE - TrRsBSP
     ;;
     sub     t0 = t0, t1
     st8     [t17] = t1, TrRsRSC - TrRsBSPSTORE         // Save old BspStore
     ;;
     dep     t18 = t0, t18, RSC_MBZ1, RSC_LOADRS_LEN
     mov     ar.bspstore = t3
     ld8     t1 = [t21], PmsStIPSR - PmsStIIP               // Copy IIP to trap frame as IIP
     ;;
     st8     [t17] = t18, TrStIIP - TrRsRSC
     ld8     t0 = [t21], PmsStIFS - PmsStIPSR               // Copy IPSR to trap frame as IPSR
     ;;
     st8     [t17] = t1, TrStIPSR - TrStIIP
     ;;
     st8     [t17] = t0, TrStIFS - TrStIPSR
     ld8     t1 = [t21], PmsBrRp - PmsStIFS               // Copy IFS to trap frame as IFS
     ;;
     st8     [t17] = t1, TrBrRp - TrStIFS
     ld8     t0 = [t21], PmsPreds - PmsBrRp
     ;;
     st8     [t17] = t0, TrStISR - TrBrRp
     mov     t1 = cr.isr
     ;;
     st8     [t17] = t1, TrRsPFS - TrStISR
     mov     t0 = ar.pfs
     ;;
     st8     [t17] = t0, TrStIIPA - TrRsPFS
     mov     t1 = cr.iipa
     ;;
     st8     [t17] = t1, TrStIIM - TrStIIPA
     mov     t0 = cr.iim
     ;;
     st8     [t17] = t0, TrStIHA - TrStIIM
     mov     t1 = cr.iha
     ;;
     st8     [t17] = t0, TrStFPSR - TrStIHA
     mov     t0 = ar.fpsr
     ;;
     st8     [t17] = t0
     ld8     t1 = [t21]
     ;;
     add     t17 = TrPreds - TrStFPSR, t17
     add     t21 = PmsIntGp - PmsPreds, t21
     ;;
     st8     [t17] = t1, TrApUNAT - TrPreds
     mov     t0 = ar.unat
     ;;
     st8     [t17] = t0, TrIntGp - TrApUNAT
     ld8     t1 = [t21], PmsIntSp - PmsIntGp
     ;;
     st8     [t17] = t1, TrIntSp - TrIntGp
     ld8     t0 = [t21], PmsIntTeb - PmsIntSp
     ;;
     st8     [t17] = t0, TrIntTeb - TrIntSp
     ld8     t1 = [t21], PmsIntT0 - PmsIntTeb
     ;;
     st8     [t17] = t1, TrRsRNAT - TrIntTeb
     mov     t0 = ar.rnat
     ;;
     st8     [t17] = t0, TrBrT0 - TrRsRNAT
     mov     t1 = bt0
     ;;
     st8     [t17] = t1, TrBrT1 - TrBrT0
     mov     t0 = bt1
     ;;
     st8     [t17] = t0, TrApCCV-TrBrT1
     mov     t1 = ar.ccv
     ;;
     st8     [t17] = t1, TrSegCSD - TrApCCV
     mov     t0 = ar.csd
     ;;
     st8     [t17] = t0, TrIntT0 - TrSegCSD
     ld8     t1 = [t21], PmsIntT1 - PmsIntT0
     ;;
     st8     [t17] = t1, TrIntT1 - TrIntT0
     ld8     t0 = [t21], PmsIntV0 - PmsIntT1
     ;;
     st8     [t17] = t0, TrIntV0 - TrIntT1
     mov     t16 = ar.lc
     mov     t1 = 7
     ;;
     mov     ar.lc = t1
     ;;
iRegCopy1:
     ld8     t0 = [t21], 8
     ;;
     st8     [t17] = t0, 8
     br.ctop.sptk.few iRegCopy1
     ;;
     mov     t1 = 15
     add     t21 = PmsIntT7 - PmsB0R16, t21       // Skip over the bank 0 registers.
     ;;
     mov     ar.lc = t1
     ;;
iRegCopy2:
     ld8     t0 = [t21], 8
     ;;
     st8     [t17] = t0, 8
     br.ctop.sptk.few iRegCopy2
     ;;
     mov     ar.lc = t16

iEnableTranslation:

// let us switch to virtual mode
//
//      Need to do a "rfi" in order set "it" and "ed" bits in the PSR.
//
//      Make sure interrupts are disabled and that we are running on bank 1.
//
        rsm       1 << PSR_I
        bsw.1
        ;;

//
// psr mask prepration, warning we will have a problem with PMI here
//

        movl    t0 = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IC,1) |MASK_IA64(PSR_DA,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_MC,1);;
        mov     t1=psr;;
        or      t0=t0,t1
        movl    t1=iVirtualSwitchDone;;
        mov     cr.iip=t1;;
        movl    t1 = FPSR_FOR_KERNEL      /* initial fpsr value     */;\
        mov     cr.ipsr = t0;;
        mov     ar.fpsr = t1;;
        rfi
        ;;

iVirtualSwitchDone:
// done with enabling address translation

//
//      Set up arguments to the handler.
//

        alloc   t1 = 0, 0, 2, 0
        mov     r32 =  r11
        add     r33 = ThreadStateSaveAreaLength+TrapFrameLength, sp

// call our handler
(pt1)   movl        t0=HalpMcaHandler;;
(pt2)   movl        t0=HalpInitHandler;;
        mov         b6=t0;;
        br.call.dpnt b0=b6
        ;;

// psr mask prepration
        rsm     MASK_IA64(PSR_IC,1);;
        movl    t0 = MASK_IA64(PSR_DA,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1);;
        movl    t1=0xffffffffffffffff;;
        xor     t0=t0,t1;;
        mov     t1=psr;;
        and     t0=t0,t1
        movl    t1=BeginOsInitRestore;;
        tpa     t1=t1;;
        mov     cr.iip=t1;;
        mov     cr.ipsr = t0;;
        rfi
        ;;

BeginOsInitRestore:
// restore the original stack frame here
        mov    t16 = SerStackFrame
        movl   t21 = KiPcr + PcOsMcaResourcePtr
        ;;
        tpa    t1 = t21           //  Calculate physical address of PCR OsInitResourcePtr
        sub    t16 = t16, t21
        sub    t0 = SerStateDumpPhysical, t21
        ;;
        ld8    rEventResources = [t1]
        add    t16 = t1, t16
        add    t0 = t1, t0
        ;;
        add    t16 = rEventResources, t16   // Calculate the physical address of the Stack Frame
        add    t0 = rEventResources, t0   // Calculate the physical address of the State Dump pointer.
        ;;
        ld8    t0 = [t0];
        movl   t7 = PSRmcMask
        ;;
        RtnIntCxt( t7, t1, t16 )  // switch from interrupt context -> RSC mgmt.
        ;;

        //
        // let us restore all the registers from our PSI structure
        //

        mov     t6 = gp
        br.dpnt osInitProcStateRestore
        ;;

osInitDoneRestore:

        // Pal requires DFH of 0
        rsm         1 << PSR_DFH
        ;;
        rsm         1 << PSR_MFL  // just restoring to original state only
        ;;
        srlz.d
        ;;

     //
     // - Restore processor state from OsToSalHandOff.
     //
     // - Branch back to SALE_CHECK.

      mov    t1 = PcOsMcaResourcePtr
      movl   t21 = KiPcr
      ;;
      tpa    rPcrPhysicalAddress = t21           //  Calculate physical address of PCR
      ;;
      add    t0 = rPcrPhysicalAddress, t1
      sub    t21 = SerOsToSalHandOff, t21
      ;;
      ld8    t1 = [t0], PcInOsInit-PcOsMcaResourcePtr
      add    t21 = t21, rPcrPhysicalAddress
      ;;
      add    t1 = t1, t21          // Calculate the physical address of the OsInitResources->SalToOSHandOff
      ;;
      add    t16  = 0x8,  t1
      add    t17  = 0x10, t1
      ;;
      ld8    r8  = [t1], 0x18      // result of error handling
      ld8    r9  = [t16], 0x18      // physical SAL's GP value
      ld8    t22 = [t17]            // new Processor Min-State Save Ptr
      ;;
      ld8    t1 = [t1]         // SAL return address
      ld8    r10    = [t16]         // New Context Switch Flag
      xchg1  t0 = [t0], r0     // KiPcr.InOsInit = 0
      ;;
      mov     b0 = t1
      br.dpnt b0                       // Return to SALE_CHECK
      ;;

      .endp HalpOsInitDispatch

iStayInPhysicalMode::
// we have to reboot the machine, assume the log is already there in NVM
// OS can read the log next time when it comes around.  Or OS can try to
// run in physical mode as well.

iResetNow:
        mov     r8  = -2                     // cold reset
        mov     r9  = rSalGlobalPointer      // SalReturnAddress
        mov     r10 = r0                     // return in the same context
        mov     r22 = rProcMinStateSavePtr   // Processor Min-State Save Area
        ;;
        mov     b0  = rSalReturnAddress
        br.dpnt b0
        ;;

#if 0
//      do EFI system reset here...
//      Go to BugCheck (in physical mode).
//      Out to Port 80: Fatal TLB error
//
#endif // 0

iThyself:
        br          iThyself                     // loop for safety
        ;;

//EndMain//////////////////////////////////////////////////////////////////////

//++
// Name:
//      osInitProcStateDump()
//
// Stub Description:
//
//       This stub dumps the processor state during MCHK to a data area
//
// On Entry:
//
//       t0 = rPcrInitStateDump.
//
// Return Value:
//
//       None.
//
//--

osInitProcStateDump:
// TF: ASSERT( t0 == rPcrInitStateDump )

//save BRs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0                // duplicate t0 in t2

        mov         t1=b0
        mov         t3=b1
        mov         t5=b2;;
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=b3
        mov         t3=b4
        mov         t5=b5;;
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=b6
        mov         t3=b7;;
        st8         [t0]=t1,2*Inc8
        st8         [t2]=t3,2*Inc8;;

icSaveCRs:
// save CRs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0                // duplicate t0 in t2

        mov         t1=cr0                      // cr.dcr
        mov         t3=cr1                      // cr.itm
        mov         t5=cr2;;                    // cr.iva

        st8         [t0]=t1,8*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;            // 48 byte increments

        mov         t1=cr8;;                    // cr.pta
        st8         [t0]=t1,Inc8*8;;            // 64 byte increments

// Reading interruption registers when PSR.ic=1 causes an illegal operation fault
        mov         t1=psr;;
        tbit.nz.unc pt0,p0=t1,PSRic;;           // PSI Valid Log bit pos. test
(pt0)   st8         [t0]=r0,9*8+160             // increment by 168 byte inc.
(pt0)   br.dpnt     iSkipIntrRegs
        ;;

        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0                // duplicate t0 in t7

        mov         t1=cr16                     // cr.ipsr
        mov         t3=cr17                     // cr.isr
        mov         t5=r0;;                     // cr.ida => cr18
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=cr19                     // cr.iip
        mov         t3=cr20                     // cr.ifa
        mov         t5=cr21;;                   // cr.iitr
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=cr22                     // cr.iipa
        mov         t3=cr23                     // cr.ifs
        mov         t5=cr24;;                   // cr.iim
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=cr25;;                   // cr.iha
        st8         [t0]=t1,160;;               // 160 byte increment

iSkipIntrRegs:
        st8         [t0]=r0,168                 // another 168 byte inc.

        mov         t1=cr66;;                   // cr.lid
        st8         [t0]=t1,40                  // 40 byte increment

        mov         t1=cr71;;                   // cr.ivr
        st8         [t0]=t1,Inc8

        mov         t1=cr72;;                   // cr.tpr
        st8         [t0]=t1,24                  // 24 byte increment

        mov         t1=r0;;                     // cr.eoi => cr75
        st8         [t0]=t1,168                 // 168 byte inc.

        mov         t1=r0;;                     // cr.irr0 => cr96
        st8         [t0]=t1,Inc16               // 16 byte inc.

        mov         t1=r0;;                     // cr.irr1 => cr98
        st8         [t0]=t1,Inc16               // 16 byte inc.

        mov         t1=r0;;                     // cr.irr2 => cr100
        st8         [t0]=t1,Inc16               // 16 byte inc

        mov         t1=r0;;                     // cr.irt1 => cr100
        st8         [t0]=t1,Inc16               // 16b inc.

        mov         t1=r0;;                     // cr.itv => cr114
        st8         [t0]=t1,Inc16               // 16 byte inc.

        mov         t1=r0;;                     // cr.pmv => cr116
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.lrr0 => cr117
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.lrr1 => cr118
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.cmcv => cr119
        st8         [t0]=t1,Inc8*10;;

icSaveARs:
// save ARs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0                // duplicate t0 in t7

        mov         t1=ar0                      // ar.kr0
        mov         t3=ar1                      // ar.kr1
        mov         t5=ar2;;                    // ar.kr2
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=ar3                      // ar.kr3
        mov         t3=ar4                      // ar.kr4
        mov         t5=ar5;;                    // ar.kr5
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=ar6                      // ar.kr6
        mov         t3=ar7                      // ar.kr7
        mov         t5=r0;;                     // ar.kr8
        st8         [t0]=t1,10*Inc8
        st8         [t2]=t3,10*Inc8
        st8         [t7]=t5,10*Inc8;;           // increment by 72 bytes

        mov         t1=ar16                     // ar.rsc
        mov         t3=ar17                     // ar.bsp
        mov         t5=ar18;;                   // ar.bspstore
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=ar19;;                   // ar.rnat
        st8         [t0]=t1,Inc8*13             // increment by 13x8 bytes

        mov         t1=ar32;;                   // ar.ccv
        st8         [t0]=t1,Inc8*4

        mov         t1=ar36;;                   // ar.unat
        st8         [t0]=t1,Inc8*4

        mov         t1=ar40;;                   // ar.fpsr
        st8         [t0]=t1,Inc8*4

        mov         t1=ar44;;                   // ar.itc
        st8         [t0]=t1,160                 // 160

        mov         t1=ar64;;                   // ar.pfs
        st8         [t0]=t1,Inc8

        mov         t1=ar65;;                   // ar.lc
        st8         [t0]=t1,Inc8

        mov         t1=ar66;;                   // ar.ec
        st8         [t0]=t1
        adds        t0=Inc8*62,t0               //padding

// save RRs
        mov         ar.lc=0x08-1
        movl        t2=0x00;;

icStRR:
        mov         t1=rr[t2];;
        st8         [t0]=t1,Inc8
        add         t2=1,t2
        br.cloop.dpnt icStRR
        ;;

// align memory addresses to 16 bytes
        and         t1=0x0f,t0;;
        cmp.ne.unc  pt0,p0=t1,r0;;
(pt0)   add         t0=Inc8,t0

icSaveFRs:
// just save FP for INIT restore only, "C" code will trash f6-f15
// save ar.NaT
        mov         t3=ar.unat;;                 // ar.unat

        stf.spill   [t0]=f6,Inc16;;
        stf.spill   [t0]=f7,Inc16;;
        stf.spill   [t0]=f8,Inc16;;
        stf.spill   [t0]=f9,Inc16;;
        stf.spill   [t0]=f10,Inc16;;
        stf.spill   [t0]=f11,Inc16;;
        stf.spill   [t0]=f12,Inc16;;
        stf.spill   [t0]=f13,Inc16;;
        stf.spill   [t0]=f14,Inc16;;
        stf.spill   [t0]=f15,Inc16;;

        mov         t2=ar.unat;;
        st8         [t0]=t2,Inc8                // save User NaT bits for r16-t11
        mov         ar.unat=t3                  // restore original unat

        br.dpnt     osInitDoneDump
        ;;

//EndStub//////////////////////////////////////////////////////////////////////


//++
// Name:
//       osInitProcStateRestore()
//
// Stub Description:
//
//       This is a stub to restore the saved processor state during MCHK
//
// On Entry:
//
//       t0 = rPcrInitStateDump.
//
// Return Value:
//
//       None.
//--

osInitProcStateRestore:

// TF: ASSERT( t0 == rPcrInitStateDump )

// Restore bank1 GR16-31

irestore_BRs:
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         b0=t1
        mov         b1=t3
        mov         b2=t5;;

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         b3=t1
        mov         b4=t3
        mov         b5=t5;;

        ld8         t1=[t0],2*Inc8
        ld8         t3=[t2],2*Inc8;;
        mov         b6=t1
        mov         b7=t3;;

irestore_CRs:
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],8*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;            // 48 byte increments
        mov         cr0=t1                      // cr.dcr
        mov         cr1=t3                      // cr.itm
        mov         cr2=t5;;                    // cr.iva

        ld8         t1=[t0],8*Inc8;;            // 64 byte increments
//      mov         cr8=t1                      // cr.pta


// if PSR.ic=1, reading interruption registers causes an illegal operation fault
        mov         t1=psr;;
        tbit.nz.unc pt0,p0=t1,PSRic;;           // PSI Valid Log bit pos. test
(pt0)   st8         [t0]=r0,9*8+160             // increment by 160 byte inc.
(pt0)   br.dpnt     irSkipIntrRegs
        ;;

        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         cr16=t1                     // cr.ipsr
        mov         cr17=t3                     // cr.isr is read only
//      mov         cr18=t5;;                   // cr.ida

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         cr19=t1                     // cr.iip
        mov         cr20=t3                     // cr.idtr
        mov         cr21=t5;;                   // cr.iitr

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         cr22=t1                     // cr.iipa
        mov         cr23=t3                     // cr.ifs
        mov         cr24=t5                     // cr.iim

        ld8         t1=[t0],160;;               // 160 byte increment
        mov         cr25=t1                     // cr.iha

irSkipIntrRegs:
        ld8         t1=[t0],168;;               // another 168 byte inc.

        ld8         t1=[t0],40;;                // 40 byte increment
        mov         cr66=t1                     // cr.lid

        ld8         t1=[t0],Inc8;;
//      mov         cr71=t1                     // cr.ivr is read only
        ld8         t1=[t0],24;;                // 24 byte increment
        mov         cr72=t1                     // cr.tpr

        ld8         t1=[t0],168;;               // 168 byte inc.
//      mov         cr75=t1                     // cr.eoi

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr96=t1                     // cr.irr0 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr98=t1                     // cr.irr1 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc
//      mov         cr100=t1                    // cr.irr2 is read only

        ld8         t1=[t0],Inc16;;             // 16b inc.
//      mov         cr102=t1                    // cr.irt1 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr114=t1                    // cr.itv

        ld8         t1=[t0],Inc8;;
//      mov         cr116=t1                    // cr.pmv
        ld8         t1=[t0],Inc8;;
//      mov         cr117=t1                    // cr.lrr0
        ld8         t1=[t0],Inc8;;
//      mov         cr118=t1                    // cr.lrr1
        ld8         t1=[t0],Inc8*10;;
//      mov         cr119=t1                    // cr.cmcv

irestore_ARs:
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         ar0=t1                      // ar.kro
        mov         ar1=t3                      // ar.kr1
        mov         ar2=t5;;                    // ar.kr2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         ar3=t1                      // ar.kr3
        mov         ar4=t3                      // ar.kr4
        mov         ar5=t5;;                    // ar.kr5

        ld8         t1=[t0],10*Inc8
        ld8         t3=[t2],10*Inc8
        ld8         t5=[t7],10*Inc8;;
        mov         ar6=t1                      // ar.kr6
        mov         ar7=t3                      // ar.kr7
//      mov         ar8=t7                      // ar.kr8
        ;;

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
//      mov         ar16=t1                     // ar.rsc
//      mov         ar17=t3                     // ar.bsp is read only
        mov         ar18=t5;;                   // ar.bspstore

        ld8         t1=[t0],Inc8*13;;
        mov         ar19=t1                     // ar.rnat

        ld8         t1=[t0],Inc8*4;;
        mov         ar32=t1                     // ar.ccv

        ld8         t1=[t0],Inc8*4;;
        mov         ar36=t1                     // ar.unat

        ld8         t1=[t0],Inc8*4;;
        mov         ar40=t1                     // ar.fpsr

        ld8         t1=[t0],160;;               // 160
//      mov         ar44=t1                     // ar.itc

        ld8         t1=[t0],Inc8;;
        mov         ar64=t1                     // ar.pfs

        ld8         t1=[t0],Inc8;;
        mov         ar65=t1                     // ar.lc

        ld8         t1=[t0];;
        mov         ar66=t1                     // ar.ec
        adds        t0=Inc8*62,t0;;             // padding

irestore_RRs:
        mov         t3=ar.lc
        mov         ar.lc=0x08-1
        movl        t2=0x00
icStRRr:
        ld8         t1=[t0],Inc8;;
//      mov         rr[t2]=t1                   // what are its access previledges?
        add         t2=1,t2
        br.cloop.dpnt icStRRr
        ;;
        mov         ar.lc=t3

// align memory addresses to 16 bytes
        and         t1=0x0f,t0;;
        cmp.ne.unc  pt0,p0=t1,r0;;
(pt0)   add         t0=Inc8,t0;;

// restore FP's which might be trashed by the "C" code
        mov         t3=ar.unat
        add         t1=16*10,t0;;                // to get to NaT of GR 16-31
        ld8         t1=[t1];;
        mov         ar.unat=t1;;                // first restore NaT

irestore_FRs:
        ldf.fill    f6=[t0],Inc16;;
        ldf.fill    f7=[t0],Inc16;;
        ldf.fill    f8=[t0],Inc16;;
        ldf.fill    f9=[t0],Inc16;;
        ldf.fill    f10=[t0],Inc16;;
        ldf.fill    f11=[t0],Inc16;;
        ldf.fill    f12=[t0],Inc16;;
        ldf.fill    f13=[t0],Inc16;;
        ldf.fill    f14=[t0],Inc16;;
        ldf.fill    f15=[t0],Inc16;;

        mov         ar.unat=t3                  // restore original NaT

        br.dpnt     osInitDoneRestore
        ;;

//EndStub//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\osmca.h ===
#ifndef OSMCA_H_INCLUDED
#define OSMCA_H_INCLUDED

//###########################################################################
//**
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/osmca.h_v   2.2   09 Mar 1999 10:30:26   smariset  $
// $Log:   I:/DEVPVCS/OSMCA/osmca.h_v  $
// 
//    Rev 2.2   09 Mar 1999 10:30:26   smariset
// *.h consolidation
// 
//    Rev 2.0   Dec 11 1998 11:42:18   khaw
// Post FW 0.5 release sync-up
// 
//   Rev 1.4   29 Oct 1998 14:25:02   smariset
//Consolidated Sources
//
//   Rev 1.3   07 Aug 1998 13:47:50   smariset
// 
//
//   Rev 1.2   10 Jul 1998 11:04:24   smariset
//just checking in
//
//   Rev 1.1   08 Jul 1998 14:23:16   smariset
// 
//
//   Rev 1.0   02 Jul 1998 09:20:56   smariset
// 
//
//
//*****************************************************************************//

// SAL_MC_SET_PARAMS
// typedef's

typedef (*fptr)(void);
typedef SAL_PAL_RETURN_VALUES (*fpSalProc)(ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG);

typedef struct tagPLabel
{
    ULONGLONG    fPtr;
    ULONGLONG    gp;
} PLabel;

typedef struct tagSalHandOffState
{
    ULONGLONG     OsGp;
    ULONGLONG     pPalProc;
    fptr    pSalProc;
    ULONGLONG     SalGp;
     LONGLONG     RendzResult;
    ULONGLONG     SalRtnAddr;
    ULONGLONG     MinStatePtr;
} SalHandOffState;

#define SAL_RZ_NOT_REQUIRED                 0
#define SAL_RZ_WITH_MC_RENDEZVOUS           1
#define SAL_RZ_WITH_MC_RENDEZVOUS_AND_INIT  2
#define SAL_RZ_FAILED                      -1
#define SalRendezVousSucceeded( _SalHandOffState ) \
                    ((_SalHandOffState).RendzResult > SAL_RZ_NOT_REQUIRED)

//
// HAL Private SalRendezVousSucceeded definition, 
// using ntos\inc\ia64.h: _SAL_HANDOFF_STATE.
//

#define HalpSalRendezVousSucceeded( _SalHandOffState ) \
                    ((_SalHandOffState).RendezVousResult > SAL_RZ_NOT_REQUIRED)

typedef struct tagOsHandOffState
{
    ULONGLONG     Result;
    ULONGLONG     SalGp;
    ULONGLONG     nMinStatePtr;
    ULONGLONG     SalRtnAddr;
    ULONGLONG     NewCxFlag;
} OsHandOffState;

typedef SAL_PAL_RETURN_VALUES (*fpOemMcaDispatch)(ULONGLONG);

// function prototypes
void     HalpOsMcaDispatch(void);
void     HalpOsInitDispatch(void);
VOID     HalpCMCEnable ( VOID );
VOID     HalpCMCDisable( VOID );
VOID     HalpCMCDisableForAllProcessors( VOID );
VOID     HalpCPEEnable ( VOID );
VOID     HalpCPEDisable( VOID );
BOOLEAN  HalpInitializeOSMCA( ULONG Number );
VOID     HalpCmcHandler( VOID );
VOID     HalpCpeHandler( VOID );
SAL_PAL_RETURN_VALUES HalpMcaHandler(ULONG64 RendezvousState, PPAL_MINI_SAVE_AREA  Pmsa);

extern VOID HalpAcquireMcaSpinLock( PKSPIN_LOCK );
extern VOID HalpReleaseMcaSpinLock( PKSPIN_LOCK );
void     HalpOsMcaDispatch1(void);

//
// wrappers to SAL procedure calls
//

SAL_PAL_RETURN_VALUES 
HalpGetErrLogSize( ULONGLONG Reserved, 
                   ULONGLONG EventType
                 );   

#define HalpGetStateInfoSize( /* ULONGLONG */ _EventType ) HalpGetErrLogSize( 0, (_EventType) )

SAL_PAL_RETURN_VALUES 
HalpGetErrLog( ULONGLONG  Reserved, 
               ULONGLONG  EventType, 
               ULONGLONG *MemAddr
             );

#define HalpGetStateInfo( /* ULONGLONG */ _EventType, /* ULONGLONG * */ _Buffer ) \
                             HalpGetErrLog( 0, (ULONGLONG)(_EventType), (PULONGLONG)(_Buffer) )

SAL_PAL_RETURN_VALUES 
HalpClrErrLog( ULONGLONG Reserved, 
               ULONGLONG EventType  // MCA_EVENT,INIT_EVENT,CMC_EVENT,CPE_EVENT
             );

#define HalpClearStateInfo( /* ULONGLONG */ _EventType ) HalpClrErrLog( 0, (_EventType) )

SAL_PAL_RETURN_VALUES HalpSalSetParams(ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG);
SAL_PAL_RETURN_VALUES HalpSalSetVectors(ULONGLONG, ULONGLONG, PHYSICAL_ADDRESS, ULONGLONG, ULONGLONG);
SAL_PAL_RETURN_VALUES HalpSalRendz(void);

#define  GetGp()      __getReg(CV_IA64_IntGp)

#endif // OSMCA_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\osmca.c ===
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
//
//             10 Jun 1999  Bugcheck  Bernard Lint
//                                    M. Jayakumar (Muthurajan.Jayakumar@intel.com)
//                                    Thierry Fevrier
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OSMCA.C - Merced OS Machine Check Handler
//
// Description:
//    This module has OS Machine Check Handler Reference Code.
//
//      Contents:   HalpOsMcaInit()
//                  HalpCmcHandler()
//                  HalpMcaHandler()
//                  HalpMcRzHandlr()
//                  HalpMcWkupHandlr()
//                  HalpProcMcaHndlr()
//                  HalpPlatMcaHndlr()
//
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//
#include "halp.h"
#include "nthal.h"
#include "arc.h"
#include "i64fw.h"
#include "check.h"
#include "iosapic.h"
#include "inbv.h"
#include "osmca.h"

// pmdata.c: CPE definitions.
extern ULONG             HalpMaxCPEImplemented;
extern ULONG             HalpCPEIntIn[];

// i64fw.c: HAL Private Data structure for SAL/PAL
extern HALP_SAL_PAL_DATA HalpSalPalData;

// i64fwasm.s: low-level protection data structures
extern KSPIN_LOCK        HalpMcaSpinLock;
extern KSPIN_LOCK        HalpCmcSpinLock;
extern KSPIN_LOCK        HalpCpeSpinLock;

//
// IA64 MCE Info structures to keep track of MCE features
// available on installed hardware.
//

HALP_MCA_INFO       HalpMcaInfo;
HALP_CMC_INFO       HalpCmcInfo;
HALP_CPE_INFO       HalpCpeInfo;
KERNEL_MCE_DELIVERY HalpMceKernelDelivery;
volatile ULONG      HalpOsMcaInProgress = 0;

//
// SAL_MC_SET_PARAMS.time_out
//

ULONGLONG HalpMcRendezTimeOut = HALP_DEFAULT_MC_RENDEZ_TIMEOUT;

//
// HalpProcessorMcaRecords:
//
// Number of MCA records pre-allocated per processor.
//

ULONGLONG HalpProcessorMcaRecords = HALP_DEFAULT_PROCESSOR_MCA_RECORDS;

//
// HalpProcessorInitRecords:
//
// Number of INIT records pre-allocated per processor.
//

ULONGLONG HalpProcessorInitRecords = HALP_DEFAULT_PROCESSOR_INIT_RECORDS;

//
// HalpMceLogsMaxCount:
//
// Maximum number of saved logs.
//

ULONG HalpMceLogsMaxCount = HALP_MCELOGS_MAXCOUNT;

//
// HAL Private Error Device GUIDs:
// [useful for kdexts]
//

ERROR_DEVICE_GUID HalpErrorProcessorGuid              = ERROR_PROCESSOR_GUID;
ERROR_DEVICE_GUID HalpErrorMemoryGuid                 = ERROR_MEMORY_GUID;
ERROR_DEVICE_GUID HalpErrorPciBusGuid                 = ERROR_PCI_BUS_GUID;
ERROR_DEVICE_GUID HalpErrorPciComponentGuid           = ERROR_PCI_COMPONENT_GUID;
ERROR_DEVICE_GUID HalpErrorSystemEventLogGuid         = ERROR_SYSTEM_EVENT_LOG_GUID;
ERROR_DEVICE_GUID HalpErrorSmbiosGuid                 = ERROR_SMBIOS_GUID;
ERROR_DEVICE_GUID HalpErrorPlatformSpecificGuid       = ERROR_PLATFORM_SPECIFIC_GUID;
ERROR_DEVICE_GUID HalpErrorPlatformBusGuid            = ERROR_PLATFORM_BUS_GUID;
ERROR_DEVICE_GUID HalpErrorPlatformHostControllerGuid = ERROR_PLATFORM_HOST_CONTROLLER_GUID;

//
// HAL Private Error Definitions:
// [useful for kdexts]
// Actually in this case, the typed pointers allow also the inclusion of the symbols definitions
// without the data structures sizes.
//

PERROR_MODINFO                  HalpPErrorModInfo;
PERROR_PROCESSOR_CPUID_INFO     HalpPErrorProcessorCpuIdInfo;
PERROR_PROCESSOR                HalpPErrorProcessor;
PERROR_PROCESSOR_STATIC_INFO    HalpPErrorProcessorStaticInfo;
PERROR_MEMORY                   HalpPErrorMemory;
PERROR_PCI_BUS                  HalpPErrorPciBus;
PERROR_PCI_COMPONENT            HalpPErrorPciComponent;
PERROR_SYSTEM_EVENT_LOG         HalpPErrorSystemEventLog;
PERROR_SMBIOS                   HalpPErrorSmbios;
PERROR_PLATFORM_SPECIFIC        HalpPErrorPlatformSpecific;
PERROR_PLATFORM_BUS             HalpPErrorPlatformBus;
PERROR_PLATFORM_HOST_CONTROLLER HalpPErrorPlatformHostController;

//
// MCA/CMC/CPE state catchers
//

ERROR_SEVERITY
HalpMcaProcessLog(
    PMCA_EXCEPTION  McaLog
    );

BOOLEAN
HalpPreAllocateMceTypeRecords(
    ULONG EventType,
    ULONG Number
    );

VOID
HalpMcaBugCheck(
    ULONG          McaBugCheckType,
    PMCA_EXCEPTION McaLog,
    ULONGLONG      McaAllocatedLogSize,
    ULONGLONG      Arg4
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,   HalpInitializeOSMCA)
#pragma alloc_text(INIT,   HalpAllocateMceStacks)
#pragma alloc_text(INIT,   HalpPreAllocateMceRecords)
#pragma alloc_text(INIT,   HalpPreAllocateMceTypeRecords)
#pragma alloc_text(PAGELK, HalpMcaHandler)
#pragma alloc_text(PAGELK, HalpMcaProcessLog)
#pragma alloc_text(PAGELK, HalpMcaBugCheck)
#pragma alloc_text(PAGELK, HalpGetErrLog)
#pragma alloc_text(PAGELK, HalpClrErrLog)
#pragma alloc_text(PAGE,   HalpGetMceInformation)
#endif // ALLOC_PRAGMA


BOOLEAN
HalpSaveEventLog(
    PSINGLE_LIST_ENTRY   HeadList,
    PERROR_RECORD_HEADER RecordHeader,
    ULONG                Tag,
    POOL_TYPE            PoolType,
    PKSPIN_LOCK          SpinLock
    )
{
    PSINGLE_LIST_ENTRY   entry, previousEntry;
    SIZE_T               logSize;
    PERROR_RECORD_HEADER savedLog;
    KIRQL                oldIrql;

    //
    // Allocate and Initialize the new entry
    //

    logSize = RecordHeader->Length;
    if ( !logSize ) {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpSaveEventLog: record length is zeroed.\n" ));
        return FALSE;
    }
    entry = (PSINGLE_LIST_ENTRY)ExAllocatePoolWithTag( PoolType, sizeof(*entry) + logSize, Tag );
    if ( entry == NULL )   {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpSaveEventLog: Event log allocation failed.\n" ));
        return FALSE;
    }
    entry->Next = NULL;
    savedLog = (PERROR_RECORD_HEADER)((ULONG_PTR)entry + sizeof(*entry));
    RtlCopyMemory( savedLog, RecordHeader, logSize );

    //
    // Insert the new entry with protection.
    //

    KeRaiseIrql( HIGH_LEVEL, &oldIrql );
    KiAcquireSpinLock( SpinLock );

    previousEntry = HeadList;
    while( previousEntry->Next != NULL )   {
        previousEntry = previousEntry->Next;
    }
    previousEntry->Next = entry;

    KiReleaseSpinLock( SpinLock );
    KeLowerIrql( oldIrql );

    return TRUE;

} // HalpSaveEventLog()

#define HalpSaveCorrectedMcaLog( _McaLog ) \
   HalpSaveEventLog( &HalpMcaInfo.CorrectedLogs, (PERROR_RECORD_HEADER)(_McaLog), 'CacM', NonPagedPool, &HalpMcaSpinLock )

NTSTATUS
HalpCheckForMcaLogs(
    VOID
    )
/*++
    Routine Description:
        This routine checks the FW early during boot if a MCA event log is present.
        The log is considered as "previous".

        This routine is called at phase 1 on BSP only, from HalpPreAllocateMceRecords().
        it is executed on the standard kernel stacks.

    Arguments:
        None

    Return Value:
        STATUS_NO_MEMORY if mca log allocation failed.
        STATUS_SUCCESS   otherwise, regardless of FW interfaces failures.
--*/

{
    NTSTATUS             status;
    PERROR_RECORD_HEADER log;

    log = ExAllocatePoolWithTag( NonPagedPool, HalpMcaInfo.Stats.MaxLogSize, 'PacM' );
    if ( !log ) {
        return( STATUS_NO_MEMORY );
    }

    status = HalpGetFwMceLog( MCA_EVENT, log, &HalpMcaInfo.Stats, HALP_FWMCE_DONOT_CLEAR_LOG );
    if ( status != STATUS_NOT_FOUND )   {
        //
        // Successful log collection or invalid record or unsuccessful FW Interface calls
        // are considered as a trigger for the MCA log consumers to collect them from the FW.
        //

        InterlockedIncrement( &HalpMcaInfo.Stats.McaPreviousCount );
    }

    ExFreePoolWithTag( log, 'PacM' );
    return( STATUS_SUCCESS );

} // HalpCheckForMcaLogs()

BOOLEAN
HalpPreAllocateMceTypeRecords(
    ULONG EventType,
    ULONG Number
    )
{
    SAL_PAL_RETURN_VALUES rv = {0};
    ULONGLONG             defaultEventRecords;
    PVOID                 log;
    SIZE_T                logSize;
    PHYSICAL_ADDRESS      physicalAddr;

    if ( (EventType != MCA_EVENT) && (EventType != INIT_EVENT) )    {
        ASSERTMSG( "HAL!HalpPreAllocateMceTypeRecords: unknown event type!\n", FALSE );
        return FALSE;
    }

    //
    // On BSP only, call SAL to get maximum size of EventType record
    //

    if ( Number == 0 )  {
        rv = HalpGetStateInfoSize( EventType );
        if ( !SAL_SUCCESSFUL(rv) )  {
            HalDebugPrint(( HAL_ERROR, "HAL!HalpPreAllocateMceTypeRecords: SAL_GET_STATE_INFO_SIZE failed...\n" ));
            return FALSE;
        }
        logSize = rv.ReturnValues[1];
    }

    if ( EventType == MCA_EVENT )   {

        if ( Number == 0 )  {
            // Update HalpMcaInfo, without protection. This is not required.
            HalpMcaInfo.Stats.MaxLogSize = (ULONG)logSize;
        }
        else  {
            logSize = (SIZE_T)HalpMcaInfo.Stats.MaxLogSize;
        }

       defaultEventRecords = HalpProcessorMcaRecords;

    }
    else {
        ASSERTMSG( "HAL!HalpPreAllocateMceTypeRecords: invalid event type!\n", EventType == INIT_EVENT );

        if ( Number == 0 )  {
            // Update HalpInitInfo, without protection. This is not required.
            HalpInitInfo.MaxLogSize = (ULONG)logSize;
        }
        else  {
            logSize = (SIZE_T)HalpInitInfo.MaxLogSize;
        }

       defaultEventRecords = HalpProcessorInitRecords;

    }

    // Determine size of allocation
    logSize = ROUND_TO_PAGES( (logSize * defaultEventRecords) );

    //
    // Allocate Event Records buffer
    //

    physicalAddr.QuadPart = 0xffffffffffffffffI64;
    log = MmAllocateContiguousMemory( logSize, physicalAddr );
    if ( log == NULL )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpPreAllocateMceTypeRecords: SAL %s Event Records allocation failed (0x%Ix)...\n",
                                   ( EventType == MCA_EVENT ) ? "MCA" : "INIT",
                                   logSize ));
        return FALSE;
    }

    //
    // Update KPCR entry.
    //
    {
       volatile KPCR * const pcr = KeGetPcr();
       PSAL_EVENT_RESOURCES eventResources;

       if ( EventType == MCA_EVENT )    {
           eventResources = pcr->OsMcaResourcePtr;
       }

       eventResources->EventPool     = log;
       eventResources->EventPoolSize = (ULONG) logSize;

    }

    return TRUE;

} // HalpPreAllocateMceTypeRecords()

BOOLEAN
HalpPreAllocateMceRecords(
    IN ULONG Number
    )
{
    NTSTATUS status;

    //
    // Pre-Allocate MCA records
    //

    if ( !HalpPreAllocateMceTypeRecords( MCA_EVENT , Number ) )   {
        return FALSE;
    }

    //
    // Check for MCA logs.
    // These might be logs related to previous boot sessions.
    //

    status = HalpCheckForMcaLogs();
    if ( !NT_SUCCESS( status ) )  {
        return FALSE;
    }

    return TRUE;

} // HalpPreAllocateMceRecords()

BOOLEAN
HalpAllocateMceStacks(
    IN ULONG Number
    )
{
    PHYSICAL_ADDRESS physicalAddr;
    PVOID            mem;
    PVOID            mcaStateDump, mcaBackStore, mcaStack;
    ULONGLONG        mcaStateDumpPhysical;
    ULONGLONG        mcaBackStoreLimit, mcaStackLimit;
    ULONG            length;

    //
    // Allocate MCA/INIT stacks
    //

    length = HALP_MCA_STATEDUMP_SIZE + HALP_MCA_BACKSTORE_SIZE + HALP_MCA_STACK_SIZE;
    physicalAddr.QuadPart = 0xffffffffffffffffI64;
    mem = MmAllocateContiguousMemory( length, physicalAddr );
    if ( mem == NULL )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpAllocateMceStacks: MCA State Dump allocation failed (0x%Ix)...\n",
                                   length ));
        return FALSE;
    }

    //
    // The layout in memory by increasing addresses is:
    //
    //   Bottom of stack
    //          .
    //          .
    //          .
    //   Initial Stack
    //   State Dump Area
    //          .
    //          .
    //   Initial BSP
    //          .
    //          .
    //          .
    //   BSP Limit
    //

    mcaStack = mem;
    mcaStackLimit = (ULONGLONG)mem + HALP_MCA_STACK_SIZE;

    mem = (PCHAR) mem + HALP_MCA_STACK_SIZE;
    mcaStateDump = mem;
    mcaStateDumpPhysical = MmGetPhysicalAddress(mem).QuadPart;


    mem = (PCHAR) mem + HALP_MCA_STATEDUMP_SIZE;
    mcaBackStore = mem;
    mcaBackStoreLimit = (ULONGLONG)mem + (ULONGLONG)(ULONG)HALP_MCA_BACKSTORE_SIZE;


    //
    // Update PCR MCA, INIT stacks
    //

    {
        volatile KPCR * const pcr = KeGetPcr();
        PSAL_EVENT_RESOURCES eventResources;

        eventResources = pcr->OsMcaResourcePtr;

        eventResources->StateDump = mcaStateDump;
        eventResources->StateDumpPhysical = mcaStateDumpPhysical;
        eventResources->BackStore = mcaBackStore;
        eventResources->BackStoreLimit = mcaBackStoreLimit;
        eventResources->Stack = (PCHAR) mcaStackLimit;
        eventResources->StackLimit = (ULONGLONG) mcaStack;

    }

    return TRUE;

} // HalpPreAllocateMceRecords()

//++
// Name: HalpInitializeOSMCA()
//
// Routine Description:
//
//      This routine registers MCA init's
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--

BOOLEAN
HalpInitializeOSMCA(
    IN ULONG Number
    )
{
    SAL_PAL_RETURN_VALUES rv = {0};
    ULONGLONG             gp_reg;

    //
    // Register SAL_MC_RendezVous parameters with SAL
    //

    rv = HalpSalSetParams(0, RendzType, IntrVecType, MC_RZ_VECTOR, HalpMcRendezTimeOut);
    if ( !SAL_SUCCESSFUL(rv) )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_MC_SET_PARAMS.rendezvous vector failed...\n" ));
        return FALSE;
    }

    //
    // Register WakeUp parameters with SAL
    //

    rv = HalpSalSetParams(0, WakeUpType, IntrVecType, MC_WKUP_VECTOR,0);
    if ( !SAL_SUCCESSFUL(rv) )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_MC_SET_PARAMS.wakeup vector failed...\n" ));
        return FALSE;
    }

    //
    // Allocate MCA, INIT stacks
    //

    if ( !HalpAllocateMceStacks( Number ) )   {
        return FALSE;
    }

    //
    // Pre-Allocate desired number of MCA,INIT records
    //

    HalpMcaInfo.KernelToken = (PVOID)(ULONG_PTR)HALP_KERNEL_TOKEN;
    if ( !HalpPreAllocateMceRecords( Number ) )   {
        return FALSE;
    }

    //
    // Initialize HAL private CMC, CPE structures.
    //

    if ( HalpFeatureBits & HAL_CMC_PRESENT ) {
        rv = HalpGetStateInfoSize( CMC_EVENT );
        if ( SAL_SUCCESSFUL( rv ) ) {
            if ( rv.ReturnValues[1] >= sizeof( ERROR_RECORD_HEADER ) )   {
                HalpCmcInfo.Stats.MaxLogSize  = (ULONG)rv.ReturnValues[1];
                HalpCmcInfo.KernelToken = (PVOID)(ULONG_PTR)HALP_KERNEL_TOKEN;
                HalpCmcInfo.KernelLogs.MaxCount = HalpMceLogsMaxCount;
                HalpCmcInfo.DriverLogs.MaxCount = HalpMceLogsMaxCount;
                HalpCmcInfo.Stats.PollingInterval = HAL_CMC_INTERRUPTS_BASED;
                HalpCmcInfo.ThresholdCounter = 0;

            } else  {
                
                HalDebugPrint(( HAL_ERROR, 
                                "HAL!HalpGetFeatureBits: Invalid max CMC log size from SAL\n" ));
                HalpFeatureBits &= ~HAL_CMC_PRESENT;
            }

        } else  {
            
            HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_GET_STATE_INFO_SIZE.CMC failed...\n" ));

            HalpFeatureBits &= ~HAL_CMC_PRESENT;
        }

    }

    if ( HalpFeatureBits & HAL_CPE_PRESENT ) {
        rv = HalpGetStateInfoSize( CPE_EVENT );
        if ( SAL_SUCCESSFUL( rv ) )   {
            if ( rv.ReturnValues[1] >= sizeof( ERROR_RECORD_HEADER ) )   {
                HalpCpeInfo.Stats.MaxLogSize = (ULONG)rv.ReturnValues[1];
                HalpCpeInfo.KernelToken = (PVOID)(ULONG_PTR)HALP_KERNEL_TOKEN;
                HalpCpeInfo.KernelLogs.MaxCount = HalpMceLogsMaxCount;
                HalpCpeInfo.DriverLogs.MaxCount = HalpMceLogsMaxCount;
                HalpCpeInfo.ThresholdCounter = 0;

            } else  {
                
                HalDebugPrint(( HAL_ERROR, 
                                "HAL!HalpGetFeatureBits: Invalid max CPE log size from SAL\n" ));
                HalpFeatureBits &= ~HAL_CPE_PRESENT;
            }
        } else {
            HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_GET_STATE_INFO_SIZE.CPE failed...\n" ));
            HalpFeatureBits &= ~HAL_CPE_PRESENT;
        }
    }

    //
    // Register OsMcaDispatch (OS_MCA) physical address with SAL
    //

    gp_reg = GetGp();
    rv = HalpSalSetVectors(0, MchkEvent, MmGetPhysicalAddress((fptr)(((PLabel*)HalpOsMcaDispatch1)->fPtr)), gp_reg,0);
    if ( !SAL_SUCCESSFUL(rv) )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_SET_VECTOR.MCA vector failed...\n" ));
        return FALSE;
    }

    //
    // Register OsInitDispatch physical address with SAL
    //

    rv = HalpSalSetVectors(0, InitEvent, MmGetPhysicalAddress((fptr)(((PLabel*)HalpOsInitDispatch)->fPtr)), gp_reg,0);
    if ( !SAL_SUCCESSFUL(rv) )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_SET_VECTOR.INIT vector failed...\n" ));
        return FALSE;
    }

    return TRUE;

} // HalpInitializeOSMCA()

//EndProc//////////////////////////////////////////////////////////////////////

VOID
HalpMcaBugCheck(
    ULONG          McaBugCheckType,
    PMCA_EXCEPTION McaLog,
    ULONGLONG      McaAllocatedLogSize,
    ULONGLONG      SalStatus
    )
//++
// Name: HalpMcaBugCheck()
//
// Routine Description:
//
//      This function is called to bugcheck the system in a case of a fatal MCA
//      or fatal FW interface errors. The OS must guarantee as much as possible
//      error containment in this path.
//      With the current implementation, this function should be only called from
//      the OS_MCA path. For other MCA specific wrappers of KeBugCheckEx, one should
//      HalpMcaKeBugCheckEx().
//
// Arguments On Entry:
//      ULONG          McaBugCheckType
//      PMCA_EXCEPTION McaLog
//      ULONGLONG      McaAllocatedLogSize
//      ULONGLONG      SalStatus
//
// Return:
//      None.
//
// Implementation notes:
//      This code CANNOT [as default rules - at least entry and through fatal MCAs handling]
//          - make any system call
//          - attempt to acquire any spinlock used by any code outside the MCA handler
//          - change the interrupt state.
//      Passing data to non-MCA code must be done using manual semaphore instructions.
//      This code should minimize the path and the global or memory allocated data accesses.
//      This code should only access MCA-namespace structures.
//      This code is called under the MP protection of HalpMcaSpinLock and with the flag
//      HalpOsMcaInProgress set.
//
//--
{

    if ( HalpOsMcaInProgress )   {

        //
        // Enable InbvDisplayString calls to make it through to bootvid driver.
        //

        if ( InbvIsBootDriverInstalled() ) {

            InbvAcquireDisplayOwnership();

            InbvResetDisplay();
            InbvSolidColorFill(0,0,639,479,4); // make the screen blue
            InbvSetTextColor(15);
            InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
            InbvEnableDisplayString(TRUE);     // enable display string
            InbvSetScrollRegion(0,0,639,479);  // set to use entire screen
        }

        HalDisplayString (MSG_MCA_HARDWARE_ERROR);
        HalDisplayString (MSG_HARDWARE_ERROR2);

//
// Thierry 09/2000:
//
//   - if desired, process the MCA log HERE...
//
//     and use HalDisplayString() to dump info for the field or hardware vendor.
//     The processing could be based on processor or platform independent record definitions.
//

        HalDisplayString( MSG_HALT );

        if ( HalpMcaInfo.NoBugCheck == 0 )  {

           KeBugCheckEx( MACHINE_CHECK_EXCEPTION, (ULONG_PTR)McaBugCheckType,
                                                  (ULONG_PTR)McaLog,
                                                  (ULONG_PTR)McaAllocatedLogSize,
                                                  (ULONG_PTR)SalStatus );
        }

    }

    if ( ((*KdDebuggerNotPresent) == FALSE) && ((*KdDebuggerEnabled) != FALSE) )    {
        KeEnterKernelDebugger();
    }

    while( TRUE ) {
          //
        ; // Simply sit here so the MCA HARDWARE ERROR screen does not get corrupted...
          //
    }

    // noreturn

} // HalpMcaBugCheck()

ERROR_SEVERITY
HalpMcaProcessLog(
    PMCA_EXCEPTION  McaLog
    )
//++
// Name: HalpMcaProcessLog()
//
// Routine Description:
//
//      This function is called to process the MCA event log in the OS_MCA path.
//
// Arguments On Entry:
//      PMCA_EXCEPTION McaLog - Pointer to the MCA event log.
//
// Return:
//      ERROR_SEVERITY
//
// Implementation notes:
//      This code CANNOT [as default rules]
//          - make any system call
//          - attempt to acquire any spinlock used by any code outside the MCA handler
//          - change the interrupt state.
//      Passing data to non-MCA code must be done using manual semaphore instructions.
//      This code should minimize the path and the global or memory allocated data accesses.
//      This code should only access MCA-namespace structures.
//      This code is called under the MP protection of HalpMcaSpinLock and with the flag
//      HalpOsMcaInProgress set.
//
//--
{
    ERROR_SEVERITY mcaSeverity;

    mcaSeverity = McaLog->ErrorSeverity;
    switch( mcaSeverity )    {

        case ErrorFatal:
            break;

        case ErrorRecoverable:
            //
            // Thierry - FIXFIX 08/2000:
            //
            ///////////////////////////////////////////////////////////////
            //
            //  Call to kernel supported recovery will be here....
            //
            ///////////////////////////////////////////////////////////////
            //
            // However, for now we do not recover so flag it as ErrorFatal.
            mcaSeverity = ErrorFatal;
            break;

        case ErrorCorrected:
        default:
            //
            // These ERRROR_SEVERITY values have no HAL MCA specific handling.
            // As specified by the SAL Specs July 2000, we should not get these values in this path.
            //
            break;
    }

    //
    // If OEM driver has registered an exception callback for MCA event,
    // call it here and save returned error severity value.
    //

    if ( HalpMcaInfo.DriverInfo.ExceptionCallback ) {
        mcaSeverity = HalpMcaInfo.DriverInfo.ExceptionCallback(
                                     HalpMcaInfo.DriverInfo.DeviceContext,
                                     McaLog );
    }

    //
    // Save corrected log for future kernel notification.
    //

    if ( (HalpMcaInfo.KernelDelivery) && (mcaSeverity == ErrorCorrected) ) {
        InterlockedIncrement( &HalpMcaInfo.Stats.McaCorrectedCount );
#if 0
//
// Thierry - 09/16/2000: ToBeDone.
//  Saving the corrected MCA log records requires careful rendez-vous configuration
//  handling, possible OS_MCA monarch selection, MCA logs (pre-)allocations and
//  special locking in case a consumer accesses the logs queue on another processor.
//
//  The kernel-WMI and/or OEM MCA driver notification is done in HalpMcaHandler().
//
        if ( !HalpSaveCorrectedMcaLog( McaLog ) )   {
            InterlockedIncrement( &HalpMcaInfo.CorrectedLogsLost );
        }
#endif // 0

        //
        //  The kernel-WMI and/or OEM MCA driver notification for corrected MCA event
        //  is done in HalpMcaHandler().
        //

    }

    //
    // Thierry 10/17/2000 BUGBUG
    //
    // The FW does not save the MCA log in NVRAM and we have no official date from Intel
    // when the SAL will be doing it.
    // So for now, return as ErrorFatal and let dump the log through the debugger.
    //
    // Before Sal Rev <ToBeDetermined>, the error logs were completely erroneous...
    //

    if ( HalpSalPalData.SalRevision.Revision < HALP_SAL_REVISION_MAX )  {
        return( ErrorFatal );
    }
    else    {
        return( mcaSeverity );
    }

} // HalpMcaProcessLog()

SAL_PAL_RETURN_VALUES
HalpMcaHandler(
    ULONG64 RendezvousState,
    PPAL_MINI_SAVE_AREA  Pmsa
    )
//++
// Name: HalpMcaHandler()
//
// Routine Description:
//
//      This is the OsMca handler for firmware uncorrected errors
//      It is our option to run this in physical or virtual mode.
//
// Arguments On Entry:
//      None.
//
// Conditions On Entry: 09/2000 implementation.
//      - PSR state: at least,
//          PSR.dt = 1, PSR.it = 1, PSR.rt = 1 - virtual mode.
//          PSR.ic = 1, PSR.i = 0              - Interruption resources collection enabled,
//                                               Interrupts off.
//          PSR.mc = 1                         - MCA masked for this processor.
//      - SalToOsHndOff initialized.
//      - s0 = MinStatePtr.
//      - s1 = IA64 PAL Processor State Parameter.
//      - s2 = PALE_CHECK return address.
//      - Processor registers state saved in myStateDump[] by osmcaProcStateDump().
//      - myStackFrame[0] = ar.rsc
//      - myStackFrame[1] = ar.pfs
//      - myStackFrame[2] = ar.ifs
//      - myStackFrame[3] = ar.bspstore
//      - myStackFrame[4] = ar.rnat
//      - myStackFrame[5] = ar.bsp - ar.bspstore
//      - ar.bspstore = myBspStore
//      - sp = &mySp[sizeof(mySp[])]
//
// Return:
//      rtn0=Success/Failure (0/!0)
//      rtn1=Alternate MinState Pointer if any else NULL
//
// Implementation notes:
//      This code CANNOT [as default rules - at least entry and through fatal MCAs handling]
//          - make any system call
//          - attempt to acquire any spinlock used by any code outside the MCA handler
//          - change the interrupt state.
//      Passing data to non-MCA code must be done using manual semaphore instructions.
//      This code should minimize the path and the global or memory allocated data accesses.
//      This code should only access MCA-namespace structures and should not access globals
//      until it is safe.
//
//--
{
    SAL_PAL_RETURN_VALUES rv;
    LONGLONG              salStatus;
    BOOLEAN               mcWakeUp;
    PMCA_EXCEPTION        mcaLog;
    ULONGLONG             mcaAllocatedLogSize;
    PSAL_EVENT_RESOURCES  mcaResources;
    KIRQL                 oldIrql;
    BOOLEAN               raisedIrql;

    volatile KPCR * const pcr = KeGetPcr();

    //
    // Acquire MCA spinlock protecting OS_MCA resources.
    //
    // Thierry 10/06/2000: FIXFIX.
    //   we will move this MP synchronization in HalpOsMcaDispatch after current discussions
    //   with Intel about MP MCA handling are completed.
    //   Expecting responses from Intel about these.
    //


    //
    // If we are running below MCA_LEVEL then we need to raise irql to
    // MCA_LEVEL.
    //
    if (KeGetCurrentIrql() < MCA_LEVEL)
    {
        KeRaiseIrql(MCA_LEVEL, &oldIrql);
        raisedIrql = TRUE;
    } else {
        raisedIrql = FALSE;
    }

    //
    // Enable interrupts while we spin on the MCA spinlock.  This will allow the
    // monarch processor to IPI us if it needs to.
    //
    HalpEnableInterrupts();
    HalpAcquireMcaSpinLock( &HalpMcaSpinLock );
    HalpDisableInterrupts();

    HalpOsMcaInProgress++;

    //
    // Save OsToSal minimum state
    //

    mcaResources = pcr->OsMcaResourcePtr;
    mcaResources->OsToSalHandOff.SalReturnAddress = mcaResources->SalToOsHandOff.SalReturnAddress;
    mcaResources->OsToSalHandOff.SalGlobalPointer = mcaResources->SalToOsHandOff.SalGlobalPointer;

    //
    // update local variables with pre-initialized MCA log data.
    //

    mcaLog = (PMCA_EXCEPTION)(mcaResources->EventPool);
    mcaAllocatedLogSize = mcaResources->EventPoolSize;
    if ( !mcaLog || !mcaAllocatedLogSize )  {
        //
        // The following code should never happen or the implementation of the HAL MCA logs
        // pre-allocation failed miserably. This would be a development error.
        //
        HalpMcaBugCheck( (ULONG_PTR)HAL_BUGCHECK_MCA_ASSERT, mcaLog,
                                                             mcaAllocatedLogSize,
                                                             (ULONGLONG)0 );
    }

    //
    // Get the MCA logs
    //

    salStatus = (LONGLONG)0;
    while( salStatus >= 0 )  {
        ERROR_SEVERITY errorSeverity;

        rv = HalpGetStateInfo( MCA_EVENT, mcaLog );
        salStatus = rv.ReturnValues[0];
        switch( salStatus )    {

            case SAL_STATUS_SUCCESS:
                errorSeverity = HalpMcaProcessLog( mcaLog );

                if ( errorSeverity == ErrorFatal )  {
                    //
                    // We are now going down with a MACHINE_CHECK_EXCEPTION.
                    // No return...
                    //
                    HalpMcaBugCheck( HAL_BUGCHECK_MCA_FATAL, mcaLog,
                                                             mcaAllocatedLogSize,
                                                             0 );
                } else {

                    //
                    // Ideally we would have recovered the error at this point.
                    // However we don't currently handle MCA error recovery
                    // yet.  Once we do then this "else clause" should be
                    // deleted.
                    //
                    HalpMcaBugCheck( HAL_BUGCHECK_MCA_NONFATAL, mcaLog,
                                                                mcaAllocatedLogSize,
                                                                0 );
                }

                rv = HalpClearStateInfo( MCA_EVENT );
                if ( !SAL_SUCCESSFUL(rv) )  {
                    //
                    // Current consideration for this implementation - 08/2000:
                    // if clearing the event fails, we assume that FW has a real problem;
                    // continuing will be dangerous. We bugcheck.
                    //
                    HalpMcaBugCheck( HAL_BUGCHECK_MCA_CLEAR_STATEINFO, mcaLog,
                                                                       mcaAllocatedLogSize,
                                                                       rv.ReturnValues[0] );
                }
                // SAL_STATUS_SUCCESS, SAL_STATUS_SUCCESS_MORE_RECORDS ... and
                // ErrorSeverity != ErrorFatal.

                //
                // Call the registered kernel handler.
                //
                // Thierry 08/2000 - FIXFIX:
                // The errorSeverity check is under comments. It should not be commented for the
                // final version. However, we wanted to have kernel notification if we are getting
                // log error severity != ErrorFatal or != ErrorRecoverable.

                if ( /* (errorSeverity == ErrorCorrected) && */
                     ( HalpMcaInfo.KernelDelivery || HalpMcaInfo.DriverInfo.DpcCallback ) ) {
                    InterlockedExchange( &HalpMcaInfo.DpcNotification, 1 );
                }
                break;

            case SAL_STATUS_NO_INFORMATION_AVAILABLE:
                //
                // The salStatus value will break the salStatus loop.
                //
                rv.ReturnValues[0] = SAL_STATUS_SUCCESS;
                break;

            case SAL_STATUS_SUCCESS_WITH_OVERFLOW:
            case SAL_STATUS_INVALID_ARGUMENT:
            case SAL_STATUS_ERROR:
            case SAL_STATUS_VA_NOT_REGISTERED:
            default: // Thierry 08/00: WARNING - SAL July 2000 - v2.90.
                     // default includes possible unknown positive salStatus values.
                HalpMcaBugCheck( HAL_BUGCHECK_MCA_GET_STATEINFO, mcaLog,
                                                                 mcaAllocatedLogSize,
                                                                 salStatus );
                break;
        }
    }

    //
    // If we get here then one of two things have happened.  Either the SAL
    // didn't return any records or we got a recoverable error, handled it, and
    // the HAL_BUGCHECK_MCA_NONFATAL bugcheck above in the SAL_STATUS_SUCCESS
    // case above has been removed.
    //
    // Once we add code to recover from MCAs and support returning to the SAL we
    // need to change this bugcheck so it is only called if we received no error
    // records in response to SAL_GET_STATEINFO.
    //
    HalpMcaBugCheck( HAL_BUGCHECK_MCA_NONFATAL, 0, 0, 0 );

    //
    // Currently 08/2000, we do not support the modification of the minstate.
    //

    mcaResources->OsToSalHandOff.MinStateSavePtr = mcaResources->SalToOsHandOff.MinStateSavePtr;
    mcaResources->OsToSalHandOff.Result          = rv.ReturnValues[0];

    //
    // If error was corrected and MCA non-monarch processors are in rendez vous,
    // we will have to wake them up.
    //

    mcWakeUp = ( (rv.ReturnValues[0] == SAL_STATUS_SUCCESS) &&
                 HalpSalRendezVousSucceeded( mcaResources->SalToOsHandOff ) );

    //
    // Release MCA spinlock protecting OS_MCA resources.
    //

    HalpOsMcaInProgress = 0;
    HalpReleaseMcaSpinLock( &HalpMcaSpinLock );

    if (raisedIrql)
    {
        KeLowerIrql(oldIrql);
    }

    //
    // If required, let's wake MCA non-monarch processors up.
    //

    if ( mcWakeUp )  {
        HalpMcWakeUp();
    }

    return( rv );

} // HalpMcaHandler()

//++
// Name: HalpGetErrLogSize()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_GET_STATE_INFO_SIZE
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Event Type (MCA,INIT,CMC,CPE)
//
// Returns
//              rtn0=Success/Failure (0/!0)
//              rtn1=Size
//--
SAL_PAL_RETURN_VALUES
HalpGetErrLogSize(  ULONGLONG Res,
                    ULONGLONG eType
                 )
{
    SAL_PAL_RETURN_VALUES rv = {0};
    HalpSalCall(SAL_GET_STATE_INFO_SIZE, eType, 0,0,0,0,0,0, &rv);

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpGetErrLog()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_GET_STATE_INFO
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Event Type (MCA,INIT,CMC)
//              arg3 = pBuffer
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES
HalpGetErrLog(  ULONGLONG  Res,
                ULONGLONG  eType,
                ULONGLONG* pBuff
             )
{
    SAL_PAL_RETURN_VALUES rv={0};

    HalpSalCall(SAL_GET_STATE_INFO, eType, 0, (ULONGLONG)pBuff, 0,0,0,0, &rv);

    //
    // Regardless of the call success or failure, fix the record to store
    // the processor number the SAL_PROC was executed on.
    // This feature is requested by WMI.
    //

    HalpSetFwMceLogProcessorNumber( (PERROR_RECORD_HEADER)pBuff );

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpClrErrLog()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_CLEAR_STATE_INFO
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Event Type (MCA,INIT,CMC,CPE)
//
//      Success/Failure (0/!0)
//--

SAL_PAL_RETURN_VALUES
HalpClrErrLog(  ULONGLONG Res,
                ULONGLONG eType
             )
{
    SAL_PAL_RETURN_VALUES rv={0};

    HalpSalCall( SAL_CLEAR_STATE_INFO, eType, 0,0,0,0,0,0, &rv );

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpSalSetParams()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_MC_SET_PARAMS
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Parameter Type (rendz. or wakeup)
//              arg2 = Event Type (interrupt/semaphore)
//              arg3 = Interrupt Vector or Memory Address
//              arg4 = Timeout value for rendezvous
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES
HalpSalSetParams(ULONGLONG Res,
                ULONGLONG pType,
                ULONGLONG eType,
                ULONGLONG VecAdd,
                ULONGLONG tValue)
{
    SAL_PAL_RETURN_VALUES rv={0};

    HalpSalCall(SAL_MC_SET_PARAMS, pType, eType, VecAdd,tValue,0,0,0,&rv);

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpSalSetVectors()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_SET_VECTORS
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Event Type (MCA, INIT..)
//              arg2 = Physical Address of handler
//              arg3 = gp
//              arg4 = length of event handler in bytes
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES
HalpSalSetVectors(  ULONGLONG Res,
                    ULONGLONG eType,
                    PHYSICAL_ADDRESS Addr,
                    ULONGLONG gpValue,
                    ULONGLONG szHndlr)
{
    SAL_PAL_RETURN_VALUES rv={0};

    if ( eType == InitEvent )   {
        //
        // Thierry 08/2000:
        //    Current implementation assumes that OS decides the monarch inside OS_INIT.
        //    This implies handler_2, gp_2, length_2 are identical to handler_1, gp_1, length_1.
        //

        HalpSalCall(SAL_SET_VECTORS, eType, (ULONGLONG)Addr.QuadPart, gpValue, szHndlr,
                                            (ULONGLONG)Addr.QuadPart, gpValue, szHndlr, &rv);
    }
    else  {
        HalpSalCall(SAL_SET_VECTORS, eType, (ULONGLONG)Addr.QuadPart, gpValue,szHndlr,0,0,0,&rv);
    }

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////


//++
// Name: HalpSalRendz()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_MC_RENDEZ
//
// Arguments On Entry:
//              arg0 = Reserved
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES
HalpSalRendz(void)
{
    SAL_PAL_RETURN_VALUES rv={0};

    HalpSalCall(SAL_MC_RENDEZ, 0, 0, 0,0,0,0,0,&rv);

    return(rv);
}

VOID
HalpMcWakeUp(
    VOID
    )

/*++

Routine Description:

   This function does IPI to wakeup the MC non-monarch processors.

Arguments:

   None.

Return Value:

   None.

Remarks:

   This function is assumed to be executed on the MC monarch processor.

--*/

{
    USHORT  LogicalCpu;
    USHORT  ProcessorID;
    USHORT  monarchID;

    //
    // Scan the processor set and request an interprocessor interrupt on
    // each of the specified targets.
    //

    monarchID = (USHORT)PCR->HalReserved[PROCESSOR_ID_INDEX];

    for (LogicalCpu = 0; LogicalCpu < HalpMpInfo.ProcessorCount; LogicalCpu++) {

        //
        // Only IPI processors that are started.
        //

        if (HalpActiveProcessors & (1 << HalpProcessorInfo[LogicalCpu].NtProcessorNumber)) {

            ProcessorID = HalpProcessorInfo[LogicalCpu].LocalApicID;

            //
            // Request interprocessor interrupt on target physicalCpu.
            //

            if ( ProcessorID != monarchID ) {
                HalpSendIPI(ProcessorID, MC_WKUP_VECTOR);
            }
        }
    }

} // HalpMcWakeUp()

VOID
HalpCMCEnable(
    VOID
    )
/*++

Routine Description:

    This routine sets the processor CMCV register with CMCI_VECTOR.

Arguments:

    None.

Return Value:

    None.

--*/
{

    if ( HalpFeatureBits & HAL_CMC_PRESENT )    {
        HalpWriteCMCVector( CMCI_VECTOR );
    }
    return;

} // HalpCMCEnable()

VOID
HalpCMCDisable(
    VOID
    )
/*++
    Routine Description:
        This routine resets the processor CMCV register.

    Arguments:
        None

    Return Value:
        None
--*/
{

    HalpWriteCMCVector( 0x10000ui64 );
    return;

} // HalpCMCDisable()

NTSTATUS
HalpGenerateCMCInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is used for testing CMC processing.  It is called indirectly
    using HalSetSystemInformation.HalGenerateCmcInterrupt.  The expectation is
    that the caller has done whatever processing to simulate the error that the
    SAL expects prior to calling this function.

Arguments:

    CmcVector: CMC Vector value.

Value:

    STATUS_SUCCESS

--*/
{

    if (HalpFeatureBits & HAL_CMC_PRESENT) {

        HalpSendIPI( (USHORT)PCR->HalReserved[PROCESSOR_ID_INDEX],
                     CMCI_VECTOR | DELIVER_FIXED);

        return STATUS_SUCCESS;
    }

    return STATUS_NOT_SUPPORTED;
}

ULONG_PTR
HalpSetCMCVector(
    IN ULONG_PTR CmcVector
    )
/*++

Routine Description:

    This routine sets the processor CMCV register with specified vector.
    This function is the broadcast function for HalpCMCDisableForAllProcessors().

Arguments:

    CmcVector: CMC Vector value.

Value:

    STATUS_SUCCESS

--*/
{

    HalpWriteCMCVector( (ULONG64)CmcVector );

    return((ULONG_PTR)(ULONG)(STATUS_SUCCESS));

} // HalpSetCmcVector()

VOID
HalpCMCDisableForAllProcessors(
    VOID
    )
/*++

Routine Description:

    This routine disables processor CMC on every processor in the host configuration
    by executing HalpSetCmcVector( 0ui64 ) on every processor in a synchronous manner.

Arguments:

    None.

Value:

    None.

--*/
{
    //
    // Can not do an IPI if the processors are above IPI level such
    // as we are in the kernel debugger.
    //

    if (KeGetCurrentIrql() < IPI_LEVEL) {
        (VOID)KiIpiGenericCall( HalpSetCMCVector, (ULONG_PTR)0x10000ui64 );
    } else {
        HalpSetCMCVector(0x10000ui64);
    }

    return;

} // HalpCMCDisableForAllProcessors()

VOID
HalpCMCIHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:
        Processor Interrupt routine for CMC interrupts.

    Arguments:
        TrapFrame - Captured trap frame address.

    Return Parameters:
        None.

    Notes:
        Thierry 08/2000:
            This function does not do much, it flags the PCR InOsCmc field
            and calls the second-level handler: HalpCmcHandler().
            However, this was implmented this way so this function abstracts the
            standard interrupts resources from the purely CMC processing in HalpCmcHandler().

--*/

{
     volatile KPCR * const pcr = KeGetPcr();

     pcr->InOsCmc = TRUE;

     HalpCmcHandler();

     pcr->InOsCmc = FALSE;
     return;

} // HalpCMCIHandler()

VOID
HalpCmcProcessLog(
    PCMC_EXCEPTION CmcLog
    )
/*++

    Routine Description:
        This function does a simple processing check a IA64 CMC log.

    Arguments:
        CmcLog - Provides CMC log address

    Return Parameters:
        None.

    Notes:
        Currently simply checking and outputing log contents for checked hal only.

--*/

{

#if DBG
    //
    // Simple log processing for first debugging...
    //

    GUID                  processorDeviceGuid = ERROR_PROCESSOR_GUID;
    BOOLEAN               processorDeviceFound;
    PERROR_RECORD_HEADER  header = (PERROR_RECORD_HEADER)CmcLog;
    PERROR_SECTION_HEADER section, sectionMax;

    if ( header->ErrorSeverity != ErrorCorrected )  {
        HalDebugPrint(( HAL_ERROR,
                        "HAL!HalpCmcProcessLog: CMC record with severity [%d] != corrected!!!\n",
                        header->ErrorSeverity ));
    }
    //
    // SAL spec BUGBUG 08/2000: we should have put the length of the header in the definition.
    //                          Same for section header.
    //

    processorDeviceFound = FALSE;
    section    = (PERROR_SECTION_HEADER)((ULONG_PTR)header + sizeof(*header));
    sectionMax = (PERROR_SECTION_HEADER)((ULONG_PTR)header + header->Length);
    while( section < sectionMax )   {
        if ( IsEqualGUID( &section->Guid, &processorDeviceGuid ) )  {
            PERROR_PROCESSOR processorRecord = (PERROR_PROCESSOR)section;
            processorDeviceFound = TRUE;
            //
            // Minimum processing here. This will enhance with testing and most common
            // occurences.
            //

            if ( processorRecord->Valid.StateParameter )    {
                ULONGLONG stateParameter = processorRecord->StateParameter.StateParameter;

                //
                // At any time more than one error could be valid
                //

                if((stateParameter >> ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_SHIFT) &
                                      ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_MASK) {
                    //
                    // cache error
                    //
                    HalDebugPrint(( HAL_INFO,
                                    "HAL!HalpCmcProcessLog: Corrected Processor CACHE Machine Check error\n" ));

                }
                if((stateParameter >> ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_SHIFT) &
                                      ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_MASK) {
                    //
                    // tlb error
                    //
                    HalDebugPrint(( HAL_INFO,
                                    "HAL!HalpCmcProcessLog: Corrected Processor TLB Machine Check error\n" ));
                }
                if((stateParameter >> ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_SHIFT) &
                                      ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_MASK) {
                    //
                    // bus error
                    //
                    HalDebugPrint(( HAL_INFO,
                                    "HAL!HalpCmcProcessLog: Corrected Processor BUS Machine Check error\n" ));
                }
                if((stateParameter >> ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_SHIFT) &
                                      ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_MASK) {
                    //
                    // unknown error
                    //
                    HalDebugPrint(( HAL_INFO,
                                    "HAL!HalpCmcProcessLog: Corrected Processor UNKNOWN Machine Check error\n" ));
                }
            }
        }
    }
    if ( !processorDeviceFound )    {
        HalDebugPrint(( HAL_ERROR,
                        "HAL!HalpCmcProcessLog: CMC log without processor device record!!!\n"));
    }

#endif // DBG

    return;

} // HalpCmcProcessLog()

//++
// Name: HalpCmcHandler()
//
// Routine Description:
//
//      This is the second level CMC Interrupt Handler for FW corrected errors.
//
// Arguments On Entry:
//      None.
//
// Return.
//      None.
//
// Notes:
//      This function calls the kernel notification and inserts the OEM CMC driver dpc if
//      registered.
//      Accessing the CMC logs at this level could be inacceptable because of the possible
//      large size of the logs and the time required to collect them.
//      The collection of the logs is delayed until the work item calls
//      HalQuerySystemInformation.HalCmcLogInformation.
//--

VOID
HalpCmcHandler(
   VOID
   )
{

    LARGE_INTEGER CurrentTime;

    //
    // Internal housekeeping.
    //

    InterlockedIncrement( &HalpCmcInfo.Stats.CmcInterruptCount );

    //
    // Notify the kernel if registered.
    //

    if ( HalpCmcInfo.KernelDelivery ) {
        if ( !HalpCmcInfo.KernelDelivery( HalpCmcInfo.KernelToken, CmcAvailable, NULL ) ) {
            InterlockedIncrement( &HalpCmcInfo.Stats.KernelDeliveryFails );
        }
    }

    //
    // Notify the OEM CMC driver if registered.
    //

    if ( HalpCmcInfo.DriverInfo.DpcCallback )   {
        if ( !KeInsertQueueDpc( &HalpCmcInfo.DriverDpc, NULL, NULL ) )  {
            InterlockedIncrement( &HalpCmcInfo.Stats.DriverDpcQueueFails );
        }
    }

    //
    // Now check if we are receiving CMC more frequently than our
    // threshold and if so call kernel to switch to polled mode
    //
    if (HalpCmcInfo.ThresholdMaximum != 0)
    {
        CurrentTime = KeQueryPerformanceCounter(NULL);

        KiAcquireSpinLock(&HalpCmcSpinLock);
        if (HalpCmcInfo.Stats.PollingInterval == HAL_CMC_INTERRUPTS_BASED)
        {
            if ( (CurrentTime.QuadPart - HalpCmcInfo.LastTime.QuadPart) < HalpCmcInfo.ThresholdTime.QuadPart)
            {
                if (++HalpCmcInfo.ThresholdCounter > HalpCmcInfo.ThresholdMaximum)
                {
                    //
                    // We have crossed the threshold so we need to
                    // downgrade to polling mode. We switch down to polling
                    // every 60 seconds as per the Intel Itanium Error
                    // Handling guide
                    //
                    HalpCmcInfo.Stats.PollingInterval = HALP_CMC_DEFAULT_POLLING_INTERVAL;
                    KiReleaseSpinLock(&HalpCmcSpinLock);

                    HalpCMCDisableForAllProcessors();

                    if (HalpCmcInfo.KernelDelivery != NULL) {

                        HalpCmcInfo.KernelDelivery( HalpCmcInfo.KernelToken,
                                                    CmcSwitchToPolledMode,
                                                    (PVOID)UlongToPtr(HalpCmcInfo.Stats.PollingInterval) );
                    }
                } else {
                    KiReleaseSpinLock(&HalpCmcSpinLock);
                }
            } else {
                HalpCmcInfo.LastTime = CurrentTime;
                HalpCmcInfo.ThresholdCounter = 0;
                KiReleaseSpinLock(&HalpCmcSpinLock);
            }
        } else {
            KiReleaseSpinLock(&HalpCmcSpinLock);
        }
    }

} // HalpCmcHandler()

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpCpeHandler()
//
// Routine Description:
//
//      This is the second level CPE Interrupt Handler for Platform corrected errors.
//
// Arguments On Entry:
//      None.
//
// Return.
//      None.
//
// Notes:
//      This function calls the kernel notification and inserts the OEM CPE driver dpc if
//      registered.
//      Accessing the CPE logs at this level could be inacceptable because of the possible
//      large size of the logs and the time required to collect them.
//      The collection of the logs is delayed until the work item calls
//      HalQuerySystemInformation.HalCpeLogInformation.
//--

VOID
HalpCpeHandler(
   VOID
   )
{
    LARGE_INTEGER CurrentTime;
    KIRQL Irql;

    //
    // Internal housekeeping.
    //

    InterlockedIncrement( &HalpCpeInfo.Stats.CpeInterruptCount );

    //
    // Disable further CPE interrupts.  We have to do this now because WMI
    // doesn't call SAL_GET_STATE_INFO until much later and the SAL routine
    // is what actually resets the LEVEL triggered interrupt source.
    //
    // We will reenable interrupts on the way back out of the HalpClrErrLog
    // call.
    //
    HalpCPEDisable();

    //
    // Notify the kernel if registered.
    //

    if ( HalpCpeInfo.KernelDelivery ) {
        if ( !HalpCpeInfo.KernelDelivery( HalpCpeInfo.KernelToken, CpeAvailable, NULL ) ) {
            InterlockedIncrement( &HalpCpeInfo.Stats.KernelDeliveryFails );
        }
    }

    //
    // Notify the OEM CPE driver if registered.
    //

    if ( HalpCpeInfo.DriverInfo.DpcCallback )   {
        if ( !KeInsertQueueDpc( &HalpCpeInfo.DriverDpc, NULL, NULL ) )  {
            InterlockedIncrement( &HalpCpeInfo.Stats.DriverDpcQueueFails );
        }
    }


    //
    // Now check if we are receiving Cpe more frequently than our
    // threshold and if so call kernel to switch to polled mode
    //
    if (HalpCpeInfo.ThresholdMaximum != 0)
    {
        CurrentTime = KeQueryPerformanceCounter(NULL);

        KiAcquireSpinLock(&HalpCpeSpinLock);
        if (HalpCpeInfo.Stats.PollingInterval == HAL_CPE_INTERRUPTS_BASED)
        {
            if ( (CurrentTime.QuadPart - HalpCpeInfo.LastTime.QuadPart) < HalpCpeInfo.ThresholdTime.QuadPart)
            {
                if (++HalpCpeInfo.ThresholdCounter > HalpCpeInfo.ThresholdMaximum)
                {
                    //
                    // We have crossed the threshold so we need to
                    // downgrade to polling mode. We switch down to polling
                    // every 60 seconds as per the Intel Itanium Error
                    // Handling guide
                    //
                    HalpCpeInfo.Stats.PollingInterval = HALP_CPE_DEFAULT_POLLING_INTERVAL;
                    KiReleaseSpinLock(&HalpCpeSpinLock);

                    if (HalpCpeInfo.KernelDelivery != NULL) {

                        HalpCpeInfo.KernelDelivery( HalpCpeInfo.KernelToken,
                                                    CpeSwitchToPolledMode,
                                                    (PVOID)UlongToPtr(HalpCpeInfo.Stats.PollingInterval) );
                    }
                } else {
                    KiReleaseSpinLock(&HalpCpeSpinLock);
                }

            } else {
                HalpCpeInfo.LastTime = CurrentTime;
                HalpCpeInfo.ThresholdCounter = 0;
                KiReleaseSpinLock(&HalpCpeSpinLock);
            }
        } else {
            KiReleaseSpinLock(&HalpCpeSpinLock);
        }
    }

} // HalpCpeHandler()

//EndProc//////////////////////////////////////////////////////////////////////

VOID
HalpMcRzHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:


    Arguements:


    Return Parameters:


--*/

{
    SAL_PAL_RETURN_VALUES rv={0};
    HalpDisableInterrupts();
    rv=HalpSalRendz();
    HalpEnableInterrupts();
    // do any Isr clean up and re-enable the interrupts & MC's

   return;

}

//EndProc//////////////////////////////////////////////////////////////////////


VOID
HalpMcWkupHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:


    Arguements:


    Return Parameters:


--*/

{

    return;
}

//EndProc//////////////////////////////////////////////////////////////////////

VOID
HalpCPEIHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:
        Processor Interrupt routine for CPE interrupts.

    Arguments:
        TrapFrame - Captured trap frame address.

    Return Parameters:
        None.

    Notes:
        Thierry 08/2000:
            This function does not do much, it flags the PCR InOsCpe field
            and calls the second-level handler: HalpCpeHandler().
            However, this was implmented this way so this function abstracts the
            standard interrupts resources from the purely CPE processing in HalpCpeHandler().

--*/

{
     volatile KPCR * const pcr = KeGetPcr();

     pcr->InOsCpe = TRUE;

     HalpCpeHandler();

     pcr->InOsCpe = FALSE;
     return;

} // HalpCPEIHandler()

VOID
HalpCPEEnable (
    VOID
    )

/*++

Routine Description:

    This routine sets the default HAL CPE handling regardless of the user specified
    registry setting. It enables the supported Platform Interrupt sources and
    exposes the initial interrupt/polling based mode used for CPE.

    The user specified registry setting is handled via HalpMcaInit() at the end of
    phase 1.

Arguments:

    None.

Return Parameters:

    None.

Implementation Notes:

    The following implementation assumes that this code is executed on BSP.

--*/

{
    ULONG i;

    if ( HalpFeatureBits & HAL_CPE_PRESENT )    {

        ULONG maxCPE = HalpMaxCPEImplemented;

        if ( maxCPE )   {
            //
            // Pick up the information from HalpCPEIntIn, HalpCPEDestination, HalpCPEVectorFlags,
            // HalpCPEIoSapicVector.
            //

            for (i=0 ; i != maxCPE; i++ ) {
                HalpEnableRedirEntry( HalpCPEIntIn[i] );
            }

            //
            // Initialize the remaining fields of HAL private CPE info structure.
            //

            HalpCpeInfo.Stats.PollingInterval = HAL_CPE_INTERRUPTS_BASED;

        }
        else  {

            //
            // We will implement Polling model.
            //

            HalpCpeInfo.Stats.PollingInterval = HALP_CPE_DEFAULT_POLLING_INTERVAL;

        }

    }
    else  {

        HalpCpeInfo.Stats.PollingInterval = HAL_CPE_DISABLED;

    }

} // HalpCPEEnable()

VOID
HalpCPEDisable (
    VOID
    )

/*++

Routine Description:

    This routine disables the SAPIC Platform Interrupt Sources.
    Note that if HalpMaxCPEImplemented is 0, the function does nothing.

Arguments:

    None.

Return Parameters:

    None.

--*/

{
    //
    // Pick up the information from HalpCPEIntIn, HalpCPEDestination, HalpCPEVectorFlags,
    // HalpCPEIoSapicVector

    ULONG i;

    for (i=0; i < HalpMaxCPEImplemented; i++) {
        HalpDisableRedirEntry(HalpCPEIntIn[i]);
    }

} // HalpCPEDisable()

VOID
HalpMCADisable(
    VOID
    )
{
   PHYSICAL_ADDRESS NULL_PHYSICAL_ADDRESS = {0};
   SAL_PAL_RETURN_VALUES rv = {0};
   char Lid;
   ULONGLONG gp_reg = GetGp();

   // Disable CMCs
   HalpCMCDisableForAllProcessors();

   // Disable CPE Interrupts
   HalpCPEDisable();

   //DeRegister Rendez. Paramters with SAL

#define NULL_VECTOR 0xF

   rv = HalpSalSetParams(0,RendzType, IntrVecType, NULL_VECTOR, HalpMcRendezTimeOut );

   // Deregister WakeUp parameters with SAL

   rv=HalpSalSetParams(0, WakeUpType, IntrVecType, NULL_VECTOR,0);

   // Deregister OsMcaDispatch (OS_MCA) physical address with SAL
   rv=HalpSalSetVectors(0, MchkEvent, NULL_PHYSICAL_ADDRESS, gp_reg,0);

   // Deregister OsInitDispatch physical address with SAL
   rv=HalpSalSetVectors(0, InitEvent, NULL_PHYSICAL_ADDRESS, gp_reg,0);

} // HalpMCADisable()

NTSTATUS
HalpGetMceInformation(
    PHAL_ERROR_INFO ErrorInfo,
    PULONG          ErrorInfoLength
    )
/*++
    Routine Description:
        This routine is called by HaliQuerySystemInformation for the HalErrorInformation class.

    Arguments:
        ErrorInfo : pointer to HAL_ERROR_INFO structure.

        ErrorInfoLength : size of the valid memory structure pointed by ErrorInfo.

    Return Value:
        STATUS_SUCCESS if successful
        error status otherwise
--*/
{
    NTSTATUS status;
    ULONG    cpePollingInterval;

    PAGED_CODE();

    ASSERT( ErrorInfo );
    ASSERT( ErrorInfoLength );

    //
    // Backward compatibility only.
    //

    if ( !ErrorInfo->Version || ( ErrorInfo->Version > HAL_ERROR_INFO_VERSION ) ) {
        return( STATUS_REVISION_MISMATCH );
    }

    //
    // Zero Reserved field.
    //

    ErrorInfo->Reserved                = 0;

    //
    // Collect MCA info under protection if required.
    //

    ErrorInfo->McaMaxSize              = HalpMcaInfo.Stats.MaxLogSize;
    ErrorInfo->McaPreviousEventsCount  = HalpMcaInfo.Stats.McaPreviousCount;
    ErrorInfo->McaCorrectedEventsCount = HalpMcaInfo.Stats.McaCorrectedCount;    // approximation.
    ErrorInfo->McaKernelDeliveryFails  = HalpMcaInfo.Stats.KernelDeliveryFails;  // approximation.
    ErrorInfo->McaDriverDpcQueueFails  = HalpMcaInfo.Stats.DriverDpcQueueFails;  // approximation.
    ErrorInfo->McaReserved             = 0;

    //
    // Collect CMC info under protection if required.
    //

    ErrorInfo->CmcMaxSize              = HalpCmcInfo.Stats.MaxLogSize;
    ErrorInfo->CmcPollingInterval      = HalpCmcInfo.Stats.PollingInterval;
    ErrorInfo->CmcInterruptsCount      = HalpCmcInfo.Stats.CmcInterruptCount;    // approximation.
    ErrorInfo->CmcKernelDeliveryFails  = HalpCmcInfo.Stats.KernelDeliveryFails;  // approximation.
    ErrorInfo->CmcDriverDpcQueueFails  = HalpCmcInfo.Stats.DriverDpcQueueFails;  // approximation.

    HalpAcquireCmcMutex();
    ErrorInfo->CmcGetStateFails        = HalpCmcInfo.Stats.GetStateFails;
    ErrorInfo->CmcClearStateFails      = HalpCmcInfo.Stats.ClearStateFails;
    ErrorInfo->CmcLogId                = HalpCmcInfo.Stats.LogId;
    HalpReleaseCmcMutex();

    ErrorInfo->CmcReserved             = 0;

    //
    // Collect CPE info under protection if required.
    //

    ErrorInfo->CpeMaxSize              = HalpCpeInfo.Stats.MaxLogSize;
    ErrorInfo->CpePollingInterval      = HalpCpeInfo.Stats.PollingInterval;

    ErrorInfo->CpeInterruptsCount      = HalpCpeInfo.Stats.CpeInterruptCount;    // approximation.
    ErrorInfo->CpeKernelDeliveryFails  = HalpCpeInfo.Stats.KernelDeliveryFails;  // approximation.
    ErrorInfo->CpeDriverDpcQueueFails  = HalpCpeInfo.Stats.DriverDpcQueueFails;  // approximation.

    HalpAcquireCpeMutex();
    ErrorInfo->CpeGetStateFails        = HalpCpeInfo.Stats.GetStateFails;
    ErrorInfo->CpeClearStateFails      = HalpCpeInfo.Stats.ClearStateFails;
    ErrorInfo->CpeLogId                = HalpCpeInfo.Stats.LogId;
    HalpReleaseCpeMutex();

    // CpeInterruptSources: Number of SAPIC Platform Interrup Sources supported by HAL.
    ErrorInfo->CpeInterruptSources     = HalpMaxCPEImplemented;

    //
    // Update KernelTokens
    //

    ErrorInfo->McaKernelToken          = (ULONGLONG) HalpMcaInfo.KernelToken;
    ErrorInfo->CmcKernelToken          = (ULONGLONG) HalpCmcInfo.KernelToken;
    ErrorInfo->CpeKernelToken          = (ULONGLONG) HalpCpeInfo.KernelToken;

    ErrorInfo->KernelReserved[3]       = (ULONGLONG) 0;

    *ErrorInfoLength = sizeof(*ErrorInfo);

    return( STATUS_SUCCESS );

} // HalpGetMceInformation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\osmchk.s ===
//###########################################################################
//**
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/osmchk.s_v   2.1   05 Mar 1999 12:59:42   smariset  $
// $Log:   I:/DEVPVCS/OSMCA/osmchk.s_v  $
//
//   Rev 2.0   Dec 11 1998 11:42:18   khaw
//Post FW 0.5 release sync-up
//
//   Rev 1.4   12 Oct 1998 14:05:20   smariset
//gp fix up work around
//
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OSMCHK.ASM - Merced OS Machine Check Abort Dispatcher
//
// Description:
//    Merced OS Machine Check Abort Stub to OSMCA "C" frame work.  If
//    we find a TLB related error, we cannot switch to virtual mode in
//    the OS.  All TLB related errors will need system reboot after 
//    storing the errors to a persistence storage media (HD or Flash).
//
//      HalpOsMcaDispatch               - Main
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//
#include "ksia64.h"
#include "fwglobal.h"

        GLOBAL_FUNCTION(HalpOsMcaDispatch)
        GLOBAL_FUNCTION(HalpMCAEnable)
        GLOBAL_FUNCTION(HalpMcaHandler)
        GLOBAL_FUNCTION(HalpAcquireMcaSpinLock)
        GLOBAL_FUNCTION(HalpReleaseMcaSpinLock)

        .text
//++
// Name: HalpOsMcaDispatch()
// 
// Routine Description:
//
//      This is the OS call back handler, which is only exported to the SAL for call back 
//      during MCA errors. This handler will dispatch to the appropriate MCA procedure. 
//
//      Sets up virtual->physical address translation
//      0x00100000->0x00100000 in dtr1/itr1 for OS_MCA. 
//      
// Arguments:
//
//      None
//
// On entry:
//
//      This function is called:
//          - in physical mode for uncorrected or correctable MCA events,
//          - RSE enforced in lazy mode,
//          - Processor resources:
//      PSR.dt = 0, PSR.it = 0, PSR.rt = 0 - Physical mode.
//      PSR.ic = 0, PSR.i  = 0             - Interrupt resources collection and interrupt disabled.
//      PSR.mc = 1                         - Machine Checks masked
//      PSR.mfl = 0                        - low fp disabled.
//      GR1  : OS_MCA Global Pointer (GP) registered by OS: OS's GP.
//      GR2-7: Unspecified.
//      GR8  : Physical address of the PAL_PROC entrypoint.
//      GR9  : Physical address of the SAL_PROC entrypoint.
//      GR10 : Physical address value of the SAL Global Pointer: SAL's GP.
//      GR11 : Rendezvous state information, defined as:
//                0 - Rendezvous of other processors was not required by 
//                    PAL_CHECK and as such was not done.
//                1 - All other processors in the system were successfully 
//                    rendezvous using MC_RENDEZVOUS interrupt.
//                2 - All other processors in the system were successfully
//                    rendezvous using a combination of MC_RENDEZVOUS 
//                    interrupt and INIT.
//               -1 - Rendezvous of other processors was required by PAL 
//                    but was unsuccessful.
//      GR12 : Return address to a location within SAL_CHECK.
//      GR17 : Pointer to processor minimum state saved memory location.
//      GR18 : Processor state as defined below:
//          D0-D5:          Reserved
//          D6-D31:         As defined in PAL EAS
//          D60-D63:        As defined in PAL EAS
//          D32-D47:        Size in bytes of processor dynamic state
//          D48-D59:        Reserved.
//      GR19 : Return address to a location within PAL_CHECK. 
//      BR0  : Unspecified.
//
// Return State:
//
//      Note  : The OS_MCA procedure may or may not return to SAL_CHECK
//              in the case of uncorrected machine checks.
//              If it returns to SAL, the runtime convention requires that
//              it sets appropriate values in the Min-State area pointed
//              to by GR12 for continuing execution at the interrupted
//              context or at a new context.
//              Furthermore, the OS_MCA procedure must restore the 
//              processor state to the same state as on entry except as:
//      GR1-7  : Unspecified.
//      GR8    : Return status
//                0 [= SAL_STATUS_SUCCESS] - Error has been corrected 
//                    by OS_MCA.
//               -1 - Error has not been corrected by OS_MCA and
//                    SAL must warm boot the system.
//               -2 - Error has not been corrected by OS_MCA and 
//                    SAL must cold boot the system.
//               -3 - Error has not been corrected by OS_MCA and 
//                    SAL must halt the system.
//      GR9    : Physical address value for SAL's GP.
//      GR10   : Context flag
//                0 - Return will be to the same context.
//                1 - Return will be to a   new  context.
//      GR11-21: Unspecified.
//      GR22   : Pointer to a structure containing new values of registers 
//               in the Min-State Save area. 
//               OS_MCA must supply this parameter even if it does not 
//               change the register values in the Min-State Save areas.
//      GR23-31: Unspecified.
//      BR0    : Unspecified.
//      PSR.mc : May be either 0 or 1.
//--

HalpOsMcaDispatch::
   
      // aliases for known registers:
      
      rPalProcEntryPoint     = r8
      rSalProcEntryPoint     = r9
      rSalGlobalPointer      = r10
      rRendezVousResult      = r11
      rSalReturnAddress      = r12
      rProcMinStateSavePtr   = r17
      rProcStateParameter    = r18
      rPalCheckReturnAddress = r19
      rEventResources        = t22
      rPcrPhysicalAddress    = t6 
      
    //
    // - Flag the processor as "InOsMca":
    //   KiPcr.InOsMca = 1
    //
    // - Update KiPcr.McaPTOM to point to TopOfMemory, 
    //   Memory after Processor Minimum State Save area. 
    //
    // - Update processor McaResource.SalToOsHandOff
    //
    // - Update local rPcrMcaStateDump before calling osMcaProcStateDump.  
    //
    
      mov    rEventResources = PcOsMcaResourcePtr      
      movl   t21 = KiPcr
      ;;
      tpa    rPcrPhysicalAddress = t21           //  Calculate physical address of PCR
      mov    t19  = SerSalToOsHandOff
      mov    t1  = 0x1
      ;;
      add    t0 = rPcrPhysicalAddress, rEventResources      
      sub    t21 = rPcrPhysicalAddress, t21               
      add    t16  = TOM, rProcMinStateSavePtr
      ;;
      ld8    rEventResources = [t0], PcInOsMca-PcOsMcaResourcePtr
      mov    t18  = SerPTOM
      add    t20  = 0x8,  t19
      ;;        
      xchg1  t1  = [t0], t1
      add    rEventResources = rEventResources, t21          // Calculate the physical address of the OsMcaResources
      add    t21  = 0x10, t19
      ;;                    
      add    t18  = rEventResources, t18
      add    t19  = rEventResources, t19
      add    t20  = rEventResources, t20
      add    t21  = rEventResources, t21
      ;;
      ld8    t17  = [t16]
      st8    [t19] = rPalProcEntryPoint,  0x18
      add    t0 = SerStateDumpPhysical, rEventResources
      ;;
      st8    [t18] = t17
      st8    [t20] = rSalProcEntryPoint,  0x18
      st8    [t21] = rSalGlobalPointer,   0x18
      ;;
      st8    [t19] = rRendezVousResult
      st8    [t20] = rSalReturnAddress
      st8    [t21] = rProcMinStateSavePtr
      ld8    t0 = [t0]                                  // McaStateDump
      ;;

    
    //
    // Save in preserved registers:
    //     - pointer to processor minimum state save area, 
    //     - processor state parameter
    //     - PAL_CHECK return address.
    //   s0 [=r4] <- r17, 
    //   s1 [=r5] <- r18,
    //   s2 [=r6] <- r19
    //

        SaveRs(rProcMinStateSavePtr, rProcStateParameter, rPalCheckReturnAddress)

    //
    // Save register resources in myStateDump[].
    //

        br.dpnt     osMcaProcStateDump
        ;;

osMcaDoneDump::
        //
        // If we have a TLB error, we cannot enable translation
        //
        tbit.nz.unc pt0,p0=s1, 60  // PSP.tc=60
(pt0)   br.dpnt     ResetNow
        ;;                

    //
    // Initialize current sp and ar.bsp and ar.bspstore
    //
    //    KiPcr.McaStackFrame[0] = ar.rsc
    //    KiPcr.McaStackFrame[1] = ar.pfs
    //    KiPcr.McaStackFrame[2] = ar.ifs
    //    KiPcr.McaStackFrame[3] = ar.bspstore
    //    KiPcr.McaStackFrame[4] = ar.rnat
    //    ar.bspstore = t0 [=KiPcr.McaBspStore]
    //    KiPcr.McaStackFrame[5] = ar.bsp - KiPcr.McaBspStore 
    //      [BUGBUG ?? : should be ar.bsptore=KiPcr.McaStackFrame[3]] 
    //    sp = KiPcr.McaStack
    // 

      movl   t21 = KiPcr + PcOsMcaResourcePtr
      ;;
      tpa    t0 = t21           //  Calculate physical address of PCR OsMcaResourcePtr
      mov    t1 = SerStackFrame
      ;;
      sub    t16 = SerBackStore, t21      
      sub    t1 = t1, t21
      ;;
      add    t16 = t0, t16   
      add    t1 = t0, t1   
      ld8    rEventResources = [t0], PcInitialBStore - PcOsMcaResourcePtr
      ;;        
      add    t16 = rEventResources, t16   // Calculate physical address of the new BSP
      mov    t21 = t0                    // t21 now points to InitialBStore in the PCR
      ;;
      add    t1 = rEventResources, t1   // Calculate the physical address of the Stack Frame   
      ld8    t0 = [t16], SerStack - SerBackStore
      ;;
      SwIntCxt( t4, t1, t0 )
      ;;
      st8    [t21] = t0, PcInitialStack - PcInitialBStore  // Save the InitialBStore in the PCR
      ld8    t1 = [t16], SerBackStoreLimit - SerStack      // Get inital MCA stack
      ;;
      st8    [t21] = t1, PcBStoreLimit - PcInitialStack
      ld8    t0 = [t16], SerStackLimit - SerBackStoreLimit
      ;;
      add    t1 = -STACK_SCRATCH_AREA, t1
      st8    [t21] = t0, PcStackLimit - PcBStoreLimit     // Save BStore limit
      ld8    t18 = [t16]  
      ;;
      mov    sp = t1
      st8    [t21] = t18
      ;;
      
EnableTranslation::
// let us switch to virtual mode
//
//      Need to do a "rfi" in order set "it" and "ed" bits in the PSR.
//
//      Make sure interrupts are disabled and that we are running on bank 1.
//
        rsm       1 << PSR_I
        bsw.1
        ;;

        mov       ar.rsc = r0                  // put RSE in lazy mode and use kernel mode stores.
        
//
// psr mask prepration, warning we will have a problem with PMI here
//
        movl    t0  = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IC,1) |MASK_IA64(PSR_DA,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_MC,1);;
        mov     t1  = psr;;
        or      t0  = t0, t1
        movl    t1  = VirtualSwitchDone;;
        mov     cr.iip  = t1
        mov     cr.ipsr = t0;;
        rfi
        ;;

VirtualSwitchDone::
// done with enabling address translation
     
// call our handler
        movl        t0  = HalpMcaHandler;;
        mov         b6  = t0;;
        br.call.dpnt b0=b6
        ;;

DisableTranslation::
// psr mask prepration
        rsm     MASK_IA64(PSR_IC,1);;
        movl    t0 = MASK_IA64(PSR_DA,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1);;
        movl    t1=0xffffffffffffffff;;
        xor     t0=t0,t1;;
        mov     t1=psr;;
        and     t0=t0,t1
        movl    t1=BeginOsMcaRestore;;
        tpa     t1=t1;;
        mov     cr.iip=t1;;
        mov     cr.ipsr = t0;;
        rfi
        ;;

BeginOsMcaRestore::
// restore the original stack frame here
        mov    t16 = SerStackFrame
        movl   t21 = KiPcr + PcOsMcaResourcePtr
        ;;
        tpa    t1 = t21           //  Calculate physical address of PCR OsMcaResourcePtr
        sub    t16 = t16, t21
        sub    t0 = SerStateDumpPhysical, t21
        ;;
        ld8    rEventResources = [t1]
        add    t16 = t1, t16
        add    t0 = t1, t0
        ;;        
        add    t16 = rEventResources, t16   // Calculate the physical address of the Stack Frame   
        add    t0 = rEventResources, t0   // Calculate the physical address of the State Dump pointer.
        ;;
        ld8    t0 = [t0];
        movl   t4 = PSRmcMask
        ;;
        RtnIntCxt( t4, t1, t16 )  // switch from interrupt context -> RSC mgmt.
        ;;

        //
        // let us restore all the registers from our PSI structure
        //
        
        mov     t6 = gp
        br.dpnt osMcaProcStateRestore
        ;;

osMcaDoneRestore::

        // Pal requires DFH of 0
        rsm         1 << PSR_DFH
        ;;
        rsm         1 << PSR_MFL  // just restoring to original state only
        ;;
        srlz.d
        ;;

     //
     // - Restore processor state from OsToSalHandOff. 
     //   
     // - Branch back to SALE_CHECK. 
     
      mov    t1 = PcOsMcaResourcePtr      
      movl   t21 = KiPcr
      ;;
      tpa    rPcrPhysicalAddress = t21           //  Calculate physical address of PCR
      ;;
      add    t0 = rPcrPhysicalAddress, t1      
      sub    t21 = SerOsToSalHandOff, t21               
      ;;
      ld8    t1 = [t0], PcInOsMca-PcOsMcaResourcePtr
      add    t21 = t21, rPcrPhysicalAddress
      ;;        
      add    t1 = t1, t21          // Calculate the physical address of the OsMcaResources->SalToOSHandOff
      ;;
      add    t16  = 0x8,  t1
      add    t17  = 0x10, t1
      ;;
      ld8    r8  = [t1], 0x18      // result of error handling
      ld8    r9  = [t16], 0x18      // physical SAL's GP value
      ld8    r22 = [t17]            // new Processor Min-State Save Ptr
      ;;
      ld8    t1 = [t1]         // SAL return address
      ld8    r10    = [t16]         // New Context Switch Flag
      xchg1  t0 = [t0], r0     // KiPcr.InOsMca = 0
      ;;
      mov     b0 = t1
      br.dpnt b0                       // Return to SALE_CHECK
      ;;
        
StayInPhysicalMode::
// we have to reboot the machine, assume the log is already there in NVM
// OS can read the log next time when it comes around.  Or OS can try to
// run in physical mode as well.

ResetNow::
//      do EFI system reset here...
//      Go to BugCheck (in physical mode). 
//      Out to Port 80: Fatal TLB error
//

Thyself::        
        br          Thyself                     // loop for safety      
        ;;


//EndMain//////////////////////////////////////////////////////////////////////


//++
// Name:
//      osMcaProcStateDump()
// 
// Stub Description:
//
//       This stub dumps the processor state during MCHK to a data area
//
// On Entry:
//
//       t0 = rPcrMcaStateDump.
//
// Return Value:
//
//       None.
//
//--

osMcaProcStateDump::
// Get and save GR0-31 from Proc. Min. State Save Area to SAL PSI
        
// TF: ASSERT( t0 == rPcrMcaStateDump )

//save BRs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0                // duplicate t0 in t2

        mov         t1=b0
        mov         t3=b1
        mov         t5=b2;;
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;  

        mov         t1=b3
        mov         t3=b4
        mov         t5=b5;;
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;  

        mov         t1=b6
        mov         t3=b7;;
        st8         [t0]=t1,2*Inc8
        st8         [t2]=t3,2*Inc8;;

cSaveCRs::
// save CRs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0                // duplicate t0 in t2

        mov         t1=cr0                      // cr.dcr
        mov         t3=cr1                      // cr.itm
        mov         t5=cr2;;                    // cr.iva

        st8         [t0]=t1,8*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;            // 48 byte increments

        mov         t1=cr8;;                    // cr.pta
        st8         [t0]=t1,Inc8*8;;            // 64 byte increments

// Reading interruption registers when PSR.ic=1 causes an illegal operation fault
        mov         t1=psr;;
        tbit.nz.unc pt0,p0=t1,PSRic;;           // PSI Valid Log bit pos. test
(pt0)   st8         [t0]=r0;;                   
(pt0)   adds        t0 = 0x30*Inc8, t0          // cr16->cr64 increment
(pt0)   br.dpnt     SkipIntrRegs
        ;;

        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0                // duplicate t0 in t4
        
        mov         t1=cr16                     // cr.ipsr
        mov         t3=cr17                     // cr.isr
        mov         t5=r0;;                     // cr.ida => cr18
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;                                      

        mov         t1=cr19                     // cr.iip
        mov         t3=cr20                     // cr.ifa  
        mov         t5=cr21;;                   // cr.iitr
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;                                      

        mov         t1=cr22                     // cr.iipa
        mov         t3=cr23                     // cr.ifs
        mov         t5=cr24;;                   // cr.iim
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;    
                                          
        mov         t1=cr25;;                   // cr.iha
        st8         [t0]=t1;;
        adds        t0 = 0x27*Inc8, t0;;        // cr25->cr64 byte increment

SkipIntrRegs::
        mov         t1=cr64;;                   // cr.lid
        st8         [t0]=t1,Inc8                // 

        mov         t1=cr65;;                   // cr.ivr
        st8         [t0]=t1,Inc8

        mov         t1=cr66;;                   // cr.tpr
        st8         [t0]=t1,Inc8                
    
        mov         t1=r0;;                     // cr.eoi
        st8         [t0]=t1,Inc8                // 
    
        mov         t1=r0;;                     // cr.irr0 
        st8         [t0]=t1,Inc8             

        mov         t1=r0;;                     // cr.irr1 
        st8         [t0]=t1,Inc8              

        mov         t1=r0;;                     // cr.irr2 
        st8         [t0]=t1,Inc8               

        mov         t1=r0;;                     // cr.irr3 
        st8         [t0]=t1,Inc8                

        mov         t1=r0;;                     // cr.itv 
        st8         [t0]=t1,Inc8              

        mov         t1=r0;;                     // cr.pmv 
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.cmcv 
        st8         [t0]=t1,6*Inc8

        mov         t1=r0;;                     // cr.lrr0 
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.lrr1 
        st8         [t0]=t1;;                  
        adds        t0 = 0x2f*Inc8, t0;;        // cr81->ar [128]

cSaveARs::
// save ARs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0                // duplicate t0 in t4

        mov         t1=ar0                      // ar.kr0
        mov         t3=ar1                      // ar.kr1
        mov         t5=ar2;;                    // ar.kr2
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;

        mov         t1=ar3                      // ar.kr3                               
        mov         t3=ar4                      // ar.kr4
        mov         t5=ar5;;                    // ar.kr5
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,13*Inc8;;           // ar5->ar18

        mov         t1=ar6                      // ar.kr6
        mov         t3=ar7;;                    // ar.kr7
        st8         [t0]=t1,10*Inc8
        st8         [t2]=t3,10*Inc8;;

        mov         t1=ar16                     // ar.rsc
        mov         t3=ar17                     // ar.bsp
        mov         t5=ar18;;                   // ar.bspstore
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;

        mov         t1=ar19;;                   // ar.rnat
        st8         [t0]=t1,Inc8*13             // increment by 13x8 bytes

        mov         t1=ar32;;                   // ar.ccv
        st8         [t0]=t1,Inc8*4

        mov         t1=ar36;;                   // ar.unat
        st8         [t0]=t1,Inc8*4

        mov         t1=ar40;;                   // ar.fpsr
        st8         [t0]=t1,Inc8*4

        mov         t1=ar44;;                   // ar.itc
        st8         [t0]=t1,160                 // 160

        mov         t1=ar64;;                   // ar.pfs
        st8         [t0]=t1,Inc8

        mov         t1=ar65;;                   // ar.lc
        st8         [t0]=t1,Inc8

        mov         t1=ar66;;                   // ar.ec
        st8         [t0]=t1
        adds        t0=Inc8*62,t0               //padding
    
// save RRs
        mov         ar.lc=0x08-1
        movl        t2=0x00;;

cStRR::
        mov         t1=rr[t2];;
        st8         [t0]=t1,Inc8
        add         t2=1,t2
        br.cloop.dpnt cStRR
        ;;

// align memory addresses to 16 bytes
        and         t1=0x0f,t0;;
        cmp.ne.unc  pt0,p0=t1,r0;;
(pt0)   add         t0=Inc8,t0

cSaveFRs::
// just save FP for MCA restore only, "C" code will trash f6-f15
// save ar.NaT 
        mov         t3=ar.unat;;                 // ar.unat

        stf.spill   [t0]=f6,Inc16;;
        stf.spill   [t0]=f7,Inc16;;
        stf.spill   [t0]=f8,Inc16;;
        stf.spill   [t0]=f9,Inc16;;
        stf.spill   [t0]=f10,Inc16;;
        stf.spill   [t0]=f11,Inc16;;
        stf.spill   [t0]=f12,Inc16;;
        stf.spill   [t0]=f13,Inc16;;
        stf.spill   [t0]=f14,Inc16;;
        stf.spill   [t0]=f15,Inc16;;

        mov         t2=ar.unat;;
        st8         [t0]=t2,Inc8                // save User NaT bits for r16-r31
        mov         ar.unat=t3                  // restore original unat

        br.dpnt     osMcaDoneDump
        ;;

//EndStub//////////////////////////////////////////////////////////////////////


//++
// Name:
//       osMcaProcStateRestore()
// 
// Stub Description:
//
//       This is a stub to restore the saved processor state during MCHK
//
// On Entry:
//
//       t0 = rPcrMcaStateDump.
//
// Return Value:
//
//       None.
//--

osMcaProcStateRestore::

// TF: ASSERT( t0 == rPcrMcaStateDump )

restore_BRs::
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;  
        mov         b0=t1
        mov         b1=t3
        mov         b2=t5;;

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;  
        mov         b3=t1
        mov         b4=t3
        mov         b5=t5;;

        ld8         t1=[t0],2*Inc8
        ld8         t3=[t2],2*Inc8;;  
        mov         b6=t1
        mov         b7=t3;;

restore_CRs::
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],8*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;            // 48 byte increments
        mov         cr0=t1                      // cr.dcr
        mov         cr1=t3                      // cr.itm
        mov         cr2=t5;;                    // cr.iva

        ld8         t1=[t0],8*Inc8;;            // 64 byte increments
//      mov         cr8=t1                      // cr.pta


// if PSR.ic=1, reading interruption registers causes an illegal operation fault
        mov         t1=psr;;
        tbit.nz.unc pt0,p0=t1,PSRic;;           // PSI Valid Log bit pos. test
(pt0)   st8         [t0]=r0,9*8+160             // increment by 160 byte inc.
(pt0)   br.dpnt     rSkipIntrRegs
        ;;

        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         cr16=t1                     // cr.ipsr
        mov         cr17=t3                     // cr.isr is read only
//      mov         cr18=t5;;                   // cr.ida

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         cr19=t1                     // cr.iip
        mov         cr20=t3                     // cr.idtr
        mov         cr21=t5;;                   // cr.iitr

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         cr22=t1                     // cr.iipa
        mov         cr23=t3                     // cr.ifs
        mov         cr24=t5                     // cr.iim

        ld8         t1=[t0],160;;               // 160 byte increment
        mov         cr25=t1                     // cr.iha 

rSkipIntrRegs::
        ld8         t1=[t0],168;;               // another 168 byte inc.

        ld8         t1=[t0],40;;                // 40 byte increment
        mov         cr66=t1                     // cr.lid

        ld8         t1=[t0],Inc8;;
//      mov         cr71=t1                     // cr.ivr is read only
        ld8         t1=[t0],24;;                // 24 byte increment
        mov         cr72=t1                     // cr.tpr
   
        ld8         t1=[t0],168;;               // 168 byte inc.
//      mov         cr75=t1                     // cr.eoi
   
        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr96=t1                     // cr.irr0 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr98=t1                     // cr.irr1 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc
//      mov         cr100=t1                    // cr.irr2 is read only

        ld8         t1=[t0],Inc16;;             // 16b inc.
//      mov         cr102=t1                    // cr.irr3 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr114=t1                    // cr.itv

        ld8         t1=[t0],Inc8;;
//      mov         cr116=t1                    // cr.pmv
        ld8         t1=[t0],Inc8;;
//      mov         cr117=t1                    // cr.lrr0
        ld8         t1=[t0],Inc8;;
//      mov         cr118=t1                    // cr.lrr1
        ld8         t1=[t0],Inc8*10;;
//      mov         cr119=t1                    // cr.cmcv

restore_ARs::
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         ar0=t1                      // ar.kro
        mov         ar1=t3                      // ar.kr1
        mov         ar2=t5;;                    // ar.kr2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         ar3=t1                      // ar.kr3                               
        mov         ar4=t3                      // ar.kr4
        mov         ar5=t5;;                    // ar.kr5

        ld8         t1=[t0],10*Inc8
        ld8         t3=[t2],10*Inc8
        ld8         t5=[t4],10*Inc8;;
        mov         ar6=t1                      // ar.kr6
        mov         ar7=t3                      // ar.kr7
//      mov         ar8=t4                      // ar.kr8
        ;;

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
//      mov         ar16=t1                     // ar.rsc
//      mov         ar17=t3                     // ar.bsp is read only
        mov         ar18=t5;;                   // ar.bspstore

        ld8         t1=[t0],Inc8*13;;
        mov         ar19=t1                     // ar.rnat

        ld8         t1=[t0],Inc8*4;;
        mov         ar32=t1                     // ar.ccv

        ld8         t1=[t0],Inc8*4;;
        mov         ar36=t1                     // ar.unat

        ld8         t1=[t0],Inc8*4;;
        mov         ar40=t1                     // ar.fpsr

        ld8         t1=[t0],160;;               // 160
//      mov         ar44=t1                     // ar.itc

        ld8         t1=[t0],Inc8;;
        mov         ar64=t1                     // ar.pfs

        ld8         t1=[t0],Inc8;;
        mov         ar65=t1                     // ar.lc

        ld8         t1=[t0];;
        mov         ar66=t1                     // ar.ec
        adds        t0=Inc8*62,t0;;             // padding 
    
restore_RRs::
        mov         t3=ar.lc
        mov         ar.lc=0x08-1
        movl        t2=0x00
cStRRr::
        ld8         t1=[t0],Inc8;;
//      mov         rr[t2]=t1                   // what are its access previledges?
        add         t2=1,t2
        br.cloop.dpnt cStRRr
        ;;
        mov         ar.lc=t3

// align memory addresses to 16 bytes
        and         t1=0x0f,t0;;
        cmp.ne.unc  pt0,p0=t1,r0;;
(pt0)   add         t0=Inc8,t0;;

// restore FP's which might be trashed by the "C" code
        mov         t3=ar.unat
        add         t1=16*10,t0;;                // to get to NaT of GR 16-31
        ld8         t1=[t1];;
        mov         ar.unat=t1;;                // first restore NaT

restore_FRs::
        ldf.fill    f6=[t0],Inc16;;
        ldf.fill    f7=[t0],Inc16;;
        ldf.fill    f8=[t0],Inc16;;
        ldf.fill    f9=[t0],Inc16;;
        ldf.fill    f10=[t0],Inc16;;
        ldf.fill    f11=[t0],Inc16;;
        ldf.fill    f12=[t0],Inc16;;
        ldf.fill    f13=[t0],Inc16;;
        ldf.fill    f14=[t0],Inc16;;
        ldf.fill    f15=[t0],Inc16;;

        mov         ar.unat=t3                  // restore original NaT

        br.dpnt     osMcaDoneRestore
        ;;

//EndStub//////////////////////////////////////////////////////////////////////

//++
// VOID
// HalpAcquireMcaSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function acquires a MCA spin lock.
//    This function does not modify the interrupt state or the IRQL.
//
//    N.B: This function does *NOT* replace KiAcquireSpinLock but 
//         allows us to place it in a locked MCA specific section.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a MCA spin lock.
//
// Return Value:
//
//    None.
//
//--

        .align      16

        LEAF_ENTRY(HalpAcquireMcaSpinLock)

#if !defined(NT_UP)

        ACQUIRE_SPINLOCK(a0,a0,Halpasl10)

        br.ret.dptk brp
        ;;

#else

        LEAF_RETURN

#endif // !defined(NT_UP)

        LEAF_EXIT(HalpAcquireMcaSpinLock)

//EndProc//////////////////////////////////////////////////////////////////////

//++
// VOID
// HalpReleaseMcaSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function release a MCA spin lock.
//    This function does not modify the interrupt state or the IRQL.
//
//    N.B: This function does *NOT* replace KiReleaseSpinLock but
//         allows us to place it in a locked MCA specific section.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a MCA spin lock.
//
// Return Value:
//
//    None.
//
//--

        .align      16

        LEAF_ENTRY(HalpReleaseMcaSpinLock)

#if !defined(NT_UP)
        st8.rel     [a0] = zero             // set spin lock not owned
#endif

        LEAF_RETURN
        LEAF_EXIT(HalpReleaseMcaSpinLock)

//EndProc//////////////////////////////////////////////////////////////////////


//++
// Name:
//      HalpMCAEnable()
// 
// Routine Description:
//
//      This procedure enables MCA resources that are not already enabled. 
//
// Arguments:
//
//      None  
//
// Return value:
//    
//      None
//      
//--
        .align      16
        .proc       HalpMCAEnable
HalpMCAEnable::
        NESTED_SETUP(0,2,0,0);;

// nothing right now...

        NESTED_RETURN
        .endp       HalpMCAEnable 

//EndProc//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\pmdata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmdata.c

Abstract:

    Declares various data which is initialize data, or pagable data.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

FADT    HalpFixedAcpiDescTable;
ULONG   HalpThrottleScale;

ULONG   HalpAcpiFlags = HAL_ACPI_PCI_RESOURCES;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

//
// This array represents the ISA PIC vectors.
// They start out identity-mapped.
//
ULONG   HalpPicVectorRedirect[PIC_VECTORS] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    10, 11, 12, 13, 14, 15
};

ULONG HalpPicVectorFlags[PIC_VECTORS] = {0};

//
// HalpCPEIntIn[] represents the Platform Interrupt Source's
// connection to SAPIC input pin. They start out "identity-mapped".
//


ULONG HalpCPEIntIn[HALP_CPE_MAX_INTERRUPT_SOURCES] =
{
   0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
   10, 11, 12, 13, 14, 15
};

//
// HalpCMCDestination[] represents the target CPU number of CMC interrupt source.
// They start out with all pointing to processor 0.
//

USHORT HalpCPEDestination[HALP_CPE_MAX_INTERRUPT_SOURCES] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0
};

//
// HalpCPEVectorFlags[] represents the flags for CPE interrupt source.
//

ULONG HalpCPEVectorFlags[HALP_CPE_MAX_INTERRUPT_SOURCES] = {0};

//
// HalpCPEIoSapicVector[] represents the interrupt vector of CPE interrupt source.
// They start out with all vectors at CPEI_VECTOR.
//


UCHAR HalpCPEIoSapicVector[HALP_CPE_MAX_INTERRUPT_SOURCES] = {CPEI_VECTOR};

//
// HalpMaxCPEImplemented indicates as how many INITIN pins are
// connected to different sources of platform CMC Error. The default value is 0.
// Since this will be used to index the arrays, a value of 0 means one source of CPE is
// implemented in this platform.

ULONG HalpMaxCPEImplemented = 0;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGELKSX")
#endif

SLEEP_STATE_CONTEXT HalpSleepContext = {0};
PVOID               HalpWakeVector  = NULL;
PVOID               HalpVirtAddrForFlush = NULL;
PVOID               HalpPteForFlush = NULL;
UCHAR               HalpRtcRegA;
UCHAR               HalpRtcRegB;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

UCHAR  rgzNoApicTable[]     = "HAL: No ACPI SAPIC Table Found\n";
UCHAR  HalpSzHackPci[]      = "VALID_PCI_RESOURCE";
UCHAR  HalpSzHackPrt[]      = "HACK_PRT_SUPPORT";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\pmsleep.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmsleep.c

Abstract:

    This file provides the code that changes the system from
    the ACPI S0 (running) state to any one of the sleep states.

Author:

    Jake Oshins (jakeo) Feb. 11, 1997

Revision History:

   Todd Kjos (HP) (v-tkjos) 1-Jun-1998: Initial port to IA64

--*/
#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "ixsleep.h"
#include "kddll.h"

//
// Internal functions
//

VOID
HalpLockedIncrementUlong(
    PULONG SyncVariable
);

VOID
HalpReboot (
    VOID
    );

NTSTATUS
HaliAcpiFakeSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

VOID
HalpSetClockBeforeSleep(
    VOID
    );

VOID
HalpSetClockAfterSleep(
    VOID
    );

BOOLEAN
HalpWakeupTimeElapsed(
    VOID
    );

VOID
HalpReenableAcpi(
    VOID
    );

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    );

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    PVOID OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    LIST_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, HaliAcpiSleep)
#pragma alloc_text(PAGELK, HaliAcpiFakeSleep)
#pragma alloc_text(PAGELK, HalpAcpiPreSleep)
#pragma alloc_text(PAGELK, HalpAcpiPostSleep)
#pragma alloc_text(PAGELK, HalpWakeupTimeElapsed)
#pragma alloc_text(PAGELK, HalpReenableAcpi)
#pragma alloc_text(PAGELK, HaliSetWakeEnable)
#pragma alloc_text(PAGELK, HaliSetWakeAlarm)
#endif

HAL_WAKEUP_STATE HalpWakeupState;
ULONG Barrier;
volatile ULONG HalpSleepSync;
PKPROCESSOR_STATE HalpHiberProcState;

#if DBG
BOOLEAN             HalpFailSleep  = FALSE;
#endif

#define PM1_TMR_EN 0x0001
#define PM1_RTC_EN 0x0400
#define WAK_STS    0x8000

#define HAL_PRIMARY_PROCESSOR 0

//
// For re-enabling the debugger's com port.
//
extern PUCHAR KdComPortInUse;


VOID
HalpAcpiFlushCache(
    )
{
    HalSweepDcache();
    HalSweepIcache();
}



VOID
HalpSaveProcessorStateAndWait(
    IN PKPROCESSOR_STATE ProcessorState,
    IN volatile PULONG   Count
    )
/*++
Rountine description:

    This function saves the volatile, non-volatile and special register
    state of the current processor.

    N.B. floating point state is NOT captured.

Arguments:

    ProcessorState  -  Address of processor state record to fill in.

    pBarrier - Address of a value to use as a lock.

Return Value:

    None.  This function does not return.

--*/
{

#if 0
    //
    // Fill in ProcessorState
    //

    KeSaveStateForHibernate(ProcessorState);

    //
    // Save return address, not caller's return address.
    //

    ProcessorState->ContextFrame.StIIP = HalpGetReturnAddress();
#endif

    //
    // Flush the cache, as the processor may be about to power off.
    //
    //
    HalpAcpiFlushCache();

    //
    // Singal that this processor has saved its state.
    //

    HalpLockedIncrementUlong(Count);

    //
    // Wait for the hibernation file to be written.
    // Processor 0 will zero Barrier when it is
    // finished.
    //
    // N.B.  We can't return from this function
    // before the hibernation file is finished
    // because we would be tearing down the very same
    // stack that we will be jumping onto when the
    // processor resumes.  But after the hibernation
    // file is written, it doesn't matter, because
    // the stack will be restored from disk.
    //

    while (*Count != 0);

}

BOOLEAN
HalpAcpiPreSleep(
    SLEEP_STATE_CONTEXT Context
    )
/*++

Routine Description:

Arguments:

    none

Return Value:

    status

--*/
{
    USHORT pmTimer;
    GEN_ADDR pm1a;
    GEN_ADDR pm1b;

    pm1a = HalpFixedAcpiDescTable.x_pm1a_evt_blk;
    pm1a.Address.QuadPart += (HalpFixedAcpiDescTable.x_pm1a_evt_blk.BitWidth / 2 / 8); // 2 because we want to cut it in half, 8 because we want to convert bits to bytes
    pm1a.BitWidth = HalpFixedAcpiDescTable.x_pm1a_evt_blk.BitWidth / 2;

    pm1b = HalpFixedAcpiDescTable.x_pm1b_evt_blk;
    pm1b.Address.QuadPart += (HalpFixedAcpiDescTable.x_pm1b_evt_blk.BitWidth / 2 / 8);
    pm1b.BitWidth = HalpFixedAcpiDescTable.x_pm1b_evt_blk.BitWidth / 2;

    HalpSleepContext.AsULONG = Context.AsULONG;

    #if DBG
        if (HalpFailSleep) {

            return FALSE;
        }
    #endif

    //
    // If we should have woken up already, don't sleep.
    //
    if (HalpWakeupTimeElapsed()) {
        return FALSE;
    }

    //
    // If an RTC alarm is set, then enable it and disable
    // periodic interrupts (for profiling.)
    //
    HalpSetClockBeforeSleep();

    //
    // Check to see if we need to disable all wakeup events.
    //

    if (!HalpWakeupState.GeneralWakeupEnable) {

        AcpiEnableDisableGPEvents(FALSE);

    } else {

        //
        // Only call this before going to sleep --- waking up should
        // reset the GPEs to the 'proper' value
        //

        AcpiGpeEnableWakeEvents();

    }

    if (Context.bits.Flags & SLEEP_STATE_SAVE_MOTHERBOARD) {

        HalpSaveDmaControllerState();

        HalpSaveTimerState();

    }

    //
    // We need to make sure that the PM timer is disabled from
    // this point onward. We also need to make that the
    // RTC Enable is only enabled if the RTC shold wake up the compiler
    //

    pmTimer = (USHORT)HalpReadGenAddr(&pm1a);

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {

        pmTimer |= (USHORT)HalpReadGenAddr(&pm1b);
    }

    //
    // Clear the timer enable bit.
    //

    pmTimer &= ~PM1_TMR_EN;

    //
    // Check to see if we the machine supports RTC wake in Fixed Feature
    // space. Some machines implement RTC support via control methods.
    //
    if (!(HalpFixedAcpiDescTable.flags & RTC_WAKE_GENERIC) ) {

        //
        // Check to see f we need to disable/enable the RTC alarm
        //
        if (!HalpWakeupState.RtcWakeupEnable) {
           pmTimer &= ~PM1_RTC_EN;
        } else {
           pmTimer |= PM1_RTC_EN;

        }

    }


    //
    // Write it back into the hardware.
    //

    HalpWriteGenAddr(&pm1a, pmTimer);

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {

        HalpWriteGenAddr(&pm1b, pmTimer);
    }

    return TRUE;
}

BOOLEAN
HalpAcpiPostSleep(
    ULONG Context
    )
{
    USHORT pmTimer;
    GEN_ADDR pm1a;
    GEN_ADDR pm1b;

    pm1a = HalpFixedAcpiDescTable.x_pm1a_evt_blk;
    pm1a.Address.QuadPart += (HalpFixedAcpiDescTable.pm1_evt_len / 2);

    pm1b = HalpFixedAcpiDescTable.x_pm1b_evt_blk;
    pm1b.Address.QuadPart += (HalpFixedAcpiDescTable.pm1_evt_len / 2);

    //
    // Read te currently set PM1 Enable bits.
    //

    pmTimer = (USHORT)HalpReadGenAddr(&pm1a);

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {

        pmTimer |= (USHORT)HalpReadGenAddr(&pm1b);
    }

    //
    // Set the timer enable bit. Clear the RTC enable bit.
    //

    pmTimer &= ~PM1_RTC_EN;

    //
    // Write it back the new PM1 Enable bits
    //

    HalpWriteGenAddr(&pm1a, pmTimer);

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {

        HalpWriteGenAddr(&pm1b, pmTimer);
    }

    //
    // Unset the RTC alarm and re-enable periodic interrupts.
    //
    HalpSetClockAfterSleep();

    HalpWakeupState.RtcWakeupEnable = FALSE;

    *((PULONG)HalpWakeVector) = 0;

   HalpSetInterruptControllerWakeupState(Context);

    if (HalpSleepContext.bits.Flags & SLEEP_STATE_SAVE_MOTHERBOARD) {

        //
        // If Kd was in use, then invalidate it.  It will re-sync itself.
        //
        if (KdComPortInUse) {
            KdRestore(TRUE);
        }

        HalpRestoreDmaControllerState();

        HalpRestoreTimerState();

    }

    //
    // Enable all GPEs, not just the wake ones
    //

    AcpiEnableDisableGPEvents(TRUE);

    return TRUE;
}


BOOLEAN
HalpWakeupTimeElapsed(
    VOID
    )
{
    LARGE_INTEGER wakeupTime, currentTime;
    TIME_FIELDS currentTimeFields;

    //
    // Check to see if a wakeup timer has already expired.
    //
    if (HalpWakeupState.RtcWakeupEnable) {

        HalQueryRealTimeClock(&currentTimeFields);

        RtlTimeFieldsToTime(&currentTimeFields,
                            &currentTime);

        RtlTimeFieldsToTime(&HalpWakeupState.RtcWakeupTime,
                            &wakeupTime);

        if (wakeupTime.QuadPart < currentTime.QuadPart) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
HaliSetWakeAlarm (
        IN ULONGLONG    WakeSystemTime,
        IN PTIME_FIELDS WakeTimeFields OPTIONAL
        )
/*++

Routine Description:

    This routine sets the real-time clock's alarm to go
    off at a specified time in the future and programs
    the ACPI chipset so that this wakes the computer.

Arguments:

    WakeSystemTime - amount of time that passes before we wake
    WakeTimeFields - time to wake broken down into TIME_FIELDS

Return Value:

    status

--*/
{
    if (WakeSystemTime == 0) {

        HalpWakeupState.RtcWakeupEnable = FALSE;
        return STATUS_SUCCESS;

    }

    ASSERT( WakeTimeFields );
    HalpWakeupState.RtcWakeupEnable = TRUE;
    HalpWakeupState.RtcWakeupTime = *WakeTimeFields;
    return HalpSetWakeAlarm(WakeSystemTime,
                            WakeTimeFields);
}

VOID
HaliSetWakeEnable(
        IN BOOLEAN      Enable
        )
/*++

Routine Description:

    This routine is called to set the policy for waking up.
    As we go to sleep, the global HalpWakeupState will be
    read and the hardware set accordingly.

Arguments:

    Enable - true or false

Return Value:

--*/
{
    if (Enable) {
        HalpWakeupState.GeneralWakeupEnable = TRUE;
    } else {
        HalpWakeupState.GeneralWakeupEnable = FALSE;
        HalpWakeupState.RtcWakeupEnable     = FALSE;
    }
}

VOID
HalpReenableAcpi(
    VOID
    )
/*++

Routine Description:

    This calls into the ACPI driver to switch back into ACPI mode,
    presumably after S4 and sets the ACPI registers that the HAL
    controls.

Arguments:

Return Value:

--*/
{
    // TEMPTEMP?
    HalpInitializeClock();

    AcpiInitEnableAcpi(TRUE);
    AcpiEnableDisableGPEvents(TRUE);
}

/*++

Routine Description:

    This is a stub to allow us to perform device powerdown
    testing on IA64 machines before they actually support
    real sleep states.

Arguments:

    <standard sleep handler args>

Return Value:

    STATUS_NOT_SUPPORTED

--*/

NTSTATUS
HaliAcpiFakeSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
{
    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
/*++
Routine Description:

    At some point in time this function will be  called to put PCs into a sleep
    state.  It saves motherboard state and then bails out.  For now this function
    is only called to implement S5 on Itanium.

Arguments:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL OldIrql;
    SLEEP_STATE_CONTEXT SleepContext;
    USHORT SlpTypA, SlpTypB, Pm1Control;
    PKPROCESSOR_STATE CurrentProcessorState;
    GEN_ADDR Pm1bEvt;
    PKPRCB Prcb;

    //
    // initial setup.
    //
    HalpDisableInterrupts();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    SleepContext.AsULONG = (ULONG) (((ULONGLONG) Context) & 0xffffffff);

    SlpTypA = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk);
    if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
        SlpTypB = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk);
    }


    //
    // If it is not processor 0, then goto wait loop.
    //
    Prcb = PCR->Prcb;
    if (Prcb->Number != 0) {
        //
        // Get processor number, get size of proc state and generate an index
        // into HalpHiberProcState.
        //

        CurrentProcessorState = HalpHiberProcState + Prcb->Number;
        HalpSaveProcessorStateAndWait(CurrentProcessorState,
                                      (PULONG) &HalpSleepSync);

        //
        // Wait for next phase
        //

        while (HalpSleepSync != 0);    // wait for barrier to move

    } else {                           // processor 0
        Barrier = 0;

        //
        // Make sure the other processors have saved their
        // state and begun to spin.
        //

        HalpLockedIncrementUlong((PULONG) &HalpSleepSync);
        while (NumberProcessors != (LONG) HalpSleepSync);

        //
        // Take care of chores (RTC, interrupt controller, etc.)
        //

        //
        // The hal has all of it's state saved into ram and is ready
        // for the power down.  If there's a system state handler give
        // it a shot
        //

        if (SystemHandler) {
            Status = (*SystemHandler)(SystemContext);
            if (!NT_SUCCESS(Status)) {
                HalpReenableAcpi();

                //
                // Restore the SLP_TYP registers.  (So that embedded controllers
                // and BIOSes can be sure that we think the machine is awake.)
                //
                HalpWriteGenAddr (&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk, SlpTypA);
                if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
                    HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk, SlpTypB);
                }

                HalpAcpiPostSleep(SleepContext.AsULONG);
            }

        } else {

            if (HalpAcpiPreSleep(SleepContext)) {

                //
                // If we will not be losing processor state, go to sleep.
                //

                if ((SleepContext.bits.Flags & SLEEP_STATE_FIRMWARE_RESTART) == 0) {

                    //
                    // Reset WAK_STS
                    //

                    HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1a_evt_blk, (USHORT) WAK_STS);
                    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
                        HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_evt_blk, (USHORT) WAK_STS);
                    }

                    //
                    // Flush the caches if necessary
                    //

                    if (SleepContext.bits.Flags & SLEEP_STATE_FLUSH_CACHE) {
                        HalpAcpiFlushCache();
                    }

                    //
                    // Issue SLP commands to PM1a_CNT and PM1b_CNT
                    //

                    //
                    // nibble 0 is 1a sleep type, put it in position and enable sleep.
                    // preserve some bits in Pm1aCnt.
                    //
                    Pm1Control = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk);
                    Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) |
                                           (SleepContext.bits.Pm1aVal << SLP_TYP_SHIFT) | SLP_EN);
                    HalpWriteGenAddr (&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk, Pm1Control);

                    //
                    // nibble 1 is 1b sleep type, put it in position and enable sleep
                    // preserve some bits in Pm1bCnt.
                    //

                    if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
                        Pm1Control = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk);
                        Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) |
                                               (SleepContext.bits.Pm1bVal << SLP_TYP_SHIFT) | SLP_EN);
                        HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk, Pm1Control);
                    }

                    if (SleepContext.bits.Flags & SLEEP_STATE_OFF) {

                        //
                        // We are trying to do Shutdown Power Off.  Some OEM's
                        // chipsets don't actually implement the ACPI registers
                        // fully.  So we are going to do a HalReturnToFirmware
                        // if the system doesn't power off in 30 seconds.
                        //

                        KeStallExecutionProcessor(30 * 1000 * 1000);

                        HalReturnToFirmware(HalPowerDownRoutine);
                    }

                    //
                    // Wait for sleep to be over
                    //

                    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
                        Pm1bEvt = HalpFixedAcpiDescTable.x_pm1b_evt_blk;
                    } else {
                        Pm1bEvt = HalpFixedAcpiDescTable.x_pm1a_evt_blk;
                    }

                    while ( ((HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_evt_blk) & WAK_STS) == 0) &&
                            ((HalpReadGenAddr(&Pm1bEvt) & WAK_STS) == 0) );

                } else {
                    CurrentProcessorState = HalpHiberProcState + Prcb->Number;
                    // HalpSetupStateForResume(CurrentProcessorState);
                }

            }       // HalpAcpiPreSleep() == 0
        }       // SystemHandler == 0

        //
        // Notify other processor of completion
        //

        HalpSleepSync = 0;

    }       // processor 0

    //
    // Restore each processor's APIC state.
    //
    // HalpPostSleepMP<NumberProc, Barrier>;

    //
    // Restore caller's IRQL.
    //
    KeLowerIrql(OldIrql);

    //
    // Exit.
    //
    // HalpSleepSync = 0;

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\pmpcisup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmpcibus.c

Abstract:

    Implements simplified PCI configuration
    read and write functions for use in
    an ACPI HAL.

Author:

    Jake Oshins (jakeo) 1-Dec-1997
    Chris Hyser (chrish@fc.hp.com) 23-Jun-1997
    Neal Vu (neal.vu@intel.com) 11-Jul-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

NTSTATUS
HalpSearchForPciDebuggingDevice(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG                        StartBusNumber,
    IN ULONG                        EndBusNumber,
    IN ULONG                        MinMem,
    IN ULONG                        MaxMem,
    IN USHORT                       MinIo,
    IN USHORT                       MaxIo,
    IN BOOLEAN                      ConfigureBridges
    );

PCIPBUSDATA HalpFakePciBusData = {
    {
        PCI_DATA_TAG,//Tag
        PCI_DATA_VERSION,//Version
        (PciReadWriteConfig)HalpReadPCIConfig,//ReadConfig
        (PciReadWriteConfig) HalpWritePCIConfig,//WriteConfig
        (PciPin2Line)HalpPCIPin2ISALine,//Pin2Line
        (PciLine2Pin)HalpPCIISALine2Pin,//Line2Pin
        {0},//ParentSlot
        NULL,NULL,NULL,NULL//Reserved[4]
    },
    {0},//Config
    PCI_MAX_DEVICES,//MaxDevice
};

BUS_HANDLER HalpFakePciBusHandler = {
    BUS_HANDLER_VERSION,//Version
    PCIBus,//InterfaceType
    PCIConfiguration,//ConfigurationType
    0,//BusNumber
    NULL,//DeviceObject
    NULL,//ParentHandler
    (PPCIBUSDATA)&HalpFakePciBusData,//BusData
    0,//DeviceControlExtensionSize
    NULL,//BusAddresses
    {0},//Reserved[4]
    (PGETSETBUSDATA)HalpGetPCIData,//GetBusData
    (PGETSETBUSDATA)HalpSetPCIData,//SetBusData
    NULL,//AdjustResourceList
    (PASSIGNSLOTRESOURCES)HalpAssignPCISlotResources,//AssignSlotResources
    NULL,//GetInterruptVector
    NULL,//TranslateBusAddress
};

ULONG       HalpMinPciBus = 0;
ULONG       HalpMaxPciBus = 0;

#define MAX_DEBUGGING_DEVICES_SUPPORTED 2
PCI_TYPE1_CFG_CYCLE_BITS HalpPciDebuggingDevice[MAX_DEBUGGING_DEVICES_SUPPORTED] = {0};

PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

VOID
HalpFindFreeResourceLimits(
    IN      ULONG   Bus,
    IN OUT  ULONG   *MinIo,
    IN OUT  ULONG   *MaxIo,
    IN OUT  ULONG   *MinMem,
    IN OUT  ULONG   *MaxMem,
    IN OUT  ULONG   *MinBus,
    IN OUT  ULONG   *MaxBus
    );

NTSTATUS
HalpSetupUnconfiguredDebuggingDevice(
    IN ULONG   Bus,
    IN ULONG   Slot,
    IN ULONG   IoMin,
    IN ULONG   IoMax,
    IN ULONG   MemMin,
    IN ULONG   MemMax,
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice
    );

NTSTATUS
HalpConfigurePciBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    );

VOID
HalpUnconfigurePciBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    );

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    );

ULONG
HalpPhase0GetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

ULONG
HalpPhase0SetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

NTSTATUS
HalpReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    );

NTSTATUS
HalpSetupPciDeviceForDebugging(
    IN     PLOADER_PARAMETER_BLOCK   LoaderBlock,   OPTIONAL
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitializePciBus)
#pragma alloc_text(INIT,HalpRegisterKdSupportFunctions)
#pragma alloc_text(INIT,HalpRegisterPciDebuggingDeviceInfo)
#pragma alloc_text(PAGELK,HalpConfigurePciBridge)
#pragma alloc_text(PAGELK,HalpFindFreeResourceLimits)
#pragma alloc_text(PAGELK,HalpPhase0GetPciDataByOffset)
#pragma alloc_text(PAGELK,HalpPhase0SetPciDataByOffset)
#pragma alloc_text(PAGELK,HalpReleasePciDeviceForDebugging)
#pragma alloc_text(PAGELK,HalpSearchForPciDebuggingDevice)
#pragma alloc_text(PAGELK,HalpSetupPciDeviceForDebugging)
#pragma alloc_text(PAGELK,HalpSetupUnconfiguredDebuggingDevice)
#pragma alloc_text(PAGELK,HalpUnconfigurePciBridge)
#endif

VOID
HalpInitializePciBus (
    VOID
    )
{
    PPCIPBUSDATA        BusData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];

    RtlZeroMemory(&HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    HalpFakePciBusHandler.Version = BUS_HANDLER_VERSION;
    HalpFakePciBusHandler.InterfaceType = PCIBus;
    HalpFakePciBusHandler.ConfigurationType = PCIConfiguration;

    //
    // Fill in PCI handlers
    //

    HalpFakePciBusHandler.GetBusData = (PGETSETBUSDATA) HalpGetPCIData;
    HalpFakePciBusHandler.SetBusData = (PGETSETBUSDATA) HalpSetPCIData;
    HalpFakePciBusHandler.AssignSlotResources = (PASSIGNSLOTRESOURCES) HalpAssignPCISlotResources;
    HalpFakePciBusHandler.BusData = &HalpFakePciBusData;

    BusData = (PPCIPBUSDATA) HalpFakePciBusHandler.BusData;

    //
    // Fill in common PCI data
    //

    BusData->CommonData.Tag         = PCI_DATA_TAG;
    BusData->CommonData.Version     = PCI_DATA_VERSION;
    BusData->CommonData.ReadConfig  = (PciReadWriteConfig) HalpReadPCIConfig;
    BusData->CommonData.WriteConfig = (PciReadWriteConfig) HalpWritePCIConfig;
    BusData->CommonData.Pin2Line    = (PciPin2Line) HalpPCIPin2ISALine;
    BusData->CommonData.Line2Pin    = (PciLine2Pin) HalpPCIISALine2Pin;

    //
    // Set defaults
    //

    BusData->MaxDevice   = PCI_MAX_DEVICES;

    //
    // There used to be a switch statment on HwType which installed
    // different handlers based on PCI Configuration Type.  This
    // has been removed since SAL is always used for IA64.
    //
}


ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    PCI_SLOT_NUMBER slotNum;
    BUS_HANDLER     busHand;

    UNREFERENCED_PARAMETER(Context);

    slotNum.u.AsULONG = Slot;

    //
    // Fake a bus handler.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    //
    // Calculate the right bus number.
    //

    busHand.BusNumber = BusOffset;

    HalpReadPCIConfig(&busHand,
                      slotNum,
                      Buffer,
                      Offset,
                      Length
                      );

    //
    // This is a hack.  The legacy HAL interfaces need to be able
    // to distinguish between busses that exist and busses that
    // don't.  And many users of the legacy interfaces implicitly
    // assume that PCI busses are tightly packed.  (i.e. All busses
    // between the lowest numbered one and the highest numbered one
    // exist.)  So here we are keeping track of the highest numbered
    // bus that we have seen so far.
    //

    if ((Length >= 2) &&
        (((PPCI_COMMON_CONFIG)Buffer)->VendorID != PCI_INVALID_VENDORID)) {

        //
        // This is a valid device.
        //

        if (busHand.BusNumber > HalpMaxPciBus) {

            //
            // This is the highest numbered bus we have
            // yet seen.
            //

            HalpMaxPciBus = busHand.BusNumber;
        }
    }

    return Length;
}

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    PCI_SLOT_NUMBER slotNum;
    BUS_HANDLER     busHand;

    UNREFERENCED_PARAMETER(Context);

    slotNum.u.AsULONG = Slot;

    //
    // Fake a bus handler.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    //
    // Calculate the right bus number.
    //

    busHand.BusNumber = BusOffset;

    HalpWritePCIConfig(&busHand,
                       slotNum,
                       Buffer,
                       Offset,
                       Length
                       );

    return Length;
}

VOID
HalpPCIPin2ISALine (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    On the current PC implementations, the bios has already filled in
    InterruptLine as it's ISA value and there's no portable way to
    change it.

    On a DBG build we adjust InterruptLine just to ensure driver's
    don't connect to it without translating it on the PCI bus.

--*/
{
    if (!PciData->u.type0.InterruptPin) {
        return ;
    }
    HalDebugPrint(( HAL_INFO, "HAL: HalpPCIPin2ISALine - non-zero InterruptPin value\n" ));
}



VOID
HalpPCIISALine2Pin (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++

    This functions maps the device's InterruptLine to it's
    device specific InterruptPin value.

    On the current PC implementations, this information is
    fixed by the BIOS.  Just make sure the value isn't being
    editted since PCI doesn't tell us how to dynically
    connect the interrupt.

--*/
{
    if (!PciNewData->u.type0.InterruptPin) {
        return ;
    }
}

VOID
HalpSetMaxLegacyPciBusNumber(
    IN ULONG BusNumber
    )

/*++

Routine Description:

    This routine bumps the Legacy PCI bus maximum up to whatever
    is passed in.  This may be necessary because the ACPI driver
    needs to run a configuration cycle to a PCI device before the
    PCI driver loads.  This happens mostly in the context of a
    _REG method.

Arguments:

    BusNumber - max PCI bus number

Return Value:

    none

--*/
{
    if (BusNumber > HalpMaxPciBus) {
        HalpMaxPciBus = BusNumber;
    }
}

ULONG
HalpPhase0SetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine writes to PCI configuration space prior to bus handler
    installation.

Arguments:

    BusNumber   PCI Bus Number.  This is the 8 bit BUS Number which is
                bits 23-16 of the Configuration Address.  In support of
                multiple top level busses, the upper 24 bits of this
                argument will supply the index into the table of
                configuration address registers.
    SlotNumber  PCI Slot Number, 8 bits composed of the 5 bit device
                number (bits 15-11 of the configuration address) and
                the 3 bit function number (10-8).
    Buffer      Address of source data.
    Offset      Number of bytes to skip from base of PCI config area.
    Length      Number of bytes to write

Return Value:

    Returns length of data written.

Notes:

    Caller is responsible for acquiring any necessary PCI config
    spinlocks.

--*/

{
    PCI_TYPE1_CFG_BITS ConfigAddress;
    ULONG ReturnLength;
    PCI_SLOT_NUMBER slot;
    PUCHAR Bfr = (PUCHAR)Buffer;
    SAL_PAL_RETURN_VALUES RetVals;
    SAL_STATUS Stat;

    ASSERT(!(Offset & ~0xff));
    ASSERT(Length);
    ASSERT((Offset + Length) <= 256);

    if ( Length + Offset > 256 ) {
        if ( Offset > 256 ) {
            return 0;
        }
        Length = 256 - Offset;
    }

    ReturnLength = Length;
    slot.u.AsULONG = SlotNumber;

    ConfigAddress.u.AsULONG = 0;
    ConfigAddress.u.bits.BusNumber = BusNumber;
    ConfigAddress.u.bits.DeviceNumber = slot.u.bits.DeviceNumber;
    ConfigAddress.u.bits.FunctionNumber = slot.u.bits.FunctionNumber;
    ConfigAddress.u.bits.RegisterNumber = (Offset & 0xfc) >> 2;
    //ConfigAddress.u.bits.Enable = TRUE;	// This is actually segment on IA64

    if ( Offset & 0x3 ) {
        //
        // Access begins at a non-register boundary in the config
        // space.  We need to read the register containing the data
        // and rewrite only the changed data.   (I wonder if this
        // ever really happens?)
        //
        ULONG SubOffset = Offset & 0x3;
        ULONG SubLength = 4 - SubOffset;
        union {
            ULONG All;
            UCHAR Bytes[4];
        } Tmp;

        if ( SubLength > Length ) {
            SubLength = Length;
        }

        //
        // Adjust Length (remaining) and (new) Offset by amount covered
        // in this first word.
        //
        Length -= SubLength;
        Offset += SubLength;

        //
        // Get the first word (register), replace only those bytes that
        // need to be changed, then write the whole thing back out again.
        //

        Stat = HalpSalCall(SAL_PCI_CONFIG_READ, ConfigAddress.u.AsULONG, 4, 0, 0, 0, 0, 0, &RetVals);
        
        if (Stat < 0 ) {
            return(0);
        }

        Tmp.All = (ULONG)RetVals.ReturnValues[1];

        while ( SubLength-- ) {
            Tmp.Bytes[SubOffset++] = *Bfr++;
        }

        Stat = HalpSalCall(SAL_PCI_CONFIG_WRITE, ConfigAddress.u.AsULONG, 4, Tmp.All, 0, 0, 0, 0, &RetVals);

        if (Stat < 0 ) {
            return(0);
        }

        //
        // Aim ConfigAddressRegister at the next word (register).
        //
        ConfigAddress.u.bits.RegisterNumber++;
    }

    //
    // Do the majority of the transfer 4 bytes at a time.
    //
    while ( Length > sizeof(ULONG) ) {
        ULONG Tmp = *(PULONG)Bfr;
        Stat = HalpSalCall(SAL_PCI_CONFIG_WRITE, ConfigAddress.u.AsULONG, 4, Tmp, 0, 0, 0, 0, &RetVals);

        if (Stat < 0 ) {
            return(ReturnLength - Length);
        }

        ConfigAddress.u.bits.RegisterNumber++;
        Bfr += sizeof(ULONG);
        Length -= sizeof(ULONG);

    }

    //
    // Do bytes in last register.
    //
    if ( Length ) {
        union {
            ULONG All;
            UCHAR Bytes[4];
        } Tmp;
        ULONG i = 0;

        while ( Length-- ) {
            Tmp.Bytes[i++] = *(PUCHAR)Bfr++;
        }

        Stat = HalpSalCall(SAL_PCI_CONFIG_WRITE, ConfigAddress.u.AsULONG, 4, Tmp.All, 0, 0, 0, 0, &RetVals);

        if (Stat < 0 ) {
            return(ReturnLength - i);
        }
    }

    return ReturnLength;
}

ULONG
HalpPhase0GetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine reads PCI config space prior to bus handlder installation.

Arguments:

    BusNumber   PCI Bus Number.  This is the 8 bit BUS Number which is
                bits 23-16 of the Configuration Address.  In support of
                multiple top level busses, the upper 24 bits of this
                argument will supply the index into the table of
                configuration address registers.
    SlotNumber  PCI Slot Number, 8 bits composed of the 5 bit device
                number (bits 15-11 of the configuration address) and
                the 3 bit function number (10-8).
    Buffer      Address of source data.
    Offset      Number of bytes to skip from base of PCI config area.
    Length      Number of bytes to write

Return Value:

    Amount of data read.

--*/

{
    PCI_TYPE1_CFG_BITS ConfigAddress;
    PCI_TYPE1_CFG_BITS ConfigAddressTemp;
    ULONG ReturnLength;
    ULONG i;
    PCI_SLOT_NUMBER slot;
    union {
        ULONG All;
        UCHAR Bytes[4];
    } Tmp;
    SAL_PAL_RETURN_VALUES RetVals;
    SAL_STATUS Stat;

    ASSERT(!(Offset & ~0xff));
    ASSERT(Length);
    ASSERT((Offset + Length) <= 256);

    if ( Length + Offset > 256 ) {
        if ( Offset > 256 ) {
            return 0;
        }
        Length = 256 - Offset;
    }

    ReturnLength = Length;
    slot.u.AsULONG = SlotNumber;

    ConfigAddress.u.AsULONG = 0;
    ConfigAddress.u.bits.BusNumber = BusNumber;
    ConfigAddress.u.bits.DeviceNumber = slot.u.bits.DeviceNumber;
    ConfigAddress.u.bits.FunctionNumber = slot.u.bits.FunctionNumber;
    ConfigAddress.u.bits.RegisterNumber = (Offset & 0xfc) >> 2;
    //ConfigAddress.u.bits.Enable = TRUE;	// This is actually segment on IA64

    //
    // If we are being asked to read data when function != 0, check
    // first to see if this device decares itself as a multi-function
    // device.  If it doesn't, don't do this read.
    //
    if (ConfigAddress.u.bits.FunctionNumber != 0) {

        ConfigAddressTemp.u.AsULONG = 0;
        ConfigAddressTemp.u.bits.RegisterNumber = 3; // contains header type
        ConfigAddressTemp.u.bits.FunctionNumber = 0; // look at base package
        ConfigAddressTemp.u.bits.DeviceNumber = ConfigAddress.u.bits.DeviceNumber;
        ConfigAddressTemp.u.bits.BusNumber    = ConfigAddress.u.bits.BusNumber;
        //ConfigAddress.u.bits.Enable = TRUE;	// This is actually segment on IA64

        Stat = HalpSalCall(SAL_PCI_CONFIG_READ, ConfigAddress.u.AsULONG, 4, 0, 0, 0, 0, 0, &RetVals);

        if (Stat < 0 ) {
            return(ReturnLength - Length);
        }

        Tmp.All = (ULONG)RetVals.ReturnValues[1];

        if (!(Tmp.Bytes[2] & 0x80)) { // if the Header type field's multi-function bit is not set

            for (i = 0; i < Length; i++) {
                *((PUCHAR)Buffer)++ = 0xff; // Make this read as if the device isn't populated
            }

            return Length;
        }
    }

    i = Offset & 0x3;

    while ( Length ) {

        //
        // Make SAL call
        //

        Stat = HalpSalCall(SAL_PCI_CONFIG_READ, ConfigAddress.u.AsULONG, 4, 0, 0, 0, 0, 0, &RetVals);

        if (Stat < 0 ) {
            return(ReturnLength - Length);
        }

        Tmp.All = (ULONG)RetVals.ReturnValues[1];

        while ( (i < 4) && Length) {
            *((PUCHAR)Buffer)++ = Tmp.Bytes[i];
            i++;
            Length--;
        }
        i = 0;
        ConfigAddress.u.bits.RegisterNumber++;
    }
    return ReturnLength;
}

NTSTATUS
HalpSetupPciDeviceForDebugging(
    IN     PLOADER_PARAMETER_BLOCK   LoaderBlock,   OPTIONAL
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
/*++

Routine Description:

    This routine finds and initializes a PCI device to be
    used for communicating with a debugger.

    The caller fills in as much of DEBUG_DEVICE_DESCRIPTOR
    as it cares to, filling unused fields with (-1).

    This routine attempts to find a matching PCI device.  It
    matches first based on Bus and Slot, if the caller has
    provided them.  Then it matches on VendorID/DeviceID, if
    the caller has provided them.  Last, it matches on
    BaseClass/SubClass.

    This routine will fill in any unused fields in the structure
    so that the caller can know specifically which PCI
    device matched the criteria.

    If the matching PCI device is not enabled, or it is
    behind a PCI to PCI bridge that is not enabled, this
    routine makes a best-effort attempt to find a safe
    configuration that allows the device (and possibly bridges)
    to function, and enables them.

    If the PCI device implements memory mapped Base Address
    registers, this function will create a virtual to physical
    mapping for the memory ranges implied by the Base Address
    Registers and fill in the TranslatedAddress field with
    virtual pointers to the bases of the ranges.  It will then
    fill in the Type field with CmResourceTypeMemory.  And
    the Valid field with be TRUE.

    If the PCI device implements I/O port Base Address registers,
    this function will put the translated port address in
    TranslatedAddress, setting the Type field to CmResourceTypePort
    and the Valid field to TRUE.

    If the PCI device does not implement a specific Base Address
    Register, the Valid field will be FALSE.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

    STATUS_SUCCESS if the device is configured and usable.

    STATUS_NO_MORE_MATCHES if no device matched the criteria.

    STATUS_INSUFFICIENT_RESOURCES if the memory requirements
    couldn't be met.

    STATUS_UNSUCCESSFUL if the routine failed for other reasons.

--*/
{
    NTSTATUS            status;
    PCI_SLOT_NUMBER     slot;
    ULONG               i, j;
    ULONG               maxPhys;

    status = HalpSearchForPciDebuggingDevice(
                PciDevice,
                0,
                0xff,
                0x10000000,
                0xfc000000,
                0x1000,
                0xffff,
                FALSE);

    if (!NT_SUCCESS(status)) {

        //
        // We didn't find the device using a conservative
        // search.  Try a more invasive one.
        //

        status = HalpSearchForPciDebuggingDevice(
                    PciDevice,
                    0,
                    0xff,
                    0x10000000,
                    0xfc000000,
                    0x1000,
                    0xffff,
                    TRUE);
    }

    //
    // Record the Bus/Dev/Func so that we can stuff it in the
    // registry later.
    //

    if (NT_SUCCESS(status)) {

        slot.u.AsULONG = PciDevice->Slot;

        for (i = 0;
             i < MAX_DEBUGGING_DEVICES_SUPPORTED;
             i++) {

            if ((HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) &&
                (HalpPciDebuggingDevice[i].u.bits.FunctionNumber ==
                 slot.u.bits.FunctionNumber)                         &&
                (HalpPciDebuggingDevice[i].u.bits.DeviceNumber ==
                 slot.u.bits.DeviceNumber)                           &&
                (HalpPciDebuggingDevice[i].u.bits.BusNumber ==
                 PciDevice->Bus)) {

                //
                // This device has already been set up for
                // debugging.  Thus we should refuse to set
                // it up again.
                //

                return STATUS_UNSUCCESSFUL;
            }
        }

        for (i = 0;
             i < MAX_DEBUGGING_DEVICES_SUPPORTED;
             i++) {

            if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == FALSE) {

                //
                // This slot is available.
                //

                HalpPciDebuggingDevice[i].u.bits.FunctionNumber =
                    slot.u.bits.FunctionNumber;
                HalpPciDebuggingDevice[i].u.bits.DeviceNumber =
                    slot.u.bits.DeviceNumber;
                HalpPciDebuggingDevice[i].u.bits.BusNumber = PciDevice->Bus;
                HalpPciDebuggingDevice[i].u.bits.Reserved1 = TRUE;

                break;
            }
        }
    }

    //
    // Check to see if the caller wants any memory.
    //

    if (PciDevice->Memory.Length != 0) {

        if (!LoaderBlock) {
            return STATUS_INVALID_PARAMETER_1;
        }

        if (PciDevice->Memory.MaxEnd.QuadPart == 0) {
            PciDevice->Memory.MaxEnd.QuadPart = -1;
        }

        maxPhys = PciDevice->Memory.MaxEnd.HighPart ? 0xffffffff : PciDevice->Memory.MaxEnd.LowPart;
        maxPhys -= PciDevice->Memory.Length;

        //
        // The HAL APIs will always return page-aligned
        // memory.  So ignore Aligned for now.
        //

        maxPhys = (ULONG)(ULONG_PTR)PAGE_ALIGN(maxPhys);
        maxPhys += ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length);

        PciDevice->Memory.Start.HighPart = 0;
        PciDevice->Memory.Start.LowPart = (ULONG)(ULONG_PTR)
            HalpAllocPhysicalMemory(LoaderBlock,
                                    maxPhys,
                                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length),
                                    FALSE);

        if (!PciDevice->Memory.Start.LowPart) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        PciDevice->Memory.VirtualAddress =
            HalpMapPhysicalMemory(PciDevice->Memory.Start,
                                  ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length),
                                  MmNonCached);
    }

    return status;
}

VOID
HalpFindFreeResourceLimits(
    IN      ULONG   Bus,
    IN OUT  ULONG   *MinIo,
    IN OUT  ULONG   *MaxIo,
    IN OUT  ULONG   *MinMem,
    IN OUT  ULONG   *MaxMem,
    IN OUT  ULONG   *MinBus,
    IN OUT  ULONG   *MaxBus
    )
{
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    UCHAR               bus, dev, func, bytesRead;
    PCI_SLOT_NUMBER     pciSlot, targetSlot;
    ULONG               newMinMem, newMaxMem;
    ULONG               newMinIo, newMaxIo;
    ULONG               newMinBus, newMaxBus;
    UCHAR               barNo;

    pciData = (PPCI_COMMON_CONFIG)buffer;
    pciSlot.u.AsULONG = 0;
    newMinMem   = *MinMem;
    newMaxMem   = *MaxMem;
    newMinIo    = *MinIo;
    newMaxIo    = *MaxIo;
    newMinBus   = *MinBus;
    newMaxBus   = *MaxBus;

    for (dev = 0; dev < PCI_MAX_DEVICES; dev++) {
        for (func = 0; func < PCI_MAX_FUNCTION; func++) {

            pciSlot.u.bits.DeviceNumber = dev;
            pciSlot.u.bits.FunctionNumber = func;


            bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(Bus,
                                 pciSlot.u.AsULONG,
                                 pciData,
                                 0,
                                 PCI_COMMON_HDR_LENGTH);

            if (bytesRead == 0) continue;

            if (pciData->VendorID != PCI_INVALID_VENDORID) {

                switch (PCI_CONFIGURATION_TYPE(pciData)) {
                case PCI_DEVICE_TYPE:

                    //
                    // While we scan across the bus, keep track
                    // of the minimum decoder values that we've seen.
                    // This will be used if we have to configure the
                    // device.  This relies on the fact that most BIOSes
                    // assign addresses from the top down.
                    //

                    for (barNo = 0; barNo < PCI_TYPE0_ADDRESSES; barNo++) {

                        if (pciData->u.type0.BaseAddresses[barNo] &
                            PCI_ADDRESS_IO_SPACE) {

                            if (pciData->u.type0.BaseAddresses[barNo] &
                                PCI_ADDRESS_IO_ADDRESS_MASK) {

                                //
                                // This BAR is implemented
                                //

                                if ((pciData->u.type0.BaseAddresses[barNo] &
                                     PCI_ADDRESS_IO_ADDRESS_MASK) <
                                    ((newMaxIo + newMinIo) / 2)) {

                                    //
                                    // This BAR is at the bottom of the range.
                                    // Bump up the min.
                                    //

                                    newMinIo = (USHORT)MAX (newMinIo,
                                                            (pciData->u.type0.BaseAddresses[barNo] &
                                                             PCI_ADDRESS_IO_ADDRESS_MASK) + 0x100);

                                } else {

                                    //
                                    // This BAR is not at the bottom of the range.
                                    // Bump down the max.
                                    //

                                    newMaxIo = (USHORT)MIN (newMaxIo,
                                                            pciData->u.type0.BaseAddresses[barNo] &
                                                            PCI_ADDRESS_IO_ADDRESS_MASK);
                                }
                            }

                        } else {

                            if (pciData->u.type0.BaseAddresses[barNo] &
                                PCI_ADDRESS_MEMORY_ADDRESS_MASK) {

                                //
                                // The BAR is populated.
                                //

                                if ((pciData->u.type0.BaseAddresses[barNo] &
                                     PCI_ADDRESS_MEMORY_ADDRESS_MASK) <
                                    ((newMaxMem / 2) + (newMinMem / 2))) {

                                    //
                                    // This BAR is at the bottom of the range.
                                    // Bump up the min.
                                    //

                                    newMinMem = MAX (newMinMem,
                                                     (pciData->u.type0.BaseAddresses[barNo] &
                                                        PCI_ADDRESS_MEMORY_ADDRESS_MASK) + 0x10000);

                                } else {

                                    //
                                    // This BAR is not at the bottom of the range.
                                    // Bump down the max.
                                    //

                                    newMaxMem = MIN (newMaxMem,
                                                     (pciData->u.type0.BaseAddresses[barNo] &
                                                        PCI_ADDRESS_MEMORY_ADDRESS_MASK));

                                }
                            }
                        }
                    }

                    break;

                case PCI_CARDBUS_BRIDGE_TYPE:
                case PCI_BRIDGE_TYPE:

                    {
                      ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                      USHORT bridgeIoMin, bridgeIoMax;

                      if ((pciData->u.type1.SecondaryBus != 0) &&
                          (pciData->u.type1.SubordinateBus !=0) &&
                          (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                          (pciData->Command & PCI_ENABLE_IO_SPACE)) {

                        bridgeMemMin = PciBridgeMemory2Base(pciData->u.type1.MemoryBase);
                        bridgeMemMax = PciBridgeMemory2Limit(pciData->u.type1.MemoryLimit);
                        bridgeIoMin = (USHORT)PciBridgeIO2Base(pciData->u.type1.IOBase, 0);
                        bridgeIoMax = (USHORT)PciBridgeIO2Limit(pciData->u.type1.IOLimit, 0);

                        //
                        // Keep track of address space allocation.
                        //

                        if (bridgeIoMin > ((newMaxIo + newMinIo) / 2)) {
                            newMaxIo = MIN(newMaxIo, bridgeIoMin);
                        }

                        if (bridgeIoMax < ((newMaxIo + newMinIo) / 2)) {
                            newMinIo = MAX(newMinIo, bridgeIoMax) + 1;
                        }

                        if (bridgeMemMin > ((newMaxMem + newMinMem) / 2)) {
                            newMaxMem = MIN(newMaxMem, bridgeMemMin);
                        }

                        if (bridgeMemMax < ((newMaxMem + newMinMem) / 2)) {
                            newMinMem = MAX(newMinMem, bridgeMemMax) + 1;
                        }

                        //
                        // Keep track of bus numbers.
                        //

                        if (pciData->u.type1.PrimaryBus > ((newMaxBus + newMinBus) / 2)) {
                            newMaxBus = MIN(newMaxBus, pciData->u.type1.PrimaryBus);
                        }

                        if (pciData->u.type1.SubordinateBus < ((newMaxBus + newMinBus) / 2)) {
                            newMinBus = MAX(newMinBus, pciData->u.type1.SubordinateBus) + 1;
                        }
                      }

                      break;

                      default:
                        break;

                    }

                }

                if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                    (func == 0)) {
                    break;
                }
            }
        }
    }

    *MinMem = newMinMem;
    *MaxMem = newMaxMem;
    *MinIo  = newMinIo;
    *MaxIo  = newMaxIo;
    *MinBus = newMinBus;
    *MaxBus = newMaxBus;
}

NTSTATUS
HalpSetupUnconfiguredDebuggingDevice(
    IN ULONG   Bus,
    IN ULONG   Slot,
    IN ULONG   IoMin,
    IN ULONG   IoMax,
    IN ULONG   MemMin,
    IN ULONG   MemMax,
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice
    )
{

    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    ULONG               barLength, bytesRead;
    ULONG               barContents = 0;
    PHYSICAL_ADDRESS    physicalAddress;
    PCI_SLOT_NUMBER     pciSlot;
    UCHAR               barNo;

    pciSlot.u.AsULONG = Slot;
    pciData = (PPCI_COMMON_CONFIG)buffer;

    bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(Bus,
                         pciSlot.u.AsULONG,
                         pciData,
                         0,
                         PCI_COMMON_HDR_LENGTH);

    ASSERT(bytesRead != 0);

    PciDevice->Bus = Bus;
    PciDevice->Slot = pciSlot.u.AsULONG;
    PciDevice->VendorID = pciData->VendorID;
    PciDevice->DeviceID = pciData->DeviceID;
    PciDevice->BaseClass = pciData->BaseClass;
    PciDevice->SubClass = pciData->SubClass;

  //DbgPrint("Configuring device between %x - %x\n",
  //         MemMin, MemMax);

    //
    // Cycle through the BARs, turning them on if necessary,
    // and mapping them.
    //

    for (barNo = 0; barNo < PCI_TYPE0_ADDRESSES; barNo++) {

        barContents = 0xffffffff;

        PciDevice->BaseAddress[barNo].Valid = FALSE;

        HalpPhase0SetPciDataByOffset(Bus,
                                     pciSlot.u.AsULONG,
                                     &barContents,
                                     0x10 + (4 * barNo),
                                     4);

        HalpPhase0GetPciDataByOffset(Bus,
                                     pciSlot.u.AsULONG,
                                     &barContents,
                                     0x10 + (4 * barNo),
                                     4);

        if (pciData->u.type0.BaseAddresses[barNo] &
            PCI_ADDRESS_IO_SPACE) {

            //
            // This is an I/O BAR.
            //

            if (!(pciData->u.type0.BaseAddresses[barNo] &
                  PCI_ADDRESS_IO_ADDRESS_MASK)) {

                //
                // And it's empty.
                //

                barLength = (((USHORT)barContents & PCI_ADDRESS_IO_ADDRESS_MASK) - 1) ^
                    0xffff;

                //
                // Try to fit this I/O window half-way between the min and the max.
                //

                if ((ULONG)(IoMax - IoMin) >= (barLength * 3)) {

                    //
                    // There is plenty of room, make a safe guess.  Try
                    // to put it half-way between the upper and lower
                    // bounds, rounding up to the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (((IoMax + IoMin) / 2) + barLength) & (barLength -1);

                } else if (barLength >= (IoMax -
                                         ((IoMin & (barLength -1)) ?
                                            ((IoMin + barLength) & (barLength -1)) :
                                            IoMin))) {
                    //
                    // Space is tight, make a not-so-safe guess.  Try
                    // to put it at the bottom of the range, rounded
                    // up the the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        ((IoMin & (barLength -1)) ?
                                            ((IoMin + barLength) & (barLength -1)) :
                                            IoMin);
                }

                IoMin = (USHORT)pciData->u.type0.BaseAddresses[barNo];
            }

            pciData->Command |= PCI_ENABLE_IO_SPACE;

            PciDevice->BaseAddress[barNo].Type = CmResourceTypePort;
            PciDevice->BaseAddress[barNo].Valid = TRUE;
            PciDevice->BaseAddress[barNo].TranslatedAddress =
                (PUCHAR)(ULONG_PTR)(pciData->u.type0.BaseAddresses[barNo] &
                PCI_ADDRESS_IO_ADDRESS_MASK);
            PciDevice->BaseAddress[barNo].Length = barLength;

        } else {

            //
            // This is a memory BAR.
            //

            barLength = ((barContents & PCI_ADDRESS_MEMORY_ADDRESS_MASK) - 1) ^
                0xffffffff;

            if (!(pciData->u.type0.BaseAddresses[barNo] &
                  PCI_ADDRESS_MEMORY_ADDRESS_MASK)) {

                //
                // And it's empty.
                //

                if (barLength == 0) continue;

                //
                // Try to fit this memory window half-way between the min and the max.
                //

                if ((ULONG)(MemMax - MemMin) >= (barLength * 3)) {

                    //
                    // There is plenty of room, make a safe guess.  Try
                    // to put it half-way between the upper and lower
                    // bounds, rounding up to the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (ULONG)(((MemMax + MemMin) / 2)
                                 + barLength) & ~(barLength -1);

                } else if (barLength >= (ULONG)(MemMax -
                                         ((MemMin & ~(barLength -1)) ?
                                            ((MemMin + barLength) & ~(barLength-1)) :
                                            MemMin))) {
                    //
                    // Space is tight, make a not-so-safe guess.  Try
                    // to put it at the bottom of the range, rounded
                    // up the the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (ULONG)((MemMin & ~(barLength -1)) ?
                                    ((MemMin + barLength) & ~(barLength -1)) :
                                      MemMin);
                }

                MemMin = pciData->u.type0.BaseAddresses[barNo] &
                    PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            }

            pciData->Command |= PCI_ENABLE_MEMORY_SPACE;

            physicalAddress.HighPart = 0;
            physicalAddress.LowPart = pciData->u.type0.BaseAddresses[barNo]
                & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            PciDevice->BaseAddress[barNo].Type = CmResourceTypeMemory;
            PciDevice->BaseAddress[barNo].Valid = TRUE;
            PciDevice->BaseAddress[barNo].TranslatedAddress =
                HalpMapPhysicalMemory(physicalAddress,
                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(physicalAddress.LowPart, barLength),
                    MmNonCached);
            PciDevice->BaseAddress[barNo].Length = barLength;
        }
    }

    pciData->Command |= PCI_ENABLE_BUS_MASTER;

    //
    // Write back any changes we made.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 pciSlot.u.AsULONG,
                                 pciData,
                                 0,
                                 0x40);

    return STATUS_SUCCESS;
}

NTSTATUS
HalpSearchForPciDebuggingDevice(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG                        StartBusNumber,
    IN ULONG                        EndBusNumber,
    IN ULONG                        MinMem,
    IN ULONG                        MaxMem,
    IN USHORT                       MinIo,
    IN USHORT                       MaxIo,
    IN BOOLEAN                      ConfigureBridges
    )
/*++

Routine Description:

    This routine is a helper function for
    HalpSetupPciDeviceForDebugging.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

    STATUS_SUCCESS if the device is configured and usable.

    STATUS_NO_MORE_MATCHES if no device matched the criteria.

    STATUS_UNSUCCESSFUL if the routine fails for other reasons.
--*/
#define TARGET_DEVICE_NOT_FOUND 0x10000
{
    NTSTATUS            status;
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    UCHAR               bus, dev, func, bytesRead;
    PCI_SLOT_NUMBER     pciSlot, targetSlot;
    ULONG               newMinMem, newMaxMem;
    ULONG               newMinIo, newMaxIo;
    ULONG               newMinBus, newMaxBus;
    UCHAR               barNo;
    BOOLEAN             unconfigureBridge = FALSE;

    pciData = (PPCI_COMMON_CONFIG)buffer;
    pciSlot.u.AsULONG = 0;
    newMinMem = MinMem;
    newMaxMem = MaxMem;
    newMinIo = MinIo;
    newMaxIo = MaxIo;
    newMinBus = StartBusNumber;
    newMaxBus = EndBusNumber;
    bus = (UCHAR)StartBusNumber;

  //DbgPrint("HalpSearchForPciDebuggingDevice:\n"
  //         "\tMem: %x-%x\n"
  //         "\tI/O: %x-%x\n"
  //         "\tBus: %x-%x\n"
  //         "\t%s Configuring Bridges\n",
  //         MinMem, MaxMem,
  //         MinIo, MaxIo,
  //         StartBusNumber, EndBusNumber,
  //         ConfigureBridges ? "" : "Not");

    //
    // This bit stays set to 1 until we find the device.
    //
    targetSlot.u.bits.Reserved = TARGET_DEVICE_NOT_FOUND;

    while (TRUE) {

        UCHAR nextBus;

        nextBus = bus + 1;

        HalpFindFreeResourceLimits(bus,
                                   &newMinIo,
                                   &newMaxIo,
                                   &newMinMem,
                                   &newMaxMem,
                                   &newMinBus,
                                   &newMaxBus
                                   );

        for (dev = 0; dev < PCI_MAX_DEVICES; dev++) {
            for (func = 0; func < PCI_MAX_FUNCTION; func++) {

                pciSlot.u.bits.DeviceNumber = dev;
                pciSlot.u.bits.FunctionNumber = func;


                bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(bus,
                                     pciSlot.u.AsULONG,
                                     pciData,
                                     0,
                                     PCI_COMMON_HDR_LENGTH);

                if (bytesRead == 0) continue;

                if (pciData->VendorID != PCI_INVALID_VENDORID) {

                  //DbgPrint("%04x:%04x - %x/%x/%x - \tSlot: %x\n",
                  //         pciData->VendorID,
                  //         pciData->DeviceID,
                  //         pciData->BaseClass,
                  //         pciData->SubClass,
                  //         pciData->ProgIf,
                  //         pciSlot.u.AsULONG);

                    switch (PCI_CONFIGURATION_TYPE(pciData)) {
                    case PCI_DEVICE_TYPE:

                        //
                        // Match first on Bus/Dev/Func
                        //

                        if ((PciDevice->Bus == bus) &&
                            (PciDevice->Slot == pciSlot.u.AsULONG)) {

                          //DbgPrint("\n\nMatched on Bus/Slot\n\n");

                            return HalpSetupUnconfiguredDebuggingDevice(
                                        bus,
                                        pciSlot.u.AsULONG,
                                        newMinIo,
                                        newMaxIo,
                                        newMinMem,
                                        newMaxMem,
                                        PciDevice
                                        );
                        }

                        if ((PciDevice->Bus == MAXULONG) &&
                            (PciDevice->Slot == MAXULONG)) {

                            //
                            // Bus and Slot weren't specified.  Match
                            // on VID/DID.
                            //

                            if ((pciData->VendorID == PciDevice->VendorID) &&
                                (pciData->DeviceID == PciDevice->DeviceID)) {

                              //DbgPrint("\n\nMatched on Vend/Dev\n\n");

                                return HalpSetupUnconfiguredDebuggingDevice(
                                            bus,
                                            pciSlot.u.AsULONG,
                                            newMinIo,
                                            newMaxIo,
                                            newMinMem,
                                            newMaxMem,
                                            PciDevice
                                            );
                            }

                            if ((PciDevice->VendorID == MAXUSHORT) &&
                                (PciDevice->DeviceID == MAXUSHORT)) {

                                //
                                // VID/DID weren't specified.  Match
                                // on class codes.
                                //

                                if ((pciData->BaseClass == PciDevice->BaseClass) &&
                                    (pciData->SubClass == PciDevice->SubClass)) {

                                  //DbgPrint("\n\nMatched on Base/Sub\n\n");
                                    //
                                    // Further match on Programming Interface,
                                    // if specified.
                                    //

                                    if ((PciDevice->ProgIf != MAXUCHAR) &&
                                        (PciDevice->ProgIf != pciData->ProgIf)) {

                                        break;
                                    }

                                  //DbgPrint("\n\nMatched on programming interface\n\n");

                                    return HalpSetupUnconfiguredDebuggingDevice(
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                PciDevice
                                                );
                                }
                            }

                        }

                        break;

                    case PCI_CARDBUS_BRIDGE_TYPE:
                        //
                        // Cardbus bridge stuff here
                        //
                    case PCI_BRIDGE_TYPE:

                        {
                          ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                          USHORT bridgeIoMin, bridgeIoMax;

                        //DbgPrint("Found a PCI to PCI bridge\n");

                          if (!((pciData->u.type1.SecondaryBus != 0) &&
                                (pciData->u.type1.SubordinateBus !=0) &&
                                (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                                (pciData->Command & PCI_ENABLE_IO_SPACE))) {

                              //
                              // The bridge is unconfigured.
                              //

                              if (ConfigureBridges){

                                  //
                                  // We should configure it now.
                                  //

                                  status = HalpConfigurePciBridge(
                                                PciDevice,
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                MAX((UCHAR)newMinBus, (bus + 1)),
                                                newMaxBus,
                                                pciData
                                                );

                                  if (!NT_SUCCESS(status)) {
                                      break;
                                  }

                                  unconfigureBridge = TRUE;

                              } else {

                                  //
                                  // We aren't configuring bridges
                                  // on this pass.
                                  //

                                  break;
                              }

                          }

                          bridgeMemMin = PciBridgeMemory2Base(pciData->u.type1.MemoryBase);
                          bridgeMemMax = PciBridgeMemory2Limit(pciData->u.type1.MemoryLimit);
                          bridgeIoMin = (USHORT)PciBridgeIO2Base(pciData->u.type1.IOBase, 0);
                          bridgeIoMax = (USHORT)PciBridgeIO2Limit(pciData->u.type1.IOLimit, 0);

                        //DbgPrint("Configured:  I/O %x-%x  Mem %x-%x\n",
                        //         bridgeIoMin, bridgeIoMax,
                        //         bridgeMemMin, bridgeMemMax);

                          //
                          // Recurse.
                          //

                          status = HalpSearchForPciDebuggingDevice(
                              PciDevice,
                              (ULONG)pciData->u.type1.SecondaryBus,
                              (ULONG)pciData->u.type1.SubordinateBus,
                              bridgeMemMin,
                              bridgeMemMax,
                              bridgeIoMin,
                              bridgeIoMax,
                              ConfigureBridges);

                          if (NT_SUCCESS(status)) {
                              return status;
                          }

                          if (!unconfigureBridge) {

                              //
                              // Bump up the bus number so that we don't
                              // scan down the busses we just recursed into.
                              //

                              nextBus = pciData->u.type1.SubordinateBus + 1;

                          } else {

                              HalpUnconfigurePciBridge(bus,
                                                       pciSlot.u.AsULONG);
                          }
                        }

                        break;
                    default:
                        break;

                    }

                }

                if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                    (func == 0)) {
                    break;
                }
            }
        }

        if (nextBus >= EndBusNumber) {
            break;
        }

        bus = nextBus;
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
HalpReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
/*++

Routine Description:

    This routine de-allocates any resources acquired in
    HalpSetupPciDeviceForDebugging.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

--*/
{
    ULONG i;

    for (i = 0; i < PCI_TYPE0_ADDRESSES; i++) {

        if (PciDevice->BaseAddress[i].Valid &&
            PciDevice->BaseAddress[i].Type == CmResourceTypeMemory) {

            PciDevice->BaseAddress[i].Valid = FALSE;

            HalpUnmapVirtualAddress(PciDevice->BaseAddress[i].TranslatedAddress,
                                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                        PciDevice->BaseAddress[i].TranslatedAddress,
                                        PciDevice->BaseAddress[i].Length));
        }
    }

    return STATUS_SUCCESS;
}

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine fills in the HalPrivateDispatchTable
    with the functions needed for debugging through
    PCI devices.

Arguments:

    LoaderBlock - The Loader Block

Return Value:

--*/
{

    KdSetupPciDeviceForDebugging = HalpSetupPciDeviceForDebugging;
    KdReleasePciDeviceForDebugging = HalpReleasePciDeviceForDebugging;

    KdGetAcpiTablePhase0 = HalpGetAcpiTablePhase0;
    KdMapPhysicalMemory64 = HalpMapPhysicalMemory64;

    KdCheckPowerButton = HalpCheckPowerButton;
}

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    ULONG               disposition;
    ULONG               bus;
    UCHAR               i;
    PCI_SLOT_NUMBER     slot;
    NTSTATUS            status;
    BOOLEAN             debuggerFound = FALSE;

    PAGED_CODE();

    for (i = 0;
         i < MAX_DEBUGGING_DEVICES_SUPPORTED;
         i++) {

        if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) {
            //
            // Must be using a PCI device for a debugger.
            //
            debuggerFound = TRUE;
        }
    }

    if (!debuggerFound) {
        return;
    }

    //
    // Open PCI service key.
    //

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\PCI");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Get the right key

    RtlInitUnicodeString (&UnicodeString,
                          L"Debug");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               BaseHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey (&Handle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_VOLATILE,
                          &disposition);

    ZwClose(BaseHandle);
    BaseHandle = Handle;

    ASSERT(disposition == REG_CREATED_NEW_KEY);

    if (!NT_SUCCESS(status)) {
        return;
    }

    for (i = 0;
         i < MAX_DEBUGGING_DEVICES_SUPPORTED;
         i++) {

        if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) {

            //
            // This entry is populated.  Create a key for it.
            //

            RtlInitUnicodeString (&UnicodeString,
                                  L"0");

            (*(PCHAR)&(UnicodeString.Buffer[0])) += i;

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       BaseHandle,
                                       (PSECURITY_DESCRIPTOR) NULL);

            status = ZwCreateKey (&Handle,
                                  KEY_READ,
                                  &ObjectAttributes,
                                  0,
                                  (PUNICODE_STRING) NULL,
                                  REG_OPTION_VOLATILE,
                                  &disposition);

            ASSERT(disposition == REG_CREATED_NEW_KEY);

            //
            // Fill in the values below this key.
            //

            bus = HalpPciDebuggingDevice[i].u.bits.BusNumber;

            RtlInitUnicodeString (&UnicodeString,
                                  L"Bus");

            status = ZwSetValueKey (Handle,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &bus,
                                    sizeof(ULONG));

            //ASSERT(NT_SUCCESS(status));

            slot.u.AsULONG = 0;
            slot.u.bits.FunctionNumber = HalpPciDebuggingDevice[i].u.bits.FunctionNumber;
            slot.u.bits.DeviceNumber = HalpPciDebuggingDevice[i].u.bits.DeviceNumber;

            RtlInitUnicodeString (&UnicodeString,
                                  L"Slot");

            status = ZwSetValueKey (Handle,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &slot.u.AsULONG,
                                    sizeof(ULONG));

            //ASSERT(NT_SUCCESS(status));

            ZwClose(Handle);
        }
    }

    ZwClose(BaseHandle);
    return;
}

NTSTATUS
HalpConfigurePciBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    )
{
    USHORT  memUnits = 0;
    ULONG   memSize;

    PciData->u.type1.PrimaryBus = (UCHAR)Bus;
    PciData->u.type1.SecondaryBus = (UCHAR)BusMin;
    PciData->u.type1.SubordinateBus = (UCHAR)(MIN(BusMax, (BusMin + 2)));

    PciData->Command &= ~PCI_ENABLE_BUS_MASTER;

  //DbgPrint("HalpConfigurePciBridge: P: %x  S: %x  S: %x\n"
  //         "\tI/O  %x-%x  Mem %x-%x  Bus %x-%x\n",
  //         PciData->u.type1.PrimaryBus,
  //         PciData->u.type1.SecondaryBus,
  //         PciData->u.type1.SubordinateBus,
  //         IoMin, IoMax,
  //         MemMin, MemMax,
  //         BusMin, BusMax);

    //
    // Only enable I/O on the bridge if we are looking for
    // something besides a 1394 controller.
    //

    if (!((PciDevice->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
          (PciDevice->SubClass == PCI_SUBCLASS_SB_IEEE1394))) {

        if (((IoMax & 0xf000) - (IoMin & 0xf000)) >= 0X1000) {

            //
            // There is enough I/O space here to enable
            // an I/O window.
            //

            PciData->u.type1.IOBase =
                (UCHAR)((IoMax & 0xf000) >> 12) - 1;
            PciData->u.type1.IOLimit = PciData->u.type1.IOBase;

            PciData->Command |= PCI_ENABLE_IO_SPACE;
            PciData->Command |= PCI_ENABLE_BUS_MASTER;
        }
    }

    //
    // Enable a memory window if possible.
    //

    memSize = ((MemMax + 1) & 0xfff00000) - (MemMin & 0xfff00000);

    if (memSize >= 0x100000) {

        memUnits = 1;
    }

    if (memSize >= 0x400000) {

        memUnits = 4;
    }

    if (memUnits > 0) {

        //
        // There is enough space.
        //

        PciData->u.type1.MemoryBase =
            (USHORT)((MemMax & 0xfff00000) >> 16) - (memUnits << 4);

        PciData->u.type1.MemoryLimit = PciData->u.type1.MemoryBase + ((memUnits- 1) << 4);

        PciData->Command |= PCI_ENABLE_MEMORY_SPACE;
        PciData->Command |= PCI_ENABLE_BUS_MASTER;

    }

    if (PciData->Command & PCI_ENABLE_BUS_MASTER) {

        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot,
                                     PciData,
                                     0,
                                     0x24);

        return STATUS_SUCCESS;

    } else {
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
HalpUnconfigurePciBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    )
{
    UCHAR   buffer[0x20] = {0};

    //
    // Zero the command register.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                 2);

    //
    // Zero the address space and bus number registers.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u),
                                 0x20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\pmisabus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmapic.c

Abstract:

    Implements functions specific to ISA busses
    in ACPI-APIC machines.

Author:

    Jake Oshins (jakeo) 11-October-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"

NTSTATUS
TranslateGlobalVectorToIsaVector(
    IN  ULONG   GlobalVector,
    OUT PULONG  IsaVector
    );

NTSTATUS
HalacpiIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalacpiIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

extern ULONG HalpPicVectorRedirect[];
extern FADT HalpFixedAcpiDescTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TranslateGlobalVectorToIsaVector)
#pragma alloc_text(PAGE, HalacpiIrqTranslateResourceRequirementsIsa)
#pragma alloc_text(PAGE, HalacpiIrqTranslateResourcesIsa)
#pragma alloc_text(PAGE, HalacpiGetInterruptTranslator)
#endif

#define TranslateIsaVectorToGlobalVector(vector)  \
            (HalpPicVectorRedirect[vector])

NTSTATUS
TranslateGlobalVectorToIsaVector(
    IN  ULONG   GlobalVector,
    OUT PULONG  IsaVector
    )
{
    UCHAR   i;

    for (i = 0; i < PIC_VECTORS; i++) {

        if (HalpPicVectorRedirect[i] == GlobalVector) {

            *IsaVector = i;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}


NTSTATUS
HalacpiIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourceRequirementsRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    PIO_RESOURCE_DESCRIPTOR modSource, target, rootTarget;
    NTSTATUS                status;
    BOOLEAN                 deleteResource;
    ULONG                   sourceCount = 0;
    ULONG                   targetCount = 0;
    ULONG                   resource, resourceLength;
    ULONG                   rootCount;
    ULONG                   irq, startIrq, endIrq;
    ULONG                   maxTargets;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    maxTargets = Source->u.Interrupt.MaximumVector -
                     Source->u.Interrupt.MinimumVector + 3;

    resourceLength = sizeof(IO_RESOURCE_DESCRIPTOR) * maxTargets;

    modSource = ExAllocatePoolWithTag(PagedPool, resourceLength, HAL_POOL_TAG);

    if (!modSource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modSource, resourceLength);

    //
    // Is the PIC_SLAVE_IRQ in this resource?
    //
    if ((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_IRQ) &&
        (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_IRQ)) {

        //
        // Clip the maximum
        //
        if (Source->u.Interrupt.MinimumVector < PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                Source->u.Interrupt.MinimumVector;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                PIC_SLAVE_IRQ - 1;

            sourceCount++;
        }

        //
        // Clip the minimum
        //
        if (Source->u.Interrupt.MaximumVector > PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                Source->u.Interrupt.MaximumVector;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                PIC_SLAVE_IRQ + 1;

            sourceCount++;
        }

        //
        // In ISA machines, the PIC_SLAVE_IRQ is rerouted
        // to PIC_SLAVE_REDIRECT.  So find out if PIC_SLAVE_REDIRECT
        // is within this list. If it isn't we need to add it.
        //
        if (!((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_REDIRECT) &&
             (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_REDIRECT))) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector = PIC_SLAVE_REDIRECT;
            modSource[sourceCount].u.Interrupt.MaximumVector = PIC_SLAVE_REDIRECT;

            sourceCount++;
        }

    } else {

        *modSource = *Source;
        sourceCount = 1;
    }

    //
    // Clip out the SCI vector, if it is here.
    //

    for (resource = 0; resource < sourceCount; resource++) {

        if ((modSource[resource].u.Interrupt.MinimumVector <=
                HalpFixedAcpiDescTable.sci_int_vector) &&
            (modSource[resource].u.Interrupt.MaximumVector >=
                HalpFixedAcpiDescTable.sci_int_vector)) {

            //
            // The SCI vector is within this range.
            //

            if (modSource[resource].u.Interrupt.MinimumVector <
                    HalpFixedAcpiDescTable.sci_int_vector) {

                //
                // Put a new range on the end of modSource.
                //

                modSource[sourceCount].u.Interrupt.MinimumVector =
                    modSource[resource].u.Interrupt.MinimumVector;

                modSource[sourceCount].u.Interrupt.MaximumVector =
                    HalpFixedAcpiDescTable.sci_int_vector - 1;

                sourceCount++;
            }

            if (modSource[resource].u.Interrupt.MaximumVector >
                    HalpFixedAcpiDescTable.sci_int_vector) {

                //
                // Put a new range on the end of modSource.
                //

                modSource[sourceCount].u.Interrupt.MinimumVector =
                    HalpFixedAcpiDescTable.sci_int_vector + 1;

                modSource[sourceCount].u.Interrupt.MaximumVector =
                    modSource[resource].u.Interrupt.MaximumVector;

                sourceCount++;
            }

            //
            // Now remove the range that we just broke up.
            //

            RtlMoveMemory(modSource + resource,
                          modSource + resource + 1,
                          sizeof(IO_RESOURCE_DESCRIPTOR) *
                            (sourceCount - resource));

            sourceCount--;
        }
    }


    target = ExAllocatePoolWithTag(PagedPool, resourceLength, HAL_POOL_TAG);

    if (!target) {
        ExFreePool(modSource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(target, resourceLength);

    //
    // Now translate each range from ISA vectors to ACPI
    // "global system interrupt vectors."  Since GSIVs aren't
    // necessarily contiguous with respect to the ISA vectors,
    // this may involve breaking each range up into smaller
    // ranges, each independently translated into the GSIV space.
    //
    for (resource = 0; resource < sourceCount; resource++) {

        //
        // For each existing resource, start with the minimum
        // and maximum, unchanged.
        //

        irq    = modSource[resource].u.Interrupt.MinimumVector;
        endIrq = modSource[resource].u.Interrupt.MaximumVector;

        do {

            //
            // Now cycle through every IRQ in this range, testing
            // to see if its translated value is contiguous
            // with respect to the translated value of the next
            // IRQ in the range.
            //

            startIrq = irq;

            for (; irq < endIrq; irq++) {

                if (TranslateIsaVectorToGlobalVector(irq) + 1 !=
                    TranslateIsaVectorToGlobalVector(irq + 1)) {

                    //
                    // This range is not contiguous.  Stop now
                    // and create a target range.
                    //

                    break;
                }
            }

            //
            // Clone the source descriptor
            //
            target[targetCount] = *Source;

            //
            // Fill in the relevant changes.
            //
            target[targetCount].u.Interrupt.MinimumVector =
                TranslateIsaVectorToGlobalVector(startIrq);

            target[targetCount].u.Interrupt.MaximumVector =
                TranslateIsaVectorToGlobalVector(irq);

			ASSERT(target[targetCount].u.Interrupt.MinimumVector <=
			         target[targetCount].u.Interrupt.MaximumVector);

            targetCount++;

        } while (irq != endIrq);
    }

    *TargetCount = targetCount;

    if (targetCount > 0) {

        *Target = target;

    } else {

        ExFreePool(target);
    }

    ExFreePool(modSource);
    return STATUS_SUCCESS;
}

NTSTATUS
HalacpiIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourcesRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    NTSTATUS    status;
    BOOLEAN     usePicSlave = FALSE;
    ULONG       i;
    ULONG       vector;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // Copy everything
    //
    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        Target->u.Interrupt.Level  =
            TranslateIsaVectorToGlobalVector(Source->u.Interrupt.Level);

        Target->u.Interrupt.Vector =
            TranslateIsaVectorToGlobalVector(Source->u.Interrupt.Vector);

        break;

    case TranslateParentToChild:

        status = TranslateGlobalVectorToIsaVector(Source->u.Interrupt.Level,
                                                  &vector);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        Target->u.Interrupt.Level = vector;

        status = TranslateGlobalVectorToIsaVector(Source->u.Interrupt.Vector,
                                                  &vector);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        Target->u.Interrupt.Vector = vector;

        //
        // Because the ISA interrupt controller is
        // cascaded, there is one case where there is
        // a two-to-one mapping for interrupt sources.
        // (On a PC, both 2 and 9 trigger vector 9.)
        //
        // We need to account for this and deliver the
        // right value back to the driver.
        //

        if (Target->u.Interrupt.Level == PIC_SLAVE_REDIRECT) {

            //
            // Search the Alternatives list.  If it contains
            // PIC_SLAVE_IRQ but not PIC_SLAVE_REDIRECT,
            // we should return PIC_SLAVE_IRQ.
            //

            for (i = 0; i < AlternativesCount; i++) {

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_REDIRECT) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_REDIRECT)) {

                    //
                    // The list contains, PIC_SLAVE_REDIRECT.  Stop
                    // looking.
                    //

                    usePicSlave = FALSE;
                    break;
                }

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_IRQ) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_IRQ)) {

                    //
                    // The list contains, PIC_SLAVE_IRQ.  Use it
                    // unless we find PIC_SLAVE_REDIRECT later.
                    //

                    usePicSlave = TRUE;
                }
            }

            if (usePicSlave) {

                Target->u.Interrupt.Level  = PIC_SLAVE_IRQ;
                Target->u.Interrupt.Vector = PIC_SLAVE_IRQ;
            }
        }

        break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HalacpiGetInterruptTranslator(
	IN INTERFACE_TYPE ParentInterfaceType,
	IN ULONG ParentBusNumber,
	IN INTERFACE_TYPE BridgeInterfaceType,
	IN USHORT Size,
	IN USHORT Version,
	OUT PTRANSLATOR_INTERFACE Translator,
	OUT PULONG BridgeBusNumber
	)
/*++

Routine Description:


Arguments:

	ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

	ParentBusNumber - The number of the bus the bridge lives on.

	ParentSlotNumber - The slot number the bridge lives in (where valid).

	BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

	ResourceType - The resource type we want to translate.

	Size - The size of the translator buffer.

	Version - The version of the translator interface requested.

	Translator - Pointer to the buffer where the translator should be returned

	BridgeBusNumber - Pointer to where the bus number of the bridge bus should be returned

Return Value:

    Returns the status of this operation.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(ParentInterfaceType);
    UNREFERENCED_PARAMETER(ParentBusNumber);

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof (TRANSLATOR_INTERFACE));

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
	case InterfaceTypeUndefined:   // special "IDE" cookie

        //
        // Pass back an interface for an IRQ translator for
        // the (E)ISA interrupts.
        //
        RtlZeroMemory(Translator, sizeof (TRANSLATOR_INTERFACE));

        Translator->Size = sizeof (TRANSLATOR_INTERFACE);
        Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
        Translator->InterfaceReference = &HalTranslatorReference;
        Translator->InterfaceDereference = &HalTranslatorDereference;
        Translator->TranslateResources = &HalacpiIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements = &HalacpiIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\sratnuma.c ===
//
// Get the IA64 versions of the following files.
//

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

//
// Use common code.
//

#include "..\..\halacpi\sratnuma.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\pmsapic.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmsapic.c

Abstract:

    Implements various SAPIC-ACPI functions.

Author:

    Todd Kjos (Hewlett-Packard) 20-Apr-1998

    Based on I386 version of pmapic.c:
      Jake Oshins (jakeo) 19-May-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "iosapic.h"
#include "xxacpi.h"
#include "ixsleep.h"

PMAPIC HalpApicTable;

struct  _IOAPIC_DEBUG_TABLE
{
    PIO_INTR_CONTROL    IoIntrControl;
    PIO_SAPIC_REGS      IoSapicRegs;

}   *HalpApicDebugAddresses;

ULONG
DetectAcpiMP(
    OUT PBOOLEAN IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitMPInfo(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PMAPIC ApicTable
    );

BOOLEAN
HalpVerifyIoSapic(
    IN PUCHAR BaseAddress
    );
VOID
HalpSaveInterruptControllerState(
    VOID
    );

VOID
HalpRestoreInterruptControllerState(
    VOID
    );

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    );

VOID
HalpSetCPEVectorState(
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags
    );

VOID
HalpProcessLocalSapic(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PPROCLOCALSAPIC ProcLocalSapic
    );

VOID
HalpProcessIoSapic(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PIOSAPIC IoSapic
    );

VOID
HalpProcessIsaVector(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PISA_VECTOR IsaVector
    );

VOID
HalpProcessPlatformInt(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PPLATFORM_INTERRUPT PlatformInt
    );

extern UCHAR  rgzNoApicTable[];
extern UCHAR  rgzNoApic[];
extern UCHAR  rgzApicNotVerified[];
extern ULONG HalpPicVectorRedirect[];

struct _MPINFO HalpMpInfo;
extern ULONG HalpPicVectorFlags[];
extern ULONG HalpIpiClock;
extern BOOLEAN HalpHiberInProgress;

// from pmdata.c: CPE related.
extern ULONG  HalpCPEIntIn[];
extern USHORT HalpCPEDestination[];
extern ULONG  HalpCPEVectorFlags[];
extern UCHAR  HalpCPEIoSapicVector[];
extern ULONG  HalpMaxCPEImplemented;

BOOLEAN HalpPicStateIntact = TRUE;

PIO_INTR_CONTROL HalpIoSapicList = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DetectAcpiMP)
#pragma alloc_text(INIT, HalpInitMPInfo)
#pragma alloc_text(INIT, HalpProcessLocalSapic)
#pragma alloc_text(INIT, HalpProcessIoSapic)
#pragma alloc_text(INIT, HalpProcessIsaVector)
#pragma alloc_text(INIT, HalpProcessPlatformInt)
#pragma alloc_text(PAGELK, HalpVerifyIoSapic)
#pragma alloc_text(PAGELK, HalpSaveInterruptControllerState)
#pragma alloc_text(PAGELK, HalpRestoreInterruptControllerState)
#pragma alloc_text(PAGELK, HalpSetInterruptControllerWakeupState)
#pragma alloc_text(PAGELK, HalpAcpiPicStateIntact)
#endif


ULONG
DetectAcpiMP(
    OUT PBOOLEAN IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    UCHAR ApicVersion, index, processorNumber;
    PUCHAR  LocalApic;
    NTSTATUS status;

    //
    // Make sure there is an SAPIC Table
    //

    HalpApicTable = HalpGetAcpiTablePhase0(LoaderBlock, APIC_SIGNATURE);

    if (HalpApicTable == NULL) {
        HalDisplayString(rgzNoApicTable);
        KeBugCheckEx(ACPI_BIOS_ERROR, 0x11, 10, 0, 0);
        return(FALSE);
    }

    HalDebugPrint(( HAL_INFO, "HAL: Found a MADT table at %p\n", HalpApicTable ));

    HalDebugPrint(( HAL_INFO, "HAL: Signature: %x      Length: %x\n",
                    HalpApicTable->Header.Signature,
                    HalpApicTable->Header.Length ));

    HalDebugPrint(( HAL_INFO, "HAL: OEMID: %s\n", HalpApicTable->Header.OEMID ));

    // We have a SAPIC table. Initialize the interrupt info structure

    HalpInitMPInfo(LoaderBlock, HalpApicTable);

    if (HalpMpInfo.IoSapicCount == 0) {
        //
        //  There are no IO Sapics.
        //
        //  Should we allow this case on the theory that
        //  that all the interrupts are connected to LINTx pins on the CPU?
        //
        HalDebugPrint(( HAL_ERROR, rgzNoApic ));
        return (FALSE);
    }

    if (HalpMpInfo.ProcessorCount == 0) {

        KeBugCheckEx(ACPI_BIOS_ERROR, 0x11, 11, 0, 0);
    }

    //
    // Initialize NtProcessorNumber in the order that we are going to process
    // them in HalStartNextProcessor.  The BSP is 0 and the rest are numbered
    // in the order the Local SAPICs appear in the MADT starting at 1.
    //

    processorNumber = 1;
    for (index = 0; index < HalpMpInfo.ProcessorCount; index++) {

        if (HalpProcessorInfo[index].LocalApicID == (USHORT)PCR->HalReserved[PROCESSOR_ID_INDEX]) {

            HalpProcessorInfo[index].NtProcessorNumber = 0;

        } else {

            HalpProcessorInfo[index].NtProcessorNumber = processorNumber++;
        }
    }

    *IsConfiguredMp = (HalpMpInfo.ProcessorCount > 1 ? TRUE : FALSE);
    return TRUE;
}

#define IO_SAPIC_REGS_SIZE 4096


VOID
HalpInitMPInfo(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PMAPIC ApicTable
    )
/*++
Routine Description:
    This routine initializes a HAL specific data structure that is
    used by the HAL to simplify access to MP information.

Arguments:
    SapicTable Pointer to the SAPIC table.

 Return Value:
     None

*/
{
    PAPICTABLE  TablePtr;
    ULONG i;

    HalpMpInfo.ProcessorCount = 0;
    HalpMpInfo.IoSapicCount = 0;

    // Walk the Multiple Apic table...

    TablePtr = (PAPICTABLE) ApicTable->APICTables;

    // Loop ends when TraversePtr is off the end of the table...
    while ((UINT_PTR)TablePtr <
           ((UINT_PTR)ApicTable + ApicTable->Header.Length)) {

        if (TablePtr->Type == LOCAL_SAPIC) {

            HalpProcessLocalSapic(LoaderBlock, (PPROCLOCALSAPIC)TablePtr);

        } else if (TablePtr->Type == IO_SAPIC) {

            HalpProcessIoSapic(LoaderBlock, (PIOSAPIC)TablePtr);

        } else if (TablePtr->Type == ISA_VECTOR_OVERRIDE) {

            HalpProcessIsaVector(LoaderBlock, (PISA_VECTOR)TablePtr);

        } else if (TablePtr->Type == PLATFORM_INTERRUPT_SOURCE)  {

            HalpProcessPlatformInt(LoaderBlock, (PPLATFORM_INTERRUPT)TablePtr);

        } else {

           HalDebugPrint(( HAL_ERROR, "HAL: Processing MADT - Skip Table %p: Type = %d, Length = %d\n", TablePtr, TablePtr->Type, TablePtr->Length ));
        }

        (UINT_PTR)TablePtr += TablePtr->Length;
    }

    //
    // Check if there is Interrupt Source Override entry. If there is, force the
    // new flags into the SAPIC state. This is done now because of the possibility
    // the firmware can place the ISO Vector Override entry ahead of IOSAPIC entry.
    //
    for (i = 0; i < PIC_VECTORS; i++) {
        if (HalpPicVectorFlags[i]) {
            HaliSetVectorState( HalpPicVectorRedirect[i],
                                HalpPicVectorFlags[i]
                              );
        }
    }

}

VOID
HalpProcessLocalSapic(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PPROCLOCALSAPIC ProcLocalSapic
    )
{
    USHORT  LID;
    ULONG ProcessorNum;

    if (ProcLocalSapic->Length != PROCESSOR_LOCAL_SAPIC_LENGTH) {
        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpProcessLocalSapic - Invalid Length %p: Expected %d, Found %d\n",
                        ProcLocalSapic,
                        PROCESSOR_LOCAL_SAPIC_LENGTH,
                        ProcLocalSapic->Length ));
        return;
    }

    // Make sure processor is enabled...
    if (!(ProcLocalSapic->Flags & PLAF_ENABLED)) {

        return;
    }

    // It is.  Bump the count and store the LID value for IPIs

    LID = (ProcLocalSapic->APICID << 8) | ProcLocalSapic->APICEID;

    HalpProcessorInfo[HalpMpInfo.ProcessorCount].AcpiProcessorID = ProcLocalSapic->ACPIProcessorID;
    HalpProcessorInfo[HalpMpInfo.ProcessorCount].LocalApicID = LID;

    HalpMpInfo.ProcessorCount++;

    HalDebugPrint(( HAL_INFO,
                    "HAL: Found a processor-local SAPIC: %p LID=%x\n",
                    ProcLocalSapic,
                    LID ));
}

VOID
HalpProcessIoSapic(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PIOSAPIC IoSapic
    )
{
    ULONG IntiBase,RedirEntries;
    PHYSICAL_ADDRESS IoSapicPhys;
    PVOID IoSapicBase;
    UINT_PTR IoSapicPhysBase;
    PIO_SAPIC_REGS SapicRegs;
    PIO_INTR_CONTROL IoIntrControl;
    ULONG   i;

    union {
        ULONG        raw;
        SAPIC_VERSION version;
    } versionUnion;

    if (IoSapic->Length != IO_SAPIC_LENGTH) {

        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpProcessIoSapic - Invalid Length %p: Expected %d, Found %d\n",
                        IoSapic,
                        IO_SAPIC_LENGTH,
                        IoSapic->Length ));

        return;
    }

    HalDebugPrint(( HAL_INFO, "HAL: Found an IO SAPIC: %p\n", IoSapic ));

    // Map IO Sapic Registers...
    IntiBase = IoSapic->SystemVectorBase;
    IoSapicPhysBase = IoSapic->IOSAPICAddress;
    IoSapicPhys.QuadPart = (UINT_PTR)IoSapicPhysBase;
    IoSapicBase = HalpMapPhysicalMemory( IoSapicPhys,
                                ADDRESS_AND_SIZE_TO_SPAN_PAGES(IoSapicPhys.LowPart, IO_SAPIC_REGS_SIZE),
                                MmNonCached);
    ASSERT(IoSapicBase);

    SapicRegs = (PIO_SAPIC_REGS)IoSapicBase;

    if (!SapicRegs) {
        HalDebugPrint(( HAL_ERROR, "HAL: Couldn't map the I/O Sapic\n" ));
        return;
    }

    // Read the IO Sapic version and extract the number of redirection table entries
    SapicRegs->RegisterSelect = IO_VERS_REGISTER;
    SapicRegs->RegisterWindow = 0;
    versionUnion.raw = SapicRegs->RegisterWindow;

    //
    // CPQMOD_JL001 - Incorrect count - hw provide max rte index not
    // count.
    //
    //RedirEntries = versionUnion.version.MaxRedirEntries;
    RedirEntries = versionUnion.version.MaxRedirEntries + 1;

    if (HalpVerifyIoSapic((PUCHAR)SapicRegs)) {

        // Allocate and fill out a IO Sapic structure
        PHYSICAL_ADDRESS    physicalAddress;

        physicalAddress.QuadPart = (LONGLONG)HalpAllocPhysicalMemory(
            LoaderBlock,
            ~0,
            BYTES_TO_PAGES(sizeof(IO_INTR_CONTROL) + (RedirEntries*sizeof(IOSAPICINTI))),
            FALSE );

        if (physicalAddress.QuadPart == 0)  {
            HalDebugPrint(( HAL_ERROR, "HAL: Couldn't allocate memory for the IO Sapic structures\n" ));
            return;
        }

        IoIntrControl = (PIO_INTR_CONTROL)HalpMapPhysicalMemory(
            physicalAddress,
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(physicalAddress.LowPart, sizeof(IO_INTR_CONTROL) + (RedirEntries*sizeof(IOSAPICINTI))),
            MmCached );

        ASSERT(IoIntrControl);

        IoIntrControl->IntiBase = IntiBase;
        IoIntrControl->IntiMax  = IntiBase + RedirEntries - 1;
        IoIntrControl->RegBaseVirtual = IoSapicBase;
        IoIntrControl->RegBasePhysical = IoSapicPhys;
        IoIntrControl->IntrMethods = &HalpIoSapicMethods;
        IoIntrControl->InterruptAffinity = ~0;
        IoIntrControl->flink = NULL;

        //
        // Mark all vectors as Free
        //
        RtlFillMemory(IoIntrControl->FreeVectors, sizeof(IoIntrControl->FreeVectors), 0xFF);

        for (i = 0; i < RedirEntries; i++) {
            IoIntrControl->Inti[i].Vector =
                DELIVER_FIXED | ACTIVE_LOW | LEVEL_TRIGGERED;
            IoIntrControl->Inti[i].Destination = 0;
            IoIntrControl->Inti[i].GlobalVector = 0;

            //
            // CPQMOD_JL002 - Fix for using the rte and not the
            // SystemVector.
            //
            //IoIntrControl->IntrMethods->MaskEntry(IoIntrControl,IntiBase+i);
            IoIntrControl->IntrMethods->MaskEntry(IoIntrControl,i);
        }

        // Insert structure into list.  Since we are running on P0 at
        // Phase0 initialization, we can assume that no one else is
        // modifying this list therefore no synchronization is needed.
        if (HalpIoSapicList == NULL) {
            HalpIoSapicList = IoIntrControl;
        } else {
            PIO_INTR_CONTROL *LastLink;
            PIO_INTR_CONTROL IoSapicListEntry;
            LastLink = &HalpIoSapicList;
            IoSapicListEntry = HalpIoSapicList;
            while (IoSapicListEntry != NULL) {

                if (IoSapicListEntry->IntiBase > IoIntrControl->IntiMax) {
                    // Insert new entry before current entry
                    IoIntrControl->flink = *LastLink;
                    *LastLink = IoIntrControl;
                    break;
                } else {
                    LastLink = &IoSapicListEntry->flink;
                    IoSapicListEntry = IoSapicListEntry->flink;
                }
            }
            if (IoSapicListEntry == NULL) {
                // We got to the end of the list.  The new entry goes
                // after the last entry...
                *LastLink = IoIntrControl;
            }
        }

        HalpMpInfo.IoSapicCount++;

    } else {
        // The Io Sapic is not there, ignore this entry in the table
        HalDebugPrint(( HAL_ERROR, rgzApicNotVerified ));
        HalpUnmapVirtualAddress(IoSapicBase, ADDRESS_AND_SIZE_TO_SPAN_PAGES(IoSapicBase, IO_SAPIC_REGS_SIZE));
    }
}

VOID
HalpProcessIsaVector(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PISA_VECTOR IsaVector
    )
{
    if (IsaVector->Length != ISA_VECTOR_OVERRIDE_LENGTH) {

        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpProcessIsaVector - Invalid Length %p: Expected %d, Found %d\n",
                        IsaVector,
                        ISA_VECTOR_OVERRIDE_LENGTH,
                        IsaVector->Length ));

        return;
    }

    //
    // Found an ISA vector redirection entry.
    //

    HalpPicVectorRedirect[IsaVector->Source] =
        IsaVector->GlobalSystemInterruptVector;

    HalpPicVectorFlags[IsaVector->Source] = IsaVector->Flags;

    HalDebugPrint(( HAL_INFO, "HAL: Found an ISA VECTOR: %p, %x -> %x, flags: %x\n",
                    IsaVector,
                    IsaVector->Source,
                    IsaVector->GlobalSystemInterruptVector,
                    IsaVector->Flags ));
}

VOID
HalpProcessPlatformInt(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PPLATFORM_INTERRUPT PlatformInt
    )
{
    if (PlatformInt->Length != PLATFORM_INTERRUPT_SOURCE_LENGTH) {

        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpProcessPlatformInt - Invalid Length %p: Expected %d, Found %d\n",
                        PlatformInt,
                        PLATFORM_INTERRUPT_SOURCE_LENGTH,
                        PlatformInt->Length ));

        return;
    }

    //
    // Process a Corrected Platform Error Interrupt Source structure.
    //

    if (PlatformInt->InterruptType == PLATFORM_INT_CPE) {


        //
        // Does this platform have more (than what we expected) number of CPE sources?
        //

        if ( HalpMaxCPEImplemented >= HALP_CPE_MAX_INTERRUPT_SOURCES ) {

            HalDebugPrint(( HAL_ERROR,
                        "HAL: Platform Interrupt Source %p skipped due to overflow: %ld >= HALP_CPE_MAX_INTERRUPT_SOURCES\n", PlatformInt, HalpMaxCPEImplemented ));

            return;
        }

        //
        // Save the input pin number of SAPIC for this CPE source
        //

        HalpCPEIntIn[HalpMaxCPEImplemented] = (ULONG)PlatformInt->GlobalVector;

        //
        // Save the Flags for this CPE source
        //

        HalpCPEVectorFlags[HalpMaxCPEImplemented] = (ULONG)PlatformInt->Flags;

        //
        // Save the IO Sapic Vector (that BIOS expects OS to use) for this platform CMC source
        //

        HalpCPEIoSapicVector[HalpMaxCPEImplemented] = (UCHAR)PlatformInt->IOSAPICVector;

// Thierry - WARNING - 09/19/2000
//    NT HAL ignores the IO SAPIC vector field for the platform interrupt sources.
//    NT imposes the CPEI_VECTOR value for Corrected Machine Errors interrupt vector, for all
//    the destination processors. Actually, the current default is to attach all the processors
//    IDT[CPEI_VECTOR] with the HAL default ISR - HalpCPEIHandler for the CPE interrupt model.
//    We will connect the ISR only for the destination processors after testing if judged valid.
//    The rationales are:
//       - IOSAPICVector was mostly added in the specs by Intel for IA64 PMI interrupt sources.
//         These PMI interrupts are not visible by NT.
//       - NT has no infrastructure at this time to support vector registration for FW/chipset
//         generated external interrupts visible to NT.
//       - Having the FW specifying the vector requires the HAL to control the specified
//         value with its current IDT[] related resources usage and defines actions in case
//         of conficts.
//

        HalDebugPrint(( HAL_INFO, "HAL: CPE source VECTOR: %x. HAL imposes VECTOR: %x\n",
                                  HalpCPEIoSapicVector[HalpMaxCPEImplemented],
                                  CPEI_VECTOR ));
        HalpCPEIoSapicVector[HalpMaxCPEImplemented] = (UCHAR)(CPEI_VECTOR);

        //
        // Save the Destination Processor (that BIOS expects OS to use) for this CPE source)
        //

        HalpCPEDestination[HalpMaxCPEImplemented] = (USHORT)(
            (PlatformInt->APICID << 8) | PlatformInt->ACPIEID);

        HalDebugPrint(( HAL_INFO, "HAL: Found an Platform Interrupt VECTOR: %p, %x -> %x, flags: %x\n",
                                  PlatformInt,
                                  PlatformInt->IOSAPICVector,
                                  PlatformInt->GlobalVector,
                                  PlatformInt->Flags ));

        //
        // Keep track of how many CPE sources are implemented in the platform.
        //

        HalpMaxCPEImplemented++;

    }
}

VOID
HalpInitPlatformInterrupts(
    VOID
    )
{
    ULONG       currentCPE;
    USHORT      processorApicID;
    PAPICTABLE  tablePtr;

    processorApicID = (USHORT)KeGetPcr()->HalReserved[PROCESSOR_ID_INDEX];

    for (currentCPE = 0; currentCPE < HalpMaxCPEImplemented; currentCPE++) {

        if (HalpCPEDestination[currentCPE] == processorApicID)
        {
            //
            // Force the flags into the SAPIC state
            //

            HalpSetCPEVectorState( HalpCPEIntIn[currentCPE],
                                   HalpCPEIoSapicVector[currentCPE],
                                   HalpCPEDestination[currentCPE],
                                   HalpCPEVectorFlags[currentCPE]
                                 );

        }
    }

    // Walk the Multiple Apic table...

    tablePtr = (PAPICTABLE) HalpApicTable->APICTables;

    // Loop ends when TraversePtr is off the end of the table...
    while ((UINT_PTR)tablePtr <
           ((UINT_PTR)HalpApicTable + HalpApicTable->Header.Length)) {

        if (tablePtr->Type == PLATFORM_INTERRUPT_SOURCE) {

            PPLATFORM_INTERRUPT platformInt = (PPLATFORM_INTERRUPT)tablePtr;

            if ((platformInt->InterruptType == PLATFORM_INT_PMI ||
                 platformInt->InterruptType == PLATFORM_INT_INIT) &&
                (processorApicID == (USHORT)((platformInt->APICID << 8) | platformInt->ACPIEID))) {

                HalpWriteRedirEntry( platformInt->GlobalVector,
                                     platformInt->IOSAPICVector,
                                     processorApicID,
                                     platformInt->Flags,
                                     platformInt->InterruptType
                                   );
            }
        }

        (UINT_PTR)tablePtr += tablePtr->Length;
    }
}

BOOLEAN
HalpVerifyIoSapic(
    IN PUCHAR BaseAddress
    )
/*++

Routine Description:

    Verify that an IO Sapic Unit exists at the specified address

 Arguments:

    BaseAddress - Virtual address of the IO Unit to test.

 Return Value:
    BOOLEAN - TRUE if a IO Unit was found at the passed address
            - FALSE otherwise

--*/

{
    union SapicUnion {
        ULONG Raw;
        struct SapicVersion Ver;
    } Temp1, Temp2;

    PIO_SAPIC_REGS IoUnitPtr = (PIO_SAPIC_REGS) BaseAddress;

    //
    //  The documented detection mechanism is to write all zeros to
    //  the Version register.  Then read it back.  The IO Unit exists if the
    //  same result is read both times and the Version is valid.
    //

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp1.Raw = IoUnitPtr->RegisterWindow;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp2.Raw = IoUnitPtr->RegisterWindow;

    if ( Temp1.Raw == 0 ||
        (Temp1.Ver.Version != Temp2.Ver.Version) ||
        (Temp1.Ver.MaxRedirEntries != Temp2.Ver.MaxRedirEntries)) {
        //
        //  No IO Unit There
        //
        HalDebugPrint(( HAL_ERROR, "HAL: No IoSapic at %I64x\n", BaseAddress ));
        return (FALSE);
    }

    HalDebugPrint(( HAL_INFO, "HAL: IoSapic found at %I64x, Max Entries = %d\n", BaseAddress, Temp1.Ver.MaxRedirEntries ));

    return (TRUE);
}

VOID
HalpInitApicDebugMappings(
    VOID
    )
/*++

Routine Description:

    This routine is called at the very beginning of phase 1 initialization.
    It creates mappings for the APICs using MmMapIoSpace.  This will allow
    us to access their registers from the debugger.

    A much better solution would be to allow us to describe our memory usage to
    MM but ....

 Arguments:


 Return Value:

--*/
{
    PHYSICAL_ADDRESS physicalAddress;
    PIO_INTR_CONTROL IoIntrControl;
    ULONG   index;

    if (HalpMpInfo.IoSapicCount == 0) {

        //
        // I doubt this machine is going to get very far without IOAPICs
        // but there is certainly nothing for this routine to do.

        return;
    }

    ASSERT(HalpApicDebugAddresses == NULL);

    HalpApicDebugAddresses = ExAllocatePool(NonPagedPool,
                                            HalpMpInfo.IoSapicCount * sizeof(*HalpApicDebugAddresses));

    if (HalpApicDebugAddresses == NULL) {

        return;
    }

    IoIntrControl = HalpIoSapicList;

    for (index = 0; index < HalpMpInfo.IoSapicCount; index++) {

        if (IoIntrControl != NULL) {

            if (HalpVirtualToPhysical((ULONG_PTR)IoIntrControl, &physicalAddress)) {

                HalpApicDebugAddresses[index].IoIntrControl =
                    MmMapIoSpace(physicalAddress,
                                 sizeof(IO_INTR_CONTROL) +
                                    (IoIntrControl->IntiMax - IoIntrControl->IntiBase + 1) * sizeof(IOSAPICINTI),
                                 MmCached
                                 );
            }

            HalpApicDebugAddresses[index].IoSapicRegs =
                MmMapIoSpace(IoIntrControl->RegBasePhysical,
                             IO_SAPIC_REGS_SIZE,
                             MmNonCached
                             );

            IoIntrControl = IoIntrControl->flink;

        } else {

            HalpApicDebugAddresses[index].IoIntrControl = NULL;
            HalpApicDebugAddresses[index].IoSapicRegs = NULL;
        }
    }
}

VOID
HalpSaveInterruptControllerState(
    VOID
    )
{
    HalDebugPrint(( HAL_ERROR, "HAL: HalpSaveInterruptControllerState - not yet implemented\n"));

    HalpHiberInProgress = TRUE;
}

VOID
HalpRestoreInterruptControllerState(
    VOID
    )
{
    //
    // Restore the IO APIC state
    //
    HalDebugPrint(( HAL_ERROR, "HAL: HalpRestoreInterruptControllerState - not yet implemented\n"));

    HalpPicStateIntact = TRUE;
}

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    )
{
    HalDebugPrint(( HAL_FATAL_ERROR, "HAL: HalpSetInterruptControllerWakeupState - not yet implemented\n"));

    KeBugCheckEx(HAL_INITIALIZATION_FAILED, 0, 0, 0 , 0);
}

BOOLEAN
HalpAcpiPicStateIntact(
    VOID
    )
{
    return HalpPicStateIntact;
}


ULONG
HalpAcpiNumProcessors(
    VOID
    )
{
    return HalpMpInfo.ProcessorCount;
}


VOID
HalpMaskAcpiInterrupt(
    VOID
    )
{
    ULONG inti;
    KAFFINITY affinity;
    ULONG sciVector = HalpFixedAcpiDescTable.sci_int_vector;

    if (sciVector < PIC_VECTORS) {
        sciVector = HalpPicVectorRedirect[sciVector];
    }

    HalpGetSapicInterruptDesc(
            Internal,
            0,
            sciVector,
            &inti,
            &affinity
            );

    HalpDisableRedirEntry(inti);

}

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    )
{
    ULONG inti;
    KAFFINITY affinity;

    ULONG sciVector = HalpFixedAcpiDescTable.sci_int_vector;

    if (sciVector < PIC_VECTORS) {
        sciVector = HalpPicVectorRedirect[sciVector];
    }

    HalpGetSapicInterruptDesc(
            Internal,
            0,
            sciVector,
            &inti,
            &affinity
            );

    HalpEnableRedirEntry(inti);
}

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID for a given processor.

Arguments:

    Processor - The logical processor number that is
        associated with this APIC ID.

    ApicId - pointer to a value to fill in with the APIC ID.

Return Value:

    Status.

--*/
{
    ULONG   index;

    for (index = 0; index < HalpMpInfo.ProcessorCount; index++) {

        if (HalpProcessorInfo[index].NtProcessorNumber == Processor) {

            //
            // Return the APIC ID, Extended APIC ID for this
            // processor.
            //

            *ApicId = HalpProcessorInfo[index].LocalApicID;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\setupnvr.h ===
/*++

Module Name:

    setupnvr.h

Abstract:

    Access function to r/w environment variables from pseudo-NVRAM file

Author:

    Mudit Vats (v-muditv) 5-18-99

Revision History:

--*/
#define MAXBOOTVARS         9
#define MAXBOOTVARSIZE      1024

#define ERROR_OK            1
#define ERROR_NOTOK         0

int ReadNVRAM();
int WriteNVRAM();
int GetBootVar( char *szBootVar, unsigned short nLength, char *szBootVal );
int SetBootVar( char *szBootVar, char *szBootVal );


NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\setupnvr.c ===
/*++

Module Name:

    setupnvr.c

Abstract:

    Access function to r/w environment variables from pseudo-NVRAM file

Author:

    Mudit Vats (v-muditv) 5-18-99

Revision History:

    6/4/99 added OSLOADOPTIONS

--*/
#include <stdio.h>
#include <string.h>
#include "halp.h"
#include "setupnvr.h"

#define SYSTEMPARTITION     0
#define OSLOADER            1
#define OSLOADPARTITION     2
#define OSLOADFILENAME      3
#define LOADIDENTIFIER      4
#define OSLOADOPTIONS       5
#define COUNTDOWN           6
#define AUTOLOAD            7
#define LASTKNOWNGOOD       8

#define BOOTNVRAMFILE         L"\\device\\harddisk0\\partition1\\boot.nvr"

PUCHAR HalpNvrKeys[] = {
    "SYSTEMPARTITION",
    "OSLOADER",
    "OSLOADPARTITION",
    "OSLOADFILENAME",
    "LOADIDENTIFIER",
    "OSLOADOPTIONS",
    "COUNTDOWN",
    "AUTOLOAD",
    "LASTKNOWNGOOD",
    ""
    };


//
//  All Pseudo-NVRAM vars stored here
//
char g_szBootVars[MAXBOOTVARS][MAXBOOTVARSIZE];


//
//  ReadNVRAM - read pseudo-nvram; read boot vars from "boot.nvr" file
//
int ReadNVRAM()
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    FILE_STANDARD_INFORMATION StandardInfo;
    char szBuffer[MAXBOOTVARSIZE+20];
    int i;
    ULONG LengthRemaining;
    ULONG CurrentLength;
    ULONG CurrentLine = 1;
    PCHAR KeyStart;
    PCHAR ValueStart;
    PCHAR pc;
    PCHAR ReadPos;
    PCHAR BufferEnd;
    CHAR c;
    BOOLEAN SkipSpace;

    //
    // Clear all variables.
    //

    for (i=SYSTEMPARTITION; i<=LASTKNOWNGOOD; i++) {
        g_szBootVars[i][0] = '\0';
    }

    RtlInitUnicodeString( &UnicodeString, BOOTNVRAMFILE );
    InitializeObjectAttributes(&Obja,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwCreateFile(
                &Handle,
                FILE_GENERIC_READ,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {
        //KdPrint(("HALIA64: Unable to open %ws for reading!\n", BOOTNVRAMFILE));
        //return NT_SUCCESS(Status);

        //
        // We didn't find the boot.nvr, so we will assume we are
        // doing a setup from cd
        //
        strcpy( g_szBootVars[0], "multi(0)disk(0)rdisk(0)partition(1)\0" );
        strcpy( g_szBootVars[1], "multi(0)disk(0)cdrom(1)\\setupldr.efi\0" );
        strcpy( g_szBootVars[2], "multi(0)disk(0)cdrom(1)\0" );
        strcpy( g_szBootVars[3], "\\IA64\0" );
        strcpy( g_szBootVars[4], "Microsoft Windows 2000 Setup\0" );
        strcpy( g_szBootVars[5], "\0" );
        strcpy( g_szBootVars[6], "30\0" );
        strcpy( g_szBootVars[7], "YES\0" );
        strcpy( g_szBootVars[8], "False\0" );

        return ERROR_OK;
    }

    Status = ZwQueryInformationFile( Handle,
                                     &IoStatusBlock,
                                     &StandardInfo,
                                     sizeof(FILE_STANDARD_INFORMATION),
                                     FileStandardInformation );

    if (!NT_SUCCESS(Status)) {
      KdPrint(("HALIA64: Error querying info on file %ws\n", BOOTNVRAMFILE));
      goto cleanup;
    }

    LengthRemaining = StandardInfo.EndOfFile.LowPart;
    
    KeyStart = ValueStart = szBuffer;
    ReadPos = szBuffer;
    SkipSpace = TRUE;

    while (LengthRemaining) {

        //
        // Read a buffer's worth of data from the 'nvram' file and
        // attempt to parse it one variable at a time.
        //

        CurrentLength = (ULONG)((szBuffer + sizeof(szBuffer)) - ReadPos);
        if (CurrentLength > LengthRemaining) {
            CurrentLength = LengthRemaining;
        }
        BufferEnd = ReadPos + CurrentLength;
        LengthRemaining -= CurrentLength;

        Status = ZwReadFile(Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            ReadPos,
                            CurrentLength,
                            NULL,
                            NULL
                            );

        if (!NT_SUCCESS(Status)) {
            KdPrint(("HALIA64: Error reading from %ws!\n", BOOTNVRAMFILE));
            goto cleanup;
        }

        //
        // Lines in the file are of the form KEY=VALUE\r, find the
        // start of the key, the start of the value and the start of
        // the next key.   Note the buffer is large enough to contain
        // at least one of the largest key and largest value.
        //

        for (pc = ReadPos; TRUE; pc++) {
            if (pc == BufferEnd) {

                //
                // Hit end of buffer.   If the data we are processing
                // begins at the start of the buffer then the data is
                // too big to process, abort.
                //

                if ((KeyStart == szBuffer) && (SkipSpace == FALSE)) {
                    KdPrint(("HALIA64: %ws line %d too long to process, aborting\n",
                             BOOTNVRAMFILE, CurrentLine));
                    Status = STATUS_UNSUCCESSFUL;
                    goto cleanup;
                }

                //
                // Move current line to start of buffer then read more
                // data into the buffer.
                //

                i = (int)((szBuffer + sizeof(szBuffer)) - KeyStart);
                RtlMoveMemory(szBuffer,
                              KeyStart,
                              i);

                ValueStart -= KeyStart - szBuffer;
                KeyStart = szBuffer;
                ReadPos = szBuffer + i;

                //
                // Break out of this loop and reexecute the read loop.
                //

                break;
            }
            c = *pc;

            if (c == '\0') {

                // 
                // Unexpected end of string, abort.
                //

                KdPrint(("HALIA64: Unexpected end of string in %ws!\n",
                         BOOTNVRAMFILE));
                Status = STATUS_UNSUCCESSFUL;
                goto cleanup;
            }

            if (SkipSpace == TRUE) {

                //
                // Skipping White Space.
                //

                if ((c == ' ') ||
                    (c == '\t') ||
                    (c == '\r') ||
                    (c == '\n')) {
                    continue;
                }

                //
                // Current character is NOT white space, set as
                // beginning of things we will look at.
                //

                KeyStart = ValueStart = pc;
                SkipSpace = FALSE;
            }

            if (c == '=') {
                if (ValueStart == KeyStart) {

                    //
                    // This is the first '=' on the line, the value
                    // starts in the next character position.
                    //

                    ValueStart = pc;
                }
            }
            if (c == '\r') {

                //
                // At end of line.   Treat from KeyStart to current
                // position as a single line containing a variable.
                //

                *ValueStart = '\0';
                for (i = 0; i < MAXBOOTVARS; i++) {
                    if (strcmp(KeyStart, HalpNvrKeys[i]) == 0) {

                        //
                        // Have a key match, copy from ValueStart+1
                        // thru end of line as the variable's value.
                        //

                        ULONGLONG ValueLength = pc - ValueStart - 1;

                        if (ValueLength >= MAXBOOTVARSIZE) {
                            ValueLength = MAXBOOTVARSIZE - 1;
                        }

                        RtlCopyMemory(g_szBootVars[i],
                                      ValueStart + 1,
                                      ValueLength);
                        g_szBootVars[i][ValueLength] = '\0';
                        CurrentLine++;
                        SkipSpace = TRUE;
                        break;
                    }
                }

                //
                // Start looking for the next key at the current
                // character position.
                //

                KeyStart = pc;
                ValueStart = pc;
            }
        }
    }

cleanup:

    ZwClose( Handle );
    return NT_SUCCESS( Status );
}



//
// WriteNVRAM - write pseudo-nvram; read boot vars from "boot.nvr" file
//
int WriteNVRAM()
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UCHAR szBuffer[MAXBOOTVARSIZE+20];
    ULONG BootVar;
    ULONG VarLen;

    RtlInitUnicodeString( &UnicodeString, BOOTNVRAMFILE );
    InitializeObjectAttributes( &Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = ZwCreateFile(
                &Handle,
                FILE_GENERIC_WRITE | DELETE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,                     // no sharing
                FILE_OVERWRITE_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |  FILE_WRITE_THROUGH,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("HALIA64: Unable to open %ws for writing!\n", BOOTNVRAMFILE));
        return ERROR_NOTOK;
    }

    //
    // Generate an entry of the form NAME=VALUE for each variable
    // and write it to the 'nvram' file.
    //

    for ( BootVar = 0; BootVar < MAXBOOTVARS; BootVar++ ) {
        VarLen = _snprintf(szBuffer, 
                           sizeof(szBuffer),
                           "%s=%s\r\n",
                           HalpNvrKeys[BootVar],
                           g_szBootVars[BootVar]);
    
        Status = ZwWriteFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                szBuffer,
                VarLen,
                NULL,
                NULL
                );

        if (!NT_SUCCESS(Status)) {
            KdPrint(("HALIA64: Error writing %s to %ws!\n",
                     HalpNvrKeys[BootVar],
                     BOOTNVRAMFILE));
            goto cleanup;
        }
    }

cleanup:

    ZwClose( Handle );
    return NT_SUCCESS( Status );
}


//
//  GetBootVar - gets the requested boot environment variable
//
//    szBootVar  - this is the requested boot var:
//
//                 SYSTEMPARTITION
//                 OSLOADER
//                 OSLOADPARTITION
//                 OSLOADFILENAME
//                 LOADIDENTIFIER
//                 OSLOADOPTIONS
//                 COUNTDOWN
//                 AUTOLOAD
//                 LASTKNOWNGOOD 
//    nLength   - length of szBootVal (input buffer)
//    szBootVal - boot environment variable returned here
//
int
GetBootVar(
    PCHAR  szBootVar,
    USHORT nLength,
    PCHAR  szBootVal
    )
{
    ULONG BootVar;

    //
    // Search the boot variable keys for a match.
    //

    for ( BootVar = 0; BootVar < MAXBOOTVARS; BootVar++ ) {
        if (_stricmp(szBootVar, HalpNvrKeys[BootVar]) == 0) {

            //
            // Found a key match, copy the variable's value to the 
            // caller's buffer.
            //

            strncpy(szBootVal, g_szBootVars[BootVar], nLength);
            return ERROR_OK;
        }
    }

    //
    // No such variable, return error.
    //

    return ERROR_NOTOK;
}


//
//  SetBootVar - sets the requested boot environment variable
//
//    szBootVar  - this is the requested boot var:
//
//                 SYSTEMPARTITION
//                 OSLOADER
//                 OSLOADPARTITION
//                 OSLOADFILENAME
//                 LOADIDENTIFIER
//                 OSLOADOPTIONS
//                 COUNTDOWN
//                 AUTOLOAD
//                 LASTKNOWNGOOD 
//    szBootVal - new boot environment variable value
//
int
SetBootVar(
    PCHAR szBootVar,
    PCHAR szBootVal
    )
{
    ULONG BootVar;

    //
    // Search the boot variable keys for a match.
    //

    for ( BootVar = 0; BootVar < MAXBOOTVARS; BootVar++ ) {
        if (_stricmp(szBootVar, HalpNvrKeys[BootVar]) == 0) {

            //
            // Found it, copy the new value to this value.
            //

            strncpy(g_szBootVars[BootVar], szBootVal, MAXBOOTVARSIZE);
            return ERROR_OK;
        }
    }

    //
    // No such variable, return error.
    //

    return ERROR_NOTOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\xxacpi.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xxacpi.c

Abstract:

    Implements various ACPI utility functions.

Author:

    Jake Oshins (jakeo) 12-Feb-1997

Environment:

    Kernel mode only.

Revision History:

   Todd Kjos (HP) (v-tkjos) 1-Jun-1998 : Added IA64 support

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "pci.h"

//#define DUMP_FADT

VOID
HalAcpiTimerCarry(
    VOID
    );

VOID
HalaAcpiTimerInit(
#if defined(ACPI64)
    ULONG_PTR  TimerPort,
#else
    ULONG      TimerPort,
#endif
    BOOLEAN    TimerValExt
    );

ULONG
HaliAcpiQueryFlags(
    VOID
    );

VOID
HaliAcpiTimerInit(
// *** TBD should be ULONG_PTR
    ULONG      TimerPort OPTIONAL,
    IN BOOLEAN    TimerValExt
    );

VOID
HaliAcpiMachineStateInit(
    IN PPROCESSOR_INIT ProcInit,
    IN PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG         PicVal
    );

BOOLEAN
FASTCALL
HalAcpiC1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC3WbinvdIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

VOID
FASTCALL
HalProcessorThrottle(
    IN UCHAR Throttle
    );

NTSTATUS
HaliSetWakeAlarm (
        IN ULONGLONG    WakeSystemTime,
        IN PTIME_FIELDS WakeTimeFields OPTIONAL
        );

VOID
HaliSetWakeEnable(
        IN BOOLEAN      Enable
        );

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
   );

PVOID
HalpRemapVirtualAddress(
    IN PVOID VirtualAddress,
    IN PVOID PhysicalAddress,
    IN BOOLEAN WriteThrough
    );

ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
HalpNumaInitializeStaticConfiguration(
    IN PLOADER_PARAMETER_BLOCK
    );

//
// HAL Hack flags
//

typedef enum {
    HalHackAddFakeSleepHandlersS1 = 1,
    HalHackAddFakeSleepHandlersS2 = 2,
    HalHackAddFakeSleepHandlersS3 = 4
} HALHACKFLAGS;

extern HALHACKFLAGS HalpHackFlags = 0;

//
// Externs
//

extern ULONG    HalpAcpiFlags;
extern PHYSICAL_ADDRESS HalpAcpiRsdt;
extern SLEEP_STATE_CONTEXT HalpShutdownContext;
extern ULONG HalpPicVectorRedirect[];

//
// Globals
//

ULONG HalpInvalidAcpiTable;
PRSDT HalpAcpiRsdtVA;
PXSDT HalpAcpiXsdtVA;
PIPPT_TABLE HalpPlatformPropertiesTable;
ULONG       HalpPlatformPropertiesEfiFlags = 0;   // IPPT Flags coming from EFI MDs

//
// This is the dispatch table used by the ACPI driver
//
HAL_ACPI_DISPATCH_TABLE HalAcpiDispatchTable;
PPM_DISPATCH_TABLE PmAcpiDispatchTable = NULL;


NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpBuildAcpiResourceList(
    OUT PIO_RESOURCE_REQUIREMENTS_LIST  List
    );

NTSTATUS
HalpAcpiDetectResourceListSize(
    OUT  PULONG   ResourceListSize
    );

VOID
HalpRestoreInterruptControllerState(
    VOID
   );

ULONG
HalpGetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
HalpReadRegistryAndApplyHacks (
    VOID
    );

#define LOW_MEMORY          0x000100000

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

// ADRIAO 01/12/98 - We no longer having the HAL declare the IO ports
//                     specified in the FADT. These will be declared in a future
//                     defined PNP0Cxx node (for new, in PNP0C02). This is done
//                     because we cannot know at the hal level what bus the ACPI
//                     FADT resources refer to. We can only the translated resource info.
//    Hence....

#define DECLARE_FADT_RESOURCES_AT_ROOT 0

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpGetAcpiTablePhase0)
#pragma alloc_text(INIT, HalpSetupAcpiPhase0)
#pragma alloc_text(PAGE, HaliInitPowerManagement)
#pragma alloc_text(PAGE, HalpQueryAcpiResourceRequirements)
#pragma alloc_text(PAGE, HalpBuildAcpiResourceList)
#pragma alloc_text(PAGE, HalpGetCrossPartitionIpiInterface)
#pragma alloc_text(PAGE, HalpAcpiDetectResourceListSize)
#pragma alloc_text(PAGE, HalpReadRegistryAndApplyHacks)
#pragma alloc_text(PAGE, HaliAcpiTimerInit)
#pragma alloc_text(PAGE, HaliAcpiMachineStateInit)
#pragma alloc_text(PAGE, HaliAcpiQueryFlags)
#pragma alloc_text(PAGE, HaliSetWakeEnable)
#endif


PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    )
/*++

Routine Description:

    This function returns a pointer to the ACPI table that is
    identified by Signature.

Arguments:

    Signature - A four byte value that identifies the ACPI table

Return Value:

    Pointer to a copy of the table

--*/
{
    PRSDT rsdt;
    PXSDT xsdt;
    ULONG entry, rsdtEntries;
    PVOID table;
    PHYSICAL_ADDRESS physicalAddr;
    PDESCRIPTION_HEADER header;
    NTSTATUS status;
    ULONG lengthInPages;
    ULONG offset;

    //
    // unless we get the exceptional case where the platform identifies that 
    // ACPI tables must be explicitly mapped cached, we map the ACPI tables 
    // noncached. We are relying on the first mapping of this range to have
    // the "correct" caching flag, as that is the cachability attribute that 
    // all subsequent mappings of this range (ie., mapping of additional data
    // in the same page from ACPI driver for a memory operation region, etc.).
    // This semantic is enforced by the memory manager.
    //
    MEMORY_CACHING_TYPE acpiTableMappingType = (HalpPlatformPropertiesEfiFlags & HAL_PLATFORM_ACPI_TABLES_CACHED) ? 
                                               MmCached : MmNonCached;

    physicalAddr.QuadPart = 0;
    header = NULL;

    if ((HalpAcpiRsdtVA == NULL) && (HalpAcpiXsdtVA == NULL)) {

        //
        // Find and map the RSDT once.  This mapping is reused on
        // subsequent calls to this routine.
        //

        status = HalpAcpiFindRsdtPhase0(LoaderBlock);

        if (!(NT_SUCCESS(status))) {
            HalDebugPrint(( HAL_INFO, "HAL: *** make sure you are using ntdetect.com v5.0 ***\n" ));
            KeBugCheckEx(MISMATCHED_HAL,
                4, 0xac31, 0, 0);
        }

        xsdt = HalpMapPhysicalMemory(HalpAcpiRsdt, 2, acpiTableMappingType );

        if (!xsdt) {
            return NULL;
        }

        //
        // Do a sanity check on the RSDT.
        //

        if ((xsdt->Header.Signature != RSDT_SIGNATURE) &&
            (xsdt->Header.Signature != XSDT_SIGNATURE)) {
            HalDisplayString("HAL: Bad RSDT pointer\n");
            KeBugCheckEx(MISMATCHED_HAL,
                4, 0xac31, 1, 0);
        }

        //
        // Remap the (X)RSDT now that we know how long it is.
        //

        offset = HalpAcpiRsdt.LowPart & (PAGE_SIZE - 1);
        lengthInPages = (offset + xsdt->Header.Length + (PAGE_SIZE - 1))
                        >> PAGE_SHIFT;
        if (lengthInPages != 2) {
            HalpUnmapVirtualAddress(xsdt, 2);
            xsdt = HalpMapPhysicalMemory(HalpAcpiRsdt, lengthInPages, acpiTableMappingType );
            if (!xsdt) {
                DbgPrint("HAL: Couldn't remap RSDT\n");
                return NULL;
            }
        }

        if (xsdt->Header.Signature == XSDT_SIGNATURE) {
            HalpAcpiXsdtVA = xsdt;
        } else {
            HalpAcpiRsdtVA = (PRSDT)xsdt;
            HalpAcpiXsdtVA = NULL;
        }
    }

    xsdt = HalpAcpiXsdtVA;
    rsdt = HalpAcpiRsdtVA;

    rsdtEntries = xsdt ?
        NumTableEntriesFromXSDTPointer(xsdt) :
        NumTableEntriesFromRSDTPointer(rsdt);

    //
    // Look down the pointer in each entry to see if it points to
    // the table we are looking for.
    //
    for (entry = 0; entry < rsdtEntries; entry++) {

        physicalAddr.QuadPart = xsdt ?
            xsdt->Tables[entry].QuadPart :
            rsdt->Tables[entry];

        if (header != NULL) {
            HalpUnmapVirtualAddress(header, 2);
        }

        header = HalpMapPhysicalMemory(physicalAddr, 2, acpiTableMappingType );
        if (!header) {
            return NULL;
        }

        if (header->Signature == Signature) {
            break;
        }
    }

    if (entry == rsdtEntries) {

        //
        // Signature not found, free the PTR for the last entry
        // examined and indicate failure to the caller.
        //

        HalpUnmapVirtualAddress(header, 2);
        return NULL;
    }

    //
    // Make sure we have mapped enough memory to cover the entire
    // table.
    //

    offset = (ULONG)((ULONG_PTR)header & (PAGE_SIZE - 1));
    lengthInPages = (header->Length + offset + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
    if (lengthInPages != 2) {
        HalpUnmapVirtualAddress(header, 2);
        header = HalpMapPhysicalMemory( physicalAddr, lengthInPages, acpiTableMappingType );
    }

    //
    // Validate the table's checksum.
    // N.B. We expect the checksum to be wrong on some early versions
    // of the FADT.
    //

    if ((header != NULL)  &&
        ((header->Signature != FADT_SIGNATURE) || (header->Revision > 2))) {

        PUCHAR c = (PUCHAR)header + header->Length;
        UCHAR s = 0;

        if (header->Length) {
            do {
                s += *--c;
            } while (c != (PUCHAR)header);
        }


        if ((s != 0) || (header->Length == 0)) {

            //
            // This table is not valid.
            //

            HalpInvalidAcpiTable = header->Signature;

#if 0

            //
            // Don't return this table.
            //

            HalpUnmapVirtualAddress(header, lengthInPages);
            return NULL;

#endif

        }
    }
    return header;
}

NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    Save some information from the ACPI tables before they get
    destroyed.

Arguments:

    none

Return Value:

    none

--*/
{
    NTSTATUS    status;
    ULONG entry;
    PVOID table;
    PVOID physicalAddr;
    PDESCRIPTION_HEADER header;
    ULONG blkSize;
    PHYSICAL_ADDRESS rawAddr;

    //
    // Copy the Fixed Acpi Descriptor Table (FADT) to a permanent
    // home.
    //

    header = HalpGetAcpiTablePhase0(LoaderBlock, FADT_SIGNATURE);
    if (header == NULL) {
        HalDebugPrint(( HAL_INFO, "HAL: Didn't find the FACP\n" ));
        return STATUS_NOT_FOUND;
    }

    RtlCopyMemory(&HalpFixedAcpiDescTable,
                  header,
                  MIN(header->Length, sizeof(HalpFixedAcpiDescTable)));

    if (header->Revision < 3) {

        KeBugCheckEx(ACPI_BIOS_ERROR, 0x11, 9, header->Revision, 0);
    }

    // Check for MMIO addresses that need to be mapped.

    blkSize = HalpFixedAcpiDescTable.pm1_evt_len;
    ASSERT(blkSize);
    if ((HalpFixedAcpiDescTable.x_pm1a_evt_blk.AddressSpaceID == AcpiGenericSpaceMemory) &&
        (blkSize > 0)) {
        rawAddr = HalpFixedAcpiDescTable.x_pm1a_evt_blk.Address;
        HalpFixedAcpiDescTable.x_pm1a_evt_blk.Address.QuadPart =
            (LONGLONG)HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmNonCached);
    }

    blkSize = HalpFixedAcpiDescTable.pm1_ctrl_len;
    ASSERT(blkSize);
    if ((HalpFixedAcpiDescTable.x_pm1a_ctrl_blk.AddressSpaceID == AcpiGenericSpaceMemory) &&
        (blkSize > 0)) {
        rawAddr = HalpFixedAcpiDescTable.x_pm1a_ctrl_blk.Address;
        HalpFixedAcpiDescTable.x_pm1a_ctrl_blk.Address.QuadPart =
            (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmNonCached);
    }

    blkSize = HalpFixedAcpiDescTable.pm_tmr_len;
    ASSERT(blkSize);
    if ((HalpFixedAcpiDescTable.x_pm_tmr_blk.AddressSpaceID == AcpiGenericSpaceMemory) &&
        (blkSize > 0)) {
    	rawAddr = HalpFixedAcpiDescTable.x_pm_tmr_blk.Address;
        HalpFixedAcpiDescTable.x_pm_tmr_blk.Address.QuadPart =
            (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmNonCached);
    }

    // The rest of these ACPI blocks are optional so test if they exist before mapping them

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.pm1_evt_len;
            rawAddr = HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address;
            HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmNonCached);
        }
    }

    if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.pm1_ctrl_len;
            rawAddr = HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address;
            HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmNonCached);
        }
    }

    if (HalpFixedAcpiDescTable.x_pm2_ctrl_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_pm2_ctrl_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.pm2_ctrl_len;
            rawAddr = HalpFixedAcpiDescTable.x_pm2_ctrl_blk.Address;
            HalpFixedAcpiDescTable.x_pm2_ctrl_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmNonCached);
        }
    }

    if (HalpFixedAcpiDescTable.x_gp0_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_gp0_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.gp0_blk_len;
            rawAddr = HalpFixedAcpiDescTable.x_gp0_blk.Address;
            HalpFixedAcpiDescTable.x_gp0_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmNonCached);
        }
    }

    if (HalpFixedAcpiDescTable.x_gp1_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_gp1_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.gp1_blk_len;
            rawAddr = HalpFixedAcpiDescTable.x_gp1_blk.Address;
            HalpFixedAcpiDescTable.x_gp1_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmNonCached);
        }
    }

    //
    // See if Static Resource Affinity Table is present.
    //

    HalpNumaInitializeStaticConfiguration(LoaderBlock);

    //
    // See if Windows Platform Properties Table is present.
    //

    HalpPlatformPropertiesTable =
        HalpGetAcpiTablePhase0(LoaderBlock, IPPT_SIGNATURE);

    //
    // Enable ACPI counter code since we need it in the boot
    // process.
    //

    HaliAcpiTimerInit(0, FALSE);

    //
    // Claim a page of memory below 1MB to be used for transitioning
    // a sleeping processor back from real mode to protected mode
    //

#ifdef IA64
    HalDebugPrint(( HAL_INFO, "HAL: WARNING - HalpSetupAcpi - Sleep transitions not yet implemented\n" ));
#else
    // check first to see if this has already been done by MP startup code
    if (!HalpLowStubPhysicalAddress) {

        HalpLowStubPhysicalAddress = (PVOID)HalpAllocPhysicalMemory (LoaderBlock,
                                            LOW_MEMORY, 1, FALSE);

        if (HalpLowStubPhysicalAddress) {

            HalpLowStub = HalpMapPhysicalMemory(HalpLowStubPhysicalAddress, 1, MmCached);
        }
    }

    //
    // Claim a PTE that will be used for cache flushing in states S2 and S3.
    //
    HalpVirtAddrForFlush = HalpMapPhysicalMemory((PVOID)LOW_MEMORY, 1, MmCached);

    HalpPteForFlush = MiGetPteAddress(HalpVirtAddrForFlush);
#endif

    return STATUS_SUCCESS;
}

VOID
HaliAcpiTimerInit(
// *** TBD should be ULONG_PTR
    IN ULONG      TimerPort  OPTIONAL,
    IN BOOLEAN    TimerValExt
    )
/*++
Routine Description:

    This routine initializes the ACPI timer.

Arguments:

    TimerPort - The address in I/O space of the ACPI timer.  If this is
                0, then the values from the cached FADT will be used.

    TimerValExt - signifies whether the timer is 24 or 32 bits.

--*/
{
#if defined(ACPI64)
    ULONG_PTR port = TimerPort;
#else
    ULONG port = TimerPort;
#endif

    BOOLEAN ext = TimerValExt;

    PAGED_CODE();

    if (port == 0) {
        port = HalpFixedAcpiDescTable.x_pm_tmr_blk.Address.LowPart;
        if (HalpFixedAcpiDescTable.flags & TMR_VAL_EXT) {
            ext = TRUE;
        } else {
            ext = FALSE;
        }
    }

    HalaAcpiTimerInit(port,
                      ext);
}

VOID
HaliAcpiMachineStateInit(
    IN PPROCESSOR_INIT ProcInit,
    IN PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG         PicVal
    )
/*++
Routine Description:

    This function is a callback used by the ACPI driver
    to notify the HAL with the processor blocks.

Arguments:

--*/
{
    POWER_STATE_HANDLER powerState;
    SLEEP_STATE_CONTEXT sleepContext;
    NTSTATUS    status;
    PSYSTEM_POWER_STATE_DISABLE_REASON pReasonNoOSPM = NULL;
    SYSTEM_POWER_LOGGING_ENTRY PowerLoggingEntry;


    PAGED_CODE();
    UNREFERENCED_PARAMETER(ProcInit);

    *PicVal = 1;    // We only support APIC on IA64

    RtlZeroMemory (&sleepContext, sizeof (sleepContext));
    powerState.Context = NULL;

    pReasonNoOSPM = ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                                HAL_POOL_TAG
                                );
    if (pReasonNoOSPM) {
        RtlZeroMemory(pReasonNoOSPM, sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
        pReasonNoOSPM->PowerReasonCode = SPSD_REASON_NONE;
    }

    //
    // Set up fake handlers that do nothing so testing device power
    // transitions isn't blocked.  Only if hack flag is set, though
    //

    HalpReadRegistryAndApplyHacks ();

    if (HalpHackFlags & HalHackAddFakeSleepHandlersS1) {
        powerState.Type = PowerStateSleeping1;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiFakeSleep;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
    } else {
        if (pReasonNoOSPM) {
            pReasonNoOSPM->PowerReasonCode = SPSD_REASON_NOOSPM;
            pReasonNoOSPM->AffectedState[PowerStateSleeping1] = TRUE;
        }
    }

    if (HalpHackFlags & HalHackAddFakeSleepHandlersS2) {
        powerState.Type = PowerStateSleeping2;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiFakeSleep;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
    } else {
        if (pReasonNoOSPM) {
            pReasonNoOSPM->PowerReasonCode = SPSD_REASON_NOOSPM;
            pReasonNoOSPM->AffectedState[PowerStateSleeping2] = TRUE;
        }
    }

    if (HalpHackFlags & HalHackAddFakeSleepHandlersS3) {

        powerState.Type = PowerStateSleeping3;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiFakeSleep;

        powerState.Context = ULongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
    } else {
        if (pReasonNoOSPM) {
            pReasonNoOSPM->PowerReasonCode = SPSD_REASON_NOOSPM;
            pReasonNoOSPM->AffectedState[PowerStateSleeping3] = TRUE;
        }
    }

    //
    // we do not register support for hibernate 
    //
    if (pReasonNoOSPM) {
        pReasonNoOSPM->PowerReasonCode = SPSD_REASON_NOOSPM;
        pReasonNoOSPM->AffectedState[PowerStateSleeping4] = TRUE;
    }

    if (pReasonNoOSPM && pReasonNoOSPM->PowerReasonCode != SPSD_REASON_NONE) {
        PowerLoggingEntry.LoggingType = LOGGING_TYPE_SPSD;
        PowerLoggingEntry.LoggingEntry = pReasonNoOSPM;

        ZwPowerInformation(
                    SystemPowerLoggingEntry,
                    &PowerLoggingEntry,
                    sizeof(PowerLoggingEntry),
                    NULL,
                    0 );
    }


    //
    // For now all we are going to do is register a shutdown handler
    // that will call shutdown-restart
    //

    if (SleepValues[4].Supported) {
        powerState.Type = PowerStateShutdownOff;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[4].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[4].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_OFF;
        HalpShutdownContext = sleepContext;

        powerState.Context = ULongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));
    }
}

ULONG
HaliAcpiQueryFlags(
    VOID
    )
/*++

Routine Description:

    This routine is temporary is used to report the presence of the
    boot.ini switch

Arguments:

    None

Return Value:

    TRUE, if switch present

--*/
{
    return HalpAcpiFlags;
}


NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    )

/*++

Routine Description:

    This is called by the ACPI driver to start the PM
    code.

Arguments:

    PmDriverDispatchTable - table of functions provided
        by the ACPI driver for the HAL

    PmHalDispatchTable - table of functions provided by
        the HAL for the ACPI driver

Return Value:

    status

--*/
{
    OBJECT_ATTRIBUTES objAttributes;
    PCALLBACK_OBJECT  callback;
    PHYSICAL_ADDRESS  pAddr;
    UNICODE_STRING    callbackName;
    NTSTATUS          status;
    PFACS             facs;

    PAGED_CODE();

    //
    // Keep a pointer to the driver's dispatch table.
    //
//  ASSERT(PmDriverDispatchTable);
//  ASSERT(PmDriverDispatchTable->Signature == ACPI_HAL_DISPATCH_SIGNATURE);
    PmAcpiDispatchTable = PmDriverDispatchTable;

    //
    // Fill in the function table
    //
    HalAcpiDispatchTable.Signature = HAL_ACPI_DISPATCH_SIGNATURE;
    HalAcpiDispatchTable.Version = HAL_ACPI_DISPATCH_VERSION;

    HalAcpiDispatchTable.HalpAcpiTimerInit = &HaliAcpiTimerInit;

    HalAcpiDispatchTable.HalpAcpiTimerInterrupt =
        (pHalAcpiTimerInterrupt)&HalAcpiTimerCarry;

    HalAcpiDispatchTable.HalpAcpiMachineStateInit = &HaliAcpiMachineStateInit;
    HalAcpiDispatchTable.HalpAcpiQueryFlags = &HaliAcpiQueryFlags;
    HalAcpiDispatchTable.HalxPicStateIntact = &HalpAcpiPicStateIntact;
    HalAcpiDispatchTable.HalxRestorePicState = &HalpRestoreInterruptControllerState;
    HalAcpiDispatchTable.HalpSetVectorState = &HaliSetVectorState;

    HalAcpiDispatchTable.HalpPciInterfaceReadConfig = &HaliPciInterfaceReadConfig;
    HalAcpiDispatchTable.HalpPciInterfaceWriteConfig = &HaliPciInterfaceWriteConfig;
    HalAcpiDispatchTable.HalpSetMaxLegacyPciBusNumber = &HalpSetMaxLegacyPciBusNumber;
    HalAcpiDispatchTable.HalpIsVectorValid = &HaliIsVectorValid;


    *PmHalDispatchTable = (PPM_DISPATCH_TABLE)&HalAcpiDispatchTable;

    //
    // Fill in Hal's private dispatch table
    //
    HalSetWakeEnable = HaliSetWakeEnable;
    HalSetWakeAlarm  = HaliSetWakeAlarm;

    //
    // Register callback that tells us to make
    // anything we need for sleeping non-pageable.
    //

    RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &objAttributes,
        &callbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );

    ExCreateCallback(&callback,
                     &objAttributes,
                     FALSE,
                     TRUE);

    ExRegisterCallback(callback,
                       (PCALLBACK_FUNCTION)&HalpPowerStateCallback,
                       NULL);

#if 0
    //
    // Find the location of the firmware waking vector.
    //  N.B.  If any of this fails, then HalpWakeVector will be NULL
    //        and we won't support S2 or S3.
    //
    if (HalpFixedAcpiDescTable.x_firmware_ctrl.Address.QuadPart) {

        facs = HalpMapPhysicalMemory(HalpFixedAcpiDescTable.x_firmware_ctrl.Address,
                            ADDRESS_AND_SIZE_TO_SPAN_PAGES(HalpFixedAcpiDescTable.x_firmware_ctrl.Address.LowPart, sizeof(FACS)),
                            MmCached);

        if (facs) {

            if (facs->Signature == FACS_SIGNATURE) {

                HalpWakeVector = &facs->x_FirmwareWakingVector;
            }
        }
    }
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine is a temporary stub that tries to detect the presence
    of an ACPI controller within the system. This code is meant to be
    inserted within NT's root system enumerator.

Arguents:

    Requirements - pointer to list of resources

Return Value:

    STATUS_SUCCESS                  - If we found a device object
    STATUS_NO_SUCH_DEVICE           - If we can't find info about the new PDO

--*/
{
    NTSTATUS                        ntStatus;
    PIO_RESOURCE_REQUIREMENTS_LIST  resourceList;
    ULONG                           resourceListSize;

    PAGED_CODE();

    //
    // Now figure out the number of resource that we need
    //
    ntStatus = HalpAcpiDetectResourceListSize(
        &resourceListSize
        );

    //
    // Convert this resourceListSize into the number of bytes that we
    // must allocate
    //
    resourceListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
        ( (resourceListSize - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );

    //
    // Allocate the correct number of bytes of the Resource List
    //
    resourceList = ExAllocatePoolWithTag(
        PagedPool,
        resourceListSize,
        HAL_POOL_TAG
        );

    //
    // This call must have succeeded or we cannot lay claim to ACPI
    //
    if (resourceList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set up the ListSize in the structure
    //
    RtlZeroMemory(resourceList, resourceListSize);
    resourceList->ListSize = resourceListSize;

    //
    // Build the ResourceList here
    //
    ntStatus = HalpBuildAcpiResourceList(resourceList);

    //
    // Did we build the list okay?
    //
    if (!NT_SUCCESS(ntStatus)) {

        //
        // Free memory and exit
        //
        ExFreePool(resourceList);
        return STATUS_NO_SUCH_DEVICE;
    }

    *Requirements = resourceList;
    return ntStatus;
}

NTSTATUS
HalpBuildAcpiResourceList(
    OUT PIO_RESOURCE_REQUIREMENTS_LIST  List
    )
/*++

Routine Description:

    This is the routine that builds the ResourceList given the FADT and
    an arbitrary number of ResourceDescriptors. We assume that the
    ResourceList has been properly allocated and sized

Arguments:

    List    - The list to fill in

Return Value:

    STATUS_SUCCESS if okay
    STATUS_UNSUCCESSUL if not

--*/
{
    PIO_RESOURCE_DESCRIPTOR partialResource;
    ULONG                   sciVector;
    ULONG                   count = 0;

    PAGED_CODE();

    ASSERT( List != NULL );

    //
    // Specify some default values (for now) to determine the Bus Type and
    // the bus number
    //
    List->AlternativeLists = 1;
    List->InterfaceType = Isa;
    List->BusNumber = 0;
    List->List[0].Version = 1;
    List->List[0].Revision = 1;

    //
    // Is there an interrupt resource required?
    //
    if (HalpFixedAcpiDescTable.sci_int_vector != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypeInterrupt;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareShared;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        //
        // The latest ACPI 2.0 spec allows the use of GSIVs in sci_int_vector in
        // the FADT.  If the vector is >= PIC_VECTORS then don't translate,
        // otherwise use the translation, if any, specified in the ISO entry in
        // the MADT.
        //
        sciVector = HalpFixedAcpiDescTable.sci_int_vector;

        if (sciVector < PIC_VECTORS)  {
            sciVector = HalpPicVectorRedirect[sciVector];
        }

        List->List[0].Descriptors[count].u.Interrupt.MinimumVector = sciVector;
        List->List[0].Descriptors[count].u.Interrupt.MaximumVector = sciVector;

        List->List[0].Count++;
        count++;
    }

#if DECLARE_FADT_RESOURCES_AT_ROOT

    //
    // Is there an SMI CMD IO Port?
    //
    if (HalpFixedAcpiDescTable.smi_cmd_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags =CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            PtrToUlong(HalpFixedAcpiDescTable.smi_cmd_io_port);
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            PtrToUlong(HalpFixedAcpiDescTable.smi_cmd_io_port);
        List->List[0].Descriptors[count].u.Port.Length = 1;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there an PM1A Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_evt_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_evt_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_evt_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_evt_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1B Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_evt_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_evt_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_evt_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_evt_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1A Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1B Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM2 Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm2_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm2_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM Timer Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm_tmr_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm_tmr_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm_tmr_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm_tmr_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm_tmr_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a GP0 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp0_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.gp0_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.gp0_blk_io_port + (ULONG) HalpFixedAcpiDescTable.gp0_blk_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.gp0_blk_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a GP1 Block IO port?
    //
    if (HalpFixedAcpiDescTable.gp1_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.gp1_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.gp1_blk_io_port + (ULONG) HalpFixedAcpiDescTable.gp1_blk_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.gp1_blk_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }
#endif // DECLARE_FADT_RESOURCES_AT_ROOT

    return STATUS_SUCCESS;
}

NTSTATUS
HalpAcpiDetectResourceListSize(
    OUT  PULONG   ResourceListSize
    )
/*++

Routine Description:

    Given a pointer to an FADT, determine the number of
    CM_PARTIAL_RESOURCE_DESCRIPTORS that are required to
    describe all the resource mentioned in the FADT

Arguments:

    ResourceListSize    - Location to store the answer

Return Value:

    STATUS_SUCCESS if everything went okay

--*/
{
    PAGED_CODE();

    //
    // First of all, assume that we need no resources
    //
    *ResourceListSize = 0;

    //
    // Is there an interrupt resource required?
    //
    if (HalpFixedAcpiDescTable.sci_int_vector != 0) {
        *ResourceListSize += 1;
    }

#if DECLARE_FADT_RESOURCES_AT_ROOT

    //
    // Is there an SMI CMD IO Port?
    //
    if (HalpFixedAcpiDescTable.smi_cmd_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there an PM1A Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1B Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1A Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1B Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM2 Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM Timer Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm_tmr_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a GP0 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp0_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a GP1 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp1_blk_io_port != 0) {
        *ResourceListSize += 1;
    }
#endif // DECALRE_FADT_RESOURCES_AT_ROOT

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    Scans the registry for TestFlags and sets the global
    hackflag to whatever the registry value is, if it
    exists.

Arguments:

    None

Return Value:

    None

--*/

VOID
HalpReadRegistryAndApplyHacks (
    VOID
    )
{
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  UnicodeString;
    HANDLE                          BaseHandle = NULL;
    NTSTATUS                        status;
    KEY_VALUE_PARTIAL_INFORMATION   hackflags;
    ULONG                           resultlength = 0;

    HalpHackFlags = 0;

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Control\\HAL");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS (status)) {
        return;
    }

    RtlInitUnicodeString (&UnicodeString,
                          L"TestFlags");

    status = ZwQueryValueKey (BaseHandle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              &hackflags,
                              sizeof (hackflags),
                              &resultlength);

    if (!NT_SUCCESS (status)) {
        return;
    }

    if (hackflags.Type != REG_DWORD || hackflags.DataLength != sizeof (ULONG)) {
        return;
    }

    HalpHackFlags = (ULONG) *hackflags.Data;
}

ULONG
HalpReadGenAddr(
    IN  PGEN_ADDR   GenAddr
    )
{
    ULONG   i, result = 0, bitWidth, mask = 0;

    //
    // Figure out how wide our target register is.
    //

    bitWidth = GenAddr->BitWidth +
               GenAddr->BitOffset;


    if (bitWidth > 16) {
        bitWidth = 32;
    } else if (bitWidth <= 8) {
        bitWidth = 8;
    } else {
        bitWidth = 16;
    }

    switch (GenAddr->AddressSpaceID) {
    case AcpiGenericSpaceIO:

        ASSERT(!(GenAddr->Address.LowPart & 0Xffff0000));
        ASSERT(GenAddr->Address.HighPart == 0);

        switch (bitWidth) {
        case 8:

            result = READ_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart);
            break;

        case 16:

            result = READ_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart);
            break;

        case 32:

            result = READ_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart);
            break;

        default:
            return 0;
        }

        break;

    case AcpiGenericSpaceMemory:

        //
        // This code path depends on the fact that the addresses
        // in these structures have already been converted to
        // virtual addresses.
        //

        switch (bitWidth) {
        case 8:

            result = READ_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart);
            break;

        case 16:

            result = READ_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart);
            break;

        case 32:

            result = READ_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart);
            break;

        default:
            return 0;
        }

        break;

    default:
        return 0;
    }

    //
    // If the register is not actually byte-aligned, correct for
    // that.
    //

    if (result && (bitWidth != GenAddr->BitWidth)) {

      result >>= GenAddr->BitOffset;
      result &= ((0x1ul << GenAddr->BitWidth) - 1);

    }

    return result;
}

VOID
HalpWriteGenAddr(
    IN  PGEN_ADDR   GenAddr,
    IN  ULONG       Value
    )
{
    ULONG   i, result = 0, bitWidth, data, mask = 0;

    data = 0;

    //
    // Figure out how wide our target register is.
    //

    bitWidth = GenAddr->BitWidth +
               GenAddr->BitOffset;


    if (bitWidth > 16) {
        bitWidth = 32;
    } else if (bitWidth <= 8) {
        bitWidth = 8;
    } else {
        bitWidth = 16;
    }

    switch (GenAddr->AddressSpaceID) {
    case AcpiGenericSpaceIO:

        ASSERT(!(GenAddr->Address.LowPart & 0Xffff0000));
        ASSERT(GenAddr->Address.HighPart == 0);

        switch (bitWidth) {
        case 8:

            ASSERT(!(Value & 0xffffff00));

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart);
                mask = (UCHAR)~0 >> (8 - GenAddr->BitWidth);
                mask = (UCHAR)~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= (UCHAR)Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart,
                             (UCHAR)data);
            break;

        case 16:

            ASSERT(!(Value & 0xffff0000));

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart);
                mask = (USHORT)~0 >> (16 - GenAddr->BitWidth);
                mask = (USHORT)~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= (USHORT)Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart,
                              (USHORT)data);
            break;

        case 32:

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart);
                mask = (ULONG)~0 >> (32 - GenAddr->BitWidth);
                mask = ~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart,
                             data);
            break;

        default:
            return;
        }

        break;

    case AcpiGenericSpaceMemory:

        //
        // This code path depends on the fact that the addresses
        // in these structures have already been converted to
        // virtual addresses.
        //

        switch (bitWidth) {
        case 8:

            ASSERT(!(Value & 0xffffff00));

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart);
                mask = (UCHAR)~0 >> (8 - GenAddr->BitWidth);
                mask = (UCHAR)~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= (UCHAR)Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart,
                                 (UCHAR)data);
            break;

        case 16:

            ASSERT(!(Value & 0xffff0000));

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart);
                mask = (USHORT)~0 >> (16 - GenAddr->BitWidth);
                mask = (USHORT)~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= (USHORT)Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart,
                                  (USHORT)data);
            break;

        case 32:

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart);
                mask = (ULONG)~0 >> (32 - GenAddr->BitWidth);
                mask = ~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart, data);
            break;

        default:
            return;
        }

        break;

    default:
        return;
    }
}

NTSTATUS
HalpGetPlatformProperties(
    OUT PULONG Properties
    )
/*++

Routine Description:

    This function retrieves the platform properties as specified in
    the ACPI-style IPPT table if present on this platform.  The table
    itself would've been retrieved earlier.

Arguments:

    Properties - Pointer to a ULONG that will be updated
    to reflect the platform property flags if present.

Return Value:

    NTSTATUS - STATUS_SUCCESS indicates the table was present and the
    ULONG pointed to by Properties contains valid data.

--*/
{
    ULONG properties = 0;
    NTSTATUS status = STATUS_UNSUCCESSFUL;

    if (HalpPlatformPropertiesTable) {
        //
        // map IPPT flag to HAL_PLATFORM flag.  Note that these do not
        // necessarily have to match 1:1.
        //
        if (HalpPlatformPropertiesTable->Flags & IPPT_DISABLE_WRITE_COMBINING) {
            properties |= HAL_PLATFORM_DISABLE_WRITE_COMBINING;
        }

        if (HalpPlatformPropertiesTable->Flags & IPPT_DISABLE_PTCG_TB_FLUSH) {
            properties |= HAL_PLATFORM_DISABLE_PTCG;
        }

        if (HalpPlatformPropertiesTable->Flags & IPPT_DISABLE_UC_MAIN_MEMORY) {
            properties |= HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY;
        }

        status = STATUS_SUCCESS;
    }

    if ( HalpPlatformPropertiesEfiFlags )   {
        properties |= HalpPlatformPropertiesEfiFlags;
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(status)) {
        *Properties = properties;
    }

    return( status );
}

NTSTATUS
HalpGetCrossPartitionIpiInterface(
    OUT HAL_CROSS_PARTITION_IPI_INTERFACE * IpiInterface
    )
/*++

Routine Description:

    This function fills in the HAL_CROSS_PARTITION_IPI_INTERFACE
    structure pointed to by the argument with the appropriate hal
    function pointers.

Arguments:

    IpiInterface - Pointer to HAL_CROSS_PARTITION_IPI_INTERFACE
    structure.

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    IpiInterface->HalSendCrossPartitionIpi = HalpSendCrossPartitionIpi;
    IpiInterface->HalReserveCrossPartitionInterruptVector =
        HalpReserveCrossPartitionInterruptVector;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\bushnd.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\bushnd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\chiphacks.c ===
//
// This file simply includes the common sources from the current HAL
// directory.
//

#include "..\chiphacks.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\xxdisp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxdisp.c

Abstract:

    This module implements the HAL display initialization and output routines
    for a x86 system.

Author:

    David N. Cutler (davec) 27-Apr-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include <inbv.h>


VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    )
{
    return;
}

VOID
HalDisplayString (
    PUCHAR String
    )

{
    //
    // forward the call to the graphical boot driver...
    //

    InbvDisplayString(String); 

} // HalDisplayString()

VOID
HalQueryDisplayParameters (
    OUT PULONG WidthInCharacters,
    OUT PULONG HeightInLines,
    OUT PULONG CursorColumn,
    OUT PULONG CursorRow
    )
{
    return;
}

VOID
HalSetDisplayParameters (
    IN ULONG CursorColumn,
    IN ULONG CursorRow
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\xxacpi.h ===
/*++

  Copyright (c) 1997  Microsoft Corporation

Module Name:

    xxacpi.h

Abstract:


    This module contains definitions specific to the HAL's
    ACPI function.

Author:

    Jake Oshins (jakeo) Feb. 18, 1997

Revision History:

	Todd Kjos (HP) (v-tkjos) 1-Jun-1998: Initial IA64 port

--*/

#if !defined(_XXACPI_H_)
#define _XXACPI_H_

#include "eisa.h"
#include "ntacpi.h"

//
// General ACPI structures
//
typedef struct {
    BOOLEAN     GeneralWakeupEnable;
    BOOLEAN     RtcWakeupEnable;
    TIME_FIELDS RtcWakeupTime;
} HAL_WAKEUP_STATE, *PHAL_WAKEUP_STATE;

//
// internal prototypes
//
PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

NTSTATUS
HalpSetupAcpiPhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    );

BOOLEAN
HalpAcpiPreSleep(
    SLEEP_STATE_CONTEXT Context
    );

NTSTATUS
HaliAcpiFakeSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

BOOLEAN
HalpAcpiPostSleep(
    ULONG Context
    );

NTSTATUS
HaliSetWakeAlarm (
	IN ULONGLONG	WakeSystemTime,
	IN PTIME_FIELDS	WakeTimeFields OPTIONAL
	);

NTSTATUS
HalpSetWakeAlarm (
	IN ULONGLONG	WakeSystemTime,
	IN PTIME_FIELDS	WakeTimeFields OPTIONAL
	);

VOID
HaliSetWakeEnable(
	IN BOOLEAN	Enable
	);

VOID
HalpSleepGetProcState(
    IN OUT PKPROCESSOR_STATE ProcState
    );
BOOLEAN
HalpAcpiPicStateIntact(
    VOID
	);

VOID
HalpAcpiRestorePicState(
    VOID
    );

//
// The kernel leaves some space (64 byte) of the PCR for the HAL to use
// as it needs.
//

typedef struct {
    ULONG   Reserved1;  // this space is used by APIC stuff
    union {
        ULONG       AddrAndFlags;
        struct {
            USHORT  Addr;
            UCHAR   Flags;
            UCHAR   Spare1;
        } ;
    } PBlk;
} HALPCR, *PHALPCR;

//
// Global HAL-ACPI stuff
//
extern FADT HalpFixedAcpiDescTable;
extern HAL_WAKEUP_STATE HalpWakeupState;
extern ULONG HalpThrottleScale;
extern SLEEP_STATE_CONTEXT HalpSleepContext;
extern KPROCESSOR_STATE    HalpSleepProcState;

extern PUCHAR  HalpLowStub;
extern PVOID   HalpLowStubPhysicalAddress;
extern PVOID   HalpWakeVector;
extern PVOID   HalpVirtAddrForFlush;
extern PVOID   HalpPteForFlush;

#endif // _XXACPI_X_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\rangesup.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\rangesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\halnls.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\halnls.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ix8259.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ix8259.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\xxhal.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Component Name:

    HALIA64

Module Name:

    xxhal.c

Abstract:

    This module determines the HAL IA64 common features based on processor
    and platform types. This exposes the processor and system features
    that the HAL would use to enable / disable its own features.
    By the mean of HAL exported interfaces or exported global variables,
    the HAL exposes its supported features.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    ToBeSpecified

Revision History:

    3/23/2000 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

#include "halp.h"

extern ULONG HalpMaxCPEImplemented;
extern HALP_SAL_PAL_DATA HalpSalPalData;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpGetFeatureBits)
#endif

ULONG
HalpGetFeatureBits (
    VOID
    )
{
    ULONG   bits = HALP_FEATURE_INIT;
    PKPRCB  prcb = KeGetCurrentPrcb();

    //
    // Determine Processor type and System type.
    //
    // For the processor, this could come from:
    //  - PAL_BUS_GET_FEATURES
    //  - PAL_DEBUG_INFO        ??
    //  - PAL_FREQ_BASE
    //  - PAL_FREQ_RATIOS
    //  - PAL_PERF_MON_INFO
    //  - PAL_PROC_GET_FEATURES
    //  - PAL_REGISTER_INFO
    //  - PAL_VERSION
    //

    // NOT-YET...

    //
    // Determine Processor features:
    // like support for Processor Hardware Performance Monitor Events and
    // - HAL_NO_SPECULATION
    // - HAL_MCA_PRESENT

    // NOT-YET - should call PAL PERF_MON call.
    bits |= HAL_PERF_EVENTS;

    //
    // Determine Platform features:
    // like support for Platform Performance Monitor Events...
    //

    // NOT-YET - should call SAL calls.

    //
    // Default software HAL support for IA64 Errors (MCA, CMC, CPE).
    //
    // However, we already know if we found an ACPI platform interrupt entry which identifier
    // is PLATFORM_INT_CPE.
    //

    bits |= HAL_MCA_PRESENT;

    if (!(HalpSalPalData.Flags & HALP_SALPAL_CMC_BROKEN)) {

        bits |= HAL_CMC_PRESENT;
    }

    if (!(HalpSalPalData.Flags & HALP_SALPAL_CPE_BROKEN)) {

        bits |= HAL_CPE_PRESENT;
    }

    return bits;

} // HalpGetFeatureBits()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixbeep.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixbeep.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\xxbiosc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxbiosc.c

Abstract:

    This module implements the protect-mode routines necessary to make the
    transition to real mode and return to protected mode.

Author:

    John Vert (jvert) 29-Oct-1991


Environment:

    Kernel mode only.
    Probably a panic-stop, so we cannot use any system services.

Revision History:

--*/



//
// commented this file since real mode to protection switch
// requirement of 386 is not needed for ia64 
//

// #include "..\..\halx86\i386\xxbiosc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\xxmemory.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxmemory.c

Abstract:

    Provides routines to allow the HAL to map physical memory.

Author:

    John Vert (jvert) 3-Sep-1991

Environment:

    Phase 0 initialization only.

Revision History:

--*/

#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpAllocPhysicalMemory)
#endif


MEMORY_ALLOCATION_DESCRIPTOR    HalpExtraAllocationDescriptor;


PVOID
HalpMapPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages,
    IN MEMORY_CACHING_TYPE CacheType
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory
    reserved for the HAL.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - This is not used for IA64.  It is here just to keep the
                  interface consistent.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

    NULL - The requested block of physical memory could not be mapped.

--*/

{

    if (CacheType == MmCached) {

        return (PVOID)(((ULONG_PTR)KSEG_ADDRESS(PhysicalAddress.QuadPart >> PAGE_SHIFT)) |
               (PhysicalAddress.QuadPart & ~(-1 << PAGE_SHIFT)));

    } else {

        return (PVOID)(((ULONG_PTR)KSEG4_ADDRESS(PhysicalAddress.QuadPart >> PAGE_SHIFT)) |
               (PhysicalAddress.QuadPart & ~(-1 << PAGE_SHIFT)));

    }

}


PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG            NumberPages
)
/*++

Routine Description:

    Maps a physical memory address into virtual space by calling HalpMapPhysicalMemory but
    always in the MmNonCached mode. MMIO.

Arguments:

    PhysicalAddress - Supplies a physical address of the memory to be mapped

    NumberPages - Number of pages to map

Return Value:

    Virtual address pointer to the requested physical address

--*/
{
    return HalpMapPhysicalMemory(PhysicalAddress, NumberPages, MmNonCached);
} // HalpMapPhysicalMemory64()


VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    )

/*++

Routine Description:

    Release PTEs previously allocated to map memory by
    HalpMapPhysicalMemory.

    Note:  This routine does not free memory, it only releases
    the Virtual to Physical translation.

Arguments:

    VirtualAddress  Supplied the base VA of the address range to be
                    released.

    NumberPages     Supplied the length of the range.

Return Value.

    None.

--*/

{
    //
    // HalpMapPhysicalMemory returns an address in KSEG4 and it doesn't use a
    // page table, so no need to unmap.
    //
//    MmUnmapIoSpace(VirtualAddress, PAGE_SIZE * NumberPages);
    return;
}

PVOID
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG_PTR MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    )
/*++

Routine Description:

    Carves out N pages of physical memory from the memory descriptor
    list in the desired location.  This function is to be called only
    during phase zero initialization.  (ie, before the kernel's memory
    management system is running)

Arguments:

    MaxPhysicalAddress - The max address where the physical memory can be
    NoPages - Number of pages to allocate

Return Value:

    The physical address or NULL if the memory could not be obtained.

--*/
{
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PLIST_ENTRY NextMd;
    ULONG AlignmentOffset;
    ULONG_PTR MaxPageAddress;
    ULONG_PTR PhysicalAddress;

    MaxPageAddress = MaxPhysicalAddress >> PAGE_SHIFT;

    //
    // Scan the memory allocation descriptors and allocate map buffers
    //

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
        Descriptor = CONTAINING_RECORD(
                         NextMd,
                         MEMORY_ALLOCATION_DESCRIPTOR,
                         ListEntry
                         );

        AlignmentOffset = bAlignOn64k ?
            ((Descriptor->BasePage + 0x0f) & ~0x0f) - Descriptor->BasePage :
            0;

        //
        // Search for a block of memory which is contains a memory chuck
        // that is greater than size pages, and has a physical address less
        // than MAXIMUM_PHYSICAL_ADDRESS.
        //

        if ((Descriptor->MemoryType == LoaderFree ||
             Descriptor->MemoryType == MemoryFirmwareTemporary) &&
            (Descriptor->BasePage) &&
            (Descriptor->PageCount >= NoPages + AlignmentOffset) &&
            (Descriptor->BasePage + NoPages + AlignmentOffset < MaxPageAddress)) {

      PhysicalAddress =
         (Descriptor->BasePage + AlignmentOffset) << PAGE_SHIFT;
                break;
        }

        NextMd = NextMd->Flink;
    }

    //
    // Use the extra descriptor to define the memory at the end of the
    // original block.
    //


    ASSERT(NextMd != &LoaderBlock->MemoryDescriptorListHead);

    if (NextMd == &LoaderBlock->MemoryDescriptorListHead)
        return 0;

    //
    // Adjust the memory descriptors.
    //

    if (AlignmentOffset == 0) {

        Descriptor->BasePage  += NoPages;
        Descriptor->PageCount -= NoPages;

        if (Descriptor->PageCount == 0) {

            //
            // The whole block was allocated,
            // Remove the entry from the list completely.
            //

            RemoveEntryList(&Descriptor->ListEntry);

        }

    } else {

        if (Descriptor->PageCount - NoPages - AlignmentOffset) {

            //
            //  Currently we only allow one Align64K allocation
            //

            ASSERT (HalpExtraAllocationDescriptor.PageCount == 0);

            //
            // The extra descriptor is needed so intialize it and insert
            // it in the list.
            //

            HalpExtraAllocationDescriptor.PageCount =
                Descriptor->PageCount - NoPages - AlignmentOffset;

            HalpExtraAllocationDescriptor.BasePage =
                Descriptor->BasePage + NoPages + AlignmentOffset;

            HalpExtraAllocationDescriptor.MemoryType = MemoryFree;

            InsertHeadList(
                &Descriptor->ListEntry,
                &HalpExtraAllocationDescriptor.ListEntry
                );
        }


        //
        // Use the current entry as the descriptor for the first block.
        //

        Descriptor->PageCount = AlignmentOffset;
    }

    return (PVOID)PhysicalAddress;
}

BOOLEAN
HalpVirtualToPhysical(
    IN  ULONG_PTR           VirtualAddress,
    OUT PPHYSICAL_ADDRESS   PhysicalAddress
    )
{
    if (VirtualAddress >= KSEG3_BASE && VirtualAddress < KSEG3_LIMIT) {

        PhysicalAddress->QuadPart = VirtualAddress - KSEG3_BASE;

    } else if (VirtualAddress >= KSEG4_BASE && VirtualAddress < KSEG4_LIMIT) {

        PhysicalAddress->QuadPart = VirtualAddress - KSEG4_BASE;

    } else {

        return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\drivesup.c ===
#include "..\drivesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\halp.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\halp.h"

// #define NT_35           1       // build hal for NT 3.5

#ifdef NT_35
#undef ALLOC_PRAGMA
#undef MmLockPagableCodeSection(a)
#undef MmUnlockPagableImageSection(a)
#define MmLockPagableCodeSection(a)     NULL
#define MmUnlockPagableImageSection(a)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\xxstubs.c ===
//
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This implements the HAL routines which don't do anything on IA64.

Author:

    John Vert (jvert) 11-Jul-1991

Revision History:

--*/
#include "halp.h"



VOID
HalSaveState(
    VOID
    )

/*++

Routine Description:

    Saves the system state into the restart block.  Currently does nothing.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    HalDebugPrint(( HAL_ERROR, "HAL: HalSaveState called - System stopped\n" ));

    KeBugCheck(0);
}


BOOLEAN
HalDataBusError(
    VOID
    )

/*++

Routine Description:

    Called when a data bus error occurs.  There is no way to fix this on
    IA64.

Arguments:

    None

Return Value:

    FALSE

--*/

{
    HalDebugPrint(( HAL_ERROR, "HAL: HalDataBusError called - System stopped\n" ));

    KeBugCheck(0);
    return(FALSE);
}

BOOLEAN
HalInstructionBusError(
    VOID
    )

/*++

Routine Description:

    Called when an instruction bus error occurs.  There is no way to fix this
    on IA64.

Arguments:

    None

Return Value:

    FALSE

--*/

{
    HalDebugPrint(( HAL_ERROR, "HAL: HalInstructionBusError called - System stopped\n" ));

    KeBugCheck(0);
    return(FALSE);
}

//*******************************************************************
// Added by T. Kjos to temporarily stub out unused functions that
// are needed at link time.  These should all be removed as the
// "real" versions are developed.

// Function called for by all stubbed functions.  Can be used for
// breakpoints on unimplemented functions
VOID DbgNop() { return; }

// Macro for stubbed function.  If function is called then BugCheck
#define STUBFUNC(Func) \
ULONG Func () \
{ \
    HalDebugPrint(( HAL_FATAL_ERROR, "HAL: " # Func " - not yet implemented - System stopped\n" )); \
    DbgNop(); \
    KeBugCheck(0); \
}

// Macro for stubbed function.  If function is called then print
// warning and continue
#define STUBFUNC_NOP(Func) \
ULONG Func () \
{ \
    HalDebugPrint(( HAL_INFO, "HAL: " # Func " - not yet implemented\n" )); \
    DbgNop(); \
    return TRUE; \
}

// Macro for stubbed void function.  If function is called then print
// warning and continue
#define STUBVOIDFUNC_NOP(Func) \
VOID Func ( VOID ) \
{ \
    HalDebugPrint(( HAL_INFO, "HAL: " # Func " - not yet implemented\n" )); \
    DbgNop(); \
    return; \
}

// Macro for stubbed void function with 3 PVOID arguments.  
// If function is called then print warning and continue
#define STUBVOIDFUNC3PVOID_NOP(Func) \
VOID Func ( PVOID pv0, PVOID pv1, PVOID pv2 ) \
{ \
    HalDebugPrint(( HAL_INFO, "HAL: " # Func " - not yet implemented\n" )); \
    DbgNop(); \
    return; \
}

// Macro for stubbed ULONG values
#define STUBULONG(UlongVar) ULONG UlongVar = 0;

// Functions that are not yet implemented...
STUBVOIDFUNC_NOP(HalpResetAllProcessors)
STUBFUNC_NOP(HalpSetClockBeforeSleep)
STUBFUNC_NOP(HalpSetClockAfterSleep)
STUBFUNC_NOP(HalpSetWakeAlarm)
STUBFUNC(HalpRemapVirtualAddress)
STUBFUNC_NOP(HalaAcpiTimerInit)
STUBFUNC_NOP(Stub_LockNMILock)
STUBFUNC_NOP(HalAcpiTimerCarry)
STUBVOIDFUNC3PVOID_NOP(HalpPowerStateCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixcmos.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixcmos.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixaddr.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixaddr.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\xxtime.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxtime.c

Abstract:

    This module implements the HAL set/query realtime clock routines for
    an x86 system.

Author:

    David N. Cutler (davec) 5-May-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"


BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine queries the realtime clock.

    N.B. This routine assumes that the caller has provided any required
        synchronization to query the realtime clock information.

Arguments:

    TimeFields - Supplies a pointer to a time structure that receives
        the realtime clock information.

Return Value:

    If the power to the realtime clock has not failed, then the time
    values are read from the realtime clock and a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{
    EFI_TIME Time;
    EFI_STATUS Status;
    BOOLEAN    bstatus;

    //
    // Read the realtime clock values provided by the EFI Runtime interface.
    //

    Status = HalpCallEfi (
                  EFI_GET_TIME_INDEX,
                  (ULONGLONG)&Time,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0
                  );

#if 0
HalDebugPrint((HAL_INFO, "HalQueryRealTimeClock: EFI GetTime return status is %Id \n", Status));
#endif // 0

    if ( EFI_ERROR( Status ) )  {
        // if EFI error, let's reset the passed TIME_FIELDS structure.
        // The caller should check the return status.
        TimeFields->Year         = 0;
        TimeFields->Day          = 0;
        TimeFields->Hour         = 0;
        TimeFields->Minute       = 0;
        TimeFields->Second       = 0;
        TimeFields->Milliseconds = 0;
        TimeFields->Weekday      = 0;
        bstatus = FALSE;
    }
    else    {

        LARGE_INTEGER ntTime;

        TimeFields->Year         = Time.Year;
        TimeFields->Month        = Time.Month;
        TimeFields->Day          = Time.Day;
        TimeFields->Hour         = Time.Hour;
        TimeFields->Minute       = Time.Minute;
        TimeFields->Second       = Time.Second;
        TimeFields->Milliseconds = Time.Nanosecond / 1000000;

        //
        // Use RTL time functions to calculate the day of week.
        //  1/ RtlTimeFieldsToTime ignores the .Weekday field.
        //  2/ RtlTimeToTimeFields sets    the .Weekday field.
        //

        RtlTimeFieldsToTime( TimeFields, &ntTime );
        RtlTimeToTimeFields( &ntTime, TimeFields );

#if 0
HalDebugPrint(( HAL_INFO, "%d / %d / %d , %d:%d:%d:%d, %d\n",   TimeFields->Year,
                                                                TimeFields->Month,
                                                                TimeFields->Day,
                                                                TimeFields->Hour,
                                                                TimeFields->Minute,
                                                                TimeFields->Second,
                                                                TimeFields->Milliseconds,
                                                                TimeFields->Weekday));
HalDebugPrint((HAL_INFO, "Timezone is %d\n", Time.TimeZone));
#endif // 0
        bstatus = TRUE;

    }

    return ( bstatus );

} // HalQueryRealTimeClock()


BOOLEAN
HalSetRealTimeClock(
    IN PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine sets the realtime clock.

    N.B. This routine assumes that the caller has provided any required
        synchronization to set the realtime clock information.

Arguments:

    TimeFields - Supplies a pointer to a time structure that specifies the
        realtime clock information.

Return Value:

    If the power to the realtime clock has not failed, then the time
    values are written to the realtime clock and a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{
    EFI_TIME CurrentTime;
    EFI_TIME NewTime;
    EFI_STATUS Status;

    //
    // NOTE: One might think we need to raise IRQL here so that we don't get
    // pre-empted between reading the Timezone and Daylight Savings Time info
    // from the Realtime clock and writing it back.  However the EFI spec
    // states that it doesn't actually use or maintain these values, it merely
    // stores them so that the eventual caller of GetTime can figure out what
    // time base was used (UTC or Local) and if DST adjustments were made.
    //
    // Of course the whole idea of getting these values from the realtime clock
    // is wrong.  What we really want is the values associated with the time
    // value we were passed in and are about to write to the clock not what
    // currently is stored in the clock.
    //

    //
    // If the realtime clock battery is still functioning, then write
    // the realtime clock values, and return a function value of TRUE.
    // Otherwise, return a function value of FALSE.
    //

    Status = HalpCallEfi (
                  EFI_GET_TIME_INDEX,
                  (ULONGLONG)&CurrentTime,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0
                  );

    if ( EFI_ERROR( Status ) )  {

        return FALSE;
    }

    NewTime.Year       = TimeFields->Year;
    NewTime.Month      = (UINT8)TimeFields->Month;
    NewTime.Day        = (UINT8)TimeFields->Day;
    NewTime.Hour       = (UINT8)TimeFields->Hour;
    NewTime.Minute     = (UINT8)TimeFields->Minute;
    NewTime.Second     = (UINT8)TimeFields->Second;
    NewTime.Nanosecond = TimeFields->Milliseconds * 1000000;
    NewTime.TimeZone   = CurrentTime.TimeZone;
    NewTime.Daylight   = CurrentTime.Daylight;

    //
    // Write the realtime clock values.
    //

    Status = HalpCallEfi (
              EFI_SET_TIME_INDEX,
              (ULONGLONG)&NewTime,
              0,
              0,
              0,
              0,
              0,
              0,
              0
              );

#if 0
HalDebugPrint(( HAL_INFO, "HalSetRealTimeClock: EFI SetTime return status is %Id \n"
                          "%d / %d / %d , %d:%d:%d:%d\n"
                          "Timezone is %d\n"
                          "Daylight is %d\n",
                          Status,
                          NewTime.Month,
                          NewTime.Day,
                          NewTime.Year,
                          NewTime.Hour,
                          NewTime.Minute,
                          NewTime.Second,
                          NewTime.Nanosecond,
                          NewTime.TimeZone,
                          NewTime.Daylight ));
#endif // 0

    return( !EFI_ERROR( Status ) );

} // HalSetRealTimeClock()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixfirm.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixfirm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixenvirv.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixenvirv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixinfo.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixinfo.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixidle.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixidle.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixhwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixhwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixisa.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixisa.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixmca.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixmca.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixmcaa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixmcaa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixbusdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixbusdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixcmos.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixcmos.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixmovnti.asm ===
;
; Include code from halx86
;

include ..\..\halx86\i386\ixmovnti.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixnmi.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixnmi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixmca.h ===
//
// Include code from halmca
// This is a cpp style symbolic link

#include "..\..\halmca\i386\ixmca.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixisasup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#ifndef MCA
#include "..\..\halx86\i386\ixisasup.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixpcibrd.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI     1

#include "..\..\halx86\i386\ixpcibrd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixmcabus.c ===
//
// Include code from halmca
// This is a cpp style symbolic link

#ifdef MCA
#include "..\..\halmca\i386\ixmcabus.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixisabus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link
//

#include "..\..\halx86\i386\ixisabus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixmcasup.c ===
//
// Include code from halmca
// This is a cpp style symbolic link

#ifdef MCA
#include "..\..\halmca\i386\ixmcasup.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixpcibus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI     1

#include "..\..\halx86\i386\ixpcibus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixpciint.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI     1

#include "..\..\halx86\i386\ixpciint.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixphwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixphwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixreboot.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixreboot.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixsleep.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixsleep.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixslpsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixslpsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixslpctx.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixslpctx.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixthunk.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixthunk.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixusage.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixusage.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixpcisup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI     1

#include "..\..\halx86\i386\ixpcisup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixpnpdrv.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixpnpdrv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\ixslpctx.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixslpctx.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
;
; Module Name:
;
;    mpclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Ron Mosgrove (Intel) Aug 1993
;       Modified to support PC+MP Systems
;--

.586p
        .xlist
include hal386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include callconv.inc
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
include i386\mp8254.inc

        .list

        EXTRNP  _KeUpdateSystemTime,0
        EXTRNP  _KeUpdateRunTime,1,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRNP  _HalpAcquireSystemHardwareSpinLock  ,0
        EXTRNP  _HalpReleaseSystemHardwareSpinLock  ,0

        EXTRNP  _HalpSetInitialClockRate,0

        EXTRNP  _HalpMcaQueueDpc, 0
        EXTRNP  _KeQueryPerformanceCounter, 1

        extrn   _HalpRtcTimeIncrements:DWORD
        extrn   _KdEnteredDebugger:DWORD

        extrn   _HalpTimerWatchdogEnabled:DWORD
        extrn   _HalpTimerWatchdogStorage:DWORD
        extrn   _HalpTimerWatchdogCurFrame:DWORD
        extrn   _HalpTimerWatchdogLastFrame:DWORD
        extrn   _HalpTimerWatchdogStorageOverflow:DWORD
ifdef ACPI_HAL
ifdef NT_UP
        EXTRNP  _HalpBrokenPiix4TimerTick, 0
        extrn   _HalpBrokenAcpiTimer:byte
endif        
endif        

ifdef MMTIMER
	EXTRNP  _HalpmmTimerClockInterrupt, 0

MMT_VECTOR              EQU     0D3h
endif
	
;
; Constants used to initialize CMOS/Real Time Clock
;

CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port
CMOS_STATUS_BUSY        EQU     80H     ; Time update in progress

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate
REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B

;
; RegisterAInitByte sets 8Hz clock rate, used during init to set up
; KeStallExecutionProcessor, etc.  (See RegASystemClockByte below.)
;

RegisterAInitByte       EQU     00101101B ; RT/CMOS Register 'A' init byte
                                        ; 32.768KHz Base divider rate
                                        ;  8Hz int rate, period = 125.0ms
PeriodInMicroSecond     EQU     125000  ;

COUNTER_TICKS_AVG_SHIFT EQU     4
COUNTER_TICKS_FOR_AVG   EQU     16
PAGE_SIZE               EQU     1000H
FRAME_COPY_SIZE         EQU     64

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
;  There is a "C" version of this structure in MPCLOCKC.C
;

TimeStrucSize EQU 20

RtcTimeIncStruc struc
    RTCRegisterA        dd  0   ;The RTC register A value for this rate
    RateIn100ns         dd  0   ;This rate in multiples of 100ns
    RateAdjustmentNs    dd  0   ;Error Correction (in ns)
    RateAdjustmentCnt   dd  0   ;Error Correction (as a fraction of 256)
    IpiRate             dd  0   ;IPI Rate Count (as a fraction of 256)
RtcTimeIncStruc ends

ifdef DBGSSF
DebugSSFStruc struc
        SSFCount1   dd      0
        SSFCount2   dd      0
        SSFRdtsc1   dd      0
        SSFRdtsc2   dd      0
        SSFRdtsc3   dd      0

        SSFRna1     dd      0
        SSFRna2     dd      0
        SSFRna3     dd      0

DebugSSFStruc ends

        public HalpDbgSSF
HalpDbgSSF  db  (size DebugSSFStruc) * 10 dup (0)

endif

    ALIGN dword

        public  RTCClockFreq
        public  RegisterAClockValue

RTCClockFreq          dd      156250
RegisterAClockValue   dd      00101010B ; default interval = 15.6250 ms

MINIMUM_STALL_FACTOR    EQU     10H     ; Reasonable Minimum

        public  HalpP0StallFactor
HalpP0StallFactor               dd    MINIMUM_STALL_FACTOR
        public  HalpInitStallComputedCount
HalpInitStallComputedCount      dd    0
        public  HalpInitStallLoopCount
HalpInitStallLoopCount          dd    0

    ALIGN   dword
;
; Clock Rate Adjustment Counter.  This counter is used to keep a tally of
;   adjustments needed to be applied to the RTC rate as passed to the
;   kernel.
;

        public  _HalpCurrentRTCRegisterA, _HalpCurrentClockRateIn100ns
        public  _HalpCurrentClockRateAdjustment, _HalpCurrentIpiRate
        public  _HalpIpiRateCounter, _HalpNextMSRate, _HalpPendingRate
        public  _HalpRateAdjustment
_HalpCurrentRTCRegisterA        dd      0
_HalpCurrentClockRateIn100ns    dd      0
_HalpCurrentClockRateAdjustment dd      0
_HalpCurrentIpiRate             dd      0
_HalpIpiRateCounter             dd      0
_HalpNextMSRate                 dd      0
_HalpPendingRate                dd      0
_HalpRateAdjustment             dd      0

ifdef ACPI_HAL
	public _HalpCurrentMSRateTableIndex
_HalpCurrentMSRateTableIndex    dd      0
endif
	
;
;  HalpUse8254      - flag to indicate 8254 should be used
;  HalpSample8254   - count to sample 8254
;
;   N.B. access to the 8254 is gaurded with the Cmos lock
;
        public  _HalpUse8254
_HalpUse8254                db  0
_HalpSample8254             db  0
_b8254Reserved              dw  0


;
; Flag to tell clock routine when P0 can Ipi Other processors
;

        public _HalpIpiClock
_HalpIpiClock dd 0

        public _HalpClockWork, _HalpClockSetMSRate, _HalpClockMcaQueueDpc
_HalpClockWork label dword
    _HalpClockSetMSRate     db  0
    _HalpClockMcaQueueDpc   db  0
    _bReserved1             db  0
    _bReserved2             db  0

;
; timer latency watchdog variables
;

        public  _HalpWatchdogAvgCounter, _HalpWatchdogCountLow, _HalpWatchdogCountHigh
        public  _HalpWatchdogTscLow, _HalpWatchdogTscHigh

    _HalpWatchdogAvgCounter dd  0
    _HalpWatchdogCountLow   dd  0
    _HalpWatchdogCountHigh  dd  0
    _HalpWatchdogTscLow     dd  0
    _HalpWatchdogTscHigh    dd  0

_DATA   ends


PAGELK    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;   This routine initialize system time clock using RTC to generate an
;   interrupt at every 15.6250 ms interval at APIC_CLOCK_VECTOR
; 
;   It also initializes the 8254 if the 8254 is to be used for performance
;   counters.
;
;   See the definition of RegisterAClockValue if clock rate needs to be
;   changed.
;
;   This routine assumes it runs during Phase 0 on P0.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

;
; timer latency watchdog initialization
;
        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

        rdtsc
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx
        xor     eax, eax
        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, eax
@@:    

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

        stdCall _HalpSetInitialClockRate

;
;   Set the interrupt rate to what is actually needed
;
        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     eax, _HalpCurrentRTCRegisterA
        shl     ax, 8
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

;
; For HALAACPI (free), init the 8254 so we can use it to
; verify the ACPI timer frequency
; 
ifdef ACPI_HAL
ifdef NT_UP
	jmp	short Hic50	  
endif
endif
	cmp     _HalpUse8254, 0
	jz      short Hic90

Hic50:
        stdCall   _HalpAcquireSystemHardwareSpinLock      ; intr disabled

        ; Program 8254 to count down the maximum interval 
        ; (8254 access is gaurded with CmosSpinLock)

        mov     eax, PERFORMANCE_INTERVAL
        mov     ecx, eax

        ; set up counter 0 for periodic, binary count-down from max value
                
        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al    ; program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al       ; program counter 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al       ; program counter 0 MSB count


        or      _HalpUse8254, PERF_8254_INITIALIZED
        stdCall   _HalpReleaseSystemHardwareSpinLock

Hic90:
        popfd                           ; restore caller's eflag
        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

PAGELK  ends

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


        page ,132
        subttl  "System Clock Interrupt"
;++
;
; Routine Description:
;
;
;    This routine is entered as the result of an interrupt generated by CLOCK2.
;    Its function is to dismiss the interrupt, raise system Irql to
;    CLOCK2_LEVEL, update performance counter and transfer control to the
;    standard system routine to update the system time and the execution
;    time of the current thread
;    and process.
;
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;    Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--

APIC_ICR_CLOCK  equ (DELIVER_FIXED OR ICR_ALL_EXCL_SELF OR APIC_CLOCK_VECTOR)

        ENTER_DR_ASSIST Hci_a, Hci_t

cPublicProc _HalpClockInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hci_a, Hci_t

;
; (esp) - base of trap frame
;
; dismiss interrupt and raise Irql
;

        push    APIC_CLOCK_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL,APIC_CLOCK_VECTOR,esp>

ifdef  NT_UP
ifdef ACPI_HAL
;
; Check to see if we need to fix up a broken PIIX4
;
        .if (_HalpBrokenAcpiTimer)
        stdCall _HalpBrokenPiix4TimerTick
        .endif
endif
endif        
        mov     al, _HalpUse8254
        or      al, al
        jz      short Hci90

        add     _HalpSample8254, 56h
        jnc     short Hci90

        ; Call KeQueryPerformanceCounter() so that wrap-around of 8254 is 
        ; detected and the base value for performance counters updated.
        ; Ignore returned value and reset HalpSample8254.
        ;
        ; WARNING - change increment value above if maximum RTC time increment
        ; is increased to be more than current maximum value of 15.625 ms.
        ; Currently the call will be made every 3rd timer tick.

        xor     eax, eax
        mov     _HalpSample8254, al
        stdCall _KeQueryPerformanceCounter, <eax>
        
Hci90:

;
; This is the RTC interrupt, so we have to clear the
; interrupt flag on the RTC.
;
        stdCall _HalpAcquireCmosSpinLock

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize

        stdCall _HalpReleaseCmosSpinLock

        mov     eax, _HalpCurrentClockRateIn100ns
        xor     ebx, ebx

        ;
        ;  Adjust the tick count as needed
        ;    

        mov     ecx, _HalpCurrentClockRateAdjustment
        add     byte ptr _HalpRateAdjustment, cl
        sbb     eax, ebx

;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; eax = time increment of this tick
; ebx = 0
;

;
; With an APIC Based System we will force a clock interrupt to all other
; processors.  This is not really an IPI in the NT sense of the word, it
; uses the Local Apic to generate interrupts to other CPU's.
;

ifdef  NT_UP

    ;   UP implemention, we don't care about IPI's here

else ; ! NT_UP

        ;
        ;  See if we need to IPI anyone,  this happens only at the
        ;  Lowest supported frequency (ie the value KeSetTimeIncrement
        ;  is called with.  We have a IPI Rate based upon the current
        ;  clock rate relative to the lowest clock rate.
        ;    

        mov     ecx, _HalpIpiRateCounter
        add     ecx, _HalpCurrentIpiRate
        cmp     ch, bl
        mov     byte ptr _HalpIpiRateCounter, cl
        jz      short HalpDontSendClockIpi      ; No, Skip it

        ;
        ; Don't send vectors onto the APIC bus until at least one other
        ; processor comes on line.  Vectors placed on the bus will hang
        ; around until someone picks them up.
        ;

        cmp     _HalpIpiClock, ebx
        je      short HalpDontSendClockIpi

        ;
        ; At least one other processor is alive, send clock pulse to all
        ; other processors
        ;

        ; We use a destination shorthand and therefore only needs to
        ; write the lower 32 bits of the ICR.


        pushfd
        cli

;
; Now issue the Clock IPI Command by writing to the Memory Mapped Register
;

        STALL_WHILE_APIC_BUSY
        mov     dword ptr APIC[LU_INT_CMD_LOW], APIC_ICR_CLOCK

        popfd

HalpDontSendClockIpi:

endif ; NT_UP

        cmp dword ptr _HalpTimerWatchdogEnabled, 0
        jz  Hci15
        push    eax


;
; Timer latency watchdog code
;

        rdtsc

;
; Compare difference to watchdog count, while storing a copy of the
; current counter.
;

        push    eax
        push    edx

        sub     eax, _HalpWatchdogTscLow
        sbb     edx, _HalpWatchdogTscHigh

        pop     _HalpWatchdogTscHigh
        pop     _HalpWatchdogTscLow
        js      Hci115                      ; Was this a bogus counter?
                                            ;   (e.g, negative delta)

        push    eax
        push    edx
        mov     ecx, dword ptr _KdEnteredDebugger
        mov     eax, [ecx]                  ; eax =
        xor     edx, edx                    ;   InterlockedExchange( 
@@:     cmpxchg [ecx], edx                  ;      &KdEnteredDebugger,
        jnz     short @b                    ;      TRUE );
        or      al, al                      
        pop     edx
        pop     eax
        jnz     Hci14                       ; In the debugger? Yes, skip it.

        cmp     _HalpPendingRate, ebx       ; Was a new rate set during last
        jnz     Hci14                       ; tick?  Yes, skip this compare

;
; If we need to compute the average of the time-stamp counter for
; the current period, add the delta to the counter.
;

        cmp     _HalpWatchdogAvgCounter, ebx
        jnz     Hci12

        cmp     edx, _HalpWatchdogCountHigh
        ja      short Hci11
        jb      Hci14

        cmp     eax, _HalpWatchdogCountLow
        jbe     Hci14

Hci11:  
        cmp     dword ptr [_HalpTimerWatchdogCurFrame], 0
        je      short Hci115
        cmp     dword ptr [_HalpTimerWatchdogStorageOverflow], 0
        jne     short Hci115

;
; copy FRAME_COPY_SIZE dwords from the stack, or to next page boundary,
; whichever is less
;       

        push    esi
        push    edi
        lea     esi, [esp+8]
        lea     ecx, [esi + PAGE_SIZE - 1]
        and     ecx, NOT(PAGE_SIZE - 1)
        sub     ecx, esi
        shr     ecx, 2
        cmp     ecx, FRAME_COPY_SIZE
        jbe     short Hci112
        mov     ecx, FRAME_COPY_SIZE
Hci111:
        mov     edi, dword ptr _HalpTimerWatchdogCurFrame
        rep     movsd
        add     _HalpTimerWatchdogCurFrame, (FRAME_COPY_SIZE*4)
;
; If we didn't copy an entire FRAME_COPY_SIZE dwords, zero fill.
;
        mov     ecx, dword ptr _HalpTimerWatchdogCurFrame
        sub     ecx, edi
        shr     ecx, 2
        xor     eax, eax
        rep     stosd
        cmp     edi, dword ptr _HalpTimerWatchdogLastFrame
        jbe     short Hci112
        mov     dword ptr [_HalpTimerWatchdogStorageOverflow], 1
Hci112:

        pop     edi
        pop     esi

Hci115:

;
; Reset last time so that we're accurate after the trap
;
        rdtsc
        mov     _HalpWatchdogTscHigh, edx
        mov     _HalpWatchdogTscLow, eax
        
        jmp     short Hci14

Hci12:
;
; Increment the total counter, perform average when the count is reached
;

        add     _HalpWatchdogCountLow, eax
        adc     _HalpWatchdogCountHigh, edx        
        dec     _HalpWatchdogAvgCounter
        jnz     short Hci14

        mov     edx, _HalpWatchdogCountHigh
        mov     eax, _HalpWatchdogCountLow

;
; compute the average * 2, this measures when we have missed 
; an interrupt at this rate.
;                 
        mov     ecx, COUNTER_TICKS_AVG_SHIFT - 1
Hci13:    
        shr     edx, 1
        rcr     eax, 1
        loop    short Hci13

        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, edx

Hci14:
        pop     eax

Hci15:
;
; Check for any more work
;
        cmp     _HalpClockWork, ebx     ; Any clock interrupt work desired?
        jz      _KeUpdateSystemTime@0   ; No, process tick

        cmp     _HalpClockMcaQueueDpc, bl
        je      short CheckTimerRate

        mov     _HalpClockMcaQueueDpc, bl

;
; Queue MCA Dpc
;

        push    eax
        stdCall _HalpMcaQueueDpc            ; Queue MCA Dpc
        pop     eax

CheckTimerRate:
;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment of this tick
; ebx = 0
;
        cmp     _HalpClockSetMSRate, bl     ; New clock rate desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick


;
; Time of clock frequency is being changed.  See if we have changed rates
; since the last tick
;
        cmp     _HalpPendingRate, ebx       ; Was a new rate set durning last
        jnz     SetUpForNextTick            ; tick?  Yes, go update globals

ProgramTimerRate:

; (eax) = time increment for current tick

;
; A new clock rate needs to be set.  Setting the rate here will
; cause the tick after the next tick to be at the new rate.
; (the next tick is already in progress and will occur at the same
; rate as this tick)
;

        push    eax

        stdCall _HalpAcquireCmosSpinLock

        mov     eax, _HalpNextMSRate
        mov     _HalpPendingRate, eax  ; pending rate

        dec     eax
        mov     ecx, TimeStrucSize
        xor     edx, edx
        mul     ecx

        mov     eax, _HalpRtcTimeIncrements[eax].RTCRegisterA
        mov     _HalpCurrentRTCRegisterA, eax

        shl     ax, 8                   ; (ah) = (al)
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Set it

        cmp _HalpTimerWatchdogEnabled, 0
        jz  short @f
;
; Timer latency watchdog: schedule to recalibrate TSC delta
;
        rdtsc
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx

        xor     eax,eax
        mov     _HalpWatchdogCountHigh, eax
        mov     _HalpWatchdogCountLow, eax
@@:

        stdCall _HalpReleaseCmosSpinLock

        pop     eax
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

SetUpForNextTick:

;
; The next tick will occur at the rate which was programmed during the last
; tick. Update globals for new rate which starts with the next tick.
;
; We will get here if there is a request for a rate change.  There could
; been two requests.  That is why we are conmparing the Pending with the
; NextRate.
;
; (eax) = time increment for current tick
;
        push    eax

        mov     eax, _HalpPendingRate
        dec     eax

ifdef ACPI_HAL
ifdef NT_UP
;
; Update the index used by Piix4 workaround; this maps RTC system clock
; milisecond indices into PM Timer (PMT) milisecond indices
;
;     RTC { 0=1ms, 1=2ms, 2=4ms, 3=8ms, 4=15.6ms }
;
;     PMT { 0=1ms, 1=2ms, 2=3ms, ..., 14=15ms }
;
; So to convert from RTC index to PMT:  PMT = (1 << RTC) - 1
;
; NOTE: Since the PM timer array only goes to 15ms, we map our last RTC
;       index (4=15.6) to PMT index 14 (15ms) as a special case
;
	mov     edx, 1
	mov     cl, al
	shl     edx, cl
	dec     edx
	cmp     edx, 0fh  ; Check for special case RTC 15.6ms -> PMT 15ms
	jne     short @f
	dec     edx
	
@@:	
	mov	_HalpCurrentMSRateTableIndex, edx
endif
endif

        mov     ecx, TimeStrucSize
        xor     edx, edx
        mul     ecx

        mov     ebx, _HalpRtcTimeIncrements[eax].RateIn100ns
        mov     ecx, _HalpRtcTimeIncrements[eax].RateAdjustmentCnt
        mov     edx, _HalpRtcTimeIncrements[eax].IpiRate
        mov     _HalpCurrentClockRateIn100ns, ebx
        mov     _HalpCurrentClockRateAdjustment, ecx
        mov     _HalpCurrentIpiRate, edx

        mov     ebx, _HalpPendingRate
        mov     _HalpPendingRate, 0     ; no longer pending, clear it

        pop     eax

        cmp     ebx, _HalpNextMSRate      ; new rate == NextRate?
        jne     ProgramTimerRate        ; no, go set new pending rate

        mov     _HalpClockSetMSRate, 0  ; all done setting new rate
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick


stdENDP _HalpClockInterrupt

        page ,132
        subttl  "System Clock Interrupt - Non BSP"
;++
;
; Routine Description:
;
;
;   This routine is entered as the result of an interrupt generated by
;   CLOCK2. Its function is to dismiss the interrupt, raise system Irql
;   to CLOCK2_LEVEL, transfer control to the standard system routine to
;   the execution time of the current thread and process.
;
;   This routine is executed on all processors other than P0
;
;
; Arguments:
;
;   None
;   Interrupt is disabled
;
; Return Value:
;
;   Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;   Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--

        ENTER_DR_ASSIST HPn_a, HPn_t

cPublicProc _HalpClockInterruptPn    ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT HPn_a, HPn_t

;
; (esp) - base of trap frame
;
; dismiss interrupt and raise Irql
;

    push    APIC_CLOCK_VECTOR
    sub     esp, 4                  ; allocate space to save OldIrql
    stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL,APIC_CLOCK_VECTOR,esp>

    ;
    ; All processors will update RunTime for current thread
    ;

    sti
    ; TOS const PreviousIrql
    stdCall _KeUpdateRunTime,<dword ptr [esp]>

    INTERRUPT_EXIT          ; lower irql to old value, iret

    ;
    ; We don't return here
    ;

stdENDP _HalpClockInterruptPn


        page ,132
        subttl  "System Clock Interrupt - Stub"
;++
;
; Routine Description:
;
;
;   This routine is entered as the result of an interrupt generated by
;   CLOCK2. Its function is to interrupt and return.
;
;   This routine is executed on P0 During Phase 0
;
;
; Arguments:
;
;   None
;   Interrupt is disabled
;
; Return Value:
;
;--

APIC_ICR_CLOCK  equ (DELIVER_FIXED OR ICR_ALL_EXCL_SELF OR APIC_CLOCK_VECTOR)

        ENTER_DR_ASSIST HStub_a, HStub_t

cPublicProc _HalpClockInterruptStub    ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT HStub_a, HStub_t

;
; (esp) - base of trap frame
;

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize

Hpi10:  test    al, 80h
        jz      short Hpi15
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        jmp     short Hpi10
Hpi15:

        mov     dword ptr APIC[LU_EOI], 0      ; send EOI to APIC local unit

        ;
        ; Do interrupt exit processing without EOI
        ;

        SPURIOUS_INTERRUPT_EXIT

        ;
        ; We don't return here
        ;

stdENDP _HalpClockInterruptStub

ifdef MMTIMER	
        page ,132
        subttl  "Multi Media Event Timer System Clock Interrupt Stub"
;++
;
; Routine Description:
;
;
;   This routine is entered as the result of an interrupt generated by
;   CLOCK2, its function is to interrupt, call HalpmmTimerClockInterrupt
;   to update performance counters and adjust the system clock frequency
;   if necessary, to IPI other processors, and update system time
;
;   This routine is executed on P0
;
; Arguments:
;
;   None - Interrupt is disabled
;
; Return Value:
;
;--
	
        ENTER_DR_ASSIST Hmmt_a, Hmmt_t

cPublicProc _HalpmmTimerClockInterruptStub

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hmmt_a, Hmmt_t

;
; (esp) - base of trap frame
;
; dismiss interrupt and raise Irql
;

    push    MMT_VECTOR
    sub     esp, 4                  ; allocate space to save OldIrql
    stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL,MMT_VECTOR,esp>

    ;
    ; Update performace counter and adjust clock frequency if necessary
    ;

    stdCall _HalpmmTimerClockInterrupt

    INTERRUPT_EXIT          ; lower irql to old value, iret

    ;
    ; We don't return here
    ;

stdENDP _HalpmmTimerClockInterruptStub
endif	

ifdef ACPI_HAL
        page ,132
        subttl  "Query 8254 Counter"
;++
;
; ULONG
; HalpQuery8254Counter(
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the current value of the 8254 counter
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Current value of the 8254 counter is returned
;
;--

	cPublicProc _HalpQuery8254Counter, 0

        stdCall   _HalpAcquireSystemHardwareSpinLock      ; intr disabled

;
; Fetch the current counter value from the hardware
;

        mov     al, COMMAND_8254_LATCH_READ + COMMAND_8254_COUNTER0
                                        ; Latch PIT Ctr 0 command.
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, LSByte.
        IODelay
        movzx   ecx, al                 ; Zero upper bytes of (ECX).
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, MSByte.
        mov     ch, al                  ; (CX) = PIT Ctr 0 count.

	mov     eax, ecx
		
        stdCall   _HalpReleaseSystemHardwareSpinLock

        stdRET    _HalpQuery8254Counter

stdENDP _HalpQuery8254Counter
endif
		
_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mp8254.inc ===
;/*++
;
;   Copyright (c) 1996-97  Microsoft Corporation
;
;   Module Name:
;
;       mp8254.inc
;
;   Abstract:
;
;       This module contains common definitions for the 8254 used
;       by the timer tick routine and the query peformance counter
;       routine.
;
;   Author:
;
;       Shivnandan Kaushik
;
if 0	; Begin C only code	*/

//
// Constants used to initialize timer 0
//

#define TIMER1_DATA_PORT0    (PUCHAR)0x40 // Timer1, channel 0 data port
#define TIMER1_DATA_PORT1    (PUCHAR)0x41 // Timer1, channel 1 data port
#define TIMER1_DATA_PORT2    (PUCHAR)0x42 // Timer1, channel 2 data port
#define TIMER1_CONTROL_PORT  (PUCHAR)0x43 // Timer1 control port

#define TIMER2_DATA_PORT0    (PUCHAR)0x48 // Timer2, channel 0 data port
#define TIMER2_CONTROL_PORT  (PUCHAR)0x4B // Timer2 control port

#define TIMER_COMMAND_COUNTER0     0x00 // Select channel 0
#define TIMER_COMMAND_COUNTER1     0x40 // Select channel 1
#define TIMER_COMMAND_COUNTER2     0x80 // Select channel 2

#define TIMER_COMMAND_RW_16BIT     0x30 // Read/Write LSB firt then MSB
#define TIMER_COMMAND_MODE2           4 // Use mode 2
#define TIMER_COMMAND_MODE3           6
#define TIMER_COMMAND_BCD             0 // Binary count down
#define TIMER_COMMAND_LATCH_READ      0 // Latch read command

#define TIMER_CLOCK_IN          1193167

#define PERFORMANCE_FREQUENCY   1193182 // frequency of 8254
#define PERFORMANCE_INTERVAL  	0x0ffff // Maximum counter value

#define PERF_USE_8254           0x01
#define PERF_8254_INITIALIZED   0x40


/*
endif
;
; Begin assembly part of the definitions
;

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB first then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

PERFORMANCE_FREQUENCY   EQU     1193182 ; frequency of 8254
PERFORMANCE_INTERVAL    EQU     0ffffH  ; Maximum counter value

PERF_USE_8254           EQU     01h
PERF_8254_INITIALIZED   EQU     40h

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpclksup.asm ===
title  "Query Performace Counter"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    mpclksup.asm
;
; Abstract:
;
;    This module implements the code necessary to do 
;    QueryPerformaceCounter the MPS way.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;   jakeo 12-16-97  -- moved code from mpprofil.asm
;
;--

.586p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
include i386\mp8254.inc

        .list

        EXTRNP  _HalpAcquireSystemHardwareSpinLock,0
        EXTRNP  _HalpReleaseSystemHardwareSpinLock,0
        extrn   _HalpUse8254:BYTE

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

    ALIGN dword
;
; counters for the performance counter
;
        public _HalpPerfCounterLow, _HalpPerfCounterHigh
        public _HalpLastPerfCounterLow, _HalpLastPerfCounterHigh
_HalpPerfCounterLow             dd      0
_HalpPerfCounterHigh            dd      0
_HalpLastPerfCounterLow         dd      0
_HalpLastPerfCounterHigh        dd      0

_DATA   ends


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceCounter (
;    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
;    )
;
; Routine Description:
;
;    This routine returns current 64-bit performance counter and,
;    optionally, the Performance Frequency.
;
;    Note this routine can NOT be called at Profiling interrupt
;    service routine.  Because this routine depends on IRR0 to determine
;    the actual count.
;
;    Also note that the performace counter returned by this routine
;    is not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    PerformanceFrequency [TOS+4] - optionally, supplies the address
;        of a variable to receive the performance counter frequency.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--

;
; Parameter definitions
;

KqpcFrequency   EQU     [esp+4]         ; User supplied Performance Frequence

ifdef MMTIMER
cPublicProc _HalpAcpiTimerQueryPerfCount      ,1
else
cPublicProc _KeQueryPerformanceCounter      ,1
endif

        mov     al, _HalpUse8254
        or      al, al
        jnz     short KqpcUse8254

KqpcUseTSC:

        ; use time stamp counter as performance counter

        mov     ecx, KqpcFrequency
        or      ecx, ecx
        jz      short kpc10

        mov     eax, dword ptr PCR[PcHal][TSCHz]          ; Frequency LowPart
        mov     edx, dword ptr PCR[PcHal][TSCHz+4]        ; Frequency HighPart
        mov     dword ptr [ecx], eax
        mov     dword ptr [ecx+4], edx

kpc10:
        rdtsc
        add     eax, PCR[PcHal.PerfCounterLow]
        adc     edx, PCR[PcHal.PerfCounterHigh]
ifdef MMTIMER
        stdRET _HalpAcpiTimerQueryPerfCount
else
        stdRET    _KeQueryPerformanceCounter
endif
	
KqpcUse8254:
        ; use 8254 as time base for performance counters
        mov     ecx, KqpcFrequency
        or      ecx, ecx
        jz      short Kqpc10

        mov     dword ptr [ecx], PERFORMANCE_FREQUENCY
        mov     dword ptr [ecx+4], 0
        xor     ecx, ecx

Kqpc10:
        test    al, PERF_8254_INITIALIZED
        jz      KqpcNoInit

        stdCall   _HalpAcquireSystemHardwareSpinLock      ; intr disabled

        ; Read current offset from 8254 counter 0

        ; Counter Latch PIT Ctr 0 command

        mov     al, COMMAND_8254_LATCH_READ+COMMAND_8254_COUNTER0
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ; Read 8254 Ctr 0, LSByte.
        IODelay
        movzx   edx,al                  ; Zero upper bytes of (EDX).
        in      al, TIMER1_DATA_PORT0   ; Read 8254 Ctr 0, MSByte.
        mov     dh, al                  ; (DX) = 8254 Ctr 0 count.
        neg     edx                     ; PIT counts down, calculate interval
        add     edx, PERFORMANCE_INTERVAL

        ; (edx) = offset value from most recent base value in 
        ; _HalpPerfCounterHigh:_HalpPerfCounterLow

        mov     eax, _HalpPerfCounterLow
        add     eax, edx
        mov     edx, _HalpPerfCounterHigh
        adc     edx, ecx

        ; (edx:eax) = 64 bit counter value
        ;
        ; Check to see if the new value is sane - should be greater than 
        ; the last counter value returned by KeQueryPerformanceCounter. 
        ; Can happen only due to wrap around of the 8254. Correct by 
        ; updating the performance counter base.

        cmp     edx, _HalpLastPerfCounterHigh
        jg      short KqpcContinue      ; Current value > last returned value
        jl      short KqpcCatchupPerfCounter  ; Current value < last returned value
        
        ; high dwords equal, compare low dword

        cmp     eax, _HalpLastPerfCounterLow 
        jg      short KqpcContinue      ; Current value > last returned value

KqpcCatchupPerfCounter:
        ; Current counter value is not greater than the previously returned 
        ; counter value - can happen only due to the 8254 timer wraparound. 
        ; Update base to account for wrap around.

        add     eax, PERFORMANCE_INTERVAL
        adc     edx, ecx

        add     _HalpPerfCounterLow, PERFORMANCE_INTERVAL
        adc     _HalpPerfCounterHigh, ecx

KqpcContinue:
        mov     _HalpLastPerfCounterLow, eax 
        mov     _HalpLastPerfCounterHigh, edx 

        stdCall   _HalpReleaseSystemHardwareSpinLock
ifdef MMTIMER
        stdRET _HalpAcpiTimerQueryPerfCount
else
        stdRET _KeQueryPerformanceCounter
endif

KqpcNoInit:

        ; 8254 is not yet initialized. Just return 0 for now

        xor     eax, eax
        xor     edx, edx
ifdef MMTIMER
        stdRET _HalpAcpiTimerQueryPerfCount

stdENDP _HalpAcpiTimerQueryPerfCount
else
        stdRET _KeQueryPerformanceCounter

stdENDP _KeQueryPerformanceCounter
endif
	
        page ,132
        subttl  "Stall Execution"
;++
;
; VOID
; KeStallExecutionProcessor (
;    IN ULONG MicroSeconds
;    )
;
; Routine Description:
;
;    This function stalls execution for the specified number of microseconds.
;    KeStallExecutionProcessor
;
; Arguments:
;
;    MicroSeconds - Supplies the number of microseconds that execution is to be
;        stalled.
;
; Return Value:
;
;    None.
;
;--

MicroSeconds equ [esp + 12]

ifdef MMTIMER
cPublicProc _HalpAcpiTimerStallExecProc       ,1
else	
cPublicProc _KeStallExecutionProcessor       ,1
endif
cPublicFpo 1,2

        push    ebx
        push    edi

;
; Issue a CPUID to implement a "fence"
;
        xor     eax, eax
fence1: cpuid


;
; Get current TSC
;

        rdtsc

        mov     ebx, eax
        mov     edi, edx

;
; Determine ending TSC
;

        mov     ecx, MicroSeconds               ; (ecx) = Microseconds
        mov     eax, PCR[PcStallScaleFactor]    ; get per microsecond
        mul     ecx

        add     ebx, eax
        adc     edi, edx

;
; Wait for ending TSC
;

kese10: rdtsc
        cmp     edi, edx
        ja      short kese10
        jc      short kese20
        cmp     ebx, eax
        ja      short kese10

kese20: pop     edi
        pop     ebx
ifdef MMTIMER
        stdRET    _HalpAcpiTimerStallExecProc

stdENDP _HalpAcpiTimerStallExecProc
else
        stdRET    _KeStallExecutionProcessor

stdENDP _KeStallExecutionProcessor
endif

_TEXT   ends

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc _HalpRemoveFences
        mov     word ptr fence1, 0c98bh
        stdRET    _HalpRemoveFences
stdENDP _HalpRemoveFences


INIT    ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpclockc.c ===
/*++

Module Name:

    mpclockc.c

Abstract:

Author:

    Ron Mosgrove - Intel

Environment:

    Kernel mode

Revision History:



--*/

#include "halp.h"

//
// Define global data used to communicate new clock rates to the clock
// interrupt service routine.
//

struct RtcTimeIncStruc {
    ULONG RTCRegisterA;        // The RTC register A value for this rate
    ULONG RateIn100ns;         // This rate in multiples of 100ns
    ULONG RateAdjustmentNs;    // Error Correction (in ns)
    ULONG RateAdjustmentCnt;   // Error Correction (as a fraction of 256)
    ULONG IpiRate;             // IPI Rate Count (as a fraction of 256)
};

//
// The adjustment is expressed in terms of a fraction of 256 so that
// the ISR can easily determine when a 100ns slice needs to be subtracted
// from the count passed to the kernel without any expensive operations
//
// Using 256 as a base means that anytime the count becomes greater
// than 256 the time slice must be incremented, the overflow can then
// be cleared by AND'ing the value with 0xff
//

#define AVAILABLE_INCREMENTS  5

struct  RtcTimeIncStruc HalpRtcTimeIncrements[AVAILABLE_INCREMENTS] = {
    {0x026,      9766,   38,    96, /* 3/8 of 256 */   16},
    {0x027,     19532,   75,   192, /* 3/4 of 256 */   32},
    {0x028,     39063,   50,   128, /* 1/2 of 256 */   64},
    {0x029,     78125,    0,     0,                   128},
    {0x02a,    156250,    0,     0,                   256}
};


ULONG HalpInitialClockRateIndex = AVAILABLE_INCREMENTS-1;

extern ULONG HalpCurrentRTCRegisterA;
extern ULONG HalpCurrentClockRateIn100ns;
extern ULONG HalpCurrentClockRateAdjustment;
extern ULONG HalpCurrentIpiRate;

extern ULONG HalpNextMSRate;

#if !defined(_WIN64)
extern ULONG HalpClockWork;
extern BOOLEAN HalpClockSetMSRate;
#endif



VOID
HalpSetInitialClockRate (
    VOID
    );

VOID
HalpInitializeTimerResolution (
    ULONG Rate
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, HalpSetInitialClockRate)
#pragma alloc_text(INIT, HalpInitializeTimerResolution)
#endif


VOID
HalpInitializeTimerResolution (
    ULONG Rate
    )
/*++

Routine Description:

    This function is called to initialize the timer resolution to be
    something other then the default.   The rate is set to the closest
    supported setting below the requested rate.

Arguments:

    Rate - in 100ns units

Return Value:

    None

--*/

{
    ULONG   i, s;

    //
    // Find the table index of the rate to use
    //

    for (i=1; i < AVAILABLE_INCREMENTS; i++) {
        if (HalpRtcTimeIncrements[i].RateIn100ns > Rate) {
            break;
        }
    }

    HalpInitialClockRateIndex = i - 1;

    //
    // Scale IpiRate according to max TimeIncr rate which can be used
    //

    s = AVAILABLE_INCREMENTS - HalpInitialClockRateIndex - 1;
    for (i=0; i < AVAILABLE_INCREMENTS; i++) {
        HalpRtcTimeIncrements[i].IpiRate <<= s;
    }
}


VOID
HalpSetInitialClockRate (
    VOID
    )

/*++

Routine Description:

    This function is called to set the initial clock interrupt rate

Arguments:

    None

Return Value:

    None

--*/

{
    extern ULONG HalpNextMSRate;

    //
    // On ACPI timer machines, we need to init an index into the
    // milisecond(s) array used by pmtimerc.c's Piix4 workaround
    //
#ifdef ACPI_HAL
#ifdef NT_UP
    extern ULONG HalpCurrentMSRateTableIndex;

    HalpCurrentMSRateTableIndex = (1 << HalpInitialClockRateIndex) - 1;

    //
    // The Piix4 upper bound table ends at 15ms (index 14), so we'll have
    // to map our 15.6ms entry to it as a special case
    //
    if (HalpCurrentMSRateTableIndex == 0xF) {
        HalpCurrentMSRateTableIndex--;
    }
#endif
#endif

    HalpNextMSRate = HalpInitialClockRateIndex;

    HalpCurrentClockRateIn100ns =
        HalpRtcTimeIncrements[HalpNextMSRate].RateIn100ns;
    HalpCurrentClockRateAdjustment =
        HalpRtcTimeIncrements[HalpNextMSRate].RateAdjustmentCnt;
    HalpCurrentRTCRegisterA =
        HalpRtcTimeIncrements[HalpNextMSRate].RTCRegisterA;
    HalpCurrentIpiRate =
        HalpRtcTimeIncrements[HalpNextMSRate].IpiRate;

    HalpClockWork = 0;

    KeSetTimeIncrement (
        HalpRtcTimeIncrements[HalpNextMSRate].RateIn100ns,
        HalpRtcTimeIncrements[0].RateIn100ns
        );

}


#ifdef MMTIMER
ULONG
HalpAcpiTimerSetTimeIncrement(
    IN ULONG DesiredIncrement
    )
#else
ULONG
HalSetTimeIncrement (
    IN ULONG DesiredIncrement
    )
#endif
/*++

Routine Description:

    This function is called to set the clock interrupt rate to the frequency
    required by the specified time increment value.

Arguments:

    DesiredIncrement - Supplies desired number of 100ns units between clock
        interrupts.

Return Value:

    The actual time increment in 100ns units.

--*/

{
    ULONG   i;
    KIRQL   OldIrql;

    //
    // Set the new clock interrupt parameters, return the new time increment value.
    //


    for (i=1; i <= HalpInitialClockRateIndex; i++) {
        if (HalpRtcTimeIncrements[i].RateIn100ns > DesiredIncrement) {
            break;
        }
    }
    i = i - 1;

    KeRaiseIrql(HIGH_LEVEL,&OldIrql);

    HalpNextMSRate = i + 1;
    HalpClockSetMSRate = TRUE;

    KeLowerIrql (OldIrql);

    return (HalpRtcTimeIncrements[i].RateIn100ns);
}

#if defined(_WIN64)

#include "..\amd64\halcmn.h"

ULONG HalpCurrentMSRateTableIndex;

//
// Forward declared functions
//

VOID
HalpUpdateTimerWatchdog (
    VOID
    );

VOID
HalpClockInterruptWork (
    VOID
    );

VOID
HalpMcaQueueDpc (
    VOID
    );

extern PBOOLEAN KdEnteredDebugger;
extern PVOID HalpTimerWatchdogCurFrame;
extern PVOID HalpTimerWatchdogLastFrame;
extern ULONG HalpTimerWatchdogStorageOverflow;
extern ULONG HalpTimerWatchdogEnabled;

//
// Local constants
//

#define COUNTER_TICKS_FOR_AVG   16
#define FRAME_COPY_SIZE         (64 * sizeof(ULONG))

#define APIC_ICR_CLOCK (DELIVER_FIXED | ICR_ALL_EXCL_SELF | APIC_CLOCK_VECTOR)
                                   
//
// Flags to tell clock routine when P0 can Ipi other processors
//

ULONG HalpIpiClock = 0;

//
// Timer latency watchdog variables
//

ULONG HalpWatchdogAvgCounter;
ULONG64 HalpWatchdogCount;
ULONG64 HalpWatchdogTsc;
HALP_CLOCKWORK_UNION HalpClockWorkUnion;

//
// Clock rate adjustment counter.  This counter is used to keep a tally of
// adjustments needed to be applied to the RTC rate as passed to the kernel.
//

ULONG HalpCurrentRTCRegisterA;
ULONG HalpCurrentClockRateIn100ns = 0;
ULONG HalpCurrentClockRateAdjustment = 0;
ULONG HalpCurrentIpiRate = 0;

ULONG HalpNextMSRate = 0;
ULONG HalpPendingRate = 0;

//
// Other
//

BOOLEAN HalpUse8254 = FALSE;
UCHAR HalpSample8254 = 0;
UCHAR HalpRateAdjustment = 0;
ULONG HalpIpiRateCounter = 0;

VOID
HalpInitializeClock (
    VOID
    )

/*++

Routine Description:

    This routine initialize system time clock using RTC to generate an
    interrupt at every 15.6250 ms interval at APIC_CLOCK_VECTOR
 
    It also initializes the 8254 if the 8254 is to be used for performance
    counters.
 
    See the definition of RegisterAClockValue if clock rate needs to be
    changed.

    This routine assumes it runs during Phase 0 on P0.

Arguments:

    None

Return Value:

    None.

--*/

{
    ULONG flags;
    UCHAR regB;

    if (HalpTimerWatchdogEnabled != 0) {
        HalpWatchdogAvgCounter = COUNTER_TICKS_FOR_AVG;
        HalpWatchdogTsc = ReadTimeStampCounter();
        HalpWatchdogCount = 0;
    }

    flags = HalpDisableInterrupts();

    HalpSetInitialClockRate();

    //
    // Set the interrupt rate to what is actually needed
    //

    HalpAcquireCmosSpinLock();

    CMOS_WRITE(CMOS_STATUS_A,(UCHAR)HalpCurrentRTCRegisterA);

    //
    // Don't clobber the Daylight Savings Time bit in register B, because we
    // stash the LastKnownGood "environment variable" there.
    //

    regB = CMOS_READ(CMOS_STATUS_B);
    regB &= 1;
    regB |= REGISTER_B_ENABLE_PERIODIC_INTERRUPT;

    //
    // Write the register B value, then read C and D to initialize
    //

    CMOS_WRITE(CMOS_STATUS_B,regB);
    CMOS_READ(CMOS_STATUS_C);
    CMOS_READ(CMOS_STATUS_D);

    HalpReleaseCmosSpinLock();

    if (HalpUse8254 != FALSE) {

        HalpAcquireSystemHardwareSpinLock();

        //
        // Program the 8254 to count down the maximum interval (8254 access
        // is guarded with the system hardware spin lock).
        //
        // First program the count mode of the timer, then program the
        // interval.
        //

        WRITE_PORT_UCHAR(TIMER1_CONTROL_PORT,
                         TIMER_COMMAND_COUNTER0 |
                         TIMER_COMMAND_RW_16BIT |
                         TIMER_COMMAND_MODE2);
        IO_DELAY();

        WRITE_PORT_USHORT_PAIR(TIMER1_DATA_PORT0,
                               TIMER1_DATA_PORT0,
                               PERFORMANCE_INTERVAL);
        IO_DELAY();

        HalpUse8254 |= PERF_8254_INITIALIZED;
        HalpReleaseSystemHardwareSpinLock();
    }

    HalpRestoreInterrupts(flags);
}

BOOLEAN
HalpClockInterruptStub (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    CLOCK2.  Its function is to dismiss the interrupt and return.

    This routine is executed on P0 during phase 0.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

    TrapFrame - Supplise a pointer to the trap frame

Return Value:

    TRUE

--*/

{
    UCHAR status;

    UNREFERENCED_PARAMETER(Interrupt);
    UNREFERENCED_PARAMETER(ServiceContext);
    UNREFERENCED_PARAMETER(TrapFrame);

    //
    // Clear the interrupt flag on the RTC by banging on the CMOS.  On some
    // systems this doesn't work the first time we do it, so we do it twice.
    // It is rumored that some machines require more than this, but that
    // hasn't been observed with NT.
    //

    CMOS_READ(CMOS_STATUS_C);

    do {
        status = CMOS_READ(CMOS_STATUS_C);
    } while ((status & 0x80) != 0);

    return TRUE;
}

BOOLEAN
HalpClockInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    CLOCK2.  Its function is to dismiss the interrupt, raise system Irql to
    CLOCK2_LEVEL, update performance the counter and transfer control to
    the standard system routine to update the system time and the execution
    time of the current thread and process.

    Thie routine is executed only on P0

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    ULONG timeIncrement;
    ULONG flags;
    ULONG64 timeStamp;
    LONG64 timeStampDelta;
    ULONG rateCounter;

    if (HalpUse8254 != FALSE) {

        if (HalpSample8254 == 0) {

            //
            // Call KeQueryPerformanceCounter() so that wrap-around of 8254
            // is detected and the base value for performance counters
            // updated.  Ignore returned value and reset HalpSample8254.
            //
            // WARNING - change reset value above if maximum RTC time
            // increment is increased to be more than the current maximum 
            // value of 15.625 ms.  Currently the call will be made every
            // 3rd timer tick.
            //

            HalpSample8254 = 2;
            KeQueryPerformanceCounter(0);

        } else {

            HalpSample8254 -= 1;
        }
    }

    //
    // This is the RTC interrupt, so we have to clear the flag on the RTC.
    //

    HalpAcquireCmosSpinLock();

    //
    // Clear the interrupt flag on the RTC by banging on the CMOS.  On some
    // systems this doesn't work the first time we do it, so we do it twice.
    // It is rumored that some machines require more than this, but that
    // hasn't been observed with NT.
    //

    CMOS_READ(CMOS_STATUS_C);
    CMOS_READ(CMOS_STATUS_C);

    HalpReleaseCmosSpinLock();

    //
    // Adjust the tick count as needed.
    //

    timeIncrement = HalpCurrentClockRateIn100ns;
    HalpRateAdjustment += (UCHAR)HalpCurrentClockRateAdjustment;
    if (HalpRateAdjustment < HalpCurrentClockRateAdjustment) {
        timeIncrement--;
    }

    //
    // With an APIC based system we will force a clock interrupt to all other
    // processors.  This is not really an IPI in the NT sense of the word,
    // it uses the Local Apic to generate interrupts to other CPUs.
    //

#if !defined(NT_UP)

    //
    // See if we need to IPI anyone.  This happens only at the lowest
    // supported frequency (i.e. the value KeSetTimeIncrement is called
    // with).  We have an IPI Rate based on the current clock relative
    // to the lowest clock rate.
    //

    rateCounter = HalpIpiRateCounter + HalpCurrentIpiRate;
    HalpIpiRateCounter = rateCounter & 0xFF;

    if (HalpIpiRateCounter != rateCounter &&
        HalpIpiClock != 0) {

        //
        // Time to send an Ipi and at least one other processor is alive.
        //

        flags = HalpDisableInterrupts();

        HalpStallWhileApicBusy();
        LOCAL_APIC(LU_INT_CMD_LOW) = APIC_ICR_CLOCK;

        HalpRestoreInterrupts(flags);
    }

#endif // NT_UP

    if (HalpTimerWatchdogEnabled != 0) {
        HalpUpdateTimerWatchdog();
    }

    if (HalpClockWork != 0) {
        HalpClockInterruptWork();
    }

    KeUpdateSystemTime(Interrupt->TrapFrame,timeIncrement);

    return TRUE;
}

BOOLEAN
HalpClockInterruptPn (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    CLOCK2.  Its function is to dismiss the interrupt, raise system Irql to
    CLOCK2_LEVEL, update performance the counter and transfer control to
    the standard system routine to update the system time and the execution
    time of the current thread and process.

    This routine is executed on all processors other than P0.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER(ServiceContext);

    HalpEnableInterrupts();

    KeUpdateRunTime(Interrupt->TrapFrame);

    return TRUE;
}


VOID
HalpClockInterruptWork (
    VOID
    )
{
    struct RtcTimeIncStruc *timeIncStruc;
    BOOLEAN changeRate;

    //
    // There is more clock interrupt work to do
    //

    if (HalpClockMcaQueueDpc != FALSE) {

        //
        // Queue an MCA dpc
        // 

        HalpClockMcaQueueDpc = FALSE;
        HalpMcaQueueDpc();
    }

    if (HalpClockSetMSRate != FALSE) {

        //
        // The clock frequency is being changed.  See if we have changed
        // rates since the last tick.
        //

        if (HalpPendingRate != 0) {

            //
            // A new rate was set during the last tick, so update
            // globals.
            //
            // The next tick will occur at the rate which was programmed
            // during the last tick.  Update globals for the new rate
            // which starts with the next tick.
            //
            // We will get here if there is a request for a rate change.
            // There could have been two requests, that is why we are
            // comparing the Pending with the NextRate.
            //

            timeIncStruc = &HalpRtcTimeIncrements[HalpPendingRate - 1];

            HalpCurrentClockRateIn100ns = timeIncStruc->RateIn100ns;
            HalpCurrentClockRateAdjustment = timeIncStruc->RateAdjustmentCnt;
            HalpCurrentIpiRate = timeIncStruc->IpiRate;

            if (HalpPendingRate != HalpNextMSRate) {
                changeRate = TRUE;
            } else {
                changeRate = FALSE;
            }

            HalpPendingRate = 0;

            if (changeRate != FALSE) {

                //
                // A new clock rate needs to be set.  Setting the rate here
                // will cause the tick after the next tick to be at the new
                // rate.
                //
                // (The next tick is already in progress and will occur at
                // the same rate as this tick.)
                //
    
                HalpAcquireCmosSpinLock();

                HalpPendingRate = HalpNextMSRate;
    
                timeIncStruc = &HalpRtcTimeIncrements[HalpPendingRate - 1];
                HalpCurrentRTCRegisterA = timeIncStruc->RTCRegisterA;
    
                CMOS_WRITE(CMOS_STATUS_A,(UCHAR)HalpCurrentRTCRegisterA);
    
                if (HalpTimerWatchdogEnabled != FALSE) {
    
                    HalpWatchdogTsc = ReadTimeStampCounter();
                    HalpWatchdogCount = 0;
                    HalpWatchdogAvgCounter = COUNTER_TICKS_FOR_AVG;
                }
    
                HalpReleaseCmosSpinLock();
            }
        }
    }
}

VOID
HalpUpdateTimerWatchdog (
    VOID
    )
{
    ULONG stackStart;
    ULONG64 timeStamp;
    ULONG64 timeStampDelta;

    timeStamp = ReadTimeStampCounter();
    timeStampDelta = timeStamp - HalpWatchdogTsc;
    HalpWatchdogTsc = timeStamp;

    if ((LONG64)timeStampDelta < 0) {

        //
        // Bogus (negative) timestamp count.
        //

        return;
    }

    if (*KdEnteredDebugger != FALSE) {

        //
        // Skip if we're in the debugger.
        //

        return;
    }

    if (HalpPendingRate != 0) {

        //
        // A new rate was set during the last tick, discontinue
        // processing
        //

        return;
    }

    if (HalpWatchdogAvgCounter != 0) {

        //
        // Increment the total counter, perform average when the count is
        // reached.
        //

        HalpWatchdogCount += timeStampDelta;
        HalpWatchdogAvgCounter -= 1;

        if (HalpWatchdogAvgCounter == 0) {
            HalpWatchdogCount /= COUNTER_TICKS_FOR_AVG;
        }

        return;
    }

    if (timeStampDelta <= HalpWatchdogCount) {
        return;
    }

    if (HalpTimerWatchdogCurFrame != NULL &&
        HalpTimerWatchdogStorageOverflow == FALSE) {

        PVOID pSrc;
        ULONG copyBytes;

        //
        // Copy FRAME_COPY_SIZE dwords from the stack, or to next
        // page boundary, whichever is less.
        //

        pSrc = &stackStart;
        copyBytes = (ULONG)(PAGE_SIZE - ((ULONG_PTR)pSrc & (PAGE_SIZE-1)));
        if (copyBytes > FRAME_COPY_SIZE) {
            copyBytes = FRAME_COPY_SIZE;
        }

        RtlCopyMemory(HalpTimerWatchdogCurFrame, pSrc, copyBytes);
        (ULONG_PTR)HalpTimerWatchdogCurFrame += copyBytes;

        //
        // If we didn't copy an entire FRAME_COPY_SIZE buffer, zero
        // fill.
        //

        copyBytes = FRAME_COPY_SIZE - copyBytes;
        if (copyBytes > 0) {
            RtlZeroMemory(HalpTimerWatchdogCurFrame,copyBytes);
            (ULONG_PTR)HalpTimerWatchdogCurFrame += copyBytes;
        }

        if (HalpTimerWatchdogCurFrame >= HalpTimerWatchdogLastFrame) {
            HalpTimerWatchdogStorageOverflow = TRUE;
        }
    }
}

#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpaddr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
All rights reserved

Module Name:

    mpaddr.c

Abstract:

Author:

    Ken Reneris

Environment:

    Kernel mode only.

Revision History:


*/

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"
#include "pci.h"

#if DEBUGGING
#include "stdio.h"
#endif

#define STATIC  // functions used internal to this module

#define KEY_VALUE_BUFFER_SIZE 1024

#if DBG
extern ULONG HalDebug;
#endif

extern struct   HalpMpInfo HalpMpInfoTable;
extern USHORT   HalpIoCompatibleRangeList0[];
extern USHORT   HalpIoCompatibleRangeList1[];
extern BOOLEAN  HalpPciLockSettings;
extern WCHAR    HalpSzSystem[];

struct PcMpTable *PcMpTablePtr;

BOOLEAN
HalpTranslateIsaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

ULONG
HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

HalpGetEisaData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


NTSTATUS
HalpAdjustEisaResourceList (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

ULONG
HalpGetEisaInterruptVector (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

// --------------------------------------------------------------------

VOID
HalpInitBusAddressMapInfo (
    VOID
    );

STATIC PSUPPORTED_RANGES
HalpBuildBusAddressMap (
    IN UCHAR  MpsBusId
    );

PBUS_HANDLER
HalpLookupCreateHandlerForBus (
    IN PPCMPBUSTRANS    pBusType,
    IN ULONG            BusNo
    );

VOID
HalpInheritBusAddressMapInfo (
    VOID
    );

BOOLEAN
HalpMPSBusId2NtBusId (
    IN UCHAR                ApicBusId,
    OUT PPCMPBUSTRANS       *ppBusType,
    OUT PULONG              BusNo
    );

STATIC PSUPPORTED_RANGES
HalpMergeRangesFromParent (
    PSUPPORTED_RANGES   CurrentList,
    UCHAR               MpsBusId
    );

#if DEBUGGING
VOID
HalpDisplayBusInformation (
    PBUS_HANDLER    Bus
    );
#endif

//
// Internal prototypes
//

struct {
    ULONG       Offset;
    UCHAR       MpsType;
} HalpMpsRangeList[] = {
    FIELD_OFFSET (SUPPORTED_RANGES, IO),            MPS_ADDRESS_MAP_IO,
    FIELD_OFFSET (SUPPORTED_RANGES, Memory),        MPS_ADDRESS_MAP_MEMORY,
    FIELD_OFFSET (SUPPORTED_RANGES, PrefetchMemory),MPS_ADDRESS_MAP_PREFETCH_MEMORY,
    FIELD_OFFSET (SUPPORTED_RANGES, Dma),           MPS_ADDRESS_MAP_UNDEFINED,
    0,                                              MPS_ADDRESS_MAP_UNDEFINED
    };

#define RANGE_LIST(a,i) ((PSUPPORTED_RANGE) ((PUCHAR) a + HalpMpsRangeList[i].Offset))

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitBusAddressMapInfo)
#pragma alloc_text(INIT,HalpBuildBusAddressMap)
#pragma alloc_text(INIT,HalpInheritBusAddressMapInfo)
#pragma alloc_text(INIT,HalpMergeRangesFromParent)
#pragma alloc_text(INIT,HalpLookupCreateHandlerForBus)
#pragma alloc_text(PAGE,HalpAllocateNewRangeList)
#pragma alloc_text(PAGE,HalpFreeRangeList)
#pragma alloc_text(PAGE,HalpMpsGetParentBus)
#pragma alloc_text(PAGE,HalpMpsBusIsRootBus)
#endif


VOID
HalpInitBusAddressMapInfo (
    VOID
    )
/*++

Routine Description:

    Reads MPS bus addressing mapping table, and builds/replaces the
    supported address range mapping for the given bus.

    Note there's a little slop in this function as it doesn't reclaim
    memory allocated before this function is called, which it replaces
    pointers too.

--*/
{
    ULONG               BusNo;
    PPCMPBUSTRANS       pBusType;
    PMPS_EXTENTRY       ExtTable2, ExtTable;
    PBUS_HANDLER        Handler;
    PSUPPORTED_RANGES   Addresses;
    ULONG               i;
    BOOLEAN             Processed;

    //
    // Check for any address mapping information for the buses
    //
    // Note: We assume that if any MPS bus address map information
    // is found for a bus, that the MPS bios will supply all the
    // valid IO, Memory, and prefetch memory addresses for that BUS.
    // The bios can not supply some address tyeps for a given bus
    // without supplying them all.
    //

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this an address map entry?
        //

        if (ExtTable->Type == EXTTYPE_BUS_ADDRESS_MAP) {

            //
            // See if this bus has already been processed
            //

            Processed = FALSE;
            ExtTable2 = HalpMpInfoTable.ExtensionTable;
            while (ExtTable2 < ExtTable) {
                if (ExtTable2->Type == EXTTYPE_BUS_ADDRESS_MAP  &&
                    ExtTable2->u.AddressMap.BusId == ExtTable->u.AddressMap.BusId) {
                        Processed = TRUE;
                        break;
                }
                ExtTable2 = (PMPS_EXTENTRY) (((PUCHAR) ExtTable2) + ExtTable2->Length);
            }

            //
            // Determine the NT bus this map info is for
            //

            if (!Processed  &&
                HalpMPSBusId2NtBusId (ExtTable->u.AddressMap.BusId, &pBusType, &BusNo)) {

                //
                // Lookup the bushander for the bus
                //

                Handler = HalpLookupCreateHandlerForBus (pBusType, BusNo);

                if (Handler) {

                    //
                    // NOTE: Until we get better kernel PnP support, for now
                    // limit the ability of the system to move already BIOS
                    // initialized devices.  This is needed because the exteneded
                    // express BIOS can't give the OS any breathing space when
                    // it hands bus supported ranges, and there's currently not
                    // an interface to the kernel to obtain current PCI device
                    // settings.  (fixed in the future.)
                    //

                    HalpPciLockSettings = TRUE;

                    //
                    // Build BusAddress Map for this MPS bus
                    //

                    Addresses = HalpBuildBusAddressMap (ExtTable->u.AddressMap.BusId);




                    //
                    // Consoladate ranges
                    //

                    HalpConsolidateRanges (Addresses);

                    //
                    // Use current ranges for any undefined MPS ranges
                    //

                    for (i=0; HalpMpsRangeList[i].Offset; i++) {
                        if (HalpMpsRangeList[i].MpsType == MPS_ADDRESS_MAP_UNDEFINED) {
                            *RANGE_LIST(Addresses,i) = *RANGE_LIST(Handler->BusAddresses, i);
                        }
                    }

                    //
                    // Set bus'es support addresses
                    //

                    Handler->BusAddresses = Addresses;

                } else {

                    DBGMSG ("HAL: Initialize BUS address map - bus not an registered NT bus\n");

                }
            }
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }
}


STATIC PSUPPORTED_RANGES
HalpBuildBusAddressMap (
    IN UCHAR  MpsBusId
    )
/*++

Routine Description:

    Builds a SUPPORT_RANGES list for the supplied Mps Bus Id, by
    MPS bus addressing mapping descriptors.

    Note this function does not include any information contained
    in the MPS bus hierarchy descriptors.

Arguments:

    MpsBusId    - mps bus id of bus to build address map for.

Return:

    The bus'es supported ranges as defined by the MPS bus
    address mapping descriptors

--*/
{
    PMPS_EXTENTRY       ExtTable;
    PSUPPORTED_RANGES   Addresses;
    PSUPPORTED_RANGE    HRange, Range;
    ULONG               i, j, k;
    ULONG               Base, Limit, AddressSpace;
    PUSHORT             CompatibleList;

    Addresses = HalpAllocateNewRangeList();

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this an address map entry for the proper bus?
        //

        if (ExtTable->Type == EXTTYPE_BUS_ADDRESS_MAP  &&
            ExtTable->u.AddressMap.BusId == MpsBusId) {

            //
            // Find range type
            //

            for (i=0; HalpMpsRangeList[i].Offset; i++) {
                if (HalpMpsRangeList[i].MpsType == ExtTable->u.AddressMap.Type) {
                    HRange = RANGE_LIST(Addresses, i);
                    break;
                }
            }

            AddressSpace = HalpMpsRangeList[i].MpsType == MPS_ADDRESS_MAP_IO ? 1 : 0;
            if (HalpMpsRangeList[i].Offset) {
                HalpAddRange (
                    HRange,
                    AddressSpace,
                    0,      // SystemBase
                    ExtTable->u.AddressMap.Base,
                    ExtTable->u.AddressMap.Base + ExtTable->u.AddressMap.Length - 1
                );

            } else {

                DBGMSG ("HALMPS: Unkown address range type in MPS table\n");

            }
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    //
    // See if the BIOS wants to modify the buses supported addresses with
    // some pre-defined default information.  (yes, another case where the
    // bios wants to be lazy.)
    //

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this an CompatibleMap entry for the proper bus?
        //

        if (ExtTable->Type == EXTTYPE_BUS_COMPATIBLE_MAP  &&
            ExtTable->u.CompatibleMap.BusId == MpsBusId) {

            //
            // All currently defined default tables are for IO ranges,
            // we'll use that assumption here.
            //

            i = 0;
            ASSERT (HalpMpsRangeList[i].MpsType == MPS_ADDRESS_MAP_IO);
            HRange = RANGE_LIST(Addresses, i);
            AddressSpace = 1;

            CompatibleList = NULL;
            switch (ExtTable->u.CompatibleMap.List) {
                case 0: CompatibleList = HalpIoCompatibleRangeList0;        break;
                case 1: CompatibleList = HalpIoCompatibleRangeList1;        break;
                default: DBGMSG ("HAL: Unknown compatible range list\n");   continue; break;
            }

            for (j=0; j < 0x10; j++) {
                for (k=0; CompatibleList[k]; k += 2) {
                    Base  = (j << 12) | CompatibleList[k];
                    Limit = (j << 12) | CompatibleList[k+1];

                    if (ExtTable->u.CompatibleMap.Modifier) {

                        HalpRemoveRange (HRange, Base, Limit);

                    } else {

                        HalpAddRange (HRange, AddressSpace, 0, Base, Limit);

                    }
                }
            }

        }
        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    return Addresses;
}

NTSTATUS
HalpAddEisaBus (
    PBUS_HANDLER    Bus
    )
/*++

Routine Description:

    Adds another EISA bus handler to the system.
    Note: this is used for ISA buses as well - they are added as eisa
    buses, then cloned into isa bus handlers

--*/
{
    Bus->GetBusData = HalpGetEisaData;
    Bus->GetInterruptVector = HalpGetEisaInterruptVector;
    Bus->AdjustResourceList = HalpAdjustEisaResourceList;

    Bus->BusAddresses->Version      = BUS_SUPPORTED_RANGE_VERSION;
    Bus->BusAddresses->Dma.Limit    = 7;
    Bus->BusAddresses->Memory.Limit = 0xFFFFFFFF;
    Bus->BusAddresses->IO.Limit     = 0xFFFF;
    Bus->BusAddresses->IO.SystemAddressSpace = 1;
    Bus->BusAddresses->PrefetchMemory.Base = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpAddPciBus (
    PBUS_HANDLER    Bus
    )
{
    //
    // The firmware should have informed NT how many PCI buses
    // there where at NtDetect time
    //

    DBGMSG ("HAL: BIOS problem.  PCI bus must be report via IS_PCI_PRESENT bios call\n");
    return STATUS_UNSUCCESSFUL;
}

PBUS_HANDLER
HalpLookupCreateHandlerForBus (
    IN PPCMPBUSTRANS    pBusType,
    IN ULONG            BusNo
    )
{
    NTSTATUS        Status;
    PBUS_HANDLER    Handler;

    Handler = HaliHandlerForBus (pBusType->NtType, BusNo);

    if (!Handler  &&  pBusType->NewInstance) {

        //
        // This bus does not exist, but we know how to add it.
        //

        Status = HalRegisterBusHandler (
                    pBusType->NtType,
                    pBusType->NtConfig,
                    BusNo,
                    Internal,                   // parent bus
                    0,
                    pBusType->BusExtensionSize,
                    pBusType->NewInstance,
                    &Handler
                    );

        if (!NT_SUCCESS(Status)) {
            Handler = NULL;
        }
    }

    return Handler;
}


VOID
HalpDetectInvalidAddressOverlaps(
    VOID
    )
{
    ULONG i, j, k;
    PBUS_HANDLER Bus1, Bus2;
    PSUPPORTED_RANGE Entry;
    PSUPPORTED_RANGES NewRange;

    //
    // Find root PCI buses and detect invalid address overlaps
    //

    for(i=0; Bus1 = HaliHandlerForBus(PCIBus, i); ++i)  {
        if (((Bus1->ParentHandler) &&
             (Bus1->ParentHandler->InterfaceType != Internal)) ||
            !(Bus1->BusAddresses))  {
            continue;
        }

        for(j=i+1; Bus2 = HaliHandlerForBus(PCIBus, j); ++j)  {
            if (((Bus2->ParentHandler) &&
                (Bus2->ParentHandler->InterfaceType != Internal)) ||
                !(Bus2->BusAddresses))  {
                continue;
            }

            NewRange = HalpMergeRanges(Bus1->BusAddresses, Bus2->BusAddresses);
            HalpConsolidateRanges(NewRange);
            for(k=0; HalpMpsRangeList[k].Offset; k++) {
                Entry = RANGE_LIST(NewRange, k);
                while (Entry) {
                    if (Entry->Limit != 0)  {
                        // KeBugCheck(HAL_INITIALIZATION_FAILED);
                        DbgPrint("HalpDetectInvalidAddressOverlaps: Address Overlap Detected\n");
                        break;
                    } else  {
                        Entry = Entry->Next;
                    }
                }
            }
            HalpFreeRangeList(NewRange);
        }
    }
}

VOID
HalpInheritBusAddressMapInfo (
    VOID
    )
/*++

Routine Description:

    Reads MPS bus hierarchy descriptors and inherits any implied bus
    address mapping information.

    Note there's a little slop in this function as it doesn't reclaim
    memory allocated before this function is called, which it replaces
    pointers too.

--*/
{
    ULONG               BusNo, i, j;
    PPCMPBUSTRANS       pBusType;
    PMPS_EXTENTRY       ExtTable;
    PBUS_HANDLER        Bus, Bus2;
    PSUPPORTED_RANGES   Addresses;
    PUCHAR              p;

    //
    // Search for any bus hierarchy descriptors and inherit supported address
    // ranges accordingly.
    //

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this a bus hierarchy descriptor?
        //

        if (ExtTable->Type == EXTTYPE_BUS_HIERARCHY) {

            //
            // Determine the NT bus
            //

            if (HalpMPSBusId2NtBusId (ExtTable->u.BusHierarchy.BusId, &pBusType, &BusNo)) {

                Bus = HalpLookupCreateHandlerForBus (pBusType, BusNo);

                if (Bus) {
                    //
                    // Get ranges from parent
                    //

                    Addresses = HalpMergeRangesFromParent (
                                    Bus->BusAddresses,
                                    ExtTable->u.BusHierarchy.ParentBusId
                                    );

                    //
                    // Set bus'es support addresses
                    //

                    Bus->BusAddresses = HalpConsolidateRanges (Addresses);

                } else {

                    DBGMSG ("HAL: Inherit BUS address map - bus not an registered NT bus\n");
                }

            } else {

                DBGMSG ("HAL: Inherit BUS address map - unkown MPS bus type\n");
            }
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    //
    // Clone EISA bus ranges to matching ISA buses
    //

    BusNo = 0;
    for (; ;) {
        Bus  = HaliHandlerForBus(Eisa, BusNo);
        Bus2 = HaliHandlerForBus(Isa , BusNo);

        if (!Bus) {
            break;
        }

        if (!Bus2) {
            //
            // Matching ISA bus didn't exist, create it
            //

            HalRegisterBusHandler (
               Isa,
               ConfigurationSpaceUndefined,
               BusNo,
               Eisa,                // parent bus
               BusNo,
               0,
               NULL,
               &Bus2
               );

            Bus2->GetBusData = HalpNoBusData;
            Bus2->TranslateBusAddress = HalpTranslateIsaBusAddress;
        }

        //
        // Copy its parent bus ranges
        //

        Addresses = HalpCopyRanges (Bus->BusAddresses);

        //
        // Pull out memory ranges above the isa 24 bit supported ranges
        //

        HalpRemoveRange (
            &Addresses->Memory,
            0x1000000,
            0x7FFFFFFFFFFFFFFF
            );

        HalpRemoveRange (
            &Addresses->PrefetchMemory,
            0x1000000,
            0x7FFFFFFFFFFFFFFF
            );

        Bus2->BusAddresses = HalpConsolidateRanges (Addresses);
        BusNo += 1;
    }

    //
    // Inherit any implied interrupt routing from parent PCI buses
    //

    HalpMPSPCIChildren ();
    HalpDetectInvalidAddressOverlaps();

#if DBG
    if (HalDebug) {
        HalpDisplayAllBusRanges ();
    }
#endif
}

STATIC PSUPPORTED_RANGES
HalpMergeRangesFromParent (
    IN PSUPPORTED_RANGES  CurrentList,
    IN UCHAR              MpsBusId
    )
/*++
Routine Description:

    Shrinks this CurrentList to include only the ranges also
    supported by the supplied MPS bus id.


Arguments:

    CurrentList - Current supported range list
    MpsBusId    - mps bus id of bus to merge with

Return:

    The bus'es supported ranges as defined by the orignal list,
    shrunk by all parents buses supported ranges as defined by
    the MPS hierarchy descriptors

--*/
{
    ULONG               BusNo;
    PPCMPBUSTRANS       pBusType;
    PMPS_EXTENTRY       ExtTable;
    PBUS_HANDLER        Bus;
    PSUPPORTED_RANGES   NewList, MergeList, MpsBusList;
    BOOLEAN             FoundParentBus;
    ULONG               i;

    FoundParentBus = FALSE;
    MergeList      = NULL;
    MpsBusList     = NULL;

    //
    // Determine the NT bus
    //

    if (HalpMPSBusId2NtBusId (MpsBusId, &pBusType, &BusNo)) {

        //
        // Lookup the bushander for the bus
        //

        Bus = HaliHandlerForBus (pBusType->NtType, BusNo);
        if (Bus) {
            MergeList = Bus->BusAddresses;
        }
    }

    //
    // If NT bus not found, use supported range list from MPS bus
    // address map descriptors
    //

    if (!MergeList) {
        MpsBusList = HalpBuildBusAddressMap(MpsBusId);
        MergeList  = MpsBusList;
    }

    //
    // If no list to merge with use CurrentList
    //

    if (!MergeList) {
        return CurrentList;
    }


    if (!CurrentList) {

        //
        // If no CurrentList, then nothing to merge with
        //

        NewList = HalpCopyRanges (MergeList);

    } else {

        //
        // Merge lists together and build a new list
        //

        NewList = HalpMergeRanges (
                        CurrentList,
                        MergeList
                    );

        //
        // MPS doesn't define DMA ranges, so we don't
        // merge those down..   Add valid DMA ranges back
        //

        HalpAddRangeList (&NewList->Dma, &CurrentList->Dma);
    }


    //
    // See if bus has parent bus listed in the bus hierarchy descriptors
    //

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        if (ExtTable->Type == EXTTYPE_BUS_HIERARCHY  &&
            ExtTable->u.BusHierarchy.BusId == MpsBusId) {

            //
            // BIOS can only list one parent per bus
            //

            ASSERT (FoundParentBus == FALSE);
            FoundParentBus = TRUE;

            //
            // Merge current list with parent's supported range list
            //

            CurrentList = NewList;
            NewList = HalpMergeRangesFromParent (
                        CurrentList,
                        ExtTable->u.BusHierarchy.ParentBusId
                        );

            //
            // Free old list
            //

            HalpFreeRangeList (CurrentList);
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    //
    // Clean up
    //

    if (MpsBusList) {
        HalpFreeRangeList (MpsBusList);
    }

    return NewList;
}

NTSTATUS
HalpMpsGetParentBus(
    IN  UCHAR MpsBus,
    OUT UCHAR *ParentMpsBus
    )
{
    PMPS_EXTENTRY       ExtTable;

    PAGED_CODE();

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this a bus hierarchy descriptor?
        //

        if (ExtTable->Type == EXTTYPE_BUS_HIERARCHY) {

            if (ExtTable->u.BusHierarchy.BusId == MpsBus) {

                *ParentMpsBus = ExtTable->u.BusHierarchy.ParentBusId;
                return STATUS_SUCCESS;
            }
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    return STATUS_NOT_FOUND;
}

BOOLEAN
HalpMpsBusIsRootBus(
    IN  UCHAR MpsBus
    )
//
// The criteria for a Root Bus are as follows:
//
// 1.1 and 1.4 BIOS:
//
// 1)  The bus is number 0.
//
//
// 1.4 BIOS only:
//
// 2)  The bus does not have a parent.
// 
// 3)  The bus has address descriptors, if
//     there are any present in the machine.
//
//
// 4)  Last resort.  Scan all possible parent busses
//     looking for a bridge that generates this bus.
//
#define BRIDGE_HEADER_BUFFER_SIZE (FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.SubordinateBus) + 1)
{
    NTSTATUS status;
    UCHAR parentBus;
    PMPS_EXTENTRY ExtTable;
    BOOLEAN biosContainsAddressInfo = FALSE;
    UCHAR parentPci, childPci;
    PCI_SLOT_NUMBER bridgeSlot;
    PCI_COMMON_CONFIG pciData;
    ULONG bytesRead, d, f;
    PPCMPBUSTRANS busType;
    ULONG busNumber;

    PAGED_CODE();

    if (MpsBus == 0) {
        return TRUE;
    }
    
    //
    // Check to see if this MPS bus, though not
    // itself numbered 0, represents a bus that
    // is numbered 0.
    //

    if (HalpMPSBusId2NtBusId(MpsBus,
                             &busType,
                             &busNumber)) {

        if (busNumber == 0) {
            return TRUE;
        }
    }
    
    if (PcMpTablePtr->Revision >= 4) {
        
        if (NT_SUCCESS(HalpMpsGetParentBus(MpsBus,&parentBus))) {
            return FALSE;
        }

        ExtTable = HalpMpInfoTable.ExtensionTable;
        while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

            if ((ExtTable->Type == EXTTYPE_BUS_ADDRESS_MAP) ||
                (ExtTable->Type == EXTTYPE_BUS_COMPATIBLE_MAP)) {

                biosContainsAddressInfo = TRUE;

                if (ExtTable->u.AddressMap.BusId == MpsBus) {

                    //
                    // This entry corresponds to the bus that
                    // we care about.
                    //
                    return TRUE;
                }
            }

            ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
        }

        //
        // Compaq machines have their own special ways to be busted.  So,
        // when dealing with Compaq, never believe their MP table at all.
        // Go straight to probing the hardware.
        //

        if (!strstr(PcMpTablePtr->OemId, "COMPAQ")) {

            //
            // If this is not Compaq, assume that probing the hardware
            // is not yet necessary.
            //

            if (biosContainsAddressInfo) {

                //
                // Some bus in this machine contained address
                // info, but ours didn't.
                //

                return FALSE;
            }

            //
            // We can't figure out much from the MPS tables.
            //

            status = HalpPci2MpsBusNumber(MpsBus,
                                          &childPci);

            //
            // This wasn't a PCI bus.  Guess that it is a root.
            //

            if (!NT_SUCCESS(status)) {
                 return TRUE;
            }
        }
    }
    
    //
    // This is a PCI bus, so scan the other PCI busses looking
    // for it's parent.
    //

    childPci = MpsBus;
    parentPci = childPci - 1;
    
    while (TRUE) {
        
        //
        // Find the bridge.
        //

        bridgeSlot.u.AsULONG = 0;

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            for (f = 0; f < PCI_MAX_FUNCTION; f++) {

                bridgeSlot.u.bits.DeviceNumber = d;
                bridgeSlot.u.bits.FunctionNumber = f;

                bytesRead = HalGetBusDataByOffset(PCIConfiguration,
                                                  parentPci,
                                                  bridgeSlot.u.AsULONG,
                                                  &pciData,
                                                  0,
                                                  BRIDGE_HEADER_BUFFER_SIZE);

                if (bytesRead == (ULONG)BRIDGE_HEADER_BUFFER_SIZE) {

                    if ((pciData.VendorID != PCI_INVALID_VENDORID) &&
                        (PCI_CONFIGURATION_TYPE((&pciData)) != PCI_DEVICE_TYPE)) {

                        //
                        // This is a bridge of some sort.
                        //

                        if (pciData.u.type1.SecondaryBus == childPci) {

                            //
                            // It is also the bridge that creates the 
                            // PCI bus.  Thus this isn't a root.

                            return FALSE;
                        }
                    }
                }
            }
        }
        
        //
        // No bridge found. Must be a root.
        //

        if (parentPci == 0) {
            return TRUE;
        }

        parentPci--;
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpdat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixdat.c

Abstract:

    Declares various data which is initialize data, or pagable data.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "apic.inc"
#include "pci.h"
#include "pcip.h"
#include "pcmp_nt.inc"
#include "ixsleep.h"


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

//
// The following data is only valid during system initialiation
// and the memory will be re-claimed by the system afterwards
//

ADDRESS_USAGE HalpDefaultPcIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
#ifndef MCA
        0x000,  0x10,   // ISA DMA
        0x0C0,  0x10,   // ISA DMA
#else
        0x000,  0x20,   // MCA DMA
        0x0C0,  0x20,   // MCA DMA
#endif
        0x080,  0x10,   // DMA

        0x020,  0x2,    // PIC
        0x0A0,  0x2,    // Cascaded PIC

        0x040,  0x4,    // Timer1, Referesh, Speaker, Control Word
        0x048,  0x4,    // Timer2, Failsafe

#if 0   // HACKHACK Remove for now since Intelille mouse software claims it.
        0x061,  0x1,    // NMI  (system control port B)
#endif
        0x092,  0x1,    // system control port A

        0x070,  0x2,    // Cmos/NMI enable
#ifdef MCA
        0x074,  0x3,    // Extended CMOS

        0x090,  0x2,    // Arbritration Control Port, Card Select Feedback
        0x093,  0x2,    // Reserved, System board setup
        0x096,  0x2,    // POS channel select
#endif
        0x0F0,  0x10,   // coprocessor ports
        0xCF8,  0x8,    // PCI Config Space Access Pair
        0,0
    }
};

ADDRESS_USAGE HalpEisaIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
        0x0D0,  0x10,   // DMA
        0x400,  0x10,   // DMA
        0x480,  0x10,   // DMA
        0x4C2,  0xE,    // DMA
        0x4D4,  0x2C,   // DMA

        0x461,  0x2,    // Extended NMI
        0x464,  0x2,    // Last Eisa Bus Muster granted

        0x4D0,  0x2,    // edge/level control registers

        0xC84,  0x1,    // System board enable
        0, 0
    }
};

#ifndef ACPI_HAL

ADDRESS_USAGE HalpDetectedROM = {
    NULL,
    CmResourceTypeMemory,
    InternalUsage | RomResource,
    {
        0,0,                // 32 ROM blocks, get initialized in ixusage.c
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0
    }
};

#endif

ADDRESS_USAGE HalpImcrIoSpace = {
    NULL, CmResourceTypeMemory, InternalUsage,
    {
        0x022,  0x02,   // ICMR ports
        0, 0
    }
};

//
// From usage.c
//

WCHAR HalpSzSystem[] = L"\\Registry\\Machine\\Hardware\\Description\\System";
WCHAR HalpSzSerialNumber[] = L"Serial Number";

ADDRESS_USAGE  *HalpAddressUsageList = NULL;

//
// From ixpcibus.c
//

WCHAR rgzMultiFunctionAdapter[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";
WCHAR rgzPCIIdentifier[] = L"PCI";
WCHAR rgzPCICardList[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\PnP\\PCI\\CardList";

//
// From ixpcibrd.c
//

WCHAR rgzReservedResources[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SystemResources\\ReservedResources";

//
// From ixinfo.c
//

WCHAR rgzSuspendCallbackName[] = L"\\Callback\\SuspendHibernateSystem";

//
// Strings used for boot.ini options
// from mphal.c
//

UCHAR HalpSzBreak[]     = "BREAK";
UCHAR HalpSzOneCpu[]    = "ONECPU";
UCHAR HalpSzPciLock[]   = "PCILOCK";
UCHAR HalpSzTimerRes[]  = "TIMERES";
UCHAR HalpSzClockLevel[]= "CLKLVL";
UCHAR HalpSzUse8254[]   = "USE8254";
UCHAR HalpSzInterruptAffinity[]= "INTAFFINITY";
UCHAR HalpSzForceClusterMode[]= "MAXPROCSPERCLUSTER";

//
// From ixcmos.asm
//

UCHAR HalpSerialLen = 0;
UCHAR HalpSerialNumber[31] = {0};

//
// Copy of floating structure
// from detection code
//

struct FloatPtrStruct HalpFloatStruct;
UCHAR  rgzBadHal[] = "\n\n" \
            "HAL: This HAL.DLL requires an MPS version 1.1 system\n"    \
            "Replace HAL.DLL with the correct hal for this system\n"    \
            "The system is halting";

UCHAR  rgzRTCNotFound[]     = "HAL: No RTC device interrupt\n";

//
// Table to translate PCMP BusType to NT INTERFACE_TYPEs
// All Eisa, Isa, VL buses are squashed onto one space
// from mpsys.c
//

NTSTATUS
HalpAddEisaBus (
    PBUS_HANDLER    Bus
    );

NTSTATUS
HalpAddPciBus (
    PBUS_HANDLER    Bus
    );


//
// From ixmca.c
//
UCHAR   MsgMCEPending[] = MSG_MCE_PENDING;
WCHAR   rgzSessionManager[] = L"Session Manager";
WCHAR   rgzEnableMCE[] = L"EnableMCE";
WCHAR   rgzEnableMCA[] = L"EnableMCA";
WCHAR   rgzEnableCMC[] = L"EnableCMC";
WCHAR   rgzNoMCABugCheck[] = L"NoMCABugCheck";

//
// Timers
//

ULONGLONG  HalpProc0TSCHz;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

UCHAR HalpAuthenticAMD[]= "AuthenticAMD";
UCHAR HalpGenuineIntel[]= "GenuineIntel";

ULONG   HalpFeatureBits = 0;

UCHAR HalpDevPolarity [4][2] = {
    //
    //  Edge        Level
    {   CFG_HIGH,   CFG_LOW     },  // 00 - bus def
    {   CFG_HIGH,   CFG_HIGH    },  // 01 - high
    {   CFG_HIGH,   CFG_LOW     },  // 10 - undefined
    {   CFG_LOW,    CFG_LOW     }   // 11 - low
};


UCHAR HalpDevLevel [2][4] = {
    //                          must-be       must-be
    //  edge        level       edge          level
    {   CFG_EDGE,   CFG_EDGE,   CFG_EDGE,     CFG_ERR_LEVEL  },  // 0 - edge
    {   CFG_LEVEL,  CFG_LEVEL,  CFG_ERR_EDGE, CFG_LEVEL      }   // 1 - level
};

//
// Stuff for sleep or hibernate.
//


MOTHERBOARD_CONTEXT HalpMotherboardState = {0};
BOOLEAN             HalpOwnedDisplayBeforeSleep = FALSE;

volatile BOOLEAN HalpHiberInProgress = FALSE;
BOOLEAN HalpDisableHibernate = FALSE;

USHORT  HalpPciIrqMask = 0;
USHORT  HalpEisaIrqMask = 0;
USHORT  HalpEisaIrqIgnore = 0x1000;

//
// from mpdetect.c (needed because we reparse MPS table on hibernate resume)
//
UCHAR  rgzNoMpsTable[]      = "HAL: No MPS Table Found\n";
UCHAR  rgzNoApic[]          = "HAL: No IO APIC Found\n";
UCHAR  rgzBadApicVersion[]  = "HAL: Bad APIC Version\n";
UCHAR  rgzApicNotVerified[] = "HAL: APIC not verified\n";
UCHAR  rgzMPPTRCheck[]      = "HAL: MP_PTR invalid checksum\n";
UCHAR  rgzNoMPTable[]       = "HAL: MPS MP structure not found\n";
UCHAR  rgzMPSBadSig[]       = "HAL: MPS table invalid signature\n";
UCHAR  rgzMPSBadCheck[]     = "HAL: MPS table invalid checksum\n";
UCHAR  rgzBadDefault[]      = "HAL: MPS default configuration unknown\n";
UCHAR  rgzNoMem[]           = "HAL: Out of Memory\n";

//
// PAGELK handle
//
PVOID   HalpSleepPageLock = NULL;
PVOID   HalpSleepPage16Lock = NULL;

//
// Timer watchdog variables
//
ULONG   HalpTimerWatchdogEnabled = 0;
ULONG   HalpTimerWatchdogStorageOverflow = 0;
PVOID   HalpTimerWatchdogCurFrame;
PVOID   HalpTimerWatchdogLastFrame;
PCHAR   HalpTimerWatchdogStorage;

#ifndef ACPI_HAL
PCMPBUSTRANS    HalpTypeTranslation[] = {
  //    "INTERN", can't be interface_type internal
        "CBUS  ", FALSE, CFG_EDGE,     CBus,           NULL,           0,                 0,
        "CBUSII", FALSE, CFG_EDGE,     CBus,           NULL,           0,                 0,
        "EISA  ", FALSE, CFG_EDGE,     Eisa,           HalpAddEisaBus, EisaConfiguration, 0,
        "ISA   ", FALSE, CFG_EDGE,     Eisa,           HalpAddEisaBus, EisaConfiguration, 0,
        "MCA   ", FALSE, CFG_MB_LEVEL, MicroChannel,   NULL,           0,                 0,
        "MPI   ", FALSE, CFG_EDGE,     MPIBus,         NULL,           0,                 0,
        "MPSA  ", FALSE, CFG_EDGE,     MPSABus,        NULL,           0,                 0,
        "NUBUS ", FALSE, CFG_EDGE,     NuBus,          NULL,           0,                 0,
        "PCI   ", TRUE,  CFG_MB_LEVEL, PCIBus,         HalpAddPciBus,  PCIConfiguration,  sizeof (PCIPBUSDATA),
        "PCMCIA", FALSE, CFG_EDGE,     PCMCIABus,      NULL,           0,                 0,
        "TC    ", FALSE, CFG_EDGE,     TurboChannel,   NULL,           0,                 0,
        "VL    ", FALSE, CFG_EDGE,     Eisa,           HalpAddEisaBus, EisaConfiguration, 0,
        "VME   ", FALSE, CFG_EDGE,     VMEBus,         NULL,           0,                 0,
        "NEC98 ", FALSE, CFG_EDGE,     Isa,            HalpAddEisaBus, EisaConfiguration, 0,
        NULL,     FALSE, CFG_EDGE,     MaximumInterfaceType, NULL,     0,                 0
        } ;
#endif

UCHAR HalpInitLevel [4][4] = {
    //                               must-be          must-be
    //  edge          level          edge             level
    {   CFG_EDGE,     CFG_LEVEL,     CFG_MB_EDGE,     CFG_MB_LEVEL     },  // 00 - bus def
    {   CFG_MB_EDGE,  CFG_MB_EDGE,   CFG_MB_EDGE,     CFG_ERR_MB_LEVEL },  // 01 - edge
    {   CFG_ERR_EDGE, CFG_ERR_LEVEL, CFG_ERR_MB_EDGE, CFG_ERR_MB_LEVEL },  // 10 - undefined
    {   CFG_MB_LEVEL, CFG_MB_LEVEL,  CFG_ERR_MB_EDGE, CFG_MB_LEVEL     }   // 11 - level
};

BOOLEAN  HalpELCRChecked;


//
// From mpaddr.c
//

USHORT  HalpIoCompatibleRangeList0[] = {
    0x0100, 0x03ff,     0x0500, 0x07FF,     0x0900, 0x0BFF,     0x0D00, 0x0FFF,
    0, 0
    };

USHORT  HalpIoCompatibleRangeList1[] = {
    0x03B0, 0x03BB,     0x03C0, 0x03DF,     0x07B0, 0x07BB,     0x07C0, 0x07DF,
    0x0BB0, 0x0BBB,     0x0BC0, 0x0BDF,     0x0FB0, 0x0FBB,     0x0FC0, 0x0FDF,
    0, 0
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpconfig.asm ===
title "PC+MP configuration table processing"

;++
;
;Copyright (c) 1991  Microsoft Corporation
;Copyright (c) 1992  Intel Corporation
;All rights reserved
;
;INTEL CORPORATION PROPRIETARY INFORMATION
;
;This software is supplied to Microsoft under the terms
;of a license agreement with Intel Corporation and may not be
;copied nor disclosed except in accordance with the terms
;of that agreement.
;
;
;Module Name:
;
;    mpconfig.asm
;
;Abstract:
;
;    Build the default PC+MP configuration tables defined in the PC+MP
;    specification. This file contains no code. It statically builds the
;    default PC+MP configurations in data. C code declaring structures to
;    use these tables must use the "pack(1)" pragma to ensure they are byte
;    aligned.
;
;
;Author:
;
;    Rajesh Shah (Intel) Oct 1993
;
;Revision History:
;
;--
.386p

include pcmp.inc
include apic.inc

;
; Entry size in bytes for Bus entries, Io Apic entries, Io Apic interrupt
; input entries and Local Apic interrupt input entries in the PC+MP table.
;
COMMON_ENTRY_SIZE   equ     08H
;
; Default values for Processor entries in the PC+MP table.
;
DEFAULT_NUM_CPUS    equ     02H
PROC_ENTRY_SIZE     equ     14H
CPU_i486            equ     0421H
CPU_FEATURES        equ     01H     ; On-chip FPU

;
;  Default Apic Version values.
;
VERSION_82489DX     equ     01H    ; 8 bit APIC version register value.
VERSION_INTEGRATED  equ     11H    ; 8 bit APIC version register value.

;
; Default values for Bus entries in the PC+MP table
;
BUS_ID_0            equ     0H
BUS_INTI_POLARITY   equ     0H
BUS_INTI_LEVEL      equ     0H

; Macros to emit the 6 byte bus type string. The string is not
; NULL terminated. If the Bus string consists of less than 6
; characters, it is padded with space characters(ASCII 20h).

BUS_TYPE_EISA macro
    db      "EISA  "
endm

BUS_TYPE_ISA macro
    db      "ISA   "
endm

BUS_TYPE_PCI macro
    db      "PCI   "
endm

BUS_TYPE_MCA macro
    db      "MCA   "
endm

;
; Macros to build the different parts of the PC+MP table. See pcmp.inc
; for the layout of the table and its entries.

; Macro to build the HEADER part of the PC+MP table.
; It takes a parameter (NumOfEntries) that specifies the total number of
; data entries in the table. Processor entries are 20(decimal) bytes long,
; all other entry types are 8 bytes long. All default configurations have
; 2 processors. The table length is computed based on the NumOfEntries
; parameter.
;
Header macro NumEntries
    dd      PCMP_SIGNATURE      ;; ASCII "PCMP"
    dw      ( (DEFAULT_NUM_CPUS * PROC_ENTRY_SIZE) \
              + ((NumEntries - DEFAULT_NUM_CPUS) * COMMON_ENTRY_SIZE)\
              + HEADER_SIZE )           ;; Total table length
    db      1                           ;; PC+MP spec. revision
    db      0                           ;; Checksum
    db      8   dup (0)                 ;; OEM Id
    db      12  dup (0)                 ;; OEM Product Id
    dd      0                           ;; OEM table pointer
    dw      0                           ;; OEM table size
    dw      NumOfEntries                ;; Number of entries in DATA portion
    dd      LU_BASE_ADDRESS             ;; Default Loacal Apic address
    dd      0                           ;; Reserved (Not Used)
endm ;;Header

;
; Macro to build Processor entries of the PC+MP table
;
; Parameter ApicVersion specifes the Apic version (82489DX or integrated)
; Parameter IsBsp is used in the CPU Flags field, and specifies if this
; processor is the BSP processor
;
Processor macro LocalApicId, ApicVersion, IsBspCpu
    db      ENTRY_PROCESSOR             ;; Processor entry type
    db      LocalApicId                 ;; ID of Loacal Apic unit.
    db      ApicVersion                 ;; Must agree with IO Apic Version
    db      CPU_ENABLED OR IsBspCpu     ;; CpuFlags
    dd      CPU_i486                    ;; Default CPU type
    dd      CPU_FEATURES                ;; Default CPU features
    db      8 dup (0)                   ;; Reserved
endm ;Processor

;
; Macro to build Bus entries of the PC+MP table
;
Bus  macro BusId, BusString
    db      ENTRY_BUS                   ;; Bus entry type
    db      BusId                       ;; ID of this bus
    BusString                           ;; This parameter is a macro that
                                        ;; emits the 6 byte bus type string.
endm ;Bus

;
; Macro to build Io Apic entries of the PC+MP table
; Parameter IoApicVersion specifes the Apic version (82489DX or integrated)
; All default configurations have a single IO Apic.
;
IoApic  macro IoApicVersion
    db      ENTRY_IOAPIC                ;; IO APIC entry type
    db      IOUNIT_APIC_ID              ;; Default Io Apic ID
    db      IoApicVersion               ;; Must agree with Local APIC ver.
    db      IO_APIC_ENABLED             ;; enable the IO APIC by default,
    dd      IO_BASE_ADDRESS             ;; Default physical address of 1st
                                        ;; IO APIC.
endm ;IoApic

;
; Macro to build Io Apic interrupt input entries of the PC+MP table
; Since all default configurations have a single IO Apic, all the IO Apic
; interrput input entries are built for the default IO Apic. For all default
; configurations, the interrupt source bus is assumed to have a bus ID 0.
;
IoApicInti macro IntType,SourceBusIrq,ApicInti
    db      ENTRY_INTI                  ;; IO Apic interrupt input entry type
    db      IntType                     ;; NMI,SMI,ExtINT or INTR
    dw      BUS_INTI_POLARITY OR BUS_INTI_LEVEL ;; Default polarity and level
    db      BUS_ID_0                    ;; Bus Id on which interrupt arrives
    db      SourceBusIrq                ;; Bus relative IRQ at which
                                        ;; interrupt arrives
    db      IOUNIT_APIC_ID              ;; Apic Id of destination IO Apic
    db      ApicInti                    ;; Io Apic Interrupt input pin
                                        ;; number this interrupt goes to
endm  ;IoApicInti

;
; Macro to build Io Apic interrupt input entries of the PC+MP table
; Since all default configurations have a single IO Apic, all the IO Apic
; interrput input entries are built for the default IO Apic. For all default
; configurations, the interrupt source bus is assumed to have a bus ID 0.
;
ApicInti macro IntType,SourceBusId,SourceBusIrq,AInti
    db      ENTRY_INTI                  ;; IO Apic interrupt input entry type
    db      IntType                     ;; NMI,SMI,ExtINT or INTR
    dw      BUS_INTI_POLARITY OR BUS_INTI_LEVEL ;; Default polarity and level
    db      SourceBusId                 ;; Bus Id on which interrupt arrives
    db      SourceBusIrq                ;; Bus relative IRQ at which
                                        ;; interrupt arrives
    db      IOUNIT_APIC_ID              ;; Apic Id of destination IO Apic
    db      AInti                       ;; Io Apic Interrupt input pin
                                        ;; number this interrupt goes to
endm  ;ApicInti

;
; Macro to build Local Apic interruptinput entries of the PC+MP table
;
Linti macro IntType,SourceBusId,SourceBusIrq,LocalApicId,ApicInti
    db      ENTRY_LINTI                 ;; Local Apic Interrupt Input
    db      IntType                     ;; NMI,SMI,ExtINT or INTR.
    dw      BUS_INTI_POLARITY OR BUS_INTI_LEVEL ;; Polarity and level
    db      SourceBusId                 ;; Bus Id on which interrupt arrives
    db      SourceBusIrq                ;; Bus relative IRQ at which
                                        ;; interrupt arrives
    db      LocalApicId                 ;; Apic Id of destination Local Apic
    db      ApicInti                    ;; Local Apic Interrupt input pin
                                        ;; number this interrupt goes to
endm  ;Linti


PAGELK   SEGMENT  DWORD PUBLIC 'CODE'

; The PC+MP table consists of a fixed size HEADER and a variable
; number of DATA entries. The order of the DATA entries is as
; follows:
;
;  1) Processor entries (20 decimal bytes long). The Boot Strap
;     Processor (BSP) entry must be the first entry.
;  2) Bus entries (8 bytes long).
;  3) IO Apic entries (8 bytes long).
;  4) IO Apic interrupt input entries (8 bytes long).
;  5) Local Apic interrupt input entries (8 bytes long).
;
; All interrupting devices are connected to Bus ID 0 in the
; default configurations.
;
; Any C code using these tables must use the pack(1) pragma.

;
; PC+MP default configuration 1: ISA bus, 82489DX Apic.
;
    public _PcMpDefaultConfig1
_PcMpDefaultConfig1 label byte

    ; Create table HEADER.
    Header 14h

    ; Create processor entries
    Processor 0, VERSION_82489DX, BSP_CPU
    Processor 1, VERSION_82489DX, 0

    ; Create bus entries
    Bus 0, BUS_TYPE_ISA

    ; Create IO Apic entries.
    IoApic VERSION_82489DX

    ; Create IO Apic interrupt input entries.
    IoApicInti INT_TYPE_INTR,1,1        ; IO APIC IRQ 1, INTIN 1
    IoApicInti INT_TYPE_INTR,0,2        ; IO APIC IRQ 0, INTIN 2
    IoApicInti INT_TYPE_INTR,3,3        ; IO APIC IRQ 3, INTIN 3
    IoApicInti INT_TYPE_INTR,4,4        ; IO APIC IRQ 4, INTIN 4
    IoApicInti INT_TYPE_INTR,5,5        ; IO APIC IRQ 5, INTIN 5
    IoApicInti INT_TYPE_INTR,6,6        ; IO APIC IRQ 6, INTIN 6
    IoApicInti INT_TYPE_INTR,7,7        ; IO APIC IRQ 7, INTIN 7
    IoApicInti INT_TYPE_INTR,8,8        ; IO APIC IRQ 8, INTIN 8
    IoApicInti INT_TYPE_INTR,9,9        ; IO APIC IRQ 9, INTIN 9
    IoApicInti INT_TYPE_INTR,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    IoApicInti INT_TYPE_INTR,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    IoApicInti INT_TYPE_INTR,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    IoApicInti INT_TYPE_INTR,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    IoApicInti INT_TYPE_INTR,0eH,0eH    ; IO APIC IRQ 14, INTIN 14
    IoApicInti INT_TYPE_INTR,0fH,0fH    ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,0,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1

;
; PC+MP default configuration 2: EISA bus, 82489DX Apic.
;
    public _PcMpDefaultConfig2
_PcMpDefaultConfig2 label byte

    ; Create table HEADER.
    Header 14h

    ; Create processor entries

    Processor 0H, VERSION_82489DX, BSP_CPU
    Processor 01H, VERSION_82489DX, 0

    ; Create bus entries
    Bus 0, BUS_TYPE_EISA

    ; Create IO Apic entries.
      IoApic VERSION_82489DX

    ; Create IO Apic interrupt input entries.
    ; In configuration 2, the 8259 PIC fields the timer and DMA interrupts.
    ; The PIC is connected to interrupt input pin 0 of the IO Apic, so this
    ; IO Apic interrupt pin can get 2 different interrupts.

    IoApicInti INT_TYPE_EXTINT,0,0      ; IO APIC IRQ 0, INTIN 0
    IoApicInti INT_TYPE_EXTINT,0dh,0    ; IO APIC IRQ 13, INTIN 0
    IoApicInti INT_TYPE_INTR,1,1        ; IO APIC IRQ 1, INTIN 1

    ; In this configuration, NMI comes through IO Apic interrupt
    ; input pin 2. In all other configurations, NMI comes through
    ; the Local Apic interrupt input LINTIN1

    IoApicInti INT_TYPE_NMI,2,2         ; IO APIC IRQ 2, INTIN 2

    IoApicInti INT_TYPE_INTR,3,3        ; IO APIC IRQ 3, INTIN 3
    IoApicInti INT_TYPE_INTR,4,4        ; IO APIC IRQ 4, INTIN 4
    IoApicInti INT_TYPE_INTR,5,5        ; IO APIC IRQ 5, INTIN 5
    IoApicInti INT_TYPE_INTR,6,6        ; IO APIC IRQ 6, INTIN 6
    IoApicInti INT_TYPE_INTR,7,7        ; IO APIC IRQ 7, INTIN 7
    IoApicInti INT_TYPE_INTR,8,8        ; IO APIC IRQ 8, INTIN 8
    IoApicInti INT_TYPE_INTR,9,9        ; IO APIC IRQ 9, INTIN 9
    IoApicInti INT_TYPE_INTR,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    IoApicInti INT_TYPE_INTR,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    IoApicInti INT_TYPE_INTR,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    IoApicInti INT_TYPE_INTR,0eH,0eH    ; IO APIC IRQ 14, INTIN 14
    IoApicInti INT_TYPE_INTR,0fH,0fH    ; IO APIC IRQ 15, INTIN 15

;
; PC+MP default configuration 3: EISA bus, 82489DX Apic, timer(Inti2)
;
    public _PcMpDefaultConfig3
_PcMpDefaultConfig3 label byte

    ; Create table HEADER.
    Header 14h

    ; Create processor entries
    Processor 0H, VERSION_82489DX, BSP_CPU
    Processor  01H, VERSION_82489DX, 0

    ; Create bus entries
    Bus 0, BUS_TYPE_EISA

    ; Create IO Apic entries.
    IoApic VERSION_82489DX

    ; Create IO Apic interrupt input entries.
    IoApicInti INT_TYPE_INTR,1,1        ; IO APIC IRQ 1, INTIN 1
    IoApicInti INT_TYPE_INTR,0,2        ; IO APIC IRQ 0, INTIN 2
    IoApicInti INT_TYPE_INTR,3,3        ; IO APIC IRQ 3, INTIN 3
    IoApicInti INT_TYPE_INTR,4,4        ; IO APIC IRQ 4, INTIN 4
    IoApicInti INT_TYPE_INTR,5,5        ; IO APIC IRQ 5, INTIN 5
    IoApicInti INT_TYPE_INTR,6,6        ; IO APIC IRQ 6, INTIN 6
    IoApicInti INT_TYPE_INTR,7,7        ; IO APIC IRQ 7, INTIN 7
    IoApicInti INT_TYPE_INTR,8,8        ; IO APIC IRQ 8, INTIN 8
    IoApicInti INT_TYPE_INTR,9,9        ; IO APIC IRQ 9, INTIN 9
    IoApicInti INT_TYPE_INTR,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    IoApicInti INT_TYPE_INTR,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    IoApicInti INT_TYPE_INTR,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    IoApicInti INT_TYPE_INTR,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    IoApicInti  INT_TYPE_INTR,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    IoApicInti  INT_TYPE_INTR,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,0,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1

;
; PC+MP default configuration 4: MCA bus, 82489DX Apic.
;
     public _PcMpDefaultConfig4
_PcMpDefaultConfig4 label byte

    ; Create table HEADER.
    Header 14h

    ; Create processor entries
    Processor 0H, VERSION_82489DX, BSP_CPU
    Processor  01H, VERSION_82489DX, 0

    ; Create bus entries
    Bus 0, BUS_TYPE_MCA

    ; Create IO Apic entries.
    IoApic VERSION_82489DX

    ; Create IO Apic interrupt input entries.
    IoApicInti INT_TYPE_INTR,1,1        ; IO APIC IRQ 1, INTIN 1
    IoApicInti INT_TYPE_INTR,0,2        ; IO APIC IRQ 0, INTIN 2
    IoApicInti INT_TYPE_INTR,3,3        ; IO APIC IRQ 3, INTIN 3
    IoApicInti INT_TYPE_INTR,4,4        ; IO APIC IRQ 4, INTIN 4
    IoApicInti INT_TYPE_INTR,5,5        ; IO APIC IRQ 5, INTIN 5
    IoApicInti INT_TYPE_INTR,6,6        ; IO APIC IRQ 6, INTIN 6
    IoApicInti INT_TYPE_INTR,7,7        ; IO APIC IRQ 7, INTIN 7
    IoApicInti INT_TYPE_INTR,8,8        ; IO APIC IRQ 8, INTIN 8
    IoApicInti INT_TYPE_INTR,9,9        ; IO APIC IRQ 9, INTIN 9
    IoApicInti INT_TYPE_INTR,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    IoApicInti INT_TYPE_INTR,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    IoApicInti INT_TYPE_INTR,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    IoApicInti INT_TYPE_INTR,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    IoApicInti  INT_TYPE_INTR,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    IoApicInti  INT_TYPE_INTR,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,0,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1

;
; PC+MP default configuration 5: ISA & PCI bus, Integrated Local Apic
;
    public _PcMpDefaultConfig5
_PcMpDefaultConfig5 label byte

    ; Create table HEADER.
    Header 15h

    ; Create processor entries
    Processor 0H, VERSION_INTEGRATED, BSP_CPU
    Processor  01H, VERSION_INTEGRATED, 0

    ; Create bus entries
    Bus 1, BUS_TYPE_ISA
    Bus 0, BUS_TYPE_PCI

    ; Create IO Apic entries.
    IoApic VERSION_INTEGRATED

    ; Create IO Apic interrupt input entries.
    ApicInti  INT_TYPE_INTR,1,1,1        ; IO APIC IRQ 1, INTIN 1
    ApicInti  INT_TYPE_INTR,1,0,2        ; IO APIC IRQ 0, INTIN 2
    ApicInti  INT_TYPE_INTR,1,3,3        ; IO APIC IRQ 3, INTIN 3
    ApicInti  INT_TYPE_INTR,1,4,4        ; IO APIC IRQ 4, INTIN 4
    ApicInti  INT_TYPE_INTR,1,5,5        ; IO APIC IRQ 5, INTIN 5
    ApicInti  INT_TYPE_INTR,1,6,6        ; IO APIC IRQ 6, INTIN 6
    ApicInti  INT_TYPE_INTR,1,7,7        ; IO APIC IRQ 7, INTIN 7
    ApicInti  INT_TYPE_INTR,1,8,8        ; IO APIC IRQ 8, INTIN 8
    ApicInti  INT_TYPE_INTR,1,9,9        ; IO APIC IRQ 9, INTIN 9
    ApicInti  INT_TYPE_INTR,1,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    ApicInti  INT_TYPE_INTR,1,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    ApicInti  INT_TYPE_INTR,1,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    ApicInti  INT_TYPE_INTR,1,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    ApicInti  INT_TYPE_INTR,1,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    ApicInti  INT_TYPE_INTR,1,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,1,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1

;
; PC+MP default configuration 6 EISA & PCI bus, Integrated Local Apic
;
    public _PcMpDefaultConfig6
_PcMpDefaultConfig6 label byte

    ; Create table HEADER.
    Header 15h

    ; Create processor entries
    Processor 0H, VERSION_INTEGRATED, BSP_CPU
    Processor 1H, VERSION_INTEGRATED, 0

    ; Create bus entries
    Bus 1, BUS_TYPE_EISA
    Bus 0, BUS_TYPE_PCI

    ; Create IO Apic entries.
    IoApic VERSION_INTEGRATED

    ; Create IO Apic interrupt input entries.
    ApicInti   INT_TYPE_INTR,1,1,1        ; IO APIC IRQ 1, INTIN 1
    ApicInti   INT_TYPE_INTR,1,0,2        ; IO APIC IRQ 0, INTIN 2
    ApicInti   INT_TYPE_INTR,1,3,3        ; IO APIC IRQ 3, INTIN 3
    ApicInti   INT_TYPE_INTR,1,4,4        ; IO APIC IRQ 4, INTIN 4
    ApicInti   INT_TYPE_INTR,1,5,5        ; IO APIC IRQ 5, INTIN 5
    ApicInti   INT_TYPE_INTR,1,6,6        ; IO APIC IRQ 6, INTIN 6
    ApicInti   INT_TYPE_INTR,1,7,7        ; IO APIC IRQ 7, INTIN 7
    ApicInti   INT_TYPE_INTR,1,8,8        ; IO APIC IRQ 8, INTIN 8
    ApicInti   INT_TYPE_INTR,1,9,9        ; IO APIC IRQ 9, INTIN 9
    ApicInti   INT_TYPE_INTR,1,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    ApicInti   INT_TYPE_INTR,1,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    ApicInti   INT_TYPE_INTR,1,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    ApicInti   INT_TYPE_INTR,1,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    ApicInti   INT_TYPE_INTR,1,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    ApicInti   INT_TYPE_INTR,1,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,1,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1


;
; PC+MP default configuration 7: MCA & PCI bus, Integrated Local Apic
;
    public _PcMpDefaultConfig7
_PcMpDefaultConfig7 label byte

    ; Create table HEADER.
    Header 15h

    ; Create processor entries
    Processor 0H, VERSION_INTEGRATED, BSP_CPU
    Processor  01H, VERSION_INTEGRATED, 0

    ; Create bus entries
    Bus 1, BUS_TYPE_MCA
    Bus 0, BUS_TYPE_PCI

    ; Create IO Apic entries.
    IoApic VERSION_INTEGRATED

    ; Create IO Apic interrupt input entries.
    ApicInti  INT_TYPE_INTR,1,1,1        ; IO APIC IRQ 1, INTIN 1
    ApicInti  INT_TYPE_INTR,1,0,2        ; IO APIC IRQ 0, INTIN 2
    ApicInti  INT_TYPE_INTR,1,3,3        ; IO APIC IRQ 3, INTIN 3
    ApicInti  INT_TYPE_INTR,1,4,4        ; IO APIC IRQ 4, INTIN 4
    ApicInti  INT_TYPE_INTR,1,5,5        ; IO APIC IRQ 5, INTIN 5
    ApicInti  INT_TYPE_INTR,1,6,6        ; IO APIC IRQ 6, INTIN 6
    ApicInti  INT_TYPE_INTR,1,7,7        ; IO APIC IRQ 7, INTIN 7
    ApicInti  INT_TYPE_INTR,1,8,8        ; IO APIC IRQ 8, INTIN 8
    ApicInti  INT_TYPE_INTR,1,9,9        ; IO APIC IRQ 9, INTIN 9
    ApicInti  INT_TYPE_INTR,1,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    ApicInti  INT_TYPE_INTR,1,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    ApicInti  INT_TYPE_INTR,1,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    ApicInti  INT_TYPE_INTR,1,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    ApicInti  INT_TYPE_INTR,1,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    ApicInti  INT_TYPE_INTR,1,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,1,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1


    ;
    ; Pointers to the default configuration tables
    ;
    public _PcMpDefaultTablePtrs

    ; Array of pointers to the default configurations.
_PcMpDefaultTablePtrs label byte
    dd  offset _PcMpDefaultConfig1      ; Pointer to Default Config 1
    dd  offset _PcMpDefaultConfig2      ; Pointer to Default Config 2
    dd  offset _PcMpDefaultConfig3      ; Pointer to Default Config 3
    dd  offset _PcMpDefaultConfig4      ; Pointer to Default Config 4
    dd  offset _PcMpDefaultConfig5      ; Pointer to Default Config 5
    dd  offset _PcMpDefaultConfig6      ; Pointer to Default Config 6
    dd  offset _PcMpDefaultConfig7      ; Pointer to Default Config 7

PAGELK ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpdebug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpdebug.c

Abstract:

    This module has some useful modules for debug aid.

Author:

    Ron Mosgrove (Intel) - Aug 1993.

Environment:

    Kernel mode or from textmode setup.

Revision History:

--*/

#ifndef _NTOS_
#include "halp.h"
#endif

#include "apic.inc"
#include "pcmp_nt.inc"
#include "stdio.h"

#define PCMP_TABLE_PTR_BASE           0x09f000
#define PCMP_TABLE_PTR_OFFSET         0x00000c00

// Create dummy PC+MP table at physical address 400K
#define  PCMP_TEST_TABLE        0x64000
#define TEST_FLOAT_PTR          0x7d000

extern struct PcMpTable *PcMpTablePtr, *PcMpDefaultTablePtrs[];
//extern struct HalpMpInfo *HalpMpInfoPtr;

CHAR Cbuf[120];

UCHAR
ComputeCheckSum(
    IN PUCHAR SourcePtr,
    IN USHORT NumOfBytes
    );

#ifdef OLD_DEBUG
extern struct PcMpConfigTable *PcMpTablePtr;
#endif

#ifdef DEBUGGING

ULONG HalpUseDbgPrint = 0;

void
HalpDisplayString(
    IN PVOID String
    )
{
    if (!HalpUseDbgPrint) {
        HalDisplayString(String);
    } else {
        DbgPrint(String);
    }
}


void
HalpDisplayItemBuf(
    IN UCHAR Length,
    IN PUCHAR Buffer,
    IN PVOID Name
    )
{
    ULONG i;
    CHAR TmpBuf[80];
    
    sprintf(TmpBuf, "    %s -", Name);
    HalpDisplayString(TmpBuf);
    for (i=0; i< Length; i++) {
        sprintf(TmpBuf, " 0x%x", Buffer[i]);
        HalpDisplayString(TmpBuf);
    }
    HalpDisplayString("\n");
}    

void
HalpDisplayULItemBuf(
    IN UCHAR Length,
    IN PULONG Buffer,
    IN PVOID Name
    )
{
    ULONG i;
    CHAR TmpBuf[80];
    
    sprintf(TmpBuf, "    %s -", Name);
    HalpDisplayString(TmpBuf);
    for (i=0; i< Length; i++) {
        sprintf(TmpBuf, " 0x%lx", Buffer[i]);
        HalpDisplayString(TmpBuf);
    }
    HalpDisplayString("\n");
}    

void
HalpDisplayItem(
    IN ULONG Item,
    IN PVOID ItemStr
    )
{
    CHAR TmpBuf[80];

    sprintf(TmpBuf, "    %s - 0x%x\n", ItemStr, Item);
    HalpDisplayString(TmpBuf);
}

VOID
HalpDisplayBIOSSysCfg(
    IN struct SystemConfigTable *SysCfgPtr
    )
{
    HalpDisplayString("BIOS System Configuration Table\n");
    HalpDisplayItem(SysCfgPtr->ModelType, "ModelType");
    HalpDisplayItem(SysCfgPtr->SubModelType, "SubModelType");
    HalpDisplayItem(SysCfgPtr->BIOSRevision, "BIOSRevision");
    HalpDisplayItemBuf(3,SysCfgPtr->FeatureInfoByte,"FeatureInfoByte");
    HalpDisplayItem(SysCfgPtr->MpFeatureInfoByte1, "MpFeatureInfoByte1");
    HalpDisplayItem(SysCfgPtr->MpFeatureInfoByte2, "MpFeatureInfoByte2");
}

VOID
HalpDisplayLocalUnit(
    )
{
    ULONG Data;
    PKPCR   pPCR;

    pPCR = KeGetPcr();

    sprintf(Cbuf, "\nLocal Apic for P%d\n", pPCR->Prcb->Number);
    HalpDisplayString(Cbuf);

#define DisplayLuReg(Reg, RegStr)   Data = *((PVULONG) (LOCALAPIC+Reg)); \
                                    HalpDisplayItem(Data , RegStr);


    DisplayLuReg( LU_ID_REGISTER  , "LU_ID_REGISTER"  );
    DisplayLuReg( LU_VERS_REGISTER, "LU_VERS_REGISTER" );
    DisplayLuReg( LU_TPR, "LU_TPR");
    DisplayLuReg( LU_APR, "LU_APR");
    DisplayLuReg( LU_PPR, "LU_PPR");
    DisplayLuReg( LU_EOI, "LU_EOI");
    DisplayLuReg( LU_REMOTE_REGISTER, "LU_REMOTE_REGISTER");
    DisplayLuReg( LU_LOGICAL_DEST, "LU_LOGICAL_DEST");

    DisplayLuReg( LU_DEST_FORMAT, "LU_DEST_FORMAT");

    DisplayLuReg( LU_SPURIOUS_VECTOR , "LU_SPURIOUS_VECTOR" );

    DisplayLuReg( LU_ISR_0, "LU_ISR_0");
    DisplayLuReg( LU_TMR_0, "LU_TMR_0");
    DisplayLuReg( LU_IRR_0, "LU_IRR_0");
    DisplayLuReg( LU_ERROR_STATUS, "LU_ERROR_STATUS");
    DisplayLuReg( LU_INT_CMD_LOW, "LU_INT_CMD_LOW");
    DisplayLuReg( LU_INT_CMD_HIGH, "LU_INT_CMD_HIGH");
    DisplayLuReg( LU_TIMER_VECTOR, "LU_TIMER_VECTOR");
    DisplayLuReg( LU_INT_VECTOR_0, "LU_INT_VECTOR_0");
    DisplayLuReg( LU_INT_VECTOR_1, "LU_INT_VECTOR_1");
    DisplayLuReg( LU_INITIAL_COUNT, "LU_INITIAL_COUNT");
    DisplayLuReg( LU_CURRENT_COUNT, "LU_CURRENT_COUNT");

    DisplayLuReg( LU_DIVIDER_CONFIG, "LU_DIVIDER_CONFIG");
    HalpDisplayString("\n");
    
}

VOID
HalpDisplayIoUnit(
    )
/*++

Routine Description:

    Verify that an IO Unit exists at the specified address

 Arguments:

    BaseAddress - Address of the IO Unit to test.

 Return Value:
    BOOLEAN - TRUE if a IO Unit was found at the passed address
            - FALSE otherwise

--*/

{
#if 0
    struct ApicIoUnit *IoUnitPtr;
    ULONG Data,i,j;
    PKPCR   pPCR;

    pPCR = KeGetPcr();

    //
    //  The documented detection mechanism is to write all zeros to
    //  the Version register.  Then read it back.  The IO Unit exists if the
    //  same result is read both times and the Version is valid.
    //



    for (j=0; j<HalpMpInfoPtr->IOApicCount; j++) { 
        IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoPtr->IoApicBase[j];

        sprintf(Cbuf,"\nIoApic %d at Vaddr 0x%x\n",j,(ULONG) IoUnitPtr);
        HalpDisplayString(Cbuf);

        IoUnitPtr->RegisterSelect = IO_ID_REGISTER;
        HalpDisplayItem(IoUnitPtr->RegisterWindow, "IO_ID_REGISTER");


        IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
        HalpDisplayItem(IoUnitPtr->RegisterWindow, "IO_VERS_REGISTER");

        for (i=0; i<16; i++) {

            IoUnitPtr->RegisterSelect = IO_REDIR_00_LOW+(i*2);
            Data = IoUnitPtr->RegisterWindow;
            sprintf(Cbuf, "    Redir [0x%x] - 0x%x, ", i, Data);
            HalpDisplayString(Cbuf);

            IoUnitPtr->RegisterSelect = IO_REDIR_00_LOW+(i*2)+1;
            Data = IoUnitPtr->RegisterWindow;
            sprintf(Cbuf, "0x%x\n", Data);
            HalpDisplayString(Cbuf);

        }  // for each Redirection entry
    } // for all Io Apics

#endif
}

void
HalpDisplayConfigTable ()
/*+++
    Debug routine  to display the PC+MP config table
--*/
{
    struct PcMpTable *MpPtr = PcMpTablePtr;
    PPCMPPROCESSOR ProcPtr;
    ULONG EntriesInTable = MpPtr->NumOfEntries;
    union PL {
        USHORT us;
        POLARITYANDLEVEL PnL;
        };

    HalpDisplayString("PcMp Configuration Table\n");

    HalpDisplayItem(MpPtr->Signature, "Signature");
    HalpDisplayItem(MpPtr->TableLength, "TableLength");
    HalpDisplayItem(MpPtr->Revision, "Revision");
    HalpDisplayItem(MpPtr->Checksum, "Checksum");

    HalpDisplayItemBuf(sizeof(MpPtr->OemId),
            MpPtr->OemId,"OemId");
    HalpDisplayItemBuf(sizeof(MpPtr->OemProductId),
            MpPtr->OemProductId,"OemProductId");
    
    HalpDisplayItem((ULONG) MpPtr->OemTablePtr, "OemTablePtr");
    HalpDisplayItem(MpPtr->OemTableSize, "OemTableSize");
    HalpDisplayItem(MpPtr->NumOfEntries, "NumOfEntries");
    HalpDisplayItem((ULONG) MpPtr->LocalApicAddress, "LocalApicAddress");
    HalpDisplayItem(MpPtr->Reserved, "Reserved");

    ProcPtr = (PPCMPPROCESSOR) ((PUCHAR) MpPtr + HEADER_SIZE);


    while (EntriesInTable) {
        EntriesInTable--;
        switch ( ProcPtr->EntryType ) {
            case ENTRY_PROCESSOR: {
                union xxx {
                    ULONG ul;
                    CPUIDENTIFIER CpuId;
                } u;
                
                sprintf (Cbuf, "Proc..: ApicId %x, Apic ver %x, Flags %x\n",
                    ProcPtr->LocalApicId,
                    ProcPtr->LocalApicVersion,
                    ProcPtr->CpuFlags
                    );
                HalpDisplayString (Cbuf);
                ProcPtr++;
                break;
            }

            case ENTRY_BUS: {
                PPCMPBUS BusPtr = (PPCMPBUS) ProcPtr;

                sprintf (Cbuf, "Bus...: id %02x, type '%.6s'\n",
                            BusPtr->BusId, BusPtr->BusType);

                HalpDisplayString (Cbuf);
                BusPtr++;
                ProcPtr = (PPCMPPROCESSOR) BusPtr;
                break;
            }

            case ENTRY_IOAPIC: {
                PPCMPIOAPIC IoApPtr = (PPCMPIOAPIC) ProcPtr;

                sprintf (Cbuf, "IoApic: id %02x, ver %x, Flags %x, Address %x\n",
                    IoApPtr->IoApicId,
                    IoApPtr->IoApicVersion,
                    IoApPtr->IoApicFlag,
                    (ULONG) IoApPtr->IoApicAddress
                    );
                HalpDisplayString (Cbuf);

                IoApPtr++;
                ProcPtr = (PPCMPPROCESSOR) IoApPtr;
                break;
            }

            case ENTRY_INTI: {
                PPCMPINTI IntiPtr = (PPCMPINTI) ProcPtr;
                union PL u;

                u.PnL = IntiPtr->Signal;

                sprintf (Cbuf, "Inti..: t%x, s%x, SInt %x-%x, Inti %x-%x\n",
                    IntiPtr->IntType,
                    u.us,
                    IntiPtr->SourceBusId,
                    IntiPtr->SourceBusIrq,
                    IntiPtr->IoApicId,
                    IntiPtr->IoApicInti
                );
                HalpDisplayString (Cbuf);

                IntiPtr++;
                ProcPtr = (PPCMPPROCESSOR) IntiPtr;
                break;
            }

            case ENTRY_LINTI: {
                PPCMPLINTI LIntiPtr = (PPCMPLINTI) ProcPtr;
                union PL u;

                u.PnL = LIntiPtr->Signal;

                sprintf (Cbuf, "Linti.: t%x, s%x, SInt %x-%x, Linti %x-%x\n",
                    LIntiPtr->IntType,
                    u.us,
                    LIntiPtr->SourceBusId,
                    LIntiPtr->SourceBusIrq,
                    LIntiPtr->DestLocalApicId,
                    LIntiPtr->DestLocalApicInti
                );
                HalpDisplayString (Cbuf);

                LIntiPtr++;
                ProcPtr = (PPCMPPROCESSOR) LIntiPtr;
                break;
            }
        
            default: {
                HalpDisplayItem(ProcPtr->EntryType, "Unknown Type");
                return;
            }
        }
    }
}

void
HalpDisplayExtConfigTable ()
{
    PMPS_EXTENTRY  ExtTable;
    extern struct HalpMpInfo HalpMpInfoTable;


    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {
        switch (ExtTable->Type) {

            case EXTTYPE_BUS_ADDRESS_MAP:
                sprintf (Cbuf, "BusMap: id %02x, t%x  Base %08x  Len %08x\n",
                    ExtTable->u.AddressMap.BusId,
                    ExtTable->u.AddressMap.Type,
                    (ULONG) ExtTable->u.AddressMap.Base,
                    (ULONG) ExtTable->u.AddressMap.Length
                );
                HalpDisplayString (Cbuf);
                break;

            case EXTTYPE_BUS_HIERARCHY:
                sprintf (Cbuf, "BusHie: id %02x, Parent:%x  sd:%x\n",
                    ExtTable->u.BusHierarchy.BusId,
                    ExtTable->u.BusHierarchy.ParentBusId,
                    ExtTable->u.BusHierarchy.SubtractiveDecode
                );
                HalpDisplayString (Cbuf);
                break;

            case EXTTYPE_BUS_COMPATIBLE_MAP:
                sprintf (Cbuf, "ComBus: id %02x %c List %x\n",
                    ExtTable->u.CompatibleMap.BusId,
                    ExtTable->u.CompatibleMap.Modifier ? '-' : '+',
                    ExtTable->u.CompatibleMap.List
                    );
                HalpDisplayString (Cbuf);
                break;

            case EXTTYPE_PERSISTENT_STORE:
                sprintf (Cbuf, "PreSTR: Address %08x Len %08x\n",
                    (ULONG) ExtTable->u.PersistentStore.Address,
                    (ULONG) ExtTable->u.PersistentStore.Length
                );
                HalpDisplayString (Cbuf);
                break;

            default:
                HalpDisplayItem(ExtTable->Type, "Unknown Type");
                break;
        }


        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }
    
}


void
HalpDisplayMpInfo()
{
#if 0
    struct HalpMpInfo *MpPtr = HalpMpInfoPtr;

    HalpDisplayString("\nHAL: Private Mp Info\n");

    HalpDisplayItem(MpPtr->ApicVersion, "ApicVersion");
    HalpDisplayItem(MpPtr->ProcessorCount, "ProcessorCount");
    HalpDisplayItem(MpPtr->BusCount, "BusCount");
    HalpDisplayItem(MpPtr->IOApicCount, "IOApicCount");
    HalpDisplayItem(MpPtr->IntiCount, "IntiCount");
    HalpDisplayItem(MpPtr->LintiCount, "LintiCount");
    HalpDisplayItem(MpPtr->IMCRPresent, "IMCRPresent");

    HalpDisplayULItemBuf(4,(PULONG) MpPtr->IoApicBase,"IoApicBase");
    HalpDisplayString("\n");
    HalpDisplayConfigTable();

#endif
}


#ifdef OLD_DEBUG

BOOLEAN
HalpVerifyLocalUnit(
    IN UCHAR ApicID
    )
/*++

Routine Description:

    Verify that a Local Apic has the specified Apic Id.

 Arguments:

    ApicId - Id to verify.

 Return Value:
    BOOLEAN - TRUE if found
            - FALSE otherwise

--*/

{
    union ApicUnion Temp;

    //
    //  The remote read command must be:
    //
    //      Vector - Bits 4-9 of the Version register
    //      Destination Mode - Physical
    //      Trigger Mode - Edge
    //      Delivery Mode - Remote Read
    //      Destination Shorthand - Destination Field
    //

#define LU_READ_REMOTE_VERSION   ( (LU_VERS_REGISTER >> 4) | \
                                    DELIVER_REMOTE_READ | \
                                    ICR_USE_DEST_FIELD)

#define DEFAULT_DELAY   100

    PVULONG LuDestAddress = (PVULONG) (LOCALAPIC + LU_INT_CMD_HIGH);
    PVULONG LuICR = (PVULONG) (LOCALAPIC + LU_INT_CMD_LOW);
    PVULONG LuRemoteReg = (PVULONG) (LOCALAPIC + LU_REMOTE_REGISTER);
    ULONG RemoteReadStatus;
    ULONG DelayCount = DEFAULT_DELAY;

    //
    //  First make sure we can get to the Apic Bus
    //

    while ( ( DelayCount-- ) && ( *LuICR & DELIVERY_PENDING ) );

    if (DelayCount == 0) {
        //
        //  We're toast, can't gain access to the APIC Bus
        //
        return (FALSE);
    }

    //
    //  Set the Address of the APIC we're looking for
    //

    *LuDestAddress = (ApicID << DESTINATION_SHIFT);

    //
    //  Issue the request
    //

    *LuICR = LU_READ_REMOTE_VERSION;

    //
    //  Reset the Delay so we can get out of here just in case...
    //

    DelayCount = DEFAULT_DELAY;

    while (DelayCount--) {

        RemoteReadStatus = *LuICR & ICR_RR_STATUS_MASK;

        if ( RemoteReadStatus == ICR_RR_INVALID) {
            //
            //  No One responded, device timed out
            //
            return (FALSE);
        }

        if ( RemoteReadStatus == ICR_RR_VALID) {
            //
            //  Someone is there and the Remote Register is valid
            //
            Temp.Raw = *LuRemoteReg;

            //
            // Do what we can to verify the Version
            //

            if (Temp.Ver.Version > 0x1f) {
                //
                //  Only known devices are 0.x and 1.x
                //
                return (FALSE);
            }

            return (TRUE);

        }   // RemoteRead Successfull

    }   // While DelayCount

    //
    //  No One responded, and the device did not time out
    //  This should never happen
    //

    return (FALSE);
}

#endif  // OLD_DEBUG

VOID
CreateBIOSTables(
    VOID)
/*++

Routine Description:
    This routine is used  to test the PC+MP detect code in the HAL.
    It creates the PC+MP structures that are really created by the
    BIOS. Since we presently do not have a BIOS that builds a PC+MP
    table, we need this for now.

Arguments:
    None.

 Return Value:
    None.

--*/

{
    PUCHAR TempPtr, BytePtr;
    UCHAR CheckSum;
    PULONG TraversePtr;
    USHORT BytesToCopy;

    HalpDisplayString("CreateBIOSTables : Entered\n");
    // First, copy default PC+MP configuration 2 table at physical
    // address PCMP_TEST_TABLE
    TempPtr = (PUCHAR) HalpMapPhysicalMemory(
                (PVOID) PCMP_TEST_TABLE, 1);

    BytesToCopy = (PcMpDefaultTablePtrs[1])->TableLength;
    RtlMoveMemory(TempPtr, (PUCHAR)PcMpDefaultTablePtrs[1],
        BytesToCopy);

    // Populate the checksum entry for the table.
    CheckSum = ComputeCheckSum(TempPtr, BytesToCopy);

    sprintf(Cbuf, "CreateBIOSTables: PC+MP table computed checksum = %x\n",
        CheckSum);
    HalpDisplayString(Cbuf);

    CheckSum = ~CheckSum + 1;
    ((struct PcMpTable *)TempPtr)->Checksum = CheckSum;

    sprintf(Cbuf, "CreateBIOSTables: PC+MP table written checksum = %x\n",
        CheckSum);
    HalpDisplayString(Cbuf);


    // Now create the floating pointer structure for the table.

    TraversePtr = (PULONG) HalpMapPhysicalMemory( (PVOID) TEST_FLOAT_PTR, 1);
    TempPtr = (PUCHAR) TraversePtr;

    *TraversePtr++ = MP_PTR_SIGNATURE;
    *TraversePtr++ = PCMP_TEST_TABLE;
    BytePtr = (PUCHAR)TraversePtr;
    *BytePtr++ = 1;  // Length in number of  16 byte paragraphs
    *BytePtr++ = 1;  // Spec Rev.
    *BytePtr++ = 0;  // CheckSum
    *BytePtr++ = 0;  // Reserved
    TraversePtr = (PULONG)BytePtr;
    *TraversePtr = 0; // Reserved

    CheckSum = ComputeCheckSum(TempPtr,16);

    sprintf(Cbuf, "CreateBIOSTables: FLOAT_PTR computed checksum = %x\n",
        CheckSum);
    HalpDisplayString(Cbuf);

    CheckSum = ~CheckSum + 1;

    sprintf(Cbuf, "CreateBIOSTables: FLOAT_PTR written checksum = %x\n",
        CheckSum);
    HalpDisplayString(Cbuf);

    ((struct PcMpTableLocator *)TempPtr)->TableChecksum = CheckSum;

    HalpDisplayString("CreateBIOSTables : Done\n");

}

#endif  // DEBUGGING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mphal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mphal.c

Abstract:


    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for a
    PC+MP system.

Author:

    David N. Cutler (davec) 25-Apr-1991

Environment:

    Kernel mode only.

Revision History:

    Ron Mosgrove (Intel) - Modified to support the PC+MP Spec
    Jake Oshins (jakeo)  - Modified to support the ACPI Spec

*/

#include "halp.h"
#include "pcmp_nt.inc"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"

ULONG HalpBusType;

extern ADDRESS_USAGE HalpDefaultPcIoSpace;
extern ADDRESS_USAGE HalpEisaIoSpace;
extern ADDRESS_USAGE HalpImcrIoSpace;
extern struct HalpMpInfo HalpMpInfoTable;
extern UCHAR rgzRTCNotFound[];
extern USHORT HalpVectorToINTI[];
extern UCHAR HalpAuthenticAMD[];
extern UCHAR HalpGenuineIntel[];
extern const UCHAR HalName[];
extern BOOLEAN HalpDoingCrashDump;

extern PULONG KiEnableTimerWatchdog;
extern ULONG HalpTimerWatchdogEnabled;
extern PCHAR HalpTimerWatchdogStorage;
extern PVOID HalpTimerWatchdogCurFrame;
extern PVOID HalpTimerWatchdogLastFrame;
extern ULONG HalpTimerWatchdogStorageOverflow;

extern KSPIN_LOCK HalpDmaAdapterListLock;
extern LIST_ENTRY HalpDmaAdapterList;
extern ULONGLONG  HalpProc0TSCHz;

#ifdef ACPI_HAL
extern ULONG HalpPicVectorRedirect[];
#define ADJUSTED_VECTOR(x)  \
            HalpPicVectorRedirect[x]
#else
#define ADJUSTED_VECTOR(x) x
#endif

#if defined(_AMD64_)

VOID
HalpInitializeBios(VOID);

#endif

VOID
HalpInitMP(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );


KSPIN_LOCK HalpSystemHardwareLock;

VOID
HalpInitBusHandlers (
    VOID
    );

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpClockInterruptPn);
HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpClockInterruptStub);

BOOLEAN
HalpmmTimer(
    VOID
    );

VOID
HalpmmTimerClockInit(
    VOID
    );

VOID
HalpmmTimerClockInterruptStub(
    VOID
    );

ULONG
HalpScaleTimers(
    VOID
    );

BOOLEAN
HalpPmTimerScaleTimers(
    VOID
    );

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpApicRebootService);
HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpBroadcastCallService);
HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpDispatchInterrupt);
HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpApcInterrupt);
HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpIpiHandler);

VOID
HalpInitializeIOUnits (
    VOID
    );

VOID
HalpInitIntiInfo (
    VOID
    );

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitializeTimerResolution (
    ULONG Rate
    );

ULONG
HalpGetFeatureBits (
    VOID
    );

VOID
HalpInitializeApicAddressing(
    UCHAR Number
    );

VOID
HalpInitReservedPages(
    VOID
    );

VOID
HalpAcpiTimerPerfCountHack(
    VOID
    );

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

#ifdef DEBUGGING
extern void HalpDisplayLocalUnit(void);
extern void HalpDisplayConfigTable(void);
extern void HalpDisplayExtConfigTable(void);
#endif // DEBUGGING

BOOLEAN         HalpStaticIntAffinity = FALSE;

BOOLEAN         HalpClockMode = Latched;

UCHAR           HalpMaxProcsPerCluster = 0;

extern BOOLEAN  HalpUse8254;
extern UCHAR    HalpSzInterruptAffinity[];
extern BOOLEAN  HalpPciLockSettings;
extern UCHAR    HalpVectorToIRQL[];
extern ULONG    HalpDontStartProcessors;
extern UCHAR    HalpSzOneCpu[];
extern UCHAR    HalpSzNoIoApic[];
extern UCHAR    HalpSzBreak[];
extern UCHAR    HalpSzPciLock[];
extern UCHAR    HalpSzTimerRes[];
extern UCHAR    HalpSzClockLevel[];
extern UCHAR    HalpSzUse8254[];
extern UCHAR    HalpSzForceClusterMode[];

ULONG UserSpecifiedCpuCount = 0;
KSPIN_LOCK  HalpAccountingLock;

#ifdef ACPI_HAL
extern KEVENT   HalpNewAdapter;
#endif

#ifdef ALLOC_PRAGMA
VOID
HalpInitTimerWatchdog(
    IN ULONG Phase
    );
#pragma alloc_text(INIT,HalpGetParameters)
#pragma alloc_text(INIT,HalpInitTimerWatchdog)
#pragma alloc_text(INIT,HalInitSystem)
#endif // ALLOC_PRAGMA

KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynchMCE(
    IN PKSPIN_LOCK SpinLock
    );

//
// Define bug check callback record.
//

KBUGCHECK_CALLBACK_RECORD HalpCallbackRecord;


VOID
HalpBugCheckCallback (
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This function is called when a bug check occurs. Its function is
    to perform anything the HAL needs done as the system bugchecks.

Arguments: (Unused in this callback).

    Buffer - Supplies a pointer to the bug check buffer.
    Length - Supplies the length of the bug check buffer in bytes.

Return Value:

    None.

--*/

{

    //
    // Make sure the HAL won't spin waiting on other processors
    // during a crashdump.
    //

    HalpDoingCrashDump = TRUE;
}

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This gets any parameters from the boot.ini invocation line.

Arguments:

    None.

Return Value:

    None

--*/
{
    PCHAR       Options;
    PCHAR       p;

    if (LoaderBlock != NULL  &&  LoaderBlock->LoadOptions != NULL) {

        Options = LoaderBlock->LoadOptions;

        //
        //  Has the user set the debug flag?
        //
        //
        //  Has the user requested a particular number of CPU's?
        //

        if (strstr(Options, HalpSzOneCpu)) {
            HalpDontStartProcessors++;
        }

        //
        // Check if PCI settings are locked down
        //

        if (strstr(Options, HalpSzPciLock)) {
            HalpPciLockSettings = TRUE;
        }

#ifndef ACPI_HAL
        //
        // Check if CLKLVL setting
        //

        if (strstr(Options, HalpSzClockLevel)) {
            HalpClockMode = LevelSensitive;
        }

        //
        // Check if 8254 is to be used as high resolution counter
        //

        if (strstr(Options, HalpSzUse8254)) {
            HalpUse8254 = TRUE;
        }
#endif

        //
        // Check if user wants device ints to go to highest numbered processor
        //

        if (strstr(Options, HalpSzInterruptAffinity)) {
            HalpStaticIntAffinity = TRUE;
        }

#ifndef ACPI_HAL
        //
        // Check for TIMERES setting
        //

        p = strstr(Options, HalpSzTimerRes);
        if (p) {
            // skip to value
            while (*p  &&  *p != ' ' &&  (*p < '0'  || *p > '9')) {
                p++;
            }

            HalpInitializeTimerResolution (atoi(p));
        }
#endif

        //
        //  Has the user asked for an initial BreakPoint?
        //

        if (strstr(Options, HalpSzBreak)) {
            DbgBreakPoint();
        }

        //
        // Does the user want to force Cluster mode APIC addressing?
        //
        p = strstr(Options, HalpSzForceClusterMode);
        if (p) {
            // skip to value
            while (*p  &&  *p != ' ' &&  (*p < '0'  || *p > '9')) {
                p++;
            }
            HalpMaxProcsPerCluster = (UCHAR)atoi(p);
            //
            // Current processors support maximum 4 processors per cluster.
            //
            if(HalpMaxProcsPerCluster > 4)   {
                HalpMaxProcsPerCluster = 4;
            }

            if (HalpMpInfoTable.ApicVersion == APIC_82489DX)   {
                //
                // Ignore user's attempt to force cluster mode if running
                // on 82489DX external APIC interrupt controller.
                //
                HalpMaxProcsPerCluster = 0;
            }
            //
            // Hack to reprogram the boot processor to use Cluster mode APIC
            // addressing if the user supplied a boot.ini switch
            // (/MAXPROCSPERCLUSTER=n) to force this. The boot.ini switch is
            // parsed after the boot processor's APIC is programmed originally
            // but before other non-boot processors were woken up.
            //
            HalpInitializeApicAddressing(0);
        }
    }

    return ;
}


VOID
HalpInitTimerWatchdog(
    IN ULONG Phase
    )
/*++

Routine Description:

    Determines if the system is running on a GenuineIntel part and initializes
    HalpTimerWatchdogEnabled accordingly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (Phase == 0) {
        ULONG   GenuinePentiumOrLater = FALSE, Junk;
        PKPRCB  Prcb;

        Prcb = KeGetCurrentPrcb();

        if (Prcb->CpuID) {
            UCHAR Buffer[50];

            //
            // Determine the processor type
            //

            HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
            Buffer[12] = 0;

            GenuinePentiumOrLater =
                ((strcmp(Buffer, HalpGenuineIntel) == 0) && (Prcb->CpuType >= 5));
            HalpTimerWatchdogEnabled = *KiEnableTimerWatchdog && GenuinePentiumOrLater;
        }
    } else if (HalpTimerWatchdogEnabled) {
        //
        // Allocate 2 pages for stack snapshots, each snapshot is 64 DWORDs.
        //
        if (HalpTimerWatchdogStorage =
                ExAllocatePoolWithTag( NonPagedPool, PAGE_SIZE * 2, HAL_POOL_TAG )) {
            HalpTimerWatchdogLastFrame =
                HalpTimerWatchdogStorage + (PAGE_SIZE * 2 - 64*4);
            HalpTimerWatchdogStorageOverflow = 0;
            HalpTimerWatchdogCurFrame = HalpTimerWatchdogStorage;
        } else {
            HalpTimerWatchdogEnabled = FALSE;
        }
    }
}

#ifdef TIMER_DBG
BOOLEAN HalInitialized = FALSE;
#endif


BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    A value of TRUE is returned is the initialization was successfully
    complete. Otherwise a value of FALSE is returend.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PLIST_ENTRY NextMd;
    PKPRCB      pPRCB;
    PKPCR       pPCR;
    BOOLEAN     Found;
    USHORT      RTCInti;
    USHORT      mmTInti;
    ULONG mapBufferSize;
    ULONG mapBufferAddress;

#ifdef DEBUGGING
extern ULONG HalpUseDbgPrint;
#endif // DEBUGGING

    pPRCB = KeGetCurrentPrcb();

    if (Phase == 0) {


        HalpBusType = LoaderBlock->u.I386.MachineType & 0x00ff;
        HalpGetParameters (LoaderBlock);

        //
        // Verify Prcb version and build flags conform to
        // this image
        //

#if !defined(_AMD64_)
#if DBG
        if (!(pPRCB->BuildType & PRCB_BUILD_DEBUG)) {
            // This checked hal requires a checked kernel
            KeBugCheckEx (MISMATCHED_HAL,
                2, pPRCB->BuildType, PRCB_BUILD_DEBUG, 0);
        }
#else
        if (pPRCB->BuildType & PRCB_BUILD_DEBUG) {
            // This free hal requires a free kernel
            KeBugCheckEx (MISMATCHED_HAL, 2, pPRCB->BuildType, 0, 0);
        }
#endif
#ifndef NT_UP
        if (pPRCB->BuildType & PRCB_BUILD_UNIPROCESSOR) {
            // This MP hal requires an MP kernel
            KeBugCheckEx (MISMATCHED_HAL, 2, pPRCB->BuildType, 0, 0);
        }
#endif
#endif  // _AMD64_
        if (pPRCB->MajorVersion != PRCB_MAJOR_VERSION) {
            KeBugCheckEx (MISMATCHED_HAL,
                1, pPRCB->MajorVersion, PRCB_MAJOR_VERSION, 0);
        }

        KeInitializeSpinLock(&HalpAccountingLock);

#ifdef ACPI_HAL
        //
        // Make sure that this is really an ACPI machine and initialize
        // the ACPI structures.
        //
        HalpSetupAcpiPhase0(LoaderBlock);
#endif

        //
        // Fill in handlers for APIs which this hal supports
        //

#ifndef NT_35
        HalQuerySystemInformation = HaliQuerySystemInformation;
        HalSetSystemInformation = HalpSetSystemInformation;
#endif
        //
        // check to see whether the kernel supports these calls
        //

        if (HALDISPATCH->Version >= HAL_DISPATCH_VERSION) {
            HalInitPnpDriver = HaliInitPnpDriver;
            HalGetDmaAdapter = HaliGetDmaAdapter;
            HalLocateHiberRanges = HaliLocateHiberRanges;
            HalResetDisplay = HalpBiosDisplayReset;
            HalAllocateMapRegisters = HalpAllocateMapRegisters;
            
#ifdef ACPI_HAL
            HalInitPowerManagement = HaliInitPowerManagement;
            HalGetInterruptTranslator = HalacpiGetInterruptTranslator;
            HalHaltSystem = HaliHaltSystem;
#else
            HalGetInterruptTranslator = HaliGetInterruptTranslator;
#endif
        }

        //
        // Phase 0 initialization only called by P0
        //

#ifdef DEBUGGING
        HalpUseDbgPrint++;
        HalpDisplayLocalUnit();
#ifndef ACPI_HAL
        HalpDisplayConfigTable();
        HalpDisplayExtConfigTable();
#endif
#endif // DEBUGGING

        //
        // Keep track of which IRQs are level triggered.
        //
#if !defined(MCA) && !defined(ACPI_HAL)
        if (HalpBusType == MACHINE_TYPE_EISA) {
            HalpRecordEisaInterruptVectors();
        }
#endif
        //
        // Register PC style IO space used by hal
        //

        HalpRegisterAddressUsage (&HalpDefaultPcIoSpace);
        if (HalpBusType == MACHINE_TYPE_EISA) {
            HalpRegisterAddressUsage (&HalpEisaIoSpace);
        }

        if (HalpMpInfoTable.IMCRPresent) {
            HalpRegisterAddressUsage (&HalpImcrIoSpace);
        }

        //
        // initialize the APIC IO unit, this could be a NOP if none exist
        //
             
        HalpInitIntiInfo ();

        HalpInitializeIOUnits();

        HalpInitializePICs(TRUE);

        //
        // Initialize CMOS
        //

        HalpInitializeCmos();

        //
        // Find the RTC interrupt.
        //

        Found = HalpGetApicInterruptDesc (
                    DEFAULT_PC_BUS,
                    0,
                    ADJUSTED_VECTOR(RTC_IRQ),
                    &RTCInti
                    );

        if (!Found) {
            HalDisplayString (rgzRTCNotFound);
            return FALSE;
        }

        //
        // Initialize timers
        //

        //
        // We can cut down the boot time using the PM timer to scale,
        // but there are so many broken ACPI timers this might not work
        //
#ifdef SPEEDY_BOOT
        if (!HalpPmTimerScaleTimers())
#endif
            HalpScaleTimers();

        HalpProc0TSCHz = ((PHALPCR)(KeGetPcr()->HalReserved))->TSCHz;

        //
        //  Initialize the reboot handler
        //

        HalpSetInternalVector(APIC_REBOOT_VECTOR,
                              HalpApicRebootService,
                              NULL,
                              HIGH_LEVEL);

        HalpSetInternalVector(APIC_GENERIC_VECTOR,
                              HalpBroadcastCallService,
                              NULL,
                              CLOCK2_LEVEL - 1);

        //
        // Initialize the clock for the processor that keeps
        // the system time. This uses a stub ISR until Phase 1
        //

        KiSetHandlerAddressToIDTIrql(APIC_CLOCK_VECTOR,
                                     HalpClockInterruptStub,
                                     NULL,
                                     CLOCK2_LEVEL);

        HalpVectorToINTI[APIC_CLOCK_VECTOR] = RTCInti;
        HalEnableSystemInterrupt(APIC_CLOCK_VECTOR, CLOCK2_LEVEL, HalpClockMode);

        //
        // Init timer watchdog if enabled.
        //

        HalpInitTimerWatchdog( Phase );

        HalpInitializeClock();

#ifndef ACPI_HAL
        HalpRegisterVector (
            DeviceUsage | InterruptLatched,
            ADJUSTED_VECTOR(RTC_IRQ),
            APIC_CLOCK_VECTOR,
            HalpVectorToIRQL [APIC_CLOCK_VECTOR >> 4]
            );
#endif

        //
        // Register NMI vector
        //

        HalpRegisterVector (
            InternalUsage,
            NMI_VECTOR,
            NMI_VECTOR,
            HIGH_LEVEL
        );


        //
        // Register spurious IDTs as in use
        //

        HalpRegisterVector (
            InternalUsage,
            APIC_SPURIOUS_VECTOR,
            APIC_SPURIOUS_VECTOR,
            HIGH_LEVEL
        );


        //
        // Initialize the profile interrupt vector.
        //

        KeSetProfileIrql(HIGH_LEVEL);
        HalStopProfileInterrupt(0);
        HalpSetInternalVector(APIC_PROFILE_VECTOR,
                              HalpProfileInterrupt,
                              NULL,
                              PROFILE_LEVEL);

        //
        // Set performance interrupt vector
        //

        HalpSetInternalVector(APIC_PERF_VECTOR,
                              HalpPerfInterrupt,
                              NULL,
                              PROFILE_LEVEL);

        //
        // Initialize the IPI, APC and DPC handlers.  On AMD64, the
        // APC and DPC handling is done in the kernel.
        //

#if !defined(_AMD64_)
        HalpSetInternalVector(DPC_VECTOR,
                              HalpDispatchInterrupt,
                              NULL,
                              DISPATCH_LEVEL);

        HalpSetInternalVector(APC_VECTOR,
                              HalpApcInterrupt,
                              NULL,
                              APC_LEVEL);
#endif
        HalpSetInternalVector(APIC_IPI_VECTOR,
                              HalpIpiHandler,
                              NULL,
                              IPI_LEVEL);

        //
        // HALMPS doesn't actually do address translation on a
        // bus.  Register the quick version of FindBusAddressTranslation.
        //

        HALPDISPATCH->HalFindBusAddressTranslation =
           HalpFindBusAddressTranslation;

        //
        // Initialize spinlock used by HalGetBusData hardware access routines
        //

        KeInitializeSpinLock(&HalpSystemHardwareLock);

        //
        // Initialize data structures used to chain dma adapters
        // together for debugging purposes
        //
        KeInitializeSpinLock(&HalpDmaAdapterListLock);
        InitializeListHead(&HalpDmaAdapterList);

#ifdef ACPI_HAL
        //
        // Initialize synchronzation event used to serialize
        // new adapter events on the ACPI HAL (which has no notion of bus
        // handlers)
        //

        KeInitializeEvent (&HalpNewAdapter, SynchronizationEvent, TRUE);
#endif

        //
        // Determine if there is physical memory above 16 MB.
        //

        LessThan16Mb = TRUE;

        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
            Descriptor = CONTAINING_RECORD( NextMd,
                                            MEMORY_ALLOCATION_DESCRIPTOR,
                                            ListEntry );

            if (Descriptor->MemoryType != LoaderFirmwarePermanent &&
                Descriptor->MemoryType != LoaderSpecialMemory  &&
                Descriptor->BasePage + Descriptor->PageCount > 0x1000) {
                LessThan16Mb = FALSE;
                break;
            }

            NextMd = Descriptor->ListEntry.Flink;
        }

#if !defined(_HALPAE_)

        HalpMapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;

        //
        // Allocate map buffers for the adapter objects
        //

        HalpMapBufferPhysicalAddress.LowPart =
            HalpAllocPhysicalMemory (LoaderBlock, MAXIMUM_PHYSICAL_ADDRESS,
                HalpMapBufferSize >> PAGE_SHIFT, TRUE);
        HalpMapBufferPhysicalAddress.HighPart = 0;


        if (!HalpMapBufferPhysicalAddress.LowPart) {

            //
            // There was not a satisfactory block.  Clear the allocation.
            //

            HalpMapBufferSize = 0;
        }

#else

        //
        // Initialize and allocate map buffers for the 24bit master adapter
        // object.
        //

        MasterAdapter24.MaxBufferPages =
            MAXIMUM_ISA_MAP_BUFFER_SIZE / PAGE_SIZE;

        mapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;
        mapBufferAddress =
            HalpAllocPhysicalMemory (LoaderBlock,
                                     MAXIMUM_PHYSICAL_ADDRESS,
                                     mapBufferSize >> PAGE_SHIFT,
                                     TRUE);

        if (mapBufferAddress == 0) {
            mapBufferSize = 0;
        }

        MasterAdapter24.MapBufferPhysicalAddress.LowPart = mapBufferAddress;
        MasterAdapter24.MapBufferPhysicalAddress.HighPart = 0;
        MasterAdapter24.MapBufferSize = mapBufferSize;

        if (HalPaeEnabled() != FALSE) {

            //
            // Initialize and allocate map buffers for the 32bit master adapter
            // object.  This should only be needed on a PAE-enabled system.
            //

            MasterAdapter32.MaxBufferPages =
                MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE;

            mapBufferSize = INITIAL_MAP_BUFFER_LARGE_SIZE;
            mapBufferAddress =
                HalpAllocPhysicalMemory (LoaderBlock,
                                         (ULONG)-1,
                                         mapBufferSize >> PAGE_SHIFT,
                                         TRUE);

            if (mapBufferAddress == 0) {
                mapBufferSize = 0;
            }

            MasterAdapter32.MapBufferPhysicalAddress.LowPart = mapBufferAddress;
            MasterAdapter32.MapBufferPhysicalAddress.HighPart = 0;
            MasterAdapter32.MapBufferSize = mapBufferSize;
        }

#endif

        //
        // Initialize and register a bug check callback record.
        //

        KeInitializeCallbackRecord(&HalpCallbackRecord);
        KeRegisterBugCheckCallback(&HalpCallbackRecord,
                                   HalpBugCheckCallback,
                                   NULL,
                                   0,
                                   (PUCHAR)HalName);

    } else {

        //
        // Phase 1 initialization
        //

        pPCR = KeGetPcr();

        if (pPCR->Number == 0) {

            //
            // Back-pocket some PTEs for DMA during low mem
            //
            HalpInitReservedPages();

#ifdef ACPI_HAL
            HalpInitNonBusHandler ();
#else
            HalpRegisterInternalBusHandlers ();
#endif

#if defined(_AMD64_)

            //
            // Initialize the BIOS support subsystem
            //

            HalpInitializeBios();
#endif

            //
            // Init timer watchdog if enabled (allocate snapshot buffer).
            //

            HalpInitTimerWatchdog( Phase );

            //
            // Initialize the clock for the processor
            // that keeps the system time.
            //

            KiSetHandlerAddressToIDTIrql(APIC_CLOCK_VECTOR,
                                         HalpClockInterrupt,
                                         NULL,
                                         CLOCK_LEVEL);

            //
            // Set initial feature bits
            //

            HalpFeatureBits = HalpGetFeatureBits();

#if DBG_SPECIAL_IRQL

            //
            // Do Special IRQL initialization.
            //

            HalpInitializeSpecialIrqlSupport();

#endif

#if !defined(_WIN64)

            //
            // Point to new movnti routine if Movnti is detected
            //

             if(HalpFeatureBits & HAL_WNI_PRESENT) {
                 HalpMoveMemory = HalpMovntiCopyBuffer;
             }

#ifdef ACPI_HAL
#ifdef NT_UP
            //
            // Perf counter patch for non-compliant ACPI machines
            //
            HalpAcpiTimerPerfCountHack();
#endif
#endif

#endif

#if defined(_AMD64_)

            //
            // Initialize per-processor profiling
            //

            HalpInitializeProfiling (pPCR->Number);
#endif

        } else {
            //
            //  Initialization needed only on non BSP processors
            //
#ifdef SPEEDY_BOOT
            if (!HalpPmTimerScaleTimers())
#endif
                HalpScaleTimers();

            //
            // Hack.  Make all processors have the same value for
            // the timestamp counter frequency.
            //

            ((PHALPCR)(KeGetPcr()->HalReserved))->TSCHz = HalpProc0TSCHz;

            //
            // Initialize the clock for all other processors
            //

            KiSetHandlerAddressToIDTIrql(APIC_CLOCK_VECTOR,
                                         HalpClockInterruptPn,
                                         NULL,
                                         CLOCK_LEVEL);

            //
            // Reduce feature bits to be a subset
            //

            HalpFeatureBits &= HalpGetFeatureBits();

#if defined(_AMD64_)

            //
            // Initialize per-processor profiling
            //

            HalpInitializeProfiling (pPCR->Number);
#endif
        }

    }

    HalpInitMP (Phase, LoaderBlock);

    if (Phase == 1) {

        //
        // Enable system NMIs on Pn
        //

        HalpEnableNMI ();

#ifdef TIMER_DBG
        HalInitialized = TRUE;
#endif

    }

    return TRUE;
}

ULONG
HalpGetFeatureBits (
    VOID
    )
{
    UCHAR   Buffer[50];
    ULONG   Junk, ProcessorStepping, ProcessorFeatures, Bits;
    PULONG  p1, p2;
    PUCHAR  OrgRoutineAddress;
    PUCHAR  MCERoutineAddress;
    ULONG   newop;
    PKPRCB  Prcb;


    Bits = 0;

    Prcb = KeGetCurrentPrcb();

    if (!Prcb->CpuID) {
        Bits |= HAL_NO_SPECULATION;
        return Bits;
    }

    //
    // Determine the processor type
    //

    HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
    Buffer[12] = 0;

    //
    // Determine which features are present
    //

    HalpCpuID (1, &ProcessorStepping, &Junk, &Junk, &ProcessorFeatures);

    if (ProcessorFeatures & CPUID_MCA_MASK) {
        Bits |= HAL_MCA_PRESENT;
    }

    if (ProcessorFeatures & CPUID_MCE_MASK) {
        Bits |= HAL_MCE_PRESENT;
    }

    if (ProcessorFeatures & CPUID_VME_MASK) {
        Bits |= HAL_CR4_PRESENT;
    }

    if(ProcessorFeatures & CPUID_WNI_MASK) {
        Bits |= HAL_WNI_PRESENT;
    }

#if defined(_AMD64_)
    Bits |= HAL_PERF_EVENTS;
#endif


    //
    // Check Intel feature bits for HAL features needed
    //

#if !defined(_WIN64)

    if (strcmp (Buffer, HalpGenuineIntel) == 0) {

        if ((Prcb->CpuType == 6) || (Prcb->CpuType == 0xf)) {
            Bits |= HAL_PERF_EVENTS;
        }

        if (Prcb->CpuType < 6) {
            Bits |= HAL_NO_SPECULATION;
        }

#ifndef NT_UP

        //
        // Check if IFU errata workaround is required
        //

        if (Prcb->Number == 0  &&  (Bits & HAL_MCA_PRESENT)  &&
            ((ProcessorStepping & 0x700) == 0x600) &&
            ((ProcessorStepping & 0xF0)  == 0x10) &&
            ((ProcessorStepping & 0xF)   <= 0x7) ) {

            //
            // If the stepping is 617 or earlier, provide software workaround
            //

            p1 = (PULONG) (KeAcquireSpinLockRaiseToSynch);
            p2 = (PULONG) (KeAcquireSpinLockRaiseToSynchMCE);
            newop = (ULONG) p2 - (ULONG) p1 - 2;    // compute offset
            ASSERT (newop < 0x7f);                  // verify within range
            newop = 0xeb | (newop << 8);            // short-jmp

            *(p1) = newop;                          // patch it
        }

#endif  // NT_UP

    } else if (strcmp (Buffer, HalpAuthenticAMD) == 0) {

        ULONG ExtendedProcessorFeatures;
        ULONG MaxExtendedFunc;

        MaxExtendedFunc = 0;
        HalpCpuID (0x80000000, &MaxExtendedFunc, &Junk, &Junk, &Junk);

        if (MaxExtendedFunc >= 0x80000001) {
            HalpCpuID (0x80000001, &Junk, &Junk, &Junk, &ExtendedProcessorFeatures);
            if (ExtendedProcessorFeatures & CPUID_NX_MASK) {
                Bits |= HAL_NX_PRESENT;
            }
        }
    }

#endif  // _WIN64

    return Bits;
}

#if !defined(_WIN64)

BOOLEAN
HalpIsNXEnabled (
    VOID
    )

/*++

Routine Description:

    This function returns a boolean indicating whether the current processor
    has the no-execute bit set in the EFER MSR.

Arguments:

    None.

Return Value:

    A value of TRUE is returned indicates that the current processor has
    enabled NX mode, otherwise FALSE is returned.

--*/

{
    ULONGLONG msrValue;
    BOOLEAN result;

    result = FALSE;
    if ((HalpGetFeatureBits() & HAL_NX_PRESENT) != 0) {

        msrValue = RDMSR(0xc0000080);
        if ((msrValue & 0x800) != 0) {
            result = TRUE;
        }
    }

    return result;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpdetect.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpdetect.c

Abstract:

    This module detects an MPS system.

Author:

    Ron Mosgrove (Intel) - Aug 1993.

Environment:

    Kernel mode or from textmode setup.

Revision History:
    Rajesh Shah (Intel) - Oct 1993. Added support for MPS table.

--*/

#ifndef _NTOS_
#include "halp.h"
#endif

#ifdef SETUP
#define FAILMSG(a)
#else
#define FAILMSG(a)  HalDisplayString(a)
extern UCHAR  rgzNoMpsTable[];
extern UCHAR  rgzNoApic[];
extern UCHAR  rgzBadApicVersion[];
extern UCHAR  rgzApicNotVerified[];
extern UCHAR  rgzMPPTRCheck[];
extern UCHAR  rgzNoMPTable[];
extern UCHAR  rgzMPSBadSig[];
extern UCHAR  rgzMPSBadCheck[];
extern UCHAR  rgzBadDefault[];
extern UCHAR  rgzNoMem[];
#endif


// Include the code that actually detect a MPS system
#include "pcmpdtct.c"


BOOLEAN
HalpVerifyIOUnit (
    IN PUCHAR BaseAddress
    );

VOID
HalpInitMpInfo (
    IN struct PcMpTable *MpTablePtr
    );

ULONG
DetectMPS (
    OUT PBOOLEAN IsConfiguredMp
    );

ULONG
DetectUPMPS (
    OUT PBOOLEAN IsConfiguredMp
    );

extern struct PcMpTable *GetPcMpTable( VOID );

ULONG UserSpecifiedNoIoApic = 0;

struct HalpMpInfo HalpMpInfoTable;
struct PcMpTable  HalpPcMpTable;

struct PcMpTable *PcMpTablePtr;

#ifndef SETUP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,HalpVerifyIOUnit)
#pragma alloc_text(PAGELK,HalpInitMpInfo)
#pragma alloc_text(PAGELK,DetectMPS)
#pragma alloc_text(PAGELK,DetectUPMPS)
#endif  // ALLOC_PRAGMA

extern struct PcMpTable *PcMpDefaultTablePtrs[];

#endif // SETUP


BOOLEAN
HalpVerifyIOUnit(
    IN PUCHAR BaseAddress
    )
/*++

Routine Description:

    Verify that an IO Unit exists at the specified address

 Arguments:

    BaseAddress - Virtual address of the IO Unit to test.

 Return Value:
    BOOLEAN - TRUE if a IO Unit was found at the passed address
            - FALSE otherwise

--*/

{
    union ApicUnion {
        ULONG Raw;
        struct ApicVersion Ver;
    } Temp1, Temp2;

    struct ApicIoUnit *IoUnitPtr = (struct ApicIoUnit *) BaseAddress;

    //
    //  The documented detection mechanism is to write all zeros to
    //  the Version register.  Then read it back.  The IO Unit exists if the
    //  same result is read both times and the Version is valid.
    //

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp1.Raw = IoUnitPtr->RegisterWindow;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp2.Raw = IoUnitPtr->RegisterWindow;

    if ((Temp1.Ver.Version != Temp2.Ver.Version) ||
        (Temp1.Ver.MaxRedirEntries != Temp2.Ver.MaxRedirEntries)) {
        //
        //  No IO Unit There
        //
        return (FALSE);
    }

    return (TRUE);
}


VOID
HalpInitMpInfo (
    IN struct PcMpTable *MpTablePtr
    )

/*++
Routine Description:
    This routine initializes a HAL specific data structure that is
    used by the HAL to simplify access to MP information.

Arguments:
    MpTablePtr: Pointer to the MPS table.

 Return Value:
     Pointer to the HAL MP information table.

*/
{
    PUCHAR TraversePtr, EndOfBaseTable;
    UCHAR  CheckSum;

    // Walk the MPS table. The HAL MP information structure has
    // pointers to the first entry for each entry type in the MPS
    // table. Set these pointers.

    TraversePtr = (PUCHAR) MpTablePtr + HEADER_SIZE;
    EndOfBaseTable = (PUCHAR) MpTablePtr + MpTablePtr->TableLength;

    HalpMpInfoTable.ApicVersion =
    (ULONG) (((PPCMPPROCESSOR)(TraversePtr))->LocalApicVersion & 0xf0);

    while (TraversePtr < EndOfBaseTable)  {
        switch (*TraversePtr)  {
            case ENTRY_PROCESSOR:
                if(((PPCMPPROCESSOR)(TraversePtr))->CpuFlags & CPU_ENABLED) {
                    if (HalpMpInfoTable.ProcessorCount == 0) {
                        HalpMpInfoTable.ProcessorEntryPtr = 
                            (PPCMPPROCESSOR) TraversePtr;
                    }
                    HalpMpInfoTable.ProcessorCount++;
                }
                TraversePtr += sizeof(PCMPPROCESSOR);
                break;

            case ENTRY_BUS:
                if (HalpMpInfoTable.BusCount == 0)  {
                    HalpMpInfoTable.BusEntryPtr = (PPCMPBUS) TraversePtr;
                }
                HalpMpInfoTable.BusCount += 1;
                TraversePtr += sizeof(PCMPBUS);
                break;

            case ENTRY_IOAPIC:
                if ((((PPCMPIOAPIC)(TraversePtr))->IoApicFlag & 
                    IO_APIC_ENABLED) && (UserSpecifiedNoIoApic == 0)) {
                    if (HalpMpInfoTable.IOApicCount == 0)  {
                        HalpMpInfoTable.IoApicEntryPtr = 
                            (PPCMPIOAPIC) TraversePtr;
                    }
                    HalpMpInfoTable.IOApicCount += 1;
                }
                TraversePtr += sizeof(PCMPIOAPIC);
                break;

            case ENTRY_INTI:
                if (HalpMpInfoTable.IntiCount == 0)  {
                    HalpMpInfoTable.IntiEntryPtr = (PPCMPINTI) TraversePtr;
                }
                HalpMpInfoTable.IntiCount += 1;
                TraversePtr += sizeof(PCMPINTI);
                break;

            case ENTRY_LINTI:
                if (HalpMpInfoTable.LintiCount == 0)  {
                    HalpMpInfoTable.LintiEntryPtr = (PPCMPLINTI) TraversePtr;
                }
                HalpMpInfoTable.LintiCount += 1;
                TraversePtr += sizeof(PCMPLINTI);
                break;

            default:
                //
                // Unknown MPS entry. Since we don't know it's size, we will
                // terminate parsing here.
                //
                DBGMSG("HAL: Invalid MPS table entry type detected\n");
                TraversePtr = EndOfBaseTable;
                break;
        }  // switch
    } // while


    //
    // Check for Extension table defined
    //

    if (MpTablePtr->ExtTableLength  &&
        MpTablePtr->TableLength + MpTablePtr->ExtTableLength < 8192) {

        CheckSum = ComputeCheckSum(
                        (PUCHAR) MpTablePtr + MpTablePtr->TableLength,
                        MpTablePtr->ExtTableLength
                        );

        CheckSum = CheckSum + MpTablePtr->ExtTableChecksum;

        if (CheckSum != 0) {
            DBGMSG("HALMPS: InitMpInfo: Extension table checksum error\n");

        } else {
            HalpMpInfoTable.ExtensionTable = (PMPS_EXTENTRY)
                (((PUCHAR) MpTablePtr) + MpTablePtr->TableLength);

            HalpMpInfoTable.EndOfExtensionTable = (PMPS_EXTENTRY)
                (((PUCHAR) MpTablePtr) + MpTablePtr->TableLength +
                                        MpTablePtr->ExtTableLength);
        }
    }

    return;
}


ULONG
DetectMPS(
    OUT PBOOLEAN IsConfiguredMp
)

/*++

Routine Description:

   This function is called from HalInitializeProcessors to determine
   if this is an appropriate system to run the MPS hal on.

   The recommended detection mechanism is:

   if ( MPS information does not exist )
       then
           System is not MPS compliant. Return false.

   In MP table:
       if ( number IO APICs < 1 )
           then
               Not a MPS System - return false

       if ( # CPUs = 1 )
           then
               Found a Single Processor MPS System
           else
               Found a MP MPS System


    A side effect of this routine is the mapping of the IO UNits and
    Local unit virtual addresses.

   Return TRUE


 Arguments:

   IsConfiguredMp - TRUE if this machine is a MP instance of the MPS spec, else FALSE.

 Return Value:
   0 - if not a MPS
   1 - if MPS

*/
{

    UCHAR ApicVersion;
    PUCHAR  LocalApic;
    PHYSICAL_ADDRESS physicalAddress;
#ifndef SETUP
    UCHAR i;
    PPCMPIOAPIC IoEntryPtr;
#endif

    //
    // Initialize MpInfo table
    //

    RtlZeroMemory (&HalpMpInfoTable, sizeof HalpMpInfoTable);

    //
    // Set the return Values to the default
    //

    *IsConfiguredMp = FALSE;

    //
    // See if there is a MP Table
    //

#if 1
    if ((PcMpTablePtr = GetPcMpTable()) == NULL) {
        FAILMSG (rgzNoMpsTable);
        return(FALSE);
    }
#else
    //********
    //******** HACK! To make down level 1.0 machine work
    //********

    if ((PcMpTablePtr = MPS10_GetPcMpTable()) == NULL) {
        FAILMSG (rgzNoMpsTable);
        return(FALSE);
    }
#endif

#ifdef SETUP
    // During setup, if we detected a default MPS configuration, we have
    // no more checking to do.
    if (PcMpTablePtr ==  (struct PcMpTable *) DEFAULT_MPS_INDICATOR)  {
        *IsConfiguredMp = TRUE;
        return(TRUE);
    }
#endif // SETUP

#if DEBUGGING
    HalpDisplayConfigTable();
#endif

    // We have a MPS table. Initialize a HAL specific MP information
    // structure that gets information from the MPS table.

    HalpInitMpInfo(PcMpTablePtr);


    // Verify the information in the MPS table as best as we can.

    if (HalpMpInfoTable.IOApicCount == 0) {
        //
        //  Someone Has a MP Table and no IO Units -- Weird
        //  We have to assume the BIOS knew what it was doing
        //  when it built the table.  so ..
        //
        FAILMSG (rgzNoApic);
        return (FALSE);
    }

    //
    //  It's a MPS System.  It could be a UP System though.
    //

#ifdef SETUP
    //
    // If this is a MPS (MPS) compliant system, but has only 1 processor,
    // for now we want to install a standard UP kernel and HAL.
    //

    if (HalpMpInfoTable.ProcessorCount <= 1) {
        return FALSE;
    }
#endif

    if (HalpMpInfoTable.ProcessorCount > 1) {
        *IsConfiguredMp = TRUE;
    }

    HalpMpInfoTable.LocalApicBase = (ULONG) PcMpTablePtr->LocalApicAddress;
    physicalAddress.QuadPart = HalpMpInfoTable.LocalApicBase;
    LocalApic = (PUCHAR) HalpMapPhysicalMemoryWriteThrough64(
                            physicalAddress,1);

    if (!LocalApic) {
        FAILMSG (rgzNoMem);
        return (FALSE);
    }

#ifndef SETUP
    HalpRemapVirtualAddress64 (
        (PVOID) LOCALAPIC,
        physicalAddress,
        TRUE
        );
#endif

    ApicVersion = (UCHAR) *(LocalApic + LU_VERS_REGISTER);

    if (ApicVersion > 0x1f) {
        //
        //  Only known Apics are 82489dx with version 0.x and
        //  Embedded Apics with version 1.x (where x is don't care)
        //
        //  Return of 0xFF?   Can't have an MPS system without a Local Unit.
        //

#ifdef DEBUGGING
        sprintf(Cbuf, "HALMPS: apic version %x, read from %x\n",
            ApicVersion, LocalApic + LU_VERS_REGISTER);

        HalDisplayString(Cbuf);
#endif

        FAILMSG (rgzBadApicVersion);
        return (FALSE);
    }

#ifdef SETUP
    //
    // MP MPS table, and the local APIC ID looked OK.
    //

    return TRUE;
#endif  //SETUP


#ifdef DEBUGGING
    if ((ApicVersion & 0xf0) == 0) {
        if (HalpMpInfoTable.ApicVersion != APIC_82489DX)
        HalDisplayString("HAL:Invalid Local Apic version in MP table\n");
        else {
            sprintf(Cbuf, "HAL: DetectMPS: Found 82489DX Local APIC (Ver 0x%x) at 0x%lx\n",
                    ApicVersion, LocalApic);
            HalDisplayString(Cbuf);
        }
    } else {
        sprintf(Cbuf, "HAL: DetectMPS: Found Embedded Local APIC (Ver 0x%x) at 0x%lx\n",
                ApicVersion, LocalApic);
        HalDisplayString(Cbuf);

    }
#endif // DEBUGGING

#ifndef SETUP
    HalpUnmapVirtualAddress(LocalApic,1);

    IoEntryPtr = HalpMpInfoTable.IoApicEntryPtr;

    for(i=0; i < HalpMpInfoTable.IOApicCount; i++, IoEntryPtr++)
    {
        if (IoEntryPtr->IoApicFlag & IO_APIC_ENABLED) {
            //
            //  Verify the existance of the IO Units
            //

            physicalAddress.QuadPart = (ULONG)IoEntryPtr->IoApicAddress;
            HalpMpInfoTable.IoApicPhys[i] = (ULONG)IoEntryPtr->IoApicAddress;
            HalpMpInfoTable.IoApicBase[i] = (PULONG)
                HalpMapPhysicalMemoryWriteThrough64(physicalAddress, 1);

            //
            //  Verify the existance of the IO Unit
            //

            if (!(HalpVerifyIOUnit((PUCHAR)HalpMpInfoTable.IoApicBase[i]))) {
                FAILMSG (rgzApicNotVerified);
                return (FALSE);
            }
        }
    }

    DBGMSG("HAL: DetectMPS: MPS system found - Returning TRUE\n");
    return(TRUE);
#endif
}


ULONG
DetectUPMPS(
    OUT PBOOLEAN IsConfiguredMp
)
/*++

Routine Description:

   This function is called by setup after DetectMPS has returned
   false.  During setup time DetectMPS will return false, if the
   machine is an MPS system, but only has one processor.   This
   function is used to detect such a machine at setup time.

 Arguments:

   IsConfiguredMp - FALSE

 Return Value:
   0 - if not a UP MPS
   1 - if UP MPS

--*/
{
    *IsConfiguredMp = FALSE;

    // we assume the caller has already called DetectMPS, and the
    // MPS table has already been parsed.

    return (HalpMpInfoTable.ProcessorCount == 1 ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixinfo.c

Abstract:

Author:

    Ken Reneris (kenr)  08-Aug-1994

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"
#include "pcmp_nt.inc"


extern ULONG_PTR  HalpPerfInterruptHandler;
static HANDLE HalpProcessId = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpSetSystemInformation)
#endif


NTSTATUS
HalpSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
{
    PAGED_CODE();

    switch (InformationClass) {
        case HalProfileSourceInterruptHandler:

            //
            // Set ISR handler for PerfVector
            //

            if (!(HalpFeatureBits & HAL_PERF_EVENTS)) {
                return STATUS_UNSUCCESSFUL;
            }
            
            //
            // Accept the interrupt handler if no other process
            // has already hooked the interrupt or if we are in
            // the context of the process that already hooked it.
            //

            if (HalpProcessId == NULL) {
                HalpPerfInterruptHandler = *((PULONG_PTR) Buffer);
                if (HalpPerfInterruptHandler != 0) {
                    HalpProcessId = PsGetCurrentProcessId();
                }
            } else if (HalpProcessId == PsGetCurrentProcessId()) {
                HalpPerfInterruptHandler = *((PULONG_PTR) Buffer);
                if (HalpPerfInterruptHandler == 0) {
                    HalpProcessId = NULL;
                }
            } else {
                return STATUS_UNSUCCESSFUL;
            }
            return STATUS_SUCCESS;

#if defined(_AMD64_)

        case HalProfileSourceInterval:

            if (BufferSize == sizeof(HAL_PROFILE_SOURCE_INTERVAL)) {
    
                PHAL_PROFILE_SOURCE_INTERVAL p;
                p = (PHAL_PROFILE_SOURCE_INTERVAL)Buffer;

                return HalpSetProfileSourceInterval(p->Source, &(p->Interval));

            }

            return STATUS_INFO_LENGTH_MISMATCH;

#endif
    }

    return HaliSetSystemInformation (InformationClass, BufferSize, Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mphibrnt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mphibrnt.c

Abstract:

    This file provides the code that changes the system from
        the ACPI S0 (running) state to S4 (hibernated).

Author:

    Jake Oshins (jakeo) May 6, 1997

Revision History:

--*/

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"
#include "ixsleep.h"

NTSTATUS
HaliLegacyHibernate(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

ULONG
DetectMPS (
    OUT PBOOLEAN IsConfiguredMp
    );

volatile extern BOOLEAN HalpHiberInProgress;
extern BOOLEAN HalpDisableHibernate;
extern UCHAR   HalpLastEnumeratedActualProcessor;

struct PcMpTable *PcMpTablePtr;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpRegisterHibernate)
#pragma alloc_text(PAGELK, HaliLegacyHibernate)
#endif


VOID
HalpRegisterHibernate(
    VOID
    )
/*++
Routine Description:

    This function registers a hibernation handler (for
    state S4) with the Policy Manager.
    
Arguments:

--*/
{
    POWER_STATE_HANDLER powerState;
    OBJECT_ATTRIBUTES   objAttributes;
    PCALLBACK_OBJECT    callback;
    UNICODE_STRING      callbackName;
    PSYSTEM_POWER_STATE_DISABLE_REASON pReasonNoOSPM,pReasonBios;
    SYSTEM_POWER_LOGGING_ENTRY PowerLoggingEntry;
    NTSTATUS ReasonStatus;
    
    PAGED_CODE();

    //
    // Register callback that tells us to make
    // anything we need for sleeping non-pageable.
    //
    
    RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &objAttributes,
        &callbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );
    
    ExCreateCallback(&callback,
                     &objAttributes,
                     FALSE,
                     TRUE);
    
    ExRegisterCallback(callback,
                       (PCALLBACK_FUNCTION)&HalpPowerStateCallback,
                       NULL);

    if (HalpDisableHibernate == FALSE) {
        
        //
        // Register the hibernation handler.
        //
    
        powerState.Type = PowerStateSleeping4;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliLegacyHibernate;
        powerState.Context = 0;
        
        ZwPowerInformation(SystemPowerStateHandler,
                           &powerState,
                           sizeof(POWER_STATE_HANDLER),
                           NULL,
                           0);
    } else {       
        
        //
        // we're not enabling hibernate because there is a hackflag
        // that disallows hibernate.  let the power manager know why.
        //
        pReasonBios = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                            HAL_POOL_TAG
                            );
        if (pReasonBios) {
            RtlZeroMemory(pReasonBios, sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
            pReasonBios->AffectedState[PowerStateSleeping4] = TRUE;
            pReasonBios->PowerReasonCode = SPSD_REASON_BIOSINCOMPATIBLE;

            PowerLoggingEntry.LoggingType = LOGGING_TYPE_SPSD;
            PowerLoggingEntry.LoggingEntry = pReasonBios;

            ReasonStatus = ZwPowerInformation(
                                    SystemPowerLoggingEntry,
                                    &PowerLoggingEntry,
                                    sizeof(PowerLoggingEntry),
                                    NULL,
                                    0 );

            if (ReasonStatus != STATUS_SUCCESS) {
                ExFreePool(pReasonBios);
            }

        }        
    }

    //
    //
    // we're on a non-ACPI system (This function is called in an #ifndef 
    // ACPI_HAL block.)  This means there is no S1-S3 handler registered. 
    // If the user wants "standby" support, they must use APM.  Let the power
    // manager interface know that we're on a legacy platform so we can inform
    // the user (for instance the user might think they are running in ACPI 
    // mode but they are not.)
    //
    pReasonNoOSPM = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                            HAL_POOL_TAG
                            );
    
    if (pReasonNoOSPM) {
        RtlZeroMemory(pReasonNoOSPM, sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
        pReasonNoOSPM->AffectedState[PowerStateSleeping1] = TRUE;
        pReasonNoOSPM->AffectedState[PowerStateSleeping2] = TRUE;
        pReasonNoOSPM->AffectedState[PowerStateSleeping3] = TRUE;
        pReasonNoOSPM->PowerReasonCode = SPSD_REASON_NOOSPM;

        PowerLoggingEntry.LoggingType = LOGGING_TYPE_SPSD;
        PowerLoggingEntry.LoggingEntry = pReasonNoOSPM;

        ReasonStatus = ZwPowerInformation(
                                SystemPowerLoggingEntry,
                                &PowerLoggingEntry,
                                sizeof(PowerLoggingEntry),
                                NULL,
                                0 );

        if (ReasonStatus != STATUS_SUCCESS) {
            ExFreePool(pReasonNoOSPM);
        }

    }
}

NTSTATUS
HaliLegacyHibernate (
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
/*++
Routine Description:

    This function is called to hibernate legacy PCs.  It saves
    hardware state and waits here for the user to power off the system.
    
Arguments:

    
--*/
{
    volatile ULONG ThisProcessor;
    static volatile ULONG Barrier = 0;
    LONG ii;
    KIRQL oldIrql, dummyIrql;
    LOADER_PARAMETER_BLOCK LoaderBlock;
    KPRCB Prcb;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN IsMpSystem;
    KAFFINITY SavedActiveProcessors;
    extern ULONG HalpProfileRunning;

    ASSERT(SystemHandler);

    ThisProcessor = KeGetPcr()->Prcb->Number;
    
    if (ThisProcessor == 0) {
        
        HalpHiberInProgress = TRUE;
        
        if ((NumberProcessors > 1) &&
            (HalpHiberProcState == NULL)) {
            
            //
            // We could not allocate memory to save processor state.
            //
            
            HalpHiberInProgress = FALSE;
        }
    }
    
    oldIrql = KeGetCurrentIrql();
    
    //
    // Wait for all processors to arrive here.
    //

    InterlockedDecrement(Number);
    while (*Number != 0);

    if (!HalpHiberInProgress)  {
    
        //
        // We could not allocate memory to save processor state.
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //
    // Save non-boot processor state
    //
    
    if (ThisProcessor != 0)  {

        //
        // Save processor state and wait here.
        // N.B. We wait here rather than returning to the kernel because
        // the stack pointer in the saved processor context points to the
        // current stack and we want to resume execution in this routine
        // with our current stack.
        //

        HalpSaveProcessorStateAndWait(&HalpHiberProcState[ThisProcessor],
                                      (PULONG)&Barrier);

        //
        // Barrier will be 0 when we return from this function before 
        // hibernating.  It will non-zero the second time this
        // function returns.
        //
        // N.B.  The non-boot processors will spin in HalpSaveProcessorState
        //       until Barrier is zeroed.
        //

        if (Barrier == 0) {
            return STATUS_DEVICE_DOES_NOT_EXIST;
        } else {
            goto HalpPnHiberResume;
        }
    }

    //
    // Save motherboard state.
    //

    HalpSaveDmaControllerState();

    //
    // Wait for all the non-boot procs to finish saving state.
    //
    
    while (Barrier != (ULONG)NumberProcessors - 1);

    //
    // Change HAL's picture of the world to single processor while
    // the hibernate file is written.
    //

    SavedActiveProcessors = HalpActiveProcessors;
    HalpActiveProcessors = KeGetCurrentPrcb()->SetMember;

    //
    // If there's a system handler, invoke it.  The system handler will
    // write the hibernation file to disk
    //

    if (SystemHandler) {
        status = SystemHandler(SystemContext);
    }

    //
    // Hibernation is over. Boot processor gets control here. The
    // non boot processors are in the state that BIOS left them.
    //

    HalpActiveProcessors = SavedActiveProcessors;
    Barrier = 0;

    //
    // If this returns success, then the system is now effectively
    // hibernated. On the other hand, if this function returns something other
    // than success, then it means that we have just un-hibernated,
    // so restore state.
    //


    if ((status == STATUS_SUCCESS) ||
        (status == STATUS_DEVICE_DOES_NOT_EXIST)) {
        
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // If you are remapping local apic, io apic and MPS table 
    // resources, you first have to unmap the current resources!!!
    // The BIOS may have created the MPS table at a different place or may
    // have changed values like processor local APIC IDs. Reparse it.
    //

    HalpUnMapIOApics();
    HalpUnMapPhysicalRange(PcMpTablePtr, 
                           (PcMpTablePtr->TableLength + PcMpTablePtr->ExtTableLength));
    DetectMPS(&IsMpSystem);
    HalpMpInfoTable.NtProcessors = NumberProcessors;
    HalpIpiClock = 0;
    RtlZeroMemory(&LoaderBlock, sizeof(LoaderBlock));
    RtlZeroMemory(&Prcb, sizeof(Prcb));
    LoaderBlock.Prcb = (ULONG) &Prcb;

    //
    // Reset Processor enumeration (so it starts at the beginning).
    //

    HalpLastEnumeratedActualProcessor = 0;

    //
    // Initialize minimum global hardware state needed.
    //

    HalpInitializeIOUnits();
    HalpInitializePICs(FALSE);

    //
    // Restore DMA controller state
    //

    HalpRestoreDmaControllerState();

    //
    // Initialize boot processor's local APIC so it can wake other processors
    //

    HalpInitializeLocalUnit ();
    KeRaiseIrql(HIGH_LEVEL, &dummyIrql);

    // 
    // Wake up the other processors
    //

    for(ii = 1; ii < NumberProcessors; ++ii)  {

        // Set processor number in dummy loader parameter block

        Prcb.Number = (UCHAR) ii;
        CurTiledCr3LowPart = HalpTiledCr3Addresses[ii].LowPart;
        if (!HalStartNextProcessor(&LoaderBlock, &HalpHiberProcState[ii]))  {

            //
            // We could not start a processor. This is a fatal error but
            // don't bail out yet until you try the remaining processors.
            //

            DBGMSG("HAL: Cannot start processor after hibernate resume\n");
        }
    }

HalpPnHiberResume:
    
    //
    // Finish up all the MP stuff that happens across multiple
    // HALs.
    //

    HalpPostSleepMP(NumberProcessors, Number);

    if (KeGetPcr()->Prcb->Number == 0)  {
        
        //
        // Restore the IO APIC state
        //
        
        HalpRestoreIoApicRedirTable();

        if (HalpProfileRunning == 1) {
            HalStartProfileInterrupt(0);
        }

    }

    KfLowerIrql(oldIrql);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpipi.asm ===
title "Interprocessor Interrupt"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;Copyright (c) 1992  Intel Corporation
;All rights reserved
;
;INTEL CORPORATION PROPRIETARY INFORMATION
;
;This software is supplied to Microsoft under the terms
;of a license agreement with Intel Corporation and may not be
;copied nor disclosed except in accordance with the terms
;of that agreement.
;
;
;Module Name:
;
;    mpipi.asm
;
;Abstract:
;
;    PC+MP IPI code.
;    Provides the HAL support for Interprocessor Interrupts and Processor
;    initialization for PC+MP Systems
;
;Author:
;
;    Ken Reneris (kenr) 13-Jan-1992
;
;Revision History:
;
;    Ron Mosgrove (Intel) Aug 1993
;        Modified for PC+MP Systems
;--
.486p
        .xlist

;
; Normal includes
;

include hal386.inc
include i386\kimacro.inc
include mac386.inc
include apic.inc
include callconv.inc                ; calling convention macros
include ntapic.inc


        EXTRNP  Kei386EoiHelper,0,IMPORT

        EXTRNP  _HalpMarkProcessorStarted,2

        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _KiIpiServiceRoutine,2,IMPORT
        EXTRNP  _HalDisplayString,1
        EXTRNP  HalpAcquireHighLevelLock,1,,FASTCALL
        EXTRNP  HalpReleaseHighLevelLock,2,,FASTCALL
        EXTRNP  HalpSendIpi,2,,FASTCALL
ifdef ACPI_HAL        
        EXTRNP  _DetectAcpiMP,2
else
        EXTRNP  _DetectMPS,1
endif        
        EXTRNP  _HalpRegisterKdSupportFunctions,1
        EXTRNP  _HalpInitializeLocalUnit,0
        EXTRNP  _HalpResetThisProcessor,0
if DBG OR DEBUGGING
        EXTRNP  _DbgBreakPoint,0,IMPORT
endif
        extrn   _HalpDefaultInterruptAffinity:DWORD
        extrn   _HalpActiveProcessors:DWORD

        extrn   _HalpGlobal8259Mask:WORD
        extrn   _HalpStaticIntAffinity:BYTE
        extrn   _HalpPICINTToVector:BYTE
        extrn   _rgzBadHal:BYTE

        extrn   _HalpMaxProcsPerCluster:BYTE
        extrn   _HalpIntDestMap:BYTE


I386_80387_BUSY_PORT    equ     0f0h

SEND_IPI    macro   IpiCommand
        mov     ecx, eax
        mov     edx, IpiCommand
        fstCall halpSendIpi
endm

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

    ALIGN   dword

        public  _HalpProcessorPCR
_HalpProcessorPCR       dd  MAXIMUM_PROCESSORS dup (?) ; PCR pointer for each processor

;
;  The following symbols are used by the Local Apic Error handler.
;                
LogApicErrors   equ 1
if LogApicErrors

        public _HalpLocalApicErrorLock
        public _HalpLocalApicErrorCount
        public _HalpApicErrorLog

APIC_ERROR_LOG_SIZE     equ     128     ; Must be 2^n see usage below

    ALIGN   dword

_HalpApicErrorLog               dw  APIC_ERROR_LOG_SIZE dup(0)
_HalpLocalApicErrorLock         dd  0
_HalpLocalApicErrorCount        dd  0

    ;
    ; Bit:
    ;
    ;    0 - Send checksum error
    ;    1 - Recieve checksum error
    ;    2 - Send accept error
    ;    3 - Receive accept error
    ;    4 - reserved
    ;    5 - Send illegal vector
    ;    6 - Receive illegal vector
    ;    7 - illegal register address
    ; 8-31 - reserved
    ;


endif ; LogApicErrors

        public HalpBroadcastLock, HalpBroadcastTargets
        public HalpBroadcastFunction, HalpBroadcastContext
HalpBroadcastLock           dd  0
HalpBroadcastFunction       dd  0
HalpBroadcastContext        dd  0
HalpBroadcastTargets        dd  0

_DATA   ends

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

    ALIGN   dword
;
;   The _PicExtintIntiHandlers and the _PicNopIntiHandlers tables are
;   used by the enable and disable system interrupt routines to determine
;   the EXTINT interrupt handler to install.
;
        public _PicExtintIntiHandlers
_PicExtintIntiHandlers   label   dword
            dd         PicInterruptHandlerInti0     ; Inti 0  - PIC 1
            dd         PicInterruptHandlerInti1     ; Inti 1  - PIC 1
            dd         PicInterruptHandlerInti2     ; Inti 2  - PIC 1
            dd         PicInterruptHandlerInti3     ; Inti 3  - PIC 1
            dd         PicInterruptHandlerInti4     ; Inti 4  - PIC 1
            dd         PicInterruptHandlerInti5     ; Inti 5  - PIC 1
            dd         PicInterruptHandlerInti6     ; Inti 6  - PIC 1
            dd         PicInterruptHandlerInti7     ; Inti 7  - PIC 1
            dd         PicInterruptHandlerInti8     ; Inti 8  - PIC 2
            dd         PicInterruptHandlerInti9     ; Inti 9  - PIC 2
            dd         PicInterruptHandlerIntiA     ; Inti 10 - PIC 2
            dd         PicInterruptHandlerIntiB     ; Inti 11 - PIC 2
            dd         PicInterruptHandlerIntiC     ; Inti 12 - PIC 2
            dd         PicInterruptHandlerIntiD     ; Inti 13 - PIC 2
            dd         PicInterruptHandlerIntiE     ; Inti 14 - PIC 2
            dd         PicInterruptHandlerIntiF     ; Inti 15 - PIC 2

        public _PicNopIntiHandlers
_PicNopIntiHandlers   label   dword
            dd         PicNopHandlerInti0     ; Inti 0  - PIC 1
            dd         PicNopHandlerInti1     ; Inti 1  - PIC 1
            dd         PicNopHandlerInti2     ; Inti 2  - PIC 1
            dd         PicNopHandlerInti3     ; Inti 3  - PIC 1
            dd         PicNopHandlerInti4     ; Inti 4  - PIC 1
            dd         PicNopHandlerInti5     ; Inti 5  - PIC 1
            dd         PicNopHandlerInti6     ; Inti 6  - PIC 1
            dd         PicNopHandlerInti7     ; Inti 7  - PIC 1
            dd         CommonPic2NopHandler   ; Inti 8  - PIC 2
            dd         CommonPic2NopHandler   ; Inti 9  - PIC 2
            dd         CommonPic2NopHandler   ; Inti 10 - PIC 2
            dd         CommonPic2NopHandler   ; Inti 11 - PIC 2
            dd         CommonPic2NopHandler   ; Inti 12 - PIC 2
            dd         PicNopHandlerIntiD     ; Inti 13 - PIC 2
            dd         CommonPic2NopHandler   ; Inti 14 - PIC 2
            dd         CommonPic2NopHandler   ; Inti 15 - PIC 2

_TEXT   ends

        page ,132
        subttl  "Post InterProcessor Interrupt"
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;
; VOID
; HalInitializeProcessor(
;       ULONG   Number
;       PVOID   LoaderBlock
;       );
;
;Routine Description:
;
;    Initialize hal pcr values for current processor (if any)
;    (called shortly after processor reaches kernel, before
;    HalInitSystem if P0)
;
;    IPI's and KeReadir/LowerIrq's must be available once this function
;    returns.  (IPI's are only used once two or more processors are
;    available)
;
;   . Enable IPI interrupt (makes sense for P1, P2, ...).
;   . Save Processor Number in PCR.
;   . if (P0)
;       . determine if the system is a PC+MP,
;       . if not a PC+MP System Halt;
;   . Enable IPI's on CPU.
;
;Arguments:
;
;    Number - Logical processor number of calling processor
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalInitializeProcessor ,2

        mov     PCR[PcIDR], 0FFFFFFFFH            ; mark all INTs as disabled

        movzx   eax, byte ptr [esp+4]
        mov     PCR[PcHal.PcrNumber], al          ; Save processor # in PCR

        mov     ecx, PCR[PcSelfPcr]               ; Flat address of this PCR
        mov     _HalpProcessorPCR[eax*4], ecx   ; Save it away

        mov     dword ptr PCR[PcStallScaleFactor], INITIAL_STALL_COUNT

        ;
        ; set bit in affinity mask for this active processor
        ;

        lock bts _HalpActiveProcessors, eax

        ;
        ; set interrupt affinity to either be most-significant processor or
        ; a set of all processors
        ;

        mov     edx, eax
        mov     eax, _HalpDefaultInterruptAffinity

hip10:  cmp     _HalpStaticIntAffinity, 1           ; Signle or all?
        sbb     ecx, ecx                            ; set mask 0 or -1
        and     ecx, eax                            ; include existing set or not
        bts     ecx, edx                            ; include self

        cmp     ecx, eax                            ; new mask a better choice?
        jc      short hip20                         ; no, done

        lock cmpxchg _HalpDefaultInterruptAffinity, ecx     ; set new mask
        jnz     short hip10                         ; if it didn't take, do it again
hip20:


        ;
        ;  Most of the following code is only needed on P0
        ;

        or      edx, edx
        jnz     PnInitCode                  ; Not P0 skip a lot

        ; Run on P0 only

        ;
        ;  Determine if the system we are on is an PC+MP
        ;
        ;  DetectMPS has a parameter we don't currently use.  It's a boolean
        ;  which is set to TRUE if the system we're on is a MP system.  Remember,
        ;  we could have a UP PC+MP system.
        ;
        ;  The DetectMPS routine also allocates Virtual Addresses for all of
        ;  the APIC's in the system (it needs to access the devices anyway so ...)
        ;

        sub     esp, 4
ifdef ACPI_HAL
        mov     eax, esp
        stdCall _DetectAcpiMP <eax, [esp + 12]> ; Are we running on an ACPI MP
else        
        stdCall _DetectMPS <esp>                ; Are we running on an PC+MP
endif        
        add     esp,4

        cmp     eax, 0                          ;  Yes (nonZero) or
        je      NotPcMp                         ;  No (Zero)

;        stdCall _HalDisplayString, <offset HalSignonString>

        ;
        ; This next call has nothing to do with processor init.
        ; But this is the only function in the HAL that gets 
        ; called before KdInit.
        ;
        stdCall _HalpRegisterKdSupportFunctions <[esp + 8]>

        mov      ax, 0FFFFH                     ; mask all PIC interrupts
        mov     _HalpGlobal8259Mask, ax         ; save the mask
        SET_8259_MASK

        ;
        ; Other P0 initialization would go here
        ;
        jmp CommonInitCode

PnInitCode:
        ;
        ; Pn initialization goes here
        ;

        mov     ecx, PCR[PcPrcb]                  ; get PRCB
        movzx   eax, byte ptr [ecx].PbHalReserved.PrcbPCMPApicID  ; get APIC id
        movzx   ecx, byte ptr [ecx].PbNumber      ; get processor number

        stdCall _HalpMarkProcessorStarted, <eax, ecx>

CommonInitCode:

        stdCall  _HalInitApicInterruptHandlers

        ;
        ; initialize the APIC local unit for this Processor
        ;

        stdCall   _HalpInitializeLocalUnit

        stdRET    _HalInitializeProcessor

NotPcMp:
        stdCall   _HalDisplayString, <offset _rgzBadHal>
        hlt

stdENDP _HalInitializeProcessor

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate

;++
;
; VOID
; HalInitApicInterruptHandlers(
;       );
;
;Routine Description:
;
;    This routine installs the interrupt vector in the IDT for the APIC
;    spurious interrupt.
;
;Arguments:
;
;    None.
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalInitApicInterruptHandlers  ,0
        enter   8,0         ; setup ebp, reserve 8 bytes of stack

        sidt    fword ptr [ebp-8]           ; get IDT address
        mov     edx, [ebp-6]                ; (edx)->IDT

        mov     ecx, PIC1_SPURIOUS_VECTOR            ; Spurious Vector
        mov     eax, offset FLAT:PicSpuriousService37
        mov     word ptr [edx+8*ecx], ax    ; Lower half of handler addr
        mov     word ptr [edx+8*ecx+2], KGDT_R0_CODE  ; set up selector
        mov     word ptr [edx+8*ecx+4], D_INT032      ; 386 interrupt gate
        shr     eax, 16                 ; (ax)=higher half of handler addr
        mov     word ptr [edx+8*ecx+6], ax

        mov     ecx, APIC_SPURIOUS_VECTOR             ; Apic Spurious Vector
        mov     eax, offset FLAT:_HalpApicSpuriousService
        mov     word ptr [edx+8*ecx], ax    ; Lower half of handler addr
        mov     word ptr [edx+8*ecx+2], KGDT_R0_CODE  ; set up selector
        mov     word ptr [edx+8*ecx+4], D_INT032      ; 386 interrupt gate
        shr     eax, 16                     ; (ax)=higher half of handler addr
        mov     word ptr [edx+8*ecx+6], ax

        leave
        stdRET _HalInitApicInterruptHandlers
stdENDP _HalInitApicInterruptHandlers

cPublicProc PicSpuriousService37  ,0
    iretd
stdENDP PicSpuriousService37

;++
;
; VOID
; HalpApicRebootService(
;       );
;
;Routine Description:
;
;   This is the ISR that handles Reboot events
;
;--

    ENTER_DR_ASSIST HReboot_a, HReboot_t
cPublicProc _HalpApicRebootService  ,0
        ENTER_INTERRUPT_FORCE_STATE HReboot_a, HReboot_t  ; (ebp) -> Trap frame

        mov     eax, APIC_REBOOT_VECTOR

        mov     ecx, dword ptr APIC[LU_TPR]     ; get the old TPR
        push    ecx                             ; save it
        mov     dword ptr APIC[LU_TPR], eax     ; set the TPR
        APICFIX edx

        ;
        ;  EOI the local APIC, warm reset does not reset the 82489 APIC
        ;  so if we don't EOI here we'll never see an interrupt after
        ;  the reboot.
        ;

        mov     dword ptr APIC[LU_EOI], 0       ; send EOI to APIC local unit

        stdCall _HalpResetThisProcessor

        ;
        ;  We should never get here, but just in case someone is stepping
        ;  through this
        ;

        pop     eax
        mov     dword ptr APIC[LU_TPR], eax     ; reset the TPR
        APICFIX edx

        ;
        ; Do interrupt exit processing without EOI
        ;

        SPURIOUS_INTERRUPT_EXIT

stdENDP _HalpApicRebootService

;++
;
; VOID
; HalpGenericCallService(
;       );
;
; Routine Description:
;   This is the ISR that handles the GenericCall interrupt
;
;--
    ENTER_DR_ASSIST HGeneric_a, HGeneric_t
cPublicProc _HalpBroadcastCallService  ,0
        ENTER_INTERRUPT HGeneric_a, HGeneric_t  ; (ebp) -> Trap frame
;
; (esp) - base of trap frame
;
; dismiss interrupt and raise Irql
;
        push    APIC_GENERIC_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall _HalBeginSystemInterrupt, <CLOCK2_LEVEL-1,APIC_GENERIC_VECTOR,esp>

        call    _HalpPollForBroadcast

        INTERRUPT_EXIT          ; lower irql to old value, iret

stdENDP _HalpBroadcastCallService

;++
;
; VOID
; HalpGenericCall(
;       IN VOID (*WorkerFunction)(VOID),
;       IN ULONG Context,
;       IN KAFFINITY TargetProcessors
;       );
;
; Routine Description:
;   Causes the WorkerFunction to be called on the specified target
;   processors.  The WorkerFunction is called at CLOCK2_LEVEL-1
;   (Must be below IPI_LEVEL in order to prevent system deadlocks).
;
; Enviroment:
;   Must be called with interrupts enabled.
;   Must be called with IRQL = CLOCK2_LEVEL-1
;--

cPublicProc _HalpGenericCall,3
cPublicFpo 3, 0

GENERIC_IPI equ (DELIVER_FIXED OR LOGICAL_DESTINATION OR ICR_USE_DEST_FIELD OR APIC_GENERIC_VECTOR)

@@:     call    _HalpPollForBroadcast
        test    HalpBroadcastLock, 1        ; Is broadcast busy?
        jnz     short @b                    ; Yes, wait

   lock bts     HalpBroadcastLock, 0        ; Try to get lock
        jc      short @b                    ; didn't get it, loop

hgc30:  mov     ecx, [esp+4]
        mov     edx, [esp+8]
        mov     eax, [esp+12]
        mov     HalpBroadcastFunction, ecx
        mov     HalpBroadcastContext, edx
        mov     HalpBroadcastTargets, eax

        or      eax, eax                    ; (eax) = Targets
        jz      gc90

        SEND_IPI  GENERIC_IPI

;
; Wait for all processors to call broadcast function
;

@@:     call    _HalpPollForBroadcast
        cmp     HalpBroadcastTargets, 0
        jnz     short @b

gc90:   mov     HalpBroadcastLock, 0        ; Release BroadcastLock
        stdRET  _HalpGenericCall

stdENDP _HalpGenericCall

;++
;
; VOID
; _HalpPollForBroadcast (
;       VOID
;       );
;
; Routine Description:
;
;   IRQL = CLOCK2_LEVEL-1
;--
cPublicProc _HalpPollForBroadcast, 0
cPublicFpo 0, 0
        mov     eax, PCR[PcSetMember]
        test    HalpBroadcastTargets, eax
        jz      short pb90

        mov     ecx, HalpBroadcastFunction  ; Pickup broadcast function
        push    HalpBroadcastContext

        not     eax                         ; Remove our bit from destionations
   lock and     HalpBroadcastTargets, eax

        call    ecx

pb90:   stdRET  _HalpPollForBroadcast

stdENDP _HalpPollForBroadcast

;++
;
; ULONG
; FASTCALL
; HalpWaitForPending (
;       ULONG   Count   (ecx)
;       PULONG  LuICR   (edx)
;       );
;
; Routine Description:
;
;   Waits for DELIVERY_PENDING to clear and returns remaining iteration count
;--
cPublicFastCall HalpWaitForPending, 2
cPublicFpo 0, 0

wfp10:  test    dword ptr [edx], DELIVERY_PENDING
        jz      short wfp20

        dec     ecx
        jnz     short wfp10

wfp20:  mov     eax, ecx
        fstRet  HalpWaitForPending

fstENDP HalpWaitForPending


;++
;
; VOID
; HalpLocalApicErrorService(
;       );
;
;Routine Description:
;
;   This routine fields Local APIC error Events
;
;--

    ENTER_DR_ASSIST HApicErr_a, HApicErr_t

cPublicProc _HalpLocalApicErrorService  ,0

;
; Save machine state in trap frame
;

    ENTER_INTERRUPT HApicErr_a, HApicErr_t  ; (ebp) -> Trap frame

if LogApicErrors

        lea     ecx, _HalpLocalApicErrorLock
        fstCall HalpAcquireHighLevelLock
        push    eax

        mov     eax, _HalpLocalApicErrorCount
        inc     _HalpLocalApicErrorCount

        lea     ecx, _HalpApicErrorLog

        and     eax, APIC_ERROR_LOG_SIZE-1
        shl     eax, 1
        add     ecx, eax

endif ; LogApicErrors

        mov     dword ptr APIC[LU_EOI], 0   ; local unit EOI
        APICFIX eax

        ;
        ;  The Apic EDS (Rev 4.0) says you have to write before you read
        ;  this doesn't work.  The write clears the status bits.
        ;  But P6 works as according to the EDS!
        ;

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbCpuType, 6
        jc      short lae10
        mov     dword ptr APIC[LU_ERROR_STATUS], 0

lae10:
        mov     eax, dword ptr APIC[LU_ERROR_STATUS] ; read error status


        ; Find out what kind of error it is and update the appropriate count.

if LogApicErrors
;    out     80h, al
        mov     byte ptr [ecx], al
        inc     ecx
        mov     al,  byte ptr PCR[PcHal.PcrNumber]
        mov     byte ptr [ecx], al

        lea     ecx, _HalpLocalApicErrorLock
        pop     edx
        fstCall HalpReleaseHighLevelLock

endif ; LogApicErrors

        SPURIOUS_INTERRUPT_EXIT     ; exit interrupt without eoi
stdENDP _HalpLocalApicErrorService

        page ,132
        subttl  "PC+MP IPI Interrupt Handler"
;++
;
; VOID
; HalpIpiHandler (
;    );
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by inter
;    processor communication.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST Hipi_a, Hipi_t

cPublicProc  _HalpIpiHandler    ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hipi_a, Hipi_t  ; (ebp) -> Trap frame

;
; Save previous IRQL
;
        push    APIC_IPI_VECTOR             ; Vector
        sub     esp, 4                      ; space for OldIrql
;
; We now dismiss the interprocessor interrupt and call its handler
;

        stdCall _HalBeginSystemInterrupt,<IPI_LEVEL,APIC_IPI_VECTOR,esp>

        stdCall _KiIpiServiceRoutine, <ebp,0>

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT                      ; will return to caller

stdENDP _HalpIpiHandler

;++
;
; VOID
; HalpApicSpuriousService(
;       );
;
;Routine Description:
;
;   A place for spurious interrupts to end up.
;
;--
cPublicProc _HalpApicSpuriousService,0
        iretd
stdENDP _HalpApicSpuriousService


;++
;
; VOID
; _PicInterruptHandlerIntiXX(
;       );
;
;Routine Description:
;
;   These handlers receive interrupts from the PIC and reissues them via
;   a vector at the proper priority level.  This is used to provide a symetric
;   interrupt distribution on a non symetric system.
;
;   The PIC interrupts will normally only be received (in the PC+MP Hal) via an
;   interrupt input from on either the IO Unit or the Local unit which has been
;   programed as EXTINT.  EXTINT interrupts are received outside of the APIC
;   priority structure (the PIC provides the vector).  We use the APIC ICR to
;   generate interrupts to the proper handler at the proper priority.
;
;   The EXTINT interrupts are directed to a single processor, currently P0.
;   There is no good reason why they can't be directed to another processor.
;
;   Since one processor must absorb the overhead of redistributing PIC interrupts
;   the interrupt handling on a system using EXTINT interrupts is not symetric.
;
;--

        ENTER_DR_ASSIST Hcpic_a, Hcpic_t

cPublicProc PicHandler  ,0

PicInterruptHandlerInti0:
        push    0
        jmp     short CommonPicHandler

PicInterruptHandlerInti1:
        push    1
        jmp     short CommonPicHandler

PicInterruptHandlerInti2:
        push    2
        jmp     short CommonPicHandler

PicInterruptHandlerInti3:
        push    3
        jmp     short CommonPicHandler

PicInterruptHandlerInti4:
        push    4
        jmp     short CommonPicHandler

PicInterruptHandlerInti5:
        push    5
        jmp     short CommonPicHandler

PicInterruptHandlerInti6:
        push    6
        jmp     short CommonPicHandler

PicInterruptHandlerInti7:
;
; Check to see if this is a spurious interrupt
;
        push    eax
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        pop     eax
        jz      short pic7_spurious     ;

        push    7
        jmp     short CommonPicHandler

picf_spurious:
        mov     al, OCW2_SPECIFIC_EOI OR SlavePicInti   ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al
        pop     eax
pic7_spurious:
        iretd                           ; ignore PIC

PicInterruptHandlerInti8:
        push    8
        jmp     short CommonPicHandler

PicInterruptHandlerInti9:
        push    9
        jmp     short CommonPicHandler

PicInterruptHandlerIntiA:
        push    10
        jmp     short CommonPicHandler

PicInterruptHandlerIntiB:
        push    11
        jmp     short CommonPicHandler

PicInterruptHandlerIntiC:
        push    12
        jmp     short CommonPicHandler

PicInterruptHandlerIntiD:
        push    13
        push    eax
        xor     eax, eax
        out     I386_80387_BUSY_PORT, al
        pop     eax
        jmp     short CommonPicHandler

PicInterruptHandlerIntiE:
        push    14
        jmp     short CommonPicHandler

PicInterruptHandlerIntiF:
        push    eax
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jz      short picf_spurious     ; Go eoi PIC1 & Ignore PIC2

        pop     eax
        push    15
        jmp     short CommonPicHandler

CommonPicHandler:
        ENTER_INTERRUPT Hcpic_a, Hcpic_t,PassDwordParm ; (ebp) -> Trap frame

;
;  Need to determine if we have a level interrupt and if so don't EOI it
;  It should be EOI'd by end system interrupt
;

        cmp     bl, 8                           ; Pic or Slave Pic
        jae     short cph20

        mov     al, bl
        or      al, OCW2_SPECIFIC_EOI           ; specific eoi
        out     PIC1_PORT0, al                  ; dismiss the interrupt
        jmp     short cph30

cph20:
        mov     al, OCW2_NON_SPECIFIC_EOI               ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, OCW2_SPECIFIC_EOI OR SlavePicInti   ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al                          ; send irq2 specific eoi to master

cph30:
        mov     al, _HalpPICINTToVector[ebx]    ; Get vector for PIC interrupt
        or      al, al                          ; Is vector known?
        jz      short cph90                     ; No, don't dispatch it

;
;  Now gain exclusive access to the ICR
;

        STALL_WHILE_APIC_BUSY

        cmp     bl, 8
        je      short HandleClockInti

;
; Write the IPI Command to the Memory Mapped Register
;

        mov     dword ptr APIC[LU_INT_CMD_HIGH], DESTINATION_ALL_CPUS
        APICFIX edx
        mov     dword ptr APIC[LU_INT_CMD_LOW], eax
        jmp     short cph90


HandleClockInti:
;
; Write the IPI Command to the Memory Mapped Register
;

        mov     dword ptr APIC[LU_INT_CMD_LOW], (DELIVER_FIXED OR ICR_SELF OR APIC_CLOCK_VECTOR)


cph90:  APICFIX edx
        SPURIOUS_INTERRUPT_EXIT     ; exit interrupt without eoi

stdENDP PicHandler


;++
;
; VOID
; _PicXXNopHandler(
;       );
;
;Routine Description:
;
;   These handlers are designed to be installed on a system to field any PIC
;   interrupts when there are not supposed to be any delivered.
;
;   In the Debug case this routine increments an error count EOI's the PIC and
;   returns.  Normally the increment is not performed.
;--



cPublicProc PicNopHandler ,0

PicNopHandlerInti0:
        push    eax                                 ; Save Scratch Registers
        mov     al, 0
        jmp     short CommonPic1NopHandler

PicNopHandlerInti1:
        push    eax                                 ; Save Scratch Registers
        mov     al, 1
        jmp     short CommonPic1NopHandler

PicNopHandlerInti2:
        push    eax                                 ; Save Scratch Registers
        mov     al, 2
        jmp     short CommonPic1NopHandler

PicNopHandlerInti3:
        push    eax                                 ; Save Scratch Registers
        mov     al, 3
        jmp     short CommonPic1NopHandler

PicNopHandlerInti4:
        push    eax                                 ; Save Scratch Registers
        mov     al, 4
        jmp     short CommonPic1NopHandler

PicNopHandlerInti5:
        push    eax                                 ; Save Scratch Registers
        mov     al, 5
        jmp     short CommonPic1NopHandler

PicNopHandlerInti6:
        push    eax                                 ; Save Scratch Registers
        mov     al, 6
        jmp     short CommonPic1NopHandler

PicNopHandlerInti7:
        push    eax                                 ; Save Scratch Registers
        mov     al, 7

CommonPic1NopHandler:
    ;
    ;  Need to determine if we have a level interrupt and if so don't EOI it
    ;  It should be EOI'd by end system interrupt
    ;

        or      al, OCW2_SPECIFIC_EOI                   ; specific eoi
        out     PIC1_PORT0, al                          ; dismiss the interrupt
        pop     eax                                     ; Restore Scratch registers
        iretd

PicNopHandlerIntiD:
        push    eax
        xor     eax, eax
        out     I386_80387_BUSY_PORT, al
        pop     eax

CommonPic2NopHandler:
        push    eax

;
;  Need to determine if we have a level interrupt and if so don't EOI it
;  It should be EOI'd by end system interrupt
;

        mov     al, OCW2_NON_SPECIFIC_EOI               ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, OCW2_SPECIFIC_EOI OR SlavePicInti   ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al                          ; send irq2 specific eoi to master
        pop     eax
        iretd

stdENDP PicNopHandler


_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
;
; Module Name:
;
;    mpirql.asm
;
; Abstract:
;
;    This module implements the mechanism for raising and lowering IRQL
;    and dispatching software interrupts for PC+MP compatible systems
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Ron Mosgrove (Intel) Sept 1993
;        Modified for PC+MP
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                ; calling convention macros
include mac386.inc
include apic.inc
include ntapic.inc
include i386\kimacro.inc
        .list

        EXTRNP  _KeBugCheck,1,IMPORT

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        align   dword

;
; Global8259Mask is used to avoid reading the PIC to get the current
; interrupt mask; format is the same as for SET_8259_MASK, i.e.,
; bits 7:0 -> PIC1, 15:8 -> PIC2
;
        public  _HalpGlobal8259Mask
_HalpGlobal8259Mask     dw      0

_DATA ends

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

;
; IOunitRedirectionTable is the memory image of the redirection table to be
; loaded into APIC I/O unit 0 at initialization.  there is one 64-bit entry
; per interrupt input to the I/O unit.  the edge/level trigger mode bit will
; be set dynamically when the table is actually loaded.  the mask bit is set
; initially, and reset by EnableSystemInterrupt.
;

;
; _HalpIRQLtoTPR maps IRQL to an APIC TPR register value
;
                align   dword
                public  _HalpIRQLtoTPR
_HalpIRQLtoTPR  label   byte
                db      ZERO_VECTOR             ; IRQL 0
                db      APC_VECTOR              ; IRQL 1
                db      DPC_VECTOR              ; IRQL 2
                db      DPC_VECTOR              ; IRQL 3
                db      DEVICE_LEVEL1           ; IRQL 4
                db      DEVICE_LEVEL2           ; IRQL 5
                db      DEVICE_LEVEL3           ; IRQL 6
                db      DEVICE_LEVEL4           ; IRQL 7
                db      DEVICE_LEVEL5           ; IRQL 8
                db      DEVICE_LEVEL6           ; IRQL 9
                db      DEVICE_LEVEL7           ; IRQL 10
                db      DEVICE_LEVEL7           ; IRQL 11
                db      DEVICE_LEVEL7           ; IRQL 12
                db      DEVICE_LEVEL7           ; IRQL 13
                db      DEVICE_LEVEL7           ; IRQL 14
                db      DEVICE_LEVEL7           ; IRQL 15
                db      DEVICE_LEVEL7           ; IRQL 16
                db      DEVICE_LEVEL7           ; IRQL 17
                db      DEVICE_LEVEL7           ; IRQL 18
                db      DEVICE_LEVEL7           ; IRQL 19
                db      DEVICE_LEVEL7           ; IRQL 20
                db      DEVICE_LEVEL7           ; IRQL 21
                db      DEVICE_LEVEL7           ; IRQL 22
                db      DEVICE_LEVEL7           ; IRQL 23
                db      DEVICE_LEVEL7           ; IRQL 24
                db      DEVICE_LEVEL7           ; IRQL 25
                db      DEVICE_LEVEL7           ; IRQL 26
                db      APIC_GENERIC_VECTOR     ; IRQL 27
                db      APIC_CLOCK_VECTOR       ; IRQL 28
                db      APIC_IPI_VECTOR         ; IRQL 29
                db      POWERFAIL_VECTOR        ; IRQL 30
                db      NMI_VECTOR              ; IRQL 31

_TEXT ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; VECTOR_MAP_ENTRY macro generates sparse table required for APIC vectors
;

VECTOR_MAP_ENTRY    macro   vector_number, apic_inti
            current_entry = $ - _HalpVectorToINTI
            entry_count = vector_number - current_entry
                REPT    entry_count
                dw      0ffffh
                ENDM
            dw      apic_inti

            endm

;
; _HalpVectorToINTI maps interrupt vector to EISA interrupt level
; (APIC INTI input);
; NOTE:  this table must ordered by ascending vector numbers
; also note that there is no entry for unused INTI13.
;

                align   dword
                public  _HalpVectorToINTI
_HalpVectorToINTI       label   word
        VECTOR_MAP_ENTRY      NMI_VECTOR, 0FFFFh
        VECTOR_MAP_ENTRY      (1+MAX_NODES)*100h-1, 0FFFFh      ; End of Table

;
; _HalpVectorToIRQL maps interrupt vector to NT IRQLs
; NOTE:  this table must ordered by ascending vector numbers
;

VECTORTOIRQL_ENTRY    macro   idt_entry, irql
            current_entry = $ - _HalpVectorToIRQL
            priority_number = (idt_entry/16)
            entry_count = priority_number - current_entry
                REPT    entry_count
                db      0FFh
                ENDM
            db      irql

            endm

                align   dword
                public  _HalpVectorToIRQL
_HalpVectorToIRQL       label   byte
        VECTORTOIRQL_ENTRY    ZERO_VECTOR,         0 ; placeholder
        VECTORTOIRQL_ENTRY    APC_VECTOR,          APC_LEVEL
        VECTORTOIRQL_ENTRY    DPC_VECTOR,          DISPATCH_LEVEL
        VECTORTOIRQL_ENTRY    APIC_GENERIC_VECTOR, PROFILE_LEVEL
        VECTORTOIRQL_ENTRY    APIC_CLOCK_VECTOR,   CLOCK1_LEVEL
        VECTORTOIRQL_ENTRY    APIC_IPI_VECTOR,     IPI_LEVEL
        VECTORTOIRQL_ENTRY    POWERFAIL_VECTOR,    POWER_LEVEL

_DATA   ENDS

        page ,132
        subttl  "Raise Irql"

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; KIRQL
; FASTCALL
; KfRaiseIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    The APIC TPR is used to block all lower-priority HW interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0,0

        movzx   edx, cl                         ; (edx) = New Irql
        movzx   ecx, byte ptr _HalpIRQLtoTPR[edx] ; get TPR value for IRQL
        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority
        mov     dword ptr APIC[LU_TPR], ecx     ; Write New Priority to the TPR

;
; get IRQL for Old Priority, and return it
;
        shr     eax, 4
        movzx   eax, _HalpVectorToIRQL[eax]   ; (al) = OldIrql
        fstRET  KfRaiseIrql

fstENDP KfRaiseIrql


;++
;
; VOID
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;    The APIC TPR is used to block all lower-priority HW interrupts.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        mov     edx, dword ptr APIC[LU_TPR]         ; (ecx) = Old Priority
        mov     dword ptr APIC[LU_TPR], DPC_VECTOR  ; Set New Priority
        shr     edx, 4
        movzx   eax, _HalpVectorToIRQL[edx]         ; (al) = OldIrql
        stdRET  _KeRaiseIrqlToDpcLevel

stdENDP _KeRaiseIrqlToDpcLevel


;++
;
; VOID
; KIRQL
; KeRaiseIrqlToSyncLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;    The APIC TPR is used to block all lower-priority HW interrupts.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0
cPublicFpo 0, 0

        mov     edx, dword ptr APIC[LU_TPR]     ; (ecx) = Old Priority
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR ; Write New Priority

        shr     edx, 4
        movzx   eax, _HalpVectorToIRQL[edx]     ; (al) = OldIrql
        stdRET  _KeRaiseIrqlToSynchLevel

stdENDP _KeRaiseIrqlToSynchLevel


        page ,132
        subttl  "Lower irql"
;++
;
; VOID
; FASTCALL
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--

; equates for accessing arguments
;

cPublicFastCall KfLowerIrql    ,1
cPublicFpo 0,0

        xor     eax, eax
        mov     al, cl              ; get new irql value

if DBG
;
; Make sure we are not lowering to ABOVE current level
;

        mov     ecx, dword ptr APIC[LU_TPR]     ; (ebx) = Old Priority
        shr     ecx, 4
        movzx   ecx, _HalpVectorToIRQL[ecx]     ; get IRQL for Old Priority
        cmp     al, cl
        jbe     short KliDbg
        push    ecx                             ; new irql for debugging
        push    eax                             ; old irql for debugging
        stdCall   _KeBugCheck, <IRQL_NOT_LESS_OR_EQUAL>
KliDbg:
endif
        xor     ecx, ecx                        ; Avoid a partial stall
        mov     cl, _HalpIRQLtoTPR[eax]         ; get TPR value corresponding to IRQL
        mov     dword ptr APIC[LU_TPR], ecx

;
; We have to ensure that the requested priority is set before
; we return.  The caller is counting on it.
;
        mov     eax, dword ptr APIC[LU_TPR]

if DBG
        cmp     ecx, eax                        ; Verify IRQL read back is same as
        je      short @f                        ; set value
        int 3
@@:
endif
        fstRET  KfLowerIrql
fstENDP KfLowerIrql

        page ,132
        subttl  "Get current irql"
;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority
        shr     eax, 4
        movzx   eax, _HalpVectorToIRQL[eax]     ; get IRQL for Old Priority
        stdRET    _KeGetCurrentIrql

stdENDP _KeGetCurrentIrql



;++
;
; KIRQL
; HalpDisableAllInterrupts (VOID)
;
; Routine Description:
;
;   This routine is called during a system crash.  The hal needs all
;   interrupts disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Old IRQL value.
;
;--

cPublicProc _HalpDisableAllInterrupts,0

    ;
    ; Raising to HIGH_LEVEL
    ;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql
        stdRET  _HalpDisableAllInterrupts

stdENDP _HalpDisableAllInterrupts

;++
;
; VOID
; HalpReenableInterrupts (
;     IN KIRQL Irql
;     )
;
; Routine Description:
;
;   Restores irql level.
;
; Arguments:
;
;    Irql - Irql state to restore to.
;
; Return Value:
;
;    None
;
;--

HriNewIrql      equ     [esp + 4]

cPublicProc _HalpReenableInterrupts,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HriNewIrql
        fstCall KfLowerIrql

        stdRET  _HalpReenableInterrupts

stdENDP _HalpReenableInterrupts

_TEXT   ends

PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; PIC initialization command strings - first word is port to write to,
; followed by bytes of Initialization Control Words (ICWs) and Operation
; Control Words (OCWs).  Last string is zero-terminated.
;

PICsInitializationString   label    byte
;
; Master PIC initialization commands
;
                dw      PIC1_PORT0
                db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 + \
                        ICW1_CASCADE + ICW1_ICW4_NEEDED
                db      PIC1_BASE
                db      1 SHL PIC_SLAVE_IRQ
                db      ICW4_NOT_SPEC_FULLY_NESTED + \
                        ICW4_NON_BUF_MODE + \
                        ICW4_NORM_EOI + \
                        ICW4_8086_MODE
PIC1InitMask    db      0FFh            ; OCW1 - mask all inputs
;
; Slave PIC initialization commands
;
                dw      PIC2_PORT0
                db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 + \
                        ICW1_CASCADE + ICW1_ICW4_NEEDED
                db      PIC2_BASE
                db      PIC_SLAVE_IRQ
                db      ICW4_NOT_SPEC_FULLY_NESTED + \
                        ICW4_NON_BUF_MODE + \
                        ICW4_NORM_EOI + \
                        ICW4_8086_MODE
PIC2InitMask    db      0FFh            ; OCW1 - mask all inputs
                dw      0               ; end of string


        page ,132
        subttl  "Interrupt Controller Chip Initialization"
;++
;
; VOID
; HalpInitializePICs (
;    BOOLEAN EnableInterrupts
;    )
;
; Routine Description:
;
;    This routine initializes the interrupt structures for the 8259A PIC.
;
; Context:
;
;    This procedure is executed by CPU 0 during Phase 0 initialization.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
EnableInterrupts equ [esp + 0ch]

cPublicProc _HalpInitializePICs       ,1

        push    esi                             ; save caller's esi
        pushfd
        cli                                     ; disable interrupt

        lea     esi, PICsInitializationString
        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        outsb                                   ; output OCW1 (mask register)
        IODelay
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

        mov     al, PIC2InitMask                ; save the initial mask in
        shl     ax, 8                           ; mask in global variable
        mov     al, PIC1InitMask
        mov     _HalpGlobal8259Mask, ax

        mov     al, EnableInterrupts
        .if     (al != 0)
        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts
        .endif
        popfd
        pop     esi                             ; restore caller's esi
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs

PAGELK  ends
       end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpipic.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpipic.c

Abstract:

    This module provides the HAL support for interprocessor interrupts and
    processor initialization for MPS systems.

Author:

    Forrest Foltz (forrestf) 27-Oct-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#if defined(APIC_HAL)

#if !defined(_MPIPIC_C_)
#define _MPIPIC_C_

#pragma optimize("Oxt2b2",on)

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"

#if !defined(LOCAL_APIC)

//
// Temporary defines.  These definitions are found in common header files in
// the private hal branch.
// 

#define LOCAL_APIC(x) (*((ULONG volatile *)&pLocalApic[(x)/sizeof(ULONG)]))

/*++

HalpStallWhileApicBusy (
    VOID
    )

Routine Description:

    This routine waits until the local apic has completed sending
    an IPI.

Parameters:

    None.

Return Value:

    None.

--*/

#define HalpStallWhileApicBusy() \
    while (((LOCAL_APIC(LU_INT_CMD_LOW) & DELIVERY_PENDING) != 0)){}

#endif  // LOCAL_APIC

//
// HalpIpiTargetLookup[] and HalpIpiTargetMask[] are tables used by
// HalpSendNodeIpi() and are initialized by HalpBuildIpiDestinationMap().
//
// They assist in performing the translation between a (32- or 64- bit)
// KAFFINITY into a 64-bit Node Target Set.
//
// Each element of HalpIpiTargetLookup[] contains the logical sum of
// the 8 (or 4) Node Target Sets for a particular byte value.  Each
// element of HalpIpiTargetMask[] contains the mask of all possible
// APIC targets for a particular byte position with KAFFINITY.
//
// For example: Suppose one wished to determine the set of APIC targets
// for affinity 0x00000000b7000000.
//
// First, find the value of HalpIpiTargetLookup[0xb7].  This represents the set
// of APIC targets for the affinity 0xb7b7b7b7b7b7b7b7.
//
// Next, mask the value with HalpIpiTargetMask[3].  The 3 represents the byte
// number within the KAFFINITY.
//
// The result of the operation will yield the set of APIC targets that
// correspond to an affinity of 0x00000000b7000000.
//

ULONG64 HalpIpiTargetLookup[256];
ULONG64 HalpIpiTargetMask[sizeof(KAFFINITY)];

//
// Local function prototypes and types.  There are up to three versions of
// the send IPI code, depending on whether the apic topology is flat, cluster
// with 8 or fewer nodes, or cluster with more than 8 nodes.
// 

VOID
FASTCALL
HalpSendFlatIpi (
    IN KAFFINITY Affinity,
    IN ULONG Command
    );

VOID
FASTCALL
HalpSendNodeIpi32 (
    IN KAFFINITY Affinity,
    IN ULONG Command
    );

VOID
FASTCALL
HalpSendNodeIpi64 (
    IN KAFFINITY Affinity,
    IN ULONG Command
    );

VOID (FASTCALL *HalpIpiRoutine) (
    IN KAFFINITY Affinity,
    IN ULONG Command
    );

//
// External data
//

extern INTERRUPT_DEST HalpIntDestMap[MAX_PROCESSORS];



//
// Implementation
//

__forceinline
VOID
HalpSendIpiWorker (
    IN UCHAR TargetSet,
    IN ULONG Command
    )

/*++

Routine Description:

    This routine is called to send an IPI command to a set of processors
    on a single node.

Parameters:

    TargetSet - Specifies the processor identifiers within the node.

    Command - Specifies the IPI command to send.

Return Value:

    None.

--*/

{
    ULONG destination;

    //
    // Only high byte of the destination is used.  Wait until the Apic is
    // not busy before sending.  Continue without waiting, there will be
    // another wait after all IPIs have been submitted.
    // 

    destination = (ULONG)TargetSet << DESTINATION_SHIFT;

    HalpStallWhileApicBusy();
    LOCAL_APIC(LU_INT_CMD_HIGH) = destination;
    LOCAL_APIC(LU_INT_CMD_LOW) = Command;
}


VOID
FASTCALL
HalpSendFlatIpi (
    IN KAFFINITY Affinity,
    IN ULONG Command
    )

/*++

Routine Description:

    This routine is called to send an IPI command to a set of processors.  This
    routine is invoked when we have a maximum of 8 processors and the APICs have
    been set up in "flat" mode.

Parameters:

    TargetSet - Specifies the processor identifiers.

    Command - Specifies the IPI command to send.

Return Value:

    None.

--*/

{
    HalpSendIpiWorker((UCHAR)Affinity,Command);
    HalpStallWhileApicBusy();
}

VOID
FASTCALL
HalpSendIpi (
    IN KAFFINITY Affinity,
    IN ULONG Command
    )

/*++

Routine Description:

    This routine disables interrupts, dispatches to the correct IPI send
    routine, and restores interrupts.

Parameters:

    Affinity - Specifies the set of processors to receive the IPI.

    Command - Specifies the IPI command to send.

Return Value:

    None.

--*/

{
    ULONG flags;

    //
    // Disable interrupts and call the appropriate routine.
    //
    // BUGBUG the compiler generates terrible code for this,
    // most likely because of the inline _asm{} block generated
    // by HalpDisableInterrupts().
    //
    // Ideally we could talk the x86 compiler team into giving
    // us an intrinsic like the AMD64 compiler's __getcallerseflags()
    // 

    flags = HalpDisableInterrupts();
    HalpIpiRoutine(Affinity,Command);
    HalpRestoreInterrupts(flags);
}

#define APIC_IPI (DELIVER_FIXED | LOGICAL_DESTINATION | ICR_USE_DEST_FIELD | APIC_IPI_VECTOR)
#define APIC_BROADCAST_EXCL \
    (DELIVER_FIXED | LOGICAL_DESTINATION | ICR_ALL_EXCL_SELF | APIC_IPI_VECTOR)

#define APIC_BROADCAST_INCL \
    (DELIVER_FIXED | LOGICAL_DESTINATION | ICR_ALL_INCL_SELF | APIC_IPI_VECTOR)

VOID
HalRequestIpi (
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

Requests an interprocessor interrupt

Arguments:

Affinity - Supplies the set of processors to be interrupted

Return Value:

None.

--*/

{

    ULONG flags;
    KAFFINITY Self;

    //
    // If the target set of processors is the complete set of processors,
    // then use the broadcast capability of the APIC. Otherwise, send the
    // IPI to the individual processors.
    //

    Self = KeGetCurrentPrcb()->SetMember;
    if ((Affinity | Self) == HalpActiveProcessors) {
        flags = HalpDisableInterrupts();
        HalpStallWhileApicBusy();
        if ((Affinity & Self) != 0) {
            LOCAL_APIC(LU_INT_CMD_LOW) = APIC_BROADCAST_INCL;

        } else {
            LOCAL_APIC(LU_INT_CMD_LOW) = APIC_BROADCAST_EXCL;
        }

        HalpStallWhileApicBusy();
        HalpRestoreInterrupts(flags);

    } else {
        HalpSendIpi(Affinity, APIC_IPI);
    }

    return;
}

VOID
HalpBuildIpiDestinationMap (
    VOID
    )

/*++

Routine Description

    This routine is called whenever a new processor comes on line, just
    after its APIC is initialized.  It (re)builds the lookup tables that
    are used by HalpSendNodeIpi{32|64}.

    This code isn't particularly fast, and doesn't need to be - it is
    executed once per processor during boot.

Arguments:

    None:

 Return Value:

    None

--*/
{

    ULONG byteNumber;
    ULONG index;
    ULONG mask;
    ULONG processor;
    ULONG64 targetMap;
    ULONG64 targetMapSum;

    if (HalpMaxProcsPerCluster == 0) {

        //
        // Running in flat mode.  IPIs are sent by the flat mode routine.
        // 

        HalpIpiRoutine = HalpSendFlatIpi;
        return;
    }

    //
    // Build HalpIpiTargetLookup[] and HalpIpiTargetMask[] according to
    // the contents of HalpIntDestMap[].  If an additional processor is
    // added, this routine can be safely called again assuming the topology
    // of the existing processors has not changed.
    // 

    for (byteNumber = 0; byteNumber < sizeof(KAFFINITY); byteNumber++) {

        targetMapSum = 0;
        for (index = 0; index < 256; index++) {

            processor = byteNumber * 8;
            mask = index;
            while (mask != 0) {

                if ((mask & 0x1) != 0) {
                    targetMap = HalpIntDestMap[processor].Cluster.Hw.DestId;
                    targetMap <<=
                        (HalpIntDestMap[processor].Cluster.Hw.ClusterId * 4);

                    HalpIpiTargetLookup[index] |= targetMap;
                    targetMapSum |= targetMap;
                }

                processor += 1;
                mask >>= 1;
            }
        }

        HalpIpiTargetMask[byteNumber] = targetMapSum;
    }

#if defined(_AMD64_)

    HalpIpiRoutine = HalpSendNodeIpi64;

#else

    //
    // Determine which of the two IPI cluster send routines to invoke
    // depending on the maximum node ID.
    //

    HalpIpiRoutine = HalpSendNodeIpi32;
    for (processor = 0; processor < MAX_PROCESSORS; processor += 1) {
        if (HalpIntDestMap[processor].Cluster.Hw.ClusterId > 7) {
            HalpIpiRoutine = HalpSendNodeIpi64;
            break;
        }
    }

#endif

}

#if !defined(_AMD64_)

//
// Here, two versions of HalpSendNodeIpi are compiled.  The first,
// HalpSendNodeIpi32(), is used when we have a maximum of 8 APIC
// nodes.  On a 32-bit processor, it is significantly faster because
// it uses 32-bit lookup, mask and shift operations.
//

#define HalpSendNodeIpi HalpSendNodeIpi32
#define TARGET_MASK ULONG
#include "mpipic.c"

#undef HalpSendNodeIpi
#undef TARGET_MASK

#endif

//
// Here the 64-bit version of HalpSendNodeIpi64 is created.  On a
// 32-bit processor, this is used when we have more than 8 APIC
// nodes.  It is the only multi-node routine on a 64-bit platform.
// 

#define HalpSendNodeIpi HalpSendNodeIpi64
#define TARGET_MASK ULONG64
#include "mpipic.c"

#pragma optimize("",on)

#else   // _MPIPIC_C_

//
// This portion of the module is included at least once (see above) in
// order to build HalpSendNodeIpi32() and/or HalpSendNodeIpi64().
// 

VOID
FASTCALL
HalpSendNodeIpi (
    IN KAFFINITY Affinity,
    IN ULONG Command
    )

/*++

Routine Description:

    This routine sends one or more IPIs to APIC nodes.  This code generates
    two forms of this routine - HalpSendNodeIpi32() and HalpSendNodeIpi64() -
    based on whether we have more than 8 APIC nodes or not.

Parameters:

    Affinity - Specifies the set of processors to receive the IPI.

    Command - Specifies the IPI command to send.

Return Value:

    None.

--*/

{
    KAFFINITY affinity;
    UCHAR clusterIndex;
    ULONG byteNumber;
    TARGET_MASK targetMap;
    TARGET_MASK targetMapSum;
    ULONG64 *targetMask;
    UCHAR logicalId;
    ULONG mapIndex;

    //
    // Affinity has some number of target processors indicated.  Each
    // target processor is a member of a cluster of processors, or "node".
    //
    // Build targetMap by processing Affinity one byte at a time.  This
    // loop executes a maximum of sizeof(KAFFINITY) times.
    //

    affinity = Affinity;
    targetMask = HalpIpiTargetMask;
    targetMapSum = 0;
    do {

        mapIndex = (UCHAR)affinity;
        if (mapIndex != 0) {
            targetMap = (TARGET_MASK)HalpIpiTargetLookup[mapIndex];
            targetMap &= (TARGET_MASK)*targetMask;
            targetMapSum |= targetMap;
        }

        targetMask += 1;
        affinity >>= 8;

    } while (affinity != 0);

    //
    // targetMap is an array of 4-bit node-relative target masks.
    // Process the array, sending an IPI to each non-zero element.
    //
    // This loop executes a maximum of sizeof(TARGET_MASK) times.
    //

    clusterIndex = 0;
    do {

        //
        // Determine whether any APICs in this node
        // are targeted, and send an IPI to the node
        // if so.
        //

        logicalId = (UCHAR)targetMapSum & 0x0F;
        if (logicalId != 0) {
            logicalId |= clusterIndex;
            HalpSendIpiWorker(logicalId,Command);
        }

        //
        // Shift the APIC targets for the next node into place, increment
        // the cluster ID, and continue processing if there are still
        // APIC targets remaining.
        //

        targetMapSum >>= 4;
        clusterIndex += 0x10;

    } while (targetMapSum != 0);

    //
    // Wait for the APIC to process the final IPI.
    //

    HalpStallWhileApicBusy();
}

#endif  // _MPIPIC_C_

#endif  // APIC_HAL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mppciint.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpciint.c

Abstract:

    All PCI bus interrupt mapping is in this module, so that a real
    system which doesn't have all the limitations which PC PCI
    systems have can replaced this code easly.
    (bus memory & i/o address mappings can also be fix here)

Author:

    Ken Reneris

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "pcmp_nt.inc"

volatile ULONG PCIType2Stall;
extern struct HalpMpInfo HalpMpInfoTable;
extern BOOLEAN HalpHackNoPciMotion;
extern BOOLEAN HalpDoingCrashDump;

VOID
HalpPCIPin2MPSLine (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

VOID
HalpPCIBridgedPin2Line (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

VOID
HalpPCIMPSLine2Pin (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

NTSTATUS
HalpGetFixedPCIMPSLine (
    IN PBUS_HANDLER      BusHandler,
    IN PBUS_HANDLER      RootHandler,
    IN PCI_SLOT_NUMBER  PciSlot,
    OUT PSUPPORTED_RANGE *Interrupt
    );

BOOLEAN
HalpMPSBusId2NtBusId (
    IN UCHAR                ApicBusId,
    OUT PPCMPBUSTRANS       *ppBusType,
    OUT PULONG              BusNo
    );

ULONG
HalpGetPCIBridgedInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpSubclassPCISupport)
#pragma alloc_text(INIT, HalpMPSPCIChildren)
#pragma alloc_text(PAGE, HalpGetFixedPCIMPSLine)
#pragma alloc_text(PAGE, HalpGetPCIBridgedInterruptVector)
#pragma alloc_text(PAGE, HalpIrqTranslateRequirementsPci)
#pragma alloc_text(PAGE, HalpIrqTranslateResourcesPci)
#endif


//
// Turn PCI pin to inti via the MPS spec
// (note: pin must be non-zero)
//

#define PCIPin2Int(Slot,Pin)                                                \
                     ((((Slot.u.bits.DeviceNumber << 2) | (Pin-1)) != 0) ?  \
                      (Slot.u.bits.DeviceNumber << 2) | (Pin-1) : 0x80);

#define PCIInt2Pin(interrupt)                                               \
            ((interrupt & 0x3) + 1)

#define PCIInt2Slot(interrupt)                                              \
            ((interrupt  & 0x7f) >> 2)


VOID
HalpSubclassPCISupport (
    PBUS_HANDLER        Handler,
    ULONG               HwType
    )
{
    ULONG               d, pin, i, MaxDeviceFound;
    PPCIPBUSDATA        BusData;
    PCI_SLOT_NUMBER     SlotNumber;
    BOOLEAN             DeviceFound;


    BusData = (PPCIPBUSDATA) Handler->BusData;
    SlotNumber.u.bits.Reserved = 0;
    MaxDeviceFound = 0;
    DeviceFound = FALSE;

#ifdef P6_WORKAROUNDS
    BusData->MaxDevice = 0x10;
#endif

    //
    // Find any PCI bus which has MPS inti information, and provide
    // MPS handlers for dealing with it.
    //
    // Note: we assume that any PCI bus with any MPS information
    // is totally defined.  (Ie, it's not possible to connect some PCI
    // interrupts on a given PCI bus via the MPS table without connecting
    // them all).
    //
    // Note2: we assume that PCI buses are listed in the MPS table in
    // the same order the BUS declares them.  (Ie, the first listed
    // PCI bus in the MPS table is assumed to match physical PCI bus 0, etc).
    //
    //

    for (d=0; d < PCI_MAX_DEVICES; d++) {

        SlotNumber.u.bits.DeviceNumber = d;
        SlotNumber.u.bits.FunctionNumber = 0;

        for (pin=1; pin <= 4; pin++) {
            i = PCIPin2Int (SlotNumber, pin);
            if (HalpGetApicInterruptDesc(PCIBus, Handler->BusNumber, i, (PUSHORT)&i)) {
                MaxDeviceFound = d;
                DeviceFound = TRUE;
            }
        }
    }

    if (DeviceFound) {

        //
        // There are Inti mapping for interrupts on this PCI bus
        // Change handlers for this bus to MPS versions
        //

        Handler->GetInterruptVector  = HalpGetSystemInterruptVector;
        BusData->CommonData.Pin2Line = (PciPin2Line) HalpPCIPin2MPSLine;
        BusData->CommonData.Line2Pin = (PciLine2Pin) HalpPCIMPSLine2Pin;
        BusData->GetIrqRange         = HalpGetFixedPCIMPSLine;

        if (BusData->MaxDevice < MaxDeviceFound) {
            BusData->MaxDevice = MaxDeviceFound;
        }

    } else {

        //
        // Not all PCI machines are eisa machine, since the PCI interrupts
        // aren't coming into IoApics go check the Eisa ELCR for broken
        // behaviour.
        //

        HalpCheckELCR ();
    }
}


VOID
HalpMPSPCIChildren (
    VOID
    )
/*++

    Any PCI buses which don't have declared interrupt mappings and
    are children of parent buses that have MPS interrupt mappings
    need to inherit interrupts from parents via PCI barbar pole
    algorithm

--*/
{
    PBUS_HANDLER        Handler, Parent;
    PPCIPBUSDATA        BusData, ParentData;
    ULONG               b, cnt, i, id;
    PCI_SLOT_NUMBER     SlotNumber;
    struct {
        union {
            UCHAR       map[4];
            ULONG       all;
        } u;
    }                   Interrupt, Hold;

    //
    // Lookup each PCI bus in the system
    //

    for (b=0; Handler = HaliHandlerForBus(PCIBus, b); b++) {

        BusData = (PPCIPBUSDATA) Handler->BusData;

        if (BusData->CommonData.Pin2Line == (PciPin2Line) HalpPCIPin2MPSLine) {

            //
            // This bus already has mappings
            //

            continue;
        }


        //
        // Check if any parent has PCI MPS interrupt mappings
        //

        Interrupt.u.map[0] = 1;
        Interrupt.u.map[1] = 2;
        Interrupt.u.map[2] = 3;
        Interrupt.u.map[3] = 4;

        Parent = Handler;
        SlotNumber = BusData->CommonData.ParentSlot;

        while (Parent = Parent->ParentHandler) {

            if (Parent->InterfaceType != PCIBus) {
                break;
            }

            //
            // Check if parent has MPS interrupt mappings
            //

            ParentData = (PPCIPBUSDATA) Parent->BusData;
            if (ParentData->CommonData.Pin2Line == (PciPin2Line) HalpPCIPin2MPSLine) {

                //
                // This parent has MPS interrupt mappings.  Set the device
                // to get its InterruptLine values from the buses SwizzleIn table
                //

                Handler->GetInterruptVector  = HalpGetPCIBridgedInterruptVector;
                BusData->CommonData.Pin2Line = (PciPin2Line) HalpPCIBridgedPin2Line;
                BusData->CommonData.Line2Pin = (PciLine2Pin) HalpPCIMPSLine2Pin;

                for (i=0; i < 4; i++) {
                    id = PCIPin2Int (SlotNumber, Interrupt.u.map[i]);
                    BusData->SwizzleIn[i] = (UCHAR) id;
                }
                break;
            }

            //
            // Apply interrupt mapping
            //

            i = SlotNumber.u.bits.DeviceNumber;
            Hold.u.map[0] = Interrupt.u.map[(i + 0) & 3];
            Hold.u.map[1] = Interrupt.u.map[(i + 1) & 3];
            Hold.u.map[2] = Interrupt.u.map[(i + 2) & 3];
            Hold.u.map[3] = Interrupt.u.map[(i + 3) & 3];
            Interrupt.u.all = Hold.u.all;

            SlotNumber = ParentData->CommonData.ParentSlot;
        }

    }
}


VOID
HalpPCIPin2MPSLine (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++
--*/
{
    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    PciData->u.type0.InterruptLine = (UCHAR)
        PCIPin2Int (SlotNumber, PciData->u.type0.InterruptPin);
}

VOID
HalpPCIBridgedPin2Line (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    test function particular to dec pci-pci bridge card

--*/
{
    PPCIPBUSDATA    BusData;
    ULONG           i;

    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    //
    // Convert slot Pin into Bus INTA-D.
    //

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    i = (PciData->u.type0.InterruptPin +
          SlotNumber.u.bits.DeviceNumber - 1) & 3;

    PciData->u.type0.InterruptLine = BusData->SwizzleIn[i];
}


VOID
HalpPCIMPSLine2Pin (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++
--*/
{
    //
    // PCI interrupts described in the MPS table are directly
    // connected to APIC Inti pins.
    // Do nothing...
    //
}

ULONG
HalpGetPCIBridgedInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
{
    //
    // Get parent's translation
    //

    return  BusHandler->ParentHandler->GetInterruptVector (
                    BusHandler->ParentHandler,
                    BusHandler->ParentHandler,
                    InterruptLevel,
                    InterruptVector,
                    Irql,
                    Affinity
                    );

}



NTSTATUS
HalpGetFixedPCIMPSLine (
    IN PBUS_HANDLER     BusHandler,
    IN PBUS_HANDLER     RootHandler,
    IN PCI_SLOT_NUMBER  PciSlot,
    OUT PSUPPORTED_RANGE *Interrupt
    )
{
    UCHAR                   buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG      PciData;

    PciData = (PPCI_COMMON_CONFIG) buffer;
    HalGetBusData (
        PCIConfiguration,
        BusHandler->BusNumber,
        PciSlot.u.AsULONG,
        PciData,
        PCI_COMMON_HDR_LENGTH
        );

    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        return STATUS_UNSUCCESSFUL;
    }

    *Interrupt = ExAllocatePoolWithTag(PagedPool,
                                       sizeof(SUPPORTED_RANGE),
                                       HAL_POOL_TAG);
    if (!*Interrupt) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (*Interrupt, sizeof (SUPPORTED_RANGE));
    (*Interrupt)->Base = 1;                 // base = 1, limit = 0


    if (!PciData->u.type0.InterruptPin) {
        return STATUS_SUCCESS;
    }

    (*Interrupt)->Base  = PciData->u.type0.InterruptLine;
    (*Interrupt)->Limit = PciData->u.type0.InterruptLine;
    return STATUS_SUCCESS;
}

VOID
HalpPCIType2TruelyBogus (
    ULONG Context
    )
/*++

    This is a piece of work.

    Type 2 of the PCI configuration space is bad.  Bad as in to
    access it one needs to block out 4K of I/O space.

    Video cards are bad.  The only decode the bits in an I/O address
    they feel like.  Which means one can't block out a 4K range
    or these video cards don't work.

    Combinding all these bad things onto an MP machine is even
    more (sic) bad.  The I/O ports can't be mapped out unless
    all processors stop accessing I/O space.

    Allowing access to device specific PCI control space during
    an interrupt isn't bad, (although accessing it on every interrupt
    is ineficent) but this cause the added grief that all processors
    need to obtained at above all device interrupts.

    And... naturally we have an MP machine with a wired down
    bad video controller, stuck in the bad Type 2 configuration
    space (when we told everyone about type 1!).   So the "fix"
    is to HALT ALL processors for the duration of reading/writing
    ANY part of PCI configuration space such that we can be sure
    no processor is touching the 4k I/O ports which get mapped out
    of existance when type2 accesses occur.

    ----

    While I'm flaming.  Hooking PCI interrupts ontop of ISA interrupts
    in a machine which has the potential to have 240+ interrupts
    sources (read APIC)  is bad.

--*/
{
    // oh - let's just wait here and not pay attention to that other processor
    // guy whom is punching holes into the I/O space
    while (PCIType2Stall == Context) {
        HalpPollForBroadcast ();
    }
}


VOID
HalpPCIAcquireType2Lock (
    PKSPIN_LOCK SpinLock,
    PKIRQL      OldIrql
    )
{
    if (!HalpDoingCrashDump) {
        *OldIrql = KfRaiseIrql (CLOCK2_LEVEL-1);
        KiAcquireSpinLock (SpinLock);

        //
        // Interrupt all other processors and have them wait until the
        // barrier is cleared.  (HalpGenericCall waits until the target
        // processors have been interrupted before returning)
        //

        HalpGenericCall (
            HalpPCIType2TruelyBogus,
            PCIType2Stall,
            HalpActiveProcessors & ~KeGetCurrentPrcb()->SetMember
            );
    } else {
        *OldIrql = HIGH_LEVEL;
    }
}

VOID
HalpPCIReleaseType2Lock (
    PKSPIN_LOCK SpinLock,
    KIRQL       Irql
    )
{
    if (!HalpDoingCrashDump) {
        PCIType2Stall++;                            // clear barrier
        KiReleaseSpinLock (SpinLock);
        KfLowerIrql (Irql);
    }
}

NTSTATUS
HalpIrqTranslateRequirementsPci(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function translates IRQ resource requirements from
    a PCI bus that is described in the MPS table to the
    root.

Arguments:

    Context  - must hold the MPS bus number of this PCI bus

Return Value:

    STATUS_SUCCESS, so long as we can allocate the necessary
    memory

--*/
#define USE_INT_LINE_REGISTER_TOKEN  0xffffffff
{
    PIO_RESOURCE_DESCRIPTOR target;
    PPCMPBUSTRANS           busType;
    PBUS_HANDLER            busHandler;
    NTSTATUS                status;
    UCHAR                   mpsBusNumber;
    ULONG                   devPciBus, bridgePciBus;
    PCI_SLOT_NUMBER         pciSlot;
    UCHAR                   interruptLine, interruptPin;
    UCHAR                   dummy;
    PDEVICE_OBJECT          parentPdo;
    ROUTING_TOKEN           routingToken;
    KIRQL                   irql;
    KAFFINITY               affinity;
    ULONG                   busVector;
    ULONG                   vector;
    BOOLEAN                 success;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);
    ASSERT(PciIrqRoutingInterface.GetInterruptRouting);

    devPciBus = (ULONG)-1;
    pciSlot.u.AsULONG = (ULONG)-1;
    status = PciIrqRoutingInterface.GetInterruptRouting(
                PhysicalDeviceObject,
                &devPciBus,
                &pciSlot.u.AsULONG,
                &interruptLine,
                &interruptPin,
                &dummy,
                &dummy,
                &parentPdo,
                &routingToken,
                &dummy
                );

    if (!NT_SUCCESS(status)) {

        //
        // We should never get here.  If we do, we have a bug.
        // It means that we're trying to arbitrate PCI IRQs for
        // a non-PCI device.
        //

#if DBG
        DbgPrint("HAL:  The PnP manager passed a non-PCI PDO to the PCI IRQ translator (%x)\n",
                 PhysicalDeviceObject);
#endif
        *TargetCount = 0;
        return STATUS_INVALID_PARAMETER_3;
    }

    target = ExAllocatePoolWithTag(PagedPool,
                                   sizeof(IO_RESOURCE_DESCRIPTOR),
                                   HAL_POOL_TAG);

    if (!target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to fill in all the relevant fields.
    //

    *target = *Source;

    if (Context == (PVOID)USE_INT_LINE_REGISTER_TOKEN) {

        //
        // This bus's vectors aren't described in
        // the MPS table.  So just use the Int Line
        // register.
        //

        busVector = interruptLine;

        busHandler = HaliHandlerForBus(Isa, 0);

    } else {

        mpsBusNumber = (UCHAR)Context;
        success = HalpMPSBusId2NtBusId(mpsBusNumber,
                                       &busType,
                                       &bridgePciBus);

        if (!success) {
            ExFreePool(target);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Start with the assumption that the incoming
        // resources will contain the proper MPS-style
        // interrupt vector.  This will be guaranteed
        // to be true if some previous translation has
        // been done on these resources.  And it might
        // be true otherwise.
        //

        busVector = Source->u.Interrupt.MinimumVector;

        if (bridgePciBus == devPciBus) {

            //
            // If this device sits on the bus for which
            // this translator has been ejected, we can
            // do better than to assume the incoming
            // resources are clever.
            //

            busVector = PCIPin2Int(pciSlot, interruptPin);
        }

        //
        // Find the PCI bus that corresponds to this MPS bus.
        //

        ASSERT(busType->NtType == PCIBus);

        //
        // TEMPTEMP  Use bus handlers for now.
        //

        busHandler = HaliHandlerForBus(PCIBus, devPciBus);

    }


    vector = busHandler->GetInterruptVector(busHandler,
                                            busHandler,
                                            busVector,
                                            busVector,
                                            &irql,
                                            &affinity);

    if (vector == 0) {

#if DBG
        DbgPrint("\nHAL: PCI Device 0x%02x, Func. 0x%x on bus 0x%x is not in the MPS table.\n   *** Note to WHQL:  Fail this machine. ***\n\n",
                 pciSlot.u.bits.DeviceNumber,
                 pciSlot.u.bits.FunctionNumber,
                 devPciBus);
#endif
        ExFreePool(target);
        *TargetCount = 0;

        return STATUS_PNP_BAD_MPS_TABLE;

    } else {

        target->u.Interrupt.MinimumVector = vector;
        target->u.Interrupt.MaximumVector = vector;

        *TargetCount = 1;
        *Target = target;
    }

    return STATUS_TRANSLATION_COMPLETE;
}

NTSTATUS
HalpIrqTranslateResourcesPci(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function translates IRQ resources between the
    IDT and PCI busses that are described in the MPS
    tables.  The translation can go in either direction.

Arguments:

    Context  - Must hold the slot number of the bridge in
               the lower sixteen bits.  Must hold the
               the bridge's primary bus number in the
               upper sixteen bits.

Return Value:

    status

--*/
{
    PPCMPBUSTRANS           busType;
    PBUS_HANDLER            busHandler;
    UCHAR                   mpsBusNumber = (UCHAR)Context;
    ULONG                   devPciBus, bridgePciBus;
    KIRQL                   irql;
    KAFFINITY               affinity;
    ULONG                   vector;
    ULONG                   busVector;
    NTSTATUS                status;
    PCI_SLOT_NUMBER         pciSlot;
    UCHAR                   interruptLine;
    UCHAR                   interruptPin;
    UCHAR                   dummy;
    PDEVICE_OBJECT          parentPdo;
    ROUTING_TOKEN           routingToken;
    BOOLEAN                 useAlternatives = FALSE;
    BOOLEAN                 foundBus = FALSE;

    ASSERT(Source->Type = CmResourceTypeInterrupt);
    ASSERT(PciIrqRoutingInterface.GetInterruptRouting);

    *Target = *Source;

    devPciBus = (ULONG)-1;
    pciSlot.u.AsULONG = (ULONG)-1;
    status = PciIrqRoutingInterface.GetInterruptRouting(
                PhysicalDeviceObject,
                &devPciBus,
                &pciSlot.u.AsULONG,
                &interruptLine,
                &interruptPin,
                &dummy,
                &dummy,
                &parentPdo,
                &routingToken,
                &dummy
                );

    ASSERT(NT_SUCCESS(status));

    switch (Direction) {
    case TranslateChildToParent:

        if (Context == (PVOID)USE_INT_LINE_REGISTER_TOKEN) {

            //
            // This bus's vectors aren't described in
            // the MPS table.  So just use the Int Line
            // register.
            //

            interruptLine = (UCHAR)Source->u.Interrupt.Vector;

            busVector = interruptLine;

            busHandler = HaliHandlerForBus(Isa, 0);

        } else {

            //
            // Find the PCI bus that corresponds to this MPS bus.
            //

            mpsBusNumber = (UCHAR)Context;
            foundBus = HalpMPSBusId2NtBusId(mpsBusNumber,
                                            &busType,
                                            &bridgePciBus);

            if (!foundBus) {
                return STATUS_INVALID_PARAMETER_1;
            }

            ASSERT(busType->NtType == PCIBus);

            //
            // Start with the assumption that the incoming
            // resources will contain the proper MPS-style
            // interrupt vector.  This will be guaranteed
            // to be true if some previous translation has
            // been done on these resources.  And it might
            // be true otherwise.
            //

            busVector = Source->u.Interrupt.Vector;

            if (devPciBus == bridgePciBus) {

                //
                // If this device sits on the bus for which
                // this translator has been ejected, we can
                // do better than to assume the incoming
                // resources are clever.
                //

                busVector = PCIPin2Int(pciSlot, interruptPin);
            }

            //
            // TEMPTEMP  Use bus handlers for now.
            //

            busHandler = HaliHandlerForBus(PCIBus, devPciBus);

        }

        vector = busHandler->GetInterruptVector(busHandler,
                                                busHandler,
                                                busVector,
                                                busVector,
                                                &irql,
                                                &affinity);

        ASSERT(vector != 0);

        Target->u.Interrupt.Vector   = vector;
        Target->u.Interrupt.Level    = irql;
        Target->u.Interrupt.Affinity = affinity;

        return STATUS_TRANSLATION_COMPLETE;

    case TranslateParentToChild:

        //
        // There is a problem here.  We are translating from the
        // context of the IDT down to the context of a specific
        // PCI bus.  (One decribed in the MPS tables.)  This may
        // not, however, be the bus that PhysicalDeviceObject's
        // hardware lives on.  There may be plug-in PCI to PCI
        // bridges between this bus and the device.
        //
        // But we are not being asked the question "What is the
        // bus-relative interrupt with respect to the bus that
        // the device lives on?"  We are being asked "What is the
        // bus-relative interrupt once that interrupt passes through
        // all those briges and makes it up to this bus?"  This
        // turns out to be a much harder question.
        //
        // There are really two cases:
        //
        // 1)  There are no bridges between this bus and the device.
        //
        // This is easy.  We answer the first question above and
        // we're done.  (This information will actually get used.
        // it will appear in the start device IRP and the device
        // manager.)
        //
        // 2)  There are bridges.
        //
        // This is the hard case.  And the information, were we
        // actually going to bother to dig it up, would get thrown
        // away.  Nobody actually cares what the answer is.  The
        // only place it is going is the "Source" argument to
        // the next translator.  And the translator for PCI to PCI
        // bridges won't end up using it.
        //
        // So we punt here and just answer the first question.
        //

        if (Context == (PVOID)USE_INT_LINE_REGISTER_TOKEN) {

            Target->u.Interrupt.Vector = interruptLine;

        } else {

            mpsBusNumber = (UCHAR)Context;
            if (HalpMPSBusId2NtBusId(mpsBusNumber,
                                     &busType,
                                     &bridgePciBus)) {

                if (devPciBus == bridgePciBus) {

                    Target->u.Interrupt.Vector = PCIPin2Int(pciSlot, interruptPin);

                } else {

                    useAlternatives = TRUE;
                }

            } else {

                useAlternatives = TRUE;
            }
        }

        if (useAlternatives) {

            //
            // Setup the default case.  We assume that the I/O
            // res list had the right answer.
            //

            ASSERT(AlternativesCount == 1);
            ASSERT(Alternatives[0].Type == CmResourceTypeInterrupt);

            Target->u.Interrupt.Vector = Alternatives[0].u.Interrupt.MinimumVector;
        }

        Target->u.Interrupt.Level = Target->u.Interrupt.Vector;
        Target->u.Interrupt.Affinity = 0xffffffff;

        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_3;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpsproca.asm ===
title "MP primitives for MP+AT Systems"

;++
;
;Copyright (c) 1991  Microsoft Corporation
;Copyright (c) 1992  Intel Corporation
;All rights reserved
;
;INTEL CORPORATION PROPRIETARY INFORMATION
;
;This software is supplied to Microsoft under the terms
;of a license agreement with Intel Corporation and may not be
;copied nor disclosed except in accordance with the terms
;of that agreement.
;
;
;Module Name:
;
;    mpsproca.asm
;
;Abstract:
;
;   PC+MP Start Next Processor assemble code
;
;   This module along with mpspro.c implement the code to start
;   processors on MP+AT Systems.
;
;Author:
;
;   Ken Reneris (kenr) 12-Jan-1992
;
;Revision History:
;
;    Ron Mosgrove (Intel) - Modified to support PC+MP Systems
;
;--



.386p
        .xlist
include i386\ixcmos.inc
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
include i386\ixslpctx.inc
        .list

ifndef NT_UP
    EXTRNP  _HalpBuildTiledCR3,1
    EXTRNP  _HalpFreeTiledCR3,0
    EXTRNP  _HalpStartProcessor,2
endif

    EXTRNP  _HalpAcquireCmosSpinLock
    EXTRNP  _HalpReleaseCmosSpinLock

    EXTRNP  _HalDisplayString,1

    EXTRNP  _StartPx_BuildRealModeStart,1
    EXTRNP  _KeStallExecutionProcessor, 1
    
    extrn   _Halp1stPhysicalPageVaddr:DWORD
    extrn   _HalpLowStub:DWORD
    extrn   _HalpLowStubPhysicalAddress:DWORD
    extrn   _HalpHiberInProgress:BYTE
    extrn   _CurTiledCr3LowPart:DWORD

;
;   Internal defines and structures
;

WarmResetVector     equ     467h   ; warm reset vector in ROM data segment

PAGELK    SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; BOOLEAN
; HalStartNextProcessor (
;   IN PLOADER_BLOCK      pLoaderBlock,
;   IN PKPROCESSOR_STATE  pProcessorState
; )
;
; Routine Description:
;
;    This routine is called by the kernel durning kernel initialization
;    to obtain more processors.  It is called until no more processors
;    are available.
;
;    If another processor exists this function is to initialize it to
;    the passed in processorstate structure, and return TRUE.
;
;    If another processor does not exists or if the processor fails to
;    start, then a FALSE is returned.
;
;    Also note that the loader block has been setup for the next processor.
;    The new processor logical thread number can be obtained from it, if
;    required.
;
;    In order to use the Startup IPI the real mode startup code must be
;    page aligned.  The HalpLowStubPhysicalAddress has always been page
;    aligned but because the PxParamBlock was placed first in this
;    segment the real mode code has been something other than page aligned.
;    This has been changed by making the first entry in the PxParamBlock
;    a jump instruction to the real mode startup code.
;
; Arguments:
;    pLoaderBlock,  - Loader block which has been intialized for the
;             next processor.
;
;    pProcessorState    - The processor state which is to be loaded into
;             the next processor.
;
;
; Return Value:
;
;    TRUE  - ProcessorNumber was dispatched.
;    FALSE - A processor was not dispatched. no other processors exists.
;
;--

pLoaderBlock        equ dword ptr [ebp+8]   ; zero based
pProcessorState     equ dword ptr [ebp+12]

;
; Local variables
;

PxFrame             equ [ebp - size PxParamBlock]
LWarmResetVector    equ [ebp - size PxParamBlock - 4]
LStatusCode         equ [ebp - size PxParamBlock - 8]
LCmosValue          equ [ebp - size PxParamBlock - 12]
Prcb                equ [ebp - size PxParamBlock - 16]


cPublicProc _HalStartNextProcessor ,2
ifdef NT_UP
    xor     eax, eax                    ; up build of hal, no processors to
    stdRET  _HalStartNextProcessor      ; start
else
    push    ebp                         ; save ebp
    mov     ebp, esp                    ; Save Frame
    sub     esp, size PxParamBlock + 16 ; Make room for local vars

    push    esi                         ; Save required registers
    push    edi
    push    ebx
    pushfd

    xor     eax, eax
    mov     LStatusCode, eax

    mov     PxFrame.SPx_flag, eax       ; Initialize the flags

    ;
    ;  Copy Processor state into the stack based Parameter Block
    ;
    lea     edi, PxFrame.SPx_PB         ; Destination on stack
    mov     esi, pProcessorState        ; Input parameter address
    mov     ecx, ProcessorStateLength   ; Structure length
    rep movsb

    ;
    ; Build a CR3 for the starting processor. If returning 
    ; from hibernation, then use setup tiled CR3 else
    ; create a new map
    ; 

    mov		al, _HalpHiberInProgress
    or		al, al
    jz		Hpsnp_Hiber

    mov		eax, _CurTiledCr3LowPart
    jmp		Hpsnp_TiledCr3_done

Hpsnp_Hiber:
    stdCall _HalpBuildTiledCR3, <pProcessorState>

Hpsnp_TiledCr3_done:
    ;
    ; Save the special registers
    ;
    mov     PxFrame.SPx_TiledCR3, eax    ; Newly contructed CR3
    mov     PxFrame.SPx_P0EBP, ebp       ; Stack pointer

    lea     eax, PxFrame
    stdCall _StartPx_BuildRealModeStart, <eax>
    
    ;
    ;  Set the BIOS warm reset vector to our routine in Low Memory
    ;
    mov     ebx, _Halp1stPhysicalPageVaddr
    add     ebx, WarmResetVector

    cli

    mov     eax, [ebx]                      ; Get current vector
    mov     LWarmResetVector, eax           ; Save it

    ;
    ;  Actually build the vector (Seg:Offset)
    ;
    mov     eax, _HalpLowStubPhysicalAddress
    shl     eax, 12                         ; seg:0
    mov     dword ptr [ebx], eax            ; start Px at Seg:0

    ;
    ;  Tell BIOS to Jump Via The Vector we gave it
    ;  By setting the Reset Code in CMOS
    ;

    stdCall _HalpAcquireCmosSpinLock
    mov     al, 0fh
    CMOS_READ
    mov     LCmosValue, eax

    mov     eax, 0a0fh
    CMOS_WRITE
    stdCall _HalpReleaseCmosSpinLock

    ;
    ;  Start the processor
    ;

    mov     eax, pLoaderBlock               ; lookup processor # we are
    mov     eax, [eax].LpbPrcb              ; starting
    mov     Prcb, eax                       ; save this away for later
    movzx   eax, byte ptr [eax].PbNumber

    stdCall _HalpStartProcessor < _HalpLowStubPhysicalAddress, eax >
    or      eax, eax
    jnz     short WaitTilPnOnline

    ;
    ;  Zero Return Value means couldn't kick start the processor
    ;  so there's no point in waiting for it.
    ;

    jmp     NotWaitingOnProcessor

WaitTilPnOnline:
    dec     eax                         ; Local APIC ID

    mov     ecx, Prcb
    mov     [ecx].PbHalReserved.PrcbPCMPApicID, al

    ;
    ;  We can't proceed until the started processor gives us the OK
    ;

    mov     edi, 200
    mov     esi, _HalpLowStub
    
WaitAbit:
    test    [esi].SPx_flag, SPX_FLAG_STARTED ; wait for Px to get it's
    jne     short ProcessorStarted          ; info

    stdCall _KeStallExecutionProcessor, <2000>
    
    dec     edi
    cmp     edi, 0
    jne     short WaitAbit
    jmp     short NotWaitingOnProcessor

ProcessorStarted:
    mov     LStatusCode, 1              ; Return TRUE

    mov     ecx, Prcb                   ; save this away for later
    movzx   ecx, byte ptr [ecx].PbNumber

NotWaitingOnProcessor:
    mov		al, _HalpHiberInProgress
    or          al, al
    jnz		short Hpsnp_ResetVector

    stdCall _HalpFreeTiledCR3           ; free memory used for tiled CR3
                                        
Hpsnp_ResetVector:    
    mov     eax, LWarmResetVector
    mov     [ebx], eax                  ; Restore reset vector

    stdCall _HalpAcquireCmosSpinLock
    mov     eax, LCmosValue             ; Restore the Cmos setting
    shl     eax, 8
    mov     al, 0fh
    CMOS_WRITE
    stdCall _HalpReleaseCmosSpinLock

    mov     eax, LStatusCode

snp_exit:
    popfd
    pop     ebx
    pop     edi
    pop     esi
    mov     esp, ebp
    pop     ebp
    stdRET  _HalStartNextProcessor
endif

stdENDP _HalStartNextProcessor


PAGELK    ends                            ; end 32 bit code

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpprofil.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    mpprofile.asm
;
; Abstract:
;
;    This module implements the code necessary to initialize,
;    field and process the profile interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;--

.586p
        .xlist
include hal386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
include i386\mp8254.inc

        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _KeProfileInterrupt,1,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpAcquireSystemHardwareSpinLock,0
        EXTRNP  _HalpReleaseSystemHardwareSpinLock,0
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        extrn   _HalpUse8254:BYTE

;
;   APIC Timer Constants
;

APIC_TIMER_DISABLED     equ      (INTERRUPT_MASKED OR PERIODIC_TIMER OR APIC_PROFILE_VECTOR)
APIC_TIMER_ENABLED      equ      (PERIODIC_TIMER OR APIC_PROFILE_VECTOR)

;
; number of 100ns intervals in one second
;
Num100nsIntervalsPerSec     equ     10000000

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

    ALIGN dword

public _HalpProfileRunning, _HalpPerfInterruptHandler
_HalpProfileRunning         dd  0
_HalpPerfInterruptHandler   dd  0

_DATA   ends


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
;   HalStartProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is set the interrupt rate to the value that's been set
;       by the KeSetProfileInterval routine. Then enable the APIC Timer interrupt.
;
;   This function gets called on every processor so the hal can enable
;   a profile interrupt on each processor.
;

;--

cPublicProc _HalStartProfileInterrupt    ,1

;
;   Set the interrupt rate to what is actually needed.
;

        mov     eax, PCR[PcHal.ProfileCountDown]
        mov     dword ptr APIC[LU_INITIAL_COUNT], eax

        mov     _HalpProfileRunning, 1    ; Indicate profiling
;
;   Set the Local APIC Timer to interrupt Periodically at APIC_PROFILE_VECTOR
;

        mov     dword ptr APIC[LU_TIMER_VECTOR], APIC_TIMER_ENABLED

        stdRET    _HalStartProfileInterrupt

stdENDP _HalStartProfileInterrupt

;++
;
;   HalStopProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;--

cPublicProc _HalStopProfileInterrupt    ,1

;
;   Turn off profiling
;

        mov     _HalpProfileRunning, 0    ; Indicate profiling is off
        mov     dword ptr APIC[LU_TIMER_VECTOR], APIC_TIMER_DISABLED
        stdRET    _HalStopProfileInterrupt

stdENDP _HalStopProfileInterrupt

;++
;   ULONG
;   HalSetProfileInterval (
;       ULONG Interval
;       );
;
;   Routine Description:
;
;       This procedure sets the interrupt rate (and thus the sampling
;       interval) for the profiling interrupt.
;
;   Arguments:
;
;       (TOS+4) - Interval in 100ns unit.
;                 (MINIMUM is 1221 or 122.1 uS) see ke\profobj.c
;
;   Return Value:
;
;       Interval actually used
;
;--

cPublicProc _HalSetProfileInterval    ,1

        mov     ecx, [esp+4]            ; ecx = interval in 100ns unit
        and     ecx, 7FFFFFFFh          ; Remove sign bit.

        ;
        ;   The only possible error is if we will cause a divide overflow
        ;   this can happen only if the (frequency * request count) is
        ;   greater than 2^32* Num100nsIntervalsPerSec.
        ;
        ;   To protect against that we just ensure that the request count
        ;   is less than (or equal to) Num100nsIntervalsPerSec
        ;
        cmp     ecx, Num100nsIntervalsPerSec
        jle     @f
        mov     ecx, Num100nsIntervalsPerSec
@@:

        ;
        ;   Save the interval we're using to return
        ;
        push    ecx

        ;
        ;   Compute the countdown value
        ;
        ;     let
        ;       R == caller's requested 100ns interval count
        ;       F == APIC Counter Freguency (hz)
        ;       N == Number of 100ns Intervals per sec
        ;
        ;     then
        ;       count = (R*F)/N
        ;
        ;   Get the previously computed APIC counter Freq
        ;   for this processor
        ;

        mov     eax, PCR[PcHal.ApicClockFreqHz]

        ;
        ;   eax <= F and ecx <= R
        ;

        ;
        ; Compute (request count) * (ApicClockFreqHz) == (R*F)
        ;

        xor     edx, edx
        mul     ecx

        ;
        ;   edx:eax contains 64Bits of (R*F)
        ;

        mov     ecx, Num100nsIntervalsPerSec
        div     ecx

        ;
        ; Compute (R*F) / Num100nsIntervalsPerSec == (R*F)/N
        ;

        mov     PCR[PcHal.ProfileCountDown], eax      ; Save the Computed Count Down
        mov     edx, dword ptr APIC[LU_CURRENT_COUNT]

        ;
        ;   Set the interrupt rate in the chip.
        ;

        mov     dword ptr APIC[LU_INITIAL_COUNT], eax

        pop     eax            ; Return Actual Interval Used

        stdRET    _HalSetProfileInterval

stdENDP _HalSetProfileInterval

        page ,132
        subttl  "System Profile Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a profile interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    HAL_PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = HAL_PROFILE_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hpi_a, Hpi_t

cPublicProc _HalpProfileInterrupt     ,0
;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hpi_a, Hpi_t

;
; (esp) - base of trap frame
;

        push    APIC_PROFILE_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <HAL_PROFILE_LEVEL,APIC_PROFILE_VECTOR,esp>

        cmp     _HalpProfileRunning, 0       ; Profiling?
        je      @f                          ; if not just exit

        stdCall _KeProfileInterrupt,<ebp>   ; (ebp) = TrapFrame address

@@:
        INTERRUPT_EXIT

stdENDP _HalpProfileInterrupt


        subttl  "System Perf Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a perf interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    HAL_PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = HAL_PROFILE_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hpf_a, Hpf_t

cPublicProc _HalpPerfInterrupt     ,0
;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hpf_a, Hpf_t

;
; (esp) - base of trap frame
;

        push    APIC_PERF_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <HAL_PROFILE_LEVEL,APIC_PERF_VECTOR,esp>

;
; Invoke perf interrupt handler
;

        mov     ecx, ebp                ; param1 = trap frame
        mov     eax, _HalpPerfInterruptHandler
        or      eax, eax
        jz      short hpf20

        call    eax

hpf10: 
;
; Starting with the Willamette processor, the perf interrupt gets masked on
; interrupting.  Needs to clear the mask before leaving the interrupt handler.
; Do this regardless of whether a valid interrupt handler exists or not.   
; 
        and     dword ptr APIC[LU_PERF_VECTOR], (NOT INTERRUPT_MASKED) 

        INTERRUPT_EXIT

hpf20:
if DBG
        int     3
endif
        jmp     short hpf10

stdENDP _HalpPerfInterrupt

_TEXT   ends

PAGELK  SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalCalibratePerformanceCounter (
;     IN LONG volatile *Number,
;     IN ULONGLONG NewCount
;     )
;
; /*++
;
; Routine Description:
;
;     This routine calibrates the performance counter value for a
;     multiprocessor system.  The calibration can be done by zeroing
;     the current performance counter, or by calculating a per-processor
;     skewing between each processors counter.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
;     NewCount - Supplies the value to synchronize the counter too
;
; Return Value:
;
;     None.
;--
NewCountLow     equ     [esp + 24]
NewCountHigh    equ     [esp + 28]

ifdef MMTIMER
cPublicProc _HalpAcpiTimerCalibratePerfCount,3
else
cPublicProc _HalCalibratePerformanceCounter,3
endif
cPublicFpo 3,0        
        push    esi
        push    edi
        push    ebx

        mov     esi, [esp+16]           ; pointer to Number

        pushfd                          ; save previous interrupt state
        cli                             ; disable interrupts

cPublicFpo 3,4        
        xor     eax, eax

        lock dec    dword ptr [esi]     ; count down
@@:     YIELD
        cmp     dword ptr [esi], 0      ; wait for all processors to signal
        jnz     short @b

        cpuid                           ; fence
        
        mov     ecx, MsrTSC             ; MSR of time stamp counter
        
        mov     eax, NewCountLow
        mov     edx, NewCountHigh
        mov     PCR[PcHal.PerfCounterLow], eax
        mov     PCR[PcHal.PerfCounterHigh], edx
        xor     eax,eax
        xor     edx,edx

        wrmsr                           ; zero the time stamp counter

        popfd                           ; restore interrupt flag
        pop     ebx
        pop     edi
        pop     esi
ifdef MMTIMER
        stdRET    _HalpAcpiTimerCalibratePerfCount

stdENDP _HalpAcpiTimerCalibratePerfCount
else
        stdRET    _HalCalibratePerformanceCounter

stdENDP _HalCalibratePerformanceCounter
endif

PAGELK  ends

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Scale Apic Timer"
;++
;
; VOID
; HalpScaleTimers (
;    IN VOID
;    )
;
; Routine Description:
;
;   Determines the frequency of the APIC timer.  This routine is run
;   during initialization
;
;
;--

cPublicProc _HalpScaleTimers ,0
        push    ebx
        push    esi
        push    edi

;
;   Don't let anyone in until we've finished here
;
        stdCall   _HalpAcquireCmosSpinLock

;
;   Protect us from interrupts
;
        pushfd
        cli

;
;   First set up the Local Apic Counter
;

;
;   Configure the APIC timer
;

APIC_TIMER_DISABLED     equ      (INTERRUPT_MASKED OR PERIODIC_TIMER OR APIC_PROFILE_VECTOR)
TIMER_ROUNDING          equ      10000


        mov     dword ptr APIC[LU_TIMER_VECTOR], APIC_TIMER_DISABLED
        mov     dword ptr APIC[LU_DIVIDER_CONFIG], LU_DIVIDE_BY_1

;
;   We're going to do this twice & take the second results
;
        mov     esi, 2
hst10:

;
;   Make sure the write has occurred
;
        mov     eax, dword ptr APIC[LU_DIVIDER_CONFIG]

;
;   We don't care what the actual time is we are only interested
;   in seeing the UIP transition.  We are garenteed a 1 sec interval
;   if we wait for the UIP bit to complete an entire cycle.

;
;   We also don't much care which direction the transition we use is
;   as long as we wait for the same transition to read the APIC clock.
;   Just because it is most likely that when we begin the UIP bit will
;   be clear, we'll use the transition from !UIP to UIP.
;

;
;   Wait for the UIP bit to be cleared, this is our starting state
;

@@:
        mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jnz     short @b                ; if z, no, wait some more

;
;   Wait for the UIP bit to get set
;

@@:
        mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short @b                ; if z, no, wait some more

;
;   At this point we found the UIP bit set, now set the initial
;   count.  Once we write this register its value is copied to the
;   current count register and countdown starts or continues from
;   there
;

        xor     eax, eax
        mov     PCR[PcHal.PerfCounterLow], eax
        mov     PCR[PcHal.PerfCounterHigh], eax        

        cpuid                           ; fence

        mov     ecx, MsrTSC             ; MSR of RDTSC
        xor     edx, edx
        mov     eax, edx
        mov     dword ptr APIC[LU_INITIAL_COUNT], 0FFFFFFFFH
        wrmsr                           ; Clear TSC count

;
;   Wait for the UIP bit to be cleared again
;

@@:
        mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jnz     short @b                ; if z, no, wait some more

;
;   Wait for the UIP bit to get set
;

@@:
        mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short @b                ; if z, no, wait some more

;
;   The cycle is complete, we found the UIP bit set. Now read
;   the counters and compute the frequency.  The frequency is
;   just the ticks counted which is the initial value minus
;   the current value.
;

        xor     eax, eax
        cpuid                           ; fence

        rdtsc
        mov     ecx, dword ptr APIC[LU_CURRENT_COUNT]

        dec     esi                     ; if this is the first time
        jnz     hst10                   ; around, go loop

        mov     dword ptr PCR[PcHal][TSCHz], eax    ; Frequency LowPart
        mov     dword ptr PCR[PcHal][TSCHz+4], edx  ; Frequency HighPart

        mov     eax, 0FFFFFFFFH
        sub     eax, ecx

;
;  Round the Apic Timer Freq
;

        xor     edx, edx                ; (edx:eax) = dividend

        mov     ecx, TIMER_ROUNDING
        div     ecx                     ; now edx has remainder

        cmp     edx, TIMER_ROUNDING / 2
        jle     @f                      ; if less don't round
        inc     eax                     ; else round up
@@:

;
;   Multiply by the  Rounding factor to get the rounded Freq
;
        mov     ecx, TIMER_ROUNDING
        xor     edx, edx
        mul     ecx

        mov     dword ptr PCR[PcHal.ApicClockFreqHz], eax

;
; Round TSC freq
;

        mov     eax, dword ptr PCR[PcHal][TSCHz]    ; Frequency LowPart
        mov     edx, dword ptr PCR[PcHal][TSCHz+4]  ; Frequency HighPart

        mov     ecx, TIMER_ROUNDING
        div     ecx                     ; now edx has remainder

        cmp     edx, TIMER_ROUNDING / 2
        jle     @f                      ; if less don't round
        inc     eax                     ; else round up
@@:
        mov     ecx, TIMER_ROUNDING
        xor     edx, edx
        mul     ecx

        mov     dword ptr PCR[PcHal][TSCHz], eax              ; Frequency LowPart
        mov     dword ptr PCR[PcHal][TSCHz+4], edx            ; Frequency HighPart

;
; Convert TSC to microseconds
;

        mov     ecx, 1000000
        div     ecx                     ; Convert to microseconds

        xor     ecx, ecx
        cmp     ecx, edx                ; any remainder?
        adc     eax, ecx                ; Yes, add one

        mov     PCR[PcStallScaleFactor], eax

        stdCall _HalpReleaseCmosSpinLock

;
;   Return Value is the timer frequency
;

        mov     eax, dword ptr PCR[PcHal.ApicClockFreqHz]
        mov     PCR[PcHal.ProfileCountDown], eax

;
;   Set the interrupt rate in the chip.
;

        mov     dword ptr APIC[LU_INITIAL_COUNT], eax

        popfd

        pop     edi
        pop     esi
        pop     ebx

        stdRET    _HalpScaleTimers
stdENDP _HalpScaleTimers


INIT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpprocst.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpprocst.c

Abstract:

    This code has been moved from mpsproc.c so that it
    can be included from both the MPS hal and the ACPI hal.

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

    Ron Mosgrove (Intel) - Modified to support the PC+MP
    
    Jake Oshins (jakeo) - moved from mpsproc.c

--*/

#include "halp.h"
#include "pcmp_nt.inc"
#include "apic.inc"
#include "stdio.h"

VOID
HalpMapCR3 (
    IN ULONG_PTR VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length
    );

ULONG
HalpBuildTiledCR3 (
    IN PKPROCESSOR_STATE    ProcessorState
    );

VOID
HalpFreeTiledCR3 (
    VOID
    );

#if defined(_AMD64_)

VOID
HalpLMStub (
    VOID
    );

#endif

VOID
StartPx_PMStub (
    VOID
    );

ULONG
HalpBuildTiledCR3Ex (
    IN PKPROCESSOR_STATE    ProcessorState,
    IN ULONG                ProcNum
    );

VOID
HalpMapCR3Ex (
    IN ULONG_PTR VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN ULONG ProcNum
    );

#if defined(_AMD64_)

VOID
HalpCommitCR3 (
    ULONG ProcNum
    );

VOID
HalpCommitCR3Worker (
    PVOID *PageTable,
    ULONG Level
    );

#endif

VOID
HalpFreeTiledCR3Ex (
    ULONG ProcNum
    );

VOID
HalpFreeTiledCR3WorkRoutine(
    IN PVOID pWorkItem
    );

VOID
HalpFreeTiledCR3Worker(
    ULONG ProcNum
    );

#define MAX_PT              16

PVOID   HiberFreeCR3[MAX_PROCESSORS][MAX_PT];   // remember pool memory to free

#define HiberFreeCR3Page(p,i) \
    (PVOID)((ULONG_PTR)HiberFreeCR3[p][i] & ~(ULONG_PTR)1)

PVOID   HalpLowStubPhysicalAddress;   // pointer to low memory bootup stub
PUCHAR  HalpLowStub;                  // pointer to low memory bootup stub


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,HalpBuildTiledCR3)
#pragma alloc_text(PAGELK,HalpMapCR3)
#pragma alloc_text(PAGELK,HalpFreeTiledCR3)
#pragma alloc_text(PAGELK,HalpBuildTiledCR3Ex)
#pragma alloc_text(PAGELK,HalpMapCR3Ex)
#pragma alloc_text(PAGELK,HalpFreeTiledCR3Ex)

#if defined(_AMD64_)
#pragma alloc_text(PAGELK,HalpCommitCR3)
#pragma alloc_text(PAGELK,HalpCommitCR3Worker)
#endif

#endif

#define PTES_PER_PAGE (PAGE_SIZE / HalPteSize())

#if !defined(_AMD64_)

PHARDWARE_PTE
GetPdeAddressEx(
    ULONG_PTR Va,
    ULONG ProcessorNumber
    )
{
    PHARDWARE_PTE pageDirectories;
    PHARDWARE_PTE pageDirectoryEntry;
    ULONG pageDirectoryIndex;

    pageDirectories = (PHARDWARE_PTE)(HiberFreeCR3Page(ProcessorNumber,0));

    if (HalPaeEnabled() != FALSE) {

        //
        // Skip over the first page, which contains the page directory pointer
        // table.
        //
    
        HalpAdvancePte( &pageDirectories, PTES_PER_PAGE );
    }

    pageDirectoryIndex = (ULONG)(Va >> MiGetPdiShift());

    //
    // Note that in the case of PAE, pageDirectoryIndex includes the PDPT
    // bits.  This works because we know that the four page directory tables
    // are adjacent.
    //

    pageDirectoryEntry = HalpIndexPteArray( pageDirectories,
                                            pageDirectoryIndex );
    return pageDirectoryEntry;
}

PHARDWARE_PTE
GetPteAddress(
    IN ULONG_PTR Va,
    IN PHARDWARE_PTE PageTable
    )
{
    PHARDWARE_PTE pointerPte;
    ULONG index;

    index = (ULONG)MiGetPteIndex( (PVOID)Va );
    pointerPte = HalpIndexPteArray( PageTable, index );

    return pointerPte;
}

#endif


ULONG
HalpBuildTiledCR3 (
    IN PKPROCESSOR_STATE    ProcessorState
    )
/*++

Routine Description:
    When the x86 processor is reset it starts in real-mode.
    In order to move the processor from real-mode to protected
    mode with flat addressing the segment which loads CR0 needs
    to have its linear address mapped to the physical
    location of the segment for said instruction so the
    processor can continue to execute the following instruction.

    This function is called to build such a tiled page directory.
    In addition, other flat addresses are tiled to match the
    current running flat address for the new state.  Once the
    processor is in flat mode, we move to a NT tiled page which
    can then load up the remaining processor state.

Arguments:
    ProcessorState  - The state the new processor should start in.

Return Value:
    Physical address of Tiled page directory


--*/
{
    return(HalpBuildTiledCR3Ex(ProcessorState,0));
}

VOID
HalpStoreFreeCr3 (
    IN ULONG ProcNum,
    IN PVOID Page,
    IN BOOLEAN FreeContiguous
    )
{
    ULONG index;
    PVOID page;

    page = Page;

    //
    // Remember whether this page should be freed via MmFreeContiguousMemory()
    // or ExFreePool();
    // 

    if (FreeContiguous != FALSE) {

        //
        // Set the low bit to indicate that this page must be freed
        // via MmFreeContiguousMemory()
        //

        (ULONG_PTR)page |= 1;

    }

    for (index = 0; index < MAX_PT; index += 1) {

        if (HiberFreeCR3[ProcNum][index] == NULL) {
            HiberFreeCR3[ProcNum][index] = page;
            break;
        }
    }

    ASSERT(index < MAX_PT);
}


ULONG
HalpBuildTiledCR3Ex (
    IN PKPROCESSOR_STATE    ProcessorState,
    IN ULONG                ProcNum
    )
/*++

Routine Description:
    When the x86 processor is reset it starts in real-mode.
    In order to move the processor from real-mode to protected
    mode with flat addressing the segment which loads CR0 needs
    to have its linear address mapped to machine the physical
    location of the segment for said instruction so the
    processor can continue to execute the following instruction.

    This function is called to build such a tiled page directory.
    In addition, other flat addresses are tiled to match the
    current running flat address for the new state.  Once the
    processor is in flat mode, we move to a NT tiled page which
    can then load up the remaining processor state.

Arguments:
    ProcessorState  - The state the new processor should start in.

Return Value:
    Physical address of Tiled page directory


--*/
{
    ULONG allocationSize;
    PHARDWARE_PTE pte;
    PHARDWARE_PTE pdpt;
    PHARDWARE_PTE pdpte;
    PHARDWARE_PTE pageDirectory;
    PHYSICAL_ADDRESS physicalAddress;
    ULONG i;
    PVOID pageTable;
    BOOLEAN contigMemory;

    contigMemory = FALSE;

#if defined(_AMD64_)

    //
    // Need a single level 4 page to reside below 4G.
    //

    allocationSize = PAGE_SIZE;
    physicalAddress.HighPart = 0;
    physicalAddress.LowPart = 0xffffffff;

    pageTable = MmAllocateContiguousMemory (allocationSize, physicalAddress);
    contigMemory = TRUE;

#else

    if (HalPaeEnabled() != FALSE) {

        //
        // Need 5 pages for PAE mode: one for the page directory pointer
        // table and one for each of the four page directories.  Note that
        // only the single PDPT page really needs to come from memory below 4GB
        // physical.
        //
    
        allocationSize = PAGE_SIZE * 5;
        physicalAddress.HighPart = 0;
        physicalAddress.LowPart = 0xffffffff;

        pageTable = MmAllocateContiguousMemory (allocationSize, physicalAddress);
        contigMemory = TRUE;

    } else {

        //
        // Just one page for the page directory.
        //
    
        allocationSize = PAGE_SIZE;
        pageTable = ExAllocatePoolWithTag (NonPagedPool, allocationSize, HAL_POOL_TAG);
    }

#endif

    if (!pageTable) {
        // Failed to allocate memory.
        return 0;
    }

    //
    // Remember to free this page table when the process is complete.
    //

    HalpStoreFreeCr3(ProcNum,pageTable,contigMemory);
    
    RtlZeroMemory (pageTable, allocationSize);

#if !defined(_AMD64_)

    if (HalPaeEnabled() != FALSE) {
    
        //
        // Initialize each of the four page directory pointer table entries
        //
    
        pdpt = (PHARDWARE_PTE)pageTable;
        pageDirectory = pdpt;
        for (i = 0; i < 4; i++) {

            //
            // Get a pointer to the page directory pointer table entry
            //

            pdpte = HalpIndexPteArray( pdpt, i );
    
            //
            // Skip to the first (next) page directory.
            //

            HalpAdvancePte( &pageDirectory, PTES_PER_PAGE );

            //
            // Find its physical address and update the page directory pointer
            // table entry.
            //
    
            physicalAddress = MmGetPhysicalAddress( pageDirectory );
            pdpte->Valid = 1;
            HalpSetPageFrameNumber( pdpte,
                                    physicalAddress.QuadPart >> PAGE_SHIFT );
        }
    }

#endif  // _AMD64_

    //
    //  Map page for real mode stub (one page)
    //

    HalpMapCR3Ex ((ULONG_PTR) HalpLowStubPhysicalAddress,
                HalpPtrToPhysicalAddress( HalpLowStubPhysicalAddress ),
                PAGE_SIZE,
                ProcNum);

#if defined(_AMD64_)

    //
    // Map page for long mode stub (one page)
    //

    HalpMapCR3Ex ((ULONG64) &HalpLMStub,
                  HalpPtrToPhysicalAddress( NULL ),
                  PAGE_SIZE,
                  ProcNum);

#else   // _AMD64_

    //
    //  Map page for protect mode stub (one page)
    //

    HalpMapCR3Ex ((ULONG_PTR) &StartPx_PMStub,
                  HalpPtrToPhysicalAddress( NULL ),
                  PAGE_SIZE,
                  ProcNum);

    //
    //  Map page(s) for processors GDT
    //

    HalpMapCR3Ex ((ULONG_PTR)ProcessorState->SpecialRegisters.Gdtr.Base, 
                  HalpPtrToPhysicalAddress( NULL ),
                  ProcessorState->SpecialRegisters.Gdtr.Limit,
                  ProcNum);


    //
    //  Map page(s) for processors IDT
    //

    HalpMapCR3Ex ((ULONG_PTR)ProcessorState->SpecialRegisters.Idtr.Base, 
                  HalpPtrToPhysicalAddress( NULL ),
                  ProcessorState->SpecialRegisters.Idtr.Limit,
                  ProcNum);

#endif  // _AMD64_

#if defined(_AMD64_)

    //
    // Commit the mapping structures
    //

    HalpCommitCR3 (ProcNum);

#endif

    ASSERT (MmGetPhysicalAddress (pageTable).HighPart == 0);

    return MmGetPhysicalAddress (pageTable).LowPart;
}


VOID
HalpMapCR3 (
    IN ULONG_PTR VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length
    )
/*++

Routine Description:
    Called to build a page table entry for the passed page
    directory.  Used to build a tiled page directory with
    real-mode & flat mode.

Arguments:
    VirtAddress     - Current virtual address
    PhysicalAddress - Optional. Physical address to be mapped
                      to, if passed as a NULL then the physical
                      address of the passed virtual address
                      is assumed.
    Length          - number of bytes to map

Return Value:
    none.

--*/
{
    HalpMapCR3Ex(VirtAddress,PhysicalAddress,Length,0);
}

#if defined(_AMD64_)

VOID
HalpMapCR3Ex (
    IN ULONG_PTR VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN ULONG ProcNum
    )
/*++

Routine Description:
    Called to build a page table entry for the passed page
    directory.  Used to build a tiled page directory with
    real-mode & flat mode.

Arguments:
    VirtAddress     - Current virtual address
    PhysicalAddress - Optional. Physical address to be mapped
                      to, if passed as a NULL then the physical
                      address of the passed virtual address
                      is assumed.
    Length          - number of bytes to map

Return Value:
    none.

--*/
{
    PVOID *pageTable;
    PVOID *tableEntry;
    PHARDWARE_PTE pte;
    ULONG tableIndex;
    ULONG level;
    ULONG i;

    while (Length > 0) {

        pageTable = HiberFreeCR3Page(ProcNum,0);
        level = 3;
    
        while (TRUE) {
    
            //
            // Descend down the mapping tables, making sure that a page table
            // exists at each level for this address.
            //
            // NOTE: The "page table entries" are in reality linear pointers
            //       to the next lower page.  After the structure is built,
            //       these will be converted to real page table entries.
            // 
    
            tableIndex = (ULONG)(VirtAddress >> (level * 9 + PTI_SHIFT));
            tableIndex &= PTE_PER_PAGE - 1;
    
            tableEntry = &pageTable[tableIndex];
            if (level == 0) {
                break;
            }
    
            pageTable = *tableEntry;
            if (pageTable == NULL) {
    
                pageTable = ExAllocatePoolWithTag(NonPagedPool,
                                                  PAGE_SIZE,
                                                  HAL_POOL_TAG);
                if (!pageTable) {
    
                    //
                    // This allocation is critical.
                    //
    
                    KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                                 PAGE_SIZE,
                                 6,
                                 (ULONG_PTR)__FILE__,
                                 __LINE__
                                 );
                }

                //
                // Zero the page and store it in our list of mapping pages
                // 

                RtlZeroMemory (pageTable, PAGE_SIZE);
                HalpStoreFreeCr3(ProcNum,pageTable,FALSE);

                *tableEntry = pageTable;
            }

            level -= 1;
        }
    
        //
        // The lowest-level page table entries are treated as real PTEs.
        //
    
        pte = (PHARDWARE_PTE)tableEntry;
    
        if (PhysicalAddress.QuadPart == 0) {
            PhysicalAddress = MmGetPhysicalAddress((PVOID)VirtAddress);
        }
    
        HalpSetPageFrameNumber( pte, PhysicalAddress.QuadPart >> PAGE_SHIFT );
    
        pte->Valid = 1;
        pte->Write = 1;
    
        PhysicalAddress.QuadPart = 0;
        VirtAddress += PAGE_SIZE;
        if (Length > PAGE_SIZE) {
            Length -= PAGE_SIZE;
        } else {
            Length = 0;
        }
    }
}


VOID
HalpCommitCR3 (
    ULONG ProcNum
    )

/*++

Routine Description:

    The AMD64 four-level page table structure was created for each processor
    using linear pointers in place of PTEs.  This routine walks the structures,
    replacing these linear pointers with actual PTE entries.

Arguments:

    ProcNum - Identifies the processor for which the page table structure
              will be processed.

Return Value:

    None.

--*/
{
    HalpCommitCR3Worker(HiberFreeCR3Page(ProcNum,0),3);
}


VOID
HalpCommitCR3Worker (
    PVOID *PageTable,
    ULONG Level
    )

/*++

Routine Description:

    This is the worker routine for HalpCommitCR3.  It is called recursively
    for three of the four levels of page tables.  The lowest level, the
    page tables themselves, are already filled in with PTEs.

Arguments:

    PageTable - Pointer to the topmost level of the pagetable structure.

    Level - Supplies the remaining number of page levels.


Return Value:

    None.

--*/
{
    PVOID *tableEntry;
    ULONG index;
    PHYSICAL_ADDRESS physicalAddress;
    PHARDWARE_PTE pte;

    //
    // Examine each PTE in this page.
    // 

    for (index = 0; index < PTE_PER_PAGE; index++) {

        tableEntry = &PageTable[index];
        if (*tableEntry != NULL) {

            //
            // A non-null entry was found.  It contains a linear pointer
            // to the next lower page table.  If the current level is 2
            // or higher then the next level is at least a Page Directory
            // so convert that page as well with a recursive call to this
            // routine.
            // 

            if (Level >= 2) {
                HalpCommitCR3Worker( *tableEntry, Level - 1 );
            }

            //
            // Now convert the current table entry to PTE format.
            //

            pte = (PHARDWARE_PTE)tableEntry;
            physicalAddress = MmGetPhysicalAddress(*tableEntry);
            *tableEntry = NULL;
            HalpSetPageFrameNumber(pte,physicalAddress.QuadPart >> PAGE_SHIFT);
            pte->Valid = 1;
            pte->Write = 1;
        }
    }
}

#else

VOID
HalpMapCR3Ex (
    IN ULONG_PTR VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN ULONG ProcNum
    )
/*++

Routine Description:
    Called to build a page table entry for the passed page
    directory.  Used to build a tiled page directory with
    real-mode & flat mode.

Arguments:
    VirtAddress     - Current virtual address
    PhysicalAddress - Optional. Physical address to be mapped
                      to, if passed as a NULL then the physical
                      address of the passed virtual address
                      is assumed.
    Length          - number of bytes to map

Return Value:
    none.

--*/
{
    ULONG         i;
    PHARDWARE_PTE PTE;
    PVOID         pPageTable;
    PHYSICAL_ADDRESS pPhysicalPage;


    while (Length) {
        PTE = GetPdeAddressEx (VirtAddress,ProcNum);
        if (HalpIsPteFree( PTE ) != FALSE) {
            pPageTable = ExAllocatePoolWithTag(NonPagedPool,
                                               PAGE_SIZE,
                                               HAL_POOL_TAG);
            if (!pPageTable) {

                //
                // This allocation is critical.
                //

                KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                             PAGE_SIZE,
                             6,
                             (ULONG_PTR)__FILE__,
                             __LINE__
                             );
            }
            RtlZeroMemory (pPageTable, PAGE_SIZE);
            HalpStoreFreeCr3(ProcNum,pPageTable,FALSE);

            pPhysicalPage = MmGetPhysicalAddress (pPageTable);
            HalpSetPageFrameNumber( PTE, pPhysicalPage.QuadPart >> PAGE_SHIFT );
            PTE->Valid = 1;
            PTE->Write = 1;
        }

        pPhysicalPage.QuadPart =
            HalpGetPageFrameNumber( PTE ) << PAGE_SHIFT;

        pPageTable = MmMapIoSpace (pPhysicalPage, PAGE_SIZE, TRUE);

        PTE = GetPteAddress (VirtAddress, pPageTable);

        if (PhysicalAddress.QuadPart == 0) {
            PhysicalAddress = MmGetPhysicalAddress((PVOID)VirtAddress);
        }

        HalpSetPageFrameNumber( PTE, PhysicalAddress.QuadPart >> PAGE_SHIFT );
        PTE->Valid = 1;
        PTE->Write = 1;

        MmUnmapIoSpace (pPageTable, PAGE_SIZE);

        PhysicalAddress.QuadPart = 0;
        VirtAddress += PAGE_SIZE;
        if (Length > PAGE_SIZE) {
            Length -= PAGE_SIZE;
        } else {
            Length = 0;
        }
    }
}

#endif

VOID
HalpFreeTiledCR3 (
    VOID
    )
/*++

Routine Description:
    Frees any memory allocated when the tiled page directory
    was built.

Arguments:
    none

Return Value:
    none
--*/
{
    HalpFreeTiledCR3Ex(0);
}

typedef struct _FREE_TILED_CR3_CONTEXT {
    WORK_QUEUE_ITEM WorkItem;
    ULONG ProcNum;
} FREE_TILED_CR3_CONTEXT, *PFREE_TILED_CR3_CONTEXT;

VOID
HalpFreeTiledCR3Worker(
    ULONG ProcNum
    ) 
{
    ULONG i;
    PVOID page;
    
    for (i = 0; HiberFreeCR3[ProcNum][i]; i++) {

        //
        // Free each page according to the method with which it was
        // allocated.
        //

        page = HiberFreeCR3[ProcNum][i];

        if (((ULONG_PTR)page & 1 ) == 0) {
            ExFreePool(page);
        } else {
            (ULONG_PTR)page ^= 1;
            MmFreeContiguousMemory(page);
        }

        HiberFreeCR3[ProcNum][i] = 0;
    }
}

VOID
HalpFreeTiledCR3WorkRoutine(
    IN PFREE_TILED_CR3_CONTEXT Context
    ) 
{
    HalpFreeTiledCR3Worker(Context->ProcNum);
    ExFreePool((PVOID)Context);
}

VOID
HalpFreeTiledCR3Ex (
    ULONG ProcNum
    )
/*++

Routine Description:
    Frees any memory allocated when the tiled page directory
    was built.

Arguments:
    none

Return Value:
    none
--*/
{
    PFREE_TILED_CR3_CONTEXT Context;

    if(KeGetCurrentIrql() == PASSIVE_LEVEL) {
        HalpFreeTiledCR3Worker(ProcNum); 

    } else {

        Context = (PFREE_TILED_CR3_CONTEXT) ExAllocatePoolWithTag(
                                                NonPagedPool,
                                                sizeof(FREE_TILED_CR3_CONTEXT),
                                                HAL_POOL_TAG
                                                );
        if (Context) {
            Context->ProcNum = ProcNum;	
            ExInitializeWorkItem(&Context->WorkItem, 
                                 HalpFreeTiledCR3WorkRoutine, 
                                 Context); 
            ExQueueWorkItem(&Context->WorkItem, DelayedWorkQueue);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpspin.asm ===
TITLE   "Spin Locks"
;++
;
;  Copyright (c) 1989-1998  Microsoft Corporation
;
;  Module Name:
;
;     spinlock.asm
;
;  Abstract:
;
;     This module implements x86 spinlock functions for the PC+MP HAL.
;
;  Author:
;
;     Bryan Willman (bryanwi) 13 Dec 89
;
;  Environment:
;
;     Kernel mode only.
;
;  Revision History:
;
;   Ron Mosgrove (o-RonMo) Dec 93 - modified for PC+MP HAL.
;--

.486p

include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include hal386.inc
include mac386.inc
include apic.inc
include ntapic.inc

        EXTRNP _KeBugCheckEx,5,IMPORT
        EXTRNP KfRaiseIrql, 1,,FASTCALL
        EXTRNP KfLowerIrql, 1,,FASTCALL
        EXTRNP _KeSetEventBoostPriority, 2, IMPORT
        EXTRNP _KeWaitForSingleObject,5, IMPORT
        extrn  _HalpVectorToIRQL:byte
        extrn  _HalpIRQLtoTPR:byte

ifdef NT_UP

LOCK_ADD     equ   add
LOCK_DEC     equ   dec
LOCK_CMPXCHG equ   cmpxchg

else

LOCK_ADD     equ   lock add
LOCK_DEC     equ   lock dec
LOCK_CMPXCHG equ   lock cmpxchg

endif

        _TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        SUBTTL "Acquire Kernel Spin Lock"
;++
;
;  KIRQL
;  FASTCALL
;  KfAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function raises to DISPATCH_LEVEL and acquires the specified
;     spin lock.
;
;  Arguments:
;
;     SpinLock (ecx) - Supplies a pointer to a kernel spin lock.
;
;  Return Value:
;
;     The old IRQL is returned as the function value.
;
;--

        align 16
cPublicFastCall KfAcquireSpinLock  ,1
cPublicFpo 0,0

        mov     edx, dword ptr APIC[LU_TPR] ; get old IRQL vector
        mov     dword ptr APIC[LU_TPR], DPC_VECTOR ; raise IRQL
        jmp     short sls10             ; finish in common code

        fstENDP KfAcquireSpinLock

        SUBTTL "Acquire Kernel Spin Lock"
;++
;
;  KIRQL
;  FASTCALL
;  KeAcquireSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function raises to SYNCH_LEVEL and acquires the specified
;     spin lock.
;
;  Arguments:
;
;     SpinLock (ecx) - Supplies a pointer to a kernel spin lock.
;
;  Return Value:
;
;     The old IRQL is returned as the function value.
;
;--

        align 16
cPublicFastCall KeAcquireSpinLockRaiseToSynch,1
cPublicFpo 0,0

        mov     edx, dword ptr APIC[LU_TPR] ; get old vector
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR ; raise IRQL
sls10:  shr     edx, 4                  ; extract high 4 bits of vector
        movzx   eax, _HalpVectorToIRQL[edx] ; translate TPR to old IRQL

ifndef NT_UP

;
; Attempt to acquire the specified spin lock.
;

sls20:  ACQUIRE_SPINLOCK ecx, <short sls30> ;

        fstRET  KeAcquireSpinLockRaiseToSynch

;
; Lock is owned - spin until it is free, then try again.
;

sls30:  SPIN_ON_SPINLOCK ecx, sls20     ;

else

        fstRET  KeAcquireSpinLockRaiseToSynch

endif

        fstENDP KeAcquireSpinLockRaiseToSynch

        SUBTTL "KeAcquireSpinLockRaiseToSynchMCE"
;++
;
;  KIRQL
;  FASTCALL
;  KeAcquireSpinLockRaiseToSynchMCE (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function performs the same function as KeAcquireSpinLockRaiseToSynch
;     but provides a work around for an IFU errata for Pentium Pro processors
;     prior to stepping 619.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to a kernel spin lock.
;
;  Return Value:
;
;     OldIrql  (TOS+8) - pointer to place old irql.
;
;--

ifndef NT_UP

        align 16
cPublicFastCall KeAcquireSpinLockRaiseToSynchMCE,1
cPublicFpo 0,0

        mov     edx, dword ptr APIC[LU_TPR]     ; (ecx) = Old Priority (Vector)
        mov     eax, edx
        shr     eax, 4
        movzx   eax, _HalpVectorToIRQL[eax]     ; (al) = OldIrql

        ;
        ; Test lock
        ;
        ; TEST_SPINLOCK   ecx,<short slm30>   ; NOTE - Macro expanded below:

        test    dword ptr [ecx], 1
        nop                           ; On a P6 prior to stepping B1 (619), we
        nop                           ; need these 5 NOPs to ensure that we
        nop                           ; do not take a machine check exception.
        nop                           ; The cost is just 1.5 clocks as the P6
        nop                           ; just tosses the NOPs.

        jnz     short slm30

        ;
        ; Raise irql.
        ;

slm10:  mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR

        ;
        ; Attempt to assert the lock
        ;

        ACQUIRE_SPINLOCK    ecx,<short slm20>
        fstRET  KeAcquireSpinLockRaiseToSynchMCE

        ;
        ; Lock is owned, spin till it looks free, then go get it
        ;

        align dword

slm20:  mov     dword ptr APIC[LU_TPR], edx

        align dword
slm30:  SPIN_ON_SPINLOCK    ecx,slm10

        fstENDP KeAcquireSpinLockRaiseToSynchMCE

endif

        SUBTTL "Release Kernel Spin Lock"
;++
;
;  VOID
;  FASTCALL
;  KeReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN KIRQL OldIrql
;     )
;
;  Routine Description:
;
;     This function releases a spin lock and lowers to the old IRQL.
;
;  Arguments:
;
;     SpinLock (ecx) - Supplies a pointer to a spin lock.
;     OldIrql (dl) - Supplies the old IRQL value.
;
;  Return Value:
;
;     None.
;
;--

        align 16
cPublicFastCall KfReleaseSpinLock  ,2
cPublicFpo 0,0

        movzx   eax, dl                 ; zero extend old IRQL 

ifndef NT_UP

        RELEASE_SPINLOCK ecx            ; release spin lock

endif

;
; Lower IRQL to its previous level.
;
; N.B. Ensure that the requested priority is set before returning.
;

        movzx   ecx, _HalpIRQLtoTPR[eax] ; translate IRQL to TPR value
        mov     dword ptr APIC[LU_TPR], ecx ; lower to old IRQL
        mov     eax, dword ptr APIC[LU_TPR] ; synchronize

        fstRET  KfReleaseSpinLock

        fstENDP KfReleaseSpinLock

        SUBTTL  "Acquire Lock With Interrupts Disabled" 
;++
;
;  ULONG
;  FASTCALL
;  HalpAcquireHighLevelLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;    This function disables interrupts and acquires a spinlock.
;
; Arguments:
;
;    SpinLock (ecx) - Supplies a pointer to a spin lock.
;
; Return Value:
;
;    The old EFLAGS are returned as the function value.
;
;--

        align   16
cPublicFastCall HalpAcquireHighLevelLock, 1

        pushfd                          ; save EFLAGS
        pop     eax                     ;
ahll10: cli                             ; disable interrupts

        ACQUIRE_SPINLOCK ecx, ahll20    ; attempt to acquire spin lock

        fstRET    HalpAcquireHighLevelLock

ahll20: push    eax                     ; restore EFLAGS
        popfd                           ;

        SPIN_ON_SPINLOCK ecx, <ahll10>  ; wait for lock to be free

        fstENDP HalpAcquireHighLevelLock

        SUBTTL  "Release Lock And Enable Interrupts"
;++
;
;  VOID
;  FASTCALL
;  HalpReleaseHighLevelLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN ULONG Eflags
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock and restores the old EFLAGS.
;
; Arguments:
;
;     SpinLock (ecx) - Supplies a pointer to a spin lock.
;     Eflags (edx) - supplies the old EFLAGS value.
;
; Return Value:
;
;     None.
;
;--

        align   16
cPublicFastCall HalpReleaseHighLevelLock, 2

        RELEASE_SPINLOCK ecx            ; release spin lock

        push    edx                     ; restore old EFLAGS
        popfd                           ;

        fstRET    HalpReleaseHighLevelLock

        fstENDP HalpReleaseHighLevelLock

        SUBTTL  "Acquire Fast Mutex"
;++
;
;  VOID
;  FASTCALL
;  ExAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquires ownership of the specified FastMutex.
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex.
;
;  Return Value:
;
;     None.
;
;--

        align   16
cPublicFastCall ExAcquireFastMutex,1
cPublicFpo 0,0

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority (Vector)

if DBG
        ;
        ; Caller must already be at or below APC_LEVEL.
        ;

        cmp     eax, APC_VECTOR
        jg      short afm11             ; irql too high ==> fatal.
endif

        mov     dword ptr APIC[LU_TPR], APC_VECTOR ; Write New Priority to the TPR

   LOCK_DEC     dword ptr [ecx].FmCount         ; Get count
        jnz     short afm10                     ; Not the owner so go wait.

        mov     dword ptr [ecx].FmOldIrql, eax

        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov	dword ptr [ecx].FmOwner, esp
        fstRet  ExAcquireFastMutex

cPublicFpo 0,0
afm10:
        inc     dword ptr [ecx].FmContention

cPublicFpo 0,2
        push    ecx
        push    eax
        add     ecx, FmEvent                    ; Wait on Event
        stdCall _KeWaitForSingleObject,<ecx,WrExecutive,0,0,0>
        pop     eax                             ; (al) = OldTpr
        pop     ecx                             ; (ecx) = FAST_MUTEX

        mov     dword ptr [ecx].FmOldIrql, eax

        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov	dword ptr [ecx].FmOwner, esp
        fstRet  ExAcquireFastMutex

if DBG

cPublicFpo 0,1
afm11:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,033h,0>

endif

fstENDP ExAcquireFastMutex

        SUBTTL  "Release Fast Mutex"
;++
;
;  VOID
;  FASTCALL
;  ExReleaseFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function releases ownership of the FastMutex.
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex.
;
;  Return Value:
;
;     None.
;
;--

        align   16
cPublicFastCall ExReleaseFastMutex,1
cPublicFpo 0,0

if DBG
        ;
        ; Caller must already be at APC_LEVEL or have APCs blocked.
        ;

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority (Vector)
        cmp     eax, APC_VECTOR
        je      short rfm04                     ; irql is ok.

cPublicFpo 0,1
        stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,034h,0>

rfm04:
endif
        mov     eax, dword ptr [ecx].FmOldIrql    ; (eax) = OldTpr

   LOCK_ADD     dword ptr [ecx].FmCount, 1      ; Remove our count
        jle     short rfm05                     ; if <= 0, set event

cPublicFpo 0,0
        mov     dword ptr APIC[LU_TPR], eax
        mov     ecx, dword ptr APIC[LU_TPR]
if DBG
        cmp     eax, ecx                        ; Verify TPR is what was
        je      short @f                        ; written
        int 3
@@:
endif
        fstRet  ExReleaseFastMutex


cPublicFpo 0,1
rfm05:  add     ecx, FmEvent
        push    eax                         ; save new tpr
        stdCall _KeSetEventBoostPriority, <ecx, 0>
        pop     eax                         ; restore tpr

cPublicFpo 0,0
        mov     dword ptr APIC[LU_TPR], eax
        mov     ecx, dword ptr APIC[LU_TPR]
if DBG
        cmp     eax, ecx                        ; Verify TPR is what was
        je      short @f                        ; written
        int 3
@@:
endif
        fstRet  ExReleaseFastMutex

if DBG

endif

fstENDP ExReleaseFastMutex

        SUBTTL  "Try To Acquire Fast Mutex"
;++
;
;  BOOLEAN
;  FASTCALL
;  ExTryToAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquires ownership of the FastMutex.
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex.
;
;  Return Value:
;
;     Returns TRUE if the FAST_MUTEX was acquired; otherwise FALSE.
;
;--

        align   16
cPublicFastCall ExTryToAcquireFastMutex,1
cPublicFpo 0,0

if DBG
        ;
        ; Caller must already be at or below APC_LEVEL.
        ;

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority (Vector)
        cmp     eax, APC_VECTOR
        jg      short tam11                     ; irql too high ==> fatal.
endif

        ;
        ; Try to acquire.
        ;

        push    dword ptr APIC[LU_TPR]          ; Save Old Priority (Vector)
        mov     dword ptr APIC[LU_TPR], APC_VECTOR ; Write New Priority to the TPR

        mov     edx, 0                          ; Value to set
        mov     eax, 1                          ; Value to compare against
   LOCK_CMPXCHG dword ptr [ecx].FmCount, edx    ; Attempt to acquire
        jnz     short tam20                     ; got it?

cPublicFpo 0,0
        mov     eax, 1                          ; return TRUE
        pop     dword ptr [ecx].FmOldIrql       ; Store Old TPR

        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov	dword ptr [ecx].FmOwner, esp

        fstRet  ExTryToAcquireFastMutex

tam20:  pop     ecx                             ; (ecx) = Old TPR
        mov     dword ptr APIC[LU_TPR], ecx
        mov     eax, dword ptr APIC[LU_TPR]

if DBG
        cmp     ecx, eax                        ; Verify TPR is what was
        je      short @f                        ; written
        int 3
@@:
endif

        xor     eax, eax                        ; return FALSE
        YIELD
        fstRet  ExTryToAcquireFastMutex         ; all done

if DBG

cPublicFpo 0,1
tam11:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,033h,0>

endif

fstENDP ExTryToAcquireFastMutex

        SUBTTL  "Acquire In Stack Queued SpinLock"
;++
;
; VOID
; FASTCALL
; KeAcquireInStackQueuedSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; VOID
; FASTCALL
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    These functions raise IRQL and acquire an in-stack queued spin lock.
;
; Arguments:
;
;    SpinLock (ecx) - Supplies a pointer to a spin lock.
;    LockHandle (edx) - supplies a pointer to a lock context.
;
; Return Value:
;
;   None.
;
;--

        align 16
cPublicFastCall KeAcquireInStackQueuedSpinLock, 2
cPublicFpo 0,0

        mov     eax, dword ptr APIC[LU_TPR] ; get old IRQL vector
        mov     dword ptr APIC[LU_TPR], DPC_VECTOR ; raise IRQL
        jmp     short iqsl10            ; finish in common code

        fstENDP KeAcquireInStackQueuedSpinLock


        align   16
cPublicFastCall KeAcquireInStackQueuedSpinLockRaiseToSynch, 2
cPublicFpo 0,0

        mov     eax, dword ptr APIC[LU_TPR] ; get old IRQL vector
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR ; raise IRQL
iqsl10: shr     eax, 4                  ; extract high 4 bits of vector
        mov     al, _HalpVectorToIRQL[eax] ; translate to old IRQL
        mov     [edx].LqhOldIrql, al    ; save old IRQL in lock context

;
; Set spin lock address in lock context and clear next queue link.
;

ifndef NT_UP

        mov     [edx].LqhLock, ecx      ; set spin lock address
        and     dword ptr [edx].LqhNext, 0 ; clear next link

ifdef CAPKERN_SYNCH_POINTS

        push    ecx                     ; lock address
        push    000010101h              ; 1 Dword, Timestamp, Subcode = 1
        call    _CAP_Log_NInt           ;
        add     esp, 8                  ;

endif

;
; Exchange the value of the lock with the address of the lock context.
; 

        mov     eax, edx                ; save lock context address
        xchg    [ecx], edx              ; exchange lock context address
        cmp     edx, 0                  ; check if lock is already held
        jnz     short iqsl30            ; if nz, lock already held

;
; N.B. The spin lock address is dword aligned and the bottom two bits are
;      used as indicators.
;
;      Bit 0 is LOCK_QUEUE_WAIT.
;      Bit 1 is LOCK_QUEUE_OWNER.
;

        or      [eax].LqLock, LOCK_QUEUE_OWNER ; set lock owner

endif

iqsl20: fstRET  KeAcquireInStackQueuedSpinLockRaiseToSynch

;
; The lock is already held by another processor. Set the wait bit in the
; lock context, then set the next field in the lock context of the last
; waiter in the lock queue.
;

ifndef NT_UP

iqsl30: or      [eax].LqLock, LOCK_QUEUE_WAIT ; set lock wait
        mov     [edx].LqNext, eax       ; set next entry in previous last

ifdef CAPKERN_SYNCH_POINTS

        xor     edx, edx                ; clear wait counter
iqsl40: inc     edx                     ; count wait time
        test    [eax].LqLock, LOCK_QUEUE_WAIT ; check if lock ownership granted
        jz      short iqsl50            ; if z, lock owner granted

        YIELD                           ; yield to other SMT processors

        jmp     short iqsl40            ;

iqsl50: push    ecx                     ; lock address
        push    edx                     ; wait counter
        push    000020104h              ; 2 Dwords, Timestamp, Subcode = 4
        call    _CAP_Log_NInt           ;
        add     esp, 12                 ;

        fstRET  KeAcquireInStackQueuedSpinLockRaiseToSynch

else

iqsl40: test    [eax].LqLock, LOCK_QUEUE_WAIT ; check if lock ownership granted
        jz      short iqsl20            ; if z, lock ownership granted

        YIELD                           ; yield to other SMT processors

        jmp     short iqsl40            ;

endif

endif

        fstENDP KeAcquireInStackQueuedSpinLockRaiseToSynch

        SUBTTL  "Acquire Queued Spin Lock"
;++
;
; KIRQL
; FASTCALL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; KIRQL
; FASTCALL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; Routine Description:
;
;    These function raise IRQL and acquire a processor specific queued spin
;    lock.
;
; Arguments:
;
;    Number (ecx) - Supplies the queued spinlock number.
;
; Return Value:
;
;    The old IRQL is returned as the function value.
;
;--

        .errnz  (LOCK_QUEUE_HEADER_SIZE - 8)

        align   16
cPublicFastCall KeAcquireQueuedSpinLock, 1
cPublicFpo 0,0

        mov     eax, dword ptr APIC[LU_TPR] ; get old IRQL vector
        mov     dword ptr APIC[LU_TPR], DPC_VECTOR ; raise IRQL
        jmp     short aqsl10            ; finish in common code

        fstENDP KeAcquireQueuedSpinLock

        align   16
cPublicFastCall KeAcquireQueuedSpinLockRaiseToSynch, 1
cPublicFpo 0,0

        mov     eax, dword ptr APIC[LU_TPR] ; get old IRQL vector
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR ; raise IRQL
aqsl10: shr     eax, 4                      ; extract high 4 bits of vector
        movzx   eax, byte ptr _HalpVectorToIRQL[eax] ; translate to old IRQL

;
; Get address of per processor lock queue entry.
;

ifndef NT_UP

        mov     edx, PCR[PcPrcb]        ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue ; get lock queue address
        mov     ecx, [edx].LqLock       ; get spin lock address

ifdef CAPKERN_SYNCH_POINTS

        push    ecx                     ; lock address
        push    000010101h              ; 1 Dword, Timestamp, Subcode = 1
        call    _CAP_Log_NInt           ;
        add     esp, 8                  ;

endif

        push    eax                     ; save old IRQL

cPublicFpo 0,1

if DBG

        test    ecx, LOCK_QUEUE_OWNER + LOCK_QUEUE_WAIT ; inconsistent state?
        jnz     short aqsl60            ; if nz, inconsistent state

endif

;
; Exchange the value of the lock with the address of the lock context.
;

        mov     eax, edx                ; save lock queue entry address
        xchg    [ecx], edx              ; exchange lock queue address
        cmp     edx, 0                  ; check if lock is already held
        jnz     short aqsl30            ; if nz, lock already held

;
; N.B. The spin lock address is dword aligned and the bottom two bits are
;      used as indicators.
;
;      Bit 0 is LOCK_QUEUE_WAIT.
;      Bit 1 is LOCK_QUEUE_OWNER.
;

        or      [eax].LqLock, LOCK_QUEUE_OWNER ; set lock owner
aqsl20: pop     eax                     ; restore old IRQL

cPublicFpo 0,0

endif

        fstRET  KeAcquireQueuedSpinLockRaiseToSynch

;
; The lock is already held by another processor. Set the wait bit in the
; lock context, then set the next field in the lock context of the last
; waiter in the lock queue.
;

ifndef NT_UP

cPublicFpo 0,1

aqsl30: or      [eax].LqLock, LOCK_QUEUE_WAIT ; set lock wait
        mov     [edx].LqNext, eax       ; set next entry in previous last

ifdef CAPKERN_SYNCH_POINTS

        xor     edx, edx                ; clear wait counter
aqsl40: inc     edx                     ; count wait time
        test    [eax].LqLock, LOCK_QUEUE_WAIT ; check if lock ownership granted
        jz      short aqsl50            ; if z, lock owner granted

        YIELD                           ; yield to other SMT processors

        jmp     short aqsl40            ;

aqsl50: push    ecx                     ; lock address
        push    edx                     ; wait counter
        push    000020104h              ; 2 Dwords, Timestamp, Subcode = 4
        call    _CAP_Log_NInt           ;
        add     esp, 12                 ;
        jmp     short aqsl20            ;

else

aqsl40: test    [eax].LqLock, LOCK_QUEUE_WAIT ; check if lock ownership granted
        jz      short aqsl20            ; if z, lock owner granted

        YIELD                           ; yield to other SMT processors

        jmp     short aqsl40            ;

endif

;
; Inconsistent state in lock queue entry.
;

if DBG

cPublicFpo 0,1

aqsl60: stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED, ecx, edx, 0, 0>
        int     3                       ; so stacktrace works

endif

endif

        fstENDP KeAcquireQueuedSpinLockRaiseToSynch

        SUBTTL  "Release Queued SpinLock"
;++
;
; VOID
; FASTCALL
; KeReleaseQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number,
;     IN KIRQL OldIrql
;     )
;
; Arguments:
;
;     Number (ecx) - Supplies the queued spinlock number.
;
;     OldIrql (dl) - Supplies the old IRQL.
;
; VOID
; KeReleaseInStackQueuedSpinLock (
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Arguments:
;
;    LockHandle (ecx) - Address of Lock Queue Handle structure.
;
; Routine Description:
;
;    These functions release a queued spinlock and lower IRQL to the old
;    value.
;
; Return Value:
;
;    None.
;
;--

        .errnz  (LqhNext)
        .errnz  (LOCK_QUEUE_OWNER - 2)

        align   16
cPublicFastCall KeReleaseInStackQueuedSpinLock, 1
cPublicFpo 0,0

        mov     dl, byte ptr [ecx].LqhOldIrql ; set old IRQL
        mov     eax, ecx                ; set lock queue entry address
        jmp     short rqsl10            ; finish in common code

        fstENDP KeReleaseInStackQueuedSpinLock

        align   16
cPublicFastCall KeReleaseQueuedSpinLock, 2
cPublicFpo 0,0

ifndef NT_UP

        mov     eax, PCR[PcPrcb]        ; get address of PRCB
        lea     eax, [eax+ecx*8].PbLockQueue ; set lock queue entry address

endif

rqsl10: movzx   edx, dl                 ; zero extend old IRQL

ifndef NT_UP

        push    ebx                     ; save nonvolatile register

cPublicFpo 0,1

        mov     ebx, [eax].LqNext       ; get next entry address
        mov     ecx, [eax].LqLock       ; get spin lock home address

ifdef CAPKERN_SYNCH_POINTS

        push    ecx                     ; lock address
        push    000010107h              ; 1 Dword, Timestamp, Subcode = 7
        call    _CAP_Log_NInt           ;
        add     esp, 8                  ;

endif

;
; Make sure we own the lock and clear the bit
;

if DBG
        btr     ecx, 1                  ; clear lock owner bit
        jnc     short rqsl80            ; if nc, owner not set
        cmp     dword ptr [ecx], 0      ; lock must be owned for a release
        jz      short rqsl80
else

        and     ecx, NOT LOCK_QUEUE_OWNER ; Clear out the owner bit

endif


;
; Test if lock waiter present.
;

        test    ebx, ebx                ; test if lock waiter present
        mov     [eax].LqLock, ecx       ; clear lock owner bit
        jnz     short rqsl40            ; if nz, lock waiter present

;
; Attempt to release queued spin lock.
;

        push    eax                     ; save lock queue entry address
   lock cmpxchg [ecx], ebx              ; release spin lock if no waiter
        pop     eax                     ; restore lock queue entry address
        jnz     short rqsl50            ; if nz, lock waiter present
rqs120: pop     ebx                     ; restore nonvolatile register

cPublicFpo 0,0

endif

;
; Lower IRQL to its previous level.
;
; N.B. Ensure that the requested priority is set before returning.
;

rqsl30: movzx   ecx, byte ptr _HalpIRQLtoTPR[edx] ; translate IRQL to TPR value
        mov     dword ptr APIC[LU_TPR], ecx ; lower to old IRQL
        mov     eax, dword ptr APIC[LU_TPR] ; synchronize

        fstRET  KeReleaseQueuedSpinLock

;
; Lock waiter is present.
;
; Clear wait bit and set owner bit in next owner lock queue entry.
;

ifndef NT_UP

cPublicFpo 0,1

rqsl40: xor     [ebx].LqLock, (LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT) ; set bits
        and     [eax].LqNext, 0         ; clear next waiter address
        jmp     short rqs120            ;

;
; Another processor is attempting to acquire the spin lock.
;

ifdef CAPKERN_SYNCH_POINTS

rqsl50: push    ecx                     ; lock address (for CAP_Log)
        xor     ecx, ecx                ; clear wait counter
rqsl60: inc     ecx                     ; increment wait counter
        mov     ebx, [eax].LqNext       ; get address of next entry
        test    ebx, ebx                ; check if waiter present
        jnz     short rqsl70            ; if nz, waiter is present

        YIELD                           ; yield to other SMT processors

        jmp     short rqsl60            ;

rqsl70: push    ecx                     ; wait counter
        push    000020104h              ; 2 Dwords, Timestamp, Subcode = 4
        call    _CAP_Log_NInt           ;
        add     esp, 12                 ;
        jmp     short rqsl40            ;

else

rqsl50: mov     ebx, [eax].LqNext       ; get address of next entry
        test    ebx, ebx                ; check if waiter present
        jnz     short rqsl40            ; if nz, waiter is present

        YIELD                           ; yield to other SMT processors

        jmp     short rqsl50            ;

endif

;
; Inconsistent state in lock queue entry.
;

if DBG

cPublicFpo 0,1

rqsl80: stdCall _KeBugCheckEx, <SPIN_LOCK_NOT_OWNED, ecx, eax, 0, 1>
        int     3                       ; so stacktrace works

endif

endif

        fstENDP KeReleaseQueuedSpinLock

        SUBTTL  "Try to Acquire Queued SpinLock"

;++
;
; LOGICAL
; KeTryToAcquireQueuedSpinLock (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; LOGICAL
; KeTryToAcquireQueuedSpinLockRaiseToSynch (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and attempts to acquire the specified queued spinlock.  If the
;    spinlock is already owned by another thread, IRQL is restored
;    to its previous value and FALSE is returned.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (edx) - A pointer to the variable to receive the old
;                    IRQL.
;
; Return Value:
;
;    TRUE if the lock was acquired, FALSE otherwise.
;    N.B. ZF is set if FALSE returned, clear otherwise.
;
;--


        align 16
cPublicFastCall KeTryToAcquireQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,0

        push    APIC_SYNCH_VECTOR               ; raise to SYNCH
        jmp     short taqsl10                   ; continue in common code

fstENDP KeTryToAcquireQueuedSpinLockRaiseToSynch


cPublicFastCall KeTryToAcquireQueuedSpinLock,2
cPublicFpo 0,0

        push    DPC_VECTOR                      ; raise to DPC level

        ; Attempt to get the lock with interrupts disabled, raising
        ; the priority in the interrupt controller only if acquisition
        ; is successful.
taqsl10:

ifndef NT_UP

        push    edx                             ; save address of OldIrql
        pushfd                                  ; save interrupt state
cPublicFpo 0,3

        ; Get address of Lock Queue entry

        cli
        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

        mov     ecx, [edx].LqLock

ifdef CAPKERN_SYNCH_POINTS
        push    ecx           ; lock address
        push    000010108h    ; 1 Dword, Timestamp, Subcode = 8
        call    _CAP_Log_NInt
        add     esp, 8
endif

if DBG

        test    ecx, LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT
        jnz     short taqsl98                   ; jiff lock already held (or
                                                ; this proc already waiting).
endif

        ; quick test, get out if already taken

        cmp     dword ptr [ecx], 0              ; check if already taken
        jnz     short taqsl60                   ; jif already taken
        xor     eax, eax                        ; comparison value (not locked)

        ; Store the Lock Queue entry address in the lock ONLY if the
        ; current lock value is 0.

        lock cmpxchg [ecx], edx
        jnz     short taqsl60

        ; Lock has been acquired.

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [edx].LqLock, ecx

        mov     eax, [esp+8]                    ; get new IRQL
        mov     edx, [esp+4]                    ; get addr to save OldIrql

else

        mov     eax, [esp]                      ; get new IRQL

endif

        ; Raise IRQL and return success.

        ; Get old priority (vector) from Local APIC's Task Priority
        ; Register and set the new priority.

        mov     ecx, dword ptr APIC[LU_TPR]     ; (ecx) = Old Priority
        mov     dword ptr APIC[LU_TPR], eax     ; Set New Priority

ifndef NT_UP

        popfd                                   ; restore interrupt state
        add     esp, 8                          ; free locals

else

        add     esp, 4                          ; free local
endif

cPublicFpo 0,0

        shr     ecx, 4
        movzx   eax, _HalpVectorToIRQL[ecx]     ; (al) = OldIrql
        mov     [edx], al                       ; save OldIrql
        xor     eax, eax                        ; return TRUE
        or      eax, 1

        fstRET  KeTryToAcquireQueuedSpinLock

ifndef NT_UP

taqsl60:
        ; The lock is already held by another processor.  Indicate
        ; failure to the caller.

        popfd                                   ; restore interrupt state
        add     esp, 8                          ; free locals
        xor     eax, eax                        ; return FALSE
        fstRET  KeTryToAcquireQueuedSpinLock

if DBG

cPublicFpo 0,2

taqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,ecx,edx,0,0>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeTryToAcquireQueuedSpinLock
_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpswint.asm ===
title   "Software Interrupts"
;++
;
; Copyright (c) 1992  Microsoft Corporation
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
; Module Name:
;
;    mpswint.asm
;
; Abstract:
;
;    This module implements the software interrupt handlers for
;    APIC-based PC+MP multiprocessor systems.
;
; Author:
;
;    John Vert (jvert) 2-Jan-1992
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Ron Mosgrove (Intel) - Modified for PC+MP systems
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include apic.inc
include ntapic.inc
include i386\kimacro.inc
        .list

        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _KiDeliverApc,3,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT

        extrn  _HalpIRQLtoTPR:byte

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Request Software Interrupt"
;++
;
; VOID
; FASTCALL
; HalRequestSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to request a software interrupt of
;   the system.
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

; equates for accessing arguments
;

cPublicFastCall HalRequestSoftwareInterrupt ,1
cPublicFpo 0,0

        cmp     cl, PCR[PcHal.ShortDpc]
        je      short rsi10

        xor     eax, eax
        mov     al, cl                      ; get irql

;
; In an APIC based system the TPR is the IDTEntry
;

        xor     ecx, ecx
        mov     cl, _HalpIRQLtoTPR[eax]     ; get IDTEntry for IRQL

;
; Build the ICR Command - Fixed Delivery to Self, IDTEntry == al
;

        or      ecx, (DELIVER_FIXED OR ICR_SELF)

;
; Make sure the ICR is available
;

        pushfd                             ; save interrupt mode
        cli                                ; disable interrupt
        STALL_WHILE_APIC_BUSY

;
; Now write the command to the Memory Mapped Register
;

        mov     dword ptr APIC[LU_INT_CMD_LOW], ecx

;
;   We have to wait for the request to be delivered.
;   If we don't wait here, then we will return to the caller
;   before the request has been issued.
;
        STALL_WHILE_APIC_BUSY

        popfd                   ; restore original interrupt mode
        fstRET  HalRequestSoftwareInterrupt

;
; Requesting a DPC interrupt when ShortDpc is set.  Just set the
; DpcPending flag - whomever set ShortDpc will check the flag
; at the proper time
;

rsi10:  mov     PCR[PcHal.DpcPending], 1
        fstRET  HalRequestSoftwareInterrupt

fstENDP HalRequestSoftwareInterrupt

        page ,132
        subttl  "Clear Software Interrupt"

;++
;
; VOID
; HalClearSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to clear a possible pending software interrupt.
;   Support for this function is optional, and allows the kernel to
;   reduce the number of spurious software interrupts it receives/
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalClearSoftwareInterrupt ,1
        fstRET  HalClearSoftwareInterrupt
fstENDP HalClearSoftwareInterrupt


        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; VOID
; HalpDispatchInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is the interrupt handler for a software interrupt generated
;    at DISPATCH_LEVEL.  Its function is to save the machine state, raise
;    Irql to DISPATCH_LEVEL, dismiss the interrupt, and call the DPC
;    delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--


        ENTER_DR_ASSIST hdpi_a, hdpi_t

cPublicProc  _HalpDispatchInterrupt ,0

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT hdpi_a, hdpi_t

        mov     eax, DPC_VECTOR

        mov     esi, dword ptr APIC[LU_TPR]     ; get the old TPR
        mov     dword ptr APIC[LU_TPR], eax     ; set the TPR

        sti                                     ; and allow interrupts

        APICFIX edx

        mov     dword ptr APIC[LU_EOI], 0       ; send EOI to APIC local unit
        APICFIX edx

        ;
        ; Go do Dispatch Interrupt processing
        ;

di10:   stdCall _KiDispatchInterrupt

        cli
        mov     dword ptr APIC[LU_TPR], esi     ; reset the TPR

;
; We have to ensure that the requested priority is set before
; we return.  The caller is counting on it.
;
        mov     ecx, dword ptr APIC[LU_TPR]
        CHECKTPR    ecx, esi

        ;
        ; Do interrupt exit processing without EOI
        ;

        SPURIOUS_INTERRUPT_EXIT
stdENDP _HalpDispatchInterrupt

        page ,132
        subttl  "APC Interrupt"
;++
;
; HalpApcInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at APC_LEVEL. Its function is to save the machine state, raise Irql to
;    APC_LEVEL, dismiss the interrupt, and call the APC delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is Disabled
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST hapc_a, hapc_t

;
; Save machine state in trap frame
;

cPublicProc  _HalpApcInterrupt ,0

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT hapc_a, hapc_t


        mov     eax, APC_VECTOR

        mov     ecx, dword ptr APIC[LU_TPR]     ; get the old TPR
        push    ecx                             ; save it
        mov     dword ptr APIC[LU_TPR], eax     ; set the TPR

        APICFIX edx
        mov     dword ptr APIC[LU_EOI], 0       ; send EOI to APIC local unit
        APICFIX edx

        sti                                     ; and allow interrupts

        mov     eax, [ebp]+TsSegCs              ; get interrupted code's CS
        and     eax, MODE_MASK                  ; extract the mode

        ; call APC deliver routine
        ;       Previous mode
        ;       Null exception frame
        ;       Trap frame

        stdCall   _KiDeliverApc, <eax, 0,ebp>

        pop     eax

        cli
        mov     dword ptr APIC[LU_TPR], eax     ; reset the TPR

;
; We have to ensure that the requested priority is set before
; we return.  The caller is counting on it.
;
        mov     ecx, dword ptr APIC[LU_TPR]
        CHECKTPR    ecx, eax

        ;
        ; Do interrupt exit processing without EOI
        ;

        SPURIOUS_INTERRUPT_EXIT

stdENDP _HalpApcInterrupt


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpsproc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpsproc.c

Abstract:

    PC+MP Start Next Processor c code.

    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for a
    PC+MP System

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

    Ron Mosgrove (Intel) - Modified to support the PC+MP
    Jake Oshins (jakeo) - Modified for ACPI MP machines 22-Dec-1997

--*/

#if !defined(_HALPAE_)
#define _HALPAE_
#endif

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"
#include "stdio.h"
#ifdef ACPI_HAL
#include "acpitabl.h"
#endif

#ifdef DEBUGGING

void
HalpDisplayString(
    IN PVOID String
    );

#endif  // DEBUGGING

#if defined(ACPI_HAL)
const ULONG HalDisableFirmwareMapper = 1;
#if !defined(NT_UP)
        const UCHAR HalName[] = "ACPI 1.0 - APIC platform MP";
        #define HalName        L"ACPI 1.0 - APIC platform MP"
        WCHAR HalHardwareIdString[] = L"acpiapic_mp\0";
#else
        const UCHAR HalName[] = "ACPI 1.0 - APIC platform UP";
        #define HalName        L"ACPI 1.0 - APIC platform UP"
        WCHAR MpHalHardwareIdString[] = L"acpiapic_mp\0";
        WCHAR HalHardwareIdString[] = L"acpiapic_up\0";
#endif
#else
const ULONG HalDisableFirmwareMapper = 0;
#if !defined(NT_UP)
        const UCHAR HalName[] = "MPS 1.4 - APIC platform";
        #define HalName        L"MPS 1.4 - APIC platform"
        WCHAR HalHardwareIdString[] = L"mps_mp\0";
#else
        const UCHAR HalName[] = "UP MPS 1.4 - APIC platform";
        #define HalName        L"UP MPS 1.4 - APIC platform"
        WCHAR MpHalHardwareIdString[] = L"mps_mp\0";
        WCHAR HalHardwareIdString[] = L"mps_up\0";
#endif
#endif

#if !defined(NT_UP)
ULONG
HalpStartProcessor (
    IN PVOID InitCodePhysAddr,
    IN ULONG ProcessorNumber
    );
#endif

VOID
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitOtherBuses (
    VOID
    );

VOID
HalpInitializePciBus (
    VOID
    );

VOID
HalpInitializePciStubs (
    VOID
    );

VOID
HalpInheritBusAddressMapInfo (
    VOID
    );

VOID
HalpInitBusAddressMapInfo (
    VOID
    );

VOID
HalpResetThisProcessor (
    VOID
    );

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpApicRebootService);

#ifdef ACPI_HAL
VOID
HalpInitMpInfo (
    IN PMAPIC ApicTable,
    IN ULONG  Phase
    );
extern PMAPIC  HalpApicTable;
#endif

extern VOID (*HalpRebootNow)(VOID);

extern volatile ULONG  HalpNMIInProgress;

volatile ULONG HalpProcessorsNotHalted = 0;

#define LOW_MEMORY          0x000100000

//
// From hal386.inc
//

#define IDT_NMI_VECTOR      2
#define D_INT032            0x8E00

#if !defined(KGDT_R0_CODE)
#define KGDT_R0_CODE        0x8
#endif

//
// Defines to let us diddle the CMOS clock and the keyboard
//

#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71


#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64

extern USHORT HalpGlobal8259Mask;
extern PKPCR  HalpProcessorPCR[];
extern struct HalpMpInfo HalpMpInfoTable;

extern ULONG HalpIpiClock;
extern PVOID   HalpLowStubPhysicalAddress;   // pointer to low memory bootup stub
extern PUCHAR  HalpLowStub;                  // pointer to low memory bootup stub

PUCHAR  Halp1stPhysicalPageVaddr;   // pointer to physical memory 0:0
PUSHORT MppProcessorAvail;          // pointer to processavail flag
ULONG   HalpDontStartProcessors = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitMP)
#pragma alloc_text(INIT,HalAllProcessorsStarted)
#pragma alloc_text(INIT,HalReportResourceUsage)
#pragma alloc_text(INIT,HalpInitOtherBuses)
#if !defined(NT_UP)
#pragma alloc_text(PAGELK,HalpStartProcessor)
#endif
#endif



VOID
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:
    Allows MP initialization from HalInitSystem.

Arguments:
    Same as HalInitSystem

Return Value:
    None.

--*/
{
    PKPCR   pPCR;
    PHYSICAL_ADDRESS physicalAddress;


    pPCR = KeGetPcr();

    //
    //  Increment a count of the number of processors
    //  running NT, This could be different from the
    //  number of enabled processors, if one or more
    //  of the processor failed to start.
    //
    if (Phase == 1)
        HalpMpInfoTable.NtProcessors++;
#ifdef DEBUGGING
    sprintf(Cbuf, "HalpInitMP: Number of Processors = 0x%x\n",
        HalpMpInfoTable.NtProcessors);

    HalpDisplayString(Cbuf);
#endif

    if (Phase == 0) {

#if defined(NT_UP)

        //
        // On UP build - done
        //

        return ;
#endif

        //
        // Map the 1st Physical page of memory
        //
        physicalAddress.QuadPart = 0;
        Halp1stPhysicalPageVaddr = HalpMapPhysicalMemoryWriteThrough (physicalAddress, 1);

        //
        //  Allocate some low memory for processor bootup stub
        //

        HalpLowStubPhysicalAddress =
        UlongToPtr(HalpAllocPhysicalMemory (LoaderBlock,
                                            LOW_MEMORY, 1, FALSE));

        if (!HalpLowStubPhysicalAddress) {
            //
            //  Can't get memory
            //

#if DBG
            DbgPrint("HAL: can't allocate memory to start processors\n");
#endif
            return;
        }

        physicalAddress.QuadPart = (ULONGLONG)HalpLowStubPhysicalAddress;
        HalpLowStub = (PCHAR) HalpMapPhysicalMemory (physicalAddress, 1);

    } else {

        //
        //  Phase 1 for another processor
        //
        if (CurrentPrcb(pPCR)->Number != 0) {
            HalpIpiClock = 0xff;
        }

#ifdef ACPI_HAL
        HalpInitMpInfo(HalpApicTable, Phase);
#endif
    }
}



BOOLEAN
HalAllProcessorsStarted (
    VOID
    )
{
    if (KeGetPcr()->Number == 0) {

        if (HalpFeatureBits & HAL_PERF_EVENTS) {

            //
            // Enable local perf events on each processor
            //

            HalpGenericCall (
                HalpEnablePerfInterupt,
                0,
                HalpActiveProcessors
                );

        }

#if !defined(_AMD64_)
        if (HalpFeatureBits & HAL_NO_SPECULATION) {

            //
            // Processor doesn't perform speculative execeution,
            // remove fences in critical code paths
            //

            HalpRemoveFences ();
        }
#endif
    }

    return TRUE;
}

VOID
HalpInitOtherBuses (
    VOID
    )
{

    //
    // Registry is now intialized, see if there are any PCI buses
    //
}

VOID
HalReportResourceUsage (
    VOID
    )
/*++

Routine Description:
    The registery is now enabled - time to report resources which are
    used by the HAL.

Arguments:

Return Value:

--*/
{
    UNICODE_STRING  UHalName;
    INTERFACE_TYPE  interfacetype;

    //
    // Initialize phase 2
    //

    HalInitSystemPhase2 ();

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();
    HalpInitializePciStubs ();

#ifndef ACPI_HAL  // ACPI HALs don't deal with address maps
    //
    // Update supported address info with MPS bus address map
    //

    HalpInitBusAddressMapInfo ();

    //
    // Inherit any bus address mappings from MPS hierarchy descriptors
    //

    HalpInheritBusAddressMapInfo ();

#endif
    //
    // Set type
    //

    switch (HalpBusType) {
        case MACHINE_TYPE_ISA:  interfacetype = Isa;            break;
        case MACHINE_TYPE_EISA: interfacetype = Eisa;           break;
        case MACHINE_TYPE_MCA:  interfacetype = MicroChannel;   break;
        default:                interfacetype = PCIBus;         break;
    }

    //
    // Report HALs resource usage
    //

    RtlInitUnicodeString (&UHalName, HalName);

    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        interfacetype
    );

#ifndef ACPI_HAL  // ACPI HALs don't deal with address maps
    //
    // Register hibernate support
    //
    HalpRegisterHibernate();
#endif

    HalpRegisterPciDebuggingDeviceInfo();
}


VOID
HalpResetAllProcessors (
    VOID
    )
/*++

Routine Description:

    This procedure is called by the HalpReboot routine.  It is called in
    response to a system reset request.

    This routine generates a reboot request via the APIC's ICR.

    This routine will NOT return.

--*/
{
    ULONG_PTR j;
    PKGDTENTRY GdtPtr;
    ULONG TssAddr;
    PKPRCB  Prcb;

#if defined(_AMD64_)
    PKIDTENTRY64 idtEntry;
    KIDT_HANDLER_ADDRESS handler;

    handler.Address = (ULONG64)HalpApicRebootService;
#endif

    if (HalpNMIInProgress) {
        //
        //  If we are in an NMI then none of the code below is going to work so just reset the old fashion way
        //
        HalpWriteResetCommand();
    }

#ifndef NT_UP
    HalpProcessorsNotHalted = HalpMpInfoTable.NtProcessors;
#else
    //
    //  Only this processor needs to be halted
    //
    HalpProcessorsNotHalted = 1;
#endif

    //
    // Set all processors NMI handlers
    //

    for (j = 0; j < HalpMpInfoTable.NtProcessors; ++j)  {

#if defined(_AMD64_)

        idtEntry = &HalpProcessorPCR[j]->IdtBase[IDT_NMI_VECTOR];
        idtEntry->OffsetLow = handler.OffsetLow;
        idtEntry->OffsetMiddle = handler.OffsetMiddle;
        idtEntry->OffsetHigh = handler.OffsetHigh;

#else

        GdtPtr = &HalpProcessorPCR[j]->
                   GDT[HalpProcessorPCR[j]->IDT[IDT_NMI_VECTOR].Selector >> 3];
        TssAddr = (((GdtPtr->HighWord.Bits.BaseHi << 8) +
                   GdtPtr->HighWord.Bits.BaseMid) << 16) + GdtPtr->BaseLow;
        ((PKTSS)TssAddr)->Eip = (ULONG)HalpApicRebootService;

#endif

    }

    if (HalpProcessorsNotHalted > 1) {

        //
        //  Wait for the ICR to become free
        //

        if (HalpWaitForPending (0xFFFF, pLocalApic + LU_INT_CMD_LOW/4)) {

            //
            // For P54c or better processors, reboot by sending all processors
            // NMIs.  For pentiums we send interrupts, since there are some
            // pentium MP machines where the NMIs method does not work.
            //
            // The NMI method is better.
            //

            Prcb = KeGetCurrentPrcb();
            j = Prcb->CpuType << 16 | (Prcb->CpuStep & 0xff00);
            if (j > 0x50100) {

                //
                // Get other processors attention with an NMI
                //
                // BUGBUG if we're in cluster mode?
                //

                j = HalpActiveProcessors & ~Prcb->SetMember;
                j = j << DESTINATION_SHIFT;
                pLocalApic[LU_INT_CMD_HIGH/4] = (ULONG)j;
                pLocalApic[LU_INT_CMD_LOW/4] = (ICR_USE_DEST_FIELD | LOGICAL_DESTINATION | DELIVER_NMI);

                //
                // Wait 5ms and see if any processors took the NMI.  If not,
                // go do it the old way.
                //

                KeStallExecutionProcessor(5000);
                if (HalpProcessorsNotHalted != HalpMpInfoTable.NtProcessors) {

                    //
                    // Reboot local
                    //

#if defined(_AMD64_)
                    HalpApicRebootService(NULL,NULL);
#else
                    HalpApicRebootService();
#endif
                }
            }

            //
            // Signal other processors which also may be waiting to
            // reboot the machine, that it's time to go
            //

            HalpRebootNow = HalpResetThisProcessor;

            //
            // Send a reboot interrupt
            //

            pLocalApic[LU_INT_CMD_LOW/4] = (ICR_ALL_INCL_SELF | APIC_REBOOT_VECTOR);

            //
            //  we're done - set TPR to zero so the reboot interrupt will happen
            //

            pLocalApic[LU_TPR/4] = 0;
            HalpEnableInterrupts();
            for (; ;) ;
        }
    }

    //
    //  Reset the old fashion way
    //
    HalpWriteResetCommand();    

}

VOID
HalpResetThisProcessor (
    VOID
    )
/*++

Routine Description:

    This procedure is called by the HalpReboot routine.
    It is called in response to a system reset request.

    This routine is called by the reboot ISR (linked to
    APIC_REBOOT_VECTOR).  The HalpResetAllProcessors
    generates the reboot request via the APIC's ICR.

    The function of this routine is to perform any processor
    specific shutdown code needed and then reset the system
    (on the BSP==P0 only).

    This routine will NOT return.

--*/
{
    PUSHORT   Magic;
    ULONG ThisProcessor = 0;
    ULONG i, j, max, RedirEntry;
    struct ApicIoUnit *IoUnitPtr;
    PHYSICAL_ADDRESS physicalAddress;

    ThisProcessor = CurrentPrcb(KeGetPcr())->Number;

    //
    //  Do whatever is needed to this processor to restore
    //  system to a bootable state
    //

    pLocalApic[LU_TPR/4] = 0xff;
    pLocalApic[LU_TIMER_VECTOR/4] =
        (APIC_SPURIOUS_VECTOR |PERIODIC_TIMER | INTERRUPT_MASKED);
    pLocalApic[LU_INT_VECTOR_0/4] =
        (APIC_SPURIOUS_VECTOR | INTERRUPT_MASKED);
    pLocalApic[LU_INT_VECTOR_1/4] =
        ( LEVEL_TRIGGERED | ACTIVE_HIGH | DELIVER_NMI |
                 INTERRUPT_MASKED | NMI_VECTOR);
    if (HalpMpInfoTable.ApicVersion != APIC_82489DX) {
        pLocalApic[LU_FAULT_VECTOR/4] =
            APIC_FAULT_VECTOR | INTERRUPT_MASKED;
    }

    if (ThisProcessor == 0) {

        InterlockedDecrement(&HalpProcessorsNotHalted);

        //
        //  we are running on the BSP, wait for everyone to
        //  complete the re-initialization code above
        //

        while (InterlockedAnd(&HalpProcessorsNotHalted,0xffffffff) != 0) {
            ;
        }

        KeStallExecutionProcessor(100);
        
        //
        //  Write the Shutdown reason code, so the BIOS knows
        //  this is a reboot
        //

        WRITE_PORT_UCHAR(CMOS_CTRL, 0x0f);  // CMOS Addr 0f

        WRITE_PORT_UCHAR(CMOS_DATA, 0x00);  // Reason Code Reset

        physicalAddress.QuadPart = 0;
        Magic = HalpMapPhysicalMemoryWriteThrough(physicalAddress, 1);
        Magic[0x472 / sizeof(USHORT)] = 0x1234;     // warm boot

        //
        // If required, disable APIC mode
        //

        if (HalpMpInfoTable.IMCRPresent)
        {
            WRITE_PORT_UCHAR(UlongToPtr(ImcrRegPortAddr),ImcrPort);
            KeStallExecutionProcessor(100);
            WRITE_PORT_UCHAR(UlongToPtr(ImcrDataPortAddr),ImcrDisableApic);
        }

        KeStallExecutionProcessor(100);

        for (j=0; j<HalpMpInfoTable.IOApicCount; j++) {
            IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoTable.IoApicBase[j];

            //
            //  Disable all interrupts on IO Unit
            //

            IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
            max = ((IoUnitPtr->RegisterWindow >> 16) & 0xff) * 2;
            for (i=0; i <= max; i += 2) {
                IoUnitPtr->RegisterSelect  = IO_REDIR_00_LOW + i;
                IoUnitPtr->RegisterWindow |= INT_VECTOR_MASK | INTERRUPT_MASKED;

                //
                // Clear any set Remote IRR bits by programming the entry to
                // edge and then back to level. Otherwise there will be
                // no further interrupts from this source.
                //

                IoUnitPtr->RegisterSelect  = IO_REDIR_00_LOW + i;
                RedirEntry = IoUnitPtr->RegisterWindow;
                if ( (RedirEntry & LEVEL_TRIGGERED)  &&  (RedirEntry & REMOTE_IRR))  {
                    RedirEntry &= ~LEVEL_TRIGGERED;
                    IoUnitPtr->RegisterWindow = RedirEntry;
                    RedirEntry = IoUnitPtr->RegisterWindow;
                    RedirEntry |= LEVEL_TRIGGERED;
                    IoUnitPtr->RegisterWindow = RedirEntry;
                }
            }
        } // for all Io Apics

        //
        //  Disable the Local Apic
        //
        pLocalApic[LU_SPURIOUS_VECTOR/4] =
            (APIC_SPURIOUS_VECTOR | LU_UNIT_DISABLED);


        KeStallExecutionProcessor(100);

        HalpDisableInterrupts();

        //
        //  Enable Pic interrupts
        //
        HalpGlobal8259Mask = 0;
        HalpSet8259Mask ((USHORT) HalpGlobal8259Mask);

        KeStallExecutionProcessor(1000);

        //
        //  Finally, reset the system.
        //
        HalpWriteResetCommand();    


    } else {
        //
        // We're running on a processor other than the BSP
        //

        //
        //  Disable the Local Apic
        //

        pLocalApic[LU_SPURIOUS_VECTOR/4] =
            (APIC_SPURIOUS_VECTOR | LU_UNIT_DISABLED);

        KeStallExecutionProcessor(100);

        //
        //  Now we are done, tell the BSP
        //

        InterlockedDecrement(&HalpProcessorsNotHalted);
        
    }   // Not BSP


    //
    //  Everyone stops here until reset
    //

    HalpDisableInterrupts();
    while (TRUE) {
        HalpHalt();
    }
}

#if !defined(NT_UP)
ULONG
HalpStartProcessor (
    IN PVOID InitCodePhysAddr,
    IN ULONG ProcessorNumber
    )
/*++

Routine Description:

    Actually Start the Processor in question.  This routine
    assumes the init code is setup and ready to run.  The real
    mode init code must begin on a page boundry.

    NOTE: This assumes the BSP is entry 0 in the MP table.

    This routine cannot fail.

Arguments:
    InitCodePhysAddr - execution address of init code

Return Value:
    0    - Something prevented us from issuing the reset.

    n    - Processor's PCMP Local APICID + 1
--*/
{
    NTSTATUS status;
    UCHAR ApicID;
    PVULONG LuDestAddress = (PVULONG) (LOCALAPIC + LU_INT_CMD_HIGH);
    PVULONG LuICR = (PVULONG) (LOCALAPIC + LU_INT_CMD_LOW);
#define DEFAULT_DELAY   100
    ULONG DelayCount = DEFAULT_DELAY;
    ULONG ICRCommand,i;

    ASSERT((((ULONG_PTR) InitCodePhysAddr) & 0xfff00fff) == 0);

    if (ProcessorNumber >= HalpMpInfoTable.ProcessorCount)  {
        return(0);
    }

    //
    //  Get the APIC ID of the processor to start.
    //

    status = HalpGetNextProcessorApicId(ProcessorNumber,
                                        &ApicID);

    if (!NT_SUCCESS(status)) {
#ifdef DEBUGGING
        HalpDisplayString("HAL: HalpStartProcessor: No Processor Available\n");
#endif
        return(0);
    }

    if (HalpDontStartProcessors)
        return ApicID+1;

    //
    //  Make sure we can get to the Apic Bus
    //

    KeStallExecutionProcessor(200);
    if (HalpWaitForPending (DEFAULT_DELAY, LuICR) == 0) {
        //
        //  We couldn't find a processor to start
        //
#ifdef DEBUGGING
        HalpDisplayString("HAL: HalpStartProcessor: can't access APIC Bus\n");
#endif
        return 0;
    }

    // For a P54 C/CM system, it is possible that the BSP is the P54CM and the
    // P54C is the Application processor. The P54C needs an INIT (reset)
    // to restart,  so we issue a reset regardless of whether we a 82489DX
    // or an integrated APIC.

    //
    //  This system is based on the original 82489DX's.
    //  These devices do not support the Startup IPI's.
    //  The mechanism used is the ASSERT/DEASSERT INIT
    //  feature of the local APIC.  This resets the
    //  processor.
    //

#ifdef DEBUGGING
    sprintf(Cbuf, "HAL: HalpStartProcessor: Reset IPI to ApicId %d (0x%x)\n",
                ApicID,((ULONG) ApicID) << DESTINATION_SHIFT );
    HalpDisplayString(Cbuf);
#endif

    //
    //  We use a Physical Destination
    //

    *LuDestAddress = ((ULONG) ApicID) << DESTINATION_SHIFT;

    //
    //  Now Assert reset and drop it
    //

    *LuICR = LU_RESET_ASSERT;
    KeStallExecutionProcessor(10);
    *LuICR = LU_RESET_DEASSERT;
    KeStallExecutionProcessor(200);

    if (HalpMpInfoTable.ApicVersion == APIC_82489DX) {
        return ApicID+1;
    }

    //
    //  Set the Startup Address as a vector and combine with the
    //  ICR bits
    //
    ICRCommand = (ULONG)((((ULONG_PTR) InitCodePhysAddr & 0x000ff000) >> 12)
                | LU_STARTUP_IPI);

#ifdef DEBUGGING
    sprintf(Cbuf, "HAL: HalpStartProcessor: Startup IPI (0x%x) to ApicId %d (0x%x)\n",
                    ICRCommand, ApicID, ((ULONG) ApicID) << DESTINATION_SHIFT );
    HalpDisplayString(Cbuf);
#endif

    //
    //  Set the Address of the APIC again, this may not be needed
    //  but it can't hurt.
    //
    *LuDestAddress = (ApicID << DESTINATION_SHIFT);
    //
    //  Issue the request
    //
    *LuICR = ICRCommand;
    KeStallExecutionProcessor(200);

    //
    //  Repeat the Startup IPI.  This is because the second processor may
    //  have been issued an INIT request.  This is generated by some BIOSs.
    //
    //  On older processors (286) BIOS's use a mechanism called triple
    //  fault reset to transition from protected mode to real mode.
    //  This mechanism causes the processor to generate a shutdown cycle.
    //  The shutdown is typically issued by the BIOS building an invalid
    //  IDT and then generating an interrupt.  Newer processors have an
    //  INIT line that the chipset jerks when it sees a shutdown cycle
    //  issued by the processor.  The Phoenix BIOS, for example, has
    //  integrated support for triple fault reset as part of their POST
    //  (Power On Self Test) code.
    //
    //  When the P54CM powers on it is held in a tight microcode loop
    //  waiting for a Startup IPI to be issued and queuing other requests.
    //  When the POST code executes the triple fault reset test the INIT
    //  cycle is queued by the processor. Later, when a Startup IPI is
    //  issued to the CM, the CM starts and immediately gets a INIT cycle.
    //  The effect from a software standpoint is that the processor is
    //  never started.
    //
    //  The work around implemented here is to issue two Startup IPI's.
    //  The first allows the INIT to be processed and the second performs
    //  the actual startup.
    //

    //
    //  Make sure we can get to the Apic Bus
    //


    if (HalpWaitForPending (DEFAULT_DELAY, LuICR) == 0) {
        //
        //  We're toast, can't gain access to the APIC Bus
        //
#ifdef DEBUGGING
        HalpDisplayString("HAL: HalpStartProcessor: can't access APIC Bus\n");
#endif
        return 0;
    }

    //
    //  Allow Time for any Init request to be processed
    //
    KeStallExecutionProcessor(100);

    //
    //  Set the Address of the APIC again, this may not be needed
    //  but it can't hurt.
    //
    *LuDestAddress = (ApicID << DESTINATION_SHIFT);
    //
    //  Issue the request
    //
    *LuICR = ICRCommand;

    KeStallExecutionProcessor(200);
    return ApicID+1;
}
#endif  // !NT_UP


ULONG
FASTCALL
HalSystemVectorDispatchEntry (
    IN ULONG Vector,
    OUT PKINTERRUPT_ROUTINE **FlatDispatch,
    OUT PKINTERRUPT_ROUTINE *NoConnection
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\pmpcisup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\pmpcisup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpsys.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpsys.c

Abstract:


    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for a
    PC+MP system.

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode only.

Revision History:


*/

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"

#define STATIC  // functions used internal to this module

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpApicSpuriousService);
HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpLocalApicErrorService);

VOID
HalpBuildIpiDestinationMap (
    VOID
    );

VOID
HalpInitializeLocalUnit (
    VOID
    );

STATIC UCHAR
HalpPcMpIoApicById (
    IN UCHAR IoApicId
    );

UCHAR
HalpAddInterruptDest(
    IN UCHAR CurrentDest,
    IN UCHAR ThisCpu
    );

UCHAR
HalpRemoveInterruptDest(
    IN UCHAR CurrentDest,
    IN UCHAR ThisCpu
    );

UCHAR
HalpMapNtToHwProcessorId(
    IN UCHAR Number
    );

VOID
HalpRestoreIoApicRedirTable (
    VOID
    );

#if defined(_AMD64_)

BOOLEAN
PicNopHandlerInt (
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

BOOLEAN
PicInterruptHandlerInt (
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

#endif

KAFFINITY HalpNodeAffinity[MAX_NODES];
ULONG HalpMaxNode = 1;

//
//  Counters used to determine the number of interrupt enables that
//  require the Local APIC Lint0 Extint enabled
//

UCHAR Halp8259Counts[16]    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

//
//  All possible I/O APIC Sources, arranged linearly from first I/O APIC to
//  last.  Divisions between I/O APICs are implied by HalpMaxApicInti[N]
//
INTI_INFO   HalpIntiInfo[MAX_INTI];

//
//  Number of sources in I/O APIC [n]
//
USHORT      HalpMaxApicInti[MAX_IOAPICS];


INTERRUPT_DEST HalpIntDestMap[MAX_PROCESSORS];

               

extern BOOLEAN HalpHiberInProgress;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpCheckELCR)
#pragma alloc_text(PAGELK, HalpInitializeIOUnits)
#pragma alloc_text(PAGELK, HalpInitializeLocalUnit)
#pragma alloc_text(PAGELK, HalpEnableNMI)
#pragma alloc_text(PAGELK, HalpEnablePerfInterupt)
#pragma alloc_text(PAGELK, HalpRestoreIoApicRedirTable)
#pragma alloc_text(PAGELK, HalpUnMapIOApics)
#pragma alloc_text(PAGELK, HalpPostSleepMP)
#endif

//
// BEWARE -- this has to match the structure ADDRESS_USAGE.
#pragma pack(push, 1)
struct {
    struct _HalAddressUsage *Next;
    CM_RESOURCE_TYPE        Type;
    UCHAR                   Flags;
    struct {
        ULONG   Start;
        ULONG   Length;
    }                       Element[MAX_IOAPICS+2];
} HalpApicUsage;
#pragma pack(pop)

VOID
HalpCheckELCR (
    VOID
    )
{
    USHORT      elcr;
    ULONG       IsaIrq;
    USHORT      Inti;

    if (HalpELCRChecked) {
        return ;
    }

    HalpELCRChecked = TRUE;


    //
    // It turns out interrupts which are fed through the ELCR before
    // going to the IOAPIC get inverted.  So...  here we *assume*
    // the polarity of any ELCR level inti not declared in the MPS linti
    // table as being active_high instead of what they should be (which
    // is active_low).  Any system which correctly delivers these intis
    // to an IOAPIC will need to declared the correct polarity in the
    // MPS table.
    //

    elcr = READ_PORT_UCHAR ((PUCHAR) 0x4d1) << 8 | READ_PORT_UCHAR((PUCHAR) 0x4d0);
    if (elcr == 0xffff) {
        return ;
    }

    for (IsaIrq = 0; elcr; IsaIrq++, elcr >>= 1) {
        if (!(elcr & 1)) {
            continue;
        }

        if (HalpGetApicInterruptDesc (Eisa, 0, IsaIrq, &Inti)) {

            //
            // If the MPS passed Polarity for this Inti
            // is "bus default" change it to be "active high".
            //

            if (HalpIntiInfo[Inti].Polarity == 0) {
                HalpIntiInfo[Inti].Polarity = 1;
            }
        }
    }
}


STATIC VOID
HalpSetRedirEntry (
    IN USHORT InterruptInput,
    IN ULONG  Entry,
    IN ULONG  Destination
    )
/*++

Routine Description:

    This procedure sets a IO Unit Redirection Table Entry

Arguments:

    IoUnit - The IO Unit to modify (zero Based)

    InterruptInput - The input line we're interested in

    Entry - the lower 32 bits of the redir table

    Destination - the upper 32 bits on the entry

Return Value:

    None.

--*/
{
    struct ApicIoUnit *IoUnitPtr;
    ULONG  RedirRegister;
    UCHAR  IoUnit;

    for (IoUnit=0; IoUnit < MAX_IOAPICS; IoUnit++) {
        if (InterruptInput+1 <= HalpMaxApicInti[IoUnit]) {
            break;
        }
        InterruptInput -= HalpMaxApicInti[IoUnit];
    }

    ASSERT (IoUnit < MAX_IOAPICS);

    IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoTable.IoApicBase[IoUnit];

    RedirRegister = InterruptInput*2 + IO_REDIR_00_LOW;

    IoUnitPtr->RegisterSelect = RedirRegister+1;
    IoUnitPtr->RegisterWindow = Destination;

    IoUnitPtr->RegisterSelect = RedirRegister;
    IoUnitPtr->RegisterWindow = Entry;

}

STATIC VOID
HalpGetRedirEntry (
    IN USHORT InterruptInput,
    IN PULONG Entry,
    IN PULONG Destination
    )
/*++

Routine Description:

    This procedure sets a IO Unit Redirection Table Entry

Arguments:

    IoUnit - The IO Unit to modify (zero Based)

    InterruptInput - The input line we're interested in

    Entry - the lower 32 bits of the redir table

    Destination - the upper 32 bits on the entry

Return Value:

    None.

--*/
{
    struct ApicIoUnit *IoUnitPtr;
    ULONG  RedirRegister;
    UCHAR  IoUnit;

    for (IoUnit=0; IoUnit < MAX_IOAPICS; IoUnit++) {
        if (InterruptInput+1 <= HalpMaxApicInti[IoUnit]) {
            break;
        }
        InterruptInput -= HalpMaxApicInti[IoUnit];
    }

    ASSERT (IoUnit < MAX_IOAPICS);

    IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoTable.IoApicBase[IoUnit];

    RedirRegister = InterruptInput*2 + IO_REDIR_00_LOW;

    IoUnitPtr->RegisterSelect = RedirRegister+1;
    *Destination = IoUnitPtr->RegisterWindow;

    IoUnitPtr->RegisterSelect = RedirRegister;
    *Entry = IoUnitPtr->RegisterWindow;

}


STATIC VOID
HalpEnableRedirEntry(
    IN USHORT InterruptInput,
    IN ULONG  Entry,
    IN UCHAR  Cpu
    )
/*++

Routine Description:

    This procedure enables an interrupt via IO Unit
    Redirection Table Entry

Arguments:

    InterruptInput - The input line we're interested in

    Entry - the lower 32 bits of the redir table

    Destination - the upper 32 bits of the entry

Return Value:

    None.

--*/
{
    ULONG Destination;

    //
    // bump Enable Count for this INTI
    //

    HalpIntiInfo[InterruptInput].Entry = (USHORT) Entry;
    HalpIntiInfo[InterruptInput].Destinations = (UCHAR)HalpAddInterruptDest(
        HalpIntiInfo[InterruptInput].Destinations, Cpu);
    Destination = HalpIntiInfo[InterruptInput].Destinations;
    Destination = (Destination << DESTINATION_SHIFT);

    HalpSetRedirEntry (
        InterruptInput,
        Entry,
        Destination
    );

}


VOID
HalpRestoreIoApicRedirTable (
    VOID            
    )
/*++

Routine Description:

    This procedure resets any IoApic inti that is enabled for
    any processor.   This is used during the system wake procedure.


Arguments:

    None.

Return Value:

    None.

--*/
{
    USHORT       InterruptInput;
    KIRQL        OldIrql;

    for(InterruptInput=0; InterruptInput  < MAX_INTI; InterruptInput++) {
        if (HalpIntiInfo[InterruptInput].Destinations) {
            HalpSetRedirEntry (
                InterruptInput,
                HalpIntiInfo[InterruptInput].Entry,
                HalpIntiInfo[InterruptInput].Destinations << DESTINATION_SHIFT
            );
        }
    }
}


STATIC VOID
HalpDisableRedirEntry(
    IN USHORT InterruptInput,
    IN UCHAR  Cpu
    )
/*++

Routine Description:

    This procedure disables a IO Unit Redirection Table Entry
    by setting the mask bit in the Redir Entry.

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    ULONG Entry;
    ULONG Destination;

    //
    // Turn of the Destination bit for this Cpu
    //
    HalpIntiInfo[InterruptInput].Destinations =  HalpRemoveInterruptDest(
        HalpIntiInfo[InterruptInput].Destinations, Cpu);

    //
    //  Get the old entry, the only thing we want is the Entry field
    //

    HalpGetRedirEntry (
        InterruptInput,
        &Entry,
        &Destination
    );

    //
    // Only perform the disable if we've transitioned to zero enables
    //
    if ( HalpIntiInfo[InterruptInput].Destinations == 0) {
        //
        //  Disable the interrupt if no Cpu has it enabled
        //
        Entry |= INTERRUPT_MASKED;

    } else {
        //
        //  Create the new destination field sans this Cpu
        //
        Destination = HalpIntiInfo[InterruptInput].Destinations;
        Destination = (Destination << DESTINATION_SHIFT);
    }

    HalpSetRedirEntry (
        InterruptInput,
        Entry,
        Destination
    );
}

VOID
HalpSet8259Mask (
    IN USHORT Mask
    )
/*++

Routine Description:

    This procedure sets the 8259 Mask to the value passed in

Arguments:

    Mask - The mask bits to set

Return Value:

    None.

--*/
{
    WRITE_PORT_UCHAR(UlongToPtr(PIC1_PORT1),(UCHAR)Mask);
    WRITE_PORT_UCHAR(UlongToPtr(PIC2_PORT1),(UCHAR)(Mask >> 8));
}

#define PIC1_BASE 0x30

STATIC VOID
SetPicInterruptHandler(
    IN USHORT InterruptInput
    )

/*++

Routine Description:

    This procedure sets a handler for a PIC inti

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
#if defined(_AMD64_)

    KiSetHandlerAddressToIDTIrql(PIC1_BASE + InterruptInput,
                                 PicInterruptHandlerInt,
                                 (PVOID)(InterruptInput),
                                 HIGH_LEVEL);

#else

    extern VOID (*PicExtintIntiHandlers[])(VOID);

    VOID (*Hp)(VOID) = PicExtintIntiHandlers[InterruptInput];

    KiSetHandlerAddressToIDT(PIC1_BASE + InterruptInput, Hp);

#endif
}

STATIC VOID
ResetPicInterruptHandler(
    IN USHORT InterruptInput
    )

/*++

Routine Description:

    This procedure sets a handler for a PIC inti to a NOP handler

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{

#if defined(_AMD64_)

    KiSetHandlerAddressToIDTIrql(PIC1_BASE + InterruptInput,
                                 PicNopHandlerInt,
                                 (PVOID)InterruptInput,
                                 HIGH_LEVEL);

#else

    extern VOID (*PicNopIntiHandlers[])(VOID);

    VOID (*Hp)(VOID) = PicNopIntiHandlers[InterruptInput];

    KiSetHandlerAddressToIDT(PIC1_BASE + InterruptInput, Hp);

#endif

}

STATIC VOID
HalpEnablePicInti (
    IN USHORT InterruptInput
    )

/*++

Routine Description:

    This procedure enables a PIC interrupt

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    USHORT PicMask;

    ASSERT(InterruptInput < 16);

    //
    // bump Enable Count for this INTI
    //
    Halp8259Counts[InterruptInput]++;

    //
    // Only actually perform the enable if we've transitioned
    // from zero to one enables
    //
    if ( Halp8259Counts[InterruptInput] == 1) {

        //
        // Set the Interrupt Handler for PIC inti,  this is
        // the routine that fields the EXTINT vector and issues
        // an APIC vector
        //

        SetPicInterruptHandler(InterruptInput);

        PicMask = HalpGlobal8259Mask;
        PicMask &= (USHORT) ~(1 << InterruptInput);
        if (InterruptInput > 7)
            PicMask &= (USHORT) ~(1 << PIC_SLAVE_IRQ);

        HalpGlobal8259Mask = PicMask;
        HalpSet8259Mask ((USHORT) PicMask);

    }
}

STATIC VOID
HalpDisablePicInti(
    IN USHORT InterruptInput
    )

/*++

Routine Description:

    This procedure enables a PIC interrupt

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    USHORT PicMask;

    ASSERT(InterruptInput < 16);

    //
    // decrement Enable Count for this INTI
    //

    Halp8259Counts[InterruptInput]--;

    //
    // Only disable if we have zero enables
    //
    if ( Halp8259Counts[InterruptInput] == 0) {

        //
        // Disable the Interrupt Handler for PIC inti
        //

        ResetPicInterruptHandler(InterruptInput);

        PicMask = HalpGlobal8259Mask;
        PicMask |= (1 << InterruptInput);
        if (InterruptInput > 7) {
            //
            //  This inti is on the slave, see if any other
            //  inti's are enabled.  If none are then disable the
            //  slave
            //
            if ((PicMask & 0xff00) == 0xff00)
                //
                //  All inti's on the slave are disabled
                //
                PicMask |= PIC_SLAVE_IRQ;
        }

        HalpSet8259Mask ((USHORT) PicMask);
        HalpGlobal8259Mask = PicMask;

    }
}

BOOLEAN
HalEnableSystemInterrupt(
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This procedure enables a system interrupt

    Some early implementations using the 82489DX only allow a processor
    to access the IO Unit on it's own 82489DX.  Since we use a single IO
    Unit (P0's) to distribute all interrupts, we have a problem when Pn
    wants to enable an interrupt on these type of systems.

    In order to get around this problem we can take advantage of the fact
    that the kernel calls Enable/Disable on each processor which has a bit
    set in the Affinity mask for the interrupt.  Since we have only one IO
    Unit in use and that Unit is addressable from P0 only, we must set the
    P0 affinity bit for all interrupts.  We can then ignore Enable/Disable
    requests from processors other than P0 since we will always get called
    for P0.

    The right way to do this assuming a single IO Unit accessable to all
    processors, would be to use global counters to determine if the
    interrupt has not been enabled on the IO Unit.  Then enable the IO Unit
    when we transition from no processors to one processor that have the
    interrupt enabled.

Arguments:

    Vector - vector of the interrupt to be enabled

    Irql   - interrupt level of the interrupt to be enabled.

Return Value:

    None.

--*/
{
    PKPCR           pPCR;
    UCHAR           ThisCpu, DevLevel;
    USHORT          InterruptInput;
    ULONG           Entry;
    ULONG           OldLevel;
    INTI_INFO       Inti;

    ASSERT(Vector < (1+MAX_NODES)*0x100-1);
    ASSERT(Irql <= HIGH_LEVEL);

    if ( (InterruptInput = HalpVectorToINTI[Vector]) == 0xffff ) {
        //
        // There is no external device associated with this interrupt
        //

        return(FALSE);
    }

    Inti = HalpIntiInfo[InterruptInput];

    DevLevel = HalpDevLevel
            [InterruptMode == LevelSensitive ? CFG_LEVEL : CFG_EDGE]
            [Inti.Level];

    if (DevLevel & CFG_ERROR) {
        DBGMSG ("HAL: Warning device interrupt mode overridden\n");
    }

    //
    // Block interrupts & synchronize until we're done
    //

    OldLevel = HalpAcquireHighLevelLock (&HalpAccountingLock);

    pPCR = KeGetPcr();
    ThisCpu = CurrentPrcb(pPCR)->Number;

    switch (Inti.Type) {

        case INT_TYPE_INTR: {
            //
            // enable the interrupt in the I/O unit redirection table
            //
            switch (Vector) {
                case APIC_CLOCK_VECTOR:
                    ASSERT(ThisCpu == 0);
                    Entry = APIC_CLOCK_VECTOR | DELIVER_FIXED | LOGICAL_DESTINATION;
                    break;
                case NMI_VECTOR:
                    return FALSE;
                default:
                    Entry = HalVectorToIDTEntry(Vector) | DELIVER_LOW_PRIORITY | LOGICAL_DESTINATION;
                    break;
            }  // switch (Vector)

            Entry |= CFG_TYPE(DevLevel) == CFG_EDGE ? EDGE_TRIGGERED : LEVEL_TRIGGERED;
            Entry |= HalpDevPolarity[Inti.Polarity][CFG_TYPE(DevLevel)] ==
                         CFG_LOW ? ACTIVE_LOW : ACTIVE_HIGH;

            HalpEnableRedirEntry (
                    InterruptInput,
                    Entry,
                    (UCHAR) ThisCpu
                    );

            break;

        }  // case INT_TYPE_INTR:

        case INT_TYPE_EXTINT: {

            //
            // This is an interrupt that uses the IO APIC to route PIC
            // events.  In this case the IO unit has to be enabled and
            // the PIC must be enabled.
            //

            HalpEnableRedirEntry (
                0,                      // WARNING: kenr - assuming 0
                DELIVER_EXTINT | LOGICAL_DESTINATION,
                (UCHAR) ThisCpu
                );
            HalpEnablePicInti(InterruptInput);
            break;
        }  // case INT_TYPE_EXTINT

        default:
            DBGMSG ("HalEnableSystemInterrupt: Unkown Inti Type\n");
            break;
    }  //     switch (IntiType)

    HalpReleaseHighLevelLock (&HalpAccountingLock, OldLevel);
    return TRUE;
}


VOID
HalDisableSystemInterrupt(
    IN ULONG Vector,
    IN KIRQL Irql
    )

/*++


Routine Description:

    Disables a system interrupt.

    Some early implementations using the 82489DX only allow a processor
    to access the IO Unit on it's own 82489DX.  Since we use a single IO
    Unit (P0's) to distribute all interrupts, we have a problem when Pn
    wants to enable an interrupt on these type of systems.

    In order to get around this problem we can take advantage of the fact
    that the kernel calls Enable/Disable on each processor which has a bit
    set in the Affinity mask for the interrupt.  Since we have only one IO
    Unit in use and that Unit is addressable from P0 only, we must set the
    P0 affinity bit for all interrupts.  We can then ignore Enable/Disable
    requests from processors other than P0 since we will always get called
    for P0.

    The right way to do this assuming a single IO Unit accessable to all
    processors, would be to use global counters to determine if the
    interrupt has not been enabled on the IO Unit.  Then enable the IO Unit
    when we transition from no processors to one processor that have the
    interrupt enabled.

Arguments:

    Vector - Supplies the vector of the interrupt to be disabled

    Irql   - Supplies the interrupt level of the interrupt to be disabled

Return Value:

    None.

--*/
{
    PKPCR       pPCR;
    USHORT      InterruptInput;
    UCHAR       ThisCpu;
    ULONG       OldLevel;

    ASSERT(Vector < (1+MAX_NODES)*0x100-1);
    ASSERT(Irql <= HIGH_LEVEL);

    if ( (InterruptInput = HalpVectorToINTI[Vector]) == 0xffff ) {
        //
        // There is no external device associated with this interrupt
        //
        return;
    }

    //
    // Block interrupts & synchronize until we're done
    //

    OldLevel = HalpAcquireHighLevelLock (&HalpAccountingLock);

    pPCR = KeGetPcr();
    ThisCpu = CurrentPrcb(pPCR)->Number;

    switch (HalpIntiInfo[InterruptInput].Type) {

        case INT_TYPE_INTR: {
            //
            // enable the interrupt in the I/O unit redirection table
            //

            HalpDisableRedirEntry( InterruptInput, ThisCpu );
            break;

        }  // case INT_TYPE_INTR:

        case INT_TYPE_EXTINT: {
            //
            // This is an interrupt that uses the IO APIC to route PIC
            // events.  In this case the IO unit has to be enabled and
            // the PIC must be enabled.
            //
            //
            //  WARNING: The PIC is assumed to be routed only through
            //  IoApic[0]Inti[0]
            //
            HalpDisablePicInti(InterruptInput);
            break;
        }

        default:
            DBGMSG ("HalDisableSystemInterrupt: Unkown Inti Type\n");
            break;

    }


    HalpReleaseHighLevelLock (&HalpAccountingLock, OldLevel);
    return;

}

VOID
HalpInitializeIOUnits (
    VOID
    )
/*

 Routine Description:

    This routine initializes the IO APIC.  It only programs the APIC ID Register.

    HalEnableSystemInterrupt programs the Redirection table.

 Arguments:

    None

 Return Value:

    None.

*/

{
    ULONG IoApicId;
    struct ApicIoUnit *IoUnitPtr;
    ULONG i, j, max, regVal;

    for(i=0; i < HalpMpInfoTable.IOApicCount; i++) {

        IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoTable.IoApicBase[i];

        //
        //  write the I/O unit APIC-ID - Since we are using the Processor
        //  Numbers for the local unit ID's we need to set the IO unit
        //  to a high (out of Processor Number range) value.
        //
        IoUnitPtr->RegisterSelect = IO_ID_REGISTER;
        IoApicId = HalpGetIoApicId(i);
        regVal = IoUnitPtr->RegisterWindow;
        regVal &= ~APIC_ID_MASK;
        IoUnitPtr->RegisterWindow = (IoApicId << APIC_ID_SHIFT) | regVal;

        //
        //  mask all vectors on the ioapic
        //

        IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
        max = ((IoUnitPtr->RegisterWindow >> 16) & 0xff) * 2;
        for (j=0; j <= max; j += 2) {
            IoUnitPtr->RegisterSelect  = IO_REDIR_00_LOW + j;
            IoUnitPtr->RegisterWindow |= INT_VECTOR_MASK | INTERRUPT_MASKED;
        }
    }

    if (HalpHiberInProgress)  {
        return;
    }

    //
    // Add resources consumed by APICs
    //

    HalpApicUsage.Next  = NULL;
    HalpApicUsage.Type  = CmResourceTypeMemory;
    HalpApicUsage.Flags = DeviceUsage;

    HalpApicUsage.Element[0].Start = HalpMpInfoTable.LocalApicBase;
    HalpApicUsage.Element[0].Length = 0x400;
    
    ASSERT (HalpMpInfoTable.IOApicCount <= MAX_IOAPICS);
    for (i=0; i < HalpMpInfoTable.IOApicCount; i++) {
        HalpApicUsage.Element[i+1].Start = (ULONG)HalpMpInfoTable.IoApicPhys[i];
        HalpApicUsage.Element[i+1].Length = 0x400;
    }

    HalpApicUsage.Element[i+1].Start = 0;
    HalpApicUsage.Element[i+1].Length = 0;
    HalpRegisterAddressUsage ((ADDRESS_USAGE*)&HalpApicUsage);
}

VOID
HalpEnableNMI (
    VOID
    )
/*

 Routine Description:

    Enable & connect NMI sources for the calling processor.

*/
{
    PKPCR       pPCR;
    USHORT      InterruptInput;
    UCHAR       ThisCpu;
    ULONG       OldLevel;
    ULONG       Entry;

    pPCR = KeGetPcr();
    ThisCpu = CurrentPrcb(pPCR)->Number;

    OldLevel = HalpAcquireHighLevelLock (&HalpAccountingLock);

    HalpEnableLocalNmiSources();

    //
    // Enable any NMI sources found on IOAPICs
    //

    for (InterruptInput=0; InterruptInput < MAX_INTI; InterruptInput++) {
        if (HalpIntiInfo[InterruptInput].Type == INT_TYPE_NMI) {

            Entry = NMI_VECTOR | DELIVER_NMI | LOGICAL_DESTINATION;

            //
            // Halmps has had a bug in it for a long time.  It always connects
            // NMI signals on I/O APICs as level-triggered, active-high.  This
            // hack preserves that behavior for halmps and actually fixes the bug
            // on halacpi.
            //

#ifdef ACPI_HAL
#define POLARITY_HIGH               1
#define POLARITY_LOW                3
#define POLARITY_CONFORMS_WITH_BUS  0

            Entry |= ((HalpIntiInfo[InterruptInput].Level == CFG_EDGE) ? EDGE_TRIGGERED : LEVEL_TRIGGERED);
            Entry |= (((HalpIntiInfo[InterruptInput].Polarity == POLARITY_CONFORMS_WITH_BUS) ||
                       (HalpIntiInfo[InterruptInput].Polarity == POLARITY_HIGH))
                         ? ACTIVE_HIGH : ACTIVE_LOW);
#else
            Entry |= LEVEL_TRIGGERED;
#endif

            HalpEnableRedirEntry (
                InterruptInput,
                Entry,
                (UCHAR) ThisCpu
                );
        }
    }

    HalpReleaseHighLevelLock (&HalpAccountingLock, OldLevel);

    return;
}

VOID
HalpEnablePerfInterupt (
    ULONG_PTR Context
    )
{
    //
    // Enable local processor perf interrupt source
    //

    pLocalApic[LU_PERF_VECTOR/4] = (LEVEL_TRIGGERED | APIC_PERF_VECTOR |
            DELIVER_FIXED | ACTIVE_LOW);
}

UCHAR
HalpAddInterruptDest(
    IN UCHAR CurrentDest,
    IN UCHAR ThisCpu
    )
/*++

Routine Description:

    This routine adds a CPU to the destination processor set of device
    interrupts.

Arguments:

    CurrentDest - The present processor destination set for the interrupt

    ThisCpu - The logical NT processor number which has to be added to the
              interrupt destination mask

Return Value:

    The bitmask corresponding to the new destiantion. This bitmask is suitable
    to be written into the hardware.

--*/
{

    PINTERRUPT_DEST Destination;


    if (HalpMaxProcsPerCluster == 0)  {
        return(HalpIntDestMap[ThisCpu].LogicalId | CurrentDest);
    } else  {
        //
        // The current destination is a hardware cluster & destination ID
        //
        Destination = (PINTERRUPT_DEST)&CurrentDest;

        if (HalpIntDestMap[ThisCpu].Cluster.Hw.ClusterId ==
            Destination->Cluster.Hw.ClusterId)  {
            Destination->Cluster.Hw.DestId |=
                HalpIntDestMap[ThisCpu].Cluster.Hw.DestId;
            return(Destination->Cluster.AsUchar);
        } else  {
            //
            // In cluster mode, each interrupt can be routed only to a single
            // cluster. Replace the existing destination cluster with this one.
            //
            return(HalpIntDestMap[ThisCpu].Cluster.AsUchar);
        }
    }
}


UCHAR
HalpRemoveInterruptDest(
    IN UCHAR CurrentDest,
    IN UCHAR ThisCpu
    )
/*++

Routine Description:

    This routine removes a CPU from the destination processor set of device
    interrupts.

Arguments:

    CurrentDest - The present processor destination set for the interrupt

    ThisCpu - The logical NT processor number which has to be removed from the
              interrupt destination mask

Return Value:

    The bitmask corresponding to the new destiantion. This bitmask is suitable
    to be written into the hardware.

--*/

{
    PINTERRUPT_DEST Destination;

    if (HalpMaxProcsPerCluster == 0)  {
        CurrentDest &= ~(HalpIntDestMap[ThisCpu].LogicalId);
        return(CurrentDest);
    } else  {
        Destination = (PINTERRUPT_DEST)&CurrentDest;
        if (HalpIntDestMap[ThisCpu].Cluster.Hw.ClusterId !=
            Destination->Cluster.Hw.ClusterId)  {
            //
            // We are being asked to remove a processor which is not part
            // of the destination processor set for this interrupt
            //
            return(CurrentDest);
        } else  {
            //
            // Remove this processor and check if it is the last processor
            // in the destination set
            //
            Destination->Cluster.Hw.DestId &=
                ~(HalpIntDestMap[ThisCpu].Cluster.Hw.DestId);
            if (Destination->Cluster.Hw.DestId)  {
                return(Destination->Cluster.AsUchar);
            } else  {
                //
                // There are no processors left in the destination mask.
                // Return 0 so the caller can disable the entry in the IO APIC
                //
                return(0);
            }
        }
    }
}

UCHAR
HalpMapNtToHwProcessorId(
    IN UCHAR Number
    )
/*

 Routine Description:

    This routine maps the logical NT processor number to the hardware cluster
    ID and processor ID for MPS systems.

 Arguments:

    Number: Logical NT processor number(zero based).

 Return Value:

    Bitmask representing the hardware cluster number and processor number for
    this processor. The return value is programmed into the hardware.

*/

{
    INTERRUPT_DEST IntDest;

    if (HalpMaxProcsPerCluster == 0)  {
        return(1 << Number);
    } else  {
        //
        // In systems with heirarchical APIC buses, the BIOS/MPS table has to
        // inform the OS of the underlying topology so we can do this mapping.
        // For now, just assign consecutive cluster IDs starting from 0.
        //
        IntDest.Cluster.Hw.ClusterId = (Number/HalpMaxProcsPerCluster);
        IntDest.Cluster.Hw.DestId = 1 << (Number % HalpMaxProcsPerCluster);
        return(IntDest.Cluster.AsUchar);
    }
}

VOID
HalpInitializeApicAddressing(
    IN UCHAR Number
    )
{
    if (HalpMaxProcsPerCluster == 0)  {
        pLocalApic[LU_DEST_FORMAT/4] = LU_DEST_FORMAT_FLAT;
    }  else  {
        ASSERT(Number <= (HalpMaxProcsPerCluster * MAX_CLUSTERS));
        pLocalApic[LU_DEST_FORMAT/4] = LU_DEST_FORMAT_CLUSTER;
    }

    HalpIntDestMap[Number].LogicalId =  HalpMapNtToHwProcessorId(Number);

    //
    // At this point the Logical ID is a bit map of the processor number
    // the actual ID is the upper byte of the logical destination register
    // Note that this is not strictly true of 82489's.  The 82489 has 32 bits
    // available for the logical ID, but since we want software compatability
    // between the two types of APICs we'll only use the upper byte.
    //
    // Shift the mask into the ID field and write it.
    //
    pLocalApic[LU_LOGICAL_DEST/4] = (ULONG)
        (HalpIntDestMap[Number].LogicalId << DESTINATION_SHIFT);

}


UCHAR
HalpNodeNumber(
    PKPCR pPCR
    )
/*

 Routine Description:

    This routine divines the Node number for the current CPU.
    Node numbers start at 1, and represent the granularity of interrupt
    routing decisions.

 Arguments:

    pPCR - A pointer to the PCR of the current processor.  (This implies
           the caller must have masked interrupts.)

 Return Value:

    None.

*/
{
    // One Node per cluster.
    if (HalpMaxProcsPerCluster != 0)  {
        // One Node per Cluster.
        return(CurrentPrcb(pPCR)->Number/HalpMaxProcsPerCluster + 1);
    } else {
        // One Node per machine.
        return(1);
    }
#if 0
    ULONG   localApicId;

    // One Node per physical CPU package.
    localApicId = *(PVULONG)(LOCALAPIC + LU_ID_REGISTER);
    localApicId &= APIC_ID_MASK;
    localApicId >>= APIC_ID_SHIFT;

    // TODO: Implement cpuid stuff here to determine shift
    return((localApicId>>1) + 1);
#endif
}

VOID
HalpInitializeLocalUnit (
    VOID
    )
/*

 Routine Description:


    This routine initializes the interrupt structures for the local unit
    of the APIC.  This procedure is called by HalInitializeProcessor and
    is executed by each CPU.

 Arguments:

    None

 Return Value:

    None.

*/
{
    PKPCR pPCR;
    PKPRCB prcb;
    ULONG SavedFlags;
    UCHAR Node;

    SavedFlags = HalpDisableInterrupts();

    pPCR = KeGetPcr();
    prcb = CurrentPrcb(pPCR);

    if (prcb->Number ==0) {
        //
        // enable APIC mode
        //
        //  PC+MP Spec has a port defined (IMCR - Interrupt Mode Control
        //  Port) That is used to enable APIC mode.  The APIC could already
        //  be enabled, but per the spec this is safe.
        //

        if (HalpMpInfoTable.IMCRPresent)
        {
#if defined(NEC_98)
            WRITE_PORT_UCHAR(UlongToPtr(ImcrDataPortAddr),ImcrEnableApic);
#else  // defined(NEC_98)
            WRITE_PORT_UCHAR(UlongToPtr(ImcrRegPortAddr),ImcrPort);
            WRITE_PORT_UCHAR(UlongToPtr(ImcrDataPortAddr),ImcrEnableApic);
#endif // defined(NEC_98)
        }

        //
        // By default, use flat logical APIC addressing. If we have more
        // than 8 processors, we must use cluster mode APIC addressing
        //
        if( (HalpMaxProcsPerCluster > 4)        ||
            ((HalpMpInfoTable.ProcessorCount > 8) &&
             (HalpMaxProcsPerCluster == 0)) )  {
            HalpMaxProcsPerCluster = 4;
        }

        if (HalpMpInfoTable.ApicVersion == APIC_82489DX)   {
            //
            // Ignore user's attempt to force cluster mode if running
            // on 82489DX external APIC interrupt controller.
            //
            ASSERT(HalpMpInfoTable.ProcessorCount <= 8);
            HalpMaxProcsPerCluster = 0;
        }
    }

    //
    // Add the current processor to the Node tables.
    //
    Node = HalpNodeNumber(pPCR);
    if (HalpMaxNode < Node) {
        HalpMaxNode = Node;
    }
    HalpNodeAffinity[Node-1] |= (KAFFINITY)1 << prcb->Number;

    //
    // Program the TPR to mask all events
    //
    pLocalApic[LU_TPR/4] = 0xff;
    HalpInitializeApicAddressing(prcb->Number);

    //
    //  Initialize spurious interrupt handling
    //
    KiSetHandlerAddressToIDTIrql(APIC_SPURIOUS_VECTOR,
                                 HalpApicSpuriousService,
                                 NULL,
                                 HIGH_LEVEL);

    pLocalApic[LU_SPURIOUS_VECTOR/4] = (APIC_SPURIOUS_VECTOR | LU_UNIT_ENABLED);

    if (HalpMpInfoTable.ApicVersion != APIC_82489DX)  {
        //
        //  Initialize Local Apic Fault handling
        //
        KiSetHandlerAddressToIDTIrql(APIC_FAULT_VECTOR,
                                     HalpLocalApicErrorService,
                                     NULL,
                                     HIGH_LEVEL);

        pLocalApic[LU_FAULT_VECTOR/4] = APIC_FAULT_VECTOR;
    }

    //
    //  Disable APIC Timer Vector, will be enabled later if needed
    //  We have to program a valid vector otherwise we get an APIC
    //  error.
    //
    pLocalApic[LU_TIMER_VECTOR/4] = (APIC_PROFILE_VECTOR |PERIODIC_TIMER | INTERRUPT_MASKED);

    //
    //  Disable APIC PERF Vector, will be enabled later if needed.
    //  We have to program a valid vector otherwise we get an APIC
    //  error.
    //
    pLocalApic[LU_PERF_VECTOR/4] = (APIC_PERF_VECTOR | INTERRUPT_MASKED);

    //
    //  Disable LINT0, if we were in Virtual Wire mode then this will
    //  have been enabled on the BSP, it may be enabled later by the
    //  EnableSystemInterrupt code
    //
    pLocalApic[LU_INT_VECTOR_0/4] = (APIC_SPURIOUS_VECTOR | INTERRUPT_MASKED);

    //
    //  Program NMI Handling,  it will be enabled on P0 only
    //  RLM Enable System Interrupt should do this
    //

    pLocalApic[LU_INT_VECTOR_1/4] = ( LEVEL_TRIGGERED | ACTIVE_HIGH | DELIVER_NMI |
                     INTERRUPT_MASKED | ACTIVE_HIGH | NMI_VECTOR);

    //
    //  Synchronize Apic IDs - InitDeassertCommand is sent to all APIC
    //  local units to force synchronization of arbitration-IDs with APIC-IDs.
    //
    //  NOTE: we don't have to worry about synchronizing access to the ICR
    //  at this point.
    //

    pLocalApic[LU_INT_CMD_LOW/4] = (DELIVER_INIT | LEVEL_TRIGGERED |
                     ICR_ALL_INCL_SELF | ICR_LEVEL_DEASSERTED);

    HalpBuildIpiDestinationMap();

    //
    //  we're done - set TPR to a low value and return
    //
    pLocalApic[LU_TPR/4] = ZERO_VECTOR;

    HalpRestoreInterrupts(SavedFlags);
}


VOID
HalpUnMapIOApics(
    VOID
    )
/*++
Routine Description:

    This routine unmaps the IOAPIC's and is primarily used
    to prevent loss of VA space during hibernation

Arguments:

    None:

 Return Value:

    None
*/
{
    UCHAR i;

    for(i=0; i < HalpMpInfoTable.IOApicCount; i++)  {
        if (HalpMpInfoTable.IoApicBase[i]) {
            HalpUnmapVirtualAddress(HalpMpInfoTable.IoApicBase[i],1);
        }
    }
}

VOID
HalpPostSleepMP(
    IN LONG           NumberProcessors,
    IN volatile PLONG Number
    )
/*++
Routine Description:

    This routine does the part of MP re-init that needs to
    happen after hibernation or sleeping.

Arguments:

    None:

 Return Value:

    None
*/
{
    volatile ULONG ThisProcessor;
    ULONG   localApicId;
    KIRQL   OldIrql;

    //
    // Boot processor and the newly woken processors come here
    //

    ThisProcessor = CurrentPrcb(KeGetPcr())->Number;

    if (ThisProcessor != 0)  {

        HalpInitializeLocalUnit ();
        KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    }

    //
    // Fill in this processor's Apic ID.
    //

    localApicId = *(PVULONG)(LOCALAPIC + LU_ID_REGISTER);

    localApicId &= APIC_ID_MASK;
    localApicId >>= APIC_ID_SHIFT;

    ((PHALPRCB)CurrentPrcb(KeGetPcr())->HalReserved)->PCMPApicID = (UCHAR)localApicId;

    //
    // Initialize the processor machine check registers
    //

    if ((HalpFeatureBits & HAL_MCE_PRESENT) ||
        (HalpFeatureBits & HAL_MCA_PRESENT)) {
        HalpMcaCurrentProcessorSetConfig();
    }

    //
    // Enable NMI vectors in the local APIC
    //

    HalpEnableNMI();

    //
    // Enable perf event in local APIC
    //

    if (HalpFeatureBits & HAL_PERF_EVENTS)  {
        HalpEnablePerfInterupt(0);
    }

    //
    // Wait for all processors to finish initialization.
    //

    InterlockedIncrement(Number);
    while (*Number != NumberProcessors);

    //
    // The following global hardware state needs to be set after all processors
    // have been woken up and initialized
    //

    if (CurrentPrcb(KeGetPcr())->Number == 0)  {

        //
        // Restore clock interrupt
        //

        HalpInitializeClock();

        HalpSet8259Mask(HalpGlobal8259Mask);

        HalpHiberInProgress = FALSE;

        //
        // We are now ready to send IPIs again if more than
        // one processor
        //

        if (NumberProcessors > 1) {
            HalpIpiClock = 0xff;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\xxbiosa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\xxbiosa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\xxbiosc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxbiosc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\xxdisp.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxdisp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\xxflshbf.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxflshbf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\xxioacc.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\xxioacc.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\xxmemory.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxmemory.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\xxstubs.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxstubs.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\xxtime.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxtime.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\pcmp_nt.inc ===
;/*
;++
;
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
;
;   Module Name:
;
;       pcmp_nt.inc
;
;   Abstract:
;
;       include file for PC+MP system.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       Ron Mosgrove (Intel) 30-July-1993
;
;--
;

if 0        ; Begin C only code         */

//
// Specific MPS 1.4 stuff
//
#include "pcmp.inc"

//
// Generic NT APIC HAL stuff
//
#include "ntapic.inc"

/*
endif
;
;  Begin assembly part of the definitions
;

include pcmp.inc
include ntapic.inc

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\pcip.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI 1

#include "..\..\halx86\i386\pcip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpsysbus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    mpsysbus.c

Abstract:

Author:

Environment:

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "apic.inc"
#include "pcmp_nt.inc"

ULONG HalpDefaultInterruptAffinity = 0;

#ifndef ACPI_HAL
ULONG
HalpGetEisaInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );
#else

#undef HalpGetEisaInterruptVector
#define HalpGetEisaInterruptVector HalpGetSystemInterruptVector

extern BUS_HANDLER HalpFakePciBusHandler;
#endif

extern UCHAR HalpVectorToIRQL[];
extern UCHAR HalpIRQLtoTPR[];
extern USHORT HalpVectorToINTI[];
extern KSPIN_LOCK HalpAccountingLock;
extern struct HalpMpInfo HalpMpInfoTable;
extern UCHAR HalpMaxProcsPerCluster;
extern INTERRUPT_DEST HalpIntDestMap[];

ULONG HalpINTItoVector[MAX_INTI];
UCHAR HalpPICINTToVector[16];

extern ULONG HalpMaxNode;
extern KAFFINITY HalpNodeAffinity[MAX_NODES];

UCHAR HalpNodeBucket[MAX_NODES];

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,HalpGetSystemInterruptVector)
#pragma alloc_text(PAGE, HalIrqTranslateResourceRequirementsRoot)
#pragma alloc_text(PAGE, HalTranslatorReference)
#pragma alloc_text(PAGE, HalTranslatorDereference)
#endif

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    )

/*++

Routine Description:

    This routine performs a very similar function to HalTranslateBusAddress
    except that InterfaceType and BusNumber are not known by the caller.
    This function will walk all busses known by the HAL looking for a
    valid translation for the input BusAddress of type AddressSpace.

    This function is recallable using the input/output Context parameter.
    On the first call to this routine for a given translation the ULONG_PTR
    Context should be NULL.  Note:  Not the address of it but the contents.

    If the caller decides the returned translation is not the desired
    translation, it calls this routine again passing Context in as it
    was returned on the previous call.  This allows this routine to
    traverse the bus structures until the correct translation is found
    and is provided because on multiple bus systems, it is possible for
    the same resource to exist in the independent address spaces of
    multiple busses.

Arguments:

    BusAddress          Address to be translated.
    AddressSpace        0 = Memory
                        1 = IO (There are other possibilities).
                        N.B. This argument is a pointer, the value
                        will be modified if the translated address
                        is of a different address space type from
                        the untranslated bus address.
    TranslatedAddress   Pointer to where the translated address
                        should be stored.
    Context             Pointer to a ULONG_PTR. On the initial call,
                        for a given BusAddress, it should contain
                        0.  It will be modified by this routine,
                        on subsequent calls for the same BusAddress
                        the value should be handed in again,
                        unmodified by the caller.
    NextBus             FALSE if we should attempt this translation
                        on the same bus as indicated by Context,
                        TRUE if we should be looking for another
                        bus.

Return Value:

    TRUE    if translation was successful,
    FALSE   otherwise.

--*/

{
    //
    // First, make sure the context parameter was supplied and is
    // being used correctly.  This also ensures that the caller
    // doesn't get stuck in a loop looking for subsequent translations
    // for the same thing.  We won't succeed the same translation twice
    // unless the caller reinits the context.
    //

    if ((!Context) || (*Context && (NextBus == TRUE))) {
        return FALSE;
    }
    *Context = 1;

    //
    // PC/AT (halx86) case is simplest, there is no translation.
    //

    *TranslatedAddress = BusAddress;
    return TRUE;
}

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    BOOLEAN             status;
    PSUPPORTED_RANGE    pRange;

    status = FALSE;

    switch (*AddressSpace) {
    case 0:
        if (BusHandler->InterfaceType != PCIBus) {

            // verify memory address is within buses memory limits

            pRange = &BusHandler->BusAddresses->Memory;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                        BusAddress.QuadPart <= pRange->Limit;
                pRange = pRange->Next;
            }

            pRange = &BusHandler->BusAddresses->PrefetchMemory;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                        BusAddress.QuadPart <= pRange->Limit;

                pRange = pRange->Next;
            }
        } else {
            //
            // This is a PCI bus and SystemBase is constant for all ranges
            //

            pRange = &BusHandler->BusAddresses->Memory;

            status = TRUE;
        }
        break;

    case 1:
        if (BusHandler->InterfaceType != PCIBus) {
            // verify IO address is within buses IO limits
            pRange = &BusHandler->BusAddresses->IO;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                         BusAddress.QuadPart <= pRange->Limit;

                pRange = pRange->Next;
            }
        } else {
            //
            // This is a PCI bus and SystemBase is constant for all ranges
            //

            pRange = &BusHandler->BusAddresses->IO;

            status = TRUE;
        }
        break;

    default:
        status = FALSE;
        break;
    }

    if (status) {
        *TranslatedAddress = BusAddress;
    }
#if !defined(_WIN64)
    else {
        _asm { nop };       // good for debugging
    }
#endif

    return status;
}


#define MAX_SYSTEM_IRQL     31
#define MAX_FREE_IRQL       26
#define MIN_FREE_IRQL       4
#define MAX_FREE_IDTENTRY   0xbf
#define MIN_FREE_IDTENTRY   0x51
#define IDTENTRY_BASE       0x50
#define MAX_VBUCKET          7

#define AllocateVectorIn(index)     \
    vBucket[index]++;               \
    ASSERT (vBucket[index] < 16);

#define GetIDTEntryFrom(index)  \
    (UCHAR) ( index*16 + IDTENTRY_BASE + vBucket[index] )
    // note: device levels 50,60,70,80,90,A0,B0 are not allocatable

#define GetIrqlFrom(index)  (KIRQL) ( index + MIN_FREE_IRQL )

UCHAR   nPriority[MAX_NODES][MAX_VBUCKET];

ULONG
HalpGetSystemInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

    This function returns the system interrupt vector and IRQL
    corresponding to the specified bus interrupt level and/or
    vector.  The system interrupt vector and IRQL are suitable
    for use in a subsequent call to KeInitializeInterrupt.

Arguments:

    InterruptLevel - Supplies the bus specific interrupt level.

    InterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG           SystemVector;
    USHORT          ApicInti;
    UCHAR           IDTEntry;
    ULONG           Bucket, i, OldLevel;
    BOOLEAN         Found;
    PVOID           LockHandle;
    ULONG           Node;
    PUCHAR          vBucket;

    UNREFERENCED_PARAMETER( InterruptVector );
    //
    // TODO: Remove when Affinity becomes IN OUT.
    *Affinity = ~0;
    //
    // Restrict Affinity if required.
    if (HalpMaxProcsPerCluster == 0)  {
        *Affinity &= HalpDefaultInterruptAffinity;
    }

    //
    // Find closest child bus to this handler
    //

    if (RootHandler != BusHandler) {
        while (RootHandler->ParentHandler != BusHandler) {
            RootHandler = RootHandler->ParentHandler;
        }
    }

    //
    // Find Interrupt's APIC Inti connection
    //

    Found = HalpGetApicInterruptDesc (
                RootHandler->InterfaceType,
                RootHandler->BusNumber,
                InterruptLevel,
                &ApicInti
                );

    if (!Found) {
        return 0;
    }

    //
    // If device interrupt vector mapping is not already allocated,
    // then do it now
    //

    if (!HalpINTItoVector[ApicInti]) {

        //
        // Vector is not allocated - synchronize and check again
        //

        LockHandle = MmLockPagableCodeSection (&HalpGetSystemInterruptVector);
        OldLevel = HalpAcquireHighLevelLock (&HalpAccountingLock);
        if (!HalpINTItoVector[ApicInti]) {

            //
            // Still not allocated
            //

            //
            // Pick a node.  In the future, Affinity will be INOUT and
            // we will have to screen the node against the input affinity.
            if (HalpMaxNode == 1)  {
                Node = 1;
            } else {
                //
                // Find a node that meets the affinity requirements.
                // Nodes are numbered 1..n, so 0 means we are done.
                for (i = HalpMaxNode; i; i--) {
                    if ((*Affinity & HalpNodeAffinity[i-1]) == 0)
                        continue;
                    Node = i;
                    break;
                }
                ASSERT(Node != 0);
                //
                // Look for a "less busy" alternative.
                for (i = Node-1; i; i--) {
                    //
                    // Check input Affinity to see if this node is permitted.
                    if ((*Affinity & HalpNodeAffinity[i-1]) == 0)
                        continue;
                    //
                    // Take the least busy of the permitted nodes.
                    if (HalpNodeBucket[i-1] < HalpNodeBucket[Node-1]) {
                        Node = i;
                    }
                }
            }
            HalpNodeBucket[Node-1]++;
            *Affinity = HalpNodeAffinity[Node-1];
            vBucket = nPriority[Node-1];

            //
            // Choose the least busy priority on the node.
            Bucket = MAX_VBUCKET-1;
            for (i = Bucket-1; i; i--) {
                if (vBucket[i] < vBucket[Bucket]) {
                    Bucket = i;
                }
            }
            AllocateVectorIn (Bucket);

            //
            // Now form the vector for the kernel.
            IDTEntry = GetIDTEntryFrom (Bucket);
            SystemVector = HalpVector(Node, IDTEntry);
            ASSERT(IDTEntry <= MAX_FREE_IDTENTRY);
            ASSERT(IDTEntry >= MIN_FREE_IDTENTRY);

#if defined(_AMD64_)
            *Irql = (KIRQL)(IDTEntry >> 4);
#else
            *Irql = GetIrqlFrom (Bucket);
#endif
            ASSERT(*Irql <= MAX_FREE_IRQL);

#if !defined(_WIN64)
            ASSERT((UCHAR) (HalpIRQLtoTPR[*Irql] & 0xf0) == (UCHAR) (IDTEntry & 0xf0) );
#endif

            HalpVectorToIRQL[IDTEntry >> 4] = (UCHAR)  *Irql;
            HalpVectorToINTI[SystemVector]  = (USHORT) ApicInti;
            HalpINTItoVector[ApicInti]      =          SystemVector;

            //
            // If this assigned interrupt is connected to the machines PIC,
            // then remember the PIC->SystemVector mapping.
            //

            if (RootHandler->BusNumber == 0  &&  InterruptLevel < 16  &&
                 RootHandler->InterfaceType == DEFAULT_PC_BUS) {
                HalpPICINTToVector[InterruptLevel] = (UCHAR) SystemVector;
            }

        }

        HalpReleaseHighLevelLock (&HalpAccountingLock, OldLevel);
        MmUnlockPagableImageSection (LockHandle);
    }

    //
    // Return this ApicInti's system vector & irql
    //

    SystemVector = HalpINTItoVector[ApicInti];
    *Irql = HalpVectorToIRQL[HalVectorToIDTEntry(SystemVector) >> 4];

    ASSERT(HalpVectorToINTI[SystemVector] == (USHORT) ApicInti);
    
    //
    // Find an appropriate affinity.
    //
    Node = HalpVectorToNode(SystemVector);
    *Affinity &= HalpNodeAffinity[Node-1];
    if (!*Affinity) {
        return 0;
    }

    return SystemVector;
}

VOID
HalpSetInternalVector (
    IN ULONG    InternalVector,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN PVOID Context,
    IN KIRQL Irql
    )
/*++

Routine Description:

    Used at init time to set IDT vectors for internal use.

--*/
{
    //
    // Remember this vector so it's reported as Hal internal usage
    //

//  HalpRegisterVector (
//      InternalUsage,
//      InternalVector,
//      InternalVector,
//      HalpVectorToIRQL[InternalVector >> 4]
//  );

    //
    // Connect the IDT
    //

    KiSetHandlerAddressToIDTIrql(InternalVector,
                                 HalInterruptServiceRoutine,
                                 Context,
                                 Irql);
}

//
// This section implements a "translator," which is the PnP-WDM way
// of doing the same thing that the first part of this file does.
//
VOID
HalTranslatorReference(
    PVOID Context
    )
{
    return;
}

VOID
HalTranslatorDereference(
    PVOID Context
    )
{
    return;
}

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function takes a CM_PARTIAL_RESOURCE_DESCRIPTOR and translates
    it to an IO-bus-relative from a Processor-bus-relative form, or the other
    way around.  In this x86-specific example, an IO-bus-relative form is the
    ISA IRQ and the Processor-bus-relative form is the IDT entry and the
    associated IRQL.

    N.B.  This funtion has an associated "Direction."  These are not exactly
          reciprocals.  This has to be the case because the output from
          HalIrqTranslateResourceRequirementsRoot will be used as the input
          for the ParentToChild case.

          ChildToParent:

            Level  (ISA IRQ)        -> IRQL
            Vector (ISA IRQ)        -> x86 IDT entry
            Affinity (not refereced)-> KAFFINITY

          ParentToChild:

            Level (not referenced)  -> (ISA IRQ)
            Vector (IDT entry)      -> (ISA IRQ)
            Affinity                -> 0xffffffff

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    Direction   - direction of translation (parent to child or child to parent)

    AlternativesCount   - unused

    Alternatives        - unused

    PhysicalDeviceObject- unused

    Target      - translated descriptor

Return Value:

    status

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PBUS_HANDLER    bus;
    KAFFINITY       affinity;
    KIRQL           irql;
    ULONG           vector;
    USHORT          inti;
#ifdef ACPI_HAL
    BUS_HANDLER     fakeIsaBus;
#endif

    PAGED_CODE();

    UNREFERENCED_PARAMETER(AlternativesCount);
    UNREFERENCED_PARAMETER(Alternatives);
    UNREFERENCED_PARAMETER(PhysicalDeviceObject);

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    switch (Direction) {
    case TranslateChildToParent:

#ifdef ACPI_HAL

        RtlCopyMemory(&fakeIsaBus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        fakeIsaBus.InterfaceType = Isa;
        fakeIsaBus.ParentHandler = &fakeIsaBus;
        bus = &fakeIsaBus;
#else

        if ((INTERFACE_TYPE)Context == InterfaceTypeUndefined) { // special "IDE" cookie

            ASSERT(Source->u.Interrupt.Level == Source->u.Interrupt.Vector);

            bus = HalpFindIdeBus(Source->u.Interrupt.Vector);

        } else {

            bus = HaliHandlerForBus((INTERFACE_TYPE)Context, 0);
        }

        if (!bus) {
            return STATUS_NOT_FOUND;
        }
#endif

        //
        // Copy everything
        //
        *Target = *Source;

        //
        // Translate the IRQ
        //

        vector = HalpGetEisaInterruptVector(bus,
                                            bus,
                                            Source->u.Interrupt.Level,
                                            Source->u.Interrupt.Vector,
                                            &irql,
                                            &affinity);

        if (vector == 0) {
            return STATUS_UNSUCCESSFUL;
        }

        Target->u.Interrupt.Level  = irql;
        Target->u.Interrupt.Vector = vector;
        Target->u.Interrupt.Affinity = affinity;

        if (NT_SUCCESS(status)) {
            status = STATUS_TRANSLATION_COMPLETE;
        }

        break;

    case TranslateParentToChild:

        //
        // Copy everything
        //
        *Target = *Source;

        //
        // There is no inverse to HalpGetSystemInterruptVector, so we
        // just do what that function would do.
        //

        inti = HalpVectorToINTI[Source->u.Interrupt.Vector];

        Target->u.Interrupt.Level = Target->u.Interrupt.Vector =
            HalpInti2BusInterruptLevel(inti);

        Target->u.Interrupt.Affinity = 0xFFFFFFFF;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes an IO_RESOURCE_DESCRIPTOR and translates
    it from an IO-bus-relative to a Processor-bus-relative form.  In this
    x86-specific example, an IO-bus-relative form is the ISA IRQ and the
    Processor-bus-relative form is the IDT entry and the associated IRQL.
    This is essentially a PnP form of HalGetInterruptVector.

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    PhysicalDeviceObject- unused

    TargetCount - 1

    Target      - translated descriptor

Return Value:

    status

--*/
{
    PBUS_HANDLER    bus;
    KAFFINITY       affinity;
    KIRQL           irql;
    ULONG           vector;
    BOOLEAN         success = TRUE;
#ifdef ACPI_HAL
    BUS_HANDLER     fakeIsaBus;
#endif

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

#ifdef ACPI_HAL

        RtlCopyMemory(&fakeIsaBus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        fakeIsaBus.InterfaceType = Isa;
        fakeIsaBus.ParentHandler = &fakeIsaBus;
        bus = &fakeIsaBus;
#else

    if ((INTERFACE_TYPE)Context == InterfaceTypeUndefined) { // special "IDE" cookie

        ASSERT(Source->u.Interrupt.MinimumVector == Source->u.Interrupt.MaximumVector);

        bus = HalpFindIdeBus(Source->u.Interrupt.MinimumVector);

    } else {

        bus = HaliHandlerForBus((INTERFACE_TYPE)Context, 0);
    }

    if (!bus) {
        
        //
        // There is no valid translation.
        //

        *TargetCount = 0;
        return STATUS_TRANSLATION_COMPLETE;
    }
#endif

    //
    // The interrupt requirements were obtained by calling HalAdjustResourceList
    // so we don't need to call it again.
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *TargetCount = 1;

    //
    // Copy the requirement unchanged
    //

    **Target = *Source;

    //
    // Perform the translation of the minimum & maximum
    //

    vector = HalpGetEisaInterruptVector(bus,
                                        bus,
                                        Source->u.Interrupt.MinimumVector,
                                        Source->u.Interrupt.MinimumVector,
                                        &irql,
                                        &affinity);

    if (!vector) {
        success = FALSE;
    }

    (*Target)->u.Interrupt.MinimumVector = vector;

    vector = HalpGetEisaInterruptVector(bus,
                                        bus,
                                        Source->u.Interrupt.MaximumVector,
                                        Source->u.Interrupt.MaximumVector,
                                        &irql,
                                        &affinity);

    if (!vector) {
        success = FALSE;
    }

    (*Target)->u.Interrupt.MaximumVector = vector;

    if (!success) {

        ExFreePool(*Target);
        *TargetCount = 0;
    }

    return STATUS_TRANSLATION_COMPLETE;
}

#if 0

// HALMPS doesn't provide this function.   It is left here as documentation
// for HALs which must provide translation.

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )

/*++

Routine Description:

    This routine translates memory and IO resource requirements.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt requirement to translate

    PhysicalDeviceObject - The device requesting the resource

    TargetCount - Pointer to where to return the number of descriptors this
        requirement translates into

    Target - Pointer to where a pointer to a callee allocated buffer containing
        the translated descriptors should be placed.

Return Value:

    STATUS_SUCCESS or an error status

Note:

    We do not perform any translation.

--*/

{
    ASSERT(Source);
    ASSERT(Target);
    ASSERT(TargetCount);
    ASSERT(Source->Type == CmResourceTypeMemory ||
           Source->Type == CmResourceTypePort);


    //
    // Allocate space for the target
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to target and update the fields that have changed
    //

    **Target = *Source;
    *TargetCount = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )

/*++

Routine Description:

    This routine translates memory and IO resources.   On generic x86
    machines, such as those that use this HAL, there isn't actually
    any translation.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt resource to translate

    Direction - The direction in relation to the Pnp device tree translation
        should occur in.

    AlternativesCount - The number of alternatives this resource was selected
        from.

    Alternatives - Array of alternatives this resource was selected from.

    PhysicalDeviceObject - The device requesting the resource

    Target - Pointer to a caller allocated buffer to hold the translted resource
        descriptor.

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    NTSTATUS status;

    //
    // Copy the target to the source
    //

    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Make sure PnP knows it doesn't have to walk up the tree
        // translating at each point.
        //

        status = STATUS_TRANSLATION_COMPLETE;
        break;

    case TranslateParentToChild:

        //
        // We do not translate requirements so do nothing...
        //

        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }
    return status;
}
#endif

NTSTATUS
HaliGetInterruptTranslator(
	IN INTERFACE_TYPE ParentInterfaceType,
	IN ULONG ParentBusNumber,
	IN INTERFACE_TYPE BridgeInterfaceType,
	IN USHORT Size,
	IN USHORT Version,
	OUT PTRANSLATOR_INTERFACE Translator,
	IN OUT PULONG BridgeBusNumber
	)
/*++

Routine Description:


Arguments:

	ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

	ParentBusNumber - The number of the bus the bridge lives on.

	BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

	ResourceType - The resource type we want to translate.

	Size - The size of the translator buffer.

	Version - The version of the translator interface requested.

	Translator - Pointer to the buffer where the translator should be returned

	BridgeBusNumber - Pointer the bus number of the bus that the bridge represents

Return Value:

    Returns the status of this operation.

--*/
#define BRIDGE_HEADER_BUFFER_SIZE (FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.SubordinateBus) + 1)
#define USE_INT_LINE_REGISTER_TOKEN  0xffffffff
#define DEFAULT_BRIDGE_TRANSLATOR 0x80000000
{
    PAGED_CODE();

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof(TRANSLATOR_INTERFACE));

    //
    // Fill in the common bits.
    //

    RtlZeroMemory(Translator, sizeof(TRANSLATOR_INTERFACE));

    Translator->Size = sizeof(TRANSLATOR_INTERFACE);
    Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
    Translator->Context = (PVOID)BridgeInterfaceType;
    Translator->InterfaceReference = HalTranslatorReference;
    Translator->InterfaceDereference = HalTranslatorDereference;

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
    case InterfaceTypeUndefined:  // special "IDE" cookie

        //
        // Set IRQ translator for (E)ISA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    case MicroChannel:

        //
        // Set IRQ translator for MCA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesRoot;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsRoot;

        return STATUS_SUCCESS;

    case PCIBus:

#ifndef ACPI_HAL
        //
        // Set of of two IRQ translators for PCI busses.
        //

        {
            UCHAR mpsBusNumber = 0;
            UCHAR pciBusNumber, parentPci, childPci;
            PCI_SLOT_NUMBER bridgeSlot;
            PCI_COMMON_CONFIG pciData;
            ULONG bytesRead, d, f, possibleContext;
            BOOLEAN describedByMps;
            NTSTATUS status;

            Translator->TranslateResources = HalpIrqTranslateResourcesPci;
            Translator->TranslateResourceRequirements =
                HalpIrqTranslateRequirementsPci;
        
            //
            // Look for this bus in the MPS tables.
            //

            status = HalpPci2MpsBusNumber((UCHAR)*BridgeBusNumber,
                                          &mpsBusNumber);

            if (NT_SUCCESS(status)) {

                //
                // This bus has corresponding entries for its PCI
                // devices in the MPS tables.  So eject the translator
                // that understands them.
                //

                if (HalpInterruptsDescribedByMpsTable(mpsBusNumber)) {

                    Translator->Context = (PVOID)mpsBusNumber;
                    return STATUS_SUCCESS;
                }
            }

            //
            // Do a quick check to see if we can avoid searching PCI
            // configuration space for a bridge.  This code is really
            // redundant, but it's worth trying to avoid touching
            // PCI space.
            //

            if (ParentInterfaceType != PCIBus) {

                //
                // This was a PCI bus that doesn't contain
                // mappings for PCI devices.
                //

                Translator->TranslateResources = 
                    HalpIrqTranslateResourcesPci;
                Translator->TranslateResourceRequirements =
                    HalpIrqTranslateRequirementsPci;
        
                Translator->Context = (PVOID)USE_INT_LINE_REGISTER_TOKEN;

                return STATUS_SUCCESS;

            }
            
            //
            // We didn't find this PCI bus in the MPS tables.  So there
            // are two cases.
            //
            // 1) This matters, because the parent bus is fully described
            //    in the MPS tables and we need to do translations on
            //    the vector as it passes through the bridges.
            //
            // 2) This doesn't matter, because the parent busses, while
            //    they may be in the MPS tables, they don't have any
            //    of their interrupts described.  So we just use the
            //    interrupt line register anyhow.
            //
            // At this point we need to find the PCI bridge that
            // generates this bus, either because we will eventually
            // need to know the slot number to fill in the context, or
            // because we will need to know the primary bus number to
            // look up the tree.
            //
            
            parentPci = (UCHAR)ParentBusNumber;
            childPci = (UCHAR)(*BridgeBusNumber);

            while (TRUE) {
                
                //
                // Find the bridge.
                //
    
                bridgeSlot.u.AsULONG = 0;
    
                for (d = 0; d < PCI_MAX_DEVICES; d++) {
                    for (f = 0; f < PCI_MAX_FUNCTION; f++) {
    
                        bridgeSlot.u.bits.DeviceNumber = d;
                        bridgeSlot.u.bits.FunctionNumber = f;
    
                        bytesRead = HalGetBusDataByOffset(PCIConfiguration,
                                                          parentPci,
                                                          bridgeSlot.u.AsULONG,
                                                          &pciData,
                                                          0,
                                                          BRIDGE_HEADER_BUFFER_SIZE);

                        if (bytesRead == (ULONG)BRIDGE_HEADER_BUFFER_SIZE) {
    
                            if ((pciData.VendorID != PCI_INVALID_VENDORID) &&
                                (PCI_CONFIGURATION_TYPE((&pciData)) != PCI_DEVICE_TYPE)) {
    
                                //
                                // This is a bridge of some sort.
                                //
    
                                if (pciData.u.type1.SecondaryBus == childPci) {
    
                                    //
                                    // And it is the bridge we are looking for.
                                    // Store information about
                                    //
    
                                    if (childPci == *BridgeBusNumber) {
                                    
                                        //
                                        // It is also the bridge that creates the 
                                        // PCI bus that the translator is describing.
                                        // 
                                        // N.B.  This should only happen the first time
                                        // we search through a bus.  (i.e. the first
                                        // trip through the outer while loop)
                                        //

                                        possibleContext = ((bridgeSlot.u.AsULONG & 0xffff) |
                                                           (ParentBusNumber << 16));
                                    
                                    }

                                    goto HGITFoundBridge1;
                                }
                            }
                        }
                    }
                }
                
                //
                // No bridge found.
                //

                if (parentPci == 0) {
                    return STATUS_NOT_FOUND;
                }

                parentPci--;
                continue;
                
HGITFoundBridge1:
                
                status = HalpPci2MpsBusNumber(parentPci, &mpsBusNumber);

                if (NT_SUCCESS(status)) {
    
                    if (HalpInterruptsDescribedByMpsTable(mpsBusNumber)) {
    
                        //
                        // Case 1 above.
                        //
    
                        Translator->TranslateResources = HalIrqTranslateResourcesPciBridge;
                        Translator->TranslateResourceRequirements =
                            HalIrqTranslateRequirementsPciBridge;

                        Translator->Context = (PVOID)possibleContext;
            
                        return STATUS_SUCCESS;
                    }

                    if (HalpMpsBusIsRootBus(mpsBusNumber)) {
                        
                        Translator->TranslateResources = 
                            HalpIrqTranslateResourcesPci;
                        Translator->TranslateResourceRequirements =
                            HalpIrqTranslateRequirementsPci;
                
                        Translator->Context = (PVOID)USE_INT_LINE_REGISTER_TOKEN;
        
                        return STATUS_SUCCESS;
                    }
                }

                //
                // Try again one bus higher.
                //

                childPci = parentPci;
                parentPci--;
            }
        }
#endif
        break;
    }


    //
    // If we got here, we don't have an interface.
    //

    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\pcmpdtct.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    pcmpdtct.c

Abstract:

    This module detects an MPS system.

Author:

    Ron Mosgrove (Intel) - Aug 1993.

Environment:

    Kernel mode or from textmode setup.

Revision History:
    Rajesh Shah (Intel) - Oct 1993. Added support for MPS table.

--*/

#ifndef _NTOS_
#include "halp.h"
#endif

#include "apic.inc"
#include "pcmp_nt.inc"
#include "stdio.h"

#if DEBUGGING
CHAR Cbuf[120];
VOID HalpDisplayConfigTable(VOID);
VOID HalpDisplayExtConfigTable(VOID);
VOID HalpDisplayBIOSSysCfg(struct SystemConfigTable *);
#define DBGMSG(a)   HalDisplayString(a)
#else
#define DBGMSG(a)
#endif

#define DEBUG_MSG(a)

//
// The floating pointer structure defined by the MPS spec can reside
// anywhere in BIOS extended data area. These defines are used to search for
// the floating structure starting from physical address 639K(9f000+c00)
//
#define PCMP_TABLE_PTR_BASE           0x09f000
#define PCMP_TABLE_PTR_OFFSET         0x00000c00

extern struct  HalpMpInfo HalpMpInfoTable;

UCHAR
ComputeCheckSum(
    IN PUCHAR SourcePtr,
    IN USHORT NumOfBytes
    );

VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );

struct FloatPtrStruct *
SearchFloatPtr (
    ULONG PhysicalAddress,
    ULONG ByteSize
    );

struct FloatPtrStruct *
PcMpGetFloatingPtr (
    VOID
    );

struct PcMpTable *
GetPcMpTable (
    VOID
    );


struct PcMpTable *
MPS10_GetPcMpTablePtr (
    VOID
    );

struct PcMpTable *
MPS10_GetPcMpTable (
    VOID
    );


struct PcMpTable *
GetDefaultConfig (
    IN ULONG Config
    );

#ifdef SETUP

//
// A dummy pointer to a default MPS table. For setup, we can conserve
// space by not building default tables in our data area.
#define DEFAULT_MPS_INDICATOR   0xfefefefe

#define HalpUnmapVirtualAddress(a, b)

#endif   //SETUP

#ifndef SETUP
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,SearchFloatPtr)
#pragma alloc_text(PAGELK,PcMpGetFloatingPtr)
#pragma alloc_text(PAGELK,ComputeCheckSum)
#pragma alloc_text(PAGELK,GetPcMpTable)
#pragma alloc_text(PAGELK,MPS10_GetPcMpTablePtr)
#pragma alloc_text(PAGELK,MPS10_GetPcMpTable)
#pragma alloc_text(PAGELK,GetDefaultConfig)
#endif  // ALLOC_PRAGMA

extern struct PcMpTable *PcMpDefaultTablePtrs[];
extern BOOLEAN HalpUse8254;
#endif   // ndef SETUP


struct FloatPtrStruct *
SearchFloatPtr(
    ULONG PhysicalAddress,
    ULONG ByteSize
    )
{
    // Search for the MPS floating pointer structure starting from the
    // physical address given.

    USHORT Index, ParagraphLength;
    UCHAR CheckSum;
    struct FloatPtrStruct *VirtualAddress;
    BOOLEAN CheckSumError;
    PHYSICAL_ADDRESS physAddr = {0};

#ifdef DEBUGGING
    sprintf(Cbuf, "SearchFloatPtr: Will search at physical address 0x%lx\n",
        PhysicalAddress);
    HalDisplayString(Cbuf);
#endif // DEBUGGING

    // The MPS spec says that the floating pointer structure MUST be
    // aligned at 16 byte boundaries. We can use this fact to search for
    // the structure only at those boundaries. Assume that the input physical
    // address to start search from is 16 byte aligned.

    CheckSumError = FALSE;
    for(Index = 0; Index < (ByteSize/sizeof(struct FloatPtrStruct)); Index++) {
        
        physAddr.LowPart = PhysicalAddress + (Index * sizeof(struct FloatPtrStruct));

        VirtualAddress = (struct FloatPtrStruct *)HalpMapPhysicalMemory64(
                             physAddr,
                             1
                             );
        
        if (VirtualAddress == NULL) {
            DEBUG_MSG ("SearchFloatPtr: Cannot map Physical address\n");
            return (NULL);
        }
    
        if ( (*((PULONG)VirtualAddress) ) == MP_PTR_SIGNATURE)  {

            ParagraphLength =
                ((struct FloatPtrStruct *)VirtualAddress)->MpTableLength;
            
            //
            // Detected the floating structure signature. Check if the
            // floating pointer structure checksum is valid.
            //

            CheckSum = ComputeCheckSum((PUCHAR)VirtualAddress,
                                       (USHORT) (ParagraphLength*16) );
            
            if (CheckSum == 0 )  {
            
                // We have a valid floating pointer structure.
                // Return a pointer to it.
    
                DEBUG_MSG ("SearchFloatPtr: Found structure\n");
                return((struct FloatPtrStruct *) VirtualAddress);
            }

            // Invalid structure. Continue searching.
            CheckSumError = TRUE;
            DEBUG_MSG ("SearchFloatPtr: Valid MP_PTR signature, invalid checksum\n");
        }
        
        //
        // Give back the PTE.
        //

        HalpUnmapVirtualAddress(VirtualAddress, 1);
    }

    if (CheckSumError) {
        FAILMSG (rgzMPPTRCheck);
    }

    return(NULL);
}

struct FloatPtrStruct *
PcMpGetFloatingPtr(
    VOID)
{
    ULONG EbdaSegmentPtr, BaseMemPtr;
    ULONG EbdaPhysicalAdd = 0, ByteLength, BaseMemKb = 0;
    struct FloatPtrStruct *FloatPtr = NULL;
    PUCHAR zeroVirtual;
    PHYSICAL_ADDRESS zeroPhysical;

    // Search for the floating pointer structure in the order specified in
    // MPS spec version 1.1.

    // First, search for it in the first kilobyte in the Extended BIOS Data
    // Area. The EBDA segment address is available at physical address 40:0E

    zeroPhysical = HalpPtrToPhysicalAddress( (PVOID)0 );
    zeroVirtual = HalpMapPhysicalMemoryWriteThrough64( zeroPhysical, 1);
    EbdaSegmentPtr = (ULONG)(zeroVirtual + EBDA_SEGMENT_PTR);
    EbdaPhysicalAdd = *((PUSHORT)EbdaSegmentPtr);
    EbdaPhysicalAdd = EbdaPhysicalAdd << 4;

    if (EbdaPhysicalAdd != 0)
        FloatPtr = SearchFloatPtr(EbdaPhysicalAdd, 1024);

    HalpUnmapVirtualAddress(zeroVirtual, 1);

    if (FloatPtr == NULL)  {

        // Did not find it in EBDA.
        // Look for it in the last KB of system memory.

        zeroVirtual = HalpMapPhysicalMemoryWriteThrough64( zeroPhysical, 1);
        BaseMemPtr = (ULONG)(zeroVirtual + BASE_MEM_PTR);
        BaseMemKb = *((PUSHORT)BaseMemPtr);

        FloatPtr = SearchFloatPtr(BaseMemKb*1024, 1024);

        HalpUnmapVirtualAddress(zeroVirtual, 1);

        if (FloatPtr == NULL)  {

            // Finally, look for the floating Pointer Structure at physical
            // address F0000H to FFFFFH

            ByteLength = 0xfffff - 0xf0000;

            FloatPtr = SearchFloatPtr(0xf0000, ByteLength);
        }
    }

    // At this point, we have a pointer to the MPS floating structure.

    return(FloatPtr);
}


struct PcMpTable *
MPS10_GetPcMpTablePtr(
    VOID
    )
/*++

Routine Description:

    Gets the Address of the MPS configuration table built by BIOS.
    This routine looks for the floating pointer structure defined
    in the MPS spec. This structure points to the MPS configuration
    table built by an MP BIOS. The floating pointer structure can be
    located anywhere in the extended BIOS data area(physical address range
    639K to 640K), and must be aligned on a 16 byte boundary.

 Arguments:
    None

 Return Value:
    struct PcMpTable * - Virtual address pointer to the PcMpTable, if
    it exists, NULL otherwise

--*/

{
    PUCHAR TempPtr;
    UCHAR CheckSum;
    struct PcMpTableLocator *PcMpPtrPtr;
    PULONG TraversePtr;
    PVOID  BasePtr;
    USHORT ParagraphLength;
    int i;
    PHYSICAL_ADDRESS physicalAddress;

    // Map the physical address of the BIOS extended data area to a virtual
    // address we can use.
    
    physicalAddress = HalpPtrToPhysicalAddress( (PVOID)PCMP_TABLE_PTR_BASE );
    BasePtr = (PUCHAR) HalpMapPhysicalMemory64(physicalAddress, 1);
    TempPtr = BasePtr;
    TraversePtr = (PULONG)((PUCHAR) TempPtr + PCMP_TABLE_PTR_OFFSET);

    // Look at 16 byte boundaries for the floating pointer structure
    // The structure is identified by its signature, and verified by its
    // checksum.
    for (i=0; i < (1024/16); ++i)
    {
        if (*(TraversePtr) == MP_PTR_SIGNATURE)
        {
            // Got a valid signature.
            PcMpPtrPtr = (struct PcMpTableLocator *)TraversePtr;

            // Length in 16 byte paragraphs of the floating structure.
            // Normally, this should be set to 1 by the BIOS.
            ParagraphLength = PcMpPtrPtr->MpTableLength;

            // Check if the floating pointer structure is valid.
            CheckSum = ComputeCheckSum((PUCHAR)PcMpPtrPtr,
                            (USHORT) (ParagraphLength*16));
            if (CheckSum != 0 ) {
                FAILMSG (rgzMPPTRCheck);
                // Invalid structure. Continue searching.
                TraversePtr += 4;
                continue;
            }

            // We have a valid floating pointer structure.
            // The value stored in the structure is a physical address of the
            // MPS table built by BIOS. Get the corresponding virtual
            // address.

            physicalAddress = HalpPtrToPhysicalAddress( PcMpPtrPtr->TablePtr );
            TempPtr =  HalpMapPhysicalMemory64(physicalAddress,2);
            
            //
            // Done with base pointer.
            //

            HalpUnmapVirtualAddress(BasePtr, 1);
            
            if (TempPtr == NULL) {
                DEBUG_MSG ("HAL: Cannot map BIOS created MPS table\n");
                return (NULL);
            }

            // Return the virtual address pointer to the MPS table.
            return((struct PcMpTable *) TempPtr);

        }
        TraversePtr += 4;
    }

    return(NULL);
}


UCHAR
ComputeCheckSum (
    IN PUCHAR SourcePtr,
    IN USHORT NumOfBytes
    )
/*++

Routine Description:
    This routine computes a checksum for NumOfBytes bytes, starting
    from SourcePtr. It is used to validate the tables built by BIOS.

Arguments:
    SourcePtr : Starting virtual address to compute checksum.
    NumOfBytes: Number of bytes to compute the checksum of.

 Return Value:
     The checksum value.

*/
{
    UCHAR Result = 0;
    USHORT Count;

    for(Count=0; Count < NumOfBytes; ++Count) {
        //  Result += *SourcePtr++ is complained about when compiled using /W4 warnings
        //  += assumes the original value added to is an int
        Result = Result + *SourcePtr++;        
    }

    return(Result);
}


struct PcMpTable *
MPS10_GetPcMpTable (
    VOID
    )
/*++
Routine Description:
    Detects an MPS 1.0 system only.

Arguments:
    None.

Return Value:
    Pointer to an MPS table.
--*/
{
    struct SystemConfigTable *SystemConfigPtr;

    UCHAR DefaultConfig, CheckSum;
    struct PcMpTable *MpTablePtr;
    UCHAR MpFeatureInfoByte1 = 0, MpFeatureInfoByte2 = 0;
    PHYSICAL_ADDRESS physicalAddress;

    // Get the virtual address of the system configuration table.
    physicalAddress = HalpPtrToPhysicalAddress( (PVOID)BIOS_BASE );
    SystemConfigPtr = (struct SystemConfigTable *)
        HalpMapPhysicalMemory64( physicalAddress, 16);

    if (SystemConfigPtr == NULL) {
        DEBUG_MSG ("GetPcMpTable: Cannot map system configuration table\n");
        return(NULL);
    }

    // HalpDisplayBIOSSysCfg(SystemConfigPtr);

    //  The system configuration table built by BIOS has 2 MP feature
    //  information bytes.

    MpFeatureInfoByte1 = SystemConfigPtr->MpFeatureInfoByte1;
    MpFeatureInfoByte2 = SystemConfigPtr->MpFeatureInfoByte2;

    // The second MP feature information byte tells us whether the system
    // has an IMCR(Interrupt Mode Control Register). We use this information
    // in the HAL, so we store this information in the OS specific private
    // area.

    if ((MpFeatureInfoByte2 & IMCR_MASK) == 0) {
        HalpMpInfoTable.IMCRPresent = 0;
    } else {
        HalpMpInfoTable.IMCRPresent = 1;
    }

#ifndef SETUP

    // The second MP feature information byte tells us whether Time
    // Stamp Counter should be used as a high-resolution timer on 
    // multiprocessor systems.

    if ((MpFeatureInfoByte2 & MULT_CLOCKS_MASK) != 0) {
        HalpUse8254 = 1;
    }
#endif

    // MP feature byte 1 indicates if the system is MPS compliant
    if (! (MpFeatureInfoByte1 & PCMP_IMPLEMENTED)) {
        // The MP feature information byte indicates that this
        // system is not MPS compliant.
        FAILMSG (rgzNoMpsTable);
        return(NULL);
    }

    // The system is MPS compliant. MP feature byte 2 indicates if the
    // system is a default configuration or not.
    DefaultConfig = (MpFeatureInfoByte1 & PCMP_CONFIG_MASK) >> 1;

    if (DefaultConfig) {
        return GetDefaultConfig(DefaultConfig);
    }

    // DefaultConfig == 0. This means that the BIOS has built a MP
    // config table for us. The BIOS will also build a floating pointer
    // structure that points to the MP config table. This floating pointer
    // structure resides in the BIOS extended data area.
    MpTablePtr = MPS10_GetPcMpTablePtr();

    if (MpTablePtr == NULL) {
        FAILMSG (rgzNoMPTable);     // Could not find BIOS created MPS table
        return(NULL);
    }

    // We have a pointer to the MP config table. Check if the table is valid.

    if ((MpTablePtr->Signature != PCMP_SIGNATURE) ||
        (MpTablePtr->TableLength < sizeof(struct PcMpTable)) ) {
        FAILMSG(rgzMPSBadSig);
        return(NULL);
    }

    CheckSum = ComputeCheckSum((PUCHAR)MpTablePtr, MpTablePtr->TableLength);
    if (CheckSum != 0) {
        FAILMSG(rgzMPSBadCheck);
        return(NULL);
    }

    return MpTablePtr;
}

struct PcMpTable *
GetPcMpTable(
    VOID
    )

/*++

Routine Description:
    This routine gets the MP table for a MPS compliant system.
    For a MPS compliant system, either the BIOS builds an MP table, or
    it indicates that the system is one of the default configurations
    defined in the MPS spec. The MP feature information bytes in the BIOS
    system configuration table indicate whether the system is one of the
    default systems, or has a BIOS created MP table. For a default system
    configuration, this routine uses a statically built default table.
    This routine copies the MPS table into private system memory, and
    returns a pointer to this table.

Arguments:
    None.

 Return Value:
     Pointer to the private copy of the MP table that has been copied in
     system memory.

*/
{

    struct FloatPtrStruct *FloatingPtr;
    UCHAR CheckSum;
    struct PcMpTable *MpTablePtr;
    UCHAR MpFeatureInfoByte1 = 0, MpFeatureInfoByte2 = 0;
    PUCHAR TempPtr;
    PHYSICAL_ADDRESS physicalAddress;
    ULONG tableLength;

    DEBUG_MSG("GetMpTable\n");

    FloatingPtr = PcMpGetFloatingPtr();

    if (FloatingPtr == NULL) {
        FAILMSG (rgzNoMPTable);
        return(NULL);
    }

    //  The floating structure has 2 MP feature information bytes.

    MpFeatureInfoByte1 = FloatingPtr->MpFeatureInfoByte1;
    MpFeatureInfoByte2 = FloatingPtr->MpFeatureInfoByte2;

    // The second MP feature information byte tells us whether the system
    // has an IMCR(Interrupt Mode Control Register). We use this information
    // in the HAL, so we store this information in the OS specific private
    // area.

    if ((MpFeatureInfoByte2 & IMCR_MASK) == 0)
        HalpMpInfoTable.IMCRPresent = 0;
    else
        HalpMpInfoTable.IMCRPresent = 1;

    if (MpFeatureInfoByte1 != 0)  {
        // The system configuration is one of the default
        // configurations defined in the MPS spec. Find out which
        // default configuration it is and get a pointer to the
        // corresponding default table.

        return GetDefaultConfig(MpFeatureInfoByte1);
    }


    // MpFeatureInfoByte1 == 0. This means that the BIOS has built a MP
    // config table for us. The address of the OEM created table is in
    // the MPS floating structure.

    physicalAddress = HalpPtrToPhysicalAddress( FloatingPtr->TablePtr );
    TempPtr =  HalpMapPhysicalMemory64(physicalAddress,2);

    HalpUnmapVirtualAddress(FloatingPtr, 1);
    
    if (TempPtr == NULL) {
        DEBUG_MSG ("HAL: Cannot map OEM MPS table [1]\n");
        return (NULL);
    }

    MpTablePtr = (struct PcMpTable *)TempPtr;

    // We have a pointer to the MP config table. Check if the table is valid.

    if ((MpTablePtr->Signature != PCMP_SIGNATURE) ||
    (MpTablePtr->TableLength < sizeof(struct PcMpTable)) ) {
        FAILMSG (rgzMPSBadSig);
        return(NULL);
    }

    //
    // Now re-map it, making sure that we have mapped enough pages.
    //

    tableLength = MpTablePtr->TableLength + MpTablePtr->ExtTableLength;

    HalpUnmapVirtualAddress(TempPtr, 2);

    MpTablePtr = (struct PcMpTable *)HalpMapPhysicalMemory64(
                    physicalAddress, 
                    (ULONG)(((physicalAddress.QuadPart + tableLength) / PAGE_SIZE) - 
                        (physicalAddress.QuadPart / PAGE_SIZE) + 1)
                    );
    
    if (MpTablePtr == NULL) {
        DEBUG_MSG ("HAL: Cannot map OEM MPS table [2]\n");
        return (NULL);
    }

    CheckSum = ComputeCheckSum((PUCHAR)MpTablePtr, MpTablePtr->TableLength);
    if (CheckSum != 0) {
        FAILMSG (rgzMPSBadCheck);
        return(NULL);
    }

    return MpTablePtr;
}


struct PcMpTable *
GetDefaultConfig (
    IN ULONG Config
    )
{
    Config -= 1;

    if (Config >= NUM_DEFAULT_CONFIGS)  {
        FAILMSG (rgzBadDefault);
        return NULL;
    }

#ifdef DEBUGGING
    HalDisplayString ("HALMPS: Using default table\n");
#endif

#ifdef SETUP
    return((struct PcMpTable *) DEFAULT_MPS_INDICATOR);
#else
    return PcMpDefaultTablePtrs[Config];
#endif  // SETUP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpsyssup.c ===
/*++

Module Name:

    mpsyssup.c

Abstract:

    This file contains APIC-related funtions that are
    specific to halmps.  The functions that can be
    shared with the APIC version of the ACPI HAL are
    still in mpsys.c.

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode only.

Revision History:

    Jake Oshins - 10-20-97 - split off from mpsys.c
                             

*/

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"

VOID
HalpMpsPCIPhysicalWorkaround (
    VOID
    );

NTSTATUS
HalpSearchBusForVector(
    IN  INTERFACE_TYPE  BusType,
    IN  ULONG           BusNo,
    IN  ULONG           Vector,
    IN OUT PBUS_HANDLER *BusHandler
    );

BOOLEAN
HalpMPSBusId2NtBusId (
    IN UCHAR                ApicBusId,
    OUT PPCMPBUSTRANS       *ppBusType,
    OUT PULONG              BusNo
    );

//
// Packed, somewhat arbitrary representation of an interrupt source.
// This array, when taken with the next one, allows you to figure
// out which bus-relative source maps to which APIC-relative source.
// 
ULONG       HalpSourceIrqIds[MAX_SOURCE_IRQS];

//
//  Linear mapping of interrupt input on array of I/O APICs, where all the
//  APICs have an ordering.  (Used as index into HalpIntiInfo.  Paired with
//  HalpSourceIrqIds.)
//
USHORT        HalpSourceIrqMapping[MAX_SOURCE_IRQS];

//
// HalpLastEnumeratedActualProcessor - Number of the last processor
// enumerated and returned to the OS.   (Reset on resume from hibernate).
//
// This variable is incremented independently of the processor number
// NT uses.
//

UCHAR         HalpLastEnumeratedActualProcessor = 0;

extern USHORT HalpEisaIrqMask;
extern USHORT HalpEisaIrqIgnore;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitIntiInfo)
#pragma alloc_text(INIT,HalpMpsPCIPhysicalWorkaround)
#pragma alloc_text(PAGELK,HalpGetApicInterruptDesc)
#pragma alloc_text(PAGELK, HalpEnableLocalNmiSources)
#pragma alloc_text(PAGE, HalpMPSBusId2NtBusId)
#pragma alloc_text(PAGE, HalpFindIdeBus)
#pragma alloc_text(PAGE, HalpSearchBusForVector)
#pragma alloc_text(PAGE, HalpInterruptsDescribedByMpsTable)
#pragma alloc_text(PAGE, HalpPci2MpsBusNumber)
#endif

VOID
HalpInitIntiInfo (
    VOID
    )
/*++

Routine Description:

    This function is called at initialization time before any interrupts
    are connected.  It reads the PC+MP Inti table and builds internal
    information needed to route each Inti.

Return Value:

    The following structures are filled in:
        HalpIntiInfo
        HalpSourceIrqIds
        HalpSourceIrqMapping
        HalpISAIqpToVector

--*/
{
    ULONG           ApicNo, BusNo, InterruptInput, IdIndex;
    PPCMPINTI       pInti;
    PPCMPIOAPIC     pIoApic;
    PPCMPPROCESSOR  pProc;
    PPCMPBUSTRANS   pBusType;
    ULONG           i, id;
    UCHAR           Level, Polarity;

    //
    // Clear IntiInfo table
    //

    for (i=0; i < MAX_INTI; i++) {
        HalpIntiInfo[i].Type = 0xf;
        HalpIntiInfo[i].Level = 0;
        HalpIntiInfo[i].Polarity = 0;
    }

    //
    // Check for MPS bios work-around
    //

    HalpMpsPCIPhysicalWorkaround();

    //
    // Initialize HalpMaxApicInti table
    //

    for (pInti = HalpMpInfoTable.IntiEntryPtr;
         pInti->EntryType == ENTRY_INTI;
         pInti++) {


        //
        // Which IoApic number is this?
        //

        for (pIoApic = HalpMpInfoTable.IoApicEntryPtr, ApicNo = 0;
             pIoApic->EntryType == ENTRY_IOAPIC;
             pIoApic++, ApicNo++) {

            if ( (pInti->IoApicId == pIoApic->IoApicId) || 
                 (pInti->IoApicId == 0xff) )  {
                break;
            }
        }

        if ( (pInti->IoApicId != pIoApic->IoApicId) &&
                 (pInti->IoApicId != 0xff) )  {
            DBGMSG ("PCMP table corrupt - IoApic not found for Inti\n");
            continue;
        }

        if (!(pIoApic->IoApicFlag & IO_APIC_ENABLED)) {
            DBGMSG ("PCMP IoApic for Inti is disabled\n");
            continue;
        }

        //
        // Make sure we are below the max # of IOApic which
        // are supported
        //

        ASSERT (ApicNo < MAX_IOAPICS);

        //
        // Track Max Inti line per IOApic
        //

        if (pInti->IoApicInti >= HalpMaxApicInti[ApicNo]) {
            HalpMaxApicInti[ApicNo] = pInti->IoApicInti+1;
        }
    }

    //
    // Make sure there aren't more Inti lines then we can support
    //

    InterruptInput = 0;
    for (i=0; i < MAX_IOAPICS; i++) {
        InterruptInput += HalpMaxApicInti[i];
    }
    ASSERT (InterruptInput < MAX_INTI);

    //
    // Look at each Inti and record it's type in it's
    // corresponding array entry
    //

    IdIndex = 0;
    for (pInti = HalpMpInfoTable.IntiEntryPtr;
         pInti->EntryType == ENTRY_INTI;
         pInti++) {

        //
        // Which IoApic number is this?
        //

        for (pIoApic = HalpMpInfoTable.IoApicEntryPtr, ApicNo = 0;
             pIoApic->EntryType == ENTRY_IOAPIC;
             pIoApic++, ApicNo++) {

            if ( (pInti->IoApicId == pIoApic->IoApicId) || 
                 (pInti->IoApicId == 0xff) )  {
                break;
            }
        }

        if (!(pIoApic->IoApicFlag & IO_APIC_ENABLED)) {
            continue;
        }

        //
        // Determine the NT bus this INTI is on
        //

        if (!HalpMPSBusId2NtBusId (pInti->SourceBusId, &pBusType, &BusNo)) {
            DBGMSG ("HAL: Initialize INTI - unkown MPS bus type\n");
            continue;
        }

        //
        // Calulcate InterruptInput value for this APIC Inti
        //

        InterruptInput = pInti->IoApicInti;
        for (i = 0; i < ApicNo; i++) {
            InterruptInput += HalpMaxApicInti[i];
        }

        //
        // Get IntiInfo for this vector.
        //

        Polarity = (UCHAR) pInti->Signal.Polarity;
        Level = HalpInitLevel[pInti->Signal.Level][pBusType->Level];

        //
        // Verify Level & Polarity mappings made sense
        //

#if DBG
        if (!(pBusType->NtType == MicroChannel  ||  !(Level & CFG_ERROR))) {

            DbgPrint("\n\n\n  MPS BIOS problem!  WHQL, fail this machine!\n");
            DbgPrint("Intin:  BusType %s  BusNo: %x\n", 
                     pBusType->PcMpType, 
                     pInti->SourceBusId);
            DbgPrint("  SrcBusIRQ: %x   EL: %x  PO: %x\n",
                     pInti->SourceBusIrq,
                     pInti->Signal.Level,
                     pInti->Signal.Polarity);

            if (pBusType->NtType == PCIBus) {

                DbgPrint("This entry is for PCI device %x on bus %x, PIN %x\n",
                         pInti->SourceBusIrq >> 2,
                         pInti->SourceBusId,
                         (pInti->SourceBusIrq & 0x3) + 1);
            }
        }
#endif        
        Level &= ~CFG_ERROR;

        //
        // See if this inti should go into the mask of inti that
        // we won't assign to ISA devices.
        //
        // The last part of the test here guarantees that we are not
        // picky about any devices that are in the HalpEisaIrqIgnore
        // mask.  This keep the mouse (and possibly other weird devices
        // alive.)
        //

        if ((pBusType->NtType == Isa) && 
            ((Level & ~CFG_MUST_BE) == CFG_LEVEL) &&
            !((1 << pInti->SourceBusIrq) & HalpEisaIrqIgnore)) {
            
            HalpPciIrqMask |= (1 << pInti->SourceBusIrq);
        }

        if ((pBusType->NtType == Eisa) && 
            ((Level & ~CFG_MUST_BE) == CFG_LEVEL)) {
            
            HalpEisaIrqMask |= (1 << pInti->SourceBusIrq);

            if (HalpBusType != MACHINE_TYPE_EISA) {

                //
                // The BIOS thinks that this is an EISA 
                // inti.  But we don't think that this
                // is an EISA machine.  So put this on the 
                // list of PCI inti, too.
                //

                HalpPciIrqMask |= (1 << pInti->SourceBusIrq);
            }
        }

#if DBG
        if (HalpIntiInfo[InterruptInput].Type != 0xf) {
            //
            // Multiple irqs are connected to the Inti line.  Make
            // sure Type, Level, and Polarity are all the same.
            //

            ASSERT (HalpIntiInfo[InterruptInput].Type == pInti->IntType);
            ASSERT (HalpIntiInfo[InterruptInput].Level == Level);
            ASSERT (HalpIntiInfo[InterruptInput].Polarity == Polarity);
        }
#endif
        //
        // Remember this Inti's configuration info
        //

        HalpIntiInfo[InterruptInput].Type = pInti->IntType;
        HalpIntiInfo[InterruptInput].Level = Level;
        HalpIntiInfo[InterruptInput].Polarity = Polarity;

        //
        // Get IRQs encoding for translations
        //

        ASSERT (pBusType->NtType < 16);
        ASSERT (BusNo < 256);

        if ( (pBusType->NtType == PCIBus) &&
             (pInti->SourceBusIrq == 0) )  {
            id = BusIrq2Id(pBusType->NtType, BusNo, 0x80);
        }  else  {
            id = BusIrq2Id(pBusType->NtType, BusNo, pInti->SourceBusIrq);
        }

        //
        // Addinti mapping to translation table, do it now
        //

        HalpSourceIrqIds[IdIndex] = id;
        HalpSourceIrqMapping[IdIndex] = (USHORT) InterruptInput;
        IdIndex++;

        //
        // Lots of source IRQs are supported; however, the PC+MP table
        // allows for an aribtrary number even beyond the APIC limit.
        //

        if (IdIndex >= MAX_SOURCE_IRQS) {
            DBGMSG ("MAX_SOURCE_IRQS exceeded\n");
            break;
        }

    }

    //
    // Fill in the boot processors PCMP Apic ID.
    //

    pProc = HalpMpInfoTable.ProcessorEntryPtr;
    for (i=0; i < HalpMpInfoTable.ProcessorCount; i++, pProc++) {
        if (pProc->CpuFlags & BSP_CPU) {
            ((PHALPRCB)KeGetCurrentPrcb()->HalReserved)->PCMPApicID = pProc->LocalApicId;
        }
    }

    //
    // If this is an EISA machine check the ELCR
    //

    if (HalpBusType == MACHINE_TYPE_EISA) {
        HalpCheckELCR ();
    }
}

BOOLEAN
HalpMPSBusId2NtBusId (
    IN UCHAR                MPSBusId,
    OUT PPCMPBUSTRANS       *ppBusType,
    OUT PULONG              BusNo
    )
/*++

Routine Description:

    Lookup MPS Table BusId into PCMPBUSTRANS (NtType) and instance #.

Arguments:

    MPSBusId    - Bus ID # in MPS table
    ppBusType   - Returned pointer to PPCMPBUSTRANS for this bus type
    BusNo       - Returned instance # of given bus

Return Value:

    TRUE if MPSBusId was cross referenced into an NT id.

--*/
{
    PPCMPBUS        pBus, piBus;
    PPCMPBUSTRANS   pBusType;
    NTSTATUS        status;
    UCHAR           parentBusNo;
    BOOLEAN         foundFirstRootBus = FALSE;

    PAGED_CODE();
    
    //
    // What Bus is this?
    //

    for (pBus = HalpMpInfoTable.BusEntryPtr;
         pBus->EntryType == ENTRY_BUS;
         pBus++) {

        if (MPSBusId == pBus->BusId) {
            break;
        }
    }

    if (MPSBusId != pBus->BusId) {
        DBGMSG ("PCMP table corrupt - Bus not found for Inti\n");
        return FALSE;
    }

    //
    // What InterfaceType is this Bus?
    //

    for (pBusType = HalpTypeTranslation;
         pBusType->NtType != MaximumInterfaceType;
         pBusType++) {

        if (pBus->BusType[0] == pBusType->PcMpType[0]  &&
            pBus->BusType[1] == pBusType->PcMpType[1]  &&
            pBus->BusType[2] == pBusType->PcMpType[2]  &&
            pBus->BusType[3] == pBusType->PcMpType[3]  &&
            pBus->BusType[4] == pBusType->PcMpType[4]  &&
            pBus->BusType[5] == pBusType->PcMpType[5]) {
                break;
        }
    }

    //
    // Which instance of this BusType?
    //
    
    if (!pBusType->PhysicalInstance) {
        
        //
        // This algorithm originally just counted the number
        // of busses of this type.  The newer algorithm works
        // around bugs in the MPS tables.  The rules are listed.
        //
        // 1) The first PCI bus of a given type is always bus
        //    number 0.
        //
        // 2) For busses that are secondary root PCI busses, the
        //    bus number count is incremented to equal the MPS bus
        //    number.
        //
        // 3) For busses that are generated by PCI to PCI bridges,
        //    the bus number is incremented by one.
        //
        //    N.B.  Rule #3 implies that if one bus under a bridge
        //          is described, all must be.
        //
    
        for (piBus = HalpMpInfoTable.BusEntryPtr, *BusNo = 0;
             piBus < pBus;
             piBus++) {

            if (pBus->BusType[0] == piBus->BusType[0]  &&
                pBus->BusType[1] == piBus->BusType[1]  &&
                pBus->BusType[2] == piBus->BusType[2]  &&
                pBus->BusType[3] == piBus->BusType[3]  &&
                pBus->BusType[4] == piBus->BusType[4]  &&
                pBus->BusType[5] == piBus->BusType[5]) {
                    
                status = HalpMpsGetParentBus(piBus->BusId, 
                                             &parentBusNo);

                if (NT_SUCCESS(status)) {

                    //
                    // This is a child bus.
                    //

                    *BusNo += 1;

                } else {

                    //
                    // This is a root bus.
                    //

                    if (!foundFirstRootBus) {
                        
                        //
                        // This is the first root bus.
                        // To work around buggy MPS BIOSes, this
                        // root is always numbered 0.
                        //

                        *BusNo = 0;
                        foundFirstRootBus = TRUE;

                    } else {

                        //
                        // This is a secondary root of this type.  Believe 
                        // the MPS tables.
                        //

                        *BusNo = piBus->BusId;
                    }
                }
            }
        }
    } else {
        *BusNo = pBus->BusId;
    }

    if (pBusType->NtType == MaximumInterfaceType) {
        return FALSE;
    }

    *ppBusType = pBusType;
    return TRUE;
}

VOID
HalpMpsPCIPhysicalWorkaround (
    VOID
    )
{
    PPCMPBUS        pBus;
    PPCMPBUSTRANS   pBusType;

    //
    // The MPS specification has a subtle comment that PCI bus IDs are
    // suppose to match their physical PCI bus number.  Many BIOSes don't
    // do this, so unless there's a PCI bus #0 listed in the MPS table
    // assume that the BIOS is broken
    //

    //
    // Find the PCI interface type
    //

    for (pBusType = HalpTypeTranslation;
         pBusType->NtType != MaximumInterfaceType;
         pBusType++) {

        if (pBusType->PcMpType[0] == 'P'  &&
            pBusType->PcMpType[1] == 'C'    &&
            pBusType->PcMpType[2] == 'I'    &&
            pBusType->PcMpType[3] == ' '    &&
            pBusType->PcMpType[4] == ' '    &&
            pBusType->PcMpType[5] == ' '  ) {
                break;
        }
    }

    //
    // Find the bus with ID == 0
    //

    pBus = HalpMpInfoTable.BusEntryPtr;
    while (pBus->EntryType == ENTRY_BUS) {

        if (pBus->BusId == 0) {

            //
            // If it's a PCI bus, assume physical bus IDs
            //

            if (pBus->BusType[0] != 'P' ||
                pBus->BusType[1] != 'C' ||
                pBus->BusType[2] != 'I' ||
                pBus->BusType[3] != ' ' ||
                pBus->BusType[4] != ' ' ||
                pBus->BusType[5] != ' '  ) {

                //
                // Change default behaviour of PCI type
                // from physical to virtual
                //

                pBusType->PhysicalInstance = FALSE;
            }

            break;
        }

        pBus += 1;
    }
}



BOOLEAN
HalpGetApicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PUSHORT PcMpInti
    )
/*++

Routine Description:

    This procedure gets a "Inti" describing the requested interrupt

Arguments:

    BusType - The Bus type as known to the IO subsystem

    BusNumber - The number of the Bus we care for

    BusInterruptLevel - IRQ on the Bus

Return Value:

    TRUE if PcMpInti found; otherwise FALSE.

    PcMpInti - A number that describes the interrupt to the HAL.

--*/
{
    ULONG   i, id;

    if (BusType < 16  &&  BusNumber < 256  &&  BusInterruptLevel < 256) {

        //
        // get unique BusType,BusNumber,BusInterrupt ID
        //

        id = BusIrq2Id(BusType, BusNumber, BusInterruptLevel);

        //
        // Search for ID of Bus Irq mapping, and return the corresponding
        // InterruptLine.
        //

        for (i=0; i < MAX_SOURCE_IRQS; i++) {
            if (HalpSourceIrqIds[i] == id) {
                *PcMpInti = HalpSourceIrqMapping[i];
                return TRUE;
            }
        }
    }

    //
    // Not found or search out of range
    //

    return FALSE;
}

PBUS_HANDLER
HalpFindIdeBus(
    IN  ULONG   Vector
    )
{
    PBUS_HANDLER    ideBus;
    NTSTATUS        status;
    ULONG           pciNo;

    PAGED_CODE();
    
    status = HalpSearchBusForVector(Isa, 0, Vector, &ideBus);

    if (NT_SUCCESS(status)) {
        return ideBus;
    }

    status = HalpSearchBusForVector(Eisa, 0, Vector, &ideBus);

    if (NT_SUCCESS(status)) {
        return ideBus;
    }

    status = HalpSearchBusForVector(MicroChannel, 0, Vector, &ideBus);

    if (NT_SUCCESS(status)) {
        return ideBus;
    }

    for (pciNo = 0; pciNo <= 255; pciNo++) {
    
        status = HalpSearchBusForVector(PCIBus, pciNo, Vector, &ideBus);
    
        if (NT_SUCCESS(status)) {
            return ideBus;
        }

        if (status == STATUS_NO_SUCH_DEVICE) {
            break;
        }
    }

    return NULL;
}

NTSTATUS
HalpSearchBusForVector(
    IN  INTERFACE_TYPE  BusType,
    IN  ULONG           BusNo,
    IN  ULONG           Vector,
    IN OUT PBUS_HANDLER *BusHandler
    )
{
    PBUS_HANDLER    ideBus;
    NTSTATUS        status;
    BOOLEAN         found;
    USHORT          inti;

    PAGED_CODE();
    
    ideBus = HaliHandlerForBus(BusType, BusNo);
    
    if (!ideBus) {
        return STATUS_NO_SUCH_DEVICE;
    }
    
    found = HalpGetApicInterruptDesc(BusType,
                                     BusNo,
                                     Vector,
                                     &inti);

    if (!found) {
        return STATUS_NOT_FOUND;
    }

    *BusHandler = ideBus;

    return STATUS_SUCCESS;
}

ULONG
HalpGetIoApicId(
    ULONG   ApicNo
    )
{
    return (ULONG) HalpMpInfoTable.IoApicEntryPtr[ApicNo].IoApicId;
}

VOID
HalpMarkProcessorStarted(
    ULONG   ApicID,
    ULONG   NtNumber
    )
{
    return;
}

ULONG
HalpInti2BusInterruptLevel(
    ULONG   Inti
    )
/*++

Routine Description:

    This procedure does a lookup to find a bus-relative
    interrupt vector associated with an Inti.
    
    Note:  If two different devices are sharing an interrupt,
    this function will return the answer for the first one
    that it finds.  Fortunately, the only devices that use
    their bus-relative vectors for anything (ISA devices)
    can't share interrupts.

Arguments:

    Inti - Interrupt Input on an I/O APIC

Return Value:

    A bus-relative interrupt vector.

--*/
{
    ULONG   i;

    for (i=0; i < MAX_SOURCE_IRQS; i++) {
        
        if (HalpSourceIrqMapping[i] == Inti) {
            
            return Id2BusIrq(HalpSourceIrqIds[i]);
        }
    }
    
    //
    // We should never fail to find a mapping.
    //
    
#if DBG
    KeBugCheckEx(HAL_INITIALIZATION_FAILED, 5, Inti, 0, 0);
#endif

    return 0;
}

NTSTATUS
HalpGetNextProcessorApicId(
    IN ULONG         PrcbProcessorNumber,
    IN OUT UCHAR    *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID of a non-started processor,
    which will be started by HalpStartProcessor.

Arguments:

    PrcbProcessorNumber - The logical processor number that will
        be associated with this APIC ID.
        
    ApicId - pointer to a value to fill in with the APIC ID.        

Return Value:

    status

--*/
{
    PPCMPPROCESSOR ApPtr;
    ULONG ProcessorNumber;

    if (PrcbProcessorNumber == 0) {

        //
        // I don't believe anyone ever askes for 0 and I plan not
        // to handle it.  peterj 12/5/00.
        //

        KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                     6,
                     HalpLastEnumeratedActualProcessor,
                     0,
                     0);
    }

    if (HalpLastEnumeratedActualProcessor >= HalpMpInfoTable.ProcessorCount) {

        //
        // Sorry, no more processors.
        //

        return STATUS_NOT_FOUND;
    }

    ++HalpLastEnumeratedActualProcessor;
    ProcessorNumber = HalpLastEnumeratedActualProcessor;

    //
    //  Get the MP Table entry for this processor
    //

    ApPtr = HalpMpInfoTable.ProcessorEntryPtr;


#if 0
    if (ProcessorNumber == 0) {

        //
        // Return the ID of the boot processor (BSP).
        //

        while (ApPtr->EntryType == ENTRY_PROCESSOR) {
            if ((ApPtr->CpuFlags & CPU_ENABLED) &&
                (ApPtr->CpuFlags & BSP_CPU)) {
                *ApicId = (UCHAR)ApPtr->LocalApicId;
                return STATUS_SUCCESS;
            }
            ++ApPtr;
        }

        //
        // Boot processor not found.
        //

        return STATUS_NOT_FOUND;
    }
#endif

    //
    // Skip 'ProcessorNumber' enabled processors.  The next enabled
    // processor entry (after those) will be the "next" processor.
    //
    // Note: The BSP may not be amongst the first 'ProcessorNumber'
    // processors so we must skip 'ProcessorNumber' - 1, and check
    // for the and skip the BSP.
    //

    --ProcessorNumber;

    while ((ProcessorNumber) && (ApPtr->EntryType == ENTRY_PROCESSOR)) {
        if ((ApPtr->CpuFlags & CPU_ENABLED) &&
            !(ApPtr->CpuFlags & BSP_CPU)) {

            //
            // Account for this entry (we have already started it) if this
            // processor is enabled and not the BSP (we decremented for the
            // BSP before entering the loop).
            //
            --ProcessorNumber;
        }
        ++ApPtr;
    }

    //
    // Find the first remaining enabled processor.
    //

    while(ApPtr->EntryType == ENTRY_PROCESSOR) {
        if ((ApPtr->CpuFlags & CPU_ENABLED) &&
           !(ApPtr->CpuFlags & BSP_CPU)) {
            *ApicId = (UCHAR)ApPtr->LocalApicId;
            return STATUS_SUCCESS;
        }
        ++ApPtr;
    }

    //
    // We did not find another processor.
    //

    return STATUS_NOT_FOUND;
}

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID for a given processor.
    It is intended this routine be able to produce the same
    APIC ID order as HalpGetNextProcessorApicId.

    Note:  This won't actually work in the presence of skipped
    procesors.

Arguments:

    Processor - The logical processor number that is
        associated with this APIC ID.

    ApicId - pointer to a value to fill in with the APIC ID.

Return Value:

    status

--*/
{
    PPCMPPROCESSOR ApPtr;

    //
    //  Get the MP Table entry for this processor
    //

    ApPtr = HalpMpInfoTable.ProcessorEntryPtr;

    if (Processor == 0) {

        //
        // Return the ID of the boot processor (BSP).
        //

        while (ApPtr->EntryType == ENTRY_PROCESSOR) {
            if ((ApPtr->CpuFlags & CPU_ENABLED) &&
                (ApPtr->CpuFlags & BSP_CPU)) {
                *ApicId = (UCHAR)ApPtr->LocalApicId;
                return STATUS_SUCCESS;
            }
            ++ApPtr;
        }

        //
        // Boot processor not found.
        //

        return STATUS_NOT_FOUND;
    }

    for ( ; TRUE ; ApPtr++) {

        if (ApPtr->EntryType != ENTRY_PROCESSOR) {

            //
            // Out of processor entries, fail.
            //

            return STATUS_NOT_FOUND;
        }

        if (ApPtr->CpuFlags & BSP_CPU) {

            //
            // BSP is processor 0 and is not considered in the
            // search for processors other than 0.
            //

            continue;
        }

        if (ApPtr->CpuFlags & CPU_ENABLED) {

            //
            // Count this processor.
            //

            Processor--;

            if (Processor == 0) {
                break;
            }
        }
    }

    ASSERT(ApPtr->EntryType == ENTRY_PROCESSOR);

    *ApicId = ApPtr->LocalApicId;
    return STATUS_SUCCESS;
}

BOOLEAN
HalpInterruptsDescribedByMpsTable(
    IN UCHAR MpsBusNumber
    )
{
    PPCMPINTI busInterrupt;

    PAGED_CODE();

    for (busInterrupt = HalpMpInfoTable.IntiEntryPtr;
         busInterrupt->EntryType == ENTRY_INTI;
         busInterrupt++) {

        //
        // The MPS spec requires that, if one interrupt
        // on a bus is described, all interrupts on that
        // bus must be described.  So finding one match
        // is enough.
        //

        if (busInterrupt->SourceBusId == MpsBusNumber) {

            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
HalpPci2MpsBusNumber(
    IN UCHAR PciBusNumber,
    OUT UCHAR *MpsBusNumber
    )
{
    PPCMPBUSTRANS busType;
    ULONG mpsBusNumber = 0;
    ULONG busNumber;
    
    PAGED_CODE();
    
    for (mpsBusNumber = 0;
         mpsBusNumber < 0x100;
         mpsBusNumber++) {

        if (HalpMPSBusId2NtBusId((UCHAR)mpsBusNumber,
                                 &busType,
                                 &busNumber)) {

            if ((busType->NtType == PCIBus) &&
                (PciBusNumber == (UCHAR)busNumber)) {
    
                *MpsBusNumber = (UCHAR)mpsBusNumber;
                return STATUS_SUCCESS;
            }
        }
    }
    
    return STATUS_NOT_FOUND;
}

VOID
HalpEnableLocalNmiSources(
    VOID
    )
/*++

Routine Description:

    This routine parses the information from the MP table and 
    enables any NMI sources in the local APIC of the processor
    that it is running on.
    
    Callers of this function must be holding HalpAccountingLock.

Arguments:

Return Value:

--*/
{
    PKPCR       pPCR;
    UCHAR       ThisCpu;
    UCHAR       LocalApicId;
    PPCMPLINTI  pEntry;
    ULONG       NumEntries;

    pPCR = KeGetPcr();
    ThisCpu = pPCR->Prcb->Number;

    //
    //  Enable local processor NMI source
    //

    LocalApicId = ((PHALPRCB)pPCR->Prcb->HalReserved)->PCMPApicID;
    NumEntries = HalpMpInfoTable.LintiCount;

    for (pEntry = HalpMpInfoTable.LintiEntryPtr;
         ((pEntry) && (NumEntries > 0));
        pEntry++, --NumEntries) {

        if ( ( (pEntry->DestLocalApicId == LocalApicId) ||
               (pEntry->DestLocalApicId == 0xff))  &&
             (pEntry->IntType == INT_TYPE_NMI) ) {

            //
            // Found local NMI source, enable it
            //

            if (pEntry->DestLocalApicInti == 0) {
                pLocalApic[LU_INT_VECTOR_0/4] = ( LEVEL_TRIGGERED |
                    ACTIVE_HIGH | DELIVER_NMI | NMI_VECTOR);
            } else {
                pLocalApic[LU_INT_VECTOR_1/4] = ( LEVEL_TRIGGERED |
                    ACTIVE_HIGH | DELIVER_NMI | NMI_VECTOR);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halmps\i386\mpsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;Copyright (c) 1992  Intel Corporation
;All rights reserved
;
;INTEL CORPORATION PROPRIETARY INFORMATION
;
;This software is supplied to Microsoft under the terms
;of a license agreement with Intel Corporation and may not be
;copied nor disclosed except in accordance with the terms
;of that agreement.
;
;
;Module Name:
;
;    mpsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to begin/end
;    system interrupts for a PC+MP implementation
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;    Ron Mosgrove (Intel) Aug 1993
;        Modified for PC+MP Systems
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
        .list

        EXTRNP  _KeBugCheck,1,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT
        extrn  _HalpVectorToIRQL:byte
        extrn  _HalpIRQLtoTPR:byte

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "End System Interrupt"
;++
;
; VOID
; HalpEndSystemInterrupt
;    IN KIRQL NewIrql,
;    IN ULONG Vector
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Vector - Vector number of the interrupt
;
;    Note that esp+12 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HeiNewIrql      equ     [esp + 4]
HeiVector       equ     [esp + 8]

cPublicProc _HalEndSystemInterrupt  ,2
cPublicFpo 2, 0
        xor     ecx,ecx
        mov     cl, byte ptr HeiNewIrql         ; get new IRQL
        mov     cl, _HalpIRQLtoTPR[ecx]         ; get corresponding TPR value

        mov     dword ptr APIC[LU_EOI], 0       ; send EOI to APIC local unit
        APICFIX edx

        cmp     cl, DPC_VECTOR                  ; Is new irql < DPC?
        jc      short es10                      ; Yes, go check for pending DPC

es05:   mov     dword ptr APIC[LU_TPR], ecx     ; Set new Priority

;
; We have to ensure that the requested priority is set before
; we return.  The caller is counting on it.
;
        mov     edx, dword ptr APIC[LU_TPR]
        CHECKTPR   ecx, edx
        stdRET    _HalEndSystemInterrupt

es10:   cmp     PCR[PcHal.DpcPending], 0        ; Is a DPC pending?
        mov     PCR[PcHal.ShortDpc], 0          ; Clear short dpc flag
        jz      short es05                      ; No, eoi

        mov     dword ptr APIC[LU_TPR], DPC_VECTOR  ; lower to DPC level
        APICFIX edx

        push    ebx                             ; Save EBX (used by KiDispatchInterrupt)
        push    ecx                             ; Save OldIrql
cPublicFpo 2, 2

        sti

es20:   mov     PCR[PcHal.DpcPending], 0        ; Clear pending flag

        stdCall _KiDispatchInterrupt            ; Dispatch interrupt

        cli

        pop     ecx
        pop     ebx
        jmp     short es05

stdENDP _HalEndSystemInterrupt


;++
;
;BOOLEAN
;HalBeginSystemInterrupt(
;    IN KIRQL Irql
;    IN ULONG Vector,
;    OUT PKIRQL OldIrql
;    )
;
;Routine Description:
;
;   This routine raises the IRQL to the level of the specified
;   interrupt vector.  It is called by the hardware interrupt
;   handler before any other interrupt service routine code is
;   executed.  The CPU interrupt flag is set on exit.
;
;   On APIC-based systems we do not need to check for spurious
;   interrupts since they now have their own vector.  We also
;   no longer need to check whether or not the incoming priority
;   is higher than the current priority that is guaranteed by
;   the priority mechanism of the APIC.
;
;   SO
;
;   All BeginSystemInterrupt needs to do is set the APIC TPR
;   appropriate for the IRQL, and return TRUE.  Note that to
;   use the APIC ISR priority we are not going issue EOI until
;   EndSystemInterrupt is called.
;
; Arguments:
;
;    Irql   - Supplies the IRQL to raise to
;
;    Vector - Supplies the vector of the interrupt to be
;             handled
;
;    OldIrql- Location to return OldIrql
;
; Return Value:
;
;    TRUE -  Interrupt successfully dismissed and Irql raised.
;            This routine can not fail.
;
;--


align dword
HbsiIrql        equ     byte  ptr [esp+4]
HbsiVector      equ     byte  ptr [esp+8]
HbsiOldIrql     equ     dword ptr [esp+12]

cPublicProc _HalBeginSystemInterrupt ,3
cPublicFpo 3, 0

        xor     eax, eax
        mov     al, HbsiIrql            ; (eax) = New Vector
        mov     al, _HalpIRQLtoTPR[eax]     ; get corresponding TPR value

        ;
        ; Read the TPR for the Priority (Vector) in use,
        ; and convert it to an IRQL
        ;

        mov     ecx, dword ptr APIC[LU_TPR]   ; Get the Priority
        mov     dword ptr APIC[LU_TPR], eax
        APICFIX edx

        mov     eax, HbsiOldIrql        ; return the current IRQL as OldIrql
        shr     ecx, 4
        mov     cl, byte ptr _HalpVectorToIRQL[ecx]

        mov     byte ptr [eax], cl
        mov     eax, 1                  ; return TRUE
        sti

        ;
        ; If OldIrql < DISPATCH_LEVEL and new irql >= DISPATCH_LEVEL (which
        ; is assumed), then set
        ;

        cmp     cl, DISPATCH_LEVEL
        jnc     short bs10

if DBG
        cmp     PCR[PcHal.ShortDpc], 0
        je      short @f
        int 3
@@:
endif
        mov     PCR[PcHal.ShortDpc], DISPATCH_LEVEL

bs10:
        stdRET    _HalBeginSystemInterrupt
stdENDP _HalBeginSystemInterrupt

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\halp.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/


#ifndef _HALP_H_
#define _HALP_H_

#include <nthal.h>
#include <hal.h>
#include <hali.h>
#include "ssc.h"
#include "..\..\inc\hali.h"

/*
 * Default clock and profile timer intervals (in 100ns-unit)
 */
#define DEFAULT_CLOCK_INTERVAL 100000         // 10  ms
#define MINIMUM_CLOCK_INTERVAL 10000          //  1  ms
#define MAXIMUM_CLOCK_INTERVAL 100000         // 10  ms



/*
 * Device IRQLs (must be in sync with the values defined in the header
 * files for the disk, keyboard, and mouse drivers.)
 */

#define DISK_IRQL       4
#define MOUSE_IRQL      5
#define KEYBOARD_IRQL   6
#define SERIAL_IRQL     7

/*
 * PCR address.
 * Temporary macros; should already be defined in ntddk.h for IA64
 */

#define PCR ((volatile KPCR * const)KIPCR)

#define MiGetPteAddress(va) ((PHARDWARE_PTE)(__thash((ULONG_PTR)(va))))


extern VOID
HalpInitializeInterrupts (
    VOID
    );

extern VOID
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

extern VOID
HalpProfileInterrupt (
    IN PKTRAP_FRAME TrapFrame
    );

extern VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

#endif /* _HALP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\ixinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixinfo.c

Abstract:

Author:

    Ken Reneris (kenr)  08-Aug-1994

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"

VOID
HalInitSystemPhase2 (
    VOID
    );

#ifdef _PNP_POWER_
HAL_CALLBACKS   HalCallback;
extern WCHAR    rgzSuspendCallbackName[];

VOID
HalpLockSuspendCode (
    IN PVOID    CallbackContext,
    IN PVOID    Argument1,
    IN PVOID    Argument2
    );
#endif

NTSTATUS
HalpQueryInstalledBusInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HaliQuerySystemInformation)
#pragma alloc_text(PAGE,HaliSetSystemInformation)
#pragma alloc_text(INIT,HalInitSystemPhase2)

#ifdef _PNP_POWER_
#pragma alloc_text(PAGE,HalpLockSuspendCode)
#endif

#endif


VOID
HalInitSystemPhase2 (
    VOID
    )
{
#ifdef _PNP_POWER_
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    UNICODE_STRING                  unicodeString;
    PCALLBACK_OBJECT                CallbackObject;

    //
    // Create hal callbacks
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );


    ExCreat