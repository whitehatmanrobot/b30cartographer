_GlintUnsignedIntFmat;
typedef signed32       __GlintSignedIntFmat;
typedef unsigned32     __GlintDataFmat;
typedef signed32       __Glint16FixPt16Fmat;
typedef signed32       __Glint16BitIntFmat;
typedef unsigned32     __GlintBitMaskPatternFmat;
typedef unsigned32     __GlintPointTableFmat;
typedef unsigned32     __GlintAreaStipplePatternFmat;
typedef unsigned32     __GlintSaveLineStippleStateFmat;
typedef unsigned32     __GlintUpdateLineStippleStateFmat;
typedef signed32       __GlintABGRFmat;
typedef signed32       __GlintLBSourceOffsetFmat;
typedef unsigned32     __GlintLBWindowBaseFmat;
typedef unsigned32     __GlintLBDepthFmat;
typedef unsigned32     __GlintDepthFmat;
typedef signed32       __GlintUZFmat;
typedef unsigned32     __GlintLZFmat;
typedef signed32       __GlintFastClearDepthFmat;
typedef signed32       __GlintFBPixelOffsetFmat;
typedef signed32       __GlintFBSourceOffsetFmat;
typedef unsigned32     __GlintFBWindowBaseFmat;
typedef unsigned32     __GlintFBRDataFmat;
typedef unsigned32     __GlintFBSoftwareWriteMaskFmat;
typedef unsigned32     __GlintFBHardwareWriteMaskFmat;
typedef unsigned32     __GlintFBModifiedDataFmat;
typedef unsigned32     __GlintFBPixelWriteMaskFmat;
typedef unsigned32     __GlintFBBlockColorFmat;
typedef unsigned32     __GlintFBBlockColorUFmat;
typedef unsigned32     __GlintFBBlockColorLFmat;
typedef signed32       __Glint1x8InterpFmat;
typedef signed32       __GlintFogFmat;
typedef unsigned char  __GlintStencilValFmat;
typedef unsigned32     __GlintAddress;

typedef unsigned32     __GlintWaitForCompletionFmat;

typedef unsigned32     __GlintCoverageValueFmat;
typedef unsigned32     __GlintSpanMaskFmat;

typedef unsigned32     __GlintFBSourceDataFmat;
typedef unsigned32     __GlintFBDataFmat;

typedef struct {
  unsigned32 lo;
  unsigned32 hi;
} __GlintLBRawDataFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:          27;
  unsigned32 Sign:           1;
  unsigned32 Magnitude:      4;
} __GlintSubPixelCorrectionFmat;
#else
//@@BEGIN_DDKSPLIT
// TMP HACK TO GET NT GOING
//@@END_DDKSPLIT
typedef unsigned32 __GlintSubPixelCorrectionFmat;
/*
typedef struct {
  unsigned32 Magnitude:      4;
  unsigned32 Sign:           1;
  unsigned32 pad0:          27;
} __GlintSubPixelCorrectionFmat;
*/
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 XRight:     16;
  unsigned32 XLeft:      16;
} __GlintFastBlockLimitsFmat;
#else
typedef struct {
  unsigned32 XLeft:      16;
  unsigned32 XRight:     16;
} __GlintFastBlockLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Depth:      32; 
  unsigned32 pad:        12;
  unsigned32 GID:         4; 
  unsigned32 FrameCount:  8; 
  unsigned32 Stencil:     8; 
} __GlintLBDataFmat;
#else
typedef struct {
  unsigned32 Depth:      32; 
  unsigned32 Stencil:     8; 
  unsigned32 FrameCount:  8; 
  unsigned32 GID:         4; 
  unsigned32 pad:        12;
} __GlintLBDataFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 V:                12; /* 12@20 */
  unsigned32 U:                20; /* 20@0  */
  unsigned32 pad0:             24; /* 24@8  */
  unsigned32 V_u:              8;  /* 8@0   */
} __GlintTexelCoordUVFmat;
#else
/* CHECK THIS */
typedef struct {
  unsigned32 V_u:              8;  /* 8@0   */
  unsigned32 pad0:             24; /* 24@8  */
  unsigned32 U:                20; /* 20@0  */
  unsigned32 V:                12; /* 12@20 */
} __GlintTexelCoordUVFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:          25;
  unsigned32 Present0:       1;
  unsigned32 BorderColor0:   1;
  unsigned32 Depth0:         5;
} __GlintTexelDataFmat;
#else
typedef struct {
  unsigned32 Depth0:         5;
  unsigned32 BorderColor0:   1;
  unsigned32 Present0:       1;
  unsigned32 pad0:          25;
} __GlintTexelDataFmat;
#endif

// SuspendUntilFrameBlank tag has two formats dependant on sync_mode and
// defined by the Hardware FB Arbiter
//

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 sync_mode:           2;
  unsigned32 pad2:                3;
  unsigned32 ext_index:          11;
  unsigned32 pad1:                8;
  unsigned32 ext_data:            8;
} __GlintSuspendUntilFrameBlankExtFmat;
#else
typedef struct {
  unsigned32 ext_data:            8;
  unsigned32 pad1:                8;
  unsigned32 ext_index:          11;
  unsigned32 pad2:                3;
  unsigned32 sync_mode:           2;
} __GlintSuspendUntilFrameBlankExtFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 sync_mode:           2;
  unsigned32 pad:                20;
  unsigned32 vtg_sclk:            1;
  unsigned32 vtg_data:            9;
} __GlintSuspendUntilFrameBlankVtgFmat;
#else
typedef struct {
  unsigned32 vtg_data:            9;
  unsigned32 vtg_sclk:            1;
  unsigned32 pad:                20;
  unsigned32 sync_mode:           2;
} __GlintSuspendUntilFrameBlankVtgFmat;
#endif


typedef struct {
  unsigned32 UnitEnable: 32; 
} __GlintEnableFmat;

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Y:  16;
  signed32 X:  16;
} __GlintXYFmat;
#else
typedef struct {
  signed32 X:  16;
  signed32 Y:  16;
} __GlintXYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 top:  16;
  signed32 left:  16;
} __GlintRectOrigin;
#else
typedef struct {
  signed32 left:  16;
  signed32 top:  16;
} __GlintRectOrigin;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 cy:  16;
  signed32 cx:  16;
} __GlintRectSize;
#else
typedef struct {
  signed32 cx:  16;
  signed32 cy:  16;
} __GlintRectSize;
#endif

typedef __GlintXYFmat __GlintStepFmat;

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Y:             16;
  signed32 X:             16; /* 16@0 */
  unsigned32 pad0:        30;
  unsigned32 WriteMode:    2; /* 2@0 */
} __GlintLBStepFmat;
#else 
typedef struct {
  signed32 X:             16; /* 16@0 */
  signed32 Y:             16;
  unsigned32 WriteMode:    2; /* 2@0 */
  unsigned32 pad0:        30;
} __GlintLBStepFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
 unsigned32 pad0:         16;
 unsigned32 Val:          16;
} __GlintCountFmat;
#else
//@@BEGIN_DDKSPLIT
// TMP HACK TO GET NT GOING
//@@END_DDKSPLIT
typedef unsigned32 __GlintCountFmat;
/*
typedef struct {
 unsigned32 Val:          16;
 unsigned32 pad0:         16;
} __GlintCountFmat;
*/
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 YOrigin:  16;
  signed32 XOrigin:  16;
} __GlintGIDTableFmat;
#else
typedef struct {
  signed32 XOrigin:  16;
  signed32 YOrigin:  16;
} __GlintGIDTableFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                 30;
  unsigned32 ScreenScissorEnable:  1; 
  unsigned32 UserScissorEnable:    1;
} __GlintScissorEnableFmat;
#else
typedef struct {
  unsigned32 UserScissorEnable:    1;
  unsigned32 ScreenScissorEnable:  1; 
  unsigned32 pad:                 30;
} __GlintScissorEnableFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                     13;
  unsigned32 SpanOperation:             1;
  unsigned32 pad0:                      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 CoverageEnable:            1;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 UsePointTable:             1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 AntialiasEnable:           1;
  unsigned32 PrimitiveType:             2;
  unsigned32 FastFillIncrement:         2; /* unused on TX */
  unsigned32 FastFillEnable:            1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 AreaStippleEnable:         1;
} __GlintRenderFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:         1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 FastFillEnable:            1;
  unsigned32 FastFillIncrement:         2; /* unused on TX */
  unsigned32 PrimitiveType:             2;
  unsigned32 AntialiasEnable:           1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 UsePointTable:             1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 CoverageEnable:            1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 pad0:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad1:                     13;
} __GlintRenderFmat;
#endif

typedef __GlintRenderFmat __GlintPrepareToRenderFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                13;
  unsigned32 YLimitsEnable:        1;
  unsigned32 MultiGLINT:           1;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 BitMaskOffset:        5;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 pad0:                 1;
  unsigned32 BiasCoordinates:      2;
  unsigned32 FractionAdjust:       2;
  unsigned32 InvertBitMask:        1;
  unsigned32 MirrorBitMask:        1;
} __GlintRasterizerModeFmat;
#else
typedef struct {
  unsigned32 MirrorBitMask:        1;
  unsigned32 InvertBitMask:        1;
  unsigned32 FractionAdjust:       2;
  unsigned32 BiasCoordinates:      2;
  unsigned32 pad0:                 1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskOffset:        5;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 MultiGLINT:           1;
  unsigned32 YLimitsEnable:        1;
  unsigned32 pad1:                13;
} __GlintRasterizerModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                5;
  unsigned32 MirrorStippleMask:  1;
  unsigned32 StippleMask:       16;
  unsigned32 RepeatFactor:       9;
  unsigned32 UnitEnable:         1;
} __GlintLineStippleModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:         1;
  unsigned32 RepeatFactor:       9;
  unsigned32 StippleMask:       16;
  unsigned32 MirrorStippleMask:  1;
  unsigned32 pad:         5;
} __GlintLineStippleModeFmat;
#endif

typedef __GlintXYFmat __GlintScreenRegionFmat;
typedef __GlintXYFmat __GlintScissorMinXYFmat;
typedef __GlintXYFmat __GlintScissorMaxXYFmat;
typedef __GlintXYFmat __GlintWindowOriginFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                   6;
  unsigned32 SegmentRepeatCounter:  9;
  unsigned32 SegmentBitCounter:     4;
  unsigned32 LiveRepeatCounter:     9;
  unsigned32 LiveBitCounter:        4;
} __GlintLineStippleCountersFmat;
#else
typedef struct {
  unsigned32 LiveBitCounter:        4;
  unsigned32 LiveRepeatCounter:     9;
  unsigned32 SegmentBitCounter:     4;
  unsigned32 SegmentRepeatCounter:  9;
  unsigned32 pad:                   6;
} __GlintLineStippleCountersFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                 12;
  unsigned32 MirrorY:              1;
  unsigned32 MirrorX:              1;
  unsigned32 InvertStipplePattern: 1;
  unsigned32 YOffset:              5;
  unsigned32 XOffset:              5;
  unsigned32 YAddressSelect:       3;
  unsigned32 XAddressSelect:       3;
  unsigned32 UnitEnable:           1;
} __GlintAreaStippleModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:           1;
  unsigned32 XAddressSelect:       3;
  unsigned32 YAddressSelect:       3;
  unsigned32 XOffset:              5;
  unsigned32 YOffset:              5;
  unsigned32 InvertStipplePattern: 1;
  unsigned32 MirrorX:              1;
  unsigned32 MirrorY:              1;
  unsigned32 pad:                 12;
} __GlintAreaStippleModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                31;
  unsigned32 Order:                1;
} __GlintRouterModeFmat;
#else 
typedef struct {
  unsigned32 Order:                1;
  unsigned32 pad0:                31;
} __GlintRouterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:        30;
  unsigned32 ShadeMode:   1;
  unsigned32 UnitEnable:  1;
} __GlintColorDDAModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:  1;
  unsigned32 ShadeMode:   1;
  unsigned32 pad:        30;
} __GlintColorDDAModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:            8;
  unsigned32 Blue:             8;
  unsigned32 Green:            8;
  unsigned32 Red:              8;
} __GlintColorFmat;
#else
//@@BEGIN_DDKSPLIT
// TMP HACK TO GET NT GOING
//@@END_DDKSPLIT
typedef unsigned32 __GlintColorFmat;
/*
typedef struct {
  unsigned32 Red:              8;
  unsigned32 Green:            8;
  unsigned32 Blue:             8;
  unsigned32 Alpha:            8;
} __GlintColorFmat;
*/
#endif

typedef __GlintColorFmat __GlintConstantColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     15;
} __GlintCStartFmat;
#else
typedef struct {
  unsigned32 Fraction:     15;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GlintCStartFmat;
#endif

typedef __GlintCStartFmat __GlintRStartFmat;
typedef __GlintCStartFmat __GlintGStartFmat;
typedef __GlintCStartFmat __GlintBStartFmat;
typedef __GlintCStartFmat __GlintAStartFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     15;
} __GlintdCdxFmat;
#else
typedef struct {
  unsigned32 Fraction:     15;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GlintdCdxFmat;
#endif

typedef __GlintdCdxFmat __GlintdRdxFmat;
typedef __GlintdCdxFmat __GlintdGdxFmat;
typedef __GlintdCdxFmat __GlintdBdxFmat;
typedef __GlintdCdxFmat __GlintdAdxFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     15;
} __GlintdCdyDomFmat;
#else
typedef struct {
  unsigned32 Fraction:     15;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GlintdCdyDomFmat;
#endif

typedef __GlintdCdyDomFmat __GlintdRdyDomFmat;
typedef __GlintdCdyDomFmat __GlintdGdyDomFmat;
typedef __GlintdCdyDomFmat __GlintdBdyDomFmat;
typedef __GlintdCdyDomFmat __GlintdAdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:  8;
  unsigned32 Blue:   8;
  unsigned32 Green:  8;
  unsigned32 Red:    8;
} __GlintColorFmat_s;
#else
typedef struct {
  unsigned32 Red:    8;
  unsigned32 Green:  8;
  unsigned32 Blue:   8;
  unsigned32 Alpha:  8;
} __GlintColorFmat_s;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:         20;
  unsigned32 Reference:    8;
  unsigned32 Compare:      3;
  unsigned32 UnitEnable:   1;
} __GlintAlphaTestModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:   1;
  unsigned32 Compare:      3;
  unsigned32 Reference:    8;
  unsigned32 pad:         20;
} __GlintAlphaTestModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:        12;
  unsigned32 GID:         4;
  unsigned32 FrameCount:  8;
  unsigned32 Stencil:     8;
} __GlintLBStencilFmat;
#else
typedef struct {
  unsigned32 Stencil:     8;
  unsigned32 FrameCount:  8;
  unsigned32 GID:         4;
  unsigned32 pad:        12;
} __GlintLBStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            12;
  unsigned32 WriteOverride:   1;
  unsigned32 DepthFCP:        1;
  unsigned32 StencilFCP:      1;
  unsigned32 FrameCount:      8;
  unsigned32 GID:             4;
  unsigned32 LBUpdateSource:  1;
  unsigned32 ForceLBUpdate:   1;
  unsigned32 CompareMode:     2;
  unsigned32 UnitEnable:      1;
} __GlintWindowFmat;
#else
typedef struct {
  unsigned32 UnitEnable:      1;
  unsigned32 CompareMode:     2;
  unsigned32 ForceLBUpdate:   1;
  unsigned32 LBUpdateSource:  1;
  unsigned32 GID:             4;
  unsigned32 FrameCount:      8;
  unsigned32 StencilFCP:      1;
  unsigned32 DepthFCP:        1;
  unsigned32 WriteOverride:   1;
  unsigned32 pad:            12;
} __GlintWindowFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 FastClearValue:  8;
  unsigned32 WriteMask:       8;
  unsigned32 CompareMask:     8;
  unsigned32 ReferenceValue:  8;
} __GlintStencilDataFmat;
#else
typedef struct {
  unsigned32 ReferenceValue:  8;
  unsigned32 CompareMask:     8;
  unsigned32 WriteMask:       8;
  unsigned32 FastClearValue:  8;
} __GlintStencilDataFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            15;
  unsigned32 Width:           2;
  unsigned32 StencilSource:   2;
  unsigned32 CompareFunction: 3;
  unsigned32 SFail:           3;
  unsigned32 DPFail:          3;
  unsigned32 DPPass:          3;
  unsigned32 UnitEnable:      1;
} __GlintStencilModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:       1;
  unsigned32 DPPass:           3;
  unsigned32 DPFail:           3;
  unsigned32 SFail:            3;
  unsigned32 CompareFunction:  3;
  unsigned32 StencilSource:    2;
  unsigned32 Width:            2;
  unsigned32 pad:             15;
} __GlintStencilModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:      24; 
  unsigned32 Stencil:   8;  
} __GlintStencilFmat;
#else
typedef struct {
  unsigned32 Stencil:   8;  
  unsigned32 pad:      24; 
} __GlintStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            25;
  unsigned32 CompareMode:     3;
  unsigned32 NewDepthSource:  2;
  unsigned32 WriteMask:       1;
  unsigned32 UnitEnable:      1;
} __GlintDepthModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:      1;
  unsigned32 WriteMask:       1;
  unsigned32 NewDepthSource:  2;
  unsigned32 CompareMode:     3;
  unsigned32 pad:            25;
} __GlintDepthModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            29;
  unsigned32 UpLoadData:      2;
  unsigned32 WriteEnable:     1;
} __GlintLBWriteModeFmat;
#else
typedef struct {
  unsigned32 WriteEnable:     1;
  unsigned32 UpLoadData:      2;
  unsigned32 pad:            29;
} __GlintLBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                  7;
  unsigned32 PatchCode:             3;
  unsigned32 ScanlineInterval:      2;
  unsigned32 Patch:                 1;
  unsigned32 WindowOrigin:          1;
  unsigned32 DataType:              2;
  unsigned32 spare:                 5;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 PP2:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP0:                   3;
} __GlintLBReadModeFmat;
#else
typedef struct {
  unsigned32 PP0:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP2:                   3;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 spare:                 5;
  unsigned32 DataType:              2;
  unsigned32 WindowOrigin:          1;
  unsigned32 Patch:                 1;
  unsigned32 ScanlineInterval:      2;
  unsigned32 PatchCode:             3;
  unsigned32 pad0:                  7;
} __GlintLBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                 14;
  unsigned32 Compact32:            1;
  unsigned32 GIDPosition:          4;
  unsigned32 GIDWidth:             1;
  unsigned32 FrameCountPosition:   3;
  unsigned32 FrameCountWidth:      2;
  unsigned32 StencilPosition:      3;
  unsigned32 StencilWidth:         2;
  unsigned32 DepthWidth:           2;
} __GlintLBFormatFmat;
#else
typedef struct {
  unsigned32 DepthWidth:           2;
  unsigned32 StencilWidth:         2;
  unsigned32 StencilPosition:      3;
  unsigned32 FrameCountWidth:      2;
  unsigned32 FrameCountPosition:   3;
  unsigned32 GIDWidth:             1;
  unsigned32 GIDPosition:          4;
  unsigned32 Compact32:            1;
  unsigned32 pad:                 14;
} __GlintLBFormatFmat;
#endif

typedef __GlintLBFormatFmat __GlintLBReadFormatFmat;
typedef __GlintLBFormatFmat __GlintLBWriteFormatFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                  5;
  unsigned32 PatchMode:             2;
  unsigned32 ScanlineInterval:      2;
  signed32 RelativeOffset:          3;
  unsigned32 PackedData:            1;
  unsigned32 PatchEnable:           1;
  unsigned32 TexelInhibit:          1;
  unsigned32 WindowOrigin:          1;
  unsigned32 DataType:              1;
  unsigned32 pad0:                  4;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 PP2:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP0:                   3;
} __GlintFBReadModeFmat;
#else
typedef struct {
  unsigned32 PP0:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP2:                   3;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 pad0:                  4;
  unsigned32 DataType:              1;
  unsigned32 WindowOrigin:          1;
  unsigned32 TexelInhibit:          1;
  unsigned32 PatchEnable:           1;
  unsigned32 PackedData:            1;
  signed32 RelativeOffset:          3;
  unsigned32 ScanlineInterval:      2;
  unsigned32 PatchMode:             2;
  unsigned32 pad2:                  5;
} __GlintFBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:        28;
  unsigned32 UpLoadData:   1;
  unsigned32 BlockWidth:   2; /* BACKWARDS COMPATABILITY */
  unsigned32 UnitEnable:   1;
} __GlintFBWriteModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:   1;
  unsigned32 BlockWidth:   2; /* BACKWARDS COMPATABILITY */
  unsigned32 UpLoadData:   1;
  unsigned32 pad1:        28;
} __GlintFBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:         30;
  unsigned32 ColorMode:    1;
  unsigned32 UnitEnable:   1;
} __GlintAntialiasModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:   1;
  unsigned32 ColorMode:    1;
  unsigned32 pad:         30;
} __GlintAntialiasModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                   15;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 AlphaDst:          1;
  unsigned32 BlendType:         1;
  unsigned32 ColorOrder:        1;
  unsigned32 NoAlphaBuffer:     1;
  unsigned32 ColorFormat:       4;
  unsigned32 DestinationBlend:  3;
  unsigned32 SourceBlend:       4;
  unsigned32 UnitEnable:        1;
} __PermediaAlphaBlendModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 SourceBlend:       4;
  unsigned32 DestinationBlend:  3;
  unsigned32 ColorFormat:       4;
  unsigned32 NoAlphaBuffer:     1;
  unsigned32 ColorOrder:        1;
  unsigned32 BlendType:         1;
  unsigned32 AlphaDst:          1;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad:                   15;
} __PermediaAlphaBlendModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:               14;
  unsigned32 AlphaConversion:   1;
  unsigned32 ColorConversion:   1;
  unsigned32 AlphaDst:          1;
  unsigned32 BlendType:         1;
  unsigned32 ColorOrder:        1;
  unsigned32 NoAlphaBuffer:     1;
  unsigned32 ColorFormat:       4;
  unsigned32 DestinationBlend:  3;
  unsigned32 SourceBlend:       4;
  unsigned32 UnitEnable:        1;
} __GlintAlphaBlendModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 SourceBlend:       4;
  unsigned32 DestinationBlend:  3;
  unsigned32 ColorFormat:       4;
  unsigned32 NoAlphaBuffer:     1;
  unsigned32 ColorOrder:        1;
  unsigned32 BlendType:         1;
  unsigned32 AlphaDst:          1;
  unsigned32 ColorConversion:   1;
  unsigned32 AlphaConversion:   1;
  unsigned32 pad:               14;
} __GlintAlphaBlendModeFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                  15;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 RoundingMode:    1;
  unsigned32 AlphaDither:     1;
  unsigned32 ForceAlpha:            2;
  unsigned32 DitherMethod:          1;
  unsigned32 ColorOrder:      1;
  unsigned32 YOffset:         2;
  unsigned32 XOffset:         2;
  unsigned32 ColorFormat:     4;
  unsigned32 DitherEnable:    1;
  unsigned32 UnitEnable:      1;
} __GlintDitherModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:      1;
  unsigned32 DitherEnable:    1;
  unsigned32 ColorFormat:     4;
  unsigned32 XOffset:         2;
  unsigned32 YOffset:         2;
  unsigned32 ColorOrder:      1;
  unsigned32 DitherMethod:          1;
  unsigned32 ForceAlpha:            2;
  unsigned32 AlphaDither:     1;
  unsigned32 RoundingMode:    1;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad0:                  15;
} __GlintDitherModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                    26;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 LogicalOp:               4;
  unsigned32 LogicalOpEnable:         1;
} __GlintLogicalOpModeFmat;
#else
typedef struct {
  unsigned32 LogicalOpEnable:         1;
  unsigned32 LogicalOp:               4;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 pad:                    26;
} __GlintLogicalOpModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:            10;
  unsigned32 ExternalDMA :    1;
  unsigned32 RLEHostOut:      1;
  unsigned32 Context:         2;
  unsigned32 ByteSwapMode:    2;
  unsigned32 Remainder:       2;
  unsigned32 Statistics:      2;
  unsigned32 Synchronization: 2;
  unsigned32 Color:           2;
  unsigned32 Stencil :        2;
  unsigned32 Depth:           2;
  unsigned32 Passive:         2;
  unsigned32 Active:          2;
} __GlintFilterModeFmat;
#else
typedef struct {
  unsigned32 Active:          2;
  unsigned32 Passive:         2;
  unsigned32 Depth:           2;
  unsigned32 Stencil :        2;
  unsigned32 Color:           2;
  unsigned32 Synchronization: 2;
  unsigned32 Statistics:      2;
  unsigned32 Remainder:       2;
  unsigned32 ByteSwapMode:    2;
  unsigned32 Context:         2;
  unsigned32 RLEHostOut:      1;
  unsigned32 ExternalDMA :    1;
  unsigned32 pad:            10;
} __GlintFilterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              26;
  unsigned32 Spans:             1;
  unsigned32 CompareFunction:   1;
  unsigned32 PassiveSteps:      1;
  unsigned32 ActiveSteps:       1;
  unsigned32 StatType:          1;
  unsigned32 Enable:            1;
} __GlintStatisticModeFmat;
#else
typedef struct {
  unsigned32 Enable:            1;
  unsigned32 StatType:          1;
  unsigned32 ActiveSteps:       1;
  unsigned32 PassiveSteps:      1;
  unsigned32 CompareFunction:   1;
  unsigned32 Spans:             1;
  unsigned32 pad:              26;
} __GlintStatisticModeFmat;
#endif

typedef __GlintXYFmat __GlintMinRegionFmat;
typedef __GlintXYFmat __GlintMaxRegionFmat;
typedef __GlintXYFmat __GlintMinHitRegionFmat;
typedef __GlintXYFmat __GlintMaxHitRegionFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 InterruptEnable: 1;
  unsigned32 pad:            31;
} __GlintSyncFmat;
#else
typedef struct {
  unsigned32 pad:            31;
  unsigned32 InterruptEnable: 1;
} __GlintSyncFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Count:      16;
  unsigned32 Mode:        2;
  unsigned32 unused:      4;
  unsigned32 Context:     1;
  unsigned32 MajorGroup:  5;
  unsigned32 Offset:      4;
} __GlintDMATag;
#else
typedef struct {
  unsigned32 Offset:      4;
  unsigned32 MajorGroup:  5;
  unsigned32 Context:     1;
  unsigned32 unused:      4;
  unsigned32 Mode:        2;
  unsigned32 Count:      16;
} __GlintDMATag;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:             20;
  unsigned32 ColorLoadMode:       2;
  unsigned32 BaseFormat:       3;
  unsigned32 KsDDA:            1;
  unsigned32 KdDDA:            1;
  unsigned32 TextureType:      1;
  unsigned32 ApplicationMode:  3;
  unsigned32 UnitEnable:       1;
} __GlintTextureColorModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:       1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureType:      1;
  unsigned32 KdDDA:            1;
  unsigned32 KsDDA:            1;
  unsigned32 BaseFormat:       3;
  unsigned32 ColorLoadMode:       2;
  unsigned32 pad:             20;
} __GlintTextureColorModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:             28;
  unsigned32 Sense:               1;
  unsigned32 Source:           2;
  unsigned32 UnitEnable:       1;
} __GlintChromaTestModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 Source:            2;
  unsigned32 Sense:             1;
  unsigned32 pad:               25;
} __GlintChromaTestModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:      29;
  unsigned32 Filter:    3;
} __GlintTextureFilterFmat;
#else
typedef struct {
  unsigned32 Filter:    3;
  unsigned32 pad:      29;
} __GlintTextureFilterFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:   8;
  unsigned32 Blue:    8;
  unsigned32 Green:   8;
  unsigned32 Red:     8;
} __GlintTexelFmat;
#else
typedef struct {
  unsigned32 Red:     8;
  unsigned32 Green:   8;
  unsigned32 Blue:    8;
  unsigned32 Alpha:   8;
} __GlintTexelFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:         30;
  unsigned32 ColorMode:    1;
  unsigned32 UnitEnable:   1;
} __GlintFogModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:   1;
  unsigned32 ColorMode:    1;
  unsigned32 pad:         30;
} __GlintFogModeFmat;
#endif



#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:             14;
  unsigned32 TextureMapType:   1;
  unsigned32 Height:           4;
  unsigned32 Width:               4;
  unsigned32 EnableDY:           1;
  unsigned32 EnableLOD:        1;
  unsigned32 InhibitDDA:       1;
  unsigned32 Mode:             1;
  unsigned32 TWrap:            2; 
  unsigned32 SWrap:            2; 
  unsigned32 UnitEnable:       1; 
} __GlintTextureAddressModeFmat;
#else 
typedef struct { 
  unsigned32 UnitEnable:       1; 
  unsigned32 SWrap:            2; 
  unsigned32 TWrap:            2; 
  unsigned32 Mode:             1;
  unsigned32 InhibitDDA:       1;
  unsigned32 EnableLOD:           1;
  unsigned32 EnableDY:           1;
  unsigned32 Width:               4;
  unsigned32 Height:           4;
  unsigned32 TextureMapType:   1;
  unsigned32 pad:             14;
} __GlintTextureAddressModeFmat;
#endif

typedef signed32 __GlintSStartFmat;
typedef signed32 __GlintTStartFmat;
typedef signed32 __GlintQStartFmat;
typedef signed32 __GlintdSdxFmat;
typedef signed32 __GlintdTdxFmat;
typedef signed32 __GlintdQdxFmat;
typedef signed32 __GlintdSdyDomFmat;
typedef signed32 __GlintdTdyDomFmat;
typedef signed32 __GlintdQdyDomFmat;


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             12;
  unsigned32 U:                20;
} __GlintTexelCoordUFmat;
#else
typedef struct {
  unsigned32 U:                20;
  unsigned32 pad0:             12;
} __GlintTexelCoordUFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             12;
  unsigned32 V:                20;
} __GlintTexelCoordVFmat;
#else
typedef struct {
  unsigned32 V:                20;
  unsigned32 pad0:             12;
} __GlintTexelCoordVFmat;
#endif


#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           4;
  unsigned32 BorderClamp:     1;
  unsigned32 FBSourceAddr:     2;
  unsigned32 PrimaryCache:     1;
  unsigned32 MipMap:         1;
  unsigned32 Mode:           1;
  unsigned32 VWrap:          2;
  unsigned32 UWrap:          2;
  unsigned32 MinFilter:      3;
  unsigned32 MagFilter:      1;
  unsigned32 Patch:          1;
  unsigned32 Border:         1;
  unsigned32 Depth:          3;
  unsigned32 Height:         4;
  unsigned32 Width:          4;
  unsigned32 UnitEnable:     1;
} __GlintTextureReadModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:     1;
  unsigned32 Width:          4;
  unsigned32 Height:         4;
  unsigned32 Depth:          3;
  unsigned32 Border:         1;
  unsigned32 Patch:          1;
  unsigned32 MagFilter:      1;
  unsigned32 MinFilter:      3;
  unsigned32 UWrap:          2;
  unsigned32 VWrap:          2;
  unsigned32 Mode:           1;
  unsigned32 MipMap:         1;
  unsigned32 PrimaryCache:     1;
  unsigned32 FBSourceAddr:     2;
  unsigned32 BorderClamp:     1;
  unsigned32 pad0:           4;
} __GlintTextureReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Pad0:             29;
  unsigned32 AlphaMapSense:  1;
  unsigned32 AlphaMapEnable: 1;
  unsigned32 UnitEnable:     1;
} __GlintTextureFilterModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:     1;
  unsigned32 AlphaMapEnable: 1;
  unsigned32 AlphaMapSense:  1;
  unsigned32 Pad0:             29;
} __GlintTextureFilterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           12;
  unsigned32 OneCompFormat:      2;
  unsigned32 LUTOffset:          8;
  unsigned32 ByteSwapBitMask: 1;
  unsigned32 InvertBitMask:   1;
  unsigned32 MirrorBitMask:   1;
  unsigned32 OutputFormat:    2;
  unsigned32 NumberComps:     2;
  unsigned32 ColorOrder:      1;
  unsigned32 Format:          1;
  unsigned32 Endian:          1;
} __GlintTextureFormatFmat;
#else
typedef struct {
  unsigned32 Endian:          1;
  unsigned32 Format:          1;
  unsigned32 ColorOrder:      1;
  unsigned32 NumberComps:     2;
  unsigned32 OutputFormat:    2;
  unsigned32 MirrorBitMask:   1;
  unsigned32 InvertBitMask:   1;
  unsigned32 ByteSwapBitMask: 1;
  unsigned32 LUTOffset:          8;
  unsigned32 OneCompFormat:      2;
  unsigned32 pad0:           12;
} __GlintTextureFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:          3;
  unsigned32 Addr:        29;
} __GlintTextureAddressFmat;
#else
typedef struct {
  unsigned32 Addr:        29;
  unsigned32 pad:          3;
} __GlintTextureAddressFmat;
#endif

typedef __GlintTextureAddressFmat __GlintTextureBaseAddressFmat;
typedef __GlintTextureAddressFmat __GlintTextureBaseAddressLRFmat;
typedef __GlintTexelFmat __GlintTexelLUTFmat;
typedef __GlintTexelFmat __GlintBorderColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              5;
  unsigned32 Blue:             9;
  unsigned32 Green:            9;
  unsigned32 Red:              9;
} __GlintTextureKFmat;
#else
typedef struct {
  unsigned32 Red:              9;
  unsigned32 Green:            9;
  unsigned32 Blue:             9;
  unsigned32 pad:              5;
} __GlintTextureKFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         2;
  unsigned32 Fraction:     22;
} __GlintKStartFmat;
#else
typedef struct {
  unsigned32 Fraction:     22;
  signed32 Integer:         2;
  unsigned32 pad2:          8;
} __GlintKStartFmat;
#endif

typedef __GlintKStartFmat __GlintKsStartFmat;
typedef __GlintKStartFmat __GlintKdStartFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         2;
  unsigned32 Fraction:     22;
} __GlintdKdxFmat;
#else
typedef struct {
  unsigned32 Fraction:     22;
  signed32 Integer:         2;
  unsigned32 pad2:          8;
} __GlintdKdxFmat;
#endif

typedef __GlintdKdxFmat __GlintdKsdxFmat;
typedef __GlintdKdxFmat __GlintdKddxFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         2;
  unsigned32 Fraction:     22;
} __GlintdKdyDomFmat;
#else
typedef struct {
  unsigned32 Fraction:     22;
  signed32 Integer:         2;
  unsigned32 pad2:          8;
} __GlintdKdyDomFmat;
#endif

typedef __GlintdKdyDomFmat __GlintdKsdyDomFmat;
typedef __GlintdKdyDomFmat __GlintdKddyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              30;
  unsigned32 Mode:              1;
  unsigned32 Invalidate:        1;
} __GlintTextureCacheControlFmat;
#else
typedef struct {
  unsigned32 Invalidate:        1;
  unsigned32 Mode:              1;
  unsigned32 pad:              30;
} __GlintTextureCacheControlFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              18;
  unsigned32 XMask:             5;
  unsigned32 YShift:            3;
  unsigned32 YMask:             5;
  unsigned32 PatternEnable:     1;
} __GlintPatternRAMModeFmat;
#else
typedef struct {
  unsigned32 PatternEnable:     1;
  unsigned32 YMask:             5;
  unsigned32 YShift:            3;
  unsigned32 XMask:             5;
  unsigned32 pad:              18;
} __GlintPatternRAMModeFmat;
#endif

typedef __GlintUnsignedIntFmat __GlintPatternRAMDataFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:              30;
  unsigned32 Size:              2;
} __GlintPixelSizeFmat;
#else
typedef struct {
  unsigned32 Size:              2;
  unsigned32 pad:              30;
} __GlintPixelSizeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                27;
  unsigned32 Scanline:            3;
  unsigned32 ScanlineInterval:    2;
} __GlintScanlineOwnershipFmat;
#else
typedef struct {
  unsigned32 ScanlineInterval:    2;
  unsigned32 Scanline:            3;
  unsigned32 pad:                27;
} __GlintScanlineOwnershipFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 YMax:                 16;
  signed32 YMin:                 16;
} __GlintYLimitsFmat;
#else
typedef struct {
  signed32 YMin:                 16;
  signed32 YMax:                 16;
} __GlintYLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 XMax:                 16;
  signed32 XMin:                 16;
} __GlintXLimitsFmat;
#else
typedef struct {
  signed32 XMin:                 16;
  signed32 XMax:                 16;
} __GlintXLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                 8;
  unsigned32 Offset:             24;
} __GlintTextureDownloadOffsetFmat;
#else
typedef struct {
  unsigned32 Offset:             24;
  unsigned32 pad:                 8;
} __GlintTextureDownloadOffsetFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned int TargetChip:                2;
  unsigned int DepthFormat:               2;
  unsigned int FogEnable:                 1;
  unsigned int TextureEnable:             1;
  unsigned int SmoothShadingEnable:       1;
  unsigned int DepthEnable:               1;
  unsigned int SpecularTextureEnable:     1;
  unsigned int DiffuseTextureEnable:      1;
  unsigned int SubPixelCorrectionEnable:  1;
  unsigned int DiamondExit:               1;
  unsigned int NoDraw:                    1;
  unsigned int ClampEnable:               1;
  unsigned int TextureParameterMode:      2;
  unsigned int FillDirection:             1;
  unsigned int pad:                      15;
} __GambitDeltaModeFmat;

#else

typedef struct {
  unsigned int TargetChip:                2;
  unsigned int DepthFormat:               2;
  unsigned int FogEnable:                 1;
  unsigned int TextureEnable:             1;
  unsigned int SmoothShadingEnable:       1;
  unsigned int DepthEnable:               1;
  unsigned int SpecularTextureEnable:     1;
  unsigned int DiffuseTextureEnable:      1;
  unsigned int SubPixelCorrectionEnable:  1;
  unsigned int DiamondExit:               1;
  unsigned int NoDraw:                    1;
  unsigned int ClampEnable:               1;
  unsigned int TextureParameterMode:      2;
  unsigned int FillDirection:             1;
  unsigned int pad:                      15;
} __GambitDeltaModeFmat;

#endif
typedef unsigned32 __GlintTextureDataFmat;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glintfx.h ===
/******************************Module*Header*******************************\
* Module Name: GlintFX.h
*
* Header definition specific to Permedia chip
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
*
\**************************************************************************/

typedef struct {
    HMEMREGION  texmem;
} FX_BRUSH, *PFX_BRUSH;

#define __FX_FB_PACKED                         (1 << 19)
#define __FX_FBOFFSETSHIFT                  20

#define __FX_FORCE_BACKGROUND_COLOR         (1 << 6)
#define __FX_BITMASK_PACKING                   (1 << 9)
#define __FX_BITMASK_OFFSET                 10
#define __FX_LIMITS_ENABLE                     (1 << 18) 

#define __FX_STIPPLE_FORCE_BACKGROUND_COLOR (1 << 20)

#define __RENDER_TEXTURE_ENABLE              (1 << 13)

#define __FX_TEXREADMODE_SWRAP_REPEAT       (1 << 1)
#define __FX_TEXREADMODE_TWRAP_REPEAT       (1 << 3)
#define __FX_TEXREADMODE_8HIGH              (3 << 13)
#define __FX_TEXREADMODE_8WIDE              (3 << 9)
#define __FX_TEXREADMODE_2048HIGH           (11 << 13)
#define __FX_TEXREADMODE_2048WIDE           (11 << 9)

#define __FX_TEXTUREREADMODE_PACKED_DATA    (1 << 24)

#define __FX_8x8REPEAT_TEXTUREREADMODE      ( __PERMEDIA_ENABLE                      \
                                            | __FX_TEXREADMODE_TWRAP_REPEAT       \
                                            | __FX_TEXREADMODE_SWRAP_REPEAT       \
                                            | __FX_TEXREADMODE_8HIGH              \
                                            | __FX_TEXREADMODE_8WIDE)

#define __FX_2048x2048REPEAT_TEXTUREREADMODE ( __PERMEDIA_ENABLE                     \
                                            | __FX_TEXREADMODE_TWRAP_REPEAT       \
                                            | __FX_TEXREADMODE_SWRAP_REPEAT       \
                                            | __FX_TEXREADMODE_2048HIGH           \
                                            | __FX_TEXREADMODE_2048WIDE)

#define __FX_4BPPDOWNLOAD_TEXTUREREADMODE   ( __PERMEDIA_ENABLE                      \
                                            | __FX_TEXREADMODE_2048HIGH           \
                                            | __FX_TEXREADMODE_2048WIDE)

#define __FX_TEXAPPLICATIONCOPY             (3 << 1)

#define __FX_TEXELSIZE_SHIFT                19
#define __FX_8BIT_TEXELS                    (0 << __FX_TEXELSIZE_SHIFT)
#define __FX_16BIT_TEXELS                   (1 << __FX_TEXELSIZE_SHIFT)
#define __FX_32BIT_TEXELS                   (2 << __FX_TEXELSIZE_SHIFT)
#define __FX_4BIT_TEXELS                    (3 << __FX_TEXELSIZE_SHIFT)
#define __P2_24BIT_TEXELS                   (4 << __FX_TEXELSIZE_SHIFT)

#define __FX_TEXTUREMAPFORMAT_32WIDE        1

#define __FX_TEXTUREDATAFORMAT_32BIT_RGBA   0x00
#define __FX_TEXTUREDATAFORMAT_32BIT        0x10 
#define __FX_TEXTUREDATAFORMAT_8BIT         0xe
#define __FX_TEXTUREDATAFORMAT_16BIT        0x11
#define __FX_TEXTUREDATAFORMAT_4BIT         0xf

#define __P2_TEXTURE_DATAFORMAT_FLIP        (1 << 9)

#define __FX_TEXLUTMODE_DIRECT_ENTRY        (1 << 1)
#define __FX_TEXLUTMODE_4PIXELS_PER_ENTRY   (2 << 10)    //log2
#define __FX_TEXLUTMODE_2PIXELS_PER_ENTRY   (1 << 10)    //log2
#define __FX_TEXLUTMODE_1PIXEL_PER_ENTRY    0           //log2

#define __FX_DITHERMODE_16BIT               (1<<2) | __PERMEDIA_ENABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\gigiregl.h ===
#ifndef GIGIREG_H
#define GIGIREG_H
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: gigiregl.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#if (defined(_MSDOS) || (defined(__cplusplus) && !defined(_WIN32)))
typedef unsigned long unsigned32;
typedef signed long   signed32;
#else
typedef unsigned long unsigned32;
typedef signed long signed32;
#endif

typedef unsigned short unsigned16;
typedef signed short   signed16;

typedef unsigned char unsigned8;
typedef signed char   signed8;

typedef long __GigiSignedIntegerFmat;
typedef unsigned32 __GigiUnsignedIntegerFmat;

/*
** Generic signed 16 + signed 16 format
*/

#if BIG_ENDIAN == 1 
typedef struct {
  signed32 hi:             16;
  signed32 lo:             16;
} __GigiS16S16Fmat;
#else
typedef struct {
  signed32 lo:             16;
  signed32 hi:             16;
} __GigiS16S16Fmat;
#endif 

/*
** Delta Registers
*/

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad:                      13;
  unsigned32 ColorOrder:                1;
  unsigned32 BackfaceCull:              1;
  unsigned32 FillDirection:             1;
  unsigned32 TextureParameterMode:      2;
  unsigned32 ClampEnable:               1;
  unsigned32 NoDraw:                    1;
  unsigned32 DiamondExit:               1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 DiffuseTextureEnable:      1;
  unsigned32 SpecularTextureEnable:     1;
  unsigned32 DepthEnable:               1;
  unsigned32 SmoothShadingEnable:       1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 DepthFormat:               2;
  unsigned32 TargetChip:                2;
} __GigiDeltaModeFmat;
#else
typedef struct {
  unsigned32 TargetChip:                2;
  unsigned32 DepthFormat:               2;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SmoothShadingEnable:       1;
  unsigned32 DepthEnable:               1;
  unsigned32 SpecularTextureEnable:     1;
  unsigned32 DiffuseTextureEnable:      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 DiamondExit:               1;
  unsigned32 NoDraw:                    1;
  unsigned32 ClampEnable:               1;
  unsigned32 TextureParameterMode:      2;
  unsigned32 FillDirection:             1;
  unsigned32 BackfaceCull:              1;
  unsigned32 ColorOrder:                1;
  unsigned32 pad:                      13;
} __GigiDeltaModeFmat;
#endif

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad2:                     11;
  unsigned32 RejectNegativeFace:        1;
  unsigned32 pad1:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad0:                      1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 CoverageEnable:            1;
  unsigned32 FogEnable:                 1;
  unsigned32 TextureEnable:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 UsePointTable:             1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 AntialiasEnable:           1;
  unsigned32 PrimitiveType:             2;
  unsigned32 reserved:                  2;
  unsigned32 FastFillEnable:            1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 AreaStippleEnable:         1;
} __GigiDeltaDrawFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:         1;
  unsigned32 LineStippleEnable:         1;
  unsigned32 ResetLineStipple:          1;
  unsigned32 FastFillEnable:            1;
  unsigned32 reserved:                  2;
  unsigned32 PrimitiveType:             2;
  unsigned32 AntialiasEnable:           1;
  unsigned32 AntialiasingQuality:       1;
  unsigned32 UsePointTable:             1;
  unsigned32 SyncOnBitMask:             1;
  unsigned32 SyncOnHostData:            1;
  unsigned32 TextureEnable:             1;
  unsigned32 FogEnable:                 1;
  unsigned32 CoverageEnable:            1;
  unsigned32 SubPixelCorrectionEnable:  1;
  unsigned32 pad0:                      1;
  unsigned32 SpanOperation:             1;
  unsigned32 pad1:                      1;
  unsigned32 RejectNegativeFace:        1;
  unsigned32 pad2:                     11;
} __GigiDeltaDrawFmat;
#endif

#ifdef BIG_ENDIAN
typedef union {
  struct {
    signed32 Val:                      32; /* 2.30s or 16.16s */
  } STQ;
  struct {
    unsigned32 pad:                     8;
    unsigned32 Val:                    24; /* 2.22s */
  } K;
  struct {
    unsigned32 pad:                     1;
    unsigned32 Val:                    31; /* 1.30us */
  } RGBA;
  struct {
    signed32 Val:                      32; /* 10.22s */
  } F;
  struct {
    signed32 Val:                      32; /* 16.16s */
  } XY;
  struct {
    unsigned32 pad:                     1;
    unsigned32 Val:                    31; /* 1.31us */
  } Z;
} __GigiDeltaFixedFmat;
#else 
typedef union {
  struct {
    signed32 Val:                      32; /* 2.30s or 16.16s */
  } STQ;
  struct {
    unsigned32 Val:                    24; /* 2.22s */
    unsigned32 pad:                     8;
  } K;
  struct {
    unsigned32 Val:                    31; /* 1.30us */
    unsigned32 pad:                     1;
  } RGBA;
  struct {
    signed32 Val:                      32; /* 10.22s */
  } F;
  struct {
    signed32 Val:                      32; /* 16.16s */
  } XY;
  struct {
    unsigned32 Val:                    31; /* 1.31us */
    unsigned32 pad:                     1;
  } Z;
} __GigiDeltaFixedFmat;
#endif

#define N_GIGI_DELTA_BROADCAST_MASK_BITS 4 

#ifdef BIG_ENDIAN
typedef struct {
  unsigned32 pad:                      32 - N_GIGI_DELTA_BROADCAST_MASK_BITS;
  unsigned32 Mask:                   N_GIGI_DELTA_BROADCAST_MASK_BITS ;
} __GigiDeltaBroadcastMaskFmat;
#else
typedef struct {
  unsigned32 Mask:                     N_GIGI_DELTA_BROADCAST_MASK_BITS ;
  unsigned32 pad:                      32 - N_GIGI_DELTA_BROADCAST_MASK_BITS ;
} __GigiDeltaBroadcastMaskFmat;
#endif

/*
** GIGI Host In Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Mask:         16;
  unsigned32 Mode:          2;
  unsigned32 pad0:          5;
  unsigned32 MajorGroup:    5;
  unsigned32 Offset:        4;
} __GigiDMADataFmat;
#else
typedef struct {
  unsigned32 Offset:        4;
  unsigned32 MajorGroup:    5;
  unsigned32 pad0:          5;
  unsigned32 Mode:          2;
  unsigned32 Mask:         16;
} __GigiDMADataFmat;
#endif

/*
**  GIGI Rasterizer Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 Integer:        12;
  unsigned32 Fraction:     15;
  unsigned32 pad0:          1;
} __GigiStartXDomFmat,
  __GigidXDomFmat,
  __GigiStartXSubFmat,
  __GigidXSubFmat;
#else
typedef struct {
  unsigned32 pad0:          1;
  unsigned32 Fraction:     15;
  signed32 Integer:        12;
  unsigned32 pad1:          4;
} __GigiStartXDomFmat,
  __GigidXDomFmat,
  __GigiStartXSubFmat,
  __GigidXSubFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 Integer:        12;
  unsigned32 Fraction:     15;
  unsigned32 pad0:          1;
} __GigiStartYFmat,
  __GigidYFmat;
#else
typedef struct {
  unsigned32 pad0:          1;
  unsigned32 Fraction:     15;
  signed32 Integer:        12;
  unsigned32 pad1:          4;
} __GigiStartYFmat,
  __GigidYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:         20;
  unsigned32 Val:          12;
} __GigiCountFmat,
  __GigiContinueNewLineFmat,
  __GigiContinueNewDomFmat,
  __GigiContinueNewSubFmat,
  __GigiContinueFmat;
#else
typedef struct {
  unsigned32 Val:          12;
  unsigned32 pad0:         20;
} __GigiCountFmat,
  __GigiContinueNewLineFmat,
  __GigiContinueNewDomFmat,
  __GigiContinueNewSubFmat,
  __GigiContinueFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad5:                     9;
  unsigned32 IncreaseY:                1;
  unsigned32 IncreaseX:                1;
  unsigned32 RejectNegativeFace:       1;
  unsigned32 pad4:                     2;
  unsigned32 ReuseBitMask:             1;
  unsigned32 SubPixelCorrectionEnable: 1;
  unsigned32 pad3:                     1;
  unsigned32 FogEnable:                1;
  unsigned32 TextureEnable:            1;
  unsigned32 SyncOnHostData:           1;
  unsigned32 SyncOnBitMask:            1;
  unsigned32 pad2:                     3;
  unsigned32 PrimitiveType:            2;
  unsigned32 pad1:                     2;
  unsigned32 FastFillEnable:           1;
  unsigned32 pad0:                     2;
  unsigned32 AreaStippleEnable:        1;
} __GigiRenderFmat,
  __GigiPrepareToRenderFmat;
#else
typedef struct {
  unsigned32 AreaStippleEnable:        1;
  unsigned32 pad0:                     2;
  unsigned32 FastFillEnable:           1;
  unsigned32 pad1:                     2;
  unsigned32 PrimitiveType:            2;
  unsigned32 pad2:                     3;
  unsigned32 SyncOnBitMask:            1;
  unsigned32 SyncOnHostData:           1;
  unsigned32 TextureEnable:            1;
  unsigned32 FogEnable:                1;
  unsigned32 pad3:                     1;
  unsigned32 SubPixelCorrectionEnable: 1;
  unsigned32 ReuseBitMask:             1;
  unsigned32 pad4:                     2;
  unsigned32 RejectNegativeFace:       1;
  unsigned32 IncreaseX:                1;
  unsigned32 IncreaseY:                1;
  unsigned32 pad5:                     9;
} __GigiRenderFmat,
  __GigiPrepareToRenderFmat;
#endif 

typedef __GigiUnsignedIntegerFmat __GigiBitMaskPatternFmat;

#if BIG_ENDIAN == 1 
typedef struct {
  unsigned32 pad1:                12;
  unsigned32 BitMaskRelative:      1;
  unsigned32 LimitsEnable:         1;
  unsigned32 pad0:                 1;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 BitMaskOffset:        5;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 ForceBackgroundColor: 1;
  unsigned32 BiasCoordinates:      2;
  unsigned32 FractionAdjust:       2;
  unsigned32 InvertBitMask:        1;
  unsigned32 MirrorBitMask:        1;
} __GigiRasterizerModeFmat;
#else
typedef struct {
  unsigned32 MirrorBitMask:        1;
  unsigned32 InvertBitMask:        1;
  unsigned32 FractionAdjust:       2;
  unsigned32 BiasCoordinates:      2;
  unsigned32 ForceBackgroundColor: 1;
  unsigned32 BitMaskByteSwapMode:  2;
  unsigned32 BitMaskPacking:       1;
  unsigned32 BitMaskOffset:        5;
  unsigned32 HostDataByteSwapMode: 2;
  unsigned32 pad0:                 1;
  unsigned32 LimitsEnable:         1;
  unsigned32 BitMaskRelative:      1;
  unsigned32 pad1:                12;
} __GigiRasterizerModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Max:             12;
  unsigned32 pad0:           4;
  signed32 Min:             12;
} __GigiYLimitsFmat, __GigiXLimitsFmat;
#else
typedef struct {
  signed32 Min:             12;
  unsigned32 pad0:           4;
  signed32 Max:             12;
  unsigned32 pad1:           4;
} __GigiYLimitsFmat, __GigiXLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __GigiStepFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __GigiStepFmat;
#endif

typedef __GigiStepFmat __GigiActiveStepXFmat;
typedef __GigiStepFmat __GigiActiveStepYDomEdgeFmat;
typedef __GigiStepFmat __GigiPassiveStepXFmat;
typedef __GigiStepFmat __GigiPassiveStepYDomEdgeFmat;
typedef __GigiStepFmat __GigiFastBlockFillFmat;
typedef __GigiStepFmat __GigiRectangleOriginFmat;
typedef __GigiStepFmat __GigiRectangleSizeFmat;
typedef __GigiStepFmat __GigiFBSourceDeltaFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           5;
  unsigned32 Y:             11;
  unsigned32 pad0:           5;
  unsigned32 X:             11;
} __GigiUnsignedStepFmat;
#else
typedef struct {
  unsigned32 X:             11;
  unsigned32 pad0:           5;
  unsigned32 Y:             11;
  unsigned32 pad1:           5;
} __GigiUnsignedStepFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          4;
  signed32 XRight:         12;
  unsigned32 pad0:          4;
  signed32 XLeft:          12;
} __GigiFastBlockLimitsFmat;
#else
typedef struct {
  signed32 XLeft:          12;
  unsigned32 pad0:          4;
  signed32 XRight:         12;
  unsigned32 pad1:          4;
} __GigiFastBlockLimitsFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:          27;
  unsigned32 Sign:           1;
  unsigned32 Magnitude:      4;
} __GigiSubPixelCorrectionFmat;
#else
typedef struct {
  unsigned32 Magnitude:      4;
  unsigned32 Sign:           1;
  unsigned32 pad0:          27;
} __GigiSubPixelCorrectionFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  signed32 RelativeOffset:  3;
  unsigned32 pad1:          1;
  signed32 XStart:         12;
  unsigned32 pad0:          4;
  signed32 XEnd:           12;
} __GigiPackedDataLimitsFmat;
#else
typedef struct {
  signed32 XEnd:           12;
  unsigned32 pad0:          4;
  signed32 XStart:         12;
  unsigned32 pad1:          1;
  signed32 RelativeOffset:  3;
} __GigiPackedDataLimitsFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiSpanMaskFmat;

/*
**  GIGI Scissor and Stipple Registers
*/
#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                30;
  unsigned32 ScreenScissorEnable:  1;
  unsigned32 UserScissorEnable:    1;
} __GigiScissorModeFmat;
#else
typedef struct {
  unsigned32 UserScissorEnable:    1;
  unsigned32 ScreenScissorEnable:  1;
  unsigned32 pad0:                30;
} __GigiScissorModeFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad3:                 11;
  unsigned32 ForceBackgroundColor:  1;
  unsigned32 MirrorY:               1;
  unsigned32 MirrorX:               1;
  unsigned32 InvertStipplePattern:  1;
  unsigned32 pad2:                  2;
  unsigned32 YOffset:               3;
  unsigned32 pad1:                  2;
  unsigned32 XOffset:               3;
  unsigned32 pad0:                  6;
  unsigned32 UnitEnable:            1;
} __GigiAreaStippleModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:            1;
  unsigned32 pad0:                  6;
  unsigned32 XOffset:               3;
  unsigned32 pad1:                  2;
  unsigned32 YOffset:               3;
  unsigned32 pad2:                  2;
  unsigned32 InvertStipplePattern:  1;
  unsigned32 MirrorX:               1;
  unsigned32 MirrorY:               1;
  unsigned32 ForceBackgroundColor:  1;
  unsigned32 pad3:                 11;
} __GigiAreaStippleModeFmat;
#endif

typedef __GigiStepFmat __GigiScreenRegionFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __GigiScissorMinXYFmat, __GigiScissorMaxXYFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __GigiScissorMinXYFmat, __GigiScissorMaxXYFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __GigiWindowOriginFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __GigiWindowOriginFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           5;
  unsigned32 Y:             11;
  unsigned32 pad0:           5;
  unsigned32 X:             11;
} __GigiScreenSizeFmat;
#else
typedef struct {
  unsigned32 X:             11;
  unsigned32 pad0:           5;
  unsigned32 Y:             11;
  unsigned32 pad1:           5;
} __GigiScreenSizeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:         24;
  unsigned32 Pattern:       8;
} __GigiAreaStipplePatternFmat;
#else
typedef struct {
  unsigned32 Pattern:       8;
  unsigned32 pad0:         24;
} __GigiAreaStipplePatternFmat;
#endif

/*
**  GIGI Color DDA Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __GigiCStartFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GigiCStartFmat;
#endif

typedef __GigiCStartFmat __GigiRStartFmat;
typedef __GigiCStartFmat __GigiGStartFmat;
typedef __GigiCStartFmat __GigiBStartFmat;
typedef __GigiCStartFmat __GigiAStartFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __GigidCdxFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GigidCdxFmat;
#endif

typedef __GigidCdxFmat __GigidRdxFmat;
typedef __GigidCdxFmat __GigidGdxFmat;
typedef __GigidCdxFmat __GigidBdxFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:          8;
  signed32 Integer:         9;
  unsigned32 Fraction:     11;
  unsigned32 pad0:          4;
} __GigidCdyDomFmat;
#else
typedef struct {
  unsigned32 pad0:          4;
  unsigned32 Fraction:     11;
  signed32 Integer:         9;
  unsigned32 pad2:          8;
} __GigidCdyDomFmat;
#endif

typedef __GigidCdyDomFmat __GigidRdyDomFmat;
typedef __GigidCdyDomFmat __GigidGdyDomFmat;
typedef __GigidCdyDomFmat __GigidBdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:            8;
  unsigned32 Blue:             8;
  unsigned32 Green:            8;
  unsigned32 Red:              8;
} __GigiColorFmat;
#else
typedef struct {
  unsigned32 Red:              8;
  unsigned32 Green:            8;
  unsigned32 Blue:             8;
  unsigned32 Alpha:            8;
} __GigiColorFmat;
#endif

typedef __GigiColorFmat __GigiConstantColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 AlphaInteger:     5;
  unsigned32 AlphaFraction:    3;
  unsigned32 BlueInteger:      5;
  unsigned32 BlueFraction:     3;
  unsigned32 GreenInteger:     5;
  unsigned32 GreenFraction:    3;
  unsigned32 RedInteger:       5;
  unsigned32 RedFraction:      3;
} __GigiFractionalColorFmat;
#else
typedef struct {
  unsigned32 RedFraction:      3;
  unsigned32 RedInteger:       5;
  unsigned32 GreenFraction:    3;
  unsigned32 GreenInteger:     5;
  unsigned32 BlueFraction:     3;
  unsigned32 BlueInteger:      5;
  unsigned32 AlphaFraction:    3;
  unsigned32 AlphaInteger:     5;
} __GigiFractionalColorFmat;
#endif 

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             30;
  unsigned32 ShadeMode:         1;
  unsigned32 UnitEnable:        1;
} __GigiColorDDAModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:        1;
  unsigned32 ShadeMode:         1;
  unsigned32 pad0:             30;
} __GigiColorDDAModeFmat;
#endif

/*
**  GIGI Texture Application, Fog and 
**       Alpha Blend Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:          8;  
  signed32 Integer:         2;
  unsigned32 Fraction:     19;
  unsigned32 pad0:          3;           
} __GigiFogFmat;
#else
typedef struct {
  unsigned32 pad0:          3;           
  unsigned32 Fraction:     19;
  signed32 Integer:         2;
  unsigned32 pad1:          8;  
} __GigiFogFmat;
#endif

typedef __GigiFogFmat __GigiFStartFmat;
typedef __GigiFogFmat __GigidFdxFmat;
typedef __GigiFogFmat __GigidFdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:            29;
  unsigned32 FogTest:          1;
  unsigned32 pad0:             1;
  unsigned32 FogEnable:        1;
} __GigiFogModeFmat;
#else
typedef struct {
  unsigned32 FogEnable:        1;
  unsigned32 pad0:             1;
  unsigned32 FogTest:          1;
  unsigned32 pad1:            29;
} __GigiFogModeFmat;
#endif

typedef __GigiColorFmat __GigiFogColorFmat;
typedef __GigiColorFmat __GigiTexelFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            25;
  unsigned32 KsDDA:            1;
  unsigned32 KdDDA:            1;
  unsigned32 TextureType:      1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureEnable:    1;
} __GigiTextureColorModeFmat;
#else
typedef struct {
  unsigned32 TextureEnable:    1;
  unsigned32 ApplicationMode:  3;
  unsigned32 TextureType:      1;
  unsigned32 KdDDA:            1;
  unsigned32 KsDDA:            1;
  unsigned32 pad0:            25;
} __GigiTextureColorModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                13;
  unsigned32 AlphaConversion:      1;
  unsigned32 ColorConversion:      1;
  unsigned32 ColorFormatExtension: 1;
  unsigned32 pad1:                 1;
  unsigned32 BlendType:            1;
  unsigned32 ColorOrder:           1;
  unsigned32 NoAlphaBuffer:        1;
  unsigned32 ColorFormat:          4;
  unsigned32 DestinationBlend:       3;
  unsigned32 SourceBlend:           4;
  unsigned32 AlphaBlendEnable:     1;
} __GigiAlphaBlendModeFmat;
#else
typedef struct {
  unsigned32 AlphaBlendEnable:     1;
  unsigned32 SourceBlend:          4;
  unsigned32 DestinationBlend:       3;
  unsigned32 ColorFormat:          4;
  unsigned32 NoAlphaBuffer:        1;
  unsigned32 ColorOrder:           1;
  unsigned32 BlendType:            1;
  unsigned32 pad1:                 1;
  unsigned32 ColorFormatExtension: 1; 
  unsigned32 ColorConversion:      1;
  unsigned32 AlphaConversion:      1;
  unsigned32 pad2:                13;
} __GigiAlphaBlendModeFmat;
#endif

/*
**  GIGI Texture Address Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Integer:         12;
  unsigned32 Fraction:      18;
  unsigned32 pad1:           2;
} __GigiSTFmat;
#else
typedef struct {
  unsigned32 pad1:           2;
  unsigned32 Fraction:      18;
  signed32 Integer:         12;
} __GigiSTFmat;
#endif

typedef __GigiSTFmat __GigiSStartFmat;
typedef __GigiSTFmat __GigiTStartFmat;
typedef __GigiSTFmat __GigidSdxFmat;
typedef __GigiSTFmat __GigidTdxFmat;
typedef __GigiSTFmat __GigidSdyDomFmat;
typedef __GigiSTFmat __GigidTdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  signed32 Integer:          2;
  unsigned32 Fraction:      27;
  unsigned32 pad0:           3;
} __GigiQFmat;
#else
typedef struct {
  unsigned32 pad0:           3;
  unsigned32 Fraction:      27;
  signed32 Integer:          2;
} __GigiQFmat;
#endif

typedef __GigiQFmat __GigiQStartFmat;
typedef __GigiQFmat __GigidQdxFmat;
typedef __GigiQFmat __GigidQdyDomFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 TLoMagnitude:    12;
  unsigned32 SSign:            1;
  unsigned32 SMagnitude:      19;
} __GigiTextureAddressFmat0;
#else
typedef struct {
  unsigned32 SMagnitude:      19;
  unsigned32 SSign:            1;
  unsigned32 TLoMagnitude:    12;
} __GigiTextureAddressFmat0;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            24;
  unsigned32 TSign:            1;
  unsigned32 THiMagnitude:     7;
} __GigiTextureAddressFmat1;
#else
typedef struct {
  unsigned32 THiMagnitude:     7;
  unsigned32 TSign:            1;
  unsigned32 pad0:            24;
} __GigiTextureAddressFmat1;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                    28;
  unsigned32 DeltaFormat:              1;
  unsigned32 Fast:                     1;
  unsigned32 PerspectiveCorrection:    1;
  unsigned32 Enable:                   1;
} __GigiTextureAddrModeFmat;
#else
typedef struct {
  unsigned32 Enable:                   1;
  unsigned32 PerspectiveCorrection:    1;
  unsigned32 Fast:                     1;
  unsigned32 DeltaFormat:              1;
  unsigned32 pad0:                    28;
} __GigiTextureAddrModeFmat;
#endif

/*
**  GIGI Texture Read Registers
*/

typedef struct {
#if BIG_ENDIAN == 1
    unsigned32 TCoeff :      8;
    unsigned32 Pad1 :        7;
    unsigned32 SwapT :       1;
    unsigned32 SCoeff :      8;
    unsigned32 Pad0 :        7;
    unsigned32 SwapS :       1;
#else
    unsigned32 SwapS :       1;
    unsigned32 Pad0 :        7;
    unsigned32 SCoeff :      8;
    unsigned32 SwapT :       1;
    unsigned32 Pad1 :        7;
    unsigned32 TCoeff :      8;
#endif
} __GigiTextureReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                7;
  unsigned32 PackedData:          1;
  unsigned32 pad1:                6;
  unsigned32 FilterMode:          1;
  unsigned32 Height:              4;
  unsigned32 Width:               4;
  unsigned32 pad0:                4;
  unsigned32 TWrapMode:           2;
  unsigned32 SWrapMode:           2;
  unsigned32 Enable:              1;
} __GigiTextureReadModeFmat;
#else
typedef struct {
  unsigned32 Enable:              1;
  unsigned32 SWrapMode:           2;
  unsigned32 TWrapMode:           2;
  unsigned32 pad0:                4;
  unsigned32 Width:               4;
  unsigned32 Height:              4;
  unsigned32 FilterMode:          1;
  unsigned32 pad1:                6;
  unsigned32 PackedData:          1;
  unsigned32 pad2:                7;
} __GigiTextureReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:             10;
  unsigned32 TexelSize:         3;
  unsigned32 pad1:              1;
  unsigned32 SubPatchMode:      1;
  unsigned32 WindowOrigin:      1;
  unsigned32 pad0:              7;
  unsigned32 PP2:               3;
  unsigned32 PP1:               3;
  unsigned32 PP0:               3;
} __GigiTextureMapFormatFmat;
#else
typedef struct {
  unsigned32 PP0:               3;
  unsigned32 PP1:               3;
  unsigned32 PP2:               3;
  unsigned32 pad0:              7;
  unsigned32 WindowOrigin:      1;
  unsigned32 SubPatchMode:      1;
  unsigned32 pad1:              1;
  unsigned32 TexelSize:         3;
  unsigned32 pad2:             10;
} __GigiTextureMapFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                   22;
  unsigned32 SpanFormat:              1;
  unsigned32 AlphaMap:                2;
  unsigned32 TextureFormatExtension:  1;
  unsigned32 ColorOrder:              1;
  unsigned32 NoAlphaBuffer:           1;
  unsigned32 TextureFormat:           4;
} __GigiTextureDataFormatFmat;
#else
typedef struct {
  unsigned32 TextureFormat:           4;
  unsigned32 NoAlphaBuffer:           1;
  unsigned32 ColorOrder:              1;
  unsigned32 TextureFormatExtension:  1;
  unsigned32 AlphaMap:                2;
  unsigned32 SpanFormat:              1;
  unsigned32 pad0:                   22;
} __GigiTextureDataFormatFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              8;
  unsigned32 Addr:             24;
} __GigiTexelLUTAddressFmat, __GigiTexelLUTID;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad0:              8;
} __GigiTexelLUTAddressFmat, __GigiTexelLUTID;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              1;
  unsigned32 Access:            1;
  unsigned32 pad1:              6;
  unsigned32 Addr:             24;
} __GigiTextureBaseAddressFmat;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad1:              6;
  unsigned32 Access:            1;
  unsigned32 pad0:              1;
} __GigiTextureBaseAddressFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiRawDataFmat[2];

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Alpha:             8;
  unsigned32 V:                 8;
  unsigned32 U:                 8;
  unsigned32 Y:                 8;
} __GigiTexelYUVFmat;
#else
typedef struct {
  unsigned32 Y:                 8;
  unsigned32 U:                 8;
  unsigned32 V:                 8;
  unsigned32 Alpha:             8;
} __GigiTexelYUVFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           20;
  unsigned32 PixelsPerEntry:  2;
  unsigned32 LUTOffset:       8;
  unsigned32 DirectIndex:     1;
  unsigned32 Enable:          1;
} __GigiTexelLUTModeFmat;
#else
typedef struct {
  unsigned32 Enable:          1;
  unsigned32 DirectIndex:     1;
  unsigned32 LUTOffset:       8;
  unsigned32 PixelsPerEntry:  2;
  unsigned32 pad0:           20;
} __GigiTexelLUTModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 TCoeff:            8;
  unsigned32 pad1:              7;
  unsigned32 SwapT:             1;
  unsigned32 SCoeff:            8;
  unsigned32 pad0:              7;
  unsigned32 SwapS:             1;
} __GigiInterp0Fmat;
#else
typedef struct {
  unsigned32 SwapS:             1;
  unsigned32 pad0:              7;
  unsigned32 SCoeff:            8;
  unsigned32 SwapT:             1;
  unsigned32 pad1:              7;
  unsigned32 TCoeff:            8;
} __GigiInterp0Fmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             24;
  unsigned32 Offset:            8;
} __GigiTexelLUTIndexFmat;
#else
typedef struct {
  unsigned32 Offset:            8;
  unsigned32 pad0:             24;
} __GigiTexelLUTIndexFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             15;
  unsigned32 Count:             9;
  unsigned32 Index:             8;
} __GigiTexelLUTTransferFmat;
#else
typedef struct {
  unsigned32 Index:             8;
  unsigned32 Count:             9;
  unsigned32 pad0:             15;
} __GigiTexelLUTTransferFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Valid:             1;
  unsigned32 pad0:              7;
  unsigned32 Address:          24;
} __GigiTextureIDFmat;
#else
typedef struct {
  unsigned32 Address:          24;
  unsigned32 pad0:              7;
  unsigned32 Valid:             1;
} __GigiTextureIDFmat;
#endif

typedef __GigiColorFmat __GigiAlphaMapUpperBoundFmat;
typedef __GigiColorFmat __GigiAlphaMapLowerBoundFmat;

/*
**  GIGI YUV-REG Registers
*/

typedef __GigiColorFmat __GigiChromaUpperBoundFmat;
typedef __GigiColorFmat __GigiChromaLowerBoundFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           26;
  unsigned32 TexelDisableUpdate:1;
  unsigned32 RejectTexel:     1;
  unsigned32 TestData:        1;
  unsigned32 TestMode:        2;
  unsigned32 Enable:          1;
} __GigiYUVModeFmat;
#else
typedef struct {
  unsigned32 Enable:          1;
  unsigned32 TestMode:        2;
  unsigned32 TestData:        1;
  unsigned32 RejectTexel:     1;
  unsigned32 TexelDisableUpdate:1;
  unsigned32 pad0:           26;
} __GigiYUVModeFmat;
#endif

/*
**  GIGI Localbuffer Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           15;
  unsigned32 Stencil:         1;
  unsigned32 Depth:          16;
} __GigiLBDataFmat;
#else
typedef struct {
  unsigned32 Depth:          16;
  unsigned32 Stencil:         1;
  unsigned32 pad0:           15;
} __GigiLBDataFmat;
#endif

typedef __GigiLBDataFmat __GigiLBWriteDataFmat;
typedef __GigiLBDataFmat __GigiLBSourceDataFmat;
typedef __GigiLBDataFmat __GigiLBCancelWriteFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           28;
  unsigned32 StencilWidth:    2;
  unsigned32 DepthWidth:      2;
} __GigiLBFormatFmat;
#else
typedef struct {
  unsigned32 DepthWidth:      2;
  unsigned32 StencilWidth:    2;
  unsigned32 pad0:           28;
} __GigiLBFormatFmat;
#endif

typedef __GigiLBFormatFmat __GigiLBReadFormatFmat;
typedef __GigiLBFormatFmat __GigiLBWriteFormatFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                 12;
  unsigned32 PatchMode:             1;
  unsigned32 WindowOrigin:          1;
  unsigned32 DataType:              2;
  unsigned32 pad0:                  5;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 PP2:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP0:                   3;
} __GigiLBReadModeFmat;
#else
typedef struct {
  unsigned32 PP0:                   3;
  unsigned32 PP1:                   3;
  unsigned32 PP2:                   3;
  unsigned32 ReadSourceEnable:      1;
  unsigned32 ReadDestinationEnable: 1;
  unsigned32 pad0:                  5;
  unsigned32 DataType:              2;
  unsigned32 WindowOrigin:          1;
  unsigned32 PatchMode:             1;
  unsigned32 pad1:                 12;
} __GigiLBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           12;
  unsigned32 PatchMode:       1;
  unsigned32 WindowOrigin:    1;
  unsigned32 pad0:            9;
  unsigned32 PP2:             3;
  unsigned32 PP1:             3;
  unsigned32 PP0:             3;
} __GigiLBWriteConfigFmat;
#else
typedef struct {
  unsigned32 PP0:             3;
  unsigned32 PP1:             3;
  unsigned32 PP2:             3;
  unsigned32 pad0:            9;
  unsigned32 WindowOrigin:    1;
  unsigned32 PatchMode:       1;
  unsigned32 pad1:           12;
} __GigiLBWriteConfigFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiLBReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           31;
  unsigned32 WriteEnable:     1;
} __GigiLBWriteModeFmat;
#else
typedef struct {
  unsigned32 WriteEnable:     1;
  unsigned32 pad0:           31;
} __GigiLBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:            8;
  unsigned32 Addr:           24;
} __GigiLBAddressFmat;
#else
typedef struct {
  unsigned32 Addr:           24;
  unsigned32 pad0:            8;
} __GigiLBAddressFmat;
#endif

typedef __GigiLBAddressFmat __GigiLBWindowBaseFmat;
typedef __GigiLBAddressFmat __GigiLBSourceOffsetFmat;
typedef __GigiLBAddressFmat __GigiLBWriteBaseFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           31;
  unsigned32 Stencil:         1;
} __GigiLBStencilFmat;
#else
typedef struct {
  unsigned32 Stencil:         1;
  unsigned32 pad0:           31;
} __GigiLBStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:           16;
  unsigned32 Depth:          16;
} __GigiLBDepthFmat;
#else
typedef struct {
  unsigned32 Depth:          16;
  unsigned32 pad0:           16;
} __GigiLBDepthFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              31;
  unsigned32 Data:               1;
} __GigiStencilFmat;
#else
typedef struct {
  unsigned32 Data:               1;
  unsigned32 pad0:              31;
} __GigiStencilFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              16;
  unsigned32 Data:              16;
} __GigiDepthFmat;
#else
typedef struct {
  unsigned32 Data:              16;
  unsigned32 pad0:              16;
} __GigiDepthFmat;
#endif

/*
**  GIGI Depth and Stencil Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                 13;
  unsigned32 DisableLBUpdate:       1;
  unsigned32 pad1:                 13;
  unsigned32 LBUpdateSource:        1;
  unsigned32 ForceLBUpdate:         1;
  unsigned32 pad0:                  3;
} __GigiWindowFmat;
#else
typedef struct {
  unsigned32 pad0:                  3;
  unsigned32 ForceLBUpdate:         1;
  unsigned32 LBUpdateSource:        1;
  unsigned32 pad1:                 13;
  unsigned32 DisableLBUpdate:       1;
  unsigned32 pad2:                 13;
} __GigiWindowFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad2:                 15;
  unsigned32 WriteMask:             1;
  unsigned32 pad1:                  7;
  unsigned32 CompareMask:           1;
  unsigned32 pad0:                  7;
  unsigned32 ReferenceValue:        1;
} __GigiStencilDataFmat;
#else
typedef struct {
  unsigned32 ReferenceValue:        1;
  unsigned32 pad0:                  7;
  unsigned32 CompareMask:           1;
  unsigned32 pad1:                  7;
  unsigned32 WriteMask:             1;
  unsigned32 pad2:                 15;
} __GigiStencilDataFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                17;
  unsigned32 StencilSource:        2;
  unsigned32 CompareFunction:      3;
  unsigned32 SFail:                3;
  unsigned32 DPFail:               3;
  unsigned32 DPPass:               3;
  unsigned32 UnitEnable:           1;
} __GigiStencilModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:           1;
  unsigned32 DPPass:               3;
  unsigned32 DPFail:               3;
  unsigned32 SFail:                3;
  unsigned32 CompareFunction:      3;
  unsigned32 StencilSource:        2;
  unsigned32 pad0:                17;
} __GigiStencilModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              25;
  unsigned32 CompareMode:        3;
  unsigned32 NewDepthSource:     2;
  unsigned32 WriteMask:          1;
  unsigned32 UnitEnable:         1;
} __GigiDepthModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:         1;
  unsigned32 WriteMask:          1;
  unsigned32 NewDepthSource:     2;
  unsigned32 CompareMode:        3;
  unsigned32 pad0:              25;
} __GigiDepthModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:              15;
  signed32 Z:                   17;
} __GigiZUFmat;
#else
typedef struct {
  signed32 Z:                   17;
  unsigned32 pad0:              15;
} __GigiZUFmat;
#endif

typedef __GigiZUFmat __GigiZStartUFmat;
typedef __GigiZUFmat __GigidZdxUFmat;
typedef __GigiZUFmat __GigidZdyDomUFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 Z:                 11;
  unsigned32 pad0:              21;
} __GigiZLFmat;
#else
typedef struct {
  unsigned32 pad0:              21;
  unsigned32 Z:                 11;
} __GigiZLFmat;
#endif

typedef __GigiZLFmat __GigiZStartLFmat;
typedef __GigiZLFmat __GigidZdxLFmat;
typedef __GigiZLFmat __GigidZdyDomLFmat;

/*
**  GIGI Framebuffer Registers
*/

#if BIG_ENDIAN == 1 
typedef struct {
  unsigned32 pad0:              8;
  unsigned32 Addr:             24;
} __GigiFBAddressFmat;
#else
typedef struct {
  unsigned32 Addr:             24;
  unsigned32 pad0:              8;
} __GigiFBAddressFmat;
#endif

typedef __GigiFBAddressFmat __GigiFBBaseAddressFmat;
typedef __GigiFBAddressFmat __GigiFBPixelOffsetFmat;
typedef __GigiFBAddressFmat __GigiFBSourceOffsetFmat;
typedef __GigiFBAddressFmat __GigiFBWindowBaseFmat;
typedef __GigiFBAddressFmat __GigiFBWriteBaseFmat;
typedef __GigiFBAddressFmat __GigiFBSourceBaseFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad3:                   5;
  unsigned32 PatchMode:              2;
  unsigned32 pad2:                   2;
  signed32 RelativeOffset:           3;
  unsigned32 PackedData:             1;
  unsigned32 PatchEnable:            1;
  unsigned32 TexelInhibit:           1;
  unsigned32 WindowOrigin:           1;
  unsigned32 MessageType:            1;
  unsigned32 pad0:                   4;
  unsigned32 ReadDestinationEnable:  1;
  unsigned32 ReadSourceEnable:       1;
  unsigned32 PP2:                    3;
  unsigned32 PP1:                    3;
  unsigned32 PP0:                    3;
} __GigiFBReadModeFmat;
#else
typedef struct {
  unsigned32 PP0:                    3;
  unsigned32 PP1:                    3;
  unsigned32 PP2:                    3;
  unsigned32 ReadSourceEnable:       1;
  unsigned32 ReadDestinationEnable:  1;
  unsigned32 pad0:                   4;
  unsigned32 MessageType:            1;
  unsigned32 WindowOrigin:           1;
  unsigned32 TexelInhibit:           1;
  unsigned32 PatchEnable:            1;
  unsigned32 PackedData:             1;
  signed32 RelativeOffset:           3;
  unsigned32 pad2:                   2;
  unsigned32 PatchMode:              2;
  unsigned32 pad3:                   5;
} __GigiFBReadModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct { 
  unsigned32 pad3:                   5;
  unsigned32 PatchMode:              2;
  unsigned32 pad2:                   2;
  signed32 RelativeOffset:           3;
  unsigned32 PackedData:             1;
  unsigned32 PatchEnable:            1;
  unsigned32 pad1:                   1;
  unsigned32 WindowOrigin:           1;
  unsigned32 pad0:                   7;
  unsigned32 PP2:                    3;
  unsigned32 PP1:                    3;
  unsigned32 PP0:                    3;
} __GigiFBWriteConfigFmat;
#else
typedef struct { 
  unsigned32 PP0:                    3;
  unsigned32 PP1:                    3;
  unsigned32 PP2:                    3;
  unsigned32 pad0:                   7;
  unsigned32 WindowOrigin:           1;
  unsigned32 pad1:                   1;
  unsigned32 PatchEnable:            1;
  unsigned32 PackedData:             1;
  signed32 RelativeOffset:           3;
  unsigned32 pad2:                   2;
  unsigned32 PatchMode:              2;
  unsigned32 pad3:                   5;
} __GigiFBWriteConfigFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:             29;
  unsigned32 PixelSize:         3;
} __GigiFBPixelFmat;
#else
typedef struct {
  unsigned32 PixelSize:         3;
  unsigned32 pad1:             29;
} __GigiFBPixelFmat;
#endif

typedef __GigiFBPixelFmat __GigiFBReadPixelFmat;
typedef __GigiFBPixelFmat __GigiFBWritePixelFmat;

typedef __GigiUnsignedIntegerFmat __GigiFBReadPadFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:             28;
  unsigned32 UpLoadData:        1;
  unsigned32 pad0:              2;
  unsigned32 WriteEnable:       1;
} __GigiFBWriteModeFmat;
#else
typedef struct {
  unsigned32 WriteEnable:       1;
  unsigned32 pad0:              2;
  unsigned32 UpLoadData:        1;
  unsigned32 pad1:             28;
} __GigiFBWriteModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:             28;
  signed32 RelativeOffset:      3;
  unsigned32 DataPacking:       1;
} __GigiFBPackedDataModeFmat;
#else
typedef struct {
  unsigned32 DataPacking:       1;
  signed32 RelativeOffset:      3;
  unsigned32 pad0:             28;
} __GigiFBPackedDataModeFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiFBFmat;

typedef __GigiFBFmat __GigiFBColorFmat;
typedef __GigiFBFmat __GigiFBDataFmat;
typedef __GigiFBFmat __GigiFBSourceDataFmat;

typedef __GigiUnsignedIntegerFmat __GigiFBHardwareWriteMaskFmat;
typedef __GigiUnsignedIntegerFmat __GigiFBBlockColorFmat;

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 10;
  unsigned32 Offset:               22;
} __GigiTextureDownloadOffsetFmat;
#else
typedef struct {
  unsigned32 Offset:               22;
  unsigned32 pad0:                 10;
} __GigiTextureDownloadOffsetFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad:                         22;
  unsigned32 LogicOpLogicOp:              4;
  unsigned32 LogicOpEnable:               1;
  unsigned32 ColorDDAModeEnable:          1;
  unsigned32 FBWriteModeEnable:           1;
  unsigned32 FBReadModePackedData:        1;
  unsigned32 FBReadModeReadDestination:   1;
  unsigned32 FBReadModeReadSource:        1;
} __GigiConfigFmat;
#else
typedef struct {
  unsigned32 FBReadModeReadSource:        1;
  unsigned32 FBReadModeReadDestination:   1;
  unsigned32 FBReadModePackedData:        1;
  unsigned32 FBWriteModeEnable:           1;
  unsigned32 ColorDDAModeEnable:          1;
  unsigned32 LogicOpEnable:               1;
  unsigned32 LogicOpLogicOp:              4;
  unsigned32 pad:                         22;
} __GigiConfigFmat;
#endif

/*
**  GIGI Dither Registers
*/
#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:                 15;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad0:                  2;
  unsigned32 ForceAlpha:            2;
  unsigned32 DitherMethod:          1;
  unsigned32 ColorOrder:            1;
  unsigned32 YOffset:               2;
  unsigned32 XOffset:               2;
  unsigned32 ColorFormat:           4;
  unsigned32 DitherEnable:          1;
  unsigned32 UnitEnable:            1;
} __GigiDitherModeFmat;
#else
typedef struct {
  unsigned32 UnitEnable:            1;
  unsigned32 DitherEnable:          1;
  unsigned32 ColorFormat:           4;
  unsigned32 XOffset:               2;
  unsigned32 YOffset:               2;
  unsigned32 ColorOrder:            1;
  unsigned32 DitherMethod:          1;
  unsigned32 ForceAlpha:            2;
  unsigned32 pad0:                  2;
  unsigned32 ColorFormatExtension:  1;
  unsigned32 pad1:                 15;
} __GigiDitherModeFmat;
#endif

/*
**  GIGI Logic Ops and WriteMask Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                   26;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 LogicalOp:               4;
  unsigned32 LogicalOpEnable:         1;
} __GigiLogicalOpModeFmat;
#else
typedef struct {
  unsigned32 LogicalOpEnable:         1;
  unsigned32 LogicalOp:               4;
  unsigned32 UseConstantFBWriteData:  1;
  unsigned32 pad0:                   26;
} __GigiLogicalOpModeFmat;
#endif

typedef __GigiFBFmat __GigiFBWriteDataFmat;
typedef __GigiFBFmat __GigiFBSoftwareWriteMaskFmat;

/*
**  GIGI Host Out Registers
*/

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                16;
  unsigned32 Remainder:            2;
  unsigned32 Statistics:           2;
  unsigned32 Synchronization:      2;
  unsigned32 Color:                2;
  unsigned32 Stencil:              2;
  unsigned32 Depth:                2;
  unsigned32 Passive:              2;
  unsigned32 Active:               2;
} __GigiFilterModeFmat;
#else
typedef struct {
  unsigned32 Active:               2;
  unsigned32 Passive:              2;
  unsigned32 Depth:                2;
  unsigned32 Stencil:              2;
  unsigned32 Color:                2;
  unsigned32 Synchronization:      2;
  unsigned32 Statistics:           2;
  unsigned32 Remainder:            2;
  unsigned32 pad0:                16;
} __GigiFilterModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                26;
  unsigned32 Spans:                1;
  unsigned32 CompareFunction:      1;
  unsigned32 PassiveSteps:         1;
  unsigned32 ActiveSteps:          1;
  unsigned32 StatType:             1;
  unsigned32 Enable:               1;
} __GigiStatisticModeFmat;
#else
typedef struct {
  unsigned32 Enable:               1;
  unsigned32 StatType:             1;
  unsigned32 ActiveSteps:          1;
  unsigned32 PassiveSteps:         1;
  unsigned32 CompareFunction:      1;
  unsigned32 Spans:                1;
  unsigned32 pad0:                26;
} __GigiStatisticModeFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 InterruptEnable:      1;
  unsigned32 pad0:                31;
} __GigiSyncFmat;
#else
typedef struct {
  unsigned32 pad0:                31;
  unsigned32 InterruptEnable:      1;
} __GigiSyncFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad1:           4;
  signed32 Y:               12;
  unsigned32 pad0:           4;
  signed32 X:               12;
} __GigiMinRegionFmat,
  __GigiMaxRegionFmat,
  __GigiMinHitRegionFmat,
  __GigiMaxHitRegionFmat;
#else
typedef struct {
  signed32 X:               12;
  unsigned32 pad0:           4;
  signed32 Y:               12;
  unsigned32 pad1:           4;
} __GigiMinRegionFmat,
  __GigiMaxRegionFmat,
  __GigiMinHitRegionFmat,
  __GigiMaxHitRegionFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 30;
  unsigned32 BusyFlag:              1;
  unsigned32 PickFlag:              1;
} __GigiPickResultFmat;
#else
typedef struct {
  unsigned32 PickFlag:              1;
  unsigned32 BusyFlag:              1;
  unsigned32 pad0:                 30;
} __GigiPickResultFmat;
#endif

#if BIG_ENDIAN == 1
typedef struct {
  unsigned32 pad0:                 12;
  unsigned32 screenbase:           20;
} __GigiSuspendUntilFrameBlankFmat;
#else
typedef struct {
  unsigned32 screenbase:           20;
  unsigned32 pad0:                 12;
} __GigiSuspendUntilFrameBlankFmat;
#endif

typedef __GigiUnsignedIntegerFmat __GigiResetPickResultFmat;

#if BIG_ENDIAN == 1
typedef struct {
    unsigned32 pad:                31;
    unsigned32 value:               1;
} __GigiPCITextureCacheFmat;
#else
typedef struct {
    unsigned32 value:               1;
    unsigned32 pad:                31;
} __GigiPCITextureCacheFmat;
#endif

typedef __GigiPCITextureCacheFmat __GigiPCIReadTextureCacheFmat;
typedef __GigiPCITextureCacheFmat __GigiPCIWriteTextureCacheFmat;

#endif /* GIGIREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glintdef.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: glintdef.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//************************************************************************
// *
// * DESCRIPTION  : Register Field Values for Permedia 3
// *
// ***********************************************************************

#define __PERMEDIA_ENABLE                                       1
#define __PERMEDIA_DISABLE                                      0

// From FBReadMode
#define __GLINT_8BITPIXEL                                       0
#define __GLINT_16BITPIXEL                                      1 
#define __GLINT_32BITPIXEL                                      2
#define __GLINT_4BITPIXEL                                       3
#define __GLINT_24BITPIXEL                                      4

/* Host out (Filter) options. */
#define __GLINT_FILTER_TAG                                    0x1 
#define __GLINT_FILTER_DATA                                   0x2
#define __GLINT_FILTER_TAG_AND_DATA                           0x3

/* Rasterization */
#define __GLINT_LINE_PRIMITIVE                                  0
#define __GLINT_TRAPEZOID_PRIMITIVE                             1
#define __GLINT_POINT_PRIMITIVE                                 2

#define __GLINT_FLAT_SHADE_MODE                                 0
#define __GLINT_GOURAUD_SHADE_MODE                              1

#define __GLINT_START_BIAS_ZERO                                 0
#define __GLINT_START_BIAS_HALF                                 1
#define __GLINT_START_BIAS_ALMOST_HALF                          2

/* Stipple */
#define __GLINT_AREA_STIPPLE_2_PIXEL_PATTERN                    0
#define __GLINT_AREA_STIPPLE_4_PIXEL_PATTERN                    1
#define __GLINT_AREA_STIPPLE_8_PIXEL_PATTERN                    2
#define __GLINT_AREA_STIPPLE_16_PIXEL_PATTERN                   3
#define __GLINT_AREA_STIPPLE_32_PIXEL_PATTERN                   4

/* Alpha Test */
#define __GLINT_ALPHA_COMPARE_MODE_NEVER                        0
#define __GLINT_ALPHA_COMPARE_MODE_LESS                         1
#define __GLINT_ALPHA_COMPARE_MODE_EQUAL                        2
#define __GLINT_ALPHA_COMPARE_MODE_LESS_OR_EQUAL                3
#define __GLINT_ALPHA_COMPARE_MODE_GREATER                      4
#define __GLINT_ALPHA_COMPARE_MODE_NOT_EQUAL                    5
#define __GLINT_ALPHA_COMPARE_MODE_GREATER_OR_EQUAL             6
#define __GLINT_ALPHA_COMPARE_MODE_ALWAYS                       7

/* Chroma Test Mode */
#define __GLINT_CHROMA_FBSOURCE                                 0
#define __GLINT_CHROMA_FBDATA                                   1
#define __GLINT_CHROMA_INPUT_COLOR                              2
#define __GLINT_CHROMA_OUTPUT_COLOR                             3
#define __GLINT_CHROMA_INCLUDE                                  0
#define __GLINT_CHROMA_EXCLUDE                                  1

/* Texture Filter Mode */
#define __GLINT_TEXTUREFILTER_ALPHAMAPSENSE_INCLUDE             0
#define __GLINT_TEXTUREFILTER_ALPHAMAPSENSE_EXCLUDE             1

/* Local buffer read */ 
#define __GLINT_LBDEFAULT                                       0
#define __GLINT_LBSTENCIL                                       1
#define __GLINT_LBDEPTH                                         2

#define __GLINT_TOP_LEFT_WINDOW_ORIGIN                          0
#define __GLINT_BOTTOM_LEFT_WINDOW_ORIGIN                       1

#define __GLINT_DEPTH_WIDTH_16                                  0
#define __GLINT_DEPTH_WIDTH_24                                  1
#define __GLINT_DEPTH_WIDTH_32                                  2
#define __GLINT_DEPTH_WIDTH_15                                  3

/* Stencil Test */
#define __GLINT_STENCIL_COMPARE_MODE_NEVER                      0
#define __GLINT_STENCIL_COMPARE_MODE_LESS                       1
#define __GLINT_STENCIL_COMPARE_MODE_EQUAL                      2
#define __GLINT_STENCIL_COMPARE_MODE_LESS_OR_EQUAL              3
#define __GLINT_STENCIL_COMPARE_MODE_GREATER                    4
#define __GLINT_STENCIL_COMPARE_MODE_NOT_EQUAL                  5
#define __GLINT_STENCIL_COMPARE_MODE_GREATER_OR_EQUAL           6
#define __GLINT_STENCIL_COMPARE_MODE_ALWAYS                     7

#define __GLINT_STENCIL_METHOD_KEEP                             0
#define __GLINT_STENCIL_METHOD_ZERO                             1
#define __GLINT_STENCIL_METHOD_REPLACE                          2
#define __GLINT_STENCIL_METHOD_INCR                             3
#define __GLINT_STENCIL_METHOD_DECR                             4
#define __GLINT_STENCIL_METHOD_INVERT                           5
#define __GLINT_STENCIL_METHOD_INCR_WRAP                        6
#define __GLINT_STENCIL_METHOD_DECR_WRAP                        7

/* Depth Test */
#define __GLINT_DEPTH_SOURCE_DDA                                0
#define __GLINT_DEPTH_SOURCE_SOURCE_DEPTH                       1
#define __GLINT_DEPTH_SOURCE_DEPTH_MSG                          2
#define __GLINT_DEPTH_SOURCE_LBSOURCEDATA_MSG                   3

#define __GLINT_DEPTH_COMPARE_MODE_NEVER                        0
#define __GLINT_DEPTH_COMPARE_MODE_LESS                         1
#define __GLINT_DEPTH_COMPARE_MODE_EQUAL                        2
#define __GLINT_DEPTH_COMPARE_MODE_LESS_OR_EQUAL                3
#define __GLINT_DEPTH_COMPARE_MODE_GREATER                      4
#define __GLINT_DEPTH_COMPARE_MODE_NOT_EQUAL                    5
#define __GLINT_DEPTH_COMPARE_MODE_GREATER_OR_EQUAL             6
#define __GLINT_DEPTH_COMPARE_MODE_ALWAYS                       7

/* Texture AddressMode */
#define __GLINT_TEXADDRESS_WRAP_CLAMP                           0
#define __GLINT_TEXADDRESS_WRAP_REPEAT                          1
#define __GLINT_TEXADDRESS_WRAP_MIRROR                          2
#define __GLINT_TEXADDRESS_OPERATION_2D                         0
#define __GLINT_TEXADDRESS_OPERATION_3D                         1
#define __GLINT_TEXADDRESS_TEXMAP_1D                            0
#define __GLINT_TEXADDRESS_TEXMAP_2D                            1

/* Texture ReadMode */
#define __GLINT_TEXTUREREAD_FILTER_NEAREST                      0
#define __GLINT_TEXTUREREAD_FILTER_LINEAR                       1
#define __GLINT_TEXTUREREAD_FILTER_NEARMIPNEAREST               2
#define __GLINT_TEXTUREREAD_FILTER_NEARMIPLINEAR                3
#define __GLINT_TEXTUREREAD_FILTER_LINEARMIPNEAREST             4
#define __GLINT_TEXTUREREAD_FILTER_LINEARMIPLINEAR              5

/* Texture Color Mode */
#define __GLINT_TEXCOLORMODE_APPLICATION_MODULATE               0
#define __GLINT_TEXCOLORMODE_APPLICATION_DECAL                  1
#define __GLINT_TEXCOLORMODE_APPLICATION_BLEND                  2
#define __GLINT_TEXCOLORMODE_APPLICATION_COPY                   3

/* Alpha Blend */
#define __GLINT_BLEND_FUNC_ZERO                                 0
#define __GLINT_BLEND_FUNC_ONE                                  1
#define __GLINT_BLEND_FUNC_SRC_COLOR                            2
#define __GLINT_BLEND_FUNC_DST_COLOR                            2
#define __GLINT_BLEND_FUNC_ONE_MINUS_SRC_COLOR                  3
#define __GLINT_BLEND_FUNC_ONE_MINUS_DST_COLOR                  3
#define __GLINT_BLEND_FUNC_SRC_ALPHA                            4
#define __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA                  5
#define __GLINT_BLEND_FUNC_DST_ALPHA                            6
#define __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA                  7
#define __GLINT_BLEND_FUNC_SRC_ALPHA_SATURATE                   8

/* Dither */
#define __GLINT_COLOR_FORMAT_RGBA_8888                          0
#define __GLINT_COLOR_FORMAT_RGBA_5555                          1
#define __GLINT_COLOR_FORMAT_RGBA_5551_FRONT                    1
#define __GLINT_COLOR_FORMAT_RGBA_4444                          2
#define __GLINT_COLOR_FORMAT_RGBA_4444_FRONT                    3
#define __GLINT_COLOR_FORMAT_RGBA_4444_BACK                     4
#define __GLINT_COLOR_FORMAT_RGB_332_FRONT                      5
#define __GLINT_COLOR_FORMAT_RGB_332_BACK                       6
#define __GLINT_COLOR_FORMAT_RGB_121_FRONT                      7
#define __GLINT_COLOR_FORMAT_RGB_121_BACK                       8

#define __GLINT_COLOR_FORMAT_CI_8                              14
#define __GLINT_COLOR_FORMAT_CI_4                              15


/* Logical Ops/Write mask */
#define __GLINT_LOGICOP_CLEAR                                   0
#define __GLINT_LOGICOP_AND                                     1
#define __GLINT_LOGICOP_AND_REVERSE                             2
#define __GLINT_LOGICOP_COPY                                    3
#define __GLINT_LOGICOP_AND_INVERTED                            4
#define __GLINT_LOGICOP_NOOP                                    5
#define __GLINT_LOGICOP_XOR                                     6
#define __GLINT_LOGICOP_OR                                      7
#define __GLINT_LOGICOP_NOR                                     8
#define __GLINT_LOGICOP_EQUIV                                   9
#define __GLINT_LOGICOP_INVERT                                 10
#define __GLINT_LOGICOP_OR_REVERSE                             11
#define __GLINT_LOGICOP_COPY_INVERT                            12
#define __GLINT_LOGICOP_OR_INVERT                              13
#define __GLINT_LOGICOP_NAND                                   14
#define __GLINT_LOGICOP_SET                                    15

#define __GLINT_ALL_WRITEMASKS_SET                     0xFFFFFFFF

/*-----------------------------------------------------*/

#define COLOR_MODE   /* 0=BGR, 1=RGB */                         1 
#define INV_COLOR_MODE                                          0

#define DITHER_XOFFSET                                          0
#define DITHER_YOFFSET                                          0

// Config - combined mode register for P2
#define __GLINT_CONFIG_FBREAD_SRC                               1
#define __GLINT_CONFIG_FBREAD_DST                               2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glglobal.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: glglobal.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//
// glglobal.h
//
// Common shared area for all components
#ifdef __GLGLOBAL
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __GLGLOBAL

// Registry locations
#define REGKEYROOT "SOFTWARE\\"
#define REGKEYDIRECTXSUFFIX "\\DirectX"
#define REGKEYDISPLAYSUFFIX "\\Display"
#define REGKEYVFWSUFFIX "\\VFW"

#define MAXCONTEXT      128
#define MAX_SUBBUFFERS  32 

// Max no of letters in the device name.
#define MAX_DEVICENAME_SIZE 32

// This many dwords to resend the bad regs every DMAA buffer
#define PERMEDIA_REV1_BAD_READBACK_REGISTER_SPACE       12      

#define GLINT_DMA 1
#define GLINT_NON_DMA 2
#define GLINT_FAKE_DMA 8
#define GLINT_UNKNOWN_INTERFACE 0xFF

// Definitions for the various chip types. 
#define VENDOR_ID_3DLABS    0x3D3D
#define VENDOR_ID_TI        0x104C

// Allof these ID's are guaranteed to fit into 16 bits
#define NOCHIP_ID           0x0
#define GLINT300SX_ID       0x1
#define GLINT500TX_ID       0x2
#define DELTA_ID            0x3
#define PERMEDIA_ID         0x4
#define TIPERMEDIA_ID       0x3d04      
#define GLINTMX_ID          0x6
#define TIPERMEDIA2_ID      0x3d07      // also known as P2C or P2A as of july 98
#define GAMMA_ID            0x8
#define PERMEDIA2_ID        0x9         // also known as P2V
#define PERMEDIA3_ID        0xa
#define GLINTR3_ID          0xb
#define PERMEDIA4_ID        0xc
#define GLINTR4_ID          0xd
#define GAMMA2_ID           0xe
#define GAMMA3_ID           0xf
#define GIGI_ID             0x8000
#define UNKNOWN_DEVICE_ID   0xffff

#define GLINTRX_ID          GLINTR3_ID

#define GLINT_ID            GLINT300SX_ID
#define P3R3_ID             PERMEDIA3_ID

#define PERMEDIA_SUBSYSTEM_ID       0x96
#define PERMEDIA_NT_SUBSYSTEM_ID    0x98
#define PERMEDIA_LC_SUBSYSTEM_ID    0x99
#define PERMEDIA2_SUBSYSTEM_ID      0xa0

// Pointer types - used in mini\pointer.c 
#define SOFTWARECURSOR 0
#define HARDWARECURSOR 1

#define GLINT300SX_REV1     (0      | (GLINT300SX_ID    << 16))
#define GLINT300SX_REV2     (2      | (GLINT300SX_ID    << 16))
#define GLINT500TX_REV1     (1      | (GLINT500TX_ID    << 16))
#define GLINTMX_REV1        (1      | (GLINTMX_ID          << 16))
#define DELTA_REV1          (1      | (DELTA_ID         << 16))
#define PERMEDIA_REV1       (1      | (PERMEDIA_ID      << 16))
#define TI_PERMEDIA_REV1    (1      | (TIPERMEDIA_ID    << 16))
#define PERMEDIA2_REV0      (0      | (PERMEDIA2_ID     << 16))
#define PERMEDIA2_REV1      (1      | (PERMEDIA2_ID     << 16))
#define TIPERMEDIA2_REV1    (1      | (TIPERMEDIA2_ID   << 16))
#define TIPERMEDIA2_REV2    (0x11   | (TIPERMEDIA2_ID   << 16))

#define PERMEDIA3_REV1      (1      | (PERMEDIA3_ID     << 16))
#define GLINTR3_REV1        (1      | (GLINTR3_ID       << 16))
#define PERMEDIA4_REV1      (1      | (PERMEDIA4_ID     << 16))
#define GLINTR4_REV1        (1      | (GLINTR4_ID       << 16))

#define GLINT_GETVERSION                1
#define GLINT_IOCTL_ADD_CONTEXT_MEMORY  2
#define GLINT_MEMORY_REQUEST            3
#define GLINT_16TO32_POINTER            4
#define GLINT_I2C                       5
#define GLINT_VMI_COMMAND               6
#define GLINT_FILE_IO                   7
// defined in demondef.h
//#define GLINT_DEMON_COMMAND           8
#define GLINT_SIMULATOR                 9
#define GLINT_GET_SOFT_ENGINE_INFO      6009

#define IOCTL_REGISTER_TEXTURE_HANDLER  0x20
#define IOCTL_REMOVE_TEXTURE_HANDLER    0x21

typedef struct {
    unsigned long   dwDevNode;
    unsigned long   Ring0EventHandle;   // Ring zero event handle to signal. Free'd by IOCTL on failure
}   REGISTERTEXTUREHANDLERIN, *PREGISTERTEXTUREHANDLERIN;

typedef struct {
    unsigned long   Handle;             // Returned handle
    unsigned long   Index;
}   REGISTERTEXTUREHANDLEROUT, *PREGISTERTEXTUREHANDLEROUT;

typedef struct {
    unsigned long   dwDevNode;
    unsigned long   Handle;             // Handle returned from IOCTL_REGISTER_TEXTURE_HANDLER
}   REMOVETEXTUREHANDLERIN, *PREMOVETEXTUREHANDLERIN;

typedef struct {
    unsigned long   Unused;
}   REMOVETEXTUREHANDLEROUT, *PREMOVETEXTUREHANDLEROUT;


// What is this request for?
#define GLINT_MEMORY_ALLOCATE           1
#define GLINT_MEMORY_FREE               2

typedef struct tagALLOCREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwFlags;
    unsigned long dwBytes;
    unsigned long ptr16;    // in/out
    unsigned long ptr32;    // in/out
} ALLOCREQUEST, *LPALLOCREQUEST;

#define GLINT_I2C_READ                  0
#define GLINT_I2C_WRITE                 1
#define GLINT_I2C_RESET                 2
#define GLINT_I2C_DEVICE_PRESENT        3
#define GLINT_I2C_DETECT_DATA_LOW       4
#define GLINT_I2C_READ_NOBASEADDR       5
typedef struct tagI2CREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do
    unsigned short wSlaveAddress;        // Slave we are talking to
    unsigned char NumItems;            // Number of items to send/receive
    unsigned char Data[256];            // Data to send/receive
    unsigned long dwReserved1;        // A reserved DWORD
    unsigned long dwReserved2;        // A reserved DWORD
    unsigned long dwReserved3;        // A reserved DWORD
    unsigned long dwReserved4;        // A reserved DWORD
} I2CREQUEST, *LPI2CREQUEST;

#define GLINT_VMI_READ                  0
#define GLINT_VMI_WRITE                 1
#define GLINT_VMI_GETMUTEX_A            2
#define GLINT_VMI_RELEASEMUTEX_A        3
typedef struct tagVMIREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do
    unsigned long dwRegister;        // Register to talk to
    unsigned long dwCommand;        // Command to send
    unsigned long dwMutex;            // A reserved DWORD
    unsigned long dwReserved2;        // A reserved DWORD
    unsigned long dwReserved3;        // A reserved DWORD
    unsigned long dwReserved4;        // A reserved DWORD
} VMIREQUEST, *LPVMIREQUEST;

#define _UNKNOWN_STREAM_CARD                    0
#define _3DLBROOKTREE_DAUGHTER_INRESET          1
#define _3DLBROOKTREE_DAUGHTER                  2
#define _3DLRESERVED                            3
#define _GENERIC_BROOKTREE868_DAUGHTER_8BITS    4
#define _GENERIC_BROOKTREE868_DAUGHTER_16BITS   5
#define _3DLCHRONTEL_BROOKTREE_DAUGHTER         6
#define _3DLCHRONTEL_SAMSUNG_DAUGHTER           7
#define _GENERIC_CHRONTEL_DAUGHTER_8BITS        8
#define _GENERIC_CHRONTEL_DAUGHTER_16BITS       9


#define GLINT_TVOUT_ENABLED             0
#define GLINT_TVOUT_UPDATE_QUALITY      1
#define GLINT_TVOUT_UPDATE_MODE         2
#define GLINT_TVOUT_UPDATE_POSITION     3

typedef struct tagTVOUTREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do
    unsigned long dwReturnVal;        // Returned value
    unsigned long dwSendVal;        // A sent value
    unsigned long dwReserved1;        // A reserved DWORD
    unsigned long dwReserved2;        // A reserved DWORD
    unsigned long dwReserved3;        // A reserved DWORD
    unsigned long dwReserved4;        // A reserved DWORD
} TVOUTREQUEST, *LPTVOUTREQUEST;


// Initialize VFW (turn off DisplayDriver heap, enable DDRAW, etc)
#define GLINT_VFW_INIT                          1

// De-Initialize VFW (re-enable DisplayDriver heap, etc)
#define GLINT_VFW_CLOSE                         2

// Setup the Streaming capture buffers
// Takes a width and height, returns the stride and locations of the buffers
#define GLINT_VFW_BUFFER_SETUP                  3

// Capture the current buffer
// Takes src and dest rects and a bitmap to upload to.
// Returns the time at which it was captured relative to the clock reset
#define GLINT_VFW_BUFFER_CAPTURE                4

// No longer used
#define GLINT_VFW_RESERVED1                     5
#define GLINT_VFW_RESERVED2                     6

// Starts the streaming capture by initializing interrupts
#define GLINT_VFW_STREAM_START                  7

// Stops the streaming capture by stopping interrupts
#define GLINT_VFW_STREAM_STOP                   8

// Resets the clock.  This is used at the start of the streaming.
// Takes a flag to say wether the clock is timed on PAL or NTSC
#define GLINT_VFW_RESETCLOCK                    9

// Gets the current elapsed time
#define GLINT_VFW_GETTIME                       10

// Sets up the stretch buffer - this doesn't have to succeed for the capture
// to work.  Performance is helped if is does succeed.
#define GLINT_VFW_STRETCHBUFFER_SETUP           11

// Starts and stops the video run (will cause interrupts to be turned on/off)
#define GLINT_VFW_START_VIDEO               12
#define GLINT_VFW_STOP_VIDEO                    13

// Gets the IRQ that the VFW driver should use
#define GLINT_VFW_GET_IRQ                       14

typedef struct tagVFWREQUEST
{
    // Sent values
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do

    // For buffer allocations
    unsigned long dwWidth;            // Width of the requested buffer
    unsigned long dwHeight;            // Height of the requested buffer

    // For the upload operations
    unsigned long dwBitmapWidth;    // Width of the bitmap used when uploading
    unsigned long fpBuffer;            // Buffer to copy into
    unsigned long dwSrcLeft;        // Source Rect for the operation
    unsigned long dwSrcRight;
    unsigned long dwSrcTop;
    unsigned long dwSrcBottom;

    unsigned long dwDestLeft;        // Dest Rect for the operation
    unsigned long dwDestRight;
    unsigned long dwDestTop;
    unsigned long dwDestBottom;

    unsigned long dwSrcBPP;            // Source BPP
    unsigned long dwDestBPP;        // Destination BPP
    unsigned long bSrcYUV;            // Source is YUV?  No need for dest as VFW only know YVU9
                                    // and we don't do that format
    // Various config settings
    unsigned long bEurope;            // Is this PAL or NTSC?
    unsigned long bFilterVideo;        // Should we filter the video?
    unsigned long bBobVideo;        // Should we try to bob on the upload?
            
    // Return values
    unsigned long dwStride;            // Stride of the setup buffers
    unsigned long dwAddress0;        // Address of buffer 0
    unsigned long dwAddress1;        // Address of buffer 0
    unsigned long dwAddress2;        // Address of buffer 0
    unsigned long dwCurrentTime;    // The current time in milliseconds (0 based) from the reset of the clock
    unsigned long dwIRQ;            // The current IRQ to use
    unsigned long dwVFWCallback;    // Callback function for interrupt
} VFWREQUEST, *LPVFWREQUEST;

// File IO VxD requests

#define GLINT_FIO_OPEN      0
#define GLINT_FIO_READ      1
#define GLINT_FIO_WRITE     2
#define GLINT_FIO_SIZE      3
#define GLINT_FIO_CLOSE     4

typedef struct tagFIOREQUEST
{
    unsigned long dwSize;
    unsigned long dwDevNode;
    unsigned long dwOperation;        // What do we want to do
    unsigned long dwHandle;
    unsigned long dwBuff;
    unsigned long dwBuffLen;
    unsigned long dwOffset;
} FIOREQUEST, *LPFIOREQUEST;

// P3 Csim requests

#define GLINT_SSD_STARTDMA                  0
#define GLINT_SSD_READBACK                  1
#define GLINT_SSD_GETOUTPUTDWORDS           2
#define GLINT_SSD_SETOUTPUTFIFO             3
#define GLINT_SSD_SETLOGFILENAME            4
#define GLINT_SSD_WRITETOLOGFILE            5
#define GLINT_SSD_WRITEFIFO                 6
#define GLINT_SSD_OPENLOGFILE               7
#define GLINT_SSD_CLOSELOGFILE              8
#define GLINT_SSD_WRITETOLOGFILEMULTIPLE    9

typedef struct tagSIMREQUEST
{
    unsigned long dwSize;
    unsigned long dwOperation;        // What do we want to do
    unsigned long dwAddr;
    unsigned long dwTagCount;
    unsigned long dwData;
} SIMREQUEST, *LPSIMREQUEST;


// Defines for texture semaphore signalling.
// Usage: Semaphore index = ((Logical Address) >> TEXTURE_SEMAPHORE_SHIFT) & TEXTURE_SEMAPHORE_MASK
// Currently 6 bits of semaphore, 14 bits of texture handle
#define MAX_TEXTUREHANDLERS     64
#define TEXTURE_HANDLER_SHIFT   26
#define TEXTURE_HANDLER_MASK    0x3f
typedef struct {
    unsigned long ThreadHandle;
    unsigned long ThreadEvent;
    unsigned long ThreadFlags;
    unsigned long ThreadTime;
}   TEXTUREHANDLER, *PTEXTUREHANDLER;



#define CONTEXT_GENERIC         0
#define CONTEXT_GLINT300SX      1
#define CONTEXT_GLINT500TX      2
#define CONTEXT_DELTA           3
#define CONTEXT_PERMEDIA        4
#define CONTEXT_GLINTMX         6
#define CONTEXT_PERMEDIA2       7
#define CONTEXT_PERMEDIA3       8
#define CONTEXT_GLINT_FAMILY    0x4000
#define CONTEXT_PERMEDIA_FAMILY 0x4001
#define CONTEXT_GIGI            0x8000
#define CONTEXT_ENDOFBLOCK      0xffff

// Some well known context and template handles.
#define CONTEXT_TEMPLATE_DISPLAY_HANDLE      0
#define CONTEXT_TEMPLATE_DIRECTDRAW_HANDLE   1
#define CONTEXT_TEMPLATE_ALLREADABLE_HANDLE  2
#define CONTEXT_TEMPLATE_DIRECT3D_HANDLE     3
#define CONTEXT_DISPLAY_HANDLE             4  
#define CONTEXT_DIRECTX_HANDLE               5
#define CONTEXT_NONE                         0xffff

#define P3RX_CONTEXT_MASK   0xfffeffff  // Everything except TextureManagement
#define P3_CONTEXTDUMP_SIZE 744         // 744 regisiters for above mask.

// #define P3RX_CONTEXT_MASK    0xffffffff  // Everything except TextureManagement
// #define P3_CONTEXTDUMP_SIZE  753         // 744 regisiters for above mask.

#define INVALID_D3D_HANDLE 0

#define MAX_CONTEXTS_IN_BLOCK 32
#define NPAGES_IN_CONTEXT_BLOCK 6
#define SIZE_OF_CONTEXT_BLOCK (NPAGES_IN_CONTEXT_BLOCK * PAGESIZE)

#define SIZE_CONFIGURATIONBASE 32
#define MAX_QUEUE_SIZE (MAX_SUBBUFFERS + 2)

// commands to the interrupt controller on the next VBLANK
typedef enum {
    NO_COMMAND = 0,
    COLOR_SPACE_BUFFER_0,
    COLOR_SPACE_BUFFER_1,
    GLINT_RACER_BUFFER_0,
    GLINT_RACER_BUFFER_1
} VBLANK_CONTROL_COMMAND;

// interrupt status bits
typedef enum {
    DMA_INTERRUPT_AVAILABLE     = 0x1, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
    SUSPEND_DMA_TILL_VBLANK     = 0x04, // Stop doing DMA till after next VBLANK
} INTERRUPT_CONTROL;

typedef enum {
    DIRECTX_LASTOP_UNKNOWN = 0,
    DIRECTX_LASTOP_2D,
} DIRECTX_STATE;

// bit definitions for the status words in GlintBoardStatus[]:
// Currently used to indicate sync and DMA status. We have the following rules:
// synced means no outstanding DMA as well as synced. DMA_COMPLETE means n
// outstanding DMA but not necessarily synced. Thus when we do a wait on DMA
// complete we turn off the synced bit.
// XXX for the moment we don't use the synced bit as it's awkward to see where
// to unset it - doing so for every access to the chip is too expensive. We
// probably need a "I'm about to start downloading to the FIFO" macro which
// gets put at the start of any routine which writes to the FIFO.
//
#define GLINT_SYNCED                0x01
#define GLINT_DMA_COMPLETE          0x02    // set when there is no outstanding DMA
#define GLINT_INTR_COMPLETE         0x04
#define GLINT_INTR_CONTEXT          0x08    // set if the current context is interrupt enabled
#define GLINT_2D_CHANGING           0x10    // set if 2D context is modifying pending fields

typedef struct __ContextTable {
    unsigned long   pNextContext;
    unsigned short  pNextContext16;
    unsigned short  nInBlock;
    unsigned short  nUsed;
    unsigned short  FirstFree;
    unsigned short  nFree;
    unsigned short  COffset[MAX_CONTEXTS_IN_BLOCK];
    signed short    CSize[MAX_CONTEXTS_IN_BLOCK];
    unsigned short  CTemplate[MAX_CONTEXTS_IN_BLOCK];
    unsigned short  CEndIndex[MAX_CONTEXTS_IN_BLOCK];
    unsigned short  CType[MAX_CONTEXTS_IN_BLOCK];
    unsigned short  CD3DHandle[MAX_CONTEXTS_IN_BLOCK];
}   CONTEXTTABLE, *PCONTEXTTABLE;


// For holding information about a single DMA Buffer
typedef struct tagDMAPartition
{
    unsigned long PhysAddr;        // Physical ddress of this sub-buffer
#ifndef WIN32
    //int              pad1;
#endif
    ULONG * VirtAddr;        // Virtual address of this sub-buffer
#ifndef WIN32
    //int              pad2;
#endif
    ULONG_PTR MaxAddress;    // Maximum address of this sub-buffer
#ifndef WIN32
    //int              pad3;
#endif
    unsigned short Locked;
    unsigned short bStampedDMA;    // Has the VXD Stamped the DMA buffer?
} P3_DMAPartition;

typedef struct _att21505off
{
    unsigned char WriteAddr1;       // 0000
    unsigned char PixelColRam;      // 0001
    unsigned char PixelRdMask;      // 0010
    unsigned char ReadAdd1;         // 0011
    unsigned char WriteAddr2;       // 0100
    unsigned char CursorColRam;     // 0101
    unsigned char Ctrl0;            // 0110
    unsigned char ReadAdd2;         // 0111
    unsigned char Ctrl1;            // 1000
    unsigned char Ctrl2;            // 1001
    unsigned char Status;           // 1010
    unsigned char CursorPattern;    // 1011
    unsigned char CursorXLow;       // 1100
    unsigned char CursorXHigh;      // 1101
    unsigned char CursorYLow;       // 1110
    unsigned char CursorYHigh;      // 1111
} ATT21505OFF;

typedef struct _DMAQueue
{
    unsigned long       dwContext;      // context for fragment
    unsigned long       dwSize;         // size of it (DWORDs)
    unsigned long       dwPhys;         // physical address
    unsigned long       dwEvent;        // event if required
} DMAQUEUE;

typedef struct _ContextRegs
{
    unsigned short      wNumRegs;
    unsigned short      wFirstReg[1];
} CONTEXTREGS;

typedef struct _VDDDISPLAYINFO {
    unsigned short ddiHdrSize;
    unsigned short ddiInfoFlags;        
    unsigned long  ddiDevNodeHandle;
    unsigned char  ddiDriverName[16];
    unsigned short ddiXRes;            
    unsigned short ddiYRes;            
    unsigned short ddiDPI;            
    unsigned char  ddiPlanes;    
    unsigned char  ddiBpp;    
    unsigned short ddiRefreshRateMax;    
    unsigned short ddiRefreshRateMin;    
    unsigned short ddiLowHorz;        
    unsigned short ddiHighHorz;        
    unsigned short ddiLowVert;        
    unsigned short ddiHighVert;        
    unsigned long  ddiMonitorDevNodeHandle;
    unsigned char  ddiHorzSyncPolarity;    
    unsigned char  ddiVertSyncPolarity;

    //
    // new 4.1 stuff
    //
    unsigned long  diUnitNumber;             // device unit number
    unsigned long  diDisplayFlags;           // mode specific flags
    unsigned long  diXDesktopPos;            // position of desktop
    unsigned long  diYDesktopPos;            // ...
    unsigned long  diXDesktopSize;           // size of desktop (for panning)
    unsigned long  diYDesktopSize;           // ...

} VDDDISPLAYINFO;

typedef struct _GlintInfo
{
#ifndef  WNT_DDRAW
    unsigned long           dwDevNode;            // The VXD's DevNode

    // Pointers
    unsigned long           dwDSBase;           // 32 bit base of data seg

    unsigned long           dwpRegisters;      
    unsigned long           dwpFrameBuffer;    
    unsigned long           dwpLocalBuffer;      

    // Chip Information
    unsigned long           dwRamDacType; 
#endif  // WNT_DDRAW

    volatile unsigned long  dwFlags;        
    unsigned long           ddFBSize;            // frame buffer size
    unsigned long           dwScreenBase;       // Screen base value for the screen
    unsigned long           dwOffscreenBase;    // Start of Offscreen heap   

    // TV Out support
    unsigned long           bTVEnabled;
    unsigned long           bTVPresent;
    unsigned long           dwStreamCardType;
    unsigned long           dwVSBLastAddressIndex;
    unsigned long           dwBaseOffset;
    unsigned long           dwMacroVision;

    // Driver information
#ifndef  WNT_DDRAW
    unsigned long           dwVideoMemorySize;
#endif  // WNT_DDRAW
    unsigned long           dwScreenWidth;
    unsigned long           dwScreenHeight;
    unsigned long           dwVideoWidth;
    unsigned long           dwVideoHeight;
    unsigned long           dwBpp;
    unsigned long           dwScreenWidthBytes;
    unsigned char           bPixelToBytesShift;
#ifdef W95_DDRAW
    unsigned char           bPad1[3];
#endif
    ULONG_PTR               pRegs;
    unsigned long           PixelClockFrequency;
    unsigned long           MClkFrequency;

    // Chip information. This should be filled out as much as
    // possible. We may not know all the information though.
    unsigned long           dwRenderChipID;
    unsigned long           dwRenderChipRev;   
    unsigned long           dwRenderFamily;
    unsigned long           dwGammaRev;
    unsigned long           dwTLChipID;
    unsigned long           dwTLFamily;
#ifndef  WNT_DDRAW
    unsigned long           dwSupportChipID;  
    unsigned long           dwSupportChipRev;  
    unsigned long           dwBoardID;        
    unsigned long           dwBoardRev;       
#endif  // WNT_DDRAW

    unsigned short          DisabledByGLDD;
#ifdef W95_DDRAW
    unsigned short          wPad2;
#endif
    unsigned long           bDXDriverEnabled;
    unsigned long           bDRAMBoard;

    // DirectDraw and Direct3D DMA state
    unsigned long           InterfaceType;
    unsigned long           CurrentPartition;
    unsigned long           NumberOfSubBuffers;
    P3_DMAPartition         DMAPartition[MAX_SUBBUFFERS];
    ULONG * volatile      CurrentBuffer;                    // Current BufferPointer
    ULONG_PTR               dwDirectXState;
    unsigned long           dwDMAFlushCount;

    // DMA information
    unsigned long           dw3DDMABufferSize;                // size of dma buffer
    unsigned long           dw3DDMABufferPhys;                // physical addresses of buffer
    ULONG_PTR               dw3DDMABufferVirt;                // virtual ring 0 address

    // index offsets into the queue for the front, back and end. Using separate
    // front and back offsets allows the display driver to add and the interrupt
    // controller to remove entries without a need for locking code.
    volatile unsigned long  frontIndex;
    volatile unsigned long  backIndex;
    unsigned long           endIndex;
    unsigned long           maximumIndex;

    // Debugging info. Spots possible memory leaks.
    unsigned long           iSurfaceInfoBlocksAllocated;

#ifndef  WNT_DDRAW
    unsigned long           dwVideoControl;
    unsigned long           dwDeviceHandle;
    char                    szDeviceName[16];
    unsigned long           dwCurrentContext;
    unsigned long           GlintBoardStatus;

    //
    // Some overlay related variable which should be shared with mini port
    //

    volatile ULONG          bOverlayEnabled;                // TRUE if the overlay is on at all
    volatile ULONG          bVBLANKUpdateOverlay;           // TRUE if the overlay needs to be updated by the VBLANK routine.
    volatile ULONG          VBLANKUpdateOverlayWidth;       // overlay width (updated in vblank)
    volatile ULONG          VBLANKUpdateOverlayHeight;      // overlay height (updated in vblank)

#endif  // WNT_DDRAW

} GlintInfo, *LPGLINTINFO;


// Config register
#define PM_CHIPCONFIG_AGPSIDEBAND  (1 << 8)
#define PM_CHIPCONFIG_AGP1XCAPABLE (1 << 9)
#define PM_CHIPCONFIG_AGP2XCAPABLE (1 << 10)
#define PM_CHIPCONFIG_AGP4XCAPABLE (1 << 11)

// Gamma config
#define G1_CHIPCONFIG_AGPSIDEBAND  (1 << 1)
#define G1_CHIPCONFIG_AGP1XCAPABLE (1 << 0)

// DAC types

#define RamDacRGB525    1           // value for RGB525
#define RamDacATT       2           // value for AT&T 21505
#define RamDacTVP3026   3           // TI TVP 3026 (Accel board)

// Board types

#define BID_MONTSERRAT  0
#define BID_RACER       1
#define BID_ACCEL       2

// definitions for dwFlags
// Glint Interrupt Control Bits
//
// InterruptEnable register
#define INTR_DISABLE_ALL                0x00
#define INTR_ENABLE_DMA                 0x01
#define INTR_ENABLE_SYNC                0x02
#define INTR_ENABLE_EXTERNAL            0x04
#define INTR_ENABLE_ERROR               0x08
#define INTR_ENABLE_VBLANK              0x10
#define INTR_ENABLE_SCANLINE            0x20
#define INTR_TEXTURE_DOWNLOAD           0x40
#define INTR_ENABLE_BYDMA               0x80
#define INTR_ENABLE_VIDSTREAM_B         0x100
#define INTR_ENABLE_VIDSTREAM_A         0x200

// InterruptFlags register
#define INTR_DMA_SET                    0x01
#define INTR_SYNC_SET                   0x02
#define INTR_EXTERNAL_SET               0x04
#define INTR_ERROR_SET                  0x08
#define INTR_VBLANK_SET                 0x10
#define INTR_SCANLINE_SET               0x20
#define INTR_BYDMA_SET                  0x80
#define INTR_VIDSTREAM_B_SET            0x100
#define INTR_VIDSTREAM_A_SET            0x200

#define INTR_CLEAR_ALL                  0x1f
#define INTR_CLEAR_DMA                  0x01
#define INTR_CLEAR_SYNC                 0x02
#define INTR_CLEAR_EXTERNAL             0x04
#define INTR_CLEAR_ERROR                0x08
#define INTR_CLEAR_VBLANK               0x10
#define INTR_CLEAR_SCANLINE             0x20
#define INTR_CLEAR_BYDMA                0x80
#define INTR_CLEAR_VIDSTREAM_B          0x100
#define INTR_CLEAR_VIDSTREAM_A          0x200

#define GMVF_REV2                     0x00000001 // chip is rev 2
#define GMVF_FFON                     0x00000002 // fast fill enabled
#define GMVF_NOIRQ                    0x00000004 // IRQ disabled
#define GMVF_SETUP                    0x00000008 // primitive setup in progress
#define GMVF_GCOP                     0x00000010 // something is using 4K area (affects mouse)
#define GMVF_DMAIP                    0x00000020 // DMA started

#define GMVF_565                      0x00000080 // Run in 565 mode
#define GMVF_DELTA                    0x00000100 // using delta
#define GMVF_8BPPRGB                  0x00000200 // use 322 RGB at 8bpp
#define GMVF_DISABLE_OVERLAY          0x00000400 // Disable overlay on P4
#define GMVF_SWCURSOR                 0x00000800 // Never use a hardware cursor
#define GMVF_INTCPTGDI                0x00001000 // Intercept GDI mode
#define GMVF_OFFSCRNBM                0x00002000 // Offscreen BitMaps mode
#define GMVF_HWWRITEMASK              0x00004000 // Offscreen BitMaps mode
#define GMVF_ALLOWP2VLUT              0x00008000 // Driver says P2V LUTs will work
#define GMVF_VBLANK_OCCURED           0x00010000 // VBlank has occured
#define GMVF_VBLANK_ENABLED           0x00020000 // VBlank interrupt is enabled
#define GMVF_VSA_INTERRUPT_OCCURED    0x00040000 // VPort interrupt has occured
#define GMVF_FRAME_BUFFER_IS_WC       0x00080000 // Frame buffer is write-combined
#define GMVF_CAN_USE_AGP_DMA          0x00100000 // DMA buffers allocated with WC
#define GMVF_32BIT_SPANS_ALIGNED      0x00200000 // Must align 32bpp spans.
#define GMVF_DFP_DISPLAY              0x00400000 // DFP is connected
#define GMVF_QDMA                     0x00800000 // 2D using QDMA system
#define GMVF_GAMMA                    0x01000000 // using gamma chip
#define GMVF_NODMA                    0x02000000 // DMA disabled
#define GMVF_COLORTRANSLATE           0x04000000 // Set if Chip can translate colors
#define GMVF_MMX_AVAILABLE            0x08000000 // Set if processor has MMX
#define GMVF_EXPORT24BPP              0x10000000 // Set if we should export 24bpp modes
#define GMVF_DONOTRESET               0x20000000 
#define GMVF_TRYTOVIRTUALISE4PLANEVGA 0x40000000 // Set if we should try to virtualise 4 plane VGA
#define GMVF_VIRTUALISE4PLANEVGA      0x80000000 // Set if we are virtualising 4 plane VGA modes.


// Cap for the maximum FIFO entries read back on a P3/R3 chip
#define MAX_P3_FIFO_ENTRIES 120

#ifndef MINIVDD
extern unsigned long CreateContext(struct tagThunkedData* pThisDisplay,
                                            LPGLINTINFO, unsigned long, unsigned short, unsigned short );
extern void _cdecl ChangeContext(struct tagThunkedData* pThisDisplay, LPGLINTINFO, unsigned long);
extern void DeleteContext(struct tagThunkedData* pThisDisplay, LPGLINTINFO, unsigned long);
extern void _cdecl SetEndIndex(LPGLINTINFO, unsigned long, unsigned short);
extern void StartDMAProper( struct tagThunkedData*, LPGLINTINFO, unsigned long, unsigned long, unsigned long );
#endif

#define MINIVDD_REGISTERDISPLAYDRIVER_BASE  0x1000
// Definitions for RegisterDisplayDriver options
#define MINIVDD_SHAREGLINFO         MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x00
#define MINIVDD_INITIALISEMODE      MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x01
#define MINIVDD_GETGLINFO           MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x02

#define MINIVDD_ALLOCATEMEMORY      MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x10
#define MINIVDD_FREEMEMORY          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x11

#define MINIVDD_GETREGISTRYKEY      MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x20

// For free and allocating memory and selectors for use on the
// 16 bit side.
#define MINIVDD_MEMORYREQUEST       MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x30

// For sending I2C data across the bus
#define MINIVDD_I2CREQUEST          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x40

// For sending VMI data to the VideoPort
#define MINIVDD_VMIREQUEST          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x41

// For talking to the video demon
#define MINIVDD_DEMONREQUEST        MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x42

// For sending Video For Windows commands
#define MINIVDD_VFWREQUEST          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x43

// For Multi-monitor support
#define MINIVDD_ENABLEINTERRUPTS    MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x50
#define MINIVDD_DISABLEINTERRUPTS   MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x51

#define MINIVDD_TVOUTREQUEST        MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x60

//#ifdef P3_CSIMULATOR
#define MINIVDD_SENDDMABUFFER       MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x100
#define MINIVDD_SETDMABUFFEROUT     MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x101
#define MINIVDD_GETOUTDMACOUNT      MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x102
#define MINIVDD_SETTESTNAME         MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x103
#define MINIVDD_WRITETAGDATATOFIFO  MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x104
#define MINIVDD_READBACKDMAADDR     MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x105
#define MINIVDD_SETDMAADDR          MINIVDD_REGISTERDISPLAYDRIVER_BASE+0x106
//#endif

#define REG_HKLM_PREFIX             0x01
#define REG_HKU_PREFIX              0x02
#define REG_HKCU_PREFIX             0x03
#define REG_HKCR_PREFIX             0x04
#define REG_HKCC_PREFIX             0x05
#define REG_HKDD_PREFIX             0x06
#define REG_DEVNODEDEFAULTPREFIX    0x07
#define REG_DEVNODEPREFIX           0x08

#define REGTYPE_STRING              0x100
#define REGTYPE_BINARY              0x300
#define REGTYPE_DWORD               0x400

// Defines for the offsets of regions within the Data Segment:
#define DATA_SEGMENT_OFFSET         0x0
#define GLINT_REGISTERS_OFFSET      0x10000
#define DMA_UPLOAD_2D               0x30000
#define DMA_BUFFER_3D               0x38000
#define FONT_CACHE_OFFSET           0x180000
#define FINAL_DATA_SEGMENT_SIZE     0x280000

// Defines the maximum size of the regions
#define DATA_SEGMENT_SIZE           GLINT_REGISTERS_OFFSET - DATA_SEGMENT_OFFSET
#define GLINT_REGISTERS_SIZE        DMA_UPLOAD_2D - GLINT_REGISTERS_OFFSET
#define DMA_UPLOAD_2D_SIZE          DMA_BUFFER_3D - DMA_UPLOAD_2D
#define DMA_BUFFER_3D_SIZE          FONT_CACHE_OFFSET - DMA_BUFFER_3D
#define FONT_CACHE_SIZE             FINAL_DATA_SEGMENT_SIZE - FONT_CACHE_OFFSET

// How much will we allow for 2D when it's using the 3D DMA buffer? And
// how much can we send in one DMA? Increasing this gives a small 
// performance improvement on a P2.

#define MAX_2D_DMA_USE              DMA_BUFFER_3D_SIZE
#define MAX_DMA_COUNT               0xffff
#define MIN_2D_DMA_BUFFER_SIZE      0x10000
#define MAX_2D_DMA_BUFFER_SIZE      0x60000

// Various independant things that can disable the offscreen bitmap heap.
#define D3D_DISABLED    1
#define DRIVER_DISABLED 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glintreg.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: glintreg.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

/*
 * GLINT register window definition
 */

#define DWFILL unsigned long :32
#define WFILL unsigned short :16

typedef unsigned long DWORD;

typedef struct GlintReg {
/*      0h */

    volatile DWORD  ResetStatus           ; DWFILL; // 0x0000
    volatile DWORD  IntEnable             ; DWFILL; // 0x0008
    volatile DWORD  IntFlags              ; DWFILL; // 0x0010
    volatile DWORD  InFIFOSpace           ; DWFILL; // 0x0018
    volatile DWORD  OutFIFOWords          ; DWFILL; // 0x0020
    volatile DWORD  DMAAddress            ; DWFILL; // 0x0028
    volatile DWORD  DMACount              ; DWFILL; // 0x0030
    volatile DWORD  ErrorFlags            ; DWFILL; // 0x0038
    volatile DWORD  VClkCtl               ; DWFILL; // 0x0040
    volatile DWORD  TestRegister          ; DWFILL; // 0x0048
    union {
        volatile DWORD   Aperture0        ;         // SX/TX control register
        volatile DWORD   ApertureOne      ;         // Permedia control register
    };                                      DWFILL; // 0x0050
    union {
        volatile DWORD   Aperture1        ;         // SX/TX control register
        volatile DWORD   ApertureTwo      ;         // Permedia control register
    };                                      DWFILL; // 0x0058
    union {
        volatile DWORD  DMAControl        ; // 0x0060 P2
        volatile DWORD  ControlDMAControl ; // 0x0060 P3 version of same register
    };                                      DWFILL; 
    volatile DWORD  FIFODiscon            ; DWFILL; // 0x0068 SX Rev 2, TX and Permedia
    volatile DWORD  ChipConfig            ; DWFILL; // 0x0070 Permedia
    volatile DWORD  AGPControl            ; DWFILL; // 0x0078 P3 R3
    volatile DWORD  OutDMAAddress         ; DWFILL; // 0x0080 Output DMA controller address
    union {
        volatile DWORD  OutDMACount       ;         // 0x0088 P2 Output DMA controller count
        volatile DWORD  PCIFeedbackCount  ;         // 0x0088 P3R3
    };                                      DWFILL;
    union {
        volatile DWORD  AGPTexBaseAddress ;         // 0x0090 P2
        volatile DWORD  PCIAbortStatus    ;         // 0x0090 P3R3
    };                                      DWFILL;
    volatile DWORD  PCIAbortAddress       ; DWFILL; // 0x0098 P3R3


/* Bypass DMA Registers P2 */
    volatile DWORD  ByDMAAddress;           DWFILL; // 0x00A0 Bypass DMA host address
    DWFILL; DWFILL;                                 // 0x00A8 Not used.
    DWFILL; DWFILL;                                 // 0x00B0 Not used.
    volatile DWORD  ByDMAStride;            DWFILL; // 0x00B8 Host stride in bytes.
    volatile DWORD  ByDMAMemAddr;           DWFILL; // 0x00C0 Chip base address in texels.
    volatile DWORD  ByDMASize;              DWFILL; // 0x00C8 Height and width in texels.
    volatile DWORD  ByDMAByteMask;          DWFILL; // 0x00D0 Right and left byte masks.
    volatile DWORD  ByDMAControl;           DWFILL; // 0x00D8 General bypass DMA control.
    DWFILL; DWFILL;                                 // 0x00E0 Not used.
    volatile DWORD  ByDMAComplete;          DWFILL; // 0x00E8 Manual GP restart.
    volatile DWORD  PCIPLLstatus;           DWFILL; // 0x00F0 P3R3
    DWFILL; DWFILL;                                 // 0x00F8 Not Used 

    volatile DWORD  HostTextureAddress;     DWFILL; // 0x0100 P3R3
    volatile DWORD  TextureDownloadControl; DWFILL; // 0x0108 P3R3
    volatile DWORD  TextureOperation;       DWFILL; // 0x0110 P3R3
    volatile DWORD  LogicalTexturePage;     DWFILL; // 0x0118 P3R3
    volatile DWORD  TexDMAAddress;          DWFILL; // 0x0120 P3R3
    volatile DWORD  TexFifoSpace;           DWFILL; // 0x0128 P3R3



    volatile DWORD  Fill0a[0x200/4 - 0x130/4];

    volatile DWORD  TestInputControl;       DWFILL; // 0x0200 P3R3
    volatile DWORD  TestInputRdy;           DWFILL; // 0x0208 P3R3
    volatile DWORD  TestOutputControl;      DWFILL; // 0x0210 P3R3
    volatile DWORD  TestOutputRdy;          DWFILL; // 0x0218 P3R3

    volatile DWORD  TestWriteSelect;        DWFILL; // 0x0220 P3R3
    volatile DWORD  TestWriteData;          DWFILL; // 0x0228 P3R3
    volatile DWORD  TestReadSelect;         DWFILL; // 0x0230 P3R3
    volatile DWORD  TestReadData;           DWFILL; // 0x0238 P3R3
    volatile DWORD  PClkInvertA0;           DWFILL; // 0x0240 P3R3
    volatile DWORD  PClkInvertB0;           DWFILL; // 0x0248 P3R3
    volatile DWORD  PClkProfMaskA0;         DWFILL; // 0x0250 P3R3
    volatile DWORD  PClkProfMaskB0;         DWFILL; // 0x0258 P3R3
    volatile DWORD  PClkProfCount0;         DWFILL; // 0x0260 P3R3
    volatile DWORD  PClkInvertA1;           DWFILL; // 0x0268 P3R3
    volatile DWORD  PClkInvertB1;           DWFILL; // 0x0270 P3R3
    volatile DWORD  PClkProfMaskA1;         DWFILL; // 0x0278 P3R3
    volatile DWORD  PClkProfMaskB1;         DWFILL; // 0x0280 P3R3
    volatile DWORD  PClkProfCount1;         DWFILL; // 0x0288 P3R3

    volatile DWORD  Fill0b[0x300/4 - 0x290/4];

// P3 R3 Bypass register configuration
    volatile DWORD  ByAperture1Mode;      DWFILL;  // 0x0300
    volatile DWORD  ByAperture1Stride;    DWFILL;  // 0x0308
    volatile DWORD  ByAperture1YStart;    DWFILL;  // 0x0310
    volatile DWORD  ByAperture1UStart;    DWFILL;  // 0x0318
    volatile DWORD  ByAperture1VStart;    DWFILL;  // 0x0320
    volatile DWORD  ByAperture2Mode;      DWFILL;  // 0x0328
    volatile DWORD  ByAperture2Stride;    DWFILL;  // 0x0330
    volatile DWORD  ByAperture2YStart;    DWFILL;  // 0x0338
    volatile DWORD  ByAperture2UStart;    DWFILL;  // 0x0340
    volatile DWORD  ByAperture2VStart;    DWFILL;  // 0x0348
    volatile DWORD  ByDMAReadMode;        DWFILL;  // 0x0350
    volatile DWORD  ByDMAReadStride;      DWFILL;  // 0x0358
    volatile DWORD  ByDMAReadYStart;      DWFILL;  // 0x0360
    volatile DWORD  ByDMAReadUStart;      DWFILL;  // 0x0368
    volatile DWORD  ByDMAReadVStart;      DWFILL;  // 0x0370
    volatile DWORD  ByDMAReadCommandBase; DWFILL;  // 0x0378
    volatile DWORD  ByDMAReadCommandCount;DWFILL;  // 0x0380
    volatile DWORD  ByDMAWriteMode;       DWFILL;  // 0x0388
    volatile DWORD  ByDMAWriteStride;     DWFILL;  // 0x0390
    volatile DWORD  ByDMAWriteYStart;     DWFILL;  // 0x0398
    volatile DWORD  ByDMAWriteUStart;     DWFILL;  // 0x03A0
    volatile DWORD  ByDMAWriteVStart;     DWFILL;  // 0x03A8
    volatile DWORD  ByDMAWriteCommandBase;DWFILL;  // 0x03B0
    volatile DWORD  ByDMAWriteCommandCount;DWFILL; // 0x03B8
    volatile DWORD  Fill0c[0x800/4 - 0x3C0/4];

/*       Delta Registers       */

    volatile DWORD  DeltaReset;            DWFILL;
    volatile DWORD  DeltaIntEnable;        DWFILL;
    volatile DWORD  DeltaIntFlags;         DWFILL;
    volatile DWORD  DeltaInFIFOSpace;      DWFILL;
    volatile DWORD  DeltaOutFIFOWords;     DWFILL;
    volatile DWORD  DeltaDMAAddress;       DWFILL;
    volatile DWORD  DeltaDMACount;         DWFILL;
    volatile DWORD  DeltaErrorFlags;       DWFILL;
    volatile DWORD  DeltaVClkCtl;          DWFILL;
    volatile DWORD  DeltaTestRegister;     DWFILL;
    volatile DWORD  DeltaAperture0;        DWFILL;
    volatile DWORD  DeltaAperture1;        DWFILL;
    volatile DWORD  DeltaDMAControl;       DWFILL;
    volatile DWORD  DeltaDisconnectControl;DWFILL;
    
/*       Localbuffer Registers */

    volatile DWORD  Fill1[0xC40/4 - 0x870/4];

    volatile DWORD  CommandMode;            DWFILL;    // 0xC40
    volatile DWORD  CommandIntEnable;       DWFILL;    // 0xC48
    volatile DWORD  CommandIntFlags;        DWFILL;    // 0xC50
    volatile DWORD  CommandErrorFlags;      DWFILL;    // 0xC58
    volatile DWORD  CommandStatus;          DWFILL;    // 0xC60
    volatile DWORD  CommandFaultingAddr;    DWFILL;    // 0xC68
    volatile DWORD  VertexFaultingAddr;     DWFILL;    // 0xC70
    DWFILL; DWFILL;                                    // 0xC78
    DWFILL; DWFILL;                                    // 0xC80
    volatile DWORD  WriteFaultingAddr;      DWFILL;    // 0xC88
    DWFILL; DWFILL;                                    // 0xC90
    volatile DWORD  FeedbackSelectCount;    DWFILL;    // 0xC98
    DWFILL; DWFILL;                                    // 0xCA0
    DWFILL; DWFILL;                                    // 0xCA8
    DWFILL; DWFILL;                                    // 0xCB0
    volatile DWORD  GammaProcessorMode;     DWFILL;    // 0xCB8


    volatile DWORD  Fill1a[0x1000/4 - 0xCC0/4];

/*      1000h */

    union {
        volatile DWORD  LBMemoryCtl      ;              // SX/TX 
        volatile DWORD  Reboot           ;              // Permedia SGRAM control register
        volatile DWORD  MemCounter       ;              // P3R3
    };                                     DWFILL;      // 0x1000
    union {
        volatile DWORD  LBMemoryEDO      ;              // SX/TX
        volatile DWORD  MemBypassWriteMask;             // P3R3 
    };                                     DWFILL;      // 0x1008
    volatile DWORD   MemScratch          ; DWFILL;      // 0x1010 P3R3
    volatile DWORD   LocalMemCaps        ; DWFILL;      // 0x1018 P3R3 
    volatile DWORD   LocalMemTiming      ; DWFILL;      // 0x1020 P3R3 
    volatile DWORD   LocalMemControl     ; DWFILL;      // 0x1028 P3R3 
    volatile DWORD   LocalMemRefresh     ; DWFILL;      // 0x1030 P3R3 
    volatile DWORD   LocalMemPowerdown   ; DWFILL;      // 0x1038 P3R3 
    volatile DWORD   MemControl          ; DWFILL;      // 0x1040 Permedia
    DWFILL; DWFILL;                                     // 0x1048
    DWFILL; DWFILL;                                     // 0x1050
    DWFILL; DWFILL;                                     // 0x1058
    DWFILL; DWFILL;                                     // 0x1060
    DWFILL; DWFILL;                                     // 0x1068
    DWFILL; DWFILL;                                     // 0x1070
    DWFILL; DWFILL;                                     // 0x1078
    volatile DWORD   BootAddress         ; DWFILL;      // 0x1080 Permedia
    DWFILL; DWFILL;                                     // 0x1088
    DWFILL; DWFILL;                                     // 0x1090
    DWFILL; DWFILL;                                     // 0x1098
    DWFILL; DWFILL;                                     // 0x10a0
    DWFILL; DWFILL;                                     // 0x10a8
    DWFILL; DWFILL;                                     // 0x10b0
    DWFILL; DWFILL;                                     // 0x10b8
    volatile DWORD   MemConfig           ; DWFILL;      // 0x10c0 Permedia
    DWFILL; DWFILL;                                     // 0x10c8
    DWFILL; DWFILL;                                     // 0x10d0
    DWFILL; DWFILL;                                     // 0x10d8
    DWFILL; DWFILL;                                     // 0x10e0
    DWFILL; DWFILL;                                     // 0x10e8
    DWFILL; DWFILL;                                     // 0x10f0
    DWFILL; DWFILL;                                     // 0x10f8
    union {
        volatile DWORD  BypassWriteMask  ;              // Permedia
        volatile DWORD  RemoteMemControl ;              // P3R3
    };                                     DWFILL;      // 0x1100 
    DWFILL; DWFILL;                                     // 0x1108
    DWFILL; DWFILL;                                     // 0x1110
    DWFILL; DWFILL;                                     // 0x1118
    DWFILL; DWFILL;                                     // 0x1120
    DWFILL; DWFILL;                                     // 0x1128
    DWFILL; DWFILL;                                     // 0x1130
    DWFILL; DWFILL;                                     // 0x1138
    volatile DWORD   FramebufferWriteMask; DWFILL;      // 0x1140 Permedia
    DWFILL; DWFILL;                                     // 0x1148
    DWFILL; DWFILL;                                     // 0x1150
    DWFILL; DWFILL;                                     // 0x1158
    DWFILL; DWFILL;                                     // 0x1160
    DWFILL; DWFILL;                                     // 0x1168
    DWFILL; DWFILL;                                     // 0x1170
    DWFILL; DWFILL;                                     // 0x1178
    volatile DWORD   MClkCount           ; DWFILL;      // 0x1180 Permedia


/*       Framebuffer Registers */

    volatile DWORD   Fill2[0x1800/4 - 0x1188/4];
    
/*      1800h */

    volatile DWORD   FBMemoryCtl          ; DWFILL;
    volatile DWORD   FBModeSel            ; DWFILL;
    volatile DWORD   FBGPWrMask           ; DWFILL;
    volatile DWORD   FBGPColorMask        ; DWFILL;


/*       GP Fifo Interface */
    
    volatile DWORD       Fill3[0x2000/4 - 0x1820/4];

/*      2000h */

    volatile DWORD   GPFifo[1024];


/*       Internal Video Registers */

/*      3000h */

    union {
        volatile DWORD   VTGHLimit            ;         // 0x3000 SX/TX VTG Register
        volatile DWORD   ScreenBase           ;         // 0x3000 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHSyncStart        ;         // 0x3008 SX/TX VTG Register
        volatile DWORD   ScreenStride         ;         // 0x3008 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHSyncEnd          ;         // 0x3010 SX/TX VTG Register
        volatile DWORD   HTotal               ;         // 0x3010 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHBlankEnd         ;         // 0x3018 SX/TX VTG Register
        volatile DWORD   HgEnd                ;         // 0x3018 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVLimit            ;         // 0x3020 SX/TX VTG Register
        volatile DWORD   HbEnd                ;         // 0x3020 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVSyncStart        ;         // 0x3028 SX/TX VTG Register
        volatile DWORD   HsStart              ;         // 0x3028 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVSyncEnd          ;         // 0x3030 SX/TX VTG Register
        volatile DWORD   HsEnd                ;         // 0x3030 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVBlankEnd         ;         // 0x3038 SX/TX VTG Register
        volatile DWORD   VTotal               ;         // 0x3038 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHGateStart        ;         // 0x3040 SX/TX VTG Register
        volatile DWORD   VbEnd                ;         // 0x3040 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGHGateEnd          ;         // 0x3048 SX/TX VTG Register
        volatile DWORD   VsStart              ;         // 0x3048 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVGateStart        ;         // 0x3050 SX/TX VTG Register
        volatile DWORD   VsEnd                ;         // 0x3050 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVGateEnd          ;         // 0x3058 SX/TX VTG Register
        volatile DWORD   VideoControl         ;         // 0x3058 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGPolarity          ;         // 0x3060 SX/TX VTG Register
        volatile DWORD   InterruptLine        ;         // 0x3060 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGFrameRowAddr      ;         // 0x3068 SX/TX VTG Register
        volatile DWORD   DDCData              ;         // 0x3068 Permedia VTG Register
        volatile DWORD   DisplayData          ;         // 0x3068 P2 VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGVLineNumber       ;         // 0x3070 SX/TX VTG Register
        volatile DWORD   LineCount            ;         // 0x3070 Permedia VTG Register
    };                                      DWFILL;
    union {
        volatile DWORD   VTGSerialClk         ;         // 0x3078 SX/TX VTG Register
        volatile DWORD   FifoControl          ;         // 0x3078 P2 VTG Register
    };                                      DWFILL;
    volatile DWORD   ScreenBaseRight      ; DWFILL;     // 0x3080 P2 VTG Register
    volatile DWORD   MiscControl          ; DWFILL;     // 0x3088 P3R3 VTG Register
                                    
/*    Video Overlay Control */

    volatile DWORD  Fill3a[0x3100/4 - 0x3090/4];
    
/*      3100h */

    volatile DWORD  VideoOverlayUpdate          ; DWFILL;   // 0x3100
    volatile DWORD  VideoOverlayMode            ; DWFILL;   // 0x3108
    volatile DWORD  VideoOverlayFifoControl     ; DWFILL;   // 0x3110
    volatile DWORD  VideoOverlayIndex           ; DWFILL;   // 0x3118
    volatile DWORD  VideoOverlayBase0           ; DWFILL;   // 0x3120
    volatile DWORD  VideoOverlayBase1           ; DWFILL;   // 0x3128
    volatile DWORD  VideoOverlayBase2           ; DWFILL;   // 0x3130
    volatile DWORD  VideoOverlayStride          ; DWFILL;   // 0x3138
    volatile DWORD  VideoOverlayWidth           ; DWFILL;   // 0x3140
    volatile DWORD  VideoOverlayHeight          ; DWFILL;   // 0x3148
    volatile DWORD  VideoOverlayOrigin          ; DWFILL;   // 0x3150
    volatile DWORD  VideoOverlayShrinkXDelta    ; DWFILL;   // 0x3158
    volatile DWORD  VideoOverlayZoomXDelta      ; DWFILL;   // 0x3160
    volatile DWORD  VideoOverlayYDelta          ; DWFILL;   // 0x3168
    volatile DWORD  VideoOverlayFieldOffset     ; DWFILL;   // 0x3170
    volatile DWORD  VideoOverlayStatus          ; DWFILL;   // 0x3178


/*    External Video Control */

    volatile DWORD  Fill4[0x4000/4 - 0x3180/4];
    
/*      4000h */

    volatile DWORD  ExtVCReg                    ; DWFILL;   // Dac registers

    volatile DWORD  Fill5[0x5000/4 - 0x4008/4];

    union {
        volatile DWORD   RacerProDWAndStatus  ;         // 0x5000 Racer Pro Config
        volatile DWORD   P2ExtVCReg           ;         // 0x5000 P2 External Dac
    };                                      DWFILL;

    volatile DWORD  Fill5a[0x5800/4 - 0x5008/4];

/*      5800h (Video Streams Interface) */
    volatile DWORD  VSConfiguration             ; DWFILL;   // 0x5800 PM VidStream Register
    volatile DWORD  VSStatus                    ; DWFILL;   // 0x5808 PM VidStream Register
    volatile DWORD  VSSerialBusControl          ; DWFILL;   // 0x5810 PM I2C Register

    volatile DWORD  Fill6[0x5900/4 - 0x5818/4];

    // Video Stream A Video Data
    volatile DWORD  VSAControl                  ; DWFILL;   // 0x5900 PM VidStream A Register
    volatile DWORD  VSAInterruptLine            ; DWFILL;   // 0x5908 PM VidStream A Register
    volatile DWORD  VSACurrentLine              ; DWFILL;   // 0x5910 PM VidStream A Register
    volatile DWORD  VSAVideoAddressHost         ; DWFILL;   // 0x5918 PM VidStream A Register
    volatile DWORD  VSAVideoAddressIndex        ; DWFILL;   // 0x5920 PM VidStream A Register
    volatile DWORD  VSAVideoAddress0            ; DWFILL;   // 0x5928 PM VidStream A Register
    volatile DWORD  VSAVideoAddress1            ; DWFILL;   // 0x5930 PM VidStream A Register
    volatile DWORD  VSAVideoAddress2            ; DWFILL;   // 0x5938 PM VidStream A Register
    volatile DWORD  VSAVideoStride              ; DWFILL;   // 0x5940 PM VidStream A Register
    volatile DWORD  VSAVideoStartLine           ; DWFILL;   // 0x5948 PM VidStream A Register
    volatile DWORD  VSAVideoEndLine             ; DWFILL;   // 0x5950 PM VidStream A Register
    volatile DWORD  VSAVideoStartData           ; DWFILL;   // 0x5958 PM VidStream A Register
    volatile DWORD  VSAVideoEndData             ; DWFILL;   // 0x5960 PM VidStream A Register

    // Video Stream A VBI Data
    volatile DWORD  VSAVBIAddressHost           ; DWFILL;   // 0x5968 PM VidStream A Register
    volatile DWORD  VSAVBIAddressIndex          ; DWFILL;   // 0x5970 PM VidStream A Register
    volatile DWORD  VSAVBIAddress0              ; DWFILL;   // 0x5978 PM VidStream A Register
    volatile DWORD  VSAVBIAddress1              ; DWFILL;   // 0x5980 PM VidStream A Register
    volatile DWORD  VSAVBIAddress2              ; DWFILL;   // 0x5988 PM VidStream A Register
    volatile DWORD  VSAVBIStride                ; DWFILL;   // 0x5990 PM VidStream A Register
    volatile DWORD  VSAVBIStartLine             ; DWFILL;   // 0x5998 PM VidStream A Register
    volatile DWORD  VSAVBIEndLine               ; DWFILL;   // 0x59A0 PM VidStream A Register
    volatile DWORD  VSAVBIStartData             ; DWFILL;   // 0x59A8 PM VidStream A Register
    volatile DWORD  VSAVBIEndData               ; DWFILL;   // 0x59B0 PM VidStream A Register
    volatile DWORD  VSAFIFOControl              ; DWFILL;   // 0x59B8 PM VidStream A Register

    // P3 R3 specific VSA registers
    volatile DWORD  VSATimeStamp0               ; DWFILL;   // 0x59C0 P3R3 PM VidStream A Register
    volatile DWORD  VSATimeStamp1               ; DWFILL;   // 0x59C8 P3R3 PM VidStream A Register
    volatile DWORD  VSATimeStamp2               ; DWFILL;   // 0x59D0 P3R3 PM VidStream A Register
    volatile DWORD  VSADroppedFrames            ; DWFILL;   // 0x59D8 P3R3 PM VidStream A Register

    volatile DWORD  Fill7[0x5A00/4 - 0x59E0/4];

    // Video Stream B Video Data
    volatile DWORD  VSBControl                  ; DWFILL;   // 0x5A00 PM VidStream B Register
    volatile DWORD  VSBInterruptLine            ; DWFILL;   // 0x5A08 PM VidStream B Register
    volatile DWORD  VSBCurrentLine              ; DWFILL;   // 0x5A10 PM VidStream B Register
    volatile DWORD  VSBVideoAddressHost         ; DWFILL;   // 0x5A18 PM VidStream B Register
    volatile DWORD  VSBVideoAddressIndex        ; DWFILL;   // 0x5A20 PM VidStream B Register
    volatile DWORD  VSBVideoAddress0            ; DWFILL;   // 0x5A28 PM VidStream B Register
    volatile DWORD  VSBVideoAddress1            ; DWFILL;   // 0x5A30 PM VidStream B Register
    volatile DWORD  VSBVideoAddress2            ; DWFILL;   // 0x5A38 PM VidStream B Register
    volatile DWORD  VSBVideoStride              ; DWFILL;   // 0x5A40 PM VidStream B Register
    volatile DWORD  VSBVideoStartLine           ; DWFILL;   // 0x5A48 PM VidStream B Register
    volatile DWORD  VSBVideoEndLine             ; DWFILL;   // 0x5A50 PM VidStream B Register
    volatile DWORD  VSBVideoStartData           ; DWFILL;   // 0x5A58 PM VidStream B Register
    volatile DWORD  VSBVideoEndData             ; DWFILL;   // 0x5A60 PM VidStream B Register

    volatile DWORD  VSBVBIAddressHost           ; DWFILL;   // 0x5A68 PM VidStream B Register
    volatile DWORD  VSBVBIAddressIndex          ; DWFILL;   // 0x5A70 PM VidStream B Register
    volatile DWORD  VSBVBIAddress0              ; DWFILL;   // 0x5A78 PM VidStream B Register
    volatile DWORD  VSBVBIAddress1              ; DWFILL;   // 0x5A80 PM VidStream B Register
    volatile DWORD  VSBVBIAddress2              ; DWFILL;   // 0x5A88 PM VidStream B Register
    volatile DWORD  VSBVBIStride                ; DWFILL;   // 0x5A90 PM VidStream B Register
    volatile DWORD  VSBVBIStartLine             ; DWFILL;   // 0x5A98 PM VidStream B Register
    volatile DWORD  VSBVBIEndLine               ; DWFILL;   // 0x5AA0 PM VidStream B Register
    volatile DWORD  VSBVBIStartData             ; DWFILL;   // 0x5AA8 PM VidStream B Register
    volatile DWORD  VSBVBIEndData               ; DWFILL;   // 0x5AB0 PM VidStream B Register
    volatile DWORD  VSBFIFOControl              ; DWFILL;   // 0x5AB8 PM VidStream B Register

    // P3 R3 specific VS registers
    volatile DWORD  VSDMAMode                   ; DWFILL;   // 0x5AC0 P3R3 PM VidStream A Register
    volatile DWORD  VSDMACommandBase            ; DWFILL;   // 0x5AC8 P3R3 PM VidStream A Register
    volatile DWORD  VSDMACommandCount           ; DWFILL;   // 0x5AD0 P3R3 PM VidStream A Register

    volatile DWORD  Fill8[0x6000/4 - 0x5AD8/4];

/*      6000h */
    volatile DWORD  ExtBrdReg                   ; DWFILL;
    volatile DWORD  VRAMBankSwitch              ; DWFILL;

    volatile DWORD  Fill9[0x63C0/4 - 0x6010/4]  ;
                                                  WFILL;    // 0x63c0 
    volatile BYTE   WriteMiscOutputReg          ;           // 0x63c2
    volatile BYTE   Fill9a                      ;           // 0x63c3
    union {
        volatile WORD   VGASequencerReg         ;           // 0x63c4
        struct {
            volatile BYTE   VGASequencerIndexReg    ;       // 0x63c4
            volatile BYTE   VGASequencerDataReg     ;       // 0x63c5
        };
    };
                                                  WFILL;    // 0x63c6
                                                  DWFILL;   // 0x63c8 
    volatile BYTE   ReadMiscOutputReg           ;           // 0x63cc 
    volatile BYTE   Fill9b                      ; WFILL;    // 0x63cd 
    
    volatile DWORD  Fill10[0x7000/4 - 0x63D0/4] ;

    volatile DWORD  RacerProUBufB               ; DWFILL;    // 0x7000 Racer Pro config

    volatile DWORD  Fill10a[0x8000/4 - 0x7008/4];

/*    Graphics Processor */
/*      8000h */
    volatile DWORD   StartXDom                  ; DWFILL;  /*           0 */
    volatile DWORD   dXDom                      ; DWFILL;  /*           1 */
    volatile DWORD   StartXSub                  ; DWFILL;  /*           2 */
    volatile DWORD   dXSub                      ; DWFILL;  /*           3 */
    volatile DWORD   StartY                     ; DWFILL;  /*           4 */
    volatile DWORD   dY                         ; DWFILL;  /*           5 */
    volatile DWORD   Count                      ; DWFILL;  /*           6 */
    volatile DWORD   Render                     ; DWFILL;  /*           7 */
    volatile DWORD   ContinueNewLine            ; DWFILL;  /*           8 */
    volatile DWORD   ContinueNewDom             ; DWFILL;  /*           9 */
    volatile DWORD   ContinueNewSub             ; DWFILL;  /*           A */
    volatile DWORD   Continue                   ; DWFILL;  /*           B */
    volatile DWORD   FlushSpan                  ; DWFILL;  /*           C */
    volatile DWORD   BitMaskPattern             ; DWFILL;  /*           D */
    DWFILL; DWFILL; DWFILL; DWFILL;                        /*         e-f */
    
/*      8000h+16*8 */
    volatile DWORD   PointTable0                ; DWFILL;  /*           10 */
    volatile DWORD   PointTable1                ; DWFILL;  /*           11 */
    volatile DWORD   PointTable2                ; DWFILL;  /*           12 */
    volatile DWORD   PointTable3                ; DWFILL;  /*           13 */
    volatile DWORD   RasterizerMode             ; DWFILL;  /*           14 */
    volatile DWORD   YLimits                    ; DWFILL;  /*           15 */
    volatile DWORD   ScanlineOwnership          ; DWFILL;  /*           16 */
    volatile DWORD   WaitForCompletion          ; DWFILL;  /*           17 */
    volatile DWORD   PixelSize                  ; DWFILL;  /*           18 */
    volatile DWORD   XLimits                    ; DWFILL;  /*           19 */
    volatile DWORD   RectangleOrigin            ; DWFILL;  /*           1a */
    volatile DWORD   RectangleSize              ; DWFILL;  /*           1b */
    volatile DWORD   Fill11[4*2];                          /*        1c-1f */
    
/*      8000h+32*8 */
    volatile DWORD   CoverageValue              ; DWFILL;  /*           20 */
    volatile DWORD   PrepareToRender            ; DWFILL;  /*           21 */
    volatile DWORD   ActiveStepX                ; DWFILL;  /*           22 */
    volatile DWORD   PassiveStepX               ; DWFILL;  /*           23 */
    volatile DWORD   ActiveStepYDomEdge         ; DWFILL;  /*           24 */
    volatile DWORD   PassiveStepYDomEdge        ; DWFILL;  /*           25 */
    volatile DWORD   FastBlockLimits            ; DWFILL;  /*           26 */
    volatile DWORD   FastBlockFill              ; DWFILL;  /*           27 */
    volatile DWORD   SubPixelCorrection         ; DWFILL;  /*           28 */
    volatile DWORD   ForceBackgroundColor       ; DWFILL;  /*           29 */
    volatile DWORD   PackedDataLimits           ; DWFILL;  /*           2a */
    volatile DWORD   SpanStepX                  ; DWFILL;  /*           2b */
    volatile DWORD   SpanStepYDomEdge           ; DWFILL;  /*           2c */
    volatile DWORD   SpanMask                   ; DWFILL;  /*           2d */
    volatile DWORD   SuspendReads               ; DWFILL;  /*           2e */
    volatile DWORD   Fill12[1*2];                          /*           2f */
    
/*      8000h+48*8 */
    volatile DWORD   ScissorMode                ; DWFILL;  /*           30 */
    volatile DWORD   ScissorMinXY               ; DWFILL;  /*           31 */
    volatile DWORD   ScissorMaxXY               ; DWFILL;  /*           32 */
    volatile DWORD   ScreenSize                 ; DWFILL;  /*           33 */
    volatile DWORD   AreaStippleMode            ; DWFILL;  /*           34 */
    volatile DWORD   LineStippleMode            ; DWFILL;  /*           35 */
    volatile DWORD   LoadLineStippleCounters    ; DWFILL;  /*           36 */
    volatile DWORD   UpdateLineStippleCounters  ; DWFILL;  /*           37 */
    volatile DWORD   SaveLineStippleCounters    ; DWFILL;  /*           38 */
    volatile DWORD   WindowOrigin               ; DWFILL;  /*           39 */
    volatile DWORD   Fill13[6*2];                          /*        3a-3f */
    
/*      8000h+64*8 */
    volatile DWORD   AreaStipplePattern0        ; DWFILL;  /*           40 */
    volatile DWORD   AreaStipplePattern1        ; DWFILL;  /*           41 */
    volatile DWORD   AreaStipplePattern2        ; DWFILL;  /*           42 */
    volatile DWORD   AreaStipplePattern3        ; DWFILL;  /*           43 */
    volatile DWORD   AreaStipplePattern4        ; DWFILL;  /*           44 */
    volatile DWORD   AreaStipplePattern5        ; DWFILL;  /*           45 */
    volatile DWORD   AreaStipplePattern6        ; DWFILL;  /*           46 */
    volatile DWORD   AreaStipplePattern7        ; DWFILL;  /*           47 */
    volatile DWORD   AreaStipplePattern8        ; DWFILL;  /*           48 */
    volatile DWORD   AreaStipplePattern9        ; DWFILL;  /*           49 */
    volatile DWORD   AreaStipplePattern10       ; DWFILL;  /*           4a */
    volatile DWORD   AreaStipplePattern11       ; DWFILL;  /*           4b */
    volatile DWORD   AreaStipplePattern12       ; DWFILL;  /*           4c */
    volatile DWORD   AreaStipplePattern13       ; DWFILL;  /*           4d */
    volatile DWORD   AreaStipplePattern14       ; DWFILL;  /*           4e */
    volatile DWORD   AreaStipplePattern15       ; DWFILL;  /*           4f */
    volatile DWORD   AreaStipplePattern16       ; DWFILL;  /*           50 */
    volatile DWORD   AreaStipplePattern17       ; DWFILL;  /*           51 */
    volatile DWORD   AreaStipplePattern18       ; DWFILL;  /*           52 */
    volatile DWORD   AreaStipplePattern19       ; DWFILL;  /*           53 */
    volatile DWORD   AreaStipplePattern20       ; DWFILL;  /*           54 */
    volatile DWORD   AreaStipplePattern21       ; DWFILL;  /*           55 */
    volatile DWORD   AreaStipplePattern22       ; DWFILL;  /*           56 */
    volatile DWORD   AreaStipplePattern23       ; DWFILL;  /*           57 */
    volatile DWORD   AreaStipplePattern24       ; DWFILL;  /*           58 */
    volatile DWORD   AreaStipplePattern25       ; DWFILL;  /*           59 */
    volatile DWORD   AreaStipplePattern26       ; DWFILL;  /*           5a */
    volatile DWORD   AreaStipplePattern27       ; DWFILL;  /*           5b */
    volatile DWORD   AreaStipplePattern28       ; DWFILL;  /*           5c */
    volatile DWORD   AreaStipplePattern29       ; DWFILL;  /*           5d */
    volatile DWORD   AreaStipplePattern30       ; DWFILL;  /*           5e */
    volatile DWORD   AreaStipplePattern31       ; DWFILL;  /*           5f */

    volatile DWORD   Fill14[16*2];                         /*        60-6f */
    
    volatile DWORD   TextureAddressMode         ; DWFILL;  /*           70 */
    volatile DWORD   SStart                     ; DWFILL;  /*           71 */
    volatile DWORD   dSdx                       ; DWFILL;  /*           72 */
    volatile DWORD   dSdyDom                    ; DWFILL;  /*           73 */
    volatile DWORD   TStart                     ; DWFILL;  /*           74 */
    volatile DWORD   dTdx                       ; DWFILL;  /*           75 */
    volatile DWORD   dTdyDom                    ; DWFILL;  /*           76 */
    volatile DWORD   QStart                     ; DWFILL;  /*           77 */
    volatile DWORD   dQdx                       ; DWFILL;  /*           78 */
    volatile DWORD   dQdyDom                    ; DWFILL;  /*           79 */
    volatile DWORD   LOD                        ; DWFILL;  /*           7a */
    volatile DWORD   dSdy                       ; DWFILL;  /*           7b */
    volatile DWORD   dTdy                       ; DWFILL;  /*           7c */
    volatile DWORD   dQdy                       ; DWFILL;  /*           7d */

    volatile DWORD   Fill15[2*2];                          /*        7e-7f */

    union {
        volatile DWORD   TextureAddress             ;
        volatile DWORD   S1Start                    ;
    };                                          DWFILL;  /*           80 */
    union {
        volatile DWORD   TexelCoordUV               ;
        volatile DWORD   dS1dx               ;
    };                                          DWFILL;  /*           81 */
    union {
        volatile DWORD   TexelCoordU                ;
        volatile DWORD   dS1dyDom                ;
    };                                          DWFILL;  /*           82 */
    union {
        volatile DWORD   TexelCoordV                ;
        volatile DWORD   T1Start                ;
    };                                          DWFILL;  /*           83 */
    
    volatile DWORD   dT1dx                          ; DWFILL;        // [0x084]
    volatile DWORD   dT1dyDom                       ; DWFILL;          // [0x085]
    volatile DWORD   Q1Start                        ; DWFILL;          // [0x086]
    volatile DWORD   dQ1dx                          ; DWFILL;          // [0x087]
    volatile DWORD   dQ1dyDom                       ; DWFILL;         // [0x088]
    volatile DWORD   LOD1                           ; DWFILL;          // [0x089]
    volatile DWORD   TextureLODBiasS                ; DWFILL;         // [0x08A]
    volatile DWORD   TextureLODBiasT                ; DWFILL;         // [0x08B]

    volatile DWORD   Fill16[4*2];                         /*        8b-8f */

    volatile DWORD   TxTextureReadMode          ; DWFILL;  /*           90 */
    volatile DWORD   TextureFormat              ; DWFILL;  /*           91 */
    volatile DWORD   TextureCacheControl        ; DWFILL;  /*           92 */
    volatile DWORD   TexelData0                 ; DWFILL;  /*           93 */
    volatile DWORD   TexelData1                 ; DWFILL;  /*           94 */
    volatile DWORD   BorderColor                ; DWFILL;  /*           95 */
    volatile DWORD   LUTData                    ; DWFILL;  /*           96 */
    volatile DWORD   LUTDataDirect              ; DWFILL;  /*           97 */
    volatile DWORD   TexelLUTIndex              ; DWFILL;  /*           98 */
    volatile DWORD   TexelLUTData               ; DWFILL;  /*           99 */
    volatile DWORD   TexelLUTAddress            ; DWFILL;  /*           9a */
    volatile DWORD   TexelLUTTransfer           ; DWFILL;  /*           9b */
    volatile DWORD   TextureFilterMode          ; DWFILL;  /*           9c */
    volatile DWORD   TextureChromaUpper         ; DWFILL;  /*           9d */
    volatile DWORD   TextureChromaLower         ; DWFILL;  /*           9e */

    volatile DWORD   BorderColor1               ; DWFILL;  /*           9f */

    volatile DWORD   TxBaseAddr0                ; DWFILL;  /*           a0 */
    volatile DWORD   TxBaseAddr1                ; DWFILL;  /*           a1 */
    volatile DWORD   TxBaseAddr2                ; DWFILL;  /*           a2 */
    volatile DWORD   TxBaseAddr3                ; DWFILL;  /*           a3 */
    volatile DWORD   TxBaseAddr4                ; DWFILL;  /*           a4 */
    volatile DWORD   TxBaseAddr5                ; DWFILL;  /*           a5 */
    volatile DWORD   TxBaseAddr6                ; DWFILL;  /*           a6 */
    volatile DWORD   TxBaseAddr7                ; DWFILL;  /*           a7 */
    volatile DWORD   TxBaseAddr8                ; DWFILL;  /*           a8 */
    volatile DWORD   TxBaseAddr9                ; DWFILL;  /*           a9 */
    volatile DWORD   TxBaseAddr10               ; DWFILL;  /*           aa */
    volatile DWORD   TxBaseAddr11               ; DWFILL;  /*           ab */
    volatile DWORD   TxBaseAddr12               ; DWFILL;  /*           ac */
    volatile DWORD   TxBaseAddr13               ; DWFILL;  /*           ad */
    volatile DWORD   TxBaseAddr14               ; DWFILL;  /*           ae */
    volatile DWORD   TxBaseAddr15               ; DWFILL;  /*           af */

    // volatile DWORD   Fill17[4*2];                          /*        ac-af */

    volatile DWORD   TextureBaseAddress         ; DWFILL;  /*           b0 Permedia */
    volatile DWORD   TextureMapFormat           ; DWFILL;  /*           b1 Permedia */
    volatile DWORD   TextureDataFormat          ; DWFILL;  /*           b2 Permedia */
    volatile DWORD   TextureMapWidth3           ; DWFILL;                  // [0x0B3]
    volatile DWORD   TextureMapWidth4           ; DWFILL;                  // [0x0B4]
    volatile DWORD   TextureReadPad             ; DWFILL;  /*           b5 Permedia */
    volatile DWORD   TextureMapWidth6           ; DWFILL;                  // [0x0B6]
    volatile DWORD   TextureMapWidth7           ; DWFILL;                  // [0x0B7]
    volatile DWORD   TextureMapWidth8           ; DWFILL;                  // [0x0B8]
    volatile DWORD   TextureMapWidth9           ; DWFILL;                  // [0x0B9]
    volatile DWORD   TextureMapWidth10          ; DWFILL;              // [0x0BA]
    volatile DWORD   TextureMapWidth11          ; DWFILL;              // [0x0BB]
    volatile DWORD   TextureMapWidth12          ; DWFILL;              // [0x0BC]
    volatile DWORD   TextureMapWidth13          ; DWFILL;              // [0x0BD]
    volatile DWORD   TextureMapWidth14          ; DWFILL;             // [0x0BE]
    volatile DWORD   TextureMapWidth15          ; DWFILL;              // [0x0BF]

/*      8000+192*8 */
    union {
        volatile DWORD   Texel0              ;
        volatile DWORD   TextureChromaUpper1 ;
    };                                          DWFILL;  /*             c0 */
    union {
        volatile DWORD   Texel1              ;
        volatile DWORD   TextureChromaLower1 ;
    };                                          DWFILL;  /*             c1 */
    volatile DWORD   Texel2                     ; DWFILL;  /*           c2 */
    volatile DWORD   Texel3                     ; DWFILL;  /*           c3 */
    volatile DWORD   Texel4                     ; DWFILL;  /*           c4 */
    volatile DWORD   Texel5                     ; DWFILL;  /*           c5 */
    volatile DWORD   Texel6                     ; DWFILL;  /*           c6 */
    volatile DWORD   Texel7                     ; DWFILL;  /*           c7 */
    volatile DWORD   Interp0                    ; DWFILL;  /*           c8 */
    volatile DWORD   Interp1                    ; DWFILL;  /*           c9 */
    volatile DWORD   Interp2                    ; DWFILL;  /*           ca */
    volatile DWORD   Interp3                    ; DWFILL;  /*           cb */
    volatile DWORD   Interp4                    ; DWFILL;  /*           cc */
    volatile DWORD   TextureFilter              ; DWFILL;  /*           cd */
    volatile DWORD   FxTextureReadMode          ; DWFILL;  /*           ce */
    volatile DWORD   TextureLUTMode             ; DWFILL;  /*           cf */
    
/*      8000h+208*8 */
    volatile DWORD   TextureColorMode           ; DWFILL;  /*           d0 */
    volatile DWORD   TextureEnvColor            ; DWFILL;  /*           d1 */
    volatile DWORD   FogMode                    ; DWFILL;  /*           d2 */
    volatile DWORD   FogColor                   ; DWFILL;  /*           d3 */
    volatile DWORD   FStart                     ; DWFILL;  /*           d4 */
    volatile DWORD   dFdx                       ; DWFILL;  /*           d5 */
    volatile DWORD   dFdyDom                    ; DWFILL;  /*           d6 */
    union {
        volatile DWORD   TextureKd                  ;
        volatile DWORD   ZFogBias                   ;
    };                                              DWFILL;  /*           d7 */
    volatile DWORD   TextureKs                  ; DWFILL;  /*           d8 */
    volatile DWORD   KsStart                    ; DWFILL;  /*           d9 */
    volatile DWORD   dKsdx                      ; DWFILL;  /*           da */
    volatile DWORD   dKsdyDom                   ; DWFILL;  /*           db */
    volatile DWORD   KdStart                    ; DWFILL;  /*           dc */
    volatile DWORD   dKddx                      ; DWFILL;  /*           dd */
    volatile DWORD   dKddyDom                   ; DWFILL;  /*           de */
    DWFILL; DWFILL;                                        /*           df */

    volatile DWORD   Fill20[16*2];                         /*        e0-ef */


/*      8000h+240*8 */
    volatile DWORD   RStart                     ; DWFILL;  /*           f0 */
    volatile DWORD   dRdx                       ; DWFILL;  /*           f1 */
    volatile DWORD   dRdyDom                    ; DWFILL;  /*           f2 */
    volatile DWORD   GStart                     ; DWFILL;  /*           f3 */
    volatile DWORD   dGdx                       ; DWFILL;  /*           f4 */
    volatile DWORD   dGdyDom                    ; DWFILL;  /*           f5 */
    volatile DWORD   BStart                     ; DWFILL;  /*           f6 */
    volatile DWORD   dBdx                       ; DWFILL;  /*           f7 */
    volatile DWORD   dBdyDom                    ; DWFILL;  /*           f8 */
    volatile DWORD   AStart                     ; DWFILL;  /*           f9 */
    volatile DWORD   dAdx                       ; DWFILL;  /*           fa */
    volatile DWORD   dAdyDom                    ; DWFILL;  /*           fb */
    volatile DWORD   ColorDDAMode               ; DWFILL;  /*           fc */
    volatile DWORD   ConstantColor              ; DWFILL;  /*           fd */
    volatile DWORD   Color                      ; DWFILL;  /*           fe */
    DWFILL; DWFILL;                                        /*           ff */
    
/*      8000h+256*8 */
    volatile DWORD   AlphaTestMode              ; DWFILL;  /*           100 */
    volatile DWORD   AntialiasMode              ; DWFILL;  /*           101 */
    volatile DWORD   AlphaBlendMode             ; DWFILL;  /*           102 */
    volatile DWORD   DitherMode                 ; DWFILL;  /*           103 */
    volatile DWORD   FBSoftwareWriteMask        ; DWFILL;  /*           104 */
    volatile DWORD   LogicalOpMode              ; DWFILL;  /*           105 */
    volatile DWORD   FBWriteData                ; DWFILL;  /*           105 */
    volatile DWORD   FBCancelWrite              ; DWFILL;  /*           107 */
    union {
        volatile DWORD   ActiveColorStepX       ;          /*           108 */
        volatile DWORD   RouterMode             ;          /*           108 */
    };                                            DWFILL;
    volatile DWORD   ActiveColorStepYDomEdge    ; DWFILL;  /*           109 */
    volatile DWORD   Fill21[6*2];                          /*       10a-10f */
    
/*      8000h+272*8 */
    volatile DWORD   LBReadMode                 ; DWFILL;  /*           110 */
    volatile DWORD   LBReadFormat               ; DWFILL;  /*           111 */
    volatile DWORD   LBSourceOffset             ; DWFILL;  /*           112 */
    volatile DWORD   LBData                     ; DWFILL;  /*           113 */
    volatile DWORD   LBSourceData               ; DWFILL;  /*           114 */
    volatile DWORD   LBStencil                  ; DWFILL;  /*           115 */
    volatile DWORD   LBDepth                    ; DWFILL;  /*           116 */
    volatile DWORD   LBWindowBase               ; DWFILL;  /*           117 */
    volatile DWORD   LBWriteMode                ; DWFILL;  /*           118 */
    volatile DWORD   LBWriteFormat              ; DWFILL;  /*           119 */
    volatile DWORD   LBWriteBase                ; DWFILL;  /*           11a */
    volatile DWORD   LBWriteConfig              ; DWFILL;  /*           11b */
    volatile DWORD   LBReadPad                  ; DWFILL;  /*           11c */
    volatile DWORD   TextureData                ; DWFILL;  /*           11d */
    volatile DWORD   TextureDownloadOffset      ; DWFILL;  /*           11e */
    volatile DWORD   LBWindowOffset             ; DWFILL;  /*           11f */

    volatile DWORD   HostInID                   ; DWFILL;  /*           120 */
    volatile DWORD   Security                   ; DWFILL;  /*           121 */
    volatile DWORD   FlushWriteCombining        ; DWFILL;  /*           122 */
    volatile DWORD   HostInState                ; DWFILL;  /*           123 */
    volatile DWORD   HostInIndex0               ; DWFILL;  /*           124 */
    volatile DWORD   HostInIndex1               ; DWFILL;  /*           125 */
    volatile DWORD   HostInIndex2               ; DWFILL;  /*           126 */
    volatile DWORD   HostInDMAAddress           ; DWFILL;  /*           127 */
    volatile DWORD   HostInState2               ; DWFILL;  /*           128 */
    volatile DWORD   Fill22[7*2];                          /*       129-12f */

/*      8000h+304*8 */
    volatile DWORD   Window                     ; DWFILL;  /*           130 */
    volatile DWORD   StencilMode                ; DWFILL;  /*           131 */
    volatile DWORD   StencilData                ; DWFILL;  /*           132 */
    volatile DWORD   Stencil                    ; DWFILL;  /*           133 */
    volatile DWORD   DepthMode                  ; DWFILL;  /*           134 */
    volatile DWORD   Depth                      ; DWFILL;  /*           135 */
    volatile DWORD   ZStartU                    ; DWFILL;  /*           136 */
    volatile DWORD   ZStartL                    ; DWFILL;  /*           137 */
    volatile DWORD   dZdxU                      ; DWFILL;  /*           138 */
    volatile DWORD   dZdxL                      ; DWFILL;  /*           139 */
    volatile DWORD   dZdyDomU                   ; DWFILL;  /*           13a */
    volatile DWORD   dZdyDomL                   ; DWFILL;  /*           13b */
    volatile DWORD   FastClearDepth             ; DWFILL;  /*           13c */
    volatile DWORD   LBCancelWrite              ; DWFILL;  /*           13d */
    volatile DWORD   LBWriteData                ; DWFILL;  /*           13e */
    DWFILL; DWFILL;                                        /*           13f */
    
    volatile DWORD   Fill23[16*2];                         /*       140-14f */

/*      8000h+336*8 */
    volatile DWORD   FBReadMode                 ; DWFILL;  /*           150 */
    volatile DWORD   FBSourceOffset             ; DWFILL;  /*           151 */
    volatile DWORD   FBPixelOffset              ; DWFILL;  /*           152 */
    volatile DWORD   FBColor                    ; DWFILL;  /*           153 */
    volatile DWORD   FBData                     ; DWFILL;  /*           154 */
    volatile DWORD   FBSourceData               ; DWFILL;  /*           155 */
    volatile DWORD   FBWindowBase               ; DWFILL;  /*           156 */
    volatile DWORD   FBWriteMode                ; DWFILL;  /*           157 */
    volatile DWORD   FBHardwareWriteMask        ; DWFILL;  /*           158 */
    volatile DWORD   FBBlockColor               ; DWFILL;  /*           159 */
    volatile DWORD   FBReadPixel                ; DWFILL;  /*           15a */
    volatile DWORD   FBWritePixel               ; DWFILL;  /*           15b */
    volatile DWORD   FBWriteBase                ; DWFILL;  /*           15c */
    volatile DWORD   FBWriteConfig              ; DWFILL;  /*           15d */
    volatile DWORD   FBReadPad                  ; DWFILL;  /*           15e */
    volatile DWORD   PatternRAMMode             ; DWFILL;  /*           15f */

    volatile DWORD   PatternRamData0            ; DWFILL;  /*           160 */
    volatile DWORD   PatternRamData1            ; DWFILL;  /*           161 */
    volatile DWORD   PatternRamData2            ; DWFILL;  /*           162 */
    volatile DWORD   PatternRamData3            ; DWFILL;  /*           163 */
    volatile DWORD   PatternRamData4            ; DWFILL;  /*           164 */
    volatile DWORD   PatternRamData5            ; DWFILL;  /*           165 */
    volatile DWORD   PatternRamData6            ; DWFILL;  /*           166 */
    volatile DWORD   PatternRamData7            ; DWFILL;  /*           167 */
    volatile DWORD   PatternRamData8            ; DWFILL;  /*           168 */
    volatile DWORD   PatternRamData9            ; DWFILL;  /*           169 */
    volatile DWORD   PatternRamData10           ; DWFILL;  /*           16a */
    volatile DWORD   PatternRamData11           ; DWFILL;  /*           16b */
    volatile DWORD   PatternRamData12           ; DWFILL;  /*           16c */
    volatile DWORD   PatternRamData13           ; DWFILL;  /*           16d */
    volatile DWORD   PatternRamData14           ; DWFILL;  /*           16e */
    volatile DWORD   PatternRamData15           ; DWFILL;  /*           16f */
    volatile DWORD   PatternRamData16           ; DWFILL;  /*           170 */
    volatile DWORD   PatternRamData17           ; DWFILL;  /*           171 */
    volatile DWORD   PatternRamData18           ; DWFILL;  /*           172 */
    volatile DWORD   PatternRamData19           ; DWFILL;  /*           173 */
    volatile DWORD   PatternRamData20           ; DWFILL;  /*           174 */
    volatile DWORD   PatternRamData21           ; DWFILL;  /*           175 */
    volatile DWORD   PatternRamData22           ; DWFILL;  /*           176 */
    volatile DWORD   PatternRamData23           ; DWFILL;  /*           177 */
    volatile DWORD   PatternRamData24           ; DWFILL;  /*           178 */
    volatile DWORD   PatternRamData25           ; DWFILL;  /*           179 */
    volatile DWORD   PatternRamData26           ; DWFILL;  /*           17a */
    volatile DWORD   PatternRamData27           ; DWFILL;  /*           17b */
    volatile DWORD   PatternRamData28           ; DWFILL;  /*           17c */
    volatile DWORD   PatternRamData29           ; DWFILL;  /*           17d */
    volatile DWORD   PatternRamData30           ; DWFILL;  /*           17e */
    volatile DWORD   PatternRamData31           ; DWFILL;  /*           17f */
    
/*      8000h+384*8 */
    volatile DWORD   FilterMode                 ; DWFILL;  /*           180 */
    volatile DWORD   StatisticMode              ; DWFILL;  /*           181 */
    volatile DWORD   MinRegion                  ; DWFILL;  /*           182 */
    volatile DWORD   MaxRegion                  ; DWFILL;  /*           183 */
    volatile DWORD   ResetPickResult            ; DWFILL;  /*           184 */
    volatile DWORD   MinHitRegion               ; DWFILL;  /*           185 */
    volatile DWORD   MaxHitRegion               ; DWFILL;  /*           186 */
    volatile DWORD   PickResult                 ; DWFILL;  /*           187 */
    volatile DWORD   Sync                       ; DWFILL;  /*           188 */
    volatile DWORD   RLEMask                    ; DWFILL;  // [0x189]
    DWFILL; DWFILL;                                        /*           18a */
    volatile DWORD   FBBlockColorBackU          ; DWFILL;  // [0x18B]
    volatile DWORD   FBBlockColorBackL          ; DWFILL;  // [0x18C]
    volatile DWORD   FBBlockColorUpper          ; DWFILL;  /*           18d */
    volatile DWORD   FBBlockColorLower          ; DWFILL;  /*           18e */
    volatile DWORD   SuspendUntilFrameBlank     ; DWFILL;  /*           18f */

    volatile DWORD   KsRStart                   ; DWFILL;  /*           190 */
    volatile DWORD   dKsRdx                     ; DWFILL;  /*           191 */
    volatile DWORD   dKsRdyDom                  ; DWFILL;  /*           192 */
    volatile DWORD   KsGStart                   ; DWFILL;  /*           193 */
    volatile DWORD   dKsGdx                     ; DWFILL;  /*           194 */
    volatile DWORD   dKsGdyDom                  ; DWFILL;  /*           195 */
    volatile DWORD   KsBStart                   ; DWFILL;  /*           196 */
    volatile DWORD   dKsBdx                     ; DWFILL;  /*           197 */
    volatile DWORD   dKsBdyDom                  ; DWFILL;  /*           198 */

    volatile DWORD   Fill24[7*2];                          /*       199-19f */

    volatile DWORD   KdRStart                   ; DWFILL;  /*           1a0 */
    volatile DWORD   dKdRdx                     ; DWFILL;  /*           1a1 */
    volatile DWORD   dKdRdyDom                  ; DWFILL;  /*           1a2 */
    volatile DWORD   KdGStart                   ; DWFILL;  /*           1a3 */
    volatile DWORD   dKdGdx                     ; DWFILL;  /*           1a4 */
    volatile DWORD   dKdGdyDom                  ; DWFILL;  /*           1a5 */
    volatile DWORD   KdBStart                   ; DWFILL;  /*           1a6 */
    volatile DWORD   dKdBdx                     ; DWFILL;  /*           1a7 */
    volatile DWORD   dKdBdyDom                  ; DWFILL;  /*           1a8 */

    volatile DWORD   Fill25[15*2];                         /*       1a9-1b7 */

    volatile DWORD   ContextDump                ; DWFILL;    //  0x1b8
    volatile DWORD   ContextRestore             ; DWFILL;    //  0x1b9
    volatile DWORD   ContextData                ; DWFILL;    //  0x1ba

    volatile DWORD   Fill25a[21*2];                         /*       1bb-1cf */

    volatile DWORD   TexelLUT0                  ; DWFILL;  /*           1d0 */
    volatile DWORD   TexelLUT1                  ; DWFILL;  /*           1d1 */
    volatile DWORD   TexelLUT2                  ; DWFILL;  /*           1d2 */
    volatile DWORD   TexelLUT3                  ; DWFILL;  /*           1d3 */
    volatile DWORD   TexelLUT4                  ; DWFILL;  /*           1d4 */
    volatile DWORD   TexelLUT5                  ; DWFILL;  /*           1d5 */
    volatile DWORD   TexelLUT6                  ; DWFILL;  /*           1d6 */
    volatile DWORD   TexelLUT7                  ; DWFILL;  /*           1d7 */
    volatile DWORD   TexelLUT8                  ; DWFILL;  /*           1d8 */
    volatile DWORD   TexelLUT9                  ; DWFILL;  /*           1d9 */
    volatile DWORD   TexelLUT10                 ; DWFILL;  /*           1da */
    volatile DWORD   TexelLUT11                 ; DWFILL;  /*           1db */
    volatile DWORD   TexelLUT12                 ; DWFILL;  /*           1dc */
    volatile DWORD   TexelLUT13                 ; DWFILL;  /*           1dd */
    volatile DWORD   TexelLUT14                 ; DWFILL;  /*           1de */
    volatile DWORD   TexelLUT15                 ; DWFILL;  /*           1df */

    volatile DWORD   YUVMode                    ; DWFILL;  /*           1e0 */
    volatile DWORD   ChromaUpperBound           ; DWFILL;  /*           1e1 */
    volatile DWORD   ChromaLowerBound           ; DWFILL;  /*           1e2 */
    volatile DWORD   ChromaTestMode             ; DWFILL;  /*           1e3 */

    volatile DWORD   Fill26[28*2];                         /*       1e4-1ff */

/*      8000h+512*8 DELTA specific */

    union {
        volatile DWORD   V0Fixed0    ;            // Glint Delta
        volatile DWORD   V0FloatS1   ;  };        // Permedia3 Delta
                                                  DWFILL;  /* 0x200 */
    union {
        volatile DWORD   V0Fixed1    ;
        volatile DWORD   V0FloatT1   ;  };
                                                  DWFILL;  /* 0x201 */
    union {
        volatile DWORD   V0Fixed2    ;
        volatile DWORD   V0FloatQ1   ;  };
                                                  DWFILL;  /* 0x202 */
    volatile DWORD   V0Fixed3                   ; DWFILL;  /* 0x203 */
    volatile DWORD   V0Fixed4                   ; DWFILL;  /* 0x204 */
    volatile DWORD   V0Fixed5                   ; DWFILL;  /* 0x205 */
    volatile DWORD   V0Fixed6                   ; DWFILL;  /* 0x206 */
    volatile DWORD   V0Fixed7                   ; DWFILL;  /* 0x207 */
    volatile DWORD   V0Fixed8                   ; DWFILL;  /* 0x208 */
    volatile DWORD   V0Fixed9                   ; DWFILL;  /* 0x209 */
    
    union {
        volatile DWORD   V0FixedA   ;            // Glint Delta
        volatile DWORD   V0FloatKsR ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x20A */
    union {
        volatile DWORD   V0FixedB   ;            // Glint Delta
        volatile DWORD   V0FloatKsG ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x20B */
    union {
        volatile DWORD   V0FixedC   ;            // Glint Delta
        volatile DWORD   V0FloatKsB ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x20C */

    volatile DWORD   V0FloatKdR                  ; DWFILL;  // [0x20D]
    volatile DWORD   V0FloatKdG                  ; DWFILL;  // [0x20E]
    volatile DWORD   V0FloatKdB                  ; DWFILL;  // [0x20F]

    // volatile DWORD   Fill27[3*2];

    union {
        volatile DWORD   V1Fixed0    ;
        volatile DWORD   V1FloatS1   ;  };
                                                  DWFILL;  /* 0x210 */
    union {
        volatile DWORD   V1Fixed1    ;
        volatile DWORD   V1FloatT1   ;  };
                                                  DWFILL;  /* 0x211 */
    union {
        volatile DWORD   V1Fixed2    ;
        volatile DWORD   V1FloatQ1   ;  };
                                                  DWFILL;  /* 0x212 */
    volatile DWORD   V1Fixed3                   ; DWFILL;  /* 0x213 */
    volatile DWORD   V1Fixed4                   ; DWFILL;  /* 0x214 */
    volatile DWORD   V1Fixed5                   ; DWFILL;  /* 0x215 */
    volatile DWORD   V1Fixed6                   ; DWFILL;  /* 0x216 */
    volatile DWORD   V1Fixed7                   ; DWFILL;  /* 0x217 */
    volatile DWORD   V1Fixed8                   ; DWFILL;  /* 0x218 */
    volatile DWORD   V1Fixed9                   ; DWFILL;  /* 0x219 */
        union {
        volatile DWORD   V1FixedA   ;            // Glint Delta
        volatile DWORD   V1FloatKsR ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x21A */
    union {
        volatile DWORD   V1FixedB   ;            // Glint Delta
        volatile DWORD   V1FloatKsG ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x21B */
    union {
        volatile DWORD   V1FixedC   ;            // Glint Delta
        volatile DWORD   V1FloatKsB ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x21C */

    volatile DWORD   V1FloatKdR                  ; DWFILL;  // [0x21D]
    volatile DWORD   V1FloatKdG                  ; DWFILL;  // [0x21E]
    volatile DWORD   V1FloatKdB                  ; DWFILL;  // [0x21F]

    // volatile DWORD   Fill28[3*2];

    union {
        volatile DWORD   V2Fixed0    ;
        volatile DWORD   V2FloatS1   ;  };
                                                  DWFILL;  /* 0x220 */
    union {
        volatile DWORD   V2Fixed1    ;
        volatile DWORD   V2FloatT1   ;  };
                                                  DWFILL;  /* 0x221 */
    union {
        volatile DWORD   V2Fixed2    ;
        volatile DWORD   V2FloatQ1   ;  };
                                                  DWFILL;  /* 0x222 */
    volatile DWORD   V2Fixed3                   ; DWFILL;  /* 0x223 */
    volatile DWORD   V2Fixed4                   ; DWFILL;  /* 0x224 */
    volatile DWORD   V2Fixed5                   ; DWFILL;  /* 0x225 */
    volatile DWORD   V2Fixed6                   ; DWFILL;  /* 0x226 */
    volatile DWORD   V2Fixed7                   ; DWFILL;  /* 0x227 */
    volatile DWORD   V2Fixed8                   ; DWFILL;  /* 0x228 */
    volatile DWORD   V2Fixed9                   ; DWFILL;  /* 0x229 */
    
    union {
        volatile DWORD   V2FixedA   ;            // Glint Delta
        volatile DWORD   V2FloatKsR ;   };        // Permedia3 Delta
                                                   DWFILL;  /* 0x22A */
    union {
        volatile DWORD   V2FixedB   ;            // Glint Delta
        volatile DWORD   V2FloatKsG ;   };        // Permedia3 Delta
                                                   DWFILL;  /* 0x22B */
    union {
        volatile DWORD   V2FixedC   ;            // Glint Delta
        volatile DWORD   V2FloatKsB ;   };        // Permedia3 Delta
                                                   DWFILL;  /* 0x22C */

    volatile DWORD   V2FloatKdR                  ; DWFILL;  // [0x22D]
    volatile DWORD   V2FloatKdG                  ; DWFILL;  // [0x22E]
    volatile DWORD   V2FloatKdB                  ; DWFILL;  // [0x22F]

    // volatile DWORD   Fill29[3*2];

    union {
        volatile DWORD   V0Float0   ;            // Glint Delta
        volatile DWORD   V0FloatS   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x230 */
    union {
        volatile DWORD   V0Float1   ;            // Glint Delta
        volatile DWORD   V0FloatT   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x231 */
    union {
        volatile DWORD   V0Float2   ;            // Glint Delta
        volatile DWORD   V0FloatQ   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x232 */
    volatile DWORD   V0Float3                   ; DWFILL;  /* 0x233 */
    volatile DWORD   V0Float4                   ; DWFILL;  /* 0x234 */
    union {
        volatile DWORD   V0Float5   ;
        volatile DWORD   V0FloatR   ;   };
                                                  DWFILL;  /* 0x235 */
    union {
        volatile DWORD   V0Float6   ;
        volatile DWORD   V0FloatG   ;   };
                                                  DWFILL;  /* 0x236 */
    union {
        volatile DWORD   V0Float7   ;
        volatile DWORD   V0FloatBlue   ;   };
                                                  DWFILL;  /* 0x237 */
    union {
        volatile DWORD   V0Float8   ;
        volatile DWORD   V0FloatAlpha   ;   };
                                                  DWFILL;  /* 0x238 */
    union {
        volatile DWORD   V0Float9   ;
        volatile DWORD   V0FloatF   ;   };
                                                  DWFILL;  /* 0x239 */
    union {
        volatile DWORD   V0FloatA   ;
        volatile DWORD   V0FloatX   ;   };
                                                  DWFILL;  /* 0x23a */
    union {
        volatile DWORD   V0FloatB   ;
        volatile DWORD   V0FloatY   ;   };
                                                  DWFILL;  /* 0x23b */
    union {
        volatile DWORD   V0FloatC   ;
        volatile DWORD   V0FloatZ   ;   };
                                                  DWFILL;  /* 0x23c */
    volatile DWORD   V0FloatW                   ; DWFILL; // [0x23D]
    volatile DWORD   V0FloatPackedColour        ; DWFILL; // [0x23E]
    volatile DWORD   V0FloatPackedSpecularFog   ; DWFILL; // [0x23F]

    // volatile DWORD   Fill30[3*2];

    union {
        volatile DWORD   V1Float0   ;            // Glint Delta
        volatile DWORD   V1FloatS   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x240 */
    union {
        volatile DWORD   V1Float1   ;            // Glint Delta
        volatile DWORD   V1FloatT   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x241 */
    union {
        volatile DWORD   V1Float2   ;            // Glint Delta
        volatile DWORD   V1FloatQ   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x242 */
    volatile DWORD   V1Float3                   ; DWFILL;  /* 0x243 */
    volatile DWORD   V1Float4                   ; DWFILL;  /* 0x244 */
    union {
        volatile DWORD   V1Float5   ;
        volatile DWORD   V1FloatR   ;   };
                                                  DWFILL;  /* 0x245 */
    union {
        volatile DWORD   V1Float6   ;
        volatile DWORD   V1FloatG   ;   };
                                                  DWFILL;  /* 0x246 */
    union {
        volatile DWORD   V1Float7   ;
        volatile DWORD   V1FloatBlue   ;   };
                                                  DWFILL;  /* 0x247 */
    union {
        volatile DWORD   V1Float8   ;
        volatile DWORD   V1FloatAlpha   ;   };
                                                  DWFILL;  /* 0x248 */
    union {
        volatile DWORD   V1Float9   ;
        volatile DWORD   V1FloatF   ;   };
                                                  DWFILL;  /* 0x249 */
    union {
        volatile DWORD   V1FloatA   ;
        volatile DWORD   V1FloatX   ;   };
                                                  DWFILL;  /* 0x24a */
    union {
        volatile DWORD   V1FloatB   ;
        volatile DWORD   V1FloatY   ;   };
                                                  DWFILL;  /* 0x24b */
    union {
        volatile DWORD   V1FloatC   ;
        volatile DWORD   V1FloatZ   ;   };
                                                  DWFILL;  /* 0x24c */
    volatile DWORD   V1FloatW                   ; DWFILL; // [0x24D]
    volatile DWORD   V1FloatPackedColour        ; DWFILL; // [0x24E]
    volatile DWORD   V1FloatPackedSpecularFog   ; DWFILL; // [0x24F]

    // volatile DWORD   Fill31[3*2];

    union {
        volatile DWORD   V2Float0   ;            // Glint Delta
        volatile DWORD   V2FloatS   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x250 */
    union {
        volatile DWORD   V2Float1   ;            // Glint Delta
        volatile DWORD   V2FloatT   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x251 */
    union {
        volatile DWORD   V2Float2   ;            // Glint Delta
        volatile DWORD   V2FloatQ   ;   };        // Permedia3 Delta
                                                  DWFILL;  /* 0x252 */
    volatile DWORD   V2Float3                   ; DWFILL;  /* 0x253 */
    volatile DWORD   V2Float4                   ; DWFILL;  /* 0x254 */
    union {
        volatile DWORD   V2Float5   ;
        volatile DWORD   V2FloatR   ;   };
                                                  DWFILL;  /* 0x255 */
    union {
        volatile DWORD   V2Float6   ;
        volatile DWORD   V2FloatG   ;   };
                                                  DWFILL;  /* 0x256 */
    union {
        volatile DWORD   V2Float7   ;
        volatile DWORD   V2FloatBlue   ;   };
                                                  DWFILL;  /* 0x257 */
    union {
        volatile DWORD   V2Float8   ;
        volatile DWORD   V2FloatAlpha   ;   };
                                                  DWFILL;  /* 0x258 */
    union {
        volatile DWORD   V2Float9   ;
        volatile DWORD   V2FloatF   ;   };
                                                  DWFILL;  /* 0x259 */
    union {
        volatile DWORD   V2FloatA   ;
        volatile DWORD   V2FloatX   ;   };
                                                  DWFILL;  /* 0x25a */
    union {
        volatile DWORD   V2FloatB   ;
        volatile DWORD   V2FloatY   ;   };
                                                  DWFILL;  /* 0x25b */
    union {
        volatile DWORD   V2FloatC   ;
        volatile DWORD   V2FloatZ   ;   };
                                                  DWFILL;  /* 0x25c */
    volatile DWORD   V2FloatW                   ; DWFILL; // [0x25D]
    volatile DWORD   V2FloatPackedColour        ; DWFILL; // [0x25E]
    volatile DWORD   V2FloatPackedSpecularFog   ; DWFILL; // [0x25F]

    // volatile DWORD   Fill32[3*2];

    volatile DWORD   DeltaMode                  ; DWFILL;  /* 0x260 */
    volatile DWORD   DrawTriangle               ; DWFILL;  /* 0x261 */
    volatile DWORD   RepeatTriangle             ; DWFILL;  /* 0x262 */
    volatile DWORD   DrawLine01                 ; DWFILL;  /* 0x263 */
    volatile DWORD   DrawLine10                 ; DWFILL;  /* 0x264 */
    volatile DWORD   RepeatLine                 ; DWFILL;  /* 0x265 */

    DWFILL; DWFILL;                                            // 0x266

    volatile DWORD   ProvokingVertex            ; DWFILL;  // [0x267]
    volatile DWORD   TextureLODScale            ; DWFILL;  // [0x268]
    volatile DWORD   TextureLODScale1           ; DWFILL;  // [0x269]
    volatile DWORD   DeltaControl               ; DWFILL;  // [0x26A]
    volatile DWORD   ProvokingVertexMask        ; DWFILL;  // [0x26B]

    volatile DWORD   Fill33[3*2];
    volatile DWORD   BroadcastMask              ; DWFILL;  /* 0x26F */

    volatile DWORD   Fill34[(0x530-0x270)*2];

    volatile DWORD   QDMAAddress                ; DWFILL;  /* 0x530 */
    volatile DWORD   QDMACount                  ; DWFILL;  /* 0x531 */
    volatile DWORD   Fill35[(0x53f-0x532)*2];
    volatile DWORD   QDMAContinue               ; DWFILL;  /* 0x53f */

    // PERMEDIA 3 Registers - Added Jan99 Mark Cresswell

    volatile DWORD   Fill36[(0x5d0-0x540)*2];

    volatile DWORD   FBDestReadBufferAddr0      ; DWFILL;             // [0x5D0]
    volatile DWORD   FBDestReadBufferAddr1      ; DWFILL;             // [0x5D1]
    volatile DWORD   FBDestReadBufferAddr2      ; DWFILL;             // [0x5D2]
    volatile DWORD   FBDestReadBufferAddr3      ; DWFILL;             // [0x5D3]
    volatile DWORD   FBDestReadBufferOffset0    ; DWFILL;           // [0x5D4]
    volatile DWORD   FBDestReadBufferOffset1    ; DWFILL;           // [0x5D5]
    volatile DWORD   FBDestReadBufferOffset2    ; DWFILL;           // [0x5D6]
    volatile DWORD   FBDestReadBufferOffset3    ; DWFILL;           // [0x5D7]
    volatile DWORD   FBDestReadBufferWidth0     ; DWFILL;            // [0x5D8]
    volatile DWORD   FBDestReadBufferWidth1     ; DWFILL;            // [0x5D9]
    volatile DWORD   FBDestReadBufferWidth2     ; DWFILL;            // [0x5DA]
    volatile DWORD   FBDestReadBufferWidth3     ; DWFILL;            // [0x5DB]
    volatile DWORD   FBDestReadMode               ; DWFILL;           // [0x5DC]
    volatile DWORD   FBDestReadEnables          ; DWFILL;           // [0x5DD]

    volatile DWORD   Fill37[(0x5e0-0x5de)*2];

    volatile DWORD   FBSourceReadMode           ; DWFILL;           // [0x5E0]
    volatile DWORD   FBSourceReadBufferAddr     ; DWFILL;            // [0x5E1]
    volatile DWORD   FBSourceReadBufferOffset   ; DWFILL;              // [0x5E2]
    volatile DWORD   FBSourceReadBufferWidth    ; DWFILL;           // [0x5E3]

    volatile DWORD   Fill38[(0x5e8-0x5e4)*2];

    volatile DWORD   PCIWindowBase0             ; DWFILL;                    // [0x5E8]
    volatile DWORD   PCIWindowBase1             ; DWFILL;                    // [0x5E9]
    volatile DWORD   PCIWindowBase2             ; DWFILL;                    // [0x5EA]
    volatile DWORD   PCIWindowBase3             ; DWFILL;                    // [0x5EB]
    volatile DWORD   PCIWindowBase4             ; DWFILL;                    // [0x5EC]
    volatile DWORD   PCIWindowBase5             ; DWFILL;                    // [0x5ED]
    volatile DWORD   PCIWindowBase6             ; DWFILL;                    // [0x5EE]
    volatile DWORD   PCIWindowBase7             ; DWFILL;                    // [0x5EF]
    volatile DWORD   AlphaSourceColor           ; DWFILL;                  // [0x5F0]
    volatile DWORD   AlphaDestColor             ; DWFILL;                    // [0x5F1]
    volatile DWORD   ChromaPassColor            ; DWFILL;                   // [0x5F2]
    volatile DWORD   ChromaFailColor            ; DWFILL;                   // [0x5F3]
    volatile DWORD   AlphaBlendColorMode        ; DWFILL;               // [0x5F4]
    volatile DWORD   AlphaBlendAlphaMode        ; DWFILL;               // [0x5F5]

    volatile DWORD   Fill39[(0x600-0x5f6)*2];

    volatile DWORD   FBWriteBufferAddr0         ; DWFILL;                // [0x600]
    volatile DWORD   FBWriteBufferAddr1         ; DWFILL;                // [0x601]
    volatile DWORD   FBWriteBufferAddr2         ; DWFILL;                // [0x602]
    volatile DWORD   FBWriteBufferAddr3         ; DWFILL;                // [0x603]
    volatile DWORD   FBWriteBufferOffset0       ; DWFILL;              // [0x604]
    volatile DWORD   FBWriteBufferOffset1       ; DWFILL;              // [0x605]
    volatile DWORD   FBWriteBufferOffset2       ; DWFILL;              // [0x606]
    volatile DWORD   FBWriteBufferOffset3       ; DWFILL;              // [0x607]
    volatile DWORD   FBWriteBufferWidth0        ; DWFILL;               // [0x608]
    volatile DWORD   FBWriteBufferWidth1        ; DWFILL;               // [0x609]
    volatile DWORD   FBWriteBufferWidth2        ; DWFILL;               // [0x60A]
    volatile DWORD   FBWriteBufferWidth3        ; DWFILL;               // [0x60B]
    
    volatile DWORD   Fill40[(0x614-0x60c)*2];

    volatile DWORD   FBBlockColorBack           ; DWFILL;                  // [0x614]
    
    volatile DWORD   Fill41[(0x660-0x615)*2];

    volatile DWORD   TextureCompositeMode       ; DWFILL;              // [0x660]
    volatile DWORD   TextureCompositeColorMode0 ; DWFILL;        // [0x661]
    volatile DWORD   TextureCompositeAlphaMode0 ; DWFILL;        // [0x662]
    volatile DWORD   TextureCompositeColorMode1 ; DWFILL;        // [0x663]
    volatile DWORD   TextureCompositeAlphaMode1 ; DWFILL;        // [0x664]
    volatile DWORD   TextureCompositeFactor0    ; DWFILL;           // [0x665]
    volatile DWORD   TextureCompositeFactor1    ; DWFILL;           // [0x666]
    volatile DWORD   TextureIndexMode0          ; DWFILL;             // [0x667]
    volatile DWORD   TextureIndexMode1          ; DWFILL;             // [0x668]
    volatile DWORD   LodRange0                  ; DWFILL;             // [0x669]
    volatile DWORD   LodRange1                  ; DWFILL;             // [0x66A]
    
    volatile DWORD   Fill42[(0x66f-0x66b)*2];

    volatile DWORD   LUTMode                    ; DWFILL;               // [0x66F]
        
    volatile DWORD   Fill43[(0x680-0x670)*2];

    volatile DWORD   TextureReadMode0           ; DWFILL;                  // [0x680]
    volatile DWORD   TextureReadMode1           ; DWFILL;                  // [0x681]

    volatile DWORD   Fill44[(0x685-0x682)*2];

    volatile DWORD   TextureMapSize             ; DWFILL;               // [0x685]

    volatile DWORD   Fill45[(0x690-0x686)*2];

    volatile DWORD   HeadPhysicalPageAllocation0; DWFILL;               // [0x690]
    volatile DWORD   HeadPhysicalPageAllocation1; DWFILL;               // [0x691]
    volatile DWORD   HeadPhysicalPageAllocation2; DWFILL;               // [0x692]
    volatile DWORD   HeadPhysicalPageAllocation3; DWFILL;               // [0x693]
    volatile DWORD   TailPhysicalPageAllocation0; DWFILL;               // [0x694]
    volatile DWORD   TailPhysicalPageAllocation1; DWFILL;               // [0x695]
    volatile DWORD   TailPhysicalPageAllocation2; DWFILL;               // [0x696]
    volatile DWORD   TailPhysicalPageAllocation3; DWFILL;               // [0x697]

    volatile DWORD   PhysicalPageAllocationTableAddr;   DWFILL;            // [0x698]
    volatile DWORD   BasePageOfWorkingSet;              DWFILL;            // [0x699]
    volatile DWORD   LogicalTexturePageTableAddr;       DWFILL;            // [0x69a]
    volatile DWORD   LogicalTexturePageTableLength;     DWFILL;            // [0x69b]
    volatile DWORD   BasePageOfWorkingSetHost;          DWFILL;            // [0x69c]

    volatile DWORD   Fill46[(0x6A0-0x69d)*2];

    volatile DWORD   LBDestReadMode             ; DWFILL;               // [0x6A0]
    volatile DWORD   LBDestReadEnables          ; DWFILL;                 // [0x6A1]
    volatile DWORD   LBDestReadBufferAddr       ; DWFILL;                  // [0x6A2]
    volatile DWORD   LBDestReadBufferOffset     ; DWFILL;                // [0x6A3]
    volatile DWORD   LBSourceReadMode           ; DWFILL;                  // [0x6A4]
    volatile DWORD   LBSourceReadBufferAddr     ; DWFILL;                // [0x6A5]
    volatile DWORD   LBSourceReadBufferOffset   ; DWFILL;                  // [0x6A6]
    volatile DWORD   GIDMode                    ; DWFILL;               // [0x6A7]
    volatile DWORD   LBWriteBufferAddr          ; DWFILL;                 // [0x6A8]
    volatile DWORD   LBWriteBufferOffset        ; DWFILL;               // [0x6A9]
    volatile DWORD   LBClearDataL               ; DWFILL;               // [0x6AA]
    volatile DWORD   LBClearDataU               ; DWFILL;               // [0x6AB]

    volatile DWORD   Fill47[(0x6c0-0x6ac)*2];

    volatile DWORD   RectanglePosition          ; DWFILL;                 // [0x6C0]

    volatile DWORD   Fill48[(0x6c2-0x6c1)*2];

    volatile DWORD   RenderPatchOffset          ; DWFILL;                 // [0x6C2]

    volatile DWORD   Fill49[(0x6ca-0x6c3)*2];

    volatile DWORD   DownloadTarget             ; DWFILL;               // [0x6CA]

    volatile DWORD   Fill50[(0x6F0-0x6CB)*2];

    volatile DWORD   QDMAMemoryControl          ; DWFILL;               // [0x6F0]



} GLREG, *PGLREG, far *FPGLREG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\glddtk.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: glddtk.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __DDSAMPTK_INCLUDED__ 
#define __DDSAMPTK_INCLUDED__

#pragma warning( disable: 4704)

#define P3R3DX_DLLNAME "p3r3dx.dll"
#define MAX_TEXTURE_FORMAT 35

// The Maximum possible screen widths for the cards
#define MAX_GLINT_PP_WIDTH 8192
#define MAX_PERMEDIA_PP_WIDTH 2048

// For comparing runtime versions
#define DX5_RUNTIME      0x00000500l
#define DX6_RUNTIME      0x00000600l
#define DX7_RUNTIME      0x00000700l

#ifdef  W95_DDRAW

// Videoport needs to live in pThisDisplay, it may
// be on a second display card, etc.
#define MAX_AUTOFLIP_SURFACES 3
typedef struct tagPERMEDIA_VIDEOPORT
{
    // The ID of this video port
    DWORD dwPortID;

    // Permedia VideoPort supports up to
    // 3 autoflipping surfaces
    DWORD dwNumSurfaces;
    
    LPDDRAWI_DDRAWSURFACE_LCL lpSurf[MAX_AUTOFLIP_SURFACES];
    DWORD dwSurfacePointer[MAX_AUTOFLIP_SURFACES];

    // How are the signals setup?
    DWORD dwStreamAFlags;
    DWORD dwStreamBFlags;

    // Height of the VideoBlanking interval
    DWORD dwVBIHeight;

    DWORD dwFieldHeight;
    DWORD dwFieldWidth;

    // Where are we currently reading from?
    DWORD dwCurrentHostFrame;

    // Is the video playing?
    DWORD bActive;

    // A mutex to take ownership of the videoport.
    DWORD dwMutexA;

    // For VP error checking
    DWORD bResetStatus;
    DWORD dwStartLine;
    DWORD dwStartIndex;
    DWORD dwStartLineTime;
    DWORD dwErrorCount;

    // Is the VideoPort active?
    DWORD bCreated;

} PERMEDIA_VIDEOPORT;
#endif  //  W95_DDRAW

// Enumerated type for the style of buffer that is being used.
typedef enum tageBufferType
{
    COMMAND_BUFFER = 0,
    VERTEX_BUFFER = 1,
    FORCE_DWORD_BUFFERTYPE_SIZE = 0xFFFFFFFF
} eBufferType;

typedef struct tagDRVRECT
{
#ifndef WIN32
    DWORD left;
    DWORD top;
    DWORD right;
    DWORD bottom;
#else
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
#endif
} DRVRECT;

typedef struct tagOVERLAYDATA
{
    DRVRECT rcSrc;
    DRVRECT rcDest;

#ifndef WIN32
    DWORD dwOverlayPointer;
#else
    FLATPTR pCurrentOverlay;
#endif  

    DWORD dwCurrentVideoBuffer;
    DWORD dwVisibleOverlays;

} OVERLAYDATA;

typedef struct tagP3VERTEXBUFFERINFO
{
    DWORD dwSequenceID;
    DWORD bInUse;
    eBufferType BufferType;
    DWORD dwSize;
    struct tagP3VERTEXBUFFERINFO* pNext;
    struct tagP3VERTEXBUFFERINFO* pPrev;
} P3_VERTEXBUFFERINFO;

typedef struct
{
    // Where we flipped from
    FLATPTR fpFlipFrom;

    // An ID for the flip
    DWORD   dwFlipID;

} FLIPRECORD;
typedef FLIPRECORD FAR *LPFLIPRECORD;

typedef struct _GlintDMABuffer
{
    DWORD       dwBuffSize;
    DWORD       dwBuffPhys;
    ULONG_PTR   dwBuffVirt;
    DWORD       dwSubBuff;
} GLDMABUFF, *LPGLDMABUFF;

// Function prototype to fire off a DMA operation
typedef DWORD (WINAPI *__StartDMA)(struct tagThunkedData* pThisDisplay, 
                                   DWORD dwContext, DWORD dwSize, 
                                   DWORD dwPhys, ULONG_PTR dwVirt, 
                                   DWORD dwEvent);

typedef struct tagThunkedData
{
    ULONG_PTR control;
    DWORD ramdac;
    DWORD lpMMReg;

    // The Mini VDD's DevNode
    DWORD dwDevNode;

    // Virt. Address of the start of screen memory
    DWORD dwScreenFlatAddr;

    // Virt. Address of the start of LB memory
    DWORD dwLocalBuffer;

    // Screen settings
    DWORD dwScreenWidth;
    DWORD dwScreenHeight;
    DWORD cxMemory;
    DWORD cyMemory;

    // A lookup table for all the Partial Products
    DWORD PPCodes[(MAX_GLINT_PP_WIDTH / 32) + 1];    

    // Memory to remove from the card (for debugging)
    DWORD dwSubMemory;

    // Virtual address of start of screen
    DWORD dwScreenStart;
    DWORD bPixShift;
    DWORD bBppShift;
    DWORD dwBppMask;

    // Reset flag
    DWORD bResetMode;            // Has the mode been changed?
    DWORD bStartOfDay;            // Has the driver just been initialised?

    DWORD bVFWEnabled;            // Is Video For windows currently enabled?

    DWORD bDDHeapManager;        // Using the Linear Heap manager?

    DWORD dwSetupThisDisplay;    // Has this display been intialised (a ref count)?

    DWORD dwBackBufferCount;    // How many back buffers have we handed out on TX at 640x400?
    DWORD EntriesLeft;            // Number of entries left in FIFO (for debugging)
    DWORD DMAEntriesLeft;        // Number of entries left in DMA buffer (for debugging)

    DWORD bFlippedSurface;                // Has this card had a page flip?
    DWORD ModeChangeCount;

    // Current pixel format of display
    DDPIXELFORMAT   ddpfDisplay;

    // Shared Display driver memory pointer
    LPGLINTINFO     pGLInfo;

#ifndef WIN32
    DWORD pGlint;
#else
    // Pointer to the actual glint registers.
    FPGLREG         pGlint;
#endif

    // Is this card capable of AGP texturing?
    DWORD bCanAGP;

    // Flag to tell stretchblits whether to filter. 
    DWORD bFilterStretches;

    // Overlay data
    // This data has to be available at any times, because we are emulating it.
    // Only one overlay at a time supported

    DWORD   bOverlayVisible;                // TRUE if the overlay is visible.
    DWORD   OverlayDstRectL;
    DWORD   OverlayDstRectR;
    DWORD   OverlayDstRectT;
    DWORD   OverlayDstRectB;                // where the overlay is on screen
    DWORD   OverlaySrcRectL;
    DWORD   OverlaySrcRectR;
    DWORD   OverlaySrcRectT;
    DWORD   OverlaySrcRectB;                // which bit of the overlay is visible
    ULONG_PTR OverlayDstSurfLcl;                // the surface overlaid (usually the primary)
    ULONG_PTR OverlaySrcSurfLcl;                // the overlay surface
    DWORD   OverlayDstColourKey;            // the overlaid surface's written-to colour key
    DWORD   OverlaySrcColourKey;            // the overlay's transparent colour key
    ULONG_PTR OverlayClipRgnMem;                // buffer to hold a temporary clip region
    DWORD   OverlayClipRgnMemSize;            // ...the size of the buffer
    DWORD   OverlayUpdateCountdown;            // how many flips/unlocks before an update is done.
    DWORD   bOverlayFlippedThisVbl;            // TRUE if overlay was flipped this VBL.
    DWORD   bOverlayUpdatedThisVbl;            // TRUE if overlay was updated (not including flips) this VBL.
    struct {
        ULONG_PTR   VidMem;
        DWORD       Pitch;
    } OverlayTempSurf;                        // The temporary video buffer used by the overlay.

    OVERLAYDATA P3Overlay;
    DWORD   dwOverlayFiltering;                // TRUE if the overlay is filtering.
    DWORD   bOverlayPixelDouble;            // TRUE if the screen is pixel-doubled.

#if W95_DDRAW
    // Colour control variables.
    DWORD   ColConBrightness;                // Brightness 0->10000, default 0 (ish)
    DWORD   ColConContrast;                    // Contrast 0->20000, default 10000
    DWORD   ColConGamma;                    // Gamma 1->500, default 100
#endif // W95_DDRAW

#if DX7_VIDMEM_VB
    // DrawPrim temporary index buffer.
    ULONG_PTR   DrawPrimIndexBufferMem;            // Pointer to the buffer.
    DWORD       DrawPrimIndexBufferMemSize;        // Size of the buffer.
    // DrawPrim temporary vertex buffer.
    ULONG_PTR   DrawPrimVertexBufferMem;        // Pointer to the buffer.
    DWORD       DrawPrimVertexBufferMemSize;    // Size of the buffer.
#endif // DX7_VIDMEM_VB

    // Current RenderID.
    DWORD   dwRenderID;
    // TRUE if the chip's render ID is valid.
    DWORD   bRenderIDValid;
    // The RenderIDs of the last two Flips to be
    // put into the DMA/FIFO/pipeline. See Flip32 for further info.
    DWORD   dwLastFlipRenderID;
    DWORD   dwLastFlipRenderID2;

    // DirectDraw DMA variables
    __StartDMA      StartDMA;                        // Pointer to the StartDMA function
    DWORD           PartitionSize;
    DWORD           BufferLocked;
    GLDMABUFF       DMAInfo;
    DWORD           b2D_FIFOS;                // DDRAW using FIFO's?
    
    // These buffers hold counts that the driver is using
    // to keep track of operations in the chip

#ifdef WIN32
    P3_VERTEXBUFFERINFO* pRootCommandBuffer;
    P3_VERTEXBUFFERINFO* pRootVertexBuffer;
#else
    DWORD           pRootCommandBuffer;
    DWORD           pRootVertexBuffer;
#endif

    DWORD           dwCurrentSequenceID;

    // HINSTANCE of p3r3dx.dll
    HINSTANCE       hInstance;

    // DirectDraw callbacks
    DDHAL_DDCALLBACKS               DDHALCallbacks;
    DDHAL_DDSURFACECALLBACKS        DDSurfCallbacks;

    // D3D Callbacks
    ULONG_PTR                       lpD3DGlobalDriverData;
    ULONG_PTR                       lpD3DHALCallbacks;
    ULONG_PTR                       lpD3DBufCallbacks;
#if W95_DDRAW
    DDHAL_DDEXEBUFCALLBACKS         DDExeBufCallbacks;
#endif

    DWORD dwNumTextureFormats;
    DDSURFACEDESC TextureFormats[MAX_TEXTURE_FORMAT];

    DWORD dwDXVersion;

    // These have to live here, as we could be running on 2 different cards
    // on two different displays...!
    DWORD pD3DDriverData16;
    DWORD pD3DHALCallbacks16;
    DWORD pD3DHALExecuteCallbacks16;
    
    ULONG_PTR pD3DDriverData32;
    ULONG_PTR pD3DHALCallbacks32;
    ULONG_PTR pD3DHALExecuteCallbacks32;

    // A linear allocator block for the local video heap
    LinearAllocatorInfo LocalVideoHeap0Info;
    LinearAllocatorInfo CachedCommandHeapInfo;
    LinearAllocatorInfo CachedVertexHeapInfo;

    DWORD dwGARTLin;                // Linear address of Base of AGP Memory
    DWORD dwGARTDev;                // High Linear address of Base of AGP Memory

    DWORD dwGARTLinBase;            // The base address passed into the updatenonlocalvidmem call
    DWORD dwGARTDevBase;            // The base address passsed in
#if W95_DDRAW
    // The Videoport for this display
    PERMEDIA_VIDEOPORT  VidPort;

#endif

#if WNT_DDRAW 
    
#if (_WIN32_WINNT >= 0x500)
    PFND3DPARSEUNKNOWNCOMMAND pD3DParseUnknownCommand;
#else
    DWORD pD3DParseUnknownCommand;
#endif
#else // WNT_DDRAW
    // DirectX 6 Support
#ifdef WIN32
    //pointer to vertex buffer unknown command processing function
    PFND3DPARSEUNKNOWNCOMMAND pD3DParseUnknownCommand; 
#else
    DWORD pD3DParseUnknownCommand; // ? Safe ?
#endif // WIN32
#endif // WNT_DDRAW

#if WNT_DDRAW
    PPDEV   ppdev;                                // Pointer to the NT globals
    volatile DWORD * VBlankStatusPtr;            // Pointer to VBlank status word (shared with miniport)
    volatile DWORD * bOverlayEnabled;            // Pointer to overlay enabled flag (shared with miniport)
    volatile DWORD * bVBLANKUpdateOverlay;        // Pointer to overlay update flag
    volatile DWORD * VBLANKUpdateOverlayWidth;    // Pointer to overlay width (shared with miniport)
    volatile DWORD * VBLANKUpdateOverlayHeight;    // Pointer to overlay height (shared with miniport)

#endif  // WNT_DDRAW

#ifdef WIN32
    HashTable* pDirectDrawLocalsHashTable;
    HashTable* pMocompHashTable;
#else
    DWORD pDirectDrawLocalsHashTable;
    DWORD pMocompHashTable;
#endif

#ifdef WNT_DDRAW
    DWORD       pAGPHeap;
#else
#ifdef WIN32
    // Pointer to AGP heap, used for logical texturing 
    LPVIDMEM    pAGPHeap;
#endif
#endif

    FLIPRECORD flipRecord;

    DWORD dwFlushLogfile;

    // HAL info structure. THIS MUST BE THE LAST THING IN THIS STRUCTURE
    DDHALINFO       ddhi32;

} P3_THUNKEDDATA;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\gtag.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: gtag.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef glinttag_h
#define glinttag_h

enum __GlintTagList {
    __GlintTagStartXDom = 0,                // 0x000
    __GlintTagdXDom,                        // 0x001
    __GlintTagStartXSub,                    // 0x002
    __GlintTagdXSub,                        // 0x003
    __GlintTagStartY,                       // 0x004
    __GlintTagdY,                           // 0x005
    __GlintTagCount,                        // 0x006
    __GlintTagRender,                       // 0x007
    __GlintTagContinueNewLine,              // 0x008
    __GlintTagContinueNewDom,               // 0x009
    __GlintTagContinueNewSub,               // 0x00A
    __GlintTagContinue,                     // 0x00B
    __GlintTagFlushSpan,                    // 0x00C
    __GlintTagBitMaskPattern,               // 0x00D
    __GlintTagReserved00e,
    __GlintTagReserved00f,
    __GlintTagPointTable0,                  // 0x010
    __GlintTagPointTable1,                  // 0x011
    __GlintTagPointTable2,                  // 0x012
    __GlintTagPointTable3,                  // 0x013
    __GlintTagRasterizerMode,               // 0x014
    __GlintTagYLimits,                      // 0x015
    __GlintTagScanlineOwnership,            // 0x016
    __GlintTagWaitForCompletion,            // 0x017
    __GlintTagPixelSize,                    // 0x018
    __PermediaTagXLimits,                   // 0x019
    __PermediaTagRectangleOrigin,           // 0x01A
    __PermediaTagRectangleSize,             // 0x01B
    __GlintTagReserved01c,
    __GlintTagReserved01d,
    __GlintTagReserved01e,
    __GlintTagReserved01f,
    __GlintTagCoverageValue,                // 0x020
    __GlintTagPrepareToRender,              // 0x021
    __GlintTagActiveStepX,                  // 0x022
    __GlintTagPassiveStepX,                 // 0x023
    __GlintTagActiveStepYDomEdge,           // 0x024
    __GlintTagPassiveStepYDomEdge,          // 0x025
    __GlintTagFastBlockLimits,              // 0x026
    __GlintTagFastBlockFill,                // 0x027
    __GlintTagSubPixelCorrection,           // 0x028
    __GlintTagReserved029,
    __PermediaTagPackedDataLimits,          // 0x02A
    __GlintTagReserved02b,
    __GlintTagReserved02c,
    __GlintTagReserved02d,
    __GlintTagReserved02e,
    __GlintTagReserved02f,
    __GlintTagScissorMode,                  // 0x030
    __GlintTagScissorMinXY,                 // 0x031
    __GlintTagScissorMaxXY,                 // 0x032
    __GlintTagScreenSize,                   // 0x033
    __GlintTagAreaStippleMode,              // 0x034
    __GlintTagLineStippleMode,              // 0x035
    __GlintTagLoadLineStippleCounters,      // 0x036
    __GlintTagUpdateLineStippleCounters,    // 0x037
    __GlintTagSaveLineStippleCounters,      // 0x038
    __GlintTagWindowOrigin,                 // 0x039
    __GlintTagReserved03a,
    __GlintTagReserved03b,
    __GlintTagReserved03c,
    __GlintTagReserved03d,
    __GlintTagReserved03e,
    __GlintTagReserved03f,
    __GlintTagAreaStipplePattern0,          // 0x040
    __GlintTagAreaStipplePattern1,          // 0x041
    __GlintTagAreaStipplePattern2,          // 0x042
    __GlintTagAreaStipplePattern3,          // 0x043
    __GlintTagAreaStipplePattern4,          // 0x044
    __GlintTagAreaStipplePattern5,          // 0x045
    __GlintTagAreaStipplePattern6,          // 0x046
    __GlintTagAreaStipplePattern7,          // 0x047
    __GlintTagAreaStipplePattern8,          // 0x048
    __GlintTagAreaStipplePattern9,          // 0x049
    __GlintTagAreaStipplePattern10,         // 0x04A
    __GlintTagAreaStipplePattern11,         // 0x04B
    __GlintTagAreaStipplePattern12,         // 0x04C
    __GlintTagAreaStipplePattern13,         // 0x04D
    __GlintTagAreaStipplePattern14,         // 0x04E
    __GlintTagAreaStipplePattern15,         // 0x04F
    __GlintTagAreaStipplePattern16,         // 0x050
    __GlintTagAreaStipplePattern17,         // 0x051
    __GlintTagAreaStipplePattern18,         // 0x052
    __GlintTagAreaStipplePattern19,         // 0x053
    __GlintTagAreaStipplePattern20,         // 0x054
    __GlintTagAreaStipplePattern21,         // 0x055
    __GlintTagAreaStipplePattern22,         // 0x056
    __GlintTagAreaStipplePattern23,         // 0x057
    __GlintTagAreaStipplePattern24,         // 0x058
    __GlintTagAreaStipplePattern25,         // 0x059
    __GlintTagAreaStipplePattern26,         // 0x05A
    __GlintTagAreaStipplePattern27,         // 0x05B
    __GlintTagAreaStipplePattern28,         // 0x05C
    __GlintTagAreaStipplePattern29,         // 0x05D
    __GlintTagAreaStipplePattern30,         // 0x05E
    __GlintTagAreaStipplePattern31,         // 0x05F
    __GlintTagFillFBWriteBufferAddr0,       // 0x060
    __GlintTagFillFBSourceReadBufferAddr,   // 0x061
    __GlintTagFillFBDestReadBufferAddr0,    // 0x062
    __GlintTagFillScissorMinXY,             // 0x063
    __GlintTagFillScissorMaxXY,             // 0x064
    __GlintTagFillForegroundColor0,         // 0x065
    __GlintTagFillBackgroundColor,          // 0x066
    __GlintTagFillConfig2D0,                // 0x067
    __GlintTagFillFBSourceReadBufferOffset, // 0x068
    __GlintTagFillRectanglePosition,        // 0x069
    __GlintTagFillRender2D,                 // 0x06A
    __GlintTagFillForegroundColor1,         // 0x06B
    __GlintTagFillConfig2D1,                // 0x06C
    __GlintTagFillGlyphPosition,            // 0x06D
    __GlintTagReserved06e,
    __GlintTagReserved06f,
    __GlintTagTextureAddressMode,           // 0x070
    __GlintTagSStart,                       // 0x071
    __GlintTagdSdx,                         // 0x072
    __GlintTagdSdyDom,                      // 0x073
    __GlintTagTStart,                       // 0x074
    __GlintTagdTdx,                         // 0x075
    __GlintTagdTdyDom,                      // 0x076
    __GlintTagQStart,                       // 0x077
    __GlintTagdQdx,                         // 0x078
    __GlintTagdQdyDom,                      // 0x079
    __GlintTagLOD,                          // 0x07A 
    __GlintTagdSdy,                         // 0x07B 
    __GlintTagdTdy,                         // 0x07C 
    __GlintTagdQdy,                         // 0x07D 
    __GlintTagReserved07e,
    __GlintTagReserved07f,
    __GlintTagReserved080,                  // 0x080
    __GlintTagReserved081,                  // 0x081
    __GlintTagTexelCoordU,                  // 0x082
    __GlintTagTexelCoordV,                  // 0x083
    __GlintTagReserved084,                  // 0x084
    __GlintTagReserved085,                  // 0x085
    __GlintTagReserved086,                  // 0x086
    __GlintTagReserved087,                  // 0x087
    __GlintTagReserved088,                  // 0x088
    __GlintTagLOD1,                         // 0x089
    __GlintTagTextureLODBiasS,              // 0x08A
    __GlintTagTextureLODBiasT,              // 0x08B
    __GlintTagReserved08c,
    __GlintTagReserved08d,
    __GlintTagReserved08e,
    __GlintTagReserved08f,
    __GlintTagTextureReadMode,              // 0x090
    __GlintTagTextureFormat,                // 0x091
    __GlintTagTextureCacheControl,          // 0x092
    __GlintTagReserved093,
    __GlintTagReserved094,
    __GlintTagBorderColor,                  // 0x095
    __GlintTagReserved096,
    __GlintTagReserved097,
    __GlintTagTexelLUTIndex,                // 0x098
    __GlintTagTexelLUTData,                 // 0x099
    __GlintTagTexelLUTAddress,              // 0x09A
    __GlintTagTexelLUTTransfer,             // 0x09B
    __GlintTagTextureFilterMode,            // 0x09C
    __GlintTagTextureChromaUpper,           // 0x09D
    __GlintTagTextureChromaLower,           // 0x09E
    __GlintTagBorderColor1,                 // 0x09F
    __GlintTagTextureBaseAddress,           // 0x0A0
    __GlintTagTextureBaseAddressLR,         // 0x0A1
    __GlintTagTextureBaseAddress2,          // 0x0A2
    __GlintTagTextureBaseAddress3,          // 0x0A3
    __GlintTagTextureBaseAddress4,          // 0x0A4
    __GlintTagTextureBaseAddress5,          // 0x0A5
    __GlintTagTextureBaseAddress6,          // 0x0A6
    __GlintTagTextureBaseAddress7,          // 0x0A7
    __GlintTagTextureBaseAddress8,          // 0x0A8
    __GlintTagTextureBaseAddress9,          // 0x0A9
    __GlintTagTextureBaseAddress10,         // 0x0AA
    __GlintTagTextureBaseAddress11,         // 0x0AB
    __GlintTagTextureBaseAddress12,         // 0x0AC
    __GlintTagTextureBaseAddress13,         // 0x0AD
    __GlintTagTextureBaseAddress14,         // 0x0AE
    __GlintTagTextureBaseAddress15,         // 0x0AF
    __PermediaTagTextureBaseAddress,        // 0x0B0
    __PermediaTagTextureMapFormat,          // 0x0B1
    __PermediaTagTextureDataFormat,         // 0x0B2
    __GlintTagReserved0b3,
    __GlintTagReserved0b4,
    __GlintTagReserved0b5,
    __GlintTagReserved0b6,
    __GlintTagReserved0b7,
    __GlintTagReserved0b8,
    __GlintTagReserved0b9,
    __GlintTagReserved0ba,
    __GlintTagReserved0bb,
    __GlintTagReserved0bc,
    __GlintTagReserved0bd,
    __GlintTagReserved0be,
    __GlintTagReserved0bf,
    __GlintTagTexel0,                       // 0x0C0
    __GlintTagTexel1,                       // 0x0C1
    __GlintTagTexel2,                       // 0x0C2
    __GlintTagTexel3,                       // 0x0C3
    __GlintTagTexel4,                       // 0x0C4
    __GlintTagTexel5,                       // 0x0C5
    __GlintTagTexel6,                       // 0x0C6
    __GlintTagTexel7,                       // 0x0C7
    __GlintTagInterp0,                      // 0x0C8
    __GlintTagInterp1,                      // 0x0C9
    __GlintTagInterp2,                      // 0x0CA
    __GlintTagInterp3,                      // 0x0CB
    __GlintTagInterp4,                      // 0x0CC
    __GlintTagTextureFilter,                // 0x0CD
    __PermediaTagTextureReadMode,           // 0x0CE
    __PermediaTagTexelLUTMode,              // 0x0CF
    __GlintTagTextureColorMode,             // 0x0D0
    __GlintTagTextureEnvColor,              // 0x0D1
    __GlintTagFogMode,                      // 0x0D2
    __GlintTagFogColor,                     // 0x0D3
    __GlintTagFStart,                       // 0x0D4
    __GlintTagdFdx,                         // 0x0D5
    __GlintTagdFdyDom,                      // 0x0D6
    __GlintTagZFogBias,                     // 0x0D7
    __GlintTagReserved0d8,
    __GlintTagKsStart,                      // 0x0D9
    __GlintTagdKsdx,                        // 0x0DA
    __GlintTagdKsdyDom,                     // 0x0DB
    __GlintTagKdStart,                      // 0x0DC
    __GlintTagdKddx,                        // 0x0DD
    __GlintTagdKddyDom,                     // 0x0DE
    __GlintTagReserved0df,
    __GlintTagTextTGlyphAddr0,              // 0x0E0
    __GlintTagTextRender2DGlyph0,           // 0x0E1
    __GlintTagTextTGlyphAddr1,              // 0x0E2
    __GlintTagTextRender2DGlyph1,           // 0x0E3
    __GlintTagTextTGlyphAddr2,              // 0x0E4
    __GlintTagTextRender2DGlyph2,           // 0x0E5
    __GlintTagTextTGlyphAddr3,              // 0x0E6
    __GlintTagTextRender2DGlyph3,           // 0x0E7
    __GlintTagTextTGlyphAddr4,              // 0x0E8
    __GlintTagTextRender2DGlyph4,           // 0x0E9
    __GlintTagTextTGlyphAddr5,              // 0x0EA
    __GlintTagTextRender2DGlyph5,           // 0x0EB
    __GlintTagTextTGlyphAddr6,              // 0x0EC
    __GlintTagTextRender2DGlyph6,           // 0x0ED
    __GlintTagTextTGlyphAddr7,              // 0x0EE
    __GlintTagTextRender2DGlyph7,           // 0x0EF
    __GlintTagRStart,                       // 0x0F0
    __GlintTagdRdx,                         // 0x0F1
    __GlintTagdRdyDom,                      // 0x0F2
    __GlintTagGStart,                       // 0x0F3
    __GlintTagdGdx,                         // 0x0F4
    __GlintTagdGdyDom,                      // 0x0F5
    __GlintTagBStart,                       // 0x0F6
    __GlintTagdBdx,                         // 0x0F7
    __GlintTagdBdyDom,                      // 0x0F8
    __GlintTagAStart,                       // 0x0F9
    __GlintTagdAdx,                         // 0x0FA
    __GlintTagdAdyDom,                      // 0x0FB
    __GlintTagColorDDAMode,                 // 0x0FC
    __GlintTagConstantColor,                // 0x0FD
    __GlintTagColor,                        // 0x0FE
    __GlintTagReserved0ff,
    __GlintTagAlphaTestMode,                // 0x100
    __GlintTagAntialiasMode,                // 0x101
    __GlintTagAlphaBlendMode,               // 0x102
    __GlintTagDitherMode,                   // 0x103
    __GlintTagFBSoftwareWriteMask,          // 0x104
    __GlintTagLogicalOpMode,                // 0x105
    __GlintTagFBWriteData,                  // 0x106
    __GlintTagMXSynchronize,                // 0x107
    __GlintTagRouterMode,                   // 0x108
    __GlintTagReserved109,
    __GlintTagReserved101,
    __GlintTagReserved10b,
    __GlintTagReserved10c,
    __GlintTagReserved10d,
    __GlintTagReserved10e,
    __GlintTagReserved10f,
    __GlintTagLBReadMode,                   // 0x110
    __GlintTagLBReadFormat,                 // 0x111
    __GlintTagLBSourceOffset,               // 0x112
    __GlintTagReserved113,
    __GlintTagLBSourceData,                 // 0x114
    __GlintTagLBStencil,                    // 0x115
    __GlintTagLBDepth,                      // 0x116
    __GlintTagLBWindowBase,                 // 0x117
    __GlintTagLBWriteMode,                  // 0x118
    __GlintTagLBWriteFormat,                // 0x119
    __GlintTagReserved11a,
    __GlintTagReserved11b,
    __GlintTagReserved11c,
    __GlintTagTextureData,                  // 0x11D
    __GlintTagTextureDownloadOffset,        // 0x11E
    __GlintTagLBWindowOffset,               // 0x11F
    __GlintTagHostInID,                     // 0x120
    __GlintTagSecurity,                     // 0x121
    __GlintTagFlushWriteCombining,          // 0x122
    __GlintTagHostInState,                  // 0x123
    __GlintTagReserved124,
    __GlintTagReserved125,
    __GlintTagReserved126,
    __GlintTagHostInDMAAddress,             // 0x127
    __GlintTagHostInState2,                 // 0x128
    __GlintTagReserved129,
    __GlintTagReserved12a,
    __GlintTagReserved12b,
    __GlintTagReserved12c,
    __GlintTagReserved12d,
    __GlintTagReserved12e,
    __GlintTagVertexRename,                 // 0x12F
    __GlintTagWindow,                       // 0x130
    __GlintTagStencilMode,                  // 0x131
    __GlintTagStencilData,                  // 0x132
    __GlintTagStencil,                      // 0x133
    __GlintTagDepthMode,                    // 0x134
    __GlintTagDepth,                        // 0x135
    __GlintTagZStartU,                      // 0x136
    __GlintTagZStartL,                      // 0x137
    __GlintTagdZdxU,                        // 0x138
    __GlintTagdZdxL,                        // 0x139
    __GlintTagdZdyDomU,                     // 0x13A
    __GlintTagdZdyDomL,                     // 0x13B
    __GlintTagFastClearDepth,               // 0x13C
    __GlintTagLBCancelWrite,                // 0x13D
    __GlintTagReserved13e,
    __GlintTagReserved13f,
    __GlintTagReserved140,
    __GlintTagReserved141,
    __GlintTagReserved142,
    __GlintTagReserved143,
    __GlintTagReserved144,
    __GlintTagReserved145,
    __GlintTagReserved146,
    __GlintTagReserved147,
    __GlintTagReserved148,
    __GlintTagReserved149,
    __GlintTagReserved14a,
    __GlintTagReserved14b,
    __GlintTagReserved14c,
    __GlintTagReserved14d,
    __GlintTagReserved14e,
    __GlintTagReserved14f,
    __GlintTagFBReadMode,                   // 0x150
    __GlintTagFBSourceOffset,               // 0x151
    __GlintTagFBPixelOffset,                // 0x152
    __GlintTagFBColor,                      // 0x153
    __GlintTagFBData,                       // 0x154
    __GlintTagFBSourceData,                 // 0x155
    __GlintTagFBWindowBase,                 // 0x156
    __GlintTagFBWriteMode,                  // 0x157
    __GlintTagFBHardwareWriteMask,          // 0x158
    __GlintTagFBBlockColor,                 // 0x159
    __PermediaTagFBReadPixel,               // 0x15A
    __PermediaTagFBWritePixel,              // 0x15B
    __GlintTagReserved15c,
    __PermediaTagFBWriteConfig,             // 0x15D
    __GlintTagReserved15e,
    __GlintTagPatternRAMMode,               // 0x15F
    __GlintTagPatternRAMData0,              // 0x160
    __GlintTagPatternRAMData1,              // 0x161
    __GlintTagPatternRAMData2,              // 0x162
    __GlintTagPatternRAMData3,              // 0x163
    __GlintTagPatternRAMData4,              // 0x164
    __GlintTagPatternRAMData5,              // 0x165
    __GlintTagPatternRAMData6,              // 0x166
    __GlintTagPatternRAMData7,              // 0x167
    __GlintTagPatternRAMData8,              // 0x168
    __GlintTagPatternRAMData9,              // 0x169
    __GlintTagPatternRAMData10,             // 0x16A
    __GlintTagPatternRAMData11,             // 0x16B
    __GlintTagPatternRAMData12,             // 0x16C
    __GlintTagPatternRAMData13,             // 0x16D
    __GlintTagPatternRAMData14,             // 0x16E
    __GlintTagPatternRAMData15,             // 0x16F
    __GlintTagPatternRAMData16,             // 0x170
    __GlintTagPatternRAMData17,             // 0x171
    __GlintTagPatternRAMData18,             // 0x172
    __GlintTagPatternRAMData19,             // 0x173
    __GlintTagPatternRAMData20,             // 0x174
    __GlintTagPatternRAMData21,             // 0x175
    __GlintTagPatternRAMData22,             // 0x176
    __GlintTagPatternRAMData23,             // 0x177
    __GlintTagPatternRAMData24,             // 0x178
    __GlintTagPatternRAMData25,             // 0x179
    __GlintTagPatternRAMData26,             // 0x17A
    __GlintTagPatternRAMData27,             // 0x17B
    __GlintTagPatternRAMData28,             // 0x17C
    __GlintTagPatternRAMData29,             // 0x17D
    __GlintTagPatternRAMData30,             // 0x17E
    __GlintTagPatternRAMData31,             // 0x17F
    __GlintTagFilterMode,                   // 0x180
    __GlintTagStatisticMode,                // 0x181
    __GlintTagMinRegion,                    // 0x182
    __GlintTagMaxRegion,                    // 0x183
    __GlintTagResetPickResult,              // 0x184
    __GlintTagMinHitRegion,                 // 0x185
    __GlintTagMaxHitRegion,                 // 0x186
    __GlintTagPickResult,                   // 0x187
    __GlintTagSync,                         // 0x188
    __GlintTagRLEMask,                      // 0x189
    __GlintTagReserved18a,
    __GlintTagFBBlockColorBackU,            // 0x18B
    __GlintTagFBBlockColorBackL,            // 0x18C
    __GlintTagFBBlockColorU,                // 0x18D
    __GlintTagFBBlockColorL,                // 0x18E
    __GlintTagSuspendUntilFrameBlank,       // 0x18F
    __GlintTagKsRStart,                     // 0x190
    __GlintTagdKsRdx,                       // 0x191
    __GlintTagdKsRdyDom,                    // 0x192
    __GlintTagKsGStart,                     // 0x193
    __GlintTagdKsGdx,                       // 0x194
    __GlintTagdKsGdyDom,                    // 0x195
    __GlintTagKsBStart,                     // 0x196
    __GlintTagdKsBdx,                       // 0x197
    __GlintTagdKsBdyDom,                    // 0x198
    __GlintTagReserved199,
    __GlintTagReserved19a,
    __GlintTagReserved19b,
    __GlintTagReserved19c,
    __GlintTagReserved19d,
    __GlintTagReserved19e,
    __GlintTagReserved19f,
    __GlintTagKdRStart,                     // 0x1A0
    __GlintTagdKdRdx,                       // 0x1A1
    __GlintTagdKdRdyDom,                    // 0x1A2
    __GlintTagKdGStart,                     // 0x1A3
    __GlintTagdKdGdx,                       // 0x1A4
    __GlintTagdKdGdyDom,                    // 0x1A5
    __GlintTagKdBStart,                     // 0x1A6
    __GlintTagdKdBdx,                       // 0x1A7
    __GlintTagdKdBdyDom,                    // 0x1A8
    __GlintTagReserved1a9,
    __GlintTagReserved1aa,
    __GlintTagReserved1ab,
    __GlintTagReserved1ac,
    __GlintTagReserved1ad,
    __GlintTagReserved1ae,
    __GlintTagReserved1af,
    __PermediaTagFBSourceBase,              // 0x1B0
    __PermediaTagFBSourceDelta,             // 0x1B1
    __PermediaTagConfig,                    // 0x1B2
    __GlintTagReserved1b3,
    __GlintTagReserved1b4,
    __GlintTagReserved1b5,
    __GlintTagReserved1b6,
    __GlintTagReserved1b7,
    __GlintTagContextDump,                  // 0x1B8
    __GlintTagContextRestore,               // 0x1B9
    __GlintTagContextData,                  // 0x1BA
    __GlintTagReserved1bb,
    __GlintTagReserved1bc,
    __GlintTagReserved1bd,
    __GlintTagReserved1be,
    __GlintTagReserved1bf,
    __GlintTagReserved1c0,
    __GlintTagReserved1c1,
    __GlintTagReserved1c2,
    __GlintTagReserved1c3,
    __GlintTagReserved1c4,
    __GlintTagReserved1c5,
    __GlintTagReserved1c6,
    __GlintTagReserved1c7,
    __GlintTagReserved1c8,
    __GlintTagReserved1c9,
    __GlintTagReserved1ca,
    __GlintTagReserved1cb,
    __GlintTagReserved1cc,
    __GlintTagReserved1cd,
    __GlintTagReserved1ce,
    __GlintTagReserved1cf,
    __GlintTagTexelLUT0,                    // 0x1D0
    __GlintTagTexelLUT1,                    // 0x1D1
    __GlintTagTexelLUT2,                    // 0x1D2
    __GlintTagTexelLUT3,                    // 0x1D3
    __GlintTagTexelLUT4,                    // 0x1D4
    __GlintTagTexelLUT5,                    // 0x1D5
    __GlintTagTexelLUT6,                    // 0x1D6
    __GlintTagTexelLUT7,                    // 0x1D7
    __GlintTagTexelLUT8,                    // 0x1D8
    __GlintTagTexelLUT9,                    // 0x1D9
    __GlintTagTexelLUT10,                   // 0x1DA
    __GlintTagTexelLUT11,                   // 0x1DB
    __GlintTagTexelLUT12,                   // 0x1DC
    __GlintTagTexelLUT13,                   // 0x1DD
    __GlintTagTexelLUT14,                   // 0x1DE
    __GlintTagTexelLUT15,                   // 0x1DF
    __PermediaTagYUVMode,                   // 0x1E0
    __PermediaTagChromaUpperBound,          // 0x1E1
    __PermediaTagChromaLowerBound,          // 0x1E2
    __GlintTagChromaTestMode,               // 0x1E3
    __GlintTagReserved1e4,
    __GlintTagReserved1e5,
    __GlintTagReserved1e6,
    __GlintTagReserved1e7,
    __GlintTagReserved1e8,
    __GlintTagReserved1e9,
    __GlintTagReserved1ea,
    __GlintTagReserved1eb,
    __GlintTagReserved1ec,
    __GlintTagReserved1ed,
    __GlintTagReserved1ee,
    __GlintTagReserved1ef,
    __GlintTagReserved1f0,
    __GlintTagFeedbackX,                    // 0x1F1
    __GlintTagFeedbackY,                    // 0x1F2
    __GlintTagReserved1f3,
    __GlintTagReserved1f4,
    __GlintTagReserved1f5,
    __GlintTagReserved1f6,
    __GlintTagReserved1f7,
    __GlintTagReserved1f8,
    __GlintTagReserved1f9,
    __GlintTagReserved1fa,
    __GlintTagReserved1fb,
    __GlintTagReserved1fc,
    __GlintTagReserved1fd,
    __GlintTagReserved1fe,
    __GlintTagEndOfFeedback,                // 0x1FF
    __DeltaTagV0Fixed0,                     // 0x200
    __DeltaTagV0Fixed1,                     // 0x201
    __DeltaTagV0Fixed2,                     // 0x202
    __DeltaTagV0Fixed3,                     // 0x203
    __DeltaTagV0Fixed4,                     // 0x204
    __DeltaTagV0Fixed5,                     // 0x205
    __DeltaTagV0Fixed6,                     // 0x206
    __DeltaTagV0Fixed7,                     // 0x207
    __DeltaTagV0Fixed8,                     // 0x208
    __DeltaTagV0Fixed9,                     // 0x209
    __DeltaTagV0FixedA,                     // 0x20A
    __DeltaTagV0FixedB,                     // 0x20B
    __DeltaTagV0FixedC,                     // 0x20C
    __GlintTagReserved20d,
    __GlintTagReserved20e,
    __GlintTagReserved20f,
    __DeltaTagV1Fixed0,                     // 0x210
    __DeltaTagV1Fixed1,                     // 0x211
    __DeltaTagV1Fixed2,                     // 0x212
    __DeltaTagV1Fixed3,                     // 0x213
    __DeltaTagV1Fixed4,                     // 0x214
    __DeltaTagV1Fixed5,                     // 0x215
    __DeltaTagV1Fixed6,                     // 0x216
    __DeltaTagV1Fixed7,                     // 0x217
    __DeltaTagV1Fixed8,                     // 0x218
    __DeltaTagV1Fixed9,                     // 0x219
    __DeltaTagV1FixedA,                     // 0x21A
    __DeltaTagV1FixedB,                     // 0x21B
    __DeltaTagV1FixedC,                     // 0x21C
    __GlintTagReserved21d,
    __GlintTagReserved21e,
    __GlintTagReserved21f,
    __DeltaTagV2Fixed0,                     // 0x220
    __DeltaTagV2Fixed1,                     // 0x221
    __DeltaTagV2Fixed2,                     // 0x222
    __DeltaTagV2Fixed3,                     // 0x223
    __DeltaTagV2Fixed4,                     // 0x224
    __DeltaTagV2Fixed5,                     // 0x225
    __DeltaTagV2Fixed6,                     // 0x226
    __DeltaTagV2Fixed7,                     // 0x227
    __DeltaTagV2Fixed8,                     // 0x228
    __DeltaTagV2Fixed9,                     // 0x229
    __DeltaTagV2FixedA,                     // 0x22A
    __DeltaTagV2FixedB,                     // 0x22B
    __DeltaTagV2FixedC,                     // 0x22C
    __GlintTagReserved22d,
    __GlintTagReserved22e,
    __GlintTagReserved22f,
    __DeltaTagV0Float0,                     // 0x230
    __DeltaTagV0Float1,                     // 0x231
    __DeltaTagV0Float2,                     // 0x232
    __DeltaTagV0Float3,                     // 0x233
    __DeltaTagV0Float4,                     // 0x234
    __DeltaTagV0Float5,                     // 0x235
    __DeltaTagV0Float6,                     // 0x236
    __DeltaTagV0Float7,                     // 0x237
    __DeltaTagV0Float8,                     // 0x238
    __DeltaTagV0Float9,                     // 0x239
    __DeltaTagV0FloatA,                     // 0x23A
    __DeltaTagV0FloatB,                     // 0x23B
    __DeltaTagV0FloatC,                     // 0x23C
    __GlintTagReserved23d,
    __GlintTagReserved23e,
    __GlintTagReserved23f,
    __DeltaTagV1Float0,                     // 0x240
    __DeltaTagV1Float1,                     // 0x241
    __DeltaTagV1Float2,                     // 0x242
    __DeltaTagV1Float3,                     // 0x243
    __DeltaTagV1Float4,                     // 0x244
    __DeltaTagV1Float5,                     // 0x245
    __DeltaTagV1Float6,                     // 0x246
    __DeltaTagV1Float7,                     // 0x247
    __DeltaTagV1Float8,                     // 0x248
    __DeltaTagV1Float9,                     // 0x249
    __DeltaTagV1FloatA,                     // 0x24A
    __DeltaTagV1FloatB,                     // 0x24B
    __DeltaTagV1FloatC,                     // 0x24C
    __GlintTagReserved24d,
    __GlintTagReserved24e,
    __GlintTagReserved24f,
    __DeltaTagV2Float0,                     // 0x250
    __DeltaTagV2Float1,                     // 0x251
    __DeltaTagV2Float2,                     // 0x252
    __DeltaTagV2Float3,                     // 0x253
    __DeltaTagV2Float4,                     // 0x254
    __DeltaTagV2Float5,                     // 0x255
    __DeltaTagV2Float6,                     // 0x256
    __DeltaTagV2Float7,                     // 0x257
    __DeltaTagV2Float8,                     // 0x258
    __DeltaTagV2Float9,                     // 0x259
    __DeltaTagV2FloatA,                     // 0x25A
    __DeltaTagV2FloatB,                     // 0x25B
    __DeltaTagV2FloatC,                     // 0x25C
    __GlintTagReserved25d,
    __GlintTagReserved25e,
    __GlintTagReserved25f,
    __DeltaTagDeltaMode,                    // 0x260
    __DeltaTagDrawTriangle,                 // 0x261
    __DeltaTagRepeatTriangle,               // 0x262
    __DeltaTagDrawLine01,                   // 0x263
    __DeltaTagDrawLine10,                   // 0x264
    __DeltaTagRepeatLine,                   // 0x265
    __DeltaTagDrawPoint,                    // 0x266
    __DeltaTagProvokingVertex,              // 0x267
    __DeltaTagTextureLODScale,              // 0x268
    __DeltaTagTextureLODScale1,             // 0x269
    __DeltaTagDeltaControl,                 // 0x26A
    __DeltaTagProvokingVertexMask,          // 0x26B
    __DeltaTagReserved26C,
    __DeltaTagReserved26D,
    __DeltaTagReserved26E,
    __DeltaTagBroadcastMask,                // 0x26F
    __DeltaTagXBias = 0x290,                // 0x290
    __DeltaTagYBias,                        // 0x291
    __DeltaTagZBias,                        // 0x29F
    __DeltaTagLineCoord0 = 0x2EC,           // 0x2EC
    __DeltaTagDrawLine2D10,                 // 0x2ED
    __DeltaTagLineCoord1,                   // 0x2EE
    __DeltaTagDrawLine2D01,                 // 0x2EF

    // Some duplicated tags:
    __PXRXTagStripeOffsetY = 0x019,         // 0x019 = __PermediaTagXLimits
    __PXRXTagTextureCoordMode = 0x070,      // 0x070 = __GlintTagTextureAddressMode

    __PXRXTagS1Start = 0x080,               // 0x080
    __PXRXTagdS1dx,                         // 0x081
    __PXRXTagdS1dyDom,                      // 0x082 = __GlintTagTexelCoordU
    __PXRXTagT1Start,                       // 0x083 = __GlintTagTexelCoordV
    __PXRXTagdT1dx,                         // 0x084
    __PXRXTagdT1dyDom,                      // 0x085
    __PXRXTagQ1Start,                       // 0x086
    __PXRXTagdQ1dx,                         // 0x087
    __PXRXTagdQ1dyDom,                      // 0x088

    __PXRXTagLUTIndex = 0x098,              // 0x098 = __GlintTagTextureLUTIndex
    __PXRXTagLUTData,                       // 0x099 = __GlintTagTextureLUTData
    __PXRXTagLUTAddress,                    // 0x09A = __GlintTagTextureLUTAddress
    __PXRXTagLUTTransfer,                   // 0x09B = __GlintTagTextureLUTTransfer

    __PXRXTagTextureMapWidth0 = 0xB0,       // 0x0B0 = __PermediaTagTextureBaseAddress
    __PXRXTagTextureMapWidth1,              // 0x0B1 = __PermediaTagTextureMapFormat
    __PXRXTagTextureMapWidth2,              // 0x0B2 = __PermediaTagTextureDataFormat
    __PXRXTagTextureMapWidth3,              // 0x0B3
    __PXRXTagTextureMapWidth4,              // 0x0B4
    __PXRXTagTextureMapWidth5,              // 0x0B5
    __PXRXTagTextureMapWidth6,              // 0x0B6
    __PXRXTagTextureMapWidth7,              // 0x0B7
    __PXRXTagTextureMapWidth8,              // 0x0B8
    __PXRXTagTextureMapWidth9,              // 0x0B9
    __PXRXTagTextureMapWidth10,             // 0x0BA
    __PXRXTagTextureMapWidth11,             // 0x0BB
    __PXRXTagTextureMapWidth12,             // 0x0BC
    __PXRXTagTextureMapWidth13,             // 0x0BD
    __PXRXTagTextureMapWidth14,             // 0x0BE
    __PXRXTagTextureMapWidth15,             // 0x0BF

    __PXRXTagTextureChromaUpper1 = 0x0c0,   // 0x0C0
    __PXRXTagTextureChromaLower1,           // 0x0C1

    __PXRXTagTextureApplicationMode = 0x0d0,// 0x0D0 = __GlintTagTextureColorMode

    __PXRXTagYUVMode = 0x1E0,               // 0x1E0 = __PermediaTagYUVMode
    __PXRXTagChromaUpper,                   // 0x1E1 = __PermediaTagChromaUpperBound
    __PXRXTagChromaLower,                   // 0x1E2 = __PermediaTagChromaLowerBound

    __PXRXTagV0FloatS1 = 0x200,             // 0x200
    __PXRXTagV0FloatT1,                     // 0x201
    __PXRXTagV0FloatQ1,                     // 0x202

    __PXRXTagV0FloatKsR = 0x20A,            // 0x20A
    __PXRXTagV0FloatKsG,                    // 0x20B
    __PXRXTagV0FloatKsB,                    // 0x20C
    __PXRXTagV0FloatKdR,                    // 0x20D
    __PXRXTagV0FloatKdG,                    // 0x20E
    __PXRXTagV0FloatKdB,                    // 0x20F
    __PXRXTagV1FloatS1,                     // 0x210
    __PXRXTagV1FloatT1,                     // 0x211
    __PXRXTagV1FloatQ1,                     // 0x212

    __PXRXTagV1FloatKsR = 0x21A,            // 0x21A
    __PXRXTagV1FloatKsG,                    // 0x21B
    __PXRXTagV1FloatKsB,                    // 0x21C
    __PXRXTagV1FloatKdR,                    // 0x21D
    __PXRXTagV1FloatKdG,                    // 0x21E
    __PXRXTagV1FloatKdB,                    // 0x21F
    __PXRXTagV2FloatS1,                     // 0x220
    __PXRXTagV2FloatT1,                     // 0x221
    __PXRXTagV2FloatQ1,                     // 0x222

    __PXRXTagV2FloatKsR = 0x22A,            // 0x22A
    __PXRXTagV2FloatKsG,                    // 0x22B
    __PXRXTagV2FloatKsB,                    // 0x22C
    __PXRXTagV2FloatKdR,                    // 0x22D
    __PXRXTagV2FloatKdG,                    // 0x22E
    __PXRXTagV2FloatKdB,                    // 0x22F
    __PXRXTagV0FloatS,                      // 0x230
    __PXRXTagV0FloatT,                      // 0x231
    __PXRXTagV0FloatQ,                      // 0x232

    __PXRXTagV0FloatR = 0x235,              // 0x235
    __PXRXTagV0FloatG,                      // 0x236
    __PXRXTagV0FloatB,                      // 0x237
    __PXRXTagV0FloatA,                      // 0x238
    __PXRXTagV0FloatF,                      // 0x239
    __PXRXTagV0FloatX,                      // 0x23A
    __PXRXTagV0FloatY,                      // 0x23B
    __PXRXTagV0FloatZ,                      // 0x23C
    __PXRXTagV0FloatW,                      // 0x23D
    __PXRXTagV0FloatPackedColour,           // 0x23E
    __PXRXTagV0FloatPackedSpecularFog,      // 0x23F
    __RXRXTagV1FloatS,                      // 0x240
    __RXRXTagV1FloatT,                      // 0x241
    __RXRXTagV1FloatQ,                      // 0x242

    __RXRXTagV1FloatR = 0x245,              // 0x245
    __RXRXTagV1FloatG,                      // 0x246
    __RXRXTagV1FloatB,                      // 0x247
    __RXRXTagV1FloatA,                      // 0x248
    __RXRXTagV1FloatF,                      // 0x249
    __RXRXTagV1FloatX,                      // 0x24A
    __RXRXTagV1FloatY,                      // 0x24B
    __RXRXTagV1FloatZ,                      // 0x24C
    __RXRXTagV1FloatW,                      // 0x24D
    __RXRXTagV1FloatPackedColour,           // 0x24E
    __RXRXTagV1FloatPackedSpecularFog,      // 0x24F
    __RXRXTagV2FloatS,                      // 0x250
    __RXRXTagV2FloatT,                      // 0x251
    __RXRXTagV2FloatQ,                      // 0x252

    __RXRXTagV2FloatR = 0x255,              // 0x255
    __RXRXTagV2FloatG,                      // 0x256
    __RXRXTagV2FloatB,                      // 0x257
    __RXRXTagV2FloatA,                      // 0x258
    __RXRXTagV2FloatF,                      // 0x259
    __RXRXTagV2FloatX,                      // 0x25A
    __RXRXTagV2FloatY,                      // 0x25B
    __RXRXTagV2FloatZ,                      // 0x25C
    __RXRXTagV2FloatW,                      // 0x25D
    __RXRXTagV2FloatPackedColour,           // 0x25E
    __RXRXTagV2FloatPackedSpecularFog,      // 0x25F

    __GlintTagDMAAddr = 0x530,              // 0x530
    __GlintTagDMACount,                     // 0x531
    __GlintTagCommandInterrupt,             // 0x532
    __GlintTagReserved533,
    __GlintTagReserved534,
    __GlintTagDMARectangleRead,             // 0x535
    __GlintTagDMARectangleReadAddress,      // 0x536
    __GlintTagDMARectangleReadLinePitch,    // 0x537
    __GlintTagDMARectangleReadTarget,       // 0x538
    __GlintTagDMARectangleWrite,            // 0x539
    __GlintTagDMARectangleWriteAddress,     // 0x53A
    __GlintTagDMARectangleWriteLinePitch,   // 0x53B
    __GlintTagDMAOutputAddress,             // 0x53C
    __GlintTagDMAOutputCount,               // 0x53D
    __GlintTagReserved53E,
    __GlintTagDMAContinue,                  // 0x53F
    __GlintTagReserved540,
    __GlintTagReserved541,
    __GlintTagDMAFeedback                   // 0x542
};

// Apparently MSVC can't handle large enums so lets split it in half!
enum __GlintTagList2 {
    __GlintTagDeltaModeAnd = 0x55A,         // 0x55A
    __GlintTagDeltaModeOr,                  // 0x55B
    __GlintTagReserved55C,
    __GlintTagReserved55D,
    __GlintTagReserved55E,
    __GlintTagReserved55F,
    __GlintTagReserved560,
    __GlintTagReserved561,
    __GlintTagReserved562,
    __GlintTagReserved563,
    __GlintTagDeltaControlAnd,              // 0x564
    __GlintTagDeltaControlOr,               // 0x565
    __GlintTagReserved566,
    __GlintTagReserved567,
    __GlintTagReserved568,
    __GlintTagReserved569,
    __GlintTagReserved56A,
    __GlintTagReserved56B,
    __GlintTagReserved56C,
    __GlintTagReserved56D,
    __GlintTagReserved56E,
    __GlintTagReserved56F,
    __GlintTagWindowAnd,                    // 0x570
    __GlintTagWindowOr,                     // 0x571
    __GlintTagLBReadModeAnd,                // 0x572
    __GlintTagLBReadModeOr,                 // 0x573
    __GlintTagRasterizerModeAnd,            // 0x574
    __GlintTagRasterizerModeOr,             // 0x575
    __GlintTagScissorModeAnd,               // 0x576
    __GlintTagScissorModeOr,                // 0x577
    __GlintTagLineStippleModeAnd,           // 0x578
    __GlintTagLineStippleModeOr,            // 0x579
    __GlintTagAreaStippleModeAnd,           // 0x57A
    __GlintTagAreaStippleModeOr,            // 0x57B
    __GlintTagColorDDAModeAnd,              // 0x57C
    __GlintTagColorDDAModeOr,               // 0x57D
    __GlintTagAlphaTestModeAnd,             // 0x57E
    __GlintTagAlphaTestModeOr,              // 0x57F
    __GlintTagAntialiasModeAnd,             // 0x580
    __GlintTagAntialiasModeOr,              // 0x581
    __GlintTagFogModeAnd,                   // 0x582
    __GlintTagFogModeOr,                    // 0x583
    __GlintTagTextureCoordModeAnd,          // 0x584
    __GlintTagTextureCoordModeOr,           // 0x585
    __GlintTagTextureReadMode0And,          // 0x586
    __GlintTagTextureReadMode0Or,           // 0x587
    __GlintTagTextureFormatAnd,             // 0x588
    __GlintTagTextureFormatOr,              // 0x589
    __GlintTagTextureApplicationModeAnd,    // 0x58A
    __GlintTagTextureApplicationModeOr,     // 0x58B
    __GlintTagStencilModeAnd,               // 0x58C
    __GlintTagStencilModeOr,                // 0x58D
    __GlintTagDepthModeAnd,                 // 0x58E
    __GlintTagDepthModeOr,                  // 0x58F
    __GlintTagLBWriteModeAnd,               // 0x590
    __GlintTagLBWriteModeOr,                // 0x591
    __GlintTagFBDestReadModeAnd,            // 0x592
    __GlintTagFBDestReadModeOr,             // 0x593
    __GlintTagFBSourceReadModeAnd,          // 0x594
    __GlintTagFBSourceReadModeOr,           // 0x595
    __GlintTagAlphaBlendColorModeAnd,       // 0x596
    __GlintTagAlphaBlendColorModeOr,        // 0x597
    __GlintTagChromaTestModeAnd,            // 0x598
    __GlintTagChromaTestModeOr,             // 0x599
    __GlintTagDitherModeAnd,                // 0x59A
    __GlintTagDitherModeOr,                 // 0x59B
    __GlintTagLogicalOpModeAnd,             // 0x59C
    __GlintTagLogicalOpModeOr,              // 0x59D
    __GlintTagFBWriteModeAnd,               // 0x59E
    __GlintTagFBWriteModeOr,                // 0x59F
    __GlintTagFilterModeAnd,                // 0x5A0
    __GlintTagFilterModeOr,                 // 0x5A1
    __GlintTagStatisticModeAnd,             // 0x5A2
    __GlintTagStatisticModeOr,              // 0x5A3
    __GlintTagFBDestReadEnablesAnd,         // 0x5A4
    __GlintTagFBDestReadEnablesOr,          // 0x5A5
    __GlintTagAlphaBlendAlphaModeAnd,       // 0x5A6
    __GlintTagAlphaBlendAlphaModeOr,        // 0x5A7
    __GlintTagTextureReadMode1And,          // 0x5A8
    __GlintTagTextureReadMode1Or,           // 0x5A9
    __GlintTagTextureFilterModeAnd,         // 0x5AA
    __GlintTagTextureFilterModeOr,          // 0x5AB
    __GlintTagReserved5AC,
    __GlintTagReserved5AD,
    __GlintTagLUTModeAnd,                   // 0x5AE
    __GlintTagLUTModeOr,                    // 0x5AF
    __GlintTagReserved5B0,
    __GlintTagReserved5B1,
    __GlintTagReserved5B2,
    __GlintTagReserved5B3,
    __GlintTagReserved5B4,
    __GlintTagReserved5B5,
    __GlintTagReserved5B6,
    __GlintTagReserved5B7,
    __GlintTagReserved5B8,
    __GlintTagReserved5B9,
    __GlintTagReserved5BA,
    __GlintTagReserved5BB,
    __GlintTagReserved5BC,
    __GlintTagReserved5BD,
    __GlintTagReserved5BE,
    __GlintTagReserved5BF,
    __GlintTagReserved5C0,
    __GlintTagReserved5C1,
    __GlintTagReserved5C2,
    __GlintTagReserved5C3,
    __GlintTagReserved5C4,
    __GlintTagReserved5C5,
    __GlintTagReserved5C6,
    __GlintTagReserved5C7,
    __GlintTagReserved5C8,
    __GlintTagReserved5C9,
    __GlintTagReserved5CA,
    __GlintTagReserved5CB,
    __GlintTagReserved5CC,
    __GlintTagReserved5CD,
    __GlintTagReserved5CE,
    __GlintTagReserved5CF,
    __GlintTagFBDestReadBufferAddr0,        // 0x5D0
    __GlintTagFBDestReadBufferAddr1,        // 0x5D1
    __GlintTagFBDestReadBufferAddr2,        // 0x5D2
    __GlintTagFBDestReadBufferAddr3,        // 0x5D3
    __GlintTagFBDestReadBufferOffset0,      // 0x5D4
    __GlintTagFBDestReadBufferOffset1,      // 0x5D5
    __GlintTagFBDestReadBufferOffset2,      // 0x5D6
    __GlintTagFBDestReadBufferOffset3,      // 0x5D7
    __GlintTagFBDestReadBufferWidth0,       // 0x5D8
    __GlintTagFBDestReadBufferWidth1,       // 0x5D9
    __GlintTagFBDestReadBufferWidth2,       // 0x5DA
    __GlintTagFBDestReadBufferWidth3,       // 0x5DB
    __GlintTagFBDestReadMode,               // 0x5DC
    __GlintTagFBDestReadEnables,            // 0x5DD
    __GlintTagReserved5DE,
    __GlintTagReserved5DF,
    __GlintTagFBSourceReadMode,             // 0x5E0
    __GlintTagFBSourceReadBufferAddr,       // 0x5E1
    __GlintTagFBSourceReadBufferOffset,     // 0x5E2
    __GlintTagFBSourceReadBufferWidth,      // 0x5E3
    __GlintTagReserved5E4,
    __GlintTagReserved5E5,
    __GlintTagReserved5E6,
    __GlintTagMergeSpanData,                // 0x5E7
    __GlintTagPCIWindowBase0,               // 0x5E8
    __GlintTagPCIWindowBase1,               // 0x5E9
    __GlintTagPCIWindowBase2,               // 0x5EA
    __GlintTagPCIWindowBase3,               // 0x5EB
    __GlintTagPCIWindowBase4,               // 0x5EC
    __GlintTagPCIWindowBase5,               // 0x5ED
    __GlintTagPCIWindowBase6,               // 0x5EE
    __GlintTagPCIWindowBase7,               // 0x5EF
    __GlintTagAlphaSourceColor,             // 0x5F0
    __GlintTagAlphaDestColor,               // 0x5F1
    __GlintTagChromaPassColor,              // 0x5F2
    __GlintTagChromaFailColor,              // 0x5F3
    __GlintTagAlphaBlendColorMode,          // 0x5F4
    __GlintTagAlphaBlendAlphaMode,          // 0x5F5
    __GlintTagConstantColorDDA,             // 0x5F6
    __GlintTagReserved5F7,
    __GlintTagD3DAlphaTestMode,             // 0x5F8
    __GlintTagReserved5F9,
    __GlintTagReserved5FA,
    __GlintTagReserved5FB,
    __GlintTagReserved5FC,
    __GlintTagReserved5FD,
    __GlintTagReserved5FE,
    __GlintTagReserved5FF,
    __GlintTagFBWriteBufferAddr0,           // 0x600
    __GlintTagFBWriteBufferAddr1,           // 0x601
    __GlintTagFBWriteBufferAddr2,           // 0x602
    __GlintTagFBWriteBufferAddr3,           // 0x603
    __GlintTagFBWriteBufferOffset0,         // 0x604
    __GlintTagFBWriteBufferOffset1,         // 0x605
    __GlintTagFBWriteBufferOffset2,         // 0x606
    __GlintTagFBWriteBufferOffset3,         // 0x607
    __GlintTagFBWriteBufferWidth0,          // 0x608
    __GlintTagFBWriteBufferWidth1,          // 0x609
    __GlintTagFBWriteBufferWidth2,          // 0x60A
    __GlintTagFBWriteBufferWidth3,          // 0x60B
    __GlintTagFBBlockColor0,                // 0x60C
    __GlintTagFBBlockColor1,                // 0x60D
    __GlintTagFBBlockColor2,                // 0x60E
    __GlintTagFBBlockColor3,                // 0x60F
    __GlintTagFBBlockColorBack0,            // 0x610
    __GlintTagFBBlockColorBack1,            // 0x611
    __GlintTagFBBlockColorBack2,            // 0x612
    __GlintTagFBBlockColorBack3,            // 0x613
    __GlintTagFBBlockColorBack,             // 0x614
    __GlintTagSizeOfFramebuffer,            // 0x615
    __GlintTagVTGAddress,                   // 0x616
    __GlintTagVTGData,                      // 0x617
    __GlintTagForegroundColor,              // 0x618
    __GlintTagBackgroundColor,              // 0x619
    __GlintTagDownloadAddress,              // 0x61A
    __GlintTagDownloadData,                 // 0x61B
    __GlintTagFBBlockColorExt,              // 0x61C
    __GlintTagFBBlockColorBackExt,          // 0x61D
    __GlintTagFBWriteMaskExt,               // 0x61E
    __GlintTagReserved61F,
    __GlintTagFogTable0,                    // 0x620
    __GlintTagFogTable1,                    // 0x621
    __GlintTagFogTable2,                    // 0x622
    __GlintTagFogTable3,                    // 0x623
    __GlintTagFogTable4,                    // 0x624
    __GlintTagFogTable5,                    // 0x625
    __GlintTagFogTable6,                    // 0x626
    __GlintTagFogTable7,                    // 0x627
    __GlintTagFogTable8,                    // 0x628
    __GlintTagFogTable9,                    // 0x629
    __GlintTagFogTable10,                   // 0x62A
    __GlintTagFogTable11,                   // 0x62B
    __GlintTagFogTable12,                   // 0x62C
    __GlintTagFogTable13,                   // 0x62D
    __GlintTagFogTable14,                   // 0x62E
    __GlintTagFogTable15,                   // 0x62F
    __GlintTagFogTable16,                   // 0x630
    __GlintTagFogTable17,                   // 0x631
    __GlintTagFogTable18,                   // 0x632
    __GlintTagFogTable19,                   // 0x633
    __GlintTagFogTable20,                   // 0x634
    __GlintTagFogTable21,                   // 0x635
    __GlintTagFogTable22,                   // 0x636
    __GlintTagFogTable23,                   // 0x637
    __GlintTagFogTable24,                   // 0x638
    __GlintTagFogTable25,                   // 0x639
    __GlintTagFogTable26,                   // 0x63A
    __GlintTagFogTable27,                   // 0x63B
    __GlintTagFogTable28,                   // 0x63C
    __GlintTagFogTable29,                   // 0x63D
    __GlintTagFogTable30,                   // 0x63E
    __GlintTagFogTable31,                   // 0x63F
    __GlintTagFogTable32,                   // 0x640
    __GlintTagFogTable33,                   // 0x641
    __GlintTagFogTable34,                   // 0x642
    __GlintTagFogTable35,                   // 0x643
    __GlintTagFogTable36,                   // 0x644
    __GlintTagFogTable37,                   // 0x645
    __GlintTagFogTable38,                   // 0x646
    __GlintTagFogTable39,                   // 0x647
    __GlintTagFogTable40,                   // 0x648
    __GlintTagFogTable41,                   // 0x649
    __GlintTagFogTable42,                   // 0x64A
    __GlintTagFogTable43,                   // 0x64B
    __GlintTagFogTable44,                   // 0x64C
    __GlintTagFogTable45,                   // 0x64D
    __GlintTagFogTable46,                   // 0x64E
    __GlintTagFogTable47,                   // 0x64F
    __GlintTagFogTable48,                   // 0x650
    __GlintTagFogTable49,                   // 0x651
    __GlintTagFogTable50,                   // 0x652
    __GlintTagFogTable51,                   // 0x653
    __GlintTagFogTable52,                   // 0x654
    __GlintTagFogTable53,                   // 0x655
    __GlintTagFogTable54,                   // 0x656
    __GlintTagFogTable55,                   // 0x657
    __GlintTagFogTable56,                   // 0x658
    __GlintTagFogTable57,                   // 0x659
    __GlintTagFogTable58,                   // 0x65A
    __GlintTagFogTable59,                   // 0x65B
    __GlintTagFogTable60,                   // 0x65C
    __GlintTagFogTable61,                   // 0x65D
    __GlintTagFogTable62,                   // 0x65E
    __GlintTagFogTable63,                   // 0x65F
    __GlintTagTextureCompositeMode,         // 0x660
    __GlintTagTextureCompositeColorMode0,   // 0x661
    __GlintTagTextureCompositeAlphaMode0,   // 0x662
    __GlintTagTextureCompositeColorMode1,   // 0x663
    __GlintTagTextureCompositeAlphaMode1,   // 0x664
    __GlintTagTextureCompositeFactor0,      // 0x665
    __GlintTagTextureCompositeFactor1,      // 0x666
    __GlintTagTextureIndexMode0,            // 0x667
    __GlintTagTextureIndexMode1,            // 0x668
    __GlintTagLodRange0,                    // 0x669
    __GlintTagLodRange1,                    // 0x66A
    __GlintTagInvalidateCache,              // 0x66B
    __GlintTagSetLogicalTexturePage,        // 0x66C
    __GlintTagUpdateLogicalTextureInfo,     // 0x66D
    __GlintTagTouchLogicalPage,             // 0x66E
    __GlintTagLUTMode,                      // 0x66F
    __GlintTagTextureCompositeColorMode0And,// 0x670
    __GlintTagTextureCompositeColorMode0Or, // 0x671
    __GlintTagTextureCompositeAlphaMode0And,// 0x672
    __GlintTagTextureCompositeAlphaMode0Or, // 0x673
    __GlintTagTextureCompositeColorMode1And,// 0x674
    __GlintTagTextureCompositeColorMode1Or, // 0x675
    __GlintTagTextureCompositeAlphaMode1And,// 0x676
    __GlintTagTextureCompositeAlphaMode1Or, // 0x677
    __GlintTagTextureIndexMode0And,         // 0x678
    __GlintTagTextureIndexMode0Or,          // 0x679
    __GlintTagTextureIndexMode1And,         // 0x67A
    __GlintTagTextureIndexMode1Or,          // 0x67B
    __GlintTagStencilDataAnd,               // 0x67C
    __GlintTagReserved67D,
    __GlintTagReserved67E,
    __GlintTagReserved67F,
    __GlintTagTextureReadMode0,             // 0x680
    __GlintTagTextureReadMode1,             // 0x681
    __GlintTagReserved682,
    __GlintTagReserved683,
    __GlintTagReserved684,
    __GlintTagTextureMapSize,               // 0x685
    __GlintTagTextureCacheReplacementMode,  // 0x686
    __GlintTagReserved687,
    __GlintTagReserved688,
    __GlintTagReserved689,
    __GlintTagReserved68A,
    __GlintTagReserved68B,
    __GlintTagReserved68C,
    __GlintTagStencilDataOr,                // 0x68D
    __GlintTagReserved68E,
    __GlintTagReserved68F,
    __GlintTagHeadPhysicalPageAllocation0,  // 0x690
    __GlintTagHeadPhysicalPageAllocation1,  // 0x691
    __GlintTagHeadPhysicalPageAllocation2,  // 0x692
    __GlintTagHeadPhysicalPageAllocation3,  // 0x693
    __GlintTagTailPhysicalPageAllocation0,  // 0x694
    __GlintTagTailPhysicalPageAllocation1,  // 0x695
    __GlintTagTailPhysicalPageAllocation2,  // 0x696
    __GlintTagTailPhysicalPageAllocation3,  // 0x697
    __GlintTagPhysicalPageAllocationTableAddr,
    __GlintTagBasePageOfWorkingSet,         // 0x699
    __GlintTagLogicalTexturePageTableAddr,  // 0x69A
    __GlintTagLogicalTexturePageTableLength,// 0x69B
    __GlintTagBasePageOfWorkingSetHost,     // 0x69C
    __GlintTagReserved69D,
    __GlintTagReserved69E,
    __GlintTagReserved69F,
    __GlintTagLBDestReadMode,               // 0x6A0
    __GlintTagLBDestReadEnables,            // 0x6A1
    __GlintTagLBDestReadBufferAddr,         // 0x6A2
    __GlintTagLBDestReadBufferOffset,       // 0x6A3
    __GlintTagLBSourceReadMode,             // 0x6A4
    __GlintTagLBSourceReadBufferAddr,       // 0x6A5
    __GlintTagLBSourceReadBufferOffset,     // 0x6A6
    __GlintTagGIDMode,                      // 0x6A7
    __GlintTagLBWriteBufferAddr,            // 0x6A8
    __GlintTagLBWriteBufferOffset,          // 0x6A9
    __GlintTagLBClearDataL,                 // 0x6AA
    __GlintTagLBClearDataU,                 // 0x6AB
    __GlintTagReserved6AC,
    __GlintTagReserved6AD,
    __GlintTagReserved6AE,
    __GlintTagReserved6AF,
    __GlintTagLBDestReadModeAnd,            // 0x6B0
    __GlintTagLBDestReadModeOr,             // 0x6B1
    __GlintTagLBDestReadEnablesAnd,         // 0x6B2
    __GlintTagLBDestReadEnablesOr,          // 0x6B3
    __GlintTagLBSourceReadModeAnd,          // 0x6B4
    __GlintTagLBSourceReadModeOr,           // 0x6B5
    __GlintTagGIDModeAnd,                   // 0x6B6
    __GlintTagGIDModeOr,                    // 0x6B7
    __GlintTagReserved6B8,
    __GlintTagReserved6B9,
    __GlintTagReserved6BA,
    __GlintTagReserved6BB,
    __GlintTagReserved6BC,
    __GlintTagReserved6BD,
    __GlintTagReserved6BE,
    __GlintTagReserved6BF,
    __GlintTagRectanglePosition,            // 0x6C0
    __GlintTagGlyphPosition,                // 0x6C1
    __GlintTagRenderPatchOffset,            // 0x6C2
    __GlintTagConfig2D,                     // 0x6C3
    __GlintTagReserved6C4,
    __GlintTagReserved6C5,
    __GlintTagPacked8Pixels,                // 0x6C6
    __GlintTagPacked16Pixels,               // 0x6C7
    __GlintTagRender2D,                     // 0x6C8
    __GlintTagRender2DGlyph,                // 0x6C9
    __GlintTagDownloadTarget,               // 0x6CA
    __GlintTagDownloadGlyphWidth,           // 0x6CB
    __GlintTagGlyphData,                    // 0x6CC
    __GlintTagPacked4Pixels,                // 0x6CD
    __GlintTagRLData,                       // 0x6CE
    __GlintTagRLCount,                      // 0x6CF
    __GlintTagSClkProfileMask0,             // 0x6D0
    __GlintTagSClkProfileMask1,             // 0x6D1
    __GlintTagSClkProfileCount0,            // 0x6D2
    __GlintTagSClkProfileCount1,            // 0x6D3
    __GlintTagKClkProfileMask0,             // 0x6D4
    __GlintTagKClkProfileMask1,             // 0x6D5
    __GlintTagKClkProfileMask2,             // 0x6D6
    __GlintTagKClkProfileMask3,             // 0x6D7
    __GlintTagKClkProfileCount0,            // 0x6D8
    __GlintTagKClkProfileCount1,            // 0x6D9
    __GlintTagKClkProfileCount2,            // 0x6DA
    __GlintTagKClkProfileCount3,            // 0x6DB
    __GlintTagReserved6DC,
    __GlintTagReserved6DD,
    __GlintTagReserved6DE,
    __GlintTagReserved6DF,
    __GlintTagIndexBaseAddress,             // 0x6E0
    __GlintTagVertexBaseAddress,            // 0x6E1
    __GlintTagIndexedTriangleList,          // 0x6E2
    __GlintTagIndexedTriangleFan,           // 0x6E3
    __GlintTagIndexedTriangleStrip,         // 0x6E4
    __GlintTagIndexedLineList,              // 0x6E5
    __GlintTagIndexedLineStrip,             // 0x6E6
    __GlintTagIndexedPointList,             // 0x6E7
    __GlintTagIndexedPolygon,               // 0x6E8
    __GlintTagVertexTriangleList,           // 0x6E9
    __GlintTagVertexTriangleFan,            // 0x6EA
    __GlintTagVertexTriangleStrip,          // 0x6EB
    __GlintTagVertexLineList,               // 0x6EC
    __GlintTagVertexLineStrip,              // 0x6ED
    __GlintTagVertexPointList,              // 0x6EE
    __GlintTagVertexPolygon,                // 0x6EF
    __GlintTagDMAMemoryControl,             // 0x6F0
    __GlintTagVertexValid,                  // 0x6F1
    __GlintTagVertexFormat,                 // 0x6F2
    __GlintTagVertexControl,                // 0x6F3
    __GlintTagRetainedRender,               // 0x6F4
    __GlintTagIndexedVertex,                // 0x6F5
    __GlintTagIndexedDoubleVertex,          // 0x6F6
    __GlintTagVertex0,                      // 0x6F7
    __GlintTagVertex1,                      // 0x6F8
    __GlintTagVertex2,                      // 0x6F9
    __GlintTagVertexData0,                  // 0x6FA
    __GlintTagVertexData1,                  // 0x6FB
    __GlintTagVertexData2,                  // 0x6FC
    __GlintTagVertexData,                   // 0x6FD
    __GlintTagVertexTagList0,               // 0x700
    __GlintTagVertexTagList1,               // 0x701
    __GlintTagVertexTagList2,               // 0x702
    __GlintTagVertexTagList3,               // 0x703
    __GlintTagVertexTagList4,               // 0x704
    __GlintTagVertexTagList5,               // 0x705
    __GlintTagVertexTagList6,               // 0x706
    __GlintTagVertexTagList7,               // 0x707
    __GlintTagVertexTagList8,               // 0x708
    __GlintTagVertexTagList9,               // 0x709
    __GlintTagVertexTagList10,              // 0x70A
    __GlintTagVertexTagList11,              // 0x70B
    __GlintTagVertexTagList12,              // 0x70C
    __GlintTagVertexTagList13,              // 0x70D
    __GlintTagVertexTagList14,              // 0x70E
    __GlintTagVertexTagList15,              // 0x70F
    __GlintTagVertexTagList16,              // 0x710
    __GlintTagVertexTagList17,              // 0x711
    __GlintTagVertexTagList18,              // 0x712
    __GlintTagVertexTagList19,              // 0x713
    __GlintTagVertexTagList20,              // 0x714
    __GlintTagVertexTagList21,              // 0x715
    __GlintTagVertexTagList22,              // 0x716
    __GlintTagVertexTagList23,              // 0x717
    __GlintTagVertexTagList24,              // 0x718
    __GlintTagVertexTagList25,              // 0x719
    __GlintTagVertexTagList26,              // 0x71A
    __GlintTagVertexTagList27,              // 0x71B
    __GlintTagVertexTagList28,              // 0x71C
    __GlintTagVertexTagList29,              // 0x71D
    __GlintTagVertexTagList30,              // 0x71E
    __GlintTagVertexTagList31               // 0x71F
};

#define NAreaStipplePattern 32
#define __GlintTagAreaStipplePattern(i)         (0x040+(i))
#define IsAreaStipplePattern(t)        (((t)&0x1e0)==0x040)
#define __NGlintTag  (1 << 9)

#define __MaximumGlintTagValue  0x071E

typedef long __GlintTag ;

#endif /* glinttag_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\p3rd.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: p3rd.h
*
* Content: This module contains the definitions for the P2ST internal RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// structure with all the direct access registers
typedef struct _P3RD_regs
{
    RAMDAC_REG  RDPaletteWriteAddress;
    RAMDAC_REG  RDPaletteData;
    RAMDAC_REG  RDPixelMask;
    RAMDAC_REG  RDPaletteAddressRead;
    RAMDAC_REG  RDIndexLow;
    RAMDAC_REG  RDIndexHigh;
    RAMDAC_REG  RDIndexedData;
    RAMDAC_REG  RDIndexControl;
}
P3RDRAMDAC, pP3RDRAMDAC;

// macro declared by any function wishing to use the RGB525 RAMDAC. MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define P3RD_DECL \
    P3RDRAMDAC   *pP3RDRegs = (P3RDRAMDAC *)&(pDev->pRegisters->Glint.ExtVCReg)
#else
#define P3RD_DECL \
    P3RDRAMDAC   *pP3RDRegs = (P3RDRAMDAC *)&(pRegisters->Glint.ExtVCReg)
#define P3RX_RD_DECL    \
    P3RDRAMDAC   *pP3RDRegs = (P3RDRAMDAC *)&(pThisDisplay->pGlint->ExtVCReg)
#endif

#if P3R3DX_VIDEO 
#define VideoDebugPrint(arg)
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
#define P3RD_PAL_WR_ADDR              ((PULONG)&(pP3RDRegs->RDPaletteWriteAddress.reg))
#define P3RD_PAL_RD_ADDR              ((PULONG)&(pP3RDRegs->RDPaletteAddressRead.reg))
#define P3RD_PAL_DATA                 ((PULONG)&(pP3RDRegs->RDPaletteData.reg))
#define P3RD_PIXEL_MASK               ((PULONG)&(pP3RDRegs->RDPixelMask.reg))
#define P3RD_INDEX_ADDR_LO            ((PULONG)&(pP3RDRegs->RDIndexLow.reg))
#define P3RD_INDEX_ADDR_HI            ((PULONG)&(pP3RDRegs->RDIndexHigh.reg))
#define P3RD_INDEX_DATA               ((PULONG)&(pP3RDRegs->RDIndexedData.reg))
#define P3RD_INDEX_CONTROL            ((PULONG)&(pP3RDRegs->RDIndexControl.reg))

// bit field definitions for the direct access registers
#define P3RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

// indexed register definitions accessed via P3RD_LOAD_INDEX_REG() and P3RD_READ_INDEX_REG()
#define P3RD_MISC_CONTROL               0x0000
#define P3RD_SYNC_CONTROL               0x0001
#define P3RD_DAC_CONTROL                0x0002
#define P3RD_PIXEL_SIZE                 0x0003
#define P3RD_COLOR_FORMAT               0x0004
#define P3RD_CURSOR_MODE                0x0005
#define P3RD_CURSOR_CONTROL             0x0006
#define P3RD_CURSOR_X_LOW               0x0007
#define P3RD_CURSOR_X_HIGH              0x0008
#define P3RD_CURSOR_Y_LOW               0x0009
#define P3RD_CURSOR_Y_HIGH              0x000a
#define P3RD_CURSOR_HOTSPOT_X           0x000b
#define P3RD_CURSOR_HOTSPOT_Y           0x000c
#define P3RD_OVERLAY_KEY                0x000d
#define P3RD_PAN                        0x000e
#define P3RD_SENSE                      0x000f
#define P3RD_CHECK_CONTROL              0x0018
#define P3RD_CHECK_PIXEL_RED            0x0019
#define P3RD_CHECK_PIXEL_GREEN          0x001a
#define P3RD_CHECK_PIXEL_BLUE           0x001b
#define P3RD_CHECK_LUT_RED              0x001c
#define P3RD_CHECK_LUT_GREEN            0x001d
#define P3RD_CHECK_LUT_BLUE             0x001e
#define P3RD_SCRATCH                    0x001f
#define P3RD_VIDEO_OVERLAY_CONTROL      0x0020
#define P3RD_VIDEO_OVERLAY_XSTARTLOW    0x0021
#define P3RD_VIDEO_OVERLAY_XSTARTHIGH   0x0022
#define P3RD_VIDEO_OVERLAY_YSTARTLOW    0x0023
#define P3RD_VIDEO_OVERLAY_YSTARTHIGH   0x0024
#define P3RD_VIDEO_OVERLAY_XENDLOW      0x0025
#define P3RD_VIDEO_OVERLAY_XENDHIGH     0x0026
#define P3RD_VIDEO_OVERLAY_YENDLOW      0x0027
#define P3RD_VIDEO_OVERLAY_YENDHIGH     0x0028
#define P3RD_VIDEO_OVERLAY_KEYR         0x0029
#define P3RD_VIDEO_OVERLAY_KEYG         0x002a
#define P3RD_VIDEO_OVERLAY_KEYB         0x002b
#define P3RD_VIDEO_OVERLAY_BLEND        0x002c

#define P3RD_DCLK_SETUP_1               0x01f0
#define P3RD_DCLK_SETUP_2               0x01f1
#define P3RD_KCLK_SETUP_1               0x01f2
#define P3RD_KCLK_SETUP_2               0x01f3
#define P3RD_DCLK_CONTROL               0x0200
#define P3RD_DCLK0_PRE_SCALE            0x0201
#define P3RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P3RD_DCLK0_POST_SCALE           0x0203
#define P3RD_DCLK1_PRE_SCALE            0x0204
#define P3RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P3RD_DCLK1_POST_SCALE           0x0206
#define P3RD_DCLK2_PRE_SCALE            0x0207
#define P3RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P3RD_DCLK2_POST_SCALE           0x0209
#define P3RD_DCLK3_PRE_SCALE            0x020a
#define P3RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P3RD_DCLK3_POST_SCALE           0x020c
#define P3RD_KCLK_CONTROL               0x020d
#define P3RD_KCLK_PRE_SCALE             0x020e
#define P3RD_KCLK_FEEDBACK_SCALE        0x020f
#define P3RD_KCLK_POST_SCALE            0x0210
#define P3RD_MCLK_CONTROL               0x0211
#define P3RD_SCLK_CONTROL               0x0215
#define P3RD_CURSOR_PALETTE_START       0x0303      // 303..32f
#define P3RD_CURSOR_PATTERN_START       0x0400      // 400..7ff

// bit field definitions for the indexed registers
#define P3RD_MISC_CONTROL_STEREODOUBLEBUFFER    0x80
#define P3RD_MISC_CONTROL_VSBOUTPUT             0x40
#define P3RD_MISC_CONTROL_PIXELDOUBLEBUFFER     0x20
#define P3RD_MISC_CONTROL_OVERLAYS_ENABLED      0x10
#define P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED  0x08
#define P3RD_MISC_CONTROL_HIGHCOLORRES          0x01

#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW  0x00
#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH 0x08
#define P3RD_SYNC_CONTROL_VSYNC_OFF         0x20
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW  0x00
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH 0x01
#define P3RD_SYNC_CONTROL_HSYNC_OFF         0x04

#define P3RD_DAC_CONTROL_LOW_POWER      0x01
#define P3RD_DAC_CONTROL_SYNC_ON_GREEN  0x08
#define P3RD_DAC_CONTROL_BLANK_RED      0x10
#define P3RD_DAC_CONTROL_BLANK_GREEN    0x20
#define P3RD_DAC_CONTROL_BLANK_BLUE     0x40
#define P3RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED 0x80

#define P3RD_PIXEL_SIZE_8BPP            0x00
#define P3RD_PIXEL_SIZE_16BPP           0x01
#define P3RD_PIXEL_SIZE_24_BPP          0x04
#define P3RD_PIXEL_SIZE_32BPP           0x02

#define P3RD_COLOR_FORMAT_CI8           0x0e
#define P3RD_COLOR_FORMAT_8BPP          0x25
#define P3RD_COLOR_FORMAT_15BPP         0x21
#define P3RD_COLOR_FORMAT_16BPP         0x30
#define P3RD_COLOR_FORMAT_32BPP         0x20
#define P3RD_COLOR_FORMAT_LINEAR_EXT    0x40

#define P3RD_CURSOR_MODE_REVERSE        0x40
#define P3RD_CURSOR_MODE_WINDOWS        0x00
#define P3RD_CURSOR_MODE_X              0x10
#define P3RD_CURSOR_MODE_3COLOR         0x20
#define P3RD_CURSOR_MODE_15COLOR        0x30
#define P3RD_CURSOR_MODE_64x64          0x00
#define P3RD_CURSOR_MODE_P0_32x32x2     0x02
#define P3RD_CURSOR_MODE_P1_32x32x2     0x04
#define P3RD_CURSOR_MODE_P2_32x32x2     0x06
#define P3RD_CURSOR_MODE_P3_32x32x2     0x08
#define P3RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P3RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P3RD_CURSOR_MODE_ENABLED        0x01
#define P3RD_CURSOR_MODE_OFF            0x00

#define P3RD_CURSOR_CONTROL_RPOS_ENABLED    0x04
#define P3RD_CURSOR_CONTROL_DOUBLE_Y        0x02
#define P3RD_CURSOR_CONTROL_DOUBLE_X        0x01

// Windows format byte-packed cursor data: each byte represents 4 consecutive pixels
#define P3RD_CURSOR_2_COLOR_BLACK           0x00
#define P3RD_CURSOR_2_COLOR_WHITE           0x55
#define P3RD_CURSOR_2_COLOR_TRANSPARENT     0xAA
#define P3RD_CURSOR_2_COLOR_HIGHLIGHT       0xFF

// cursor sizes
#define P3RD_CURSOR_SIZE_64_MONO    0
#define P3RD_CURSOR_SIZE_32_MONO    1
#define P3RD_CURSOR_SIZE_32_3COLOR  5
#define P3RD_CURSOR_SEL(cursorSize, cursorIndex) (((cursorSize + cursorIndex) & 7) << 1)

#define P3RD_DCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_DCLK_CONTROL_ENABLED   0x01
#define P3RD_DCLK_CONTROL_RUN       0x08
#define P3RD_DCLK_SOURCE_PLL        0x00
#define P3RD_DCLK_SOURCE_VSA        0x01
#define P3RD_DCLK_SOURCE_VSB        0x02
#define P3RD_DCLK_SOURCE_EXTERNAL   0x03

#define P3RD_MCLK_CONTROL_ENABLED   0x01
#define P3RD_MCLK_CONTROL_RUN       0x08
#define P3RD_MCLK_SOURCE_PCLK       0x00
#define P3RD_MCLK_SOURCE_HALFPCLK   0x10
#define P3RD_MCLK_SOURCE_HALFEXTMCLK 0x30
#define P3RD_MCLK_SOURCE_EXTMCLK    0x40
#define P3RD_MCLK_SOURCE_HALFKCLK   0x50
#define P3RD_MCLK_SOURCE_KCLK       0x60

#define P3RD_KCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_KCLK_CONTROL_ENABLED   0x01
#define P3RD_KCLK_CONTROL_RUN       0x08
#define P3RD_KCLK_SOURCE_PCLK       0x00
#define P3RD_KCLK_SOURCE_HALFPCLK   0x10
#define P3RD_KCLK_SOURCE_PLL        0x20

#define P3RD_SCLK_CONTROL_LOCKED    0x02    // read-only
#define P3RD_SCLK_CONTROL_ENABLED   0x01
#define P3RD_SCLK_CONTROL_RUN       0x08
#define P3RD_SCLK_SOURCE_PCLK       0x00
#define P3RD_SCLK_SOURCE_HALFPCLK   0x10
#define P3RD_SCLK_SOURCE_HALFEXTSCLK 0x30
#define P3RD_SCLK_SOURCE_EXTSCLK    0x40
#define P3RD_SCLK_SOURCE_HALFKCLK   0x50
#define P3RD_SCLK_SOURCE_KCLK       0x60

// Palette entries are reversed from P2
#define P3RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)(14 - RGBIndex)+0, Red); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)(14 - RGBIndex)+1, Green); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)(14 - RGBIndex)+2, Blue); \
}


#if 0
// need a delay between each write to the P3RD. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
#define P3RD_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}
#else
#define P3RD_DELAY
#endif

// macro to load a given data value into an internal P3RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define P3RD_INDEX_REG(index) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_LO, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P3RD_DELAY; \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_HI, (index) >> 8)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_DATA(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P3RD_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_READ_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    data = (BYTE) (VideoPortReadRegisterUlong(P3RD_INDEX_DATA) & 0xff);   \
    P3RD_DELAY; \
    VideoDebugPrint(("0x%x <-- *(0x%x)\n", data, P3RD_INDEX_DATA)); \
}

#define P3RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA,    (ULONG)(data));   \
    P3RD_DELAY; \
}

// macros to load a given RGB triple into the P3RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P3RD_PALETTE_START and multiple P3RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P3RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define P3RD_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_WR_ADDR, (ULONG)(index));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

// macro to read back a given RGB triple from the P3RD palette. Use after
// a call to P3RD_PALETTE_START_RD
//
#define P3RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);        \
    P3RD_DELAY; \
}

#define P3RD_SET_INDEX_CONTROL(mask) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_CONTROL, (ULONG)(mask)); \
    P3RD_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define P3RD_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PIXEL_MASK,  (ULONG)(mask)); \
    P3RD_DELAY; \
}

#define P3RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(P3RD_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array usage is P3RD_CURSOR_ARRAR_START() followed by 
// n iterations of P3RD_LOAD_CURSOR_ARRAY() or P3RD_READ_CURSOR_ARRAY()
//
#define P3RD_CURSOR_ARRAY_START(offset) \
{ \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO,   (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) & 0xff));  \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) >> 8));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)(data)); \
    P3RD_DELAY; \
}

#define P3RD_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(P3RD_INDEX_DATA) & 0xff; \
    P3RD_DELAY; \
}

// macro to move the cursor
//
#define P3RD_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)0);              \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define P3RD_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\p3rxdef.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: p3rxdef.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// This file containes defines for values that are filled into fields on P3/RX
// The file glintdef.h is the equivalent for glint chips.

// These defines are typically used in conjunction with the macros in bitmac2.h, 
// which shift the values to their correct locations.

#ifdef __P3RXDEF
#pragma message ("FILE : "__FILE__" : Multiple Inclusion")
#endif

#define __P3RXDEF


// Dither unit.
// these COLORFORMATs are used in various other places too,
// e.g. the alpha blend unit.
#define P3RX_DITHERMODE_COLORFORMAT_8888                0
#define P3RX_DITHERMODE_COLORFORMAT_4444                1
#define P3RX_DITHERMODE_COLORFORMAT_5551                2
#define P3RX_DITHERMODE_COLORFORMAT_565                 3
#define P3RX_DITHERMODE_COLORFORMAT_332                 4
#define P3RX_DITHERMODE_COLORFORMAT_CI                  15
#define P3RX_DITHERMODE_COLORFORMAT_ILLEGAL             -1
// Usually use the COLOR_MODE macro for the default order.
#define P3RX_DITHERMODE_COLORORDER_BGR                  0
#define P3RX_DITHERMODE_COLORORDER_RGB                  1
// Careful! These are not the way round you would expect.
#define P3RX_DITHERMODE_ALPHADITHER_DITHER              0
#define P3RX_DITHERMODE_ALPHADITHER_ROUND               1
#define P3RX_DITHERMODE_ROUNDINGMODE_TRUNCATE           0
#define P3RX_DITHERMODE_ROUNDINGMODE_ROUNDUP            1
#define P3RX_DITHERMODE_ROUNDINGMODE_ROUNDDOWN          2

// Texture unit bit fields

// Texture Read Mode
#define P3RX_TEXREADMODE_TEXELSIZE_8                    0
#define P3RX_TEXREADMODE_TEXELSIZE_16                   1
#define P3RX_TEXREADMODE_TEXELSIZE_32                   2
#define P3RX_TEXREADMODE_TEXELSIZE_64                   3
#define P3RX_TEXREADMODE_TEXTURETYPE_NORMAL             0
#define P3RX_TEXREADMODE_TEXTURETYPE_8BITINDEXED        1
#define P3RX_TEXREADMODE_TEXTURETYPE_422_YVYU           2
#define P3RX_TEXREADMODE_TEXTURETYPE_422_VYUY           3

// Texture index mode
#define P3RX_TEXINDEXMODE_WRAP_CLAMP                    0
#define P3RX_TEXINDEXMODE_WRAP_REPEAT                   1
#define P3RX_TEXINDEXMODE_WRAP_MIRROR                   2
#define P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE                3
#define P3RX_TEXINDEXMODE_MAPTYPE_1D                    0
#define P3RX_TEXINDEXMODE_MAPTYPE_2D                    1
#define P3RX_TEXINDEXMODE_FILTER_NEAREST                0
#define P3RX_TEXINDEXMODE_FILTER_LINEAR                 1
#define P3RX_TEXINDEXMODE_FILTER_NEARESTMIPNEAREST      2
#define P3RX_TEXINDEXMODE_FILTER_NEARESTMIPLINEAR       3
#define P3RX_TEXINDEXMODE_FILTER_LINEARMIPNEAREST       4
#define P3RX_TEXINDEXMODE_FILTER_LINEARMIPLINEAR        5
#define P3RX_TEXINDEXMODE_BIAS_MINUSHALF                0
#define P3RX_TEXINDEXMODE_BIAS_ZERO                     1
#define P3RX_TEXINDEXMODE_BIAS_PLUSHALF                 2

// Texture read unit
#define P3RX_TEXREADMODE_TEXELSIZE_8                    0
#define P3RX_TEXREADMODE_TEXELSIZE_16                   1
#define P3RX_TEXREADMODE_TEXELSIZE_32                   2
#define P3RX_TEXREADMODE_TEXELSIZE_64SPAN               3
#define P3RX_TEXREADMODE_ORIGIN_TOPLEFT                 0
#define P3RX_TEXREADMODE_ORIGIN_BOTTOMLEFT              1
#define P3RX_TEXREADMODE_TEXTURETYPE_NORMAL             0
#define P3RX_TEXREADMODE_TEXTURETYPE_8BITINDEXED        1
#define P3RX_TEXREADMODE_TEXTURETYPE_YVYU422            2
#define P3RX_TEXREADMODE_TEXTURETYPE_VYUY422            3
#define P3RX_TEXREADMODE_BYTESWAP_NONE                  0
#define P3RX_TEXREADMODE_BYTESWAP_ABCDEFGH              0
#define P3RX_TEXREADMODE_BYTESWAP_BADCFEHG              1
#define P3RX_TEXREADMODE_BYTESWAP_CDABGHEF              2
#define P3RX_TEXREADMODE_BYTESWAP_DCBAHGFE              3
#define P3RX_TEXREADMODE_BYTESWAP_EFGHABCD              4
#define P3RX_TEXREADMODE_BYTESWAP_FEHGBADC              5
#define P3RX_TEXREADMODE_BYTESWAP_GHEFCDAB              6
#define P3RX_TEXREADMODE_BYTESWAP_HGFEDCBA              7

// Texture Application
#define P3RX_TEXAPP_A_CC                            0
#define P3RX_TEXAPP_A_CA                            1
#define P3RX_TEXAPP_A_KC                            2
#define P3RX_TEXAPP_A_KA                            3

#define P3RX_TEXAPP_B_TC                            0
#define P3RX_TEXAPP_B_TA                            1
#define P3RX_TEXAPP_B_KC                            2
#define P3RX_TEXAPP_B_KA                            3

#define P3RX_TEXAPP_I_CA                            0
#define P3RX_TEXAPP_I_KA                            1
#define P3RX_TEXAPP_I_TC                            2
#define P3RX_TEXAPP_I_TA                            3

#define P3RX_TEXAPP_OPERATION_PASS_A                0
#define P3RX_TEXAPP_OPERATION_PASS_B                1
#define P3RX_TEXAPP_OPERATION_ADD_AB                2
#define P3RX_TEXAPP_OPERATION_MODULATE_AB           3
#define P3RX_TEXAPP_OPERATION_LERP_ABI              4
#define P3RX_TEXAPP_OPERATION_MODULATE_AB_ADD_I     5
#define P3RX_TEXAPP_OPERATION_MODULATE_AI_ADD_B     6
#define P3RX_TEXAPP_OPERATION_MODULATE_BI_ADD_A     7

// Texture composite
// 0 and 1 are the current colour on the second stage,
// and the heightfield emboss mode on the first.
// Note that HEIGHTC=HEIGHTA
#define P3RX_TEXCOMP_OC                         0
#define P3RX_TEXCOMP_OA                         1
#define P3RX_TEXCOMP_HEIGHTC                    0
#define P3RX_TEXCOMP_HEIGHTA                    1
#define P3RX_TEXCOMP_CC                         2
#define P3RX_TEXCOMP_CA                         3
#define P3RX_TEXCOMP_FC                         4
#define P3RX_TEXCOMP_FA                         5
#define P3RX_TEXCOMP_T0C                        6
#define P3RX_TEXCOMP_T0A                        7
#define P3RX_TEXCOMP_T1C                        8
#define P3RX_TEXCOMP_T1A                        9
#define P3RX_TEXCOMP_SUM                        10

// HA = height. Same as output.a on first stage.
#define P3RX_TEXCOMP_I_OA                           0
#define P3RX_TEXCOMP_I_HA                           0
#define P3RX_TEXCOMP_I_CA                           1
#define P3RX_TEXCOMP_I_FA                           2
#define P3RX_TEXCOMP_I_T0A                          3
#define P3RX_TEXCOMP_I_T1A                          4

// These need to be renamed to P3RX_TEXCOMP_AB_ARGx for consistency.
#define P3RX_TEXCOMP_ARG1                           0
#define P3RX_TEXCOMP_ARG2                           1

#define P3RX_TEXCOMP_OPERATION_PASS_A                   0
#define P3RX_TEXCOMP_OPERATION_ADD_AB                   1
#define P3RX_TEXCOMP_OPERATION_ADDSIGNED_AB             2
#define P3RX_TEXCOMP_OPERATION_SUBTRACT_AB              3
#define P3RX_TEXCOMP_OPERATION_MODULATE_AB              4
#define P3RX_TEXCOMP_OPERATION_LERP_ABI                 5
#define P3RX_TEXCOMP_OPERATION_MODULATE_AB_ADD_I        6
#define P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B        7
#define P3RX_TEXCOMP_OPERATION_ADD_AB_SUB_MODULATE_AB   8
#define P3RX_TEXCOMP_OPERATION_MODULATE_SIGNED_AB       9

// These need to be renamed P3RX_TEXCOMP_SCALE_xxx
#define P3RX_TEXCOMP_OPERATION_SCALE_HALF               0
#define P3RX_TEXCOMP_OPERATION_SCALE_ONE                1
#define P3RX_TEXCOMP_OPERATION_SCALE_TWO                2
#define P3RX_TEXCOMP_OPERATION_SCALE_FOUR               3

// Render
#define P3RX_RENDER_PRIMITIVETYPE_LINE                  0
#define P3RX_RENDER_PRIMITIVETYPE_TRAPEZOID             1
#define P3RX_RENDER_PRIMITIVETYPE_POINT                 2
#define P3RX_RENDER_ANTIALIASINGQUALITY_4X4             0
#define P3RX_RENDER_ANTIALIASINGQUALITY_8X8             1

// 2D Render operations.
#define P3RX_RENDER2D_OPERATION_NORMAL                  0
#define P3RX_RENDER2D_OPERATION_SYNC_ON_HOST_DATA       1
#define P3RX_RENDER2D_OPERATION_SYNC_ON_BIT_MASK        2
#define P3RX_RENDER2D_OPERATION_PATCH_ORDER_RENDERING   3
#define P3RX_RENDER2D_SPAN_CONSTANT                     0
#define P3RX_RENDER2D_SPAN_VARIABLE                     1

// For P3RX_ALPHABLENDxxxMODE
#define P3RX_ALPHABLENDMODE_SRCBLEND_ZERO           0
#define P3RX_ALPHABLENDMODE_SRCBLEND_ONE            1
#define P3RX_ALPHABLENDMODE_SRCBLEND_DSTCOLOR       2
#define P3RX_ALPHABLENDMODE_SRCBLEND_INVDSTCOLOR    3
#define P3RX_ALPHABLENDMODE_SRCBLEND_SRCALPHA       4
#define P3RX_ALPHABLENDMODE_SRCBLEND_INVSRCALPHA    5
#define P3RX_ALPHABLENDMODE_SRCBLEND_DSTALPHA       6
#define P3RX_ALPHABLENDMODE_SRCBLEND_INVDSTALPHA    7
#define P3RX_ALPHABLENDMODE_SRCBLEND_SRCALPHASAT    8

#define P3RX_ALPHABLENDMODE_DSTBLEND_ZERO           0
#define P3RX_ALPHABLENDMODE_DSTBLEND_ONE            1
#define P3RX_ALPHABLENDMODE_DSTBLEND_SRCCOLOR       2
#define P3RX_ALPHABLENDMODE_DSTBLEND_INVSRCCOLOR    3
#define P3RX_ALPHABLENDMODE_DSTBLEND_SRCALPHA       4
#define P3RX_ALPHABLENDMODE_DSTBLEND_INVSRCALPHA    5
#define P3RX_ALPHABLENDMODE_DSTBLEND_DSTALPHA       6
#define P3RX_ALPHABLENDMODE_DSTBLEND_INVDSTALPHA    7

#define P3RX_ALPHABLENDMODE_COLORORDER_BGR          0
#define P3RX_ALPHABLENDMODE_COLORORDER_RGB          1
#define P3RX_ALPHABLENDMODE_ALPHATYPE_OGL           0
#define P3RX_ALPHABLENDMODE_ALPHATYPE_APPLE         1
// Both colour and alpha channels.
#define P3RX_ALPHABLENDMODE_CONVERT_SCALE           0
#define P3RX_ALPHABLENDMODE_CONVERT_SHIFT           1
#define P3RX_ALPHABLENDMODE_OPERATION_ADD           0
#define P3RX_ALPHABLENDMODE_OPERATION_SSUBD         1
#define P3RX_ALPHABLENDMODE_OPERATION_DSUBS         2
#define P3RX_ALPHABLENDMODE_OPERATION_MIN           3
#define P3RX_ALPHABLENDMODE_OPERATION_MAX           4

// Alpha Blending
#define P3RX_ALPHABLENDMODE_COLORFORMAT_8888        P3RX_DITHERMODE_COLORFORMAT_8888
#define P3RX_ALPHABLENDMODE_COLORFORMAT_4444        P3RX_DITHERMODE_COLORFORMAT_4444
#define P3RX_ALPHABLENDMODE_COLORFORMAT_5551        P3RX_DITHERMODE_COLORFORMAT_5551
#define P3RX_ALPHABLENDMODE_COLORFORMAT_565         P3RX_DITHERMODE_COLORFORMAT_565
#define P3RX_ALPHABLENDMODE_COLORFORMAT_332         P3RX_DITHERMODE_COLORFORMAT_332
#define P3RX_ALPHABLENDMODE_COLORFORMAT_CI          P3RX_DITHERMODE_COLORFORMAT_CI
#define P3RX_ALPHABLENDMODE_COLORFORMAT_ILLEGAL     P3RX_DITHERMODE_COLORFORMAT_ILLEGAL

// For P3RX_CHROMATESTMODE_SOURCE
#define P3RX_CHROMATESTMODE_SOURCE_FBSOURCEDATA     0
#define P3RX_CHROMATESTMODE_SOURCE_FBDATA           1
#define P3RX_CHROMATESTMODE_SOURCE_INPUTCOLOR       2
#define P3RX_CHROMATESTMODE_SOURCE_OUTPUTCOLOR      3
// For P3RX_CHROMATESTMODE_FAILACTION and P3_CHROMATESTMODE_PASSACTION
#define P3RX_CHROMATESTMODE_ACTION_PASS                         0
#define P3RX_CHROMATESTMODE_ACTION_REJECT                       1
#define P3RX_CHROMATESTMODE_ACTION_SUBSTITUTEPASSCOLOR          2
#define P3RX_CHROMATESTMODE_ACTION_SUBSTITUTEFAILCOLOR          3

// For P3RX_TEXFILTERMODE_ALPHAMAPSENSEx
#define P3RX_ALPHAMAPSENSE_OUTOFRANGE               0
#define P3RX_ALPHAMAPSENSE_INRANGE                  1

// For P3RX_TEXCOORDMODE_ WRAPS, WRAPT, WRAPS1, WRAPT1
#define P3RX_TEXCOORDMODE_WRAP_CLAMP                0
#define P3RX_TEXCOORDMODE_WRAP_REPEAT               1
#define P3RX_TEXCOORDMODE_WRAP_MIRROR               2

#define P3RX_TEXCOORDMODE_OPERATION_2D              0
#define P3RX_TEXCOORDMODE_OPERATION_3D              1

#define P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_1D         0
#define P3RX_TEXCOORDMODE_TEXTUREMAPTYPE_2D         1

// LUT Mode
#define P3RX_LUTMODE_INCOLORORDER_BGR               0
#define P3RX_LUTMODE_INCOLORORDER_RGB               1

#define P3RX_LUTMODE_LOADFORMAT_COPY                0
#define P3RX_LUTMODE_LOADFORMAT_565REPLICATE        1
#define P3RX_LUTMODE_LOADFORMAT_5551REPLICATE       2

#define P3RX_LUTMODE_LOADCOLORORDER_BGR             0
#define P3RX_LUTMODE_LOADCOLORORDER_RGB             1

#define P3RX_LUTMODE_FRAGMENTOP_NONE                0
#define P3RX_LUTMODE_FRAGMENTOP_INDEXEDTEXTURE      1
#define P3RX_LUTMODE_FRAGMENTOP_TRANSLATE8TO32      2
#define P3RX_LUTMODE_FRAGMENTOP_TRANSLATE32TO32     3
#define P3RX_LUTMODE_FRAGMENTOP_MOTIONCOMP          4
#define P3RX_LUTMODE_FRAGMENTOP_PATTERN             5

#define P3RX_LUTMODE_SPANOP_NONE                    0
#define P3RX_LUTMODE_SPANOP_SPANPATTERN             1
#define P3RX_LUTMODE_SPANOP_TRANSLATE8TO8           2
#define P3RX_LUTMODE_SPANOP_TRANSLATE8TO16          3
#define P3RX_LUTMODE_SPANOP_TRANSLATE8TO32          4
#define P3RX_LUTMODE_SPANOP_TRANSLATE32TO32         5

// Used for P3RX_LUTMODE_SPAN[V|C]CXALIGN
#define P3RX_LUTMODE_ALIGNMENT_ABSOLOUTE            0
#define P3RX_LUTMODE_ALIGNMENT_RELATIVE             1


// Alpha test unit
#define P3RX_ANTIALIASMODE_COLORMODE_RGBA           0
#define P3RX_ANTIALIASMODE_COLORMODE_CI             1

#define P3RX_ALPHATESTMODE_COMPARE_NEVER            0
#define P3RX_ALPHATESTMODE_COMPARE_LESS             1
#define P3RX_ALPHATESTMODE_COMPARE_EQUAL            2
#define P3RX_ALPHATESTMODE_COMPARE_LESSEQUAL        3
#define P3RX_ALPHATESTMODE_COMPARE_GREATER          4
#define P3RX_ALPHATESTMODE_COMPARE_NOTEQUAL         5
#define P3RX_ALPHATESTMODE_COMPARE_GREATEREQUAL     6
#define P3RX_ALPHATESTMODE_COMPARE_ALWAYS           7

// Fogging
#define P3RX_FOGMODE_COLORMODE_RGB                  0
#define P3RX_FOGMODE_COLORMODE_CI                   1

// Framebuffer write mode
#define P3RX_FBWRITEMODE_ORIGIN_TOPLEFT             0
#define P3RX_FBWRITEMODE_ORIGIN_BOTTOMLEFT          1

// Shared
#define P3RX_STRIPE_1                               0
#define P3RX_STRIPE_2                               1
#define P3RX_STRIPE_4                               2
#define P3RX_STRIPE_8                               3
#define P3RX_STRIPE_16                              4
#define P3RX_STRIPE_32                              5
#define P3RX_STRIPE_64                              6
#define P3RX_STRIPE_128                             7

#define P3RX_LAYOUT_LINEAR                          0
#define P3RX_LAYOUT_PATCH64                         1
#define P3RX_LAYOUT_PATCH32_2                       2
#define P3RX_LAYOUT_PATCH2                          3

// Color DDA fields
#define P3RX_COLORDDA_FLATSHADE                     0
#define P3RX_COLORDDA_GOURAUDSHADE                  1

#define P3RX_DEPTH_WIDTH_16                         0
#define P3RX_DEPTH_WIDTH_24                         1
#define P3RX_DEPTH_WIDTH_32                         2
#define P3RX_DEPTH_WIDTH_15                         3

#define P3RX_STENCIL_WIDTH_0                        0
#define P3RX_STENCIL_WIDTH_1                        1
#define P3RX_STENCIL_WIDTH_2                        2
#define P3RX_STENCIL_WIDTH_3                        3
#define P3RX_STENCIL_WIDTH_4                        4
#define P3RX_STENCIL_WIDTH_5                        5
#define P3RX_STENCIL_WIDTH_6                        6
#define P3RX_STENCIL_WIDTH_7                        7
#define P3RX_STENCIL_WIDTH_8                        8

#define P3RX_STENCIL_POSITION_16                    0
#define P3RX_STENCIL_POSITION_17                    1
#define P3RX_STENCIL_POSITION_18                    2
#define P3RX_STENCIL_POSITION_19                    3
#define P3RX_STENCIL_POSITION_20                    4
#define P3RX_STENCIL_POSITION_21                    5
#define P3RX_STENCIL_POSITION_22                    6
#define P3RX_STENCIL_POSITION_23                    7
#define P3RX_STENCIL_POSITION_24                    8
#define P3RX_STENCIL_POSITION_25                    9
#define P3RX_STENCIL_POSITION_26                    10
#define P3RX_STENCIL_POSITION_27                    11
#define P3RX_STENCIL_POSITION_28                    12
#define P3RX_STENCIL_POSITION_29                    13
#define P3RX_STENCIL_POSITION_30                    14
#define P3RX_STENCIL_POSITION_31                    15
#define P3RX_STENCIL_POSITION_32                    16
#define P3RX_STENCIL_POSITION_33                    17
#define P3RX_STENCIL_POSITION_34                    18
#define P3RX_STENCIL_POSITION_35                    19
#define P3RX_STENCIL_POSITION_36                    20
#define P3RX_STENCIL_POSITION_37                    21
#define P3RX_STENCIL_POSITION_38                    22
#define P3RX_STENCIL_POSITION_39                    23

// FilterMode
#define P3RX_FILTERMODE_BYTESWAP_ABCD               0
#define P3RX_FILTERMODE_BYTESWAP_BADC               1
#define P3RX_FILTERMODE_BYTESWAP_CDAB               2
#define P3RX_FILTERMODE_BYTESWAP_DCBA               3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\linalloc.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: linalloc.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __LINALLOC_H_
#define __LINALLOC_H_


// Result values from calls to videomem allocator functions
#define GLDD_FAILED             ((DWORD)(-1))
#define GLDD_SUCCESS            0
#define GLDD_NOMEM              1
#define GLDD_INVALIDARGS        2
#define GLDD_FREE_REFERENCE     3

typedef struct tagMEMREQUEST
{
    DWORD dwSize;     // Size of this structure
    DWORD dwFlags;    // Flags for this allocation
    DWORD dwAlign;    // Alignment (minimum 4 Bytes)
    DWORD dwBytes;    // Bytes to allocated (aligned up to DWORD multiples)
    DWORD pMem;       // Pointer to the start of the memory returned

} P3_MEMREQUEST, *LPMEMREQUEST;

// P3_MEMREQUEST.dwFlags values for memory allocation
// Favour which end of memory?
#define MEM3DL_FRONT                    1
#define MEM3DL_BACK                     2
// Allocation strategy
#define MEM3DL_FIRST_FIT                8

typedef struct LinearAllocatorInfo;
typedef void (*LinearAllocatorCallbackFn)( DWORD, DWORD );

// Video local memory allocation functions
BOOL _DX_LIN_InitialiseHeapManager(LinearAllocatorInfo* pAlloc,
                                   DWORD dwMemStar, DWORD dwMemEnd);
void _DX_LIN_UnInitialiseHeapManager(LinearAllocatorInfo* pAlloc);
DWORD _DX_LIN_GetFreeMemInHeap(LinearAllocatorInfo* pAlloc);
DWORD _DX_LIN_AllocateLinearMemory(LinearAllocatorInfo* pAlloc,
                                   LPMEMREQUEST lpmmrq);
DWORD _DX_LIN_FreeLinearMemory(LinearAllocatorInfo* pAlloc, 
                               DWORD dwPointer);

// We will use a bitwise memory map to keep track of used & free memory
// (The size of this structure will be for now 32K , which will give us
// a total of 256K chunks, which for a 32MB heap means each chunk 
// controls 128 bytes)
#define MEMORY_MAP_SIZE (32*1024)/sizeof(DWORD)

typedef DWORD MemoryMap[MEMORY_MAP_SIZE]; // Chunks memory map 

typedef struct tagHashTable HashTable; // Forward decl when referenced from GDI

typedef struct tagLinearAllocatorInfo
{
    BOOL  bResetLinAllocator;         // Bool to signal us the allocators
                                      //  have been reset from the 16 bit side
    DWORD dwMemStart;                 // Start of the managed memory
    DWORD dwMemEnd;                   // End of the managed memory
    DWORD dwMaxChunks;                // Max # of chunks (can't exceed 
                                      //  MEMORY_MAP_SIZE*CHUNKS_PER_ELEM)
    DWORD dwMemPerChunk;              // How much heap memory each chunk
                                      //  controls
    MemoryMap *pMMap;                 // Ptr to allocations memory map
    MemoryMap *pLenMap;               // Ptr to lenghts memory map so we don't
                                      // have to keep the sizes allocated to 
                                      // each request 
} LinearAllocatorInfo;


#endif // __LINALLOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\p2rd.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: p2rd.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// structure with all the direct access registers
typedef struct _p2rd_regs
{
    RAMDAC_REG  RDPaletteWriteAddress;
    RAMDAC_REG  RDPaletteData;
    RAMDAC_REG  RDPixelMask;
    RAMDAC_REG  RDPaletteAddressRead;
    RAMDAC_REG  RDIndexLow;
    RAMDAC_REG  RDIndexHigh;
    RAMDAC_REG  RDIndexedData;
    RAMDAC_REG  RDIndexControl;
}
P2RDRAMDAC, pP2RDRAMDAC;

// macro declared by any function wishing to use the RGB525 RAMDAC. MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define P2RD_DECL \
    P2RDRAMDAC   *pP2RDRegs = (P2RDRAMDAC *)&(pDev->pRegisters->Glint.ExtVCReg)
#else
#define P2RD_DECL \
    P2RDRAMDAC   *pP2RDRegs = (P2RDRAMDAC *)&(pRegisters->Glint.ExtVCReg)
#endif

#if P3R3DX_VIDEO
#define VideoDebugPrint(arg)
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
#define P2RD_PAL_WR_ADDR              ((PULONG)&(pP2RDRegs->RDPaletteWriteAddress.reg))
#define P2RD_PAL_RD_ADDR              ((PULONG)&(pP2RDRegs->RDPaletteAddressRead.reg))
#define P2RD_PAL_DATA                 ((PULONG)&(pP2RDRegs->RDPaletteData.reg))
#define P2RD_PIXEL_MASK               ((PULONG)&(pP2RDRegs->RDPixelMask.reg))
#define P2RD_INDEX_ADDR_LO            ((PULONG)&(pP2RDRegs->RDIndexLow.reg))
#define P2RD_INDEX_ADDR_HI            ((PULONG)&(pP2RDRegs->RDIndexHigh.reg))
#define P2RD_INDEX_DATA               ((PULONG)&(pP2RDRegs->RDIndexedData.reg))
#define P2RD_INDEX_CONTROL            ((PULONG)&(pP2RDRegs->RDIndexControl.reg))

// bit field definitions for the direct access registers
#define P2RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

// indexed register definitions accessed via P2RD_LOAD_INDEX_REG() and P2RD_READ_INDEX_REG()
#define P2RD_MISC_CONTROL               0x0000
#define P2RD_SYNC_CONTROL               0x0001
#define P2RD_DAC_CONTROL                0x0002
#define P2RD_PIXEL_SIZE                 0x0003
#define P2RD_COLOR_FORMAT               0x0004
#define P2RD_CURSOR_MODE                0x0005
#define P2RD_CURSOR_CONTROL             0x0006
#define P2RD_CURSOR_X_LOW               0x0007
#define P2RD_CURSOR_X_HIGH              0x0008
#define P2RD_CURSOR_Y_LOW               0x0009
#define P2RD_CURSOR_Y_HIGH              0x000a
#define P2RD_CURSOR_HOTSPOT_X           0x000b
#define P2RD_CURSOR_HOTSPOT_Y           0x000c
#define P2RD_OVERLAY_KEY                0x000d
#define P2RD_PAN                        0x000e
#define P2RD_SENSE                      0x000f
#define P2RD_CHECK_CONTROL              0x0018
#define P2RD_CHECK_PIXEL_RED            0x0019
#define P2RD_CHECK_PIXEL_GREEN          0x001a
#define P2RD_CHECK_PIXEL_BLUE           0x001b
#define P2RD_CHECK_LUT_RED              0x001c
#define P2RD_CHECK_LUT_GREEN            0x001d
#define P2RD_CHECK_LUT_BLUE             0x001e
#define P2RD_DCLK_SETUP_1               0x01f0
#define P2RD_DCLK_SETUP_2               0x01f1
#define P2RD_MCLK_SETUP_1               0x01f2
#define P2RD_MCLK_SETUP_2               0x01f3
#define P2RD_DCLK_CONTROL               0x0200
#define P2RD_DCLK0_PRE_SCALE            0x0201
#define P2RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P2RD_DCLK0_POST_SCALE           0x0203
#define P2RD_DCLK1_PRE_SCALE            0x0204
#define P2RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P2RD_DCLK1_POST_SCALE           0x0206
#define P2RD_DCLK2_PRE_SCALE            0x0207
#define P2RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P2RD_DCLK2_POST_SCALE           0x0209
#define P2RD_DCLK3_PRE_SCALE            0x020a
#define P2RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P2RD_DCLK3_POST_SCALE           0x020c
#define P2RD_MCLK_CONTROL               0x020d
#define P2RD_MCLK_PRE_SCALE             0x020e
#define P2RD_MCLK_FEEDBACK_SCALE        0x020f
#define P2RD_MCLK_POST_SCALE            0x0210
#define P2RD_CURSOR_PALETTE_START       0x0303      // 303..32f
#define P2RD_CURSOR_PATTERN_START       0x0400      // 400..7ff

// bit field definitions for the indexed registers
#define P2RD_MISC_CONTROL_OVERLAYS_ENABLED      0x10
#define P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED  0x08
#define P2RD_MISC_CONTROL_HIGHCOLORRES          0x01

#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW  0x00
#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH 0x08
#define P2RD_SYNC_CONTROL_VSYNC_OFF         0x20
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW  0x00
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH 0x01
#define P2RD_SYNC_CONTROL_HSYNC_OFF         0x04

#define P2RD_DAC_CONTROL_LOW_POWER      0x01
#define P2RD_DAC_CONTROL_SYNC_ON_GREEN  0x08
#define P2RD_DAC_CONTROL_BLANK_RED      0x10
#define P2RD_DAC_CONTROL_BLANK_GREEN    0x20
#define P2RD_DAC_CONTROL_BLANK_BLUE     0x40
#define P2RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED 0x80

#define P2RD_PIXEL_SIZE_8BPP            0x00
#define P2RD_PIXEL_SIZE_16BPP           0x01
#define P2RD_PIXEL_SIZE_24_BPP          0x04
#define P2RD_PIXEL_SIZE_32BPP           0x02

#define P2RD_COLOR_FORMAT_CI8           0x0e
#define P2RD_COLOR_FORMAT_8BPP          0x25
#define P2RD_COLOR_FORMAT_15BPP         0x21
#define P2RD_COLOR_FORMAT_16BPP         0x30
#define P2RD_COLOR_FORMAT_32BPP         0x20
#define P2RD_COLOR_FORMAT_LINEAR_EXT    0x40

#define P2RD_CURSOR_MODE_REVERSE        0x40
#define P2RD_CURSOR_MODE_WINDOWS        0x00
#define P2RD_CURSOR_MODE_X              0x10
#define P2RD_CURSOR_MODE_3COLOR         0x20
#define P2RD_CURSOR_MODE_15COLOR        0x30
#define P2RD_CURSOR_MODE_64x64          0x00
#define P2RD_CURSOR_MODE_P0_32x32x2     0x02
#define P2RD_CURSOR_MODE_P1_32x32x2     0x04
#define P2RD_CURSOR_MODE_P2_32x32x2     0x06
#define P2RD_CURSOR_MODE_P3_32x32x2     0x08
#define P2RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P2RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P2RD_CURSOR_MODE_ENABLED        0x01
#define P2RD_CURSOR_MODE_OFF            0x00

#define P2RD_CURSOR_CONTROL_RPOS_ENABLED    0x04
#define P2RD_CURSOR_CONTROL_DOUBLE_Y        0x02
#define P2RD_CURSOR_CONTROL_DOUBLE_X        0x01

// Windows format byte-packed cursor data: each byte represents 4 consecutive pixels
#define P2RD_CURSOR_2_COLOR_BLACK           0x00
#define P2RD_CURSOR_2_COLOR_WHITE           0x55
#define P2RD_CURSOR_2_COLOR_TRANSPARENT     0xAA
#define P2RD_CURSOR_2_COLOR_HIGHLIGHT       0xFF

// cursor sizes
#define P2RD_CURSOR_SIZE_64_MONO    0
#define P2RD_CURSOR_SIZE_32_MONO    1
#define P2RD_CURSOR_SIZE_32_3COLOR  5
#define P2RD_CURSOR_SEL(cursorSize, cursorIndex) (((cursorSize + cursorIndex) & 7) << 1)

#define P2RD_DCLK_CONTROL_LOCKED    0x02    // read-only
#define P2RD_DCLK_CONTROL_ENABLED   0x01
#define P2RD_DCLK_CONTROL_RUN       0x08

#define P2RD_MCLK_CONTROL_LOCKED    0x02    // read-only
#define P2RD_MCLK_CONTROL_ENABLED   0x01
#define P2RD_MCLK_CONTROL_RUN       0x08

#define P2RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}


#if 0
// need a delay between each write to the P2RD. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
#define P2RD_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}
#else
#define P2RD_DELAY
#endif

// macro to load a given data value into an internal P2RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define P2RD_INDEX_REG(index) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P2RD_INDEX_ADDR_LO, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P2RD_DELAY; \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P2RD_INDEX_ADDR_HI, (index) >> 8)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P2RD_DELAY; \
}

#define P2RD_LOAD_DATA(data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P2RD_DELAY; \
}

#define P2RD_LOAD_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", P2RD_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P2RD_DELAY; \
}

#define P2RD_READ_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    data = (BYTE) (VideoPortReadRegisterUlong(P2RD_INDEX_DATA) & 0xff);   \
    P2RD_DELAY; \
    VideoDebugPrint(("0x%x <-- *(0x%x)\n", data, P2RD_INDEX_DATA)); \
}

#define P2RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA,    (ULONG)(data));   \
    P2RD_DELAY; \
}

// macros to load a given RGB triple into the P2RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P2RD_PALETTE_START and multiple P2RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P2RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define P2RD_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P2RD_DELAY; \
}

#define P2RD_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P2RD_DELAY; \
}

#define P2RD_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(red));      \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(green));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(blue));     \
    P2RD_DELAY; \
}

#define P2RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_WR_ADDR, (ULONG)(index));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(red));      \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(green));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(blue));     \
    P2RD_DELAY; \
}

// macro to read back a given RGB triple from the P2RD palette. Use after
// a call to P2RD_PALETTE_START_RD
//
#define P2RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
}

#define P2RD_SET_INDEX_CONTROL(mask) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_CONTROL, (ULONG)(mask)); \
    P2RD_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define P2RD_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PIXEL_MASK,  (ULONG)(mask)); \
    P2RD_DELAY; \
}

#define P2RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(P2RD_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array usage is P2RD_CURSOR_ARRAR_START() followed by 
// n iterations of P2RD_LOAD_CURSOR_ARRAY() or P2RD_READ_CURSOR_ARRAY()
//
#define P2RD_CURSOR_ARRAY_START(offset) \
{ \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) & 0xff));  \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) >> 8));    \
    P2RD_DELAY; \
}

#define P2RD_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)(data)); \
    P2RD_DELAY; \
}

#define P2RD_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(P2RD_INDEX_DATA) & 0xff; \
    P2RD_DELAY; \
}

// macro to move the cursor
//
#define P2RD_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI, (ULONG)0);              \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define P2RD_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\ramdac.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: ramdac.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// RAMDAC registers live on 64 bit boundaries. Leave it up to individual
// RAMDAC definitions to determine what registers are available and how
// many bits wide the registers really are.
//
typedef struct {
    volatile unsigned long   reg;
    volatile unsigned long   pad;
} RAMDAC_REG;



#include "rgb525.h"
#include "tvp3026.h"
#include "tvp4020.h"
#include "p2rd.h"
#include "p3rd.h"

//
// Supported RAMDAC definitions.
//

#define     RGB525_RAMDAC       0
#define     RGB526_RAMDAC       1
#define     RGB526DB_RAMDAC     2
#define     RGB528_RAMDAC       3
#define     RGB528A_RAMDAC      4
#define     RGB524_RAMDAC       6
#define     RGB524A_RAMDAC      7

#define     TVP3026_RAMDAC      50
#define     TVP3030_RAMDAC      51

#define     TVP4020_RAMDAC      100

#define     P2RD_RAMDAC         200
#define     P3RD_RAMDAC         201

// P3R3DX_VIDEO is defined in video.c (gldd dir)
#if MINIVDD || (P3R3DX_VIDEO == 1)
#define VideoPortWriteRegisterUlong(dst, value) (*((volatile unsigned long *) dst)) = value
#else

// Use emits to turn 16 bit instructions into 32 bit instructions.
// _asm  _emit 66h  _asm xor   bx,bx    ->  xor ebx, ebx
#define VideoPortWriteRegisterUlong(dst, value) {   \
    DWORD lVal = value, *lDst = dst;                \
    _asm  _emit 66h  _asm xor   bx,bx               \
                     _asm les   bx, lDst            \
    _asm  _emit 66h  _asm mov   ax, WORD PTR lVal   \
    _asm  _emit 66h  _asm mov   es:[bx], ax         \
}

#endif
#define VideoPortReadRegisterUlong(dst) *((volatile unsigned long *)dst)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\pmdef.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: pmdef.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// This file containes defines for values that are filled into fields on Permedia
// The file glintdef.h is the equivalent for glint chips.

// These defines are typically used in conjunction with the macros in bitmac2.h, 
// which shift the values to their correct locations.

#ifndef __PMDEF_H
#define __PMDEF_H

// Texture unit bit fields
#define PM_TEXMAPFORMAT_TEXELSIZE 19

// Dither unit bit fields
#define PM_DITHERMODE_ENABLE 0
#define PM_DITHERMODE_DITHERENABLE 1
#define PM_DITHERMODE_COLORFORMAT 2
#define PM_DITHERMODE_XOFFSET 6
#define PM_DITHERMODE_YOFFSET 8
#define PM_DITHERMODE_COLORORDER 10
#define PM_DITHERMODE_DITHERMETHOD 11
#define PM_DITHERMODE_FORCEALPHA 12
#define PM_DITHERMODE_COLORFORMATEXTENSION 16

// VSA Control
#define PM_VSACONTROL_DISCARD_1             1
#define PM_VSACONTROL_DISCARD_2             2

#endif // __PMDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\reg.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: reg.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __REG_H
#define __REG_H

#ifndef _REG_H_
#define _REG_H_

typedef signed long signed32;
typedef unsigned long unsigned32;

struct DMATag {
#if BIG_ENDIAN == 1
  unsigned32 Mask                                :16;
  unsigned32 Mode                                :2;
  unsigned32                                     :1;
  unsigned32 MajorGroup                          :9;
  unsigned32 Offset                              :4;
#else
  unsigned32 Offset                              :4;
  unsigned32 MajorGroup                          :9;
  unsigned32                                     :1;
  unsigned32 Mode                                :2;
  unsigned32 Mask                                :16;
#endif
#ifdef __cplusplus
  DMATag(void) { }
  DMATag(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMATag& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMATag& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMATag& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0x3<<14|0x1ff<<4|0xf<<0)); }
#endif /* __cplusplus */
};

struct Render {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 FBSourceReadEnable                  :1;
  unsigned32 dErr                                :7;
  unsigned32                                     :1;
  unsigned32 SpanOperation                       :1;
  unsigned32                                     :1;
  unsigned32 SubpixelCorrectionEnable            :1;
  unsigned32 CoverageEnable                      :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 SyncOnBitMask                       :1;
  unsigned32 UsePointTable                       :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 PrimitiveType                       :2;
  unsigned32                                     :2;
  unsigned32 FastFillEnable                      :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 LineStippleEnable                   :1;
  unsigned32 AreaStippleEnable                   :1;
#else
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 LineStippleEnable                   :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 FastFillEnable                      :1;
  unsigned32                                     :2;
  unsigned32 PrimitiveType                       :2;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 UsePointTable                       :1;
  unsigned32 SyncOnBitMask                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 CoverageEnable                      :1;
  unsigned32 SubpixelCorrectionEnable            :1;
  unsigned32                                     :1;
  unsigned32 SpanOperation                       :1;
  unsigned32                                     :1;
  unsigned32 dErr                                :7;
  unsigned32 FBSourceReadEnable                  :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  Render(void) { }
  Render(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Render& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Render& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Render& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x7f<<20|0x1<<18|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x3<<6|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct RasterizerMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 UseSuspendReads                     :1;
  unsigned32 D3DRules                            :1;
  unsigned32 MultiRXBlit                         :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 WordPacking                         :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 BitMaskRelative                     :1;
  unsigned32 YLimitsEnable                       :1;
  unsigned32 MultiGLINT                          :1;
  unsigned32 HostDataByteSwapMode                :2;
  unsigned32 BitMaskOffset                       :5;
  unsigned32 BitMaskPacking                      :1;
  unsigned32 BitMaskByteSwapMode                 :2;
  unsigned32 ForceBackgroundColor                :1;
  unsigned32 BiasCoordinates                     :2;
  unsigned32 FractionAdjust                      :2;
  unsigned32 InvertBitMask                       :1;
  unsigned32 MirrorBitMask                       :1;
#else
  unsigned32 MirrorBitMask                       :1;
  unsigned32 InvertBitMask                       :1;
  unsigned32 FractionAdjust                      :2;
  unsigned32 BiasCoordinates                     :2;
  unsigned32 ForceBackgroundColor                :1;
  unsigned32 BitMaskByteSwapMode                 :2;
  unsigned32 BitMaskPacking                      :1;
  unsigned32 BitMaskOffset                       :5;
  unsigned32 HostDataByteSwapMode                :2;
  unsigned32 MultiGLINT                          :1;
  unsigned32 YLimitsEnable                       :1;
  unsigned32 BitMaskRelative                     :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 WordPacking                         :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 MultiRXBlit                         :1;
  unsigned32 D3DRules                            :1;
  unsigned32 UseSuspendReads                     :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  RasterizerMode(void) { }
  RasterizerMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RasterizerMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RasterizerMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RasterizerMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x1<<26|0x1<<25|0x1<<24|0x1<<23|0x7<<20|0x1<<19|0x1<<18|0x1<<17|0x3<<15|0x1f<<10|0x1<<9|0x3<<7|0x1<<6|0x3<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct YLimits {
#if BIG_ENDIAN == 1
  signed32   MaxY                                :16;
  signed32   MinY                                :16;
#else
  signed32   MinY                                :16;
  signed32   MaxY                                :16;
#endif
#ifdef __cplusplus
  YLimits(void) { }
  YLimits(const unsigned32 i) { *((unsigned32 *)this) = i; }
  YLimits& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  YLimits& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  YLimits& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct GlintScanlineOwnership {
#if BIG_ENDIAN == 1
  unsigned32                                     :27;
  unsigned32 Scanline                            :3;
  unsigned32 ScanlineInterval                    :2;
#else
  unsigned32 ScanlineInterval                    :2;
  unsigned32 Scanline                            :3;
  unsigned32                                     :27;
#endif
#ifdef __cplusplus
  GlintScanlineOwnership(void) { }
  GlintScanlineOwnership(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintScanlineOwnership& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintScanlineOwnership& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintScanlineOwnership& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct ScanlineOwnership {
#if BIG_ENDIAN == 1
  unsigned32                                     :26;
  unsigned32 MyId                                :3;
  unsigned32 Mask                                :3;
#else
  unsigned32 Mask                                :3;
  unsigned32 MyId                                :3;
  unsigned32                                     :26;
#endif
#ifdef __cplusplus
  ScanlineOwnership(void) { }
  ScanlineOwnership(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ScanlineOwnership& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ScanlineOwnership& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ScanlineOwnership& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct GlintPixelSize {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 Size                                :2;
#else
  unsigned32 Size                                :2;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  GlintPixelSize(void) { }
  GlintPixelSize(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintPixelSize& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintPixelSize& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintPixelSize& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<0)); }
#endif /* __cplusplus */
};

struct PixelSize {
#if BIG_ENDIAN == 1
  unsigned32 Setting                             :1;
  unsigned32                                     :13;
  unsigned32 TwoDSetupUnit                       :2;
  unsigned32 FBWriteUnit                         :2;
  unsigned32 LogicalOpsUnit                      :2;
  unsigned32 FBReadUnit                          :2;
  unsigned32 LUTUnit                             :2;
  unsigned32 TextureUnit                         :2;
  unsigned32 ScissorUnit                         :2;
  unsigned32 RasterizerUnit                      :2;
  unsigned32 AllUnits                            :2;
#else
  unsigned32 AllUnits                            :2;
  unsigned32 RasterizerUnit                      :2;
  unsigned32 ScissorUnit                         :2;
  unsigned32 TextureUnit                         :2;
  unsigned32 LUTUnit                             :2;
  unsigned32 FBReadUnit                          :2;
  unsigned32 LogicalOpsUnit                      :2;
  unsigned32 FBWriteUnit                         :2;
  unsigned32 TwoDSetupUnit                       :2;
  unsigned32                                     :13;
  unsigned32 Setting                             :1;
#endif
#ifdef __cplusplus
  PixelSize(void) { }
  PixelSize(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PixelSize& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PixelSize& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PixelSize& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x3<<16|0x3<<14|0x3<<12|0x3<<10|0x3<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct StripeOffsetY {
#if BIG_ENDIAN == 1
  unsigned32                                     :16;
  unsigned32 Offset                              :16;
#else
  unsigned32 Offset                              :16;
  unsigned32                                     :16;
#endif
#ifdef __cplusplus
  StripeOffsetY(void) { }
  StripeOffsetY(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StripeOffsetY& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StripeOffsetY& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StripeOffsetY& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<0)); }
#endif /* __cplusplus */
};

struct ReadMonitorMode {
#if BIG_ENDIAN == 1
  signed32   StripeOffset                        :16;
  unsigned32                                     :8;
  unsigned32 HashFunction                        :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 HashFunction                        :1;
  unsigned32                                     :8;
  signed32   StripeOffset                        :16;
#endif
#ifdef __cplusplus
  ReadMonitorMode(void) { }
  ReadMonitorMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ReadMonitorMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ReadMonitorMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ReadMonitorMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0x1<<7|0x7<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct XY {
#if BIG_ENDIAN == 1
  signed32   Y                                   :16;
  signed32   X                                   :16;
#else
  signed32   X                                   :16;
  signed32   Y                                   :16;
#endif
#ifdef __cplusplus
  XY(void) { }
  XY(const unsigned32 i) { *((unsigned32 *)this) = i; }
  XY& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  XY& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  XY& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct UXY {
#if BIG_ENDIAN == 1
  unsigned32 Y                                   :16;
  unsigned32 X                                   :16;
#else
  unsigned32 X                                   :16;
  unsigned32 Y                                   :16;
#endif
#ifdef __cplusplus
  UXY(void) { }
  UXY(const unsigned32 i) { *((unsigned32 *)this) = i; }
  UXY& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  UXY& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  UXY& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct ScissorMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 ScreenScissorEnable                 :1;
  unsigned32 UserScissorEnable                   :1;
#else
  unsigned32 UserScissorEnable                   :1;
  unsigned32 ScreenScissorEnable                 :1;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  ScissorMode(void) { }
  ScissorMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ScissorMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ScissorMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ScissorMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct AreaStippleMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 YTableOffset                        :5;
  unsigned32 XTableOffset                        :5;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 MirrorY                             :1;
  unsigned32 MirrorX                             :1;
  unsigned32 InvertStipplePattern                :1;
  unsigned32 YOffset                             :5;
  unsigned32 XOffset                             :5;
  unsigned32 YAddressSelect                      :3;
  unsigned32 XAddressSelect                      :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 XAddressSelect                      :3;
  unsigned32 YAddressSelect                      :3;
  unsigned32 XOffset                             :5;
  unsigned32 YOffset                             :5;
  unsigned32 InvertStipplePattern                :1;
  unsigned32 MirrorX                             :1;
  unsigned32 MirrorY                             :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 XTableOffset                        :5;
  unsigned32 YTableOffset                        :5;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  AreaStippleMode(void) { }
  AreaStippleMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AreaStippleMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AreaStippleMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AreaStippleMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<26|0x1f<<21|0x1<<20|0x1<<19|0x1<<18|0x1<<17|0x1f<<12|0x1f<<7|0x7<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LineStippleMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :5;
  unsigned32 Mirror                              :1;
  unsigned32 StippleMask                         :16;
  unsigned32 RepeatFactor                        :9;
  unsigned32 StippleEnable                       :1;
#else
  unsigned32 StippleEnable                       :1;
  unsigned32 RepeatFactor                        :9;
  unsigned32 StippleMask                         :16;
  unsigned32 Mirror                              :1;
  unsigned32                                     :5;
#endif
#ifdef __cplusplus
  LineStippleMode(void) { }
  LineStippleMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LineStippleMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LineStippleMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LineStippleMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<26|0xffff<<10|0x1ff<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Line {
#if BIG_ENDIAN == 1
  unsigned32                                     :6;
  unsigned32 SegmentRepeatCounter                :9;
  unsigned32 SegmentBitCounter                   :4;
  unsigned32 LiveRepeatCounter                   :9;
  unsigned32 LiveBitCounter                      :4;
#else
  unsigned32 LiveBitCounter                      :4;
  unsigned32 LiveRepeatCounter                   :9;
  unsigned32 SegmentBitCounter                   :4;
  unsigned32 SegmentRepeatCounter                :9;
  unsigned32                                     :6;
#endif
#ifdef __cplusplus
  Line(void) { }
  Line(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Line& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Line& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Line& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1ff<<17|0xf<<13|0x1ff<<4|0xf<<0)); }
#endif /* __cplusplus */
};

struct GlintTextureAddressMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 TextureMapType                      :1;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 EnableDY                            :1;
  unsigned32 EnableLOD                           :1;
  unsigned32 InhibitDDAInitialization            :1;
  unsigned32 Operation                           :1;
  unsigned32 TWrap                               :2;
  unsigned32 SWrap                               :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SWrap                               :2;
  unsigned32 TWrap                               :2;
  unsigned32 Operation                           :1;
  unsigned32 InhibitDDAInitialization            :1;
  unsigned32 EnableLOD                           :1;
  unsigned32 EnableDY                            :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 TextureMapType                      :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  GlintTextureAddressMode(void) { }
  GlintTextureAddressMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintTextureAddressMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintTextureAddressMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintTextureAddressMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0xf<<13|0xf<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PermediaTextureAddressMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 PerspectiveCorrection               :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 PerspectiveCorrection               :1;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  PermediaTextureAddressMode(void) { }
  PermediaTextureAddressMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PermediaTextureAddressMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PermediaTextureAddressMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PermediaTextureAddressMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureCoordMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :9;
  unsigned32 DuplicateCoord                      :1;
  unsigned32 WrapT1                              :2;
  unsigned32 WrapS1                              :2;
  unsigned32 TextureMapType                      :1;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 EnableDY                            :1;
  unsigned32 EnableLOD                           :1;
  unsigned32 InhibitDDAInitialisation            :1;
  unsigned32 Operation                           :1;
  unsigned32 WrapT                               :2;
  unsigned32 WrapS                               :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 WrapS                               :2;
  unsigned32 WrapT                               :2;
  unsigned32 Operation                           :1;
  unsigned32 InhibitDDAInitialisation            :1;
  unsigned32 EnableLOD                           :1;
  unsigned32 EnableDY                            :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 TextureMapType                      :1;
  unsigned32 WrapS1                              :2;
  unsigned32 WrapT1                              :2;
  unsigned32 DuplicateCoord                      :1;
  unsigned32                                     :9;
#endif
#ifdef __cplusplus
  TextureCoordMode(void) { }
  TextureCoordMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureCoordMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureCoordMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureCoordMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<22|0x3<<20|0x3<<18|0x1<<17|0xf<<13|0xf<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GlintLOD {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Integer                             :4;
  unsigned32 Fraction                            :8;
#else
  unsigned32 Fraction                            :8;
  unsigned32 Integer                             :4;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  GlintLOD(void) { }
  GlintLOD(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintLOD& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintLOD& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintLOD& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct LOD {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 Value                               :4;
#else
  unsigned32 Value                               :4;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  LOD(void) { }
  LOD(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LOD& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LOD& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LOD& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<0)); }
#endif /* __cplusplus */
};

struct LOD1 {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 LOD                                 :12;
#else
  unsigned32 LOD                                 :12;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  LOD1(void) { }
  LOD1(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LOD1& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LOD1& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LOD1& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<0)); }
#endif /* __cplusplus */
};

struct TextureLODBias {
#if BIG_ENDIAN == 1
  unsigned32                                     :19;
  signed32   Integer                             :5;
  unsigned32 Fraction                            :8;
#else
  unsigned32 Fraction                            :8;
  signed32   Integer                             :5;
  unsigned32                                     :19;
#endif
#ifdef __cplusplus
  TextureLODBias(void) { }
  TextureLODBias(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureLODBias& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureLODBias& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureLODBias& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct GlintTextureReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 BorderClamp                         :1;
  unsigned32 FBSourceAddr                        :2;
  unsigned32 PrimaryCache                        :1;
  unsigned32 MipMap                              :1;
  unsigned32 TextureMapType                      :1;
  unsigned32 VWrap                               :2;
  unsigned32 UWrap                               :2;
  unsigned32 MinFilter                           :3;
  unsigned32 MagFilter                           :1;
  unsigned32 Patch                               :1;
  unsigned32 Border                              :1;
  unsigned32 Depth                               :3;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 Depth                               :3;
  unsigned32 Border                              :1;
  unsigned32 Patch                               :1;
  unsigned32 MagFilter                           :1;
  unsigned32 MinFilter                           :3;
  unsigned32 UWrap                               :2;
  unsigned32 VWrap                               :2;
  unsigned32 TextureMapType                      :1;
  unsigned32 MipMap                              :1;
  unsigned32 PrimaryCache                        :1;
  unsigned32 FBSourceAddr                        :2;
  unsigned32 BorderClamp                         :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  GlintTextureReadMode(void) { }
  GlintTextureReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintTextureReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintTextureReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintTextureReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x3<<25|0x1<<24|0x1<<23|0x1<<22|0x3<<20|0x3<<18|0x7<<15|0x1<<14|0x1<<13|0x1<<12|0x7<<9|0xf<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 Invert                              :1;
  unsigned32 Mirror                              :1;
  unsigned32 ByteSwap                            :3;
  unsigned32 TextureType                         :2;
  unsigned32 Origin                              :1;
  unsigned32 LogicalTexture                      :1;
  unsigned32 MapMaxLevel                         :4;
  unsigned32 MapBaseLevel                        :4;
  unsigned32 CombineCaches                       :1;
  unsigned32 Texture3D                           :1;
  unsigned32 TexelSize                           :2;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 TexelSize                           :2;
  unsigned32 Texture3D                           :1;
  unsigned32 CombineCaches                       :1;
  unsigned32 MapBaseLevel                        :4;
  unsigned32 MapMaxLevel                         :4;
  unsigned32 LogicalTexture                      :1;
  unsigned32 Origin                              :1;
  unsigned32 TextureType                         :2;
  unsigned32 ByteSwap                            :3;
  unsigned32 Mirror                              :1;
  unsigned32 Invert                              :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  TextureReadMode(void) { }
  TextureReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<30|0x1<<29|0x1<<28|0x7<<25|0x3<<23|0x1<<22|0x1<<21|0xf<<17|0xf<<13|0x1<<12|0x1<<11|0x3<<9|0xf<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :12;
  unsigned32 OneCompFormat                       :2;
  unsigned32 LUTOffset                           :8;
  unsigned32 ByteSwapBitMask                     :1;
  unsigned32 InvertBitMask                       :1;
  unsigned32 MirrorBitMask                       :1;
  unsigned32 OutputFormat                        :2;
  unsigned32 NumberComps                         :2;
  unsigned32 ColorOrder                          :1;
  unsigned32 Format                              :1;
  unsigned32 Order                               :1;
#else
  unsigned32 Order                               :1;
  unsigned32 Format                              :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 NumberComps                         :2;
  unsigned32 OutputFormat                        :2;
  unsigned32 MirrorBitMask                       :1;
  unsigned32 InvertBitMask                       :1;
  unsigned32 ByteSwapBitMask                     :1;
  unsigned32 LUTOffset                           :8;
  unsigned32 OneCompFormat                       :2;
  unsigned32                                     :12;
#endif
#ifdef __cplusplus
  TextureFormat(void) { }
  TextureFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<18|0xff<<10|0x1<<9|0x1<<8|0x1<<7|0x3<<5|0x3<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TexelLUTIndex {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Index                               :8;
#else
  unsigned32 Index                               :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  TexelLUTIndex(void) { }
  TexelLUTIndex(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TexelLUTIndex& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TexelLUTIndex& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TexelLUTIndex& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct LUTIndex {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Index                               :8;
#else
  unsigned32 Index                               :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  LUTIndex(void) { }
  LUTIndex(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LUTIndex& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LUTIndex& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LUTIndex& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct TexelLUTTransfer {
#if BIG_ENDIAN == 1
  unsigned32                                     :15;
  unsigned32 Count                               :9;
  unsigned32 Index                               :8;
#else
  unsigned32 Index                               :8;
  unsigned32 Count                               :9;
  unsigned32                                     :15;
#endif
#ifdef __cplusplus
  TexelLUTTransfer(void) { }
  TexelLUTTransfer(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TexelLUTTransfer& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TexelLUTTransfer& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TexelLUTTransfer& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1ff<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct LUTTransfer {
#if BIG_ENDIAN == 1
  unsigned32                                     :17;
  unsigned32 Count                               :7;
  unsigned32 Index                               :8;
#else
  unsigned32 Index                               :8;
  unsigned32 Count                               :7;
  unsigned32                                     :17;
#endif
#ifdef __cplusplus
  LUTTransfer(void) { }
  LUTTransfer(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LUTTransfer& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LUTTransfer& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LUTTransfer& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7f<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct GlintTextureFilterMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 AlphaMapSense                       :1;
  unsigned32 AlphaMapEnable                      :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 AlphaMapEnable                      :1;
  unsigned32 AlphaMapSense                       :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  GlintTextureFilterMode(void) { }
  GlintTextureFilterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintTextureFilterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintTextureFilterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintTextureFilterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureFilterMode {
#if BIG_ENDIAN == 1
  unsigned32 Shift1                              :1;
  unsigned32 Shift0                              :1;
  unsigned32 ForceAlphaToOne1                    :1;
  unsigned32 ForceAlphaToOne0                    :1;
  unsigned32 MultiTexture                        :1;
  unsigned32 AlphaMapFilterLimit01               :4;
  unsigned32 AlphaMapFilterLimit1                :3;
  unsigned32 AlphaMapFilterLimit0                :3;
  unsigned32 AlphaMapFiltering                   :1;
  unsigned32 AlphaMapSense1                      :1;
  unsigned32 AlphaMapEnable1                     :1;
  unsigned32 ColorOrder1                         :1;
  unsigned32 Format1                             :4;
  unsigned32 CombineCaches                       :1;
  unsigned32 AlphaMapSense0                      :1;
  unsigned32 AlphaMapEnable0                     :1;
  unsigned32 ColorOrder0                         :1;
  unsigned32 Format0                             :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Format0                             :4;
  unsigned32 ColorOrder0                         :1;
  unsigned32 AlphaMapEnable0                     :1;
  unsigned32 AlphaMapSense0                      :1;
  unsigned32 CombineCaches                       :1;
  unsigned32 Format1                             :4;
  unsigned32 ColorOrder1                         :1;
  unsigned32 AlphaMapEnable1                     :1;
  unsigned32 AlphaMapSense1                      :1;
  unsigned32 AlphaMapFiltering                   :1;
  unsigned32 AlphaMapFilterLimit0                :3;
  unsigned32 AlphaMapFilterLimit1                :3;
  unsigned32 AlphaMapFilterLimit01               :4;
  unsigned32 MultiTexture                        :1;
  unsigned32 ForceAlphaToOne0                    :1;
  unsigned32 ForceAlphaToOne1                    :1;
  unsigned32 Shift0                              :1;
  unsigned32 Shift1                              :1;
#endif
#ifdef __cplusplus
  TextureFilterMode(void) { }
  TextureFilterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureFilterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureFilterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureFilterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0x1<<27|0xf<<23|0x7<<20|0x7<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0xf<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureMapFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :10;
  unsigned32 TexelSize                           :3;
  unsigned32                                     :1;
  unsigned32 SubPatchMode                        :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32                                     :7;
  unsigned32 PP2                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP0                                 :3;
#else
  unsigned32 PP0                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP2                                 :3;
  unsigned32                                     :7;
  unsigned32 WindowOrigin                        :1;
  unsigned32 SubPatchMode                        :1;
  unsigned32                                     :1;
  unsigned32 TexelSize                           :3;
  unsigned32                                     :10;
#endif
#ifdef __cplusplus
  TextureMapFormat(void) { }
  TextureMapFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureMapFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureMapFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureMapFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<19|0x1<<17|0x1<<16|0x7<<6|0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct TextureDataFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :23;
  unsigned32 SpanFormat                          :1;
  unsigned32 AlphaMap                            :1;
  unsigned32 TextureFormatExtension              :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 TextureFormat                       :4;
#else
  unsigned32 TextureFormat                       :4;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 TextureFormatExtension              :1;
  unsigned32 AlphaMap                            :1;
  unsigned32 SpanFormat                          :1;
  unsigned32                                     :23;
#endif
#ifdef __cplusplus
  TextureDataFormat(void) { }
  TextureDataFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureDataFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureDataFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureDataFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0xf<<0)); }
#endif /* __cplusplus */
};

struct PermediaTextureReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :7;
  unsigned32 PackedData                          :1;
  unsigned32                                     :6;
  unsigned32 FilterMode                          :1;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32                                     :4;
  unsigned32 TWrap                               :2;
  unsigned32 SWrap                               :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SWrap                               :2;
  unsigned32 TWrap                               :2;
  unsigned32                                     :4;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 FilterMode                          :1;
  unsigned32                                     :6;
  unsigned32 PackedData                          :1;
  unsigned32                                     :7;
#endif
#ifdef __cplusplus
  PermediaTextureReadMode(void) { }
  PermediaTextureReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PermediaTextureReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PermediaTextureReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PermediaTextureReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<24|0x1<<17|0xf<<13|0xf<<9|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TexelLUTMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 PixelsPerEntry                      :2;
  unsigned32 Offset                              :8;
  unsigned32 DirectIndex                         :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 DirectIndex                         :1;
  unsigned32 Offset                              :8;
  unsigned32 PixelsPerEntry                      :2;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  TexelLUTMode(void) { }
  TexelLUTMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TexelLUTMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TexelLUTMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TexelLUTMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<10|0xff<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureColorMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 ColorLoadMode                       :2;
  unsigned32 BaseFormat                          :3;
  unsigned32 KsDDA                               :1;
  unsigned32 KdDDA                               :1;
  unsigned32 TextureType                         :1;
  unsigned32 ApplicationMode                     :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 ApplicationMode                     :3;
  unsigned32 TextureType                         :1;
  unsigned32 KdDDA                               :1;
  unsigned32 KsDDA                               :1;
  unsigned32 BaseFormat                          :3;
  unsigned32 ColorLoadMode                       :2;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  TextureColorMode(void) { }
  TextureColorMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureColorMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureColorMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureColorMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<10|0x7<<7|0x1<<6|0x1<<5|0x1<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureApplicationMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 MotionCompEnable                    :1;
  unsigned32 EnableKs                            :1;
  unsigned32 EnableKd                            :1;
  unsigned32 AlphaOperation                      :3;
  unsigned32 AlphaInvertI                        :1;
  unsigned32 AlphaI                              :2;
  unsigned32 AlphaB                              :2;
  unsigned32 AlphaA                              :2;
  unsigned32 ColorOperation                      :3;
  unsigned32 ColorInvertI                        :1;
  unsigned32 ColorI                              :2;
  unsigned32 ColorB                              :2;
  unsigned32 ColorA                              :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 ColorA                              :2;
  unsigned32 ColorB                              :2;
  unsigned32 ColorI                              :2;
  unsigned32 ColorInvertI                        :1;
  unsigned32 ColorOperation                      :3;
  unsigned32 AlphaA                              :2;
  unsigned32 AlphaB                              :2;
  unsigned32 AlphaI                              :2;
  unsigned32 AlphaInvertI                        :1;
  unsigned32 AlphaOperation                      :3;
  unsigned32 EnableKd                            :1;
  unsigned32 EnableKs                            :1;
  unsigned32 MotionCompEnable                    :1;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  TextureApplicationMode(void) { }
  TextureApplicationMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureApplicationMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureApplicationMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureApplicationMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<23|0x1<<22|0x1<<21|0x7<<18|0x1<<17|0x3<<15|0x3<<13|0x3<<11|0x7<<8|0x1<<7|0x3<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FogMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :22;
  unsigned32 InvertFI                            :1;
  unsigned32 ZShift                              :5;
  unsigned32 UseZ                                :1;
  unsigned32 Table                               :1;
  unsigned32 ColorMode                           :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 ColorMode                           :1;
  unsigned32 Table                               :1;
  unsigned32 UseZ                                :1;
  unsigned32 ZShift                              :5;
  unsigned32 InvertFI                            :1;
  unsigned32                                     :22;
#endif
#ifdef __cplusplus
  FogMode(void) { }
  FogMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FogMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FogMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FogMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<9|0x1f<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct ColorDDAMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 Shading                             :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Shading                             :1;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  ColorDDAMode(void) { }
  ColorDDAMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ColorDDAMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ColorDDAMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ColorDDAMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Color {
#if BIG_ENDIAN == 1
  unsigned32 Alpha                               :8;
  unsigned32 Blue                                :8;
  unsigned32 Green                               :8;
  unsigned32 Red                                 :8;
#else
  unsigned32 Red                                 :8;
  unsigned32 Green                               :8;
  unsigned32 Blue                                :8;
  unsigned32 Alpha                               :8;
#endif
#ifdef __cplusplus
  Color(void) { }
  Color(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Color& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Color& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Color& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<24|0xff<<16|0xff<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct AlphaTestMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Reference                           :8;
  unsigned32 Compare                             :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Compare                             :3;
  unsigned32 Reference                           :8;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  AlphaTestMode(void) { }
  AlphaTestMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AlphaTestMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AlphaTestMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AlphaTestMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct AntialiasMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 ScaleColor                          :1;
  unsigned32 ColorMode                           :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 ColorMode                           :1;
  unsigned32 ScaleColor                          :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  AntialiasMode(void) { }
  AntialiasMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AntialiasMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AntialiasMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AntialiasMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GlintAlphaBlendMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 AlphaConversion                     :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 AlphaDestination                    :1;
  unsigned32 AlphaType                           :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 DestinationBlend                    :3;
  unsigned32 SourceBlend                         :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SourceBlend                         :4;
  unsigned32 DestinationBlend                    :3;
  unsigned32 ColorFormat                         :4;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 AlphaType                           :1;
  unsigned32 AlphaDestination                    :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 AlphaConversion                     :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  GlintAlphaBlendMode(void) { }
  GlintAlphaBlendMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintAlphaBlendMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintAlphaBlendMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintAlphaBlendMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0xf<<8|0x7<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PermediaAlphaBlendMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :13;
  unsigned32 AlphaConversion                     :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 ColorFormatExtension                :1;
  unsigned32                                     :1;
  unsigned32 BlendType                           :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 Operation                           :7;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Operation                           :7;
  unsigned32 ColorFormat                         :4;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BlendType                           :1;
  unsigned32                                     :1;
  unsigned32 ColorFormatExtension                :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 AlphaConversion                     :1;
  unsigned32                                     :13;
#endif
#ifdef __cplusplus
  PermediaAlphaBlendMode(void) { }
  PermediaAlphaBlendMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PermediaAlphaBlendMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PermediaAlphaBlendMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PermediaAlphaBlendMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<18|0x1<<17|0x1<<16|0x1<<14|0x1<<13|0x1<<12|0xf<<8|0x7f<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct DitherMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :15;
  unsigned32 RoundingMode                        :2;
  unsigned32 AlphaDither                         :1;
  unsigned32                                     :3;
  unsigned32 ColorOrder                          :1;
  unsigned32 Yoffset                             :2;
  unsigned32 Xoffset                             :2;
  unsigned32 ColorFormat                         :4;
  unsigned32 DitherEnable                        :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 DitherEnable                        :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 Xoffset                             :2;
  unsigned32 Yoffset                             :2;
  unsigned32 ColorOrder                          :1;
  unsigned32                                     :3;
  unsigned32 AlphaDither                         :1;
  unsigned32 RoundingMode                        :2;
  unsigned32                                     :15;
#endif
#ifdef __cplusplus
  DitherMode(void) { }
  DitherMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DitherMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DitherMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DitherMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<15|0x1<<14|0x1<<10|0x3<<8|0x3<<6|0xf<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LogicalOpMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :19;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 UseConstantSource                   :1;
  unsigned32 BackgroundLogicalOp                 :4;
  unsigned32 BackgroundEnable                    :1;
  unsigned32 UseConstantFBWriteData              :1;
  unsigned32 LogicOp                             :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 LogicOp                             :4;
  unsigned32 UseConstantFBWriteData              :1;
  unsigned32 BackgroundEnable                    :1;
  unsigned32 BackgroundLogicalOp                 :4;
  unsigned32 UseConstantSource                   :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32                                     :19;
#endif
#ifdef __cplusplus
  LogicalOpMode(void) { }
  LogicalOpMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LogicalOpMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LogicalOpMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LogicalOpMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<12|0x1<<11|0xf<<7|0x1<<6|0x1<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct RouterMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Order                               :1;
#else
  unsigned32 Order                               :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  RouterMode(void) { }
  RouterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RouterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RouterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RouterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct LBReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 PP3                                 :3;
  unsigned32 PatchCode                           :3;
  unsigned32 ScanlineInterval                    :2;
  unsigned32 Patch                               :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32 DataType                            :2;
  unsigned32                                     :5;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 PP2                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP0                                 :3;
#else
  unsigned32 PP0                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP2                                 :3;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32                                     :5;
  unsigned32 DataType                            :2;
  unsigned32 WindowOrigin                        :1;
  unsigned32 Patch                               :1;
  unsigned32 ScanlineInterval                    :2;
  unsigned32 PatchCode                           :3;
  unsigned32 PP3                                 :3;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  LBReadMode(void) { }
  LBReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<25|0x7<<22|0x3<<20|0x1<<19|0x1<<18|0x3<<16|0x1<<10|0x1<<9|0x7<<6|0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct GlintPermediaLBReadFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 Compact32                           :1;
  unsigned32 GIDPosition                         :4;
  unsigned32 GIDWidth                            :1;
  unsigned32 FrameCountPosition                  :3;
  unsigned32 FrameCountWidth                     :2;
  unsigned32 StencilPosition                     :3;
  unsigned32 StencilWidth                        :2;
  unsigned32 DepthWidth                          :2;
#else
  unsigned32 DepthWidth                          :2;
  unsigned32 StencilWidth                        :2;
  unsigned32 StencilPosition                     :3;
  unsigned32 FrameCountWidth                     :2;
  unsigned32 FrameCountPosition                  :3;
  unsigned32 GIDWidth                            :1;
  unsigned32 GIDPosition                         :4;
  unsigned32 Compact32                           :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  GlintPermediaLBReadFormat(void) { }
  GlintPermediaLBReadFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintPermediaLBReadFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintPermediaLBReadFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintPermediaLBReadFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0xf<<13|0x1<<12|0x7<<9|0x3<<7|0x7<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct LBReadFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 GIDPosition                         :5;
  unsigned32 GIDWidth                            :3;
  unsigned32 FCPPosition                         :5;
  unsigned32 FCPWidth                            :4;
  unsigned32 StencilPosition                     :5;
  unsigned32 StencilWidth                        :4;
  unsigned32 DepthWidth                          :2;
#else
  unsigned32 DepthWidth                          :2;
  unsigned32 StencilWidth                        :4;
  unsigned32 StencilPosition                     :5;
  unsigned32 FCPWidth                            :4;
  unsigned32 FCPPosition                         :5;
  unsigned32 GIDWidth                            :3;
  unsigned32 GIDPosition                         :5;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  LBReadFormat(void) { }
  LBReadFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBReadFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBReadFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBReadFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<23|0x7<<20|0x1f<<15|0xf<<11|0x1f<<6|0xf<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct LBSourceOffset {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Offset                              :24;
#else
  unsigned32 Offset                              :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  LBSourceOffset(void) { }
  LBSourceOffset(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBSourceOffset& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBSourceOffset& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBSourceOffset& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct LBWindowBase {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Base                                :24;
#else
  unsigned32 Base                                :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  LBWindowBase(void) { }
  LBWindowBase(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBWindowBase& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBWindowBase& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBWindowBase& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct P2MXLBWriteMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 UpLoadData                          :2;
  unsigned32 WriteEnable                         :1;
#else
  unsigned32 WriteEnable                         :1;
  unsigned32 UpLoadData                          :2;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  P2MXLBWriteMode(void) { }
  P2MXLBWriteMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  P2MXLBWriteMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  P2MXLBWriteMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  P2MXLBWriteMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LBWriteMode {
#if BIG_ENDIAN == 1
  unsigned32 Operation                           :3;
  unsigned32 ByteEnables                         :5;
  unsigned32 Width                               :12;
  unsigned32 Packed16                            :1;
  unsigned32 Origin                              :1;
  unsigned32 Layout                              :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32                                     :2;
  unsigned32 WriteEnable                         :1;
#else
  unsigned32 WriteEnable                         :1;
  unsigned32                                     :2;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Layout                              :1;
  unsigned32 Origin                              :1;
  unsigned32 Packed16                            :1;
  unsigned32 Width                               :12;
  unsigned32 ByteEnables                         :5;
  unsigned32 Operation                           :3;
#endif
#ifdef __cplusplus
  LBWriteMode(void) { }
  LBWriteMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBWriteMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBWriteMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBWriteMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<29|0x1f<<24|0xfff<<12|0x1<<11|0x1<<10|0x1<<9|0x7<<6|0x7<<3|0x1<<0)); }
#endif /* __cplusplus */
};

struct LBWriteFormat {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 GIDPosition                         :5;
  unsigned32 GIDWidth                            :3;
  unsigned32 FCPPosition                         :5;
  unsigned32 FCPWidth                            :4;
  unsigned32 StencilPosition                     :5;
  unsigned32 StencilWidth                        :4;
  unsigned32 DepthWidth                          :2;
#else
  unsigned32 DepthWidth                          :2;
  unsigned32 StencilWidth                        :4;
  unsigned32 StencilPosition                     :5;
  unsigned32 FCPWidth                            :4;
  unsigned32 FCPPosition                         :5;
  unsigned32 GIDWidth                            :3;
  unsigned32 GIDPosition                         :5;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  LBWriteFormat(void) { }
  LBWriteFormat(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBWriteFormat& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBWriteFormat& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBWriteFormat& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<23|0x7<<20|0x1f<<15|0xf<<11|0x1f<<6|0xf<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct HostInState2 {
#if BIG_ENDIAN == 1
  unsigned32                                     :27;
  unsigned32 TagCount                            :5;
#else
  unsigned32 TagCount                            :5;
  unsigned32                                     :27;
#endif
#ifdef __cplusplus
  HostInState2(void) { }
  HostInState2(const unsigned32 i) { *((unsigned32 *)this) = i; }
  HostInState2& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  HostInState2& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  HostInState2& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<0)); }
#endif /* __cplusplus */
};

struct VertexRename {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 Rename                              :3;
#else
  unsigned32 Rename                              :3;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  VertexRename(void) { }
  VertexRename(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexRename& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexRename& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexRename& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<0)); }
#endif /* __cplusplus */
};

struct Window {
#if BIG_ENDIAN == 1
  unsigned32                                     :12;
  unsigned32 OverrideWriteFiltering              :1;
  unsigned32 DepthFCP                            :1;
  unsigned32 StencilFCP                          :1;
  unsigned32 FrameCount                          :8;
  unsigned32 GID                                 :4;
  unsigned32 LBUpdateSource                      :1;
  unsigned32 ForceLBUpdate                       :1;
  unsigned32 CompareMode                         :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 CompareMode                         :2;
  unsigned32 ForceLBUpdate                       :1;
  unsigned32 LBUpdateSource                      :1;
  unsigned32 GID                                 :4;
  unsigned32 FrameCount                          :8;
  unsigned32 StencilFCP                          :1;
  unsigned32 DepthFCP                            :1;
  unsigned32 OverrideWriteFiltering              :1;
  unsigned32                                     :12;
#endif
#ifdef __cplusplus
  Window(void) { }
  Window(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Window& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Window& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Window& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<19|0x1<<18|0x1<<17|0xff<<9|0xf<<5|0x1<<4|0x1<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct StencilMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :13;
  unsigned32 StencilWidth                        :4;
  unsigned32 StencilSource                       :2;
  unsigned32 CompareFunction                     :3;
  unsigned32 SFail                               :3;
  unsigned32 DPFail                              :3;
  unsigned32 DPPass                              :3;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 DPPass                              :3;
  unsigned32 DPFail                              :3;
  unsigned32 SFail                               :3;
  unsigned32 CompareFunction                     :3;
  unsigned32 StencilSource                       :2;
  unsigned32 StencilWidth                        :4;
  unsigned32                                     :13;
#endif
#ifdef __cplusplus
  StencilMode(void) { }
  StencilMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StencilMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StencilMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StencilMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<15|0x3<<13|0x7<<10|0x7<<7|0x7<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct StencilData {
#if BIG_ENDIAN == 1
  unsigned32 FCStencil                           :8;
  unsigned32 StencilWriteMask                    :8;
  unsigned32 CompareMask                         :8;
  unsigned32 ReferenceValue                      :8;
#else
  unsigned32 ReferenceValue                      :8;
  unsigned32 CompareMask                         :8;
  unsigned32 StencilWriteMask                    :8;
  unsigned32 FCStencil                           :8;
#endif
#ifdef __cplusplus
  StencilData(void) { }
  StencilData(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StencilData& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StencilData& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StencilData& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<24|0xff<<16|0xff<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct Stencil {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 StencilValue                        :8;
#else
  unsigned32 StencilValue                        :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  Stencil(void) { }
  Stencil(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Stencil& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Stencil& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Stencil& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct DepthMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :17;
  unsigned32 ExponentWidth                       :2;
  unsigned32 ExponentScale                       :2;
  unsigned32 NonLinearZ                          :1;
  unsigned32 Normalise                           :1;
  unsigned32 Width                               :2;
  unsigned32 CompareMode                         :3;
  unsigned32 NewDepthSource                      :2;
  unsigned32 WriteMask                           :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 WriteMask                           :1;
  unsigned32 NewDepthSource                      :2;
  unsigned32 CompareMode                         :3;
  unsigned32 Width                               :2;
  unsigned32 Normalise                           :1;
  unsigned32 NonLinearZ                          :1;
  unsigned32 ExponentScale                       :2;
  unsigned32 ExponentWidth                       :2;
  unsigned32                                     :17;
#endif
#ifdef __cplusplus
  DepthMode(void) { }
  DepthMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DepthMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DepthMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DepthMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<13|0x3<<11|0x1<<10|0x1<<9|0x3<<7|0x7<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GlintFBReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :2;
  unsigned32 SourceAddressFunction               :2;
  unsigned32 PP3                                 :3;
  unsigned32 ScanlineInterval                    :2;
  unsigned32                                     :6;
  unsigned32 WindowOrigin                        :1;
  unsigned32 DataType                            :1;
  unsigned32                                     :4;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 PP2                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP0                                 :3;
#else
  unsigned32 PP0                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP2                                 :3;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32                                     :4;
  unsigned32 DataType                            :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32                                     :6;
  unsigned32 ScanlineInterval                    :2;
  unsigned32 PP3                                 :3;
  unsigned32 SourceAddressFunction               :2;
  unsigned32                                     :2;
#endif
#ifdef __cplusplus
  GlintFBReadMode(void) { }
  GlintFBReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintFBReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintFBReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintFBReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<28|0x7<<25|0x3<<23|0x1<<16|0x1<<15|0x1<<10|0x1<<9|0x7<<6|0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct PermediaFBReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :5;
  unsigned32 PatchMode                           :2;
  unsigned32                                     :2;
  unsigned32 RelativeOffset                      :3;
  unsigned32 PackedData                          :1;
  unsigned32 PatchEnable                         :1;
  unsigned32                                     :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32 DataType                            :1;
  unsigned32                                     :4;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 PP2                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP0                                 :3;
#else
  unsigned32 PP0                                 :3;
  unsigned32 PP1                                 :3;
  unsigned32 PP2                                 :3;
  unsigned32 ReadSourceEnable                    :1;
  unsigned32 ReadDestinationEnable               :1;
  unsigned32                                     :4;
  unsigned32 DataType                            :1;
  unsigned32 WindowOrigin                        :1;
  unsigned32                                     :1;
  unsigned32 PatchEnable                         :1;
  unsigned32 PackedData                          :1;
  unsigned32 RelativeOffset                      :3;
  unsigned32                                     :2;
  unsigned32 PatchMode                           :2;
  unsigned32                                     :5;
#endif
#ifdef __cplusplus
  PermediaFBReadMode(void) { }
  PermediaFBReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PermediaFBReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PermediaFBReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PermediaFBReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<25|0x7<<20|0x1<<19|0x1<<18|0x1<<16|0x1<<15|0x1<<10|0x1<<9|0x7<<6|0x7<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct FBSourceOffset {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Offset                              :24;
#else
  unsigned32 Offset                              :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  FBSourceOffset(void) { }
  FBSourceOffset(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBSourceOffset& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBSourceOffset& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBSourceOffset& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct FBPixelOffset {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Offset                              :24;
#else
  unsigned32 Offset                              :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  FBPixelOffset(void) { }
  FBPixelOffset(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBPixelOffset& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBPixelOffset& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBPixelOffset& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct FBWindowBase {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Address                             :24;
#else
  unsigned32 Address                             :24;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  FBWindowBase(void) { }
  FBWindowBase(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBWindowBase& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBWindowBase& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBWindowBase& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffff<<0)); }
#endif /* __cplusplus */
};

struct FBWriteMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 Origin3                             :1;
  unsigned32 Origin2                             :1;
  unsigned32 Origin1                             :1;
  unsigned32 Origin0                             :1;
  unsigned32 Layout3                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout0                             :2;
  unsigned32 Enable3                             :1;
  unsigned32 Enable2                             :1;
  unsigned32 Enable1                             :1;
  unsigned32 Enable0                             :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 Replicate                           :1;
  unsigned32 UpLoadData                          :1;
  unsigned32                                     :2;
  unsigned32 WriteEnable                         :1;
#else
  unsigned32 WriteEnable                         :1;
  unsigned32                                     :2;
  unsigned32 UpLoadData                          :1;
  unsigned32 Replicate                           :1;
  unsigned32 OpaqueSpan                          :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Enable0                             :1;
  unsigned32 Enable1                             :1;
  unsigned32 Enable2                             :1;
  unsigned32 Enable3                             :1;
  unsigned32 Layout0                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout3                             :2;
  unsigned32 Origin0                             :1;
  unsigned32 Origin1                             :1;
  unsigned32 Origin2                             :1;
  unsigned32 Origin3                             :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  FBWriteMode(void) { }
  FBWriteMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBWriteMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBWriteMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBWriteMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x1<<26|0x1<<25|0x1<<24|0x3<<22|0x3<<20|0x3<<18|0x3<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x7<<9|0x7<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBReadPixel {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 PixelSize                           :3;
#else
  unsigned32 PixelSize                           :3;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  FBReadPixel(void) { }
  FBReadPixel(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBReadPixel& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBReadPixel& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBReadPixel& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<0)); }
#endif /* __cplusplus */
};

struct PatternRAMMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :18;
  unsigned32 XMask                               :5;
  unsigned32 YShift                              :3;
  unsigned32 YMask                               :5;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 YMask                               :5;
  unsigned32 YShift                              :3;
  unsigned32 XMask                               :5;
  unsigned32                                     :18;
#endif
#ifdef __cplusplus
  PatternRAMMode(void) { }
  PatternRAMMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PatternRAMMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PatternRAMMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PatternRAMMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<9|0x7<<6|0x1f<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FilterMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :10;
  unsigned32 ExternalDMAController               :1;
  unsigned32 RunLengthEncodeData                 :1;
  unsigned32 Context                             :2;
  unsigned32 ByteSwap                            :2;
  unsigned32 Remainder                           :2;
  unsigned32 Statistics                          :2;
  unsigned32 Sync                                :2;
  unsigned32 FBColor                             :2;
  unsigned32 Stencil                             :2;
  unsigned32 LBDepth                             :2;
  unsigned32 Passive                             :2;
  unsigned32 Active                              :2;
#else
  unsigned32 Active                              :2;
  unsigned32 Passive                             :2;
  unsigned32 LBDepth                             :2;
  unsigned32 Stencil                             :2;
  unsigned32 FBColor                             :2;
  unsigned32 Sync                                :2;
  unsigned32 Statistics                          :2;
  unsigned32 Remainder                           :2;
  unsigned32 ByteSwap                            :2;
  unsigned32 Context                             :2;
  unsigned32 RunLengthEncodeData                 :1;
  unsigned32 ExternalDMAController               :1;
  unsigned32                                     :10;
#endif
#ifdef __cplusplus
  FilterMode(void) { }
  FilterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FilterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FilterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FilterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<21|0x1<<20|0x3<<18|0x3<<16|0x3<<14|0x3<<12|0x3<<10|0x3<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct StatisticMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :26;
  unsigned32 Spans                               :1;
  unsigned32 CompareFunction                     :1;
  unsigned32 PassiveSteps                        :1;
  unsigned32 ActiveSteps                         :1;
  unsigned32 StatsType                           :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 StatsType                           :1;
  unsigned32 ActiveSteps                         :1;
  unsigned32 PassiveSteps                        :1;
  unsigned32 CompareFunction                     :1;
  unsigned32 Spans                               :1;
  unsigned32                                     :26;
#endif
#ifdef __cplusplus
  StatisticMode(void) { }
  StatisticMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StatisticMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StatisticMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StatisticMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PickResult {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Result                              :1;
#else
  unsigned32 Result                              :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  PickResult(void) { }
  PickResult(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PickResult& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PickResult& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PickResult& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct ContextMask {
#if BIG_ENDIAN == 1
  unsigned32                                     :12;
  unsigned32 MatrixStack                         :1;
  unsigned32 PipeControl                         :1;
  unsigned32 MultiTexture                        :1;
  unsigned32 TextureManagementState              :1;
  unsigned32 LUT                                 :1;
  unsigned32 FogTable                            :1;
  unsigned32 Ownership                           :1;
  unsigned32 DDA                                 :1;
  unsigned32 RasterizerState                     :1;
  unsigned32 Select                              :1;
  unsigned32 DMA                                 :1;
  unsigned32 TwoD                                :1;
  unsigned32 CurrentState                        :1;
  unsigned32 RasterPos                           :1;
  unsigned32 Lights8_15                          :1;
  unsigned32 Lights0_7                           :1;
  unsigned32 Material                            :1;
  unsigned32 Matrices                            :1;
  unsigned32 Geometry                            :1;
  unsigned32 GeneralControl                      :1;
#else
  unsigned32 GeneralControl                      :1;
  unsigned32 Geometry                            :1;
  unsigned32 Matrices                            :1;
  unsigned32 Material                            :1;
  unsigned32 Lights0_7                           :1;
  unsigned32 Lights8_15                          :1;
  unsigned32 RasterPos                           :1;
  unsigned32 CurrentState                        :1;
  unsigned32 TwoD                                :1;
  unsigned32 DMA                                 :1;
  unsigned32 Select                              :1;
  unsigned32 RasterizerState                     :1;
  unsigned32 DDA                                 :1;
  unsigned32 Ownership                           :1;
  unsigned32 FogTable                            :1;
  unsigned32 LUT                                 :1;
  unsigned32 TextureManagementState              :1;
  unsigned32 MultiTexture                        :1;
  unsigned32 PipeControl                         :1;
  unsigned32 MatrixStack                         :1;
  unsigned32                                     :12;
#endif
#ifdef __cplusplus
  ContextMask(void) { }
  ContextMask(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ContextMask& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ContextMask& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ContextMask& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct YUVMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :26;
  unsigned32 TexelDisableUpdate                  :1;
  unsigned32 RejectTexel                         :1;
  unsigned32 TestData                            :1;
  unsigned32 TestMode                            :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 TestMode                            :2;
  unsigned32 TestData                            :1;
  unsigned32 RejectTexel                         :1;
  unsigned32 TexelDisableUpdate                  :1;
  unsigned32                                     :26;
#endif
#ifdef __cplusplus
  YUVMode(void) { }
  YUVMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  YUVMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  YUVMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  YUVMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<5|0x1<<4|0x1<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GlintChromaTestMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 Sense                               :1;
  unsigned32 Source                              :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Source                              :2;
  unsigned32 Sense                               :1;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  GlintChromaTestMode(void) { }
  GlintChromaTestMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GlintChromaTestMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GlintChromaTestMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GlintChromaTestMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct ChromaTestMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :25;
  unsigned32 FailAction                          :2;
  unsigned32 PassAction                          :2;
  unsigned32 Source                              :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Source                              :2;
  unsigned32 PassAction                          :2;
  unsigned32 FailAction                          :2;
  unsigned32                                     :25;
#endif
#ifdef __cplusplus
  ChromaTestMode(void) { }
  ChromaTestMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ChromaTestMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ChromaTestMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ChromaTestMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct SelectRecord {
#if BIG_ENDIAN == 1
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 InvalidOperation                    :1;
  unsigned32                                     :22;
  unsigned32 Count                               :7;
#else
  unsigned32 Count                               :7;
  unsigned32                                     :22;
  unsigned32 InvalidOperation                    :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#endif
#ifdef __cplusplus
  SelectRecord(void) { }
  SelectRecord(const unsigned32 i) { *((unsigned32 *)this) = i; }
  SelectRecord& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  SelectRecord& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  SelectRecord& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x7f<<0)); }
#endif /* __cplusplus */
};

struct GMDeltaMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :6;
  unsigned32 EpilogueCount                       :2;
  unsigned32 EpilogueEnable                      :1;
  unsigned32 FlatShadingMethod                   :1;
  unsigned32 ColorSpecular                       :1;
  unsigned32 ColorDiffuse                        :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32                                     :3;
  unsigned32 TextureParameterMode                :2;
  unsigned32 ClampEnable                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 DepthFormat                         :2;
  unsigned32 TargetChip                          :2;
#else
  unsigned32 TargetChip                          :2;
  unsigned32 DepthFormat                         :2;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 ClampEnable                         :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32                                     :3;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 ColorDiffuse                        :1;
  unsigned32 ColorSpecular                       :1;
  unsigned32 FlatShadingMethod                   :1;
  unsigned32 EpilogueEnable                      :1;
  unsigned32 EpilogueCount                       :2;
  unsigned32                                     :6;
#endif
#ifdef __cplusplus
  GMDeltaMode(void) { }
  GMDeltaMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GMDeltaMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GMDeltaMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GMDeltaMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<24|0x1<<23|0x1<<22|0x1<<21|0x1<<20|0x1<<19|0x3<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct RXDeltaMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :5;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :5;
  unsigned32 Texture3DEnable                     :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 FillDirection                       :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32 ClampEnable                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 DepthFormat                         :2;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 DepthFormat                         :2;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 ClampEnable                         :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32 FillDirection                       :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 Texture3DEnable                     :1;
  unsigned32                                     :5;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :5;
#endif
#ifdef __cplusplus
  RXDeltaMode(void) { }
  RXDeltaMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RXDeltaMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RXDeltaMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RXDeltaMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<26|0x1<<20|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x3<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x3<<2)); }
#endif /* __cplusplus */
};

struct P3DeltaMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :2;
  unsigned32 Texture3DEnable                     :1;
  unsigned32                                     :1;
  unsigned32                                     :1;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :6;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 FillDirection                       :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32 ClampEnable                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 DepthFormat                         :2;
  unsigned32 TargetChip                          :2;
#else
  unsigned32 TargetChip                          :2;
  unsigned32 DepthFormat                         :2;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SmoothShadingEnable                 :1;
  unsigned32 DepthEnable                         :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 DiamondExit                         :1;
  unsigned32 NoDraw                              :1;
  unsigned32 ClampEnable                         :1;
  unsigned32 TextureParameterMode                :2;
  unsigned32 FillDirection                       :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32                                     :6;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :1;
  unsigned32                                     :1;
  unsigned32 Texture3DEnable                     :1;
  unsigned32                                     :2;
#endif
#ifdef __cplusplus
  P3DeltaMode(void) { }
  P3DeltaMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  P3DeltaMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  P3DeltaMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  P3DeltaMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<29|0x1<<26|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x3<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct DeltaDraw {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 RejectNegativeFace                  :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32                                     :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32                                     :3;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32                                     :8;
#else
  unsigned32                                     :8;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32                                     :3;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32                                     :1;
  unsigned32 SubPixelCorrectionEnable            :1;
  unsigned32 RejectNegativeFace                  :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  DeltaDraw(void) { }
  DeltaDraw(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaDraw& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaDraw& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaDraw& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<14|0x1<<13|0x1<<9|0x1<<8)); }
#endif /* __cplusplus */
};

struct DeltaControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :17;
  unsigned32 ShareColor                          :1;
  unsigned32 ShareT                              :1;
  unsigned32 ShareS                              :1;
  unsigned32 Line2D                              :1;
  unsigned32 ShareQ                              :1;
  unsigned32                                     :3;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32                                     :1;
  unsigned32 ForceQ                              :1;
  unsigned32 DrawLineEndPoint                    :1;
  unsigned32 FullScreenAA                        :1;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 FullScreenAA                        :1;
  unsigned32 DrawLineEndPoint                    :1;
  unsigned32 ForceQ                              :1;
  unsigned32                                     :1;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32                                     :3;
  unsigned32 ShareQ                              :1;
  unsigned32 Line2D                              :1;
  unsigned32 ShareS                              :1;
  unsigned32 ShareT                              :1;
  unsigned32 ShareColor                          :1;
  unsigned32                                     :17;
#endif
#ifdef __cplusplus
  DeltaControl(void) { }
  DeltaControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<6|0x1<<4|0x1<<3|0x1<<2)); }
#endif /* __cplusplus */
};

struct DeltaProvokingVertexMask {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 KdB                                 :1;
  unsigned32 KdG                                 :1;
  unsigned32 KdR                                 :1;
  unsigned32                                     :1;
  unsigned32 KsB                                 :1;
  unsigned32 KsG                                 :1;
  unsigned32 KsR                                 :1;
  unsigned32                                     :1;
  unsigned32 A                                   :1;
  unsigned32 B                                   :1;
  unsigned32 G                                   :1;
  unsigned32 R                                   :1;
#else
  unsigned32 R                                   :1;
  unsigned32 G                                   :1;
  unsigned32 B                                   :1;
  unsigned32 A                                   :1;
  unsigned32                                     :1;
  unsigned32 KsR                                 :1;
  unsigned32 KsG                                 :1;
  unsigned32 KsB                                 :1;
  unsigned32                                     :1;
  unsigned32 KdR                                 :1;
  unsigned32 KdG                                 :1;
  unsigned32 KdB                                 :1;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  DeltaProvokingVertexMask(void) { }
  DeltaProvokingVertexMask(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaProvokingVertexMask& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaProvokingVertexMask& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaProvokingVertexMask& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<11|0x1<<10|0x1<<9|0x1<<7|0x1<<6|0x1<<5|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct ProvokingVertex {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 Vertex                              :2;
#else
  unsigned32 Vertex                              :2;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  ProvokingVertex(void) { }
  ProvokingVertex(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ProvokingVertex& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ProvokingVertex& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ProvokingVertex& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<0)); }
#endif /* __cplusplus */
};

struct EpilogTag {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Tag                                 :11;
#else
  unsigned32 Tag                                 :11;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  EpilogTag(void) { }
  EpilogTag(const unsigned32 i) { *((unsigned32 *)this) = i; }
  EpilogTag& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  EpilogTag& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  EpilogTag& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7ff<<0)); }
#endif /* __cplusplus */
};

struct PointMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :30;
  unsigned32 AntialiasQuality                    :1;
  unsigned32 AntialiasEnable                     :1;
#else
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasQuality                    :1;
  unsigned32                                     :30;
#endif
#ifdef __cplusplus
  PointMode(void) { }
  PointMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PointMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PointMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PointMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PointSize {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Size                                :8;
#else
  unsigned32 Size                                :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  PointSize(void) { }
  PointSize(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PointSize& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PointSize& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PointSize& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct LineMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :3;
  unsigned32 AntialiasQuality                    :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 Mirror                              :1;
  unsigned32 StippleMask                         :16;
  unsigned32 RepeatFactor                        :9;
  unsigned32 StippleEnable                       :1;
#else
  unsigned32 StippleEnable                       :1;
  unsigned32 RepeatFactor                        :9;
  unsigned32 StippleMask                         :16;
  unsigned32 Mirror                              :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasQuality                    :1;
  unsigned32                                     :3;
#endif
#ifdef __cplusplus
  LineMode(void) { }
  LineMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LineMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LineMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LineMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<28|0x1<<27|0x1<<26|0xffff<<10|0x1ff<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LineWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Width                               :8;
#else
  unsigned32 Width                               :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  LineWidth(void) { }
  LineWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LineWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LineWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LineWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct LineWidthOffset {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Offset                              :8;
#else
  unsigned32 Offset                              :8;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  LineWidthOffset(void) { }
  LineWidthOffset(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LineWidthOffset& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LineWidthOffset& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LineWidthOffset& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<0)); }
#endif /* __cplusplus */
};

struct AALineWidth {
#if BIG_ENDIAN == 1
  unsigned32 Width                               :32;
#else
  unsigned32 Width                               :32;
#endif
#ifdef __cplusplus
  AALineWidth(void) { }
  AALineWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AALineWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AALineWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AALineWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffffff<<0)); }
#endif /* __cplusplus */
};

struct TriangleMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 UseTrianglePacketInterface          :1;
  unsigned32 AntialiasQuality                    :1;
  unsigned32 AntialiasEnable                     :1;
#else
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasQuality                    :1;
  unsigned32 UseTrianglePacketInterface          :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  TriangleMode(void) { }
  TriangleMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TriangleMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TriangleMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TriangleMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Rectangle2DMode {
#if BIG_ENDIAN == 1
  unsigned32 VerticalDirection                   :1;
  unsigned32 HorizontalDirection                 :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 SyncOnBitmask                       :1;
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 Height                              :12;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Height                              :12;
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 SyncOnBitmask                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 HorizontalDirection                 :1;
  unsigned32 VerticalDirection                   :1;
#endif
#ifdef __cplusplus
  Rectangle2DMode(void) { }
  Rectangle2DMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Rectangle2DMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Rectangle2DMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Rectangle2DMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0x1<<27|0x1<<26|0x1<<25|0x1<<24|0xfff<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct Rectangle2DControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 WindowClipping                      :1;
#else
  unsigned32 WindowClipping                      :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  Rectangle2DControl(void) { }
  Rectangle2DControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Rectangle2DControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Rectangle2DControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Rectangle2DControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct VertexMachineMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 D3DProvokingVertex                  :1;
  unsigned32 ObjectIDPerPrimitive                :1;
  unsigned32 ObjectTagEnable                     :1;
#else
  unsigned32 ObjectTagEnable                     :1;
  unsigned32 ObjectIDPerPrimitive                :1;
  unsigned32 D3DProvokingVertex                  :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  VertexMachineMode(void) { }
  VertexMachineMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexMachineMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexMachineMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexMachineMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TransformMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 BlendVertex                         :1;
  unsigned32 TexGenQ                             :1;
  unsigned32 TexGenR                             :1;
  unsigned32 TexGenT                             :1;
  unsigned32 TexGenS                             :1;
  unsigned32 TexGenModeQ                         :2;
  unsigned32 TexGenModeR                         :2;
  unsigned32 TexGenModeT                         :2;
  unsigned32 TexGenModeS                         :2;
  unsigned32 TransformTexture                    :1;
  unsigned32 TransformFaceNormal                 :1;
  unsigned32 TransformNormal                     :1;
  unsigned32 UseModelViewProjectionMatrix        :1;
  unsigned32 UseModelViewMatrix                  :1;
#else
  unsigned32 UseModelViewMatrix                  :1;
  unsigned32 UseModelViewProjectionMatrix        :1;
  unsigned32 TransformNormal                     :1;
  unsigned32 TransformFaceNormal                 :1;
  unsigned32 TransformTexture                    :1;
  unsigned32 TexGenModeS                         :2;
  unsigned32 TexGenModeT                         :2;
  unsigned32 TexGenModeR                         :2;
  unsigned32 TexGenModeQ                         :2;
  unsigned32 TexGenS                             :1;
  unsigned32 TexGenT                             :1;
  unsigned32 TexGenR                             :1;
  unsigned32 TexGenQ                             :1;
  unsigned32 BlendVertex                         :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  TransformMode(void) { }
  TransformMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TransformMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TransformMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TransformMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x3<<11|0x3<<9|0x3<<7|0x3<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GeometryMode {
#if BIG_ENDIAN == 1
  unsigned32 InvertFaceNormalCullDirection       :1;
  unsigned32 PolygonOffsetFill                   :1;
  unsigned32 PolygonOffsetLine                   :1;
  unsigned32 PolygonOffsetPoint                  :1;
  unsigned32 UserClipMask                        :6;
  unsigned32 FlatShading                         :1;
  unsigned32 AutoGenerateFaceNormal              :1;
  unsigned32 CullUsingFaceNormal                 :1;
  unsigned32 FeedbackType                        :3;
  unsigned32 RenderMode                          :2;
  unsigned32 ClipSmallTriangles                  :1;
  unsigned32 ClipShortLines                      :1;
  unsigned32 PolygonCullFace                     :2;
  unsigned32 PolygonCull                         :1;
  unsigned32 FrontFaceDirection                  :1;
  unsigned32 BackPolyMode                        :2;
  unsigned32 FrontPolyMode                       :2;
  unsigned32 FogFunction                         :2;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
#else
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 FogFunction                         :2;
  unsigned32 FrontPolyMode                       :2;
  unsigned32 BackPolyMode                        :2;
  unsigned32 FrontFaceDirection                  :1;
  unsigned32 PolygonCull                         :1;
  unsigned32 PolygonCullFace                     :2;
  unsigned32 ClipShortLines                      :1;
  unsigned32 ClipSmallTriangles                  :1;
  unsigned32 RenderMode                          :2;
  unsigned32 FeedbackType                        :3;
  unsigned32 CullUsingFaceNormal                 :1;
  unsigned32 AutoGenerateFaceNormal              :1;
  unsigned32 FlatShading                         :1;
  unsigned32 UserClipMask                        :6;
  unsigned32 PolygonOffsetPoint                  :1;
  unsigned32 PolygonOffsetLine                   :1;
  unsigned32 PolygonOffsetFill                   :1;
  unsigned32 InvertFaceNormalCullDirection       :1;
#endif
#ifdef __cplusplus
  GeometryMode(void) { }
  GeometryMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeometryMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeometryMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeometryMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0x3f<<22|0x1<<21|0x1<<20|0x1<<19|0x7<<16|0x3<<14|0x1<<13|0x1<<12|0x3<<10|0x1<<9|0x1<<8|0x3<<6|0x3<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Gamma3GeometryMode {
#if BIG_ENDIAN == 1
  unsigned32 InvertFaceNormalCullDirection       :1;
  unsigned32 PolygonOffsetFill                   :1;
  unsigned32 PolygonOffsetLine                   :1;
  unsigned32 PolygonOffsetPoint                  :1;
  unsigned32 UserClipMask                        :6;
  unsigned32 FlatShading                         :1;
  unsigned32 DisableFustumCulling                :1;
  unsigned32 CullUsingFaceNormal                 :1;
  unsigned32 FeedbackType                        :3;
  unsigned32 RenderMode                          :2;
  unsigned32 ClipSmallTriangles                  :1;
  unsigned32 ClipShortLines                      :1;
  unsigned32 PolygonCullFace                     :2;
  unsigned32 PolygonCull                         :1;
  unsigned32 FrontFaceDirection                  :1;
  unsigned32 BackPolyMode                        :2;
  unsigned32 FrontPolyMode                       :2;
  unsigned32 OrthographicProjection              :1;
  unsigned32 UserInvW                            :1;
  unsigned32                                     :1;
  unsigned32 SendInvW                            :1;
#else
  unsigned32 SendInvW                            :1;
  unsigned32                                     :1;
  unsigned32 UserInvW                            :1;
  unsigned32 OrthographicProjection              :1;
  unsigned32 FrontPolyMode                       :2;
  unsigned32 BackPolyMode                        :2;
  unsigned32 FrontFaceDirection                  :1;
  unsigned32 PolygonCull                         :1;
  unsigned32 PolygonCullFace                     :2;
  unsigned32 ClipShortLines                      :1;
  unsigned32 ClipSmallTriangles                  :1;
  unsigned32 RenderMode                          :2;
  unsigned32 FeedbackType                        :3;
  unsigned32 CullUsingFaceNormal                 :1;
  unsigned32 DisableFustumCulling                :1;
  unsigned32 FlatShading                         :1;
  unsigned32 UserClipMask                        :6;
  unsigned32 PolygonOffsetPoint                  :1;
  unsigned32 PolygonOffsetLine                   :1;
  unsigned32 PolygonOffsetFill                   :1;
  unsigned32 InvertFaceNormalCullDirection       :1;
#endif
#ifdef __cplusplus
  Gamma3GeometryMode(void) { }
  Gamma3GeometryMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Gamma3GeometryMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Gamma3GeometryMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Gamma3GeometryMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0x3f<<22|0x1<<21|0x1<<20|0x1<<19|0x7<<16|0x3<<14|0x1<<13|0x1<<12|0x3<<10|0x1<<9|0x1<<8|0x3<<6|0x3<<4|0x1<<3|0x1<<2|0x1<<0)); }
#endif /* __cplusplus */
};

struct NormaliseMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :25;
  unsigned32 BlendNormal                         :1;
  unsigned32 NormaliseSpotDirection              :1;
  unsigned32 NormaliseLightPosition              :1;
  unsigned32 AntialiasLine                       :1;
  unsigned32 InvertAutoFaceNormal                :1;
  unsigned32 FaceNormalEnable                    :1;
  unsigned32 NormalEnable                        :1;
#else
  unsigned32 NormalEnable                        :1;
  unsigned32 FaceNormalEnable                    :1;
  unsigned32 InvertAutoFaceNormal                :1;
  unsigned32 AntialiasLine                       :1;
  unsigned32 NormaliseLightPosition              :1;
  unsigned32 NormaliseSpotDirection              :1;
  unsigned32 BlendNormal                         :1;
  unsigned32                                     :25;
#endif
#ifdef __cplusplus
  NormaliseMode(void) { }
  NormaliseMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  NormaliseMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  NormaliseMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  NormaliseMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LightingMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 D3DEyeDirection                     :1;
  unsigned32 UseFaceNormal                       :1;
  unsigned32 SpecularLightingEnable              :1;
  unsigned32 NumberLights                        :9;
  unsigned32 AttenuationTest                     :1;
  unsigned32 FlipNormal                          :1;
  unsigned32 LocalViewer                         :1;
  unsigned32 TwoSidedLighting                    :2;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 TwoSidedLighting                    :2;
  unsigned32 LocalViewer                         :1;
  unsigned32 FlipNormal                          :1;
  unsigned32 AttenuationTest                     :1;
  unsigned32 NumberLights                        :9;
  unsigned32 SpecularLightingEnable              :1;
  unsigned32 UseFaceNormal                       :1;
  unsigned32 D3DEyeDirection                     :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  LightingMode(void) { }
  LightingMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LightingMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LightingMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LightingMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<15|0x1ff<<6|0x1<<5|0x1<<4|0x1<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct ColorMaterialMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :6;
  unsigned32 BackAlphaSource                     :2;
  unsigned32 BackSpecularSource                  :2;
  unsigned32 BackDiffuseSource                   :2;
  unsigned32 BackAmbientSource                   :2;
  unsigned32 BackEmissiveSource                  :2;
  unsigned32 FrontAlphaSource                    :2;
  unsigned32 FrontSpecularSource                 :2;
  unsigned32 FrontDiffuseSource                  :2;
  unsigned32 FrontAmbientSource                  :2;
  unsigned32 FrontEmissiveSource                 :2;
  unsigned32 Parameter                           :3;
  unsigned32 Face                                :2;
  unsigned32 ColorMaterialEnable                 :1;
#else
  unsigned32 ColorMaterialEnable                 :1;
  unsigned32 Face                                :2;
  unsigned32 Parameter                           :3;
  unsigned32 FrontEmissiveSource                 :2;
  unsigned32 FrontAmbientSource                  :2;
  unsigned32 FrontDiffuseSource                  :2;
  unsigned32 FrontSpecularSource                 :2;
  unsigned32 FrontAlphaSource                    :2;
  unsigned32 BackEmissiveSource                  :2;
  unsigned32 BackAmbientSource                   :2;
  unsigned32 BackDiffuseSource                   :2;
  unsigned32 BackSpecularSource                  :2;
  unsigned32 BackAlphaSource                     :2;
  unsigned32                                     :6;
#endif
#ifdef __cplusplus
  ColorMaterialMode(void) { }
  ColorMaterialMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ColorMaterialMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ColorMaterialMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ColorMaterialMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<24|0x3<<22|0x3<<20|0x3<<18|0x3<<16|0x3<<14|0x3<<12|0x3<<10|0x3<<8|0x3<<6|0x7<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct MaterialMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :9;
  unsigned32 ColorDisable                        :1;
  unsigned32 AlphaSource                         :2;
  unsigned32 SpecularTextureSource               :2;
  unsigned32 DiffuseTextureSource                :2;
  unsigned32 ColorSource2Bit                     :2;
  unsigned32 SendColorC                          :1;
  unsigned32 SendColorB                          :1;
  unsigned32 SendColorA                          :1;
  unsigned32 SendNormal                          :1;
  unsigned32 SpecularColor                       :1;
  unsigned32 TwoSidedLighting                    :2;
  unsigned32 ColorSource                         :1;
  unsigned32 PremultiplyAlpha                    :1;
  unsigned32 MonochromeSpecularTexture           :1;
  unsigned32 MonochromeDiffuseTexture            :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 DiffuseTextureEnable                :1;
  unsigned32 SpecularTextureEnable               :1;
  unsigned32 MonochromeDiffuseTexture            :1;
  unsigned32 MonochromeSpecularTexture           :1;
  unsigned32 PremultiplyAlpha                    :1;
  unsigned32 ColorSource                         :1;
  unsigned32 TwoSidedLighting                    :2;
  unsigned32 SpecularColor                       :1;
  unsigned32 SendNormal                          :1;
  unsigned32 SendColorA                          :1;
  unsigned32 SendColorB                          :1;
  unsigned32 SendColorC                          :1;
  unsigned32 ColorSource2Bit                     :2;
  unsigned32 DiffuseTextureSource                :2;
  unsigned32 SpecularTextureSource               :2;
  unsigned32 AlphaSource                         :2;
  unsigned32 ColorDisable                        :1;
  unsigned32                                     :9;
#endif
#ifdef __cplusplus
  MaterialMode(void) { }
  MaterialMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MaterialMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MaterialMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MaterialMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<22|0x3<<20|0x3<<18|0x3<<16|0x3<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x3<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FogVertexMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :26;
  unsigned32 Source                              :2;
  unsigned32 Function                            :2;
  unsigned32                                     :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32                                     :1;
  unsigned32 Function                            :2;
  unsigned32 Source                              :2;
  unsigned32                                     :26;
#endif
#ifdef __cplusplus
  FogVertexMode(void) { }
  FogVertexMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FogVertexMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FogVertexMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FogVertexMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<4|0x3<<2|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :3;
  unsigned32 UserInvW                            :1;
  unsigned32 R4D3DWrappingT                      :1;
  unsigned32 R4D3DWrappingS                      :1;
  unsigned32 R4Operation                         :2;
  unsigned32 FeedbackEnable                      :1;
  unsigned32 WhichMatrix                         :3;
  unsigned32 WhichTexGen                         :3;
  unsigned32 WhichCurrentTextureCoord            :3;
  unsigned32 TexGenQ                             :1;
  unsigned32 TexGenR                             :1;
  unsigned32 TexGenT                             :1;
  unsigned32 TexGenS                             :1;
  unsigned32 TexGenModeQ                         :2;
  unsigned32 TexGenModeR                         :2;
  unsigned32 TexGenModeT                         :2;
  unsigned32 TexGenModeS                         :2;
  unsigned32 TransformEnable                     :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 TransformEnable                     :1;
  unsigned32 TexGenModeS                         :2;
  unsigned32 TexGenModeT                         :2;
  unsigned32 TexGenModeR                         :2;
  unsigned32 TexGenModeQ                         :2;
  unsigned32 TexGenS                             :1;
  unsigned32 TexGenT                             :1;
  unsigned32 TexGenR                             :1;
  unsigned32 TexGenQ                             :1;
  unsigned32 WhichCurrentTextureCoord            :3;
  unsigned32 WhichTexGen                         :3;
  unsigned32 WhichMatrix                         :3;
  unsigned32 FeedbackEnable                      :1;
  unsigned32 R4Operation                         :2;
  unsigned32 R4D3DWrappingS                      :1;
  unsigned32 R4D3DWrappingT                      :1;
  unsigned32 UserInvW                            :1;
  unsigned32                                     :3;
#endif
#ifdef __cplusplus
  TextureMode(void) { }
  TextureMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<28|0x1<<27|0x1<<26|0x3<<24|0x1<<23|0x7<<20|0x7<<17|0x7<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x3<<8|0x3<<6|0x3<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct StripeFilterMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :13;
  unsigned32 NumberRasterisers                   :2;
  unsigned32 StripeHeight                        :3;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 RejectZeroHeightTriangles           :1;
  unsigned32 AATriangleQuality                   :1;
  unsigned32 AATriangleEnable                    :1;
  unsigned32 FilterAATriangles                   :1;
  unsigned32 FilterTriangles                     :1;
  unsigned32 AALineQuality                       :1;
  unsigned32 AALineEnable                        :1;
  unsigned32 FilterAALines                       :1;
  unsigned32 FilterLines                         :1;
  unsigned32 AAPointQuality                      :1;
  unsigned32 AAPointEnable                       :1;
  unsigned32 FilterAAPoints                      :1;
  unsigned32 FilterPoints                        :1;
#else
  unsigned32 FilterPoints                        :1;
  unsigned32 FilterAAPoints                      :1;
  unsigned32 AAPointEnable                       :1;
  unsigned32 AAPointQuality                      :1;
  unsigned32 FilterLines                         :1;
  unsigned32 FilterAALines                       :1;
  unsigned32 AALineEnable                        :1;
  unsigned32 AALineQuality                       :1;
  unsigned32 FilterTriangles                     :1;
  unsigned32 FilterAATriangles                   :1;
  unsigned32 AATriangleEnable                    :1;
  unsigned32 AATriangleQuality                   :1;
  unsigned32 RejectZeroHeightTriangles           :1;
  unsigned32 BiasCoordinates                     :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 NumberRasterisers                   :2;
  unsigned32                                     :13;
#endif
#ifdef __cplusplus
  StripeFilterMode(void) { }
  StripeFilterMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StripeFilterMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StripeFilterMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StripeFilterMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<17|0x7<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct MatrixMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :23;
  unsigned32 BoundingVolumeTestEnable            :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BoundingBoxTestEnable               :1;
  unsigned32 TransformSpotLightDirection         :1;
  unsigned32 TransformLightPosition              :1;
  unsigned32 TransformUserClip                   :1;
  unsigned32 CalculateModelViewProjMatrix        :1;
  unsigned32 CalculateModelViewMatrix            :1;
  unsigned32 SeparateModelViewMatrices           :1;
#else
  unsigned32 SeparateModelViewMatrices           :1;
  unsigned32 CalculateModelViewMatrix            :1;
  unsigned32 CalculateModelViewProjMatrix        :1;
  unsigned32 TransformUserClip                   :1;
  unsigned32 TransformLightPosition              :1;
  unsigned32 TransformSpotLightDirection         :1;
  unsigned32 BoundingBoxTestEnable               :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 BoundingVolumeTestEnable            :1;
  unsigned32                                     :23;
#endif
#ifdef __cplusplus
  MatrixMode(void) { }
  MatrixMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MatrixMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MatrixMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MatrixMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct RenderMode {
#if BIG_ENDIAN == 1
  unsigned32 Type                                :4;
  unsigned32 FBSourceReadEnable                  :1;
  unsigned32                                     :7;
  unsigned32 FrontFacing                         :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 RejectNegativeFace                  :1;
  unsigned32 SubpixelCorrectionEnable            :1;
  unsigned32 CoverageEnable                      :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 SyncOnBitMask                       :1;
  unsigned32 UsePointTable                       :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 PrimitiveType                       :2;
  unsigned32                                     :2;
  unsigned32 FastFillEnable                      :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 LineStippleEnable                   :1;
  unsigned32 AreaStippleEnable                   :1;
#else
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 LineStippleEnable                   :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 FastFillEnable                      :1;
  unsigned32                                     :2;
  unsigned32 PrimitiveType                       :2;
  unsigned32 AntialiasEnable                     :1;
  unsigned32 AntialiasingQuality                 :1;
  unsigned32 UsePointTable                       :1;
  unsigned32 SyncOnBitMask                       :1;
  unsigned32 SyncOnHostData                      :1;
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 CoverageEnable                      :1;
  unsigned32 SubpixelCorrectionEnable            :1;
  unsigned32 RejectNegativeFace                  :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 FrontFacing                         :1;
  unsigned32                                     :7;
  unsigned32 FBSourceReadEnable                  :1;
  unsigned32 Type                                :4;
#endif
#ifdef __cplusplus
  RenderMode(void) { }
  RenderMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RenderMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RenderMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RenderMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<28|0x1<<27|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x3<<6|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct EdgeFlag {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Flag                                :1;
#else
  unsigned32 Flag                                :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  EdgeFlag(void) { }
  EdgeFlag(const unsigned32 i) { *((unsigned32 *)this) = i; }
  EdgeFlag& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  EdgeFlag& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  EdgeFlag& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct TransformCurrent {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 Color                               :1;
  unsigned32 Texture                             :1;
  unsigned32 FaceNormal                          :1;
  unsigned32 Normal                              :1;
#else
  unsigned32 Normal                              :1;
  unsigned32 FaceNormal                          :1;
  unsigned32 Texture                             :1;
  unsigned32 Color                               :1;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  TransformCurrent(void) { }
  TransformCurrent(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TransformCurrent& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TransformCurrent& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TransformCurrent& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PushName {
#if BIG_ENDIAN == 1
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 InvalidOperation                    :1;
  unsigned32                                     :22;
  unsigned32 Count                               :7;
#else
  unsigned32 Count                               :7;
  unsigned32                                     :22;
  unsigned32 InvalidOperation                    :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#endif
#ifdef __cplusplus
  PushName(void) { }
  PushName(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PushName& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PushName& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PushName& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x7f<<0)); }
#endif /* __cplusplus */
};

struct PopName {
#if BIG_ENDIAN == 1
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 InvalidOperation                    :1;
  unsigned32                                     :22;
  unsigned32 Count                               :7;
#else
  unsigned32 Count                               :7;
  unsigned32                                     :22;
  unsigned32 InvalidOperation                    :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#endif
#ifdef __cplusplus
  PopName(void) { }
  PopName(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PopName& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PopName& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PopName& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x7f<<0)); }
#endif /* __cplusplus */
};

struct LoadName {
#if BIG_ENDIAN == 1
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 InvalidOperation                    :1;
  unsigned32                                     :22;
  unsigned32 Count                               :7;
#else
  unsigned32 Count                               :7;
  unsigned32                                     :22;
  unsigned32 InvalidOperation                    :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#endif
#ifdef __cplusplus
  LoadName(void) { }
  LoadName(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LoadName& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LoadName& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LoadName& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x7f<<0)); }
#endif /* __cplusplus */
};

struct GeomPoint {
#if BIG_ENDIAN == 1
  unsigned32                                     :23;
  unsigned32 EdgeA                               :1;
  unsigned32                                     :6;
  unsigned32 A                                   :2;
#else
  unsigned32 A                                   :2;
  unsigned32                                     :6;
  unsigned32 EdgeA                               :1;
  unsigned32                                     :23;
#endif
#ifdef __cplusplus
  GeomPoint(void) { }
  GeomPoint(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeomPoint& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeomPoint& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeomPoint& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<8|0x3<<0)); }
#endif /* __cplusplus */
};

struct GeomLine {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 ResetLineStipple                    :1;
  unsigned32                                     :1;
  unsigned32 EdgeB                               :1;
  unsigned32 EdgeA                               :1;
  unsigned32 ProvokingVertex                     :2;
  unsigned32                                     :2;
  unsigned32 B                                   :2;
  unsigned32 A                                   :2;
#else
  unsigned32 A                                   :2;
  unsigned32 B                                   :2;
  unsigned32                                     :2;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 EdgeA                               :1;
  unsigned32 EdgeB                               :1;
  unsigned32                                     :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  GeomLine(void) { }
  GeomLine(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeomLine& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeomLine& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeomLine& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<11|0x1<<9|0x1<<8|0x3<<6|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct GeomTriangle {
#if BIG_ENDIAN == 1
  unsigned32                                     :14;
  unsigned32 FrontFacing                         :1;
  unsigned32 SubstituteEdgeC                     :1;
  unsigned32 SubstituteEdgeB                     :1;
  unsigned32 SubstituteEdgeA                     :1;
  unsigned32 Last                                :1;
  unsigned32                                     :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 EdgeC                               :1;
  unsigned32 EdgeB                               :1;
  unsigned32 EdgeA                               :1;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 C                                   :2;
  unsigned32 B                                   :2;
  unsigned32 A                                   :2;
#else
  unsigned32 A                                   :2;
  unsigned32 B                                   :2;
  unsigned32 C                                   :2;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 EdgeA                               :1;
  unsigned32 EdgeB                               :1;
  unsigned32 EdgeC                               :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32                                     :1;
  unsigned32 Last                                :1;
  unsigned32 SubstituteEdgeA                     :1;
  unsigned32 SubstituteEdgeB                     :1;
  unsigned32 SubstituteEdgeC                     :1;
  unsigned32 FrontFacing                         :1;
  unsigned32                                     :14;
#endif
#ifdef __cplusplus
  GeomTriangle(void) { }
  GeomTriangle(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeomTriangle& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeomTriangle& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeomTriangle& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct GeomRectangle {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 SelectEnable                        :1;
  unsigned32 OffsetEnable                        :1;
  unsigned32 Type                                :2;
#else
  unsigned32 Type                                :2;
  unsigned32 OffsetEnable                        :1;
  unsigned32 SelectEnable                        :1;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  GeomRectangle(void) { }
  GeomRectangle(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GeomRectangle& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GeomRectangle& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GeomRectangle& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<3|0x1<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct ClippedColor {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32 Destination                         :2;
  unsigned32 C                                   :2;
  unsigned32 B                                   :2;
  unsigned32 A                                   :2;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 FrontFacing                         :1;
#else
  unsigned32 FrontFacing                         :1;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 A                                   :2;
  unsigned32 B                                   :2;
  unsigned32 C                                   :2;
  unsigned32 Destination                         :2;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  ClippedColor(void) { }
  ClippedColor(const unsigned32 i) { *((unsigned32 *)this) = i; }
  ClippedColor& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  ClippedColor& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  ClippedColor& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<11|0x3<<9|0x3<<7|0x3<<5|0x3<<3|0x3<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct RenderPrim {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32 FrontFacing                         :1;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 C                                   :2;
  unsigned32 B                                   :2;
  unsigned32 A                                   :2;
#else
  unsigned32 A                                   :2;
  unsigned32 B                                   :2;
  unsigned32 C                                   :2;
  unsigned32 ProvokingVertex                     :2;
  unsigned32 ResetLineStipple                    :1;
  unsigned32 FrontFacing                         :1;
  unsigned32 UseProvokingVertex                  :1;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  RenderPrim(void) { }
  RenderPrim(const unsigned32 i) { *((unsigned32 *)this) = i; }
  RenderPrim& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  RenderPrim& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  RenderPrim& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<10|0x1<<9|0x1<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct PackedNormal {
#if BIG_ENDIAN == 1
  unsigned32 Code                                :2;
  unsigned32 Z                                   :10;
  unsigned32 Y                                   :10;
  unsigned32 X                                   :10;
#else
  unsigned32 X                                   :10;
  unsigned32 Y                                   :10;
  unsigned32 Z                                   :10;
  unsigned32 Code                                :2;
#endif
#ifdef __cplusplus
  PackedNormal(void) { }
  PackedNormal(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PackedNormal& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PackedNormal& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PackedNormal& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3ff<<20|0x3ff<<10|0x3ff<<0)); }
#endif /* __cplusplus */
};

struct LightMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 LocalLight                          :1;
  unsigned32 Attenuation                         :1;
  unsigned32 Spotlight                           :1;
  unsigned32 LightOn                             :1;
#else
  unsigned32 LightOn                             :1;
  unsigned32 Spotlight                           :1;
  unsigned32 Attenuation                         :1;
  unsigned32 LocalLight                          :1;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  LightMode(void) { }
  LightMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LightMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LightMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LightMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct DMAAddr {
#if BIG_ENDIAN == 1
  unsigned32 Address                             :30;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 Address                             :30;
#endif
#ifdef __cplusplus
  DMAAddr(void) { }
  DMAAddr(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMAAddr& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMAAddr& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMAAddr& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3fffffff<<2)); }
#endif /* __cplusplus */
};

struct CommandInterrupt {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 OutputDMA                           :1;
#else
  unsigned32 OutputDMA                           :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  CommandInterrupt(void) { }
  CommandInterrupt(const unsigned32 i) { *((unsigned32 *)this) = i; }
  CommandInterrupt& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  CommandInterrupt& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  CommandInterrupt& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleRead {
#if BIG_ENDIAN == 1
  unsigned32 Alignment                           :2;
  unsigned32                                     :1;
  unsigned32 ByteSwap                            :2;
  unsigned32 PackOut                             :1;
  unsigned32 PixelSize                           :2;
  unsigned32 Height                              :12;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Height                              :12;
  unsigned32 PixelSize                           :2;
  unsigned32 PackOut                             :1;
  unsigned32 ByteSwap                            :2;
  unsigned32                                     :1;
  unsigned32 Alignment                           :2;
#endif
#ifdef __cplusplus
  DMARectangleRead(void) { }
  DMARectangleRead(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleRead& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleRead& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleRead& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3<<27|0x1<<26|0x3<<24|0xfff<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleReadLinePitch {
#if BIG_ENDIAN == 1
  unsigned32 LinePitch                           :32;
#else
  unsigned32 LinePitch                           :32;
#endif
#ifdef __cplusplus
  DMARectangleReadLinePitch(void) { }
  DMARectangleReadLinePitch(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleReadLinePitch& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleReadLinePitch& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleReadLinePitch& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffffff<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleReadTarget {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Tag                                 :11;
#else
  unsigned32 Tag                                 :11;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  DMARectangleReadTarget(void) { }
  DMARectangleReadTarget(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleReadTarget& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleReadTarget& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleReadTarget& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7ff<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleWrite {
#if BIG_ENDIAN == 1
  unsigned32 Alignment                           :2;
  unsigned32                                     :1;
  unsigned32 ByteSwap                            :2;
  unsigned32 PackOut                             :1;
  unsigned32 PixelSize                           :2;
  unsigned32 Height                              :12;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Height                              :12;
  unsigned32 PixelSize                           :2;
  unsigned32 PackOut                             :1;
  unsigned32 ByteSwap                            :2;
  unsigned32                                     :1;
  unsigned32 Alignment                           :2;
#endif
#ifdef __cplusplus
  DMARectangleWrite(void) { }
  DMARectangleWrite(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleWrite& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleWrite& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleWrite& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3<<27|0x1<<26|0x3<<24|0xfff<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct DMARectangleWriteLinePitch {
#if BIG_ENDIAN == 1
  unsigned32 LinePitch                           :32;
#else
  unsigned32 LinePitch                           :32;
#endif
#ifdef __cplusplus
  DMARectangleWriteLinePitch(void) { }
  DMARectangleWriteLinePitch(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMARectangleWriteLinePitch& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMARectangleWriteLinePitch& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMARectangleWriteLinePitch& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffffffff<<0)); }
#endif /* __cplusplus */
};

struct DMAOutputAddress {
#if BIG_ENDIAN == 1
  unsigned32 Address                             :30;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 Address                             :30;
#endif
#ifdef __cplusplus
  DMAOutputAddress(void) { }
  DMAOutputAddress(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMAOutputAddress& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMAOutputAddress& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMAOutputAddress& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3fffffff<<2)); }
#endif /* __cplusplus */
};

struct VertexArray {
#if BIG_ENDIAN == 1
  unsigned32                                     :18;
  unsigned32 OpenGLProvokingVertex               :1;
  unsigned32 D3DTriangleEdgeFlags                :1;
  unsigned32 InlineFaceNormalData                :1;
  unsigned32 InlineVertexData                    :1;
  unsigned32 InlineIndices                       :1;
  unsigned32 FaceNormalPresent                   :1;
  unsigned32 EdgeFlagPresent                     :1;
  unsigned32 TextureFormat                       :2;
  unsigned32 ColorFormat                         :2;
  unsigned32 NormalPresent                       :1;
  unsigned32 CoordinateFormat                    :2;
#else
  unsigned32 CoordinateFormat                    :2;
  unsigned32 NormalPresent                       :1;
  unsigned32 ColorFormat                         :2;
  unsigned32 TextureFormat                       :2;
  unsigned32 EdgeFlagPresent                     :1;
  unsigned32 FaceNormalPresent                   :1;
  unsigned32 InlineIndices                       :1;
  unsigned32 InlineVertexData                    :1;
  unsigned32 InlineFaceNormalData                :1;
  unsigned32 D3DTriangleEdgeFlags                :1;
  unsigned32 OpenGLProvokingVertex               :1;
  unsigned32                                     :18;
#endif
#ifdef __cplusplus
  VertexArray(void) { }
  VertexArray(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexArray& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexArray& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexArray& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x3<<5|0x3<<3|0x1<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct FBDestReadBufferWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  FBDestReadBufferWidth(void) { }
  FBDestReadBufferWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBDestReadBufferWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBDestReadBufferWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBDestReadBufferWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<0)); }
#endif /* __cplusplus */
};

struct FBDestReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 AlphaFiltering                      :1;
  unsigned32 UseReadEnables                      :1;
  unsigned32 PCIMappingEnable                    :1;
  unsigned32 Blocking                            :1;
  unsigned32 Origin3                             :1;
  unsigned32 Origin2                             :1;
  unsigned32 Origin1                             :1;
  unsigned32 Origin0                             :1;
  unsigned32 Layout3                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout0                             :2;
  unsigned32 Enable3                             :1;
  unsigned32 Enable2                             :1;
  unsigned32 Enable1                             :1;
  unsigned32 Enable0                             :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 ReadEnable                          :1;
#else
  unsigned32 ReadEnable                          :1;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Enable0                             :1;
  unsigned32 Enable1                             :1;
  unsigned32 Enable2                             :1;
  unsigned32 Enable3                             :1;
  unsigned32 Layout0                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout3                             :2;
  unsigned32 Origin0                             :1;
  unsigned32 Origin1                             :1;
  unsigned32 Origin2                             :1;
  unsigned32 Origin3                             :1;
  unsigned32 Blocking                            :1;
  unsigned32 PCIMappingEnable                    :1;
  unsigned32 UseReadEnables                      :1;
  unsigned32 AlphaFiltering                      :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  FBDestReadMode(void) { }
  FBDestReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBDestReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBDestReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBDestReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x1<<26|0x1<<25|0x1<<24|0x1<<23|0x1<<22|0x1<<21|0x1<<20|0x3<<18|0x3<<16|0x3<<14|0x3<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0x7<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBDestReadEnables {
#if BIG_ENDIAN == 1
  unsigned32 ReferenceAlpha                      :8;
  unsigned32                                     :8;
  unsigned32 R7                                  :1;
  unsigned32 R6                                  :1;
  unsigned32 R5                                  :1;
  unsigned32 R4                                  :1;
  unsigned32 R3                                  :1;
  unsigned32 R2                                  :1;
  unsigned32 R1                                  :1;
  unsigned32 R0                                  :1;
  unsigned32 E7                                  :1;
  unsigned32 E6                                  :1;
  unsigned32 E5                                  :1;
  unsigned32 E4                                  :1;
  unsigned32 E3                                  :1;
  unsigned32 E2                                  :1;
  unsigned32 E1                                  :1;
  unsigned32 E0                                  :1;
#else
  unsigned32 E0                                  :1;
  unsigned32 E1                                  :1;
  unsigned32 E2                                  :1;
  unsigned32 E3                                  :1;
  unsigned32 E4                                  :1;
  unsigned32 E5                                  :1;
  unsigned32 E6                                  :1;
  unsigned32 E7                                  :1;
  unsigned32 R0                                  :1;
  unsigned32 R1                                  :1;
  unsigned32 R2                                  :1;
  unsigned32 R3                                  :1;
  unsigned32 R4                                  :1;
  unsigned32 R5                                  :1;
  unsigned32 R6                                  :1;
  unsigned32 R7                                  :1;
  unsigned32                                     :8;
  unsigned32 ReferenceAlpha                      :8;
#endif
#ifdef __cplusplus
  FBDestReadEnables(void) { }
  FBDestReadEnables(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBDestReadEnables& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBDestReadEnables& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBDestReadEnables& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<24|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBSourceReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :7;
  unsigned32 ExternalSourceData                  :1;
  unsigned32 WrapY                               :4;
  unsigned32 WrapX                               :4;
  unsigned32 WrapYEnable                         :1;
  unsigned32 WrapXEnable                         :1;
  unsigned32 UseTexelCoord                       :1;
  unsigned32 PCIMappingEnable                    :1;
  unsigned32 Blocking                            :1;
  unsigned32 Origin                              :1;
  unsigned32 Layout                              :2;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 ReadEnable                          :1;
#else
  unsigned32 ReadEnable                          :1;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Layout                              :2;
  unsigned32 Origin                              :1;
  unsigned32 Blocking                            :1;
  unsigned32 PCIMappingEnable                    :1;
  unsigned32 UseTexelCoord                       :1;
  unsigned32 WrapXEnable                         :1;
  unsigned32 WrapYEnable                         :1;
  unsigned32 WrapX                               :4;
  unsigned32 WrapY                               :4;
  unsigned32 ExternalSourceData                  :1;
  unsigned32                                     :7;
#endif
#ifdef __cplusplus
  FBSourceReadMode(void) { }
  FBSourceReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBSourceReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBSourceReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBSourceReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<24|0xf<<20|0xf<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x3<<8|0x7<<5|0x7<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBSourceReadBufferWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  FBSourceReadBufferWidth(void) { }
  FBSourceReadBufferWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBSourceReadBufferWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBSourceReadBufferWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBSourceReadBufferWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<0)); }
#endif /* __cplusplus */
};

struct MergeSpanDataLower {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 Addr                                :5;
  unsigned32 Buffer                              :3;
  unsigned32 Load                                :1;
  unsigned32 PostDest                            :3;
  unsigned32 PostLength                          :4;
  unsigned32 PostStart                           :4;
  unsigned32 PreDest                             :3;
  unsigned32 PreLength                           :4;
  unsigned32 PreStart                            :4;
#else
  unsigned32 PreStart                            :4;
  unsigned32 PreLength                           :4;
  unsigned32 PreDest                             :3;
  unsigned32 PostStart                           :4;
  unsigned32 PostLength                          :4;
  unsigned32 PostDest                            :3;
  unsigned32 Load                                :1;
  unsigned32 Buffer                              :3;
  unsigned32 Addr                                :5;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  MergeSpanDataLower(void) { }
  MergeSpanDataLower(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MergeSpanDataLower& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MergeSpanDataLower& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MergeSpanDataLower& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<26|0x7<<23|0x1<<22|0x7<<19|0xf<<15|0xf<<11|0x7<<8|0xf<<4|0xf<<0)); }
#endif /* __cplusplus */
};

struct MergeSpanDataUpper {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 Operation                           :3;
#else
  unsigned32 Operation                           :3;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  MergeSpanDataUpper(void) { }
  MergeSpanDataUpper(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MergeSpanDataUpper& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MergeSpanDataUpper& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MergeSpanDataUpper& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<0)); }
#endif /* __cplusplus */
};

struct AlphaBlendColorMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :7;
  unsigned32 SwapSD                              :1;
  unsigned32 Operation                           :4;
  unsigned32 ConstantDest                        :1;
  unsigned32 ConstantSource                      :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 ColorOrder                          :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 InvertDest                          :1;
  unsigned32 InvertSource                        :1;
  unsigned32 DestTimesTwo                        :1;
  unsigned32 SourceTimesTwo                      :1;
  unsigned32 DestBlend                           :3;
  unsigned32 SourceBlend                         :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SourceBlend                         :4;
  unsigned32 DestBlend                           :3;
  unsigned32 SourceTimesTwo                      :1;
  unsigned32 DestTimesTwo                        :1;
  unsigned32 InvertSource                        :1;
  unsigned32 InvertDest                          :1;
  unsigned32 ColorFormat                         :4;
  unsigned32 ColorOrder                          :1;
  unsigned32 ColorConversion                     :1;
  unsigned32 ConstantSource                      :1;
  unsigned32 ConstantDest                        :1;
  unsigned32 Operation                           :4;
  unsigned32 SwapSD                              :1;
  unsigned32                                     :7;
#endif
#ifdef __cplusplus
  AlphaBlendColorMode(void) { }
  AlphaBlendColorMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AlphaBlendColorMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AlphaBlendColorMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AlphaBlendColorMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<24|0xf<<20|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0xf<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct AlphaBlendAlphaMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :12;
  unsigned32 Operation                           :3;
  unsigned32 ConstantDest                        :1;
  unsigned32 ConstantSource                      :1;
  unsigned32 AlphaConversion                     :1;
  unsigned32 AlphaType                           :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 InvertDest                          :1;
  unsigned32 InvertSource                        :1;
  unsigned32 DestTimesTwo                        :1;
  unsigned32 SourceTimesTwo                      :1;
  unsigned32 DestBlend                           :3;
  unsigned32 SourceBlend                         :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 SourceBlend                         :4;
  unsigned32 DestBlend                           :3;
  unsigned32 SourceTimesTwo                      :1;
  unsigned32 DestTimesTwo                        :1;
  unsigned32 InvertSource                        :1;
  unsigned32 InvertDest                          :1;
  unsigned32 NoAlphaBuffer                       :1;
  unsigned32 AlphaType                           :1;
  unsigned32 AlphaConversion                     :1;
  unsigned32 ConstantSource                      :1;
  unsigned32 ConstantDest                        :1;
  unsigned32 Operation                           :3;
  unsigned32                                     :12;
#endif
#ifdef __cplusplus
  AlphaBlendAlphaMode(void) { }
  AlphaBlendAlphaMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  AlphaBlendAlphaMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  AlphaBlendAlphaMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  AlphaBlendAlphaMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct FBWriteBufferWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :20;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32                                     :20;
#endif
#ifdef __cplusplus
  FBWriteBufferWidth(void) { }
  FBWriteBufferWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  FBWriteBufferWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  FBWriteBufferWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  FBWriteBufferWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<0)); }
#endif /* __cplusplus */
};

struct TextureCompositeMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  TextureCompositeMode(void) { }
  TextureCompositeMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureCompositeMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureCompositeMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureCompositeMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureCompositeRGBAMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :9;
  unsigned32 Scale                               :2;
  unsigned32 Operation                           :4;
  unsigned32 B                                   :1;
  unsigned32 A                                   :1;
  unsigned32 InvertI                             :1;
  unsigned32 I                                   :3;
  unsigned32 InvertArg2                          :1;
  unsigned32 Arg2                                :4;
  unsigned32 InvertArg1                          :1;
  unsigned32 Arg1                                :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Arg1                                :4;
  unsigned32 InvertArg1                          :1;
  unsigned32 Arg2                                :4;
  unsigned32 InvertArg2                          :1;
  unsigned32 I                                   :3;
  unsigned32 InvertI                             :1;
  unsigned32 A                                   :1;
  unsigned32 B                                   :1;
  unsigned32 Operation                           :4;
  unsigned32 Scale                               :2;
  unsigned32                                     :9;
#endif
#ifdef __cplusplus
  TextureCompositeRGBAMode(void) { }
  TextureCompositeRGBAMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureCompositeRGBAMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureCompositeRGBAMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureCompositeRGBAMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<21|0xf<<17|0x1<<16|0x1<<15|0x1<<14|0x7<<11|0x1<<10|0xf<<6|0x1<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureIndexMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :6;
  unsigned32 SourceTexelEnable                   :1;
  unsigned32 LinearBias                          :2;
  unsigned32 NearestBias                         :2;
  unsigned32 MipMapEnable                        :1;
  unsigned32 Texture3DEnable                     :1;
  unsigned32 MinificationFilter                  :3;
  unsigned32 MagnificationFilter                 :1;
  unsigned32 MapType                             :1;
  unsigned32 WrapV                               :2;
  unsigned32 WrapU                               :2;
  unsigned32 Border                              :1;
  unsigned32 Height                              :4;
  unsigned32 Width                               :4;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 Width                               :4;
  unsigned32 Height                              :4;
  unsigned32 Border                              :1;
  unsigned32 WrapU                               :2;
  unsigned32 WrapV                               :2;
  unsigned32 MapType                             :1;
  unsigned32 MagnificationFilter                 :1;
  unsigned32 MinificationFilter                  :3;
  unsigned32 Texture3DEnable                     :1;
  unsigned32 MipMapEnable                        :1;
  unsigned32 NearestBias                         :2;
  unsigned32 LinearBias                          :2;
  unsigned32 SourceTexelEnable                   :1;
  unsigned32                                     :6;
#endif
#ifdef __cplusplus
  TextureIndexMode(void) { }
  TextureIndexMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureIndexMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureIndexMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureIndexMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<25|0x3<<23|0x3<<21|0x1<<20|0x1<<19|0x7<<16|0x1<<15|0x1<<14|0x3<<12|0x3<<10|0x1<<9|0xf<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LodRange {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Max                                 :12;
  unsigned32 Min                                 :12;
#else
  unsigned32 Min                                 :12;
  unsigned32 Max                                 :12;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  LodRange(void) { }
  LodRange(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LodRange& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LodRange& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LodRange& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct InvalidateCache {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 InvalidateTLB                       :1;
  unsigned32 InvalidateBank1                     :1;
  unsigned32 InvalidateBank0                     :1;
#else
  unsigned32 InvalidateBank0                     :1;
  unsigned32 InvalidateBank1                     :1;
  unsigned32 InvalidateTLB                       :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  InvalidateCache(void) { }
  InvalidateCache(const unsigned32 i) { *((unsigned32 *)this) = i; }
  InvalidateCache& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  InvalidateCache& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  InvalidateCache& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TouchLogicalPage {
#if BIG_ENDIAN == 1
  unsigned32 Mode                                :2;
  unsigned32 Count                               :14;
  unsigned32 LogicalPage                         :16;
#else
  unsigned32 LogicalPage                         :16;
  unsigned32 Count                               :14;
  unsigned32 Mode                                :2;
#endif
#ifdef __cplusplus
  TouchLogicalPage(void) { }
  TouchLogicalPage(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TouchLogicalPage& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TouchLogicalPage& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TouchLogicalPage& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3fff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct LUTMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :4;
  unsigned32 SpanVCXAlignment                    :1;
  unsigned32 SpanCCXAlignment                    :1;
  unsigned32 PatternBase                         :8;
  unsigned32 YOffset                             :3;
  unsigned32 XOffset                             :3;
  unsigned32 MotionComp8Bits                     :1;
  unsigned32 SpanOperation                       :3;
  unsigned32 FragmentOperation                   :3;
  unsigned32 LoadColorOrder                      :1;
  unsigned32 LoadFormat                          :2;
  unsigned32 InColorOrder                        :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 InColorOrder                        :1;
  unsigned32 LoadFormat                          :2;
  unsigned32 LoadColorOrder                      :1;
  unsigned32 FragmentOperation                   :3;
  unsigned32 SpanOperation                       :3;
  unsigned32 MotionComp8Bits                     :1;
  unsigned32 XOffset                             :3;
  unsigned32 YOffset                             :3;
  unsigned32 PatternBase                         :8;
  unsigned32 SpanCCXAlignment                    :1;
  unsigned32 SpanVCXAlignment                    :1;
  unsigned32                                     :4;
#endif
#ifdef __cplusplus
  LUTMode(void) { }
  LUTMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LUTMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LUTMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LUTMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<27|0x1<<26|0xff<<18|0x7<<15|0x7<<12|0x1<<11|0x7<<8|0x7<<5|0x1<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureLayoutMode {
#if BIG_ENDIAN == 1
  unsigned32 Layout15                            :2;
  unsigned32 Layout14                            :2;
  unsigned32 Layout13                            :2;
  unsigned32 Layout12                            :2;
  unsigned32 Layout11                            :2;
  unsigned32 Layout10                            :2;
  unsigned32 Layout9                             :2;
  unsigned32 Layout8                             :2;
  unsigned32 Layout7                             :2;
  unsigned32 Layout6                             :2;
  unsigned32 Layout5                             :2;
  unsigned32 Layout4                             :2;
  unsigned32 Layout3                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout0                             :2;
#else
  unsigned32 Layout0                             :2;
  unsigned32 Layout1                             :2;
  unsigned32 Layout2                             :2;
  unsigned32 Layout3                             :2;
  unsigned32 Layout4                             :2;
  unsigned32 Layout5                             :2;
  unsigned32 Layout6                             :2;
  unsigned32 Layout7                             :2;
  unsigned32 Layout8                             :2;
  unsigned32 Layout9                             :2;
  unsigned32 Layout10                            :2;
  unsigned32 Layout11                            :2;
  unsigned32 Layout12                            :2;
  unsigned32 Layout13                            :2;
  unsigned32 Layout14                            :2;
  unsigned32 Layout15                            :2;
#endif
#ifdef __cplusplus
  TextureLayoutMode(void) { }
  TextureLayoutMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureLayoutMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureLayoutMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureLayoutMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<30|0x3<<28|0x3<<26|0x3<<24|0x3<<22|0x3<<20|0x3<<18|0x3<<16|0x3<<14|0x3<<12|0x3<<10|0x3<<8|0x3<<6|0x3<<4|0x3<<2|0x3<<0)); }
#endif /* __cplusplus */
};

struct TextureMapWidth {
#if BIG_ENDIAN == 1
  unsigned32                                     :16;
  unsigned32 HostTexture                         :1;
  unsigned32 Layout                              :2;
  unsigned32 Border                              :1;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Border                              :1;
  unsigned32 Layout                              :2;
  unsigned32 HostTexture                         :1;
  unsigned32                                     :16;
#endif
#ifdef __cplusplus
  TextureMapWidth(void) { }
  TextureMapWidth(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureMapWidth& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureMapWidth& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureMapWidth& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<15|0x3<<13|0x1<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct TextureCacheReplacementMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :19;
  unsigned32 ShowCacheInfo                       :1;
  unsigned32 ScratchLines1                       :5;
  unsigned32 KeepOldest1                         :1;
  unsigned32 ScratchLines0                       :5;
  unsigned32 KeepOldest0                         :1;
#else
  unsigned32 KeepOldest0                         :1;
  unsigned32 ScratchLines0                       :5;
  unsigned32 KeepOldest1                         :1;
  unsigned32 ScratchLines1                       :5;
  unsigned32 ShowCacheInfo                       :1;
  unsigned32                                     :19;
#endif
#ifdef __cplusplus
  TextureCacheReplacementMode(void) { }
  TextureCacheReplacementMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureCacheReplacementMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureCacheReplacementMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureCacheReplacementMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<12|0x1f<<7|0x1<<6|0x1f<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PhysicalPageAllocation {
#if BIG_ENDIAN == 1
  unsigned32                                     :16;
  unsigned32 Page                                :16;
#else
  unsigned32 Page                                :16;
  unsigned32                                     :16;
#endif
#ifdef __cplusplus
  PhysicalPageAllocation(void) { }
  PhysicalPageAllocation(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PhysicalPageAllocation& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PhysicalPageAllocation& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PhysicalPageAllocation& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<0)); }
#endif /* __cplusplus */
};

struct PhysicalPageListEntry1 {
#if BIG_ENDIAN == 1
  unsigned32 PrevPage                            :16;
  unsigned32 NextPage                            :16;
#else
  unsigned32 NextPage                            :16;
  unsigned32 PrevPage                            :16;
#endif
#ifdef __cplusplus
  PhysicalPageListEntry1(void) { }
  PhysicalPageListEntry1(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PhysicalPageListEntry1& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PhysicalPageListEntry1& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PhysicalPageListEntry1& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct LogicalPageTableEntry0 {
#if BIG_ENDIAN == 1
  unsigned32                                     :15;
  unsigned32 Resident                            :1;
  unsigned32 PhysicalPage                        :16;
#else
  unsigned32 PhysicalPage                        :16;
  unsigned32 Resident                            :1;
  unsigned32                                     :15;
#endif
#ifdef __cplusplus
  LogicalPageTableEntry0(void) { }
  LogicalPageTableEntry0(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LogicalPageTableEntry0& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LogicalPageTableEntry0& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LogicalPageTableEntry0& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct LogicalPageTableEntry1 {
#if BIG_ENDIAN == 1
  unsigned32 HostPage                            :20;
  unsigned32 VirtualHostPage                     :1;
  unsigned32 MemoryPool                          :2;
  unsigned32 Length                              :9;
#else
  unsigned32 Length                              :9;
  unsigned32 MemoryPool                          :2;
  unsigned32 VirtualHostPage                     :1;
  unsigned32 HostPage                            :20;
#endif
#ifdef __cplusplus
  LogicalPageTableEntry1(void) { }
  LogicalPageTableEntry1(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LogicalPageTableEntry1& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LogicalPageTableEntry1& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LogicalPageTableEntry1& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfffff<<12|0x1<<11|0x3<<9|0x1ff<<0)); }
#endif /* __cplusplus */
};

struct LBDestReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :8;
  unsigned32 Width                               :12;
  unsigned32 Packed16                            :1;
  unsigned32 UseReadEnables                      :1;
  unsigned32 Origin                              :1;
  unsigned32 Layout                              :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Layout                              :1;
  unsigned32 Origin                              :1;
  unsigned32 UseReadEnables                      :1;
  unsigned32 Packed16                            :1;
  unsigned32 Width                               :12;
  unsigned32                                     :8;
#endif
#ifdef __cplusplus
  LBDestReadMode(void) { }
  LBDestReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBDestReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBDestReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBDestReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0x7<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct LBDestReadEnables {
#if BIG_ENDIAN == 1
  unsigned32                                     :16;
  unsigned32 R                                   :8;
  unsigned32 E                                   :8;
#else
  unsigned32 E                                   :8;
  unsigned32 R                                   :8;
  unsigned32                                     :16;
#endif
#ifdef __cplusplus
  LBDestReadEnables(void) { }
  LBDestReadEnables(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBDestReadEnables& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBDestReadEnables& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBDestReadEnables& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<8|0xff<<0)); }
#endif /* __cplusplus */
};

struct LBSourceReadMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :9;
  unsigned32 Width                               :12;
  unsigned32 Packed16                            :1;
  unsigned32 Origin                              :1;
  unsigned32 Layout                              :1;
  unsigned32 StripeHeight                        :3;
  unsigned32 StripePitch                         :3;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 PrefetchEnable                      :1;
  unsigned32 StripePitch                         :3;
  unsigned32 StripeHeight                        :3;
  unsigned32 Layout                              :1;
  unsigned32 Origin                              :1;
  unsigned32 Packed16                            :1;
  unsigned32 Width                               :12;
  unsigned32                                     :9;
#endif
#ifdef __cplusplus
  LBSourceReadMode(void) { }
  LBSourceReadMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  LBSourceReadMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  LBSourceReadMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  LBSourceReadMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xfff<<11|0x1<<10|0x1<<9|0x1<<8|0x7<<5|0x7<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GIDMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :18;
  unsigned32 ReplaceValue                        :4;
  unsigned32 ReplaceMode                         :2;
  unsigned32 CompareMode                         :2;
  unsigned32 CompareValue                        :4;
  unsigned32 SpanEnable                          :1;
  unsigned32 FragmentEnable                      :1;
#else
  unsigned32 FragmentEnable                      :1;
  unsigned32 SpanEnable                          :1;
  unsigned32 CompareValue                        :4;
  unsigned32 CompareMode                         :2;
  unsigned32 ReplaceMode                         :2;
  unsigned32 ReplaceValue                        :4;
  unsigned32                                     :18;
#endif
#ifdef __cplusplus
  GIDMode(void) { }
  GIDMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GIDMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GIDMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GIDMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xf<<10|0x3<<8|0x3<<6|0xf<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Config2D {
#if BIG_ENDIAN == 1
  unsigned32                                     :11;
  unsigned32 LUTModeEnable                       :1;
  unsigned32 FBSourceReadModeExternalSourceData  :1;
  unsigned32 FBSourceReadModeBlocking            :1;
  unsigned32 FBWriteModeWriteEnable              :1;
  unsigned32 LogicalOpModeUseConstantSource      :1;
  unsigned32 LogicalOpBackgroundLogicalOp        :4;
  unsigned32 LogicalOpBackgroundEnable           :1;
  unsigned32 LogicalOpForegroundLogicalOp        :4;
  unsigned32 LogicalOpForegroundEnable           :1;
  unsigned32 DitherModeEnable                    :1;
  unsigned32 AlphaBlendEnable                    :1;
  unsigned32 FBDestReadModeReadEnable            :1;
  unsigned32 ScissorModeUserScissorEnable        :1;
  unsigned32 RasterizerModeMultiRXBlit           :1;
  unsigned32 RasterizerModeOpaqueSpans           :1;
#else
  unsigned32 RasterizerModeOpaqueSpans           :1;
  unsigned32 RasterizerModeMultiRXBlit           :1;
  unsigned32 ScissorModeUserScissorEnable        :1;
  unsigned32 FBDestReadModeReadEnable            :1;
  unsigned32 AlphaBlendEnable                    :1;
  unsigned32 DitherModeEnable                    :1;
  unsigned32 LogicalOpForegroundEnable           :1;
  unsigned32 LogicalOpForegroundLogicalOp        :4;
  unsigned32 LogicalOpBackgroundEnable           :1;
  unsigned32 LogicalOpBackgroundLogicalOp        :4;
  unsigned32 LogicalOpModeUseConstantSource      :1;
  unsigned32 FBWriteModeWriteEnable              :1;
  unsigned32 FBSourceReadModeBlocking            :1;
  unsigned32 FBSourceReadModeExternalSourceData  :1;
  unsigned32 LUTModeEnable                       :1;
  unsigned32                                     :11;
#endif
#ifdef __cplusplus
  Config2D(void) { }
  Config2D(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Config2D& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Config2D& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Config2D& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<20|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0xf<<12|0x1<<11|0xf<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Render2D {
#if BIG_ENDIAN == 1
  unsigned32 TextureEnable                       :1;
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 IncreasingY                         :1;
  unsigned32 IncreasingX                         :1;
  unsigned32 Height                              :12;
  unsigned32 SpanOperation                       :1;
  unsigned32 FBReadSourceEnable                  :1;
  unsigned32 Operation                           :2;
  unsigned32 Width                               :12;
#else
  unsigned32 Width                               :12;
  unsigned32 Operation                           :2;
  unsigned32 FBReadSourceEnable                  :1;
  unsigned32 SpanOperation                       :1;
  unsigned32 Height                              :12;
  unsigned32 IncreasingX                         :1;
  unsigned32 IncreasingY                         :1;
  unsigned32 AreaStippleEnable                   :1;
  unsigned32 TextureEnable                       :1;
#endif
#ifdef __cplusplus
  Render2D(void) { }
  Render2D(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Render2D& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Render2D& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Render2D& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1<<30|0x1<<29|0x1<<28|0xfff<<16|0x1<<15|0x1<<14|0x3<<12|0xfff<<0)); }
#endif /* __cplusplus */
};

struct Render2DGlyph {
#if BIG_ENDIAN == 1
  signed32   AdvanceY                            :9;
  signed32   AdvanceX                            :9;
  unsigned32 Height                              :7;
  unsigned32 Width                               :7;
#else
  unsigned32 Width                               :7;
  unsigned32 Height                              :7;
  signed32   AdvanceX                            :9;
  signed32   AdvanceY                            :9;
#endif
#ifdef __cplusplus
  Render2DGlyph(void) { }
  Render2DGlyph(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Render2DGlyph& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Render2DGlyph& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Render2DGlyph& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1ff<<23|0x1ff<<14|0x7f<<7|0x7f<<0)); }
#endif /* __cplusplus */
};

struct DMAMemoryControl {
#if BIG_ENDIAN == 1
  unsigned32 WriteDMAAlignment                   :1;
  unsigned32                                     :2;
  unsigned32 BurstSize                           :5;
  unsigned32                                     :12;
  unsigned32 ReadDMAAlignment                    :1;
  unsigned32                                     :1;
  unsigned32 ReadDMAMemory                       :1;
  unsigned32 VertexAlignment                     :1;
  unsigned32                                     :1;
  unsigned32 VertexMemory                        :1;
  unsigned32 IndexAlignment                      :1;
  unsigned32                                     :1;
  unsigned32 IndexMemory                         :1;
  unsigned32 InputDMAAlignment                   :1;
  unsigned32                                     :1;
  unsigned32 InputDMAMemory                      :1;
#else
  unsigned32 InputDMAMemory                      :1;
  unsigned32                                     :1;
  unsigned32 InputDMAAlignment                   :1;
  unsigned32 IndexMemory                         :1;
  unsigned32                                     :1;
  unsigned32 IndexAlignment                      :1;
  unsigned32 VertexMemory                        :1;
  unsigned32                                     :1;
  unsigned32 VertexAlignment                     :1;
  unsigned32 ReadDMAMemory                       :1;
  unsigned32                                     :1;
  unsigned32 ReadDMAAlignment                    :1;
  unsigned32                                     :12;
  unsigned32 BurstSize                           :5;
  unsigned32                                     :2;
  unsigned32 WriteDMAAlignment                   :1;
#endif
#ifdef __cplusplus
  DMAMemoryControl(void) { }
  DMAMemoryControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DMAMemoryControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DMAMemoryControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DMAMemoryControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<31|0x1f<<24|0x1<<11|0x1<<9|0x1<<8|0x1<<6|0x1<<5|0x1<<3|0x1<<2|0x1<<0)); }
#endif /* __cplusplus */
};

struct IndexBaseAddress {
#if BIG_ENDIAN == 1
  unsigned32 Address                             :31;
  unsigned32                                     :1;
#else
  unsigned32                                     :1;
  unsigned32 Address                             :31;
#endif
#ifdef __cplusplus
  IndexBaseAddress(void) { }
  IndexBaseAddress(const unsigned32 i) { *((unsigned32 *)this) = i; }
  IndexBaseAddress& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  IndexBaseAddress& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  IndexBaseAddress& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7fffffff<<1)); }
#endif /* __cplusplus */
};

struct VertexBaseAddress {
#if BIG_ENDIAN == 1
  unsigned32 Address                             :30;
  unsigned32                                     :2;
#else
  unsigned32                                     :2;
  unsigned32 Address                             :30;
#endif
#ifdef __cplusplus
  VertexBaseAddress(void) { }
  VertexBaseAddress(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexBaseAddress& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexBaseAddress& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexBaseAddress& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3fffffff<<2)); }
#endif /* __cplusplus */
};

struct VertexControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Line2D                              :1;
  unsigned32 OGL                                 :1;
  unsigned32 SkipFlags                           :1;
  unsigned32 ReadAll                             :1;
  unsigned32 Flat                                :1;
  unsigned32 CacheEnable                         :1;
  unsigned32 Size                                :5;
#else
  unsigned32 Size                                :5;
  unsigned32 CacheEnable                         :1;
  unsigned32 Flat                                :1;
  unsigned32 ReadAll                             :1;
  unsigned32 SkipFlags                           :1;
  unsigned32 OGL                                 :1;
  unsigned32 Line2D                              :1;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  VertexControl(void) { }
  VertexControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1f<<0)); }
#endif /* __cplusplus */
};

struct VertexTagList {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Tag                                 :11;
#else
  unsigned32 Tag                                 :11;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  VertexTagList(void) { }
  VertexTagList(const unsigned32 i) { *((unsigned32 *)this) = i; }
  VertexTagList& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  VertexTagList& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  VertexTagList& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7ff<<0)); }
#endif /* __cplusplus */
};

struct IndexedDoubleVertex {
#if BIG_ENDIAN == 1
  unsigned32 Index1                              :16;
  unsigned32 Index0                              :16;
#else
  unsigned32 Index0                              :16;
  unsigned32 Index1                              :16;
#endif
#ifdef __cplusplus
  IndexedDoubleVertex(void) { }
  IndexedDoubleVertex(const unsigned32 i) { *((unsigned32 *)this) = i; }
  IndexedDoubleVertex& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  IndexedDoubleVertex& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  IndexedDoubleVertex& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xffff<<16|0xffff<<0)); }
#endif /* __cplusplus */
};

struct HostInState {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 ReadDMAPitch                        :2;
  unsigned32 ReadDMAAddress                      :2;
  unsigned32                                     :12;
  unsigned32 DataCount                           :6;
  unsigned32 ProvokingVertexSent                 :1;
  unsigned32 PrimitiveType                       :3;
  unsigned32 PrimitiveStarted                    :1;
  unsigned32 InvertBackfaceCull                  :1;
  unsigned32                                     :1;
  unsigned32 Vertex                              :2;
#else
  unsigned32 Vertex                              :2;
  unsigned32                                     :1;
  unsigned32 InvertBackfaceCull                  :1;
  unsigned32 PrimitiveStarted                    :1;
  unsigned32 PrimitiveType                       :3;
  unsigned32 ProvokingVertexSent                 :1;
  unsigned32 DataCount                           :6;
  unsigned32                                     :12;
  unsigned32 ReadDMAAddress                      :2;
  unsigned32 ReadDMAPitch                        :2;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  HostInState(void) { }
  HostInState(const unsigned32 i) { *((unsigned32 *)this) = i; }
  HostInState& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  HostInState& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  HostInState& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<29|0x3<<27|0x3f<<9|0x1<<8|0x7<<5|0x1<<4|0x1<<3|0x3<<0)); }
#endif /* __cplusplus */
};

struct Security {
#if BIG_ENDIAN == 1
  unsigned32                                     :31;
  unsigned32 Secure                              :1;
#else
  unsigned32 Secure                              :1;
  unsigned32                                     :31;
#endif
#ifdef __cplusplus
  Security(void) { }
  Security(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Security& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Security& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Security& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<0)); }
#endif /* __cplusplus */
};

struct SClkProfileMask {
#if BIG_ENDIAN == 1
  unsigned32                                     :1;
  unsigned32 Mode                                :1;
  unsigned32                                     :7;
  unsigned32 SetupOutputFull                     :1;
  unsigned32 SetupInputEmpty                     :1;
  unsigned32 PCIReadCtrlFull                     :1;
  unsigned32 PCIDataEmpty                        :1;
  unsigned32 VertexAddressEmpty                  :1;
  unsigned32 IndexAddressEmpty                   :1;
  unsigned32 DMAAddressEmpty                     :1;
  unsigned32 VertexDataEmpty                     :1;
  unsigned32 OutputFull                          :1;
  unsigned32 VertexEmpty                         :1;
  unsigned32 IndexDataEmpty                      :1;
  unsigned32 VertexFull                          :1;
  unsigned32 VertexAddressFull                   :1;
  unsigned32 IndexEmpty                          :1;
  unsigned32 DMAWriteCtrlFull                    :1;
  unsigned32 DMADataEmpty                        :1;
  unsigned32 IndexFull                           :1;
  unsigned32 IndexAddressFull                    :1;
  unsigned32 DMAEmpty                            :1;
  unsigned32 DMAFull                             :1;
  unsigned32 DMAAddressFull                      :1;
  unsigned32 InputEmpty                          :1;
  unsigned32 Always                              :1;
#else
  unsigned32 Always                              :1;
  unsigned32 InputEmpty                          :1;
  unsigned32 DMAAddressFull                      :1;
  unsigned32 DMAFull                             :1;
  unsigned32 DMAEmpty                            :1;
  unsigned32 IndexAddressFull                    :1;
  unsigned32 IndexFull                           :1;
  unsigned32 DMADataEmpty                        :1;
  unsigned32 DMAWriteCtrlFull                    :1;
  unsigned32 IndexEmpty                          :1;
  unsigned32 VertexAddressFull                   :1;
  unsigned32 VertexFull                          :1;
  unsigned32 IndexDataEmpty                      :1;
  unsigned32 VertexEmpty                         :1;
  unsigned32 OutputFull                          :1;
  unsigned32 VertexDataEmpty                     :1;
  unsigned32 DMAAddressEmpty                     :1;
  unsigned32 IndexAddressEmpty                   :1;
  unsigned32 VertexAddressEmpty                  :1;
  unsigned32 PCIDataEmpty                        :1;
  unsigned32 PCIReadCtrlFull                     :1;
  unsigned32 SetupInputEmpty                     :1;
  unsigned32 SetupOutputFull                     :1;
  unsigned32                                     :7;
  unsigned32 Mode                                :1;
  unsigned32                                     :1;
#endif
#ifdef __cplusplus
  SClkProfileMask(void) { }
  SClkProfileMask(const unsigned32 i) { *((unsigned32 *)this) = i; }
  SClkProfileMask& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  SClkProfileMask& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  SClkProfileMask& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<30|0x1<<22|0x1<<21|0x1<<20|0x1<<19|0x1<<18|0x1<<17|0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureDownloadControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :18;
  unsigned32 SlavetextureDownload                :1;
  unsigned32 TextureThreshold                    :5;
  unsigned32 TextureGranularity                  :5;
  unsigned32 TextureMemType                      :1;
  unsigned32 TextureDownloadBusy                 :1;
  unsigned32 TextureDownloadEnable               :1;
#else
  unsigned32 TextureDownloadEnable               :1;
  unsigned32 TextureDownloadBusy                 :1;
  unsigned32 TextureMemType                      :1;
  unsigned32 TextureGranularity                  :5;
  unsigned32 TextureThreshold                    :5;
  unsigned32 SlavetextureDownload                :1;
  unsigned32                                     :18;
#endif
#ifdef __cplusplus
  TextureDownloadControl(void) { }
  TextureDownloadControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureDownloadControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureDownloadControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureDownloadControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<13|0x1f<<8|0x1f<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct DeltaFormatControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :15;
  unsigned32 TextureShift1                       :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 PerPolyMipMap1                      :1;
  unsigned32 PerPolyMipMap                       :1;
  unsigned32 ShareQ                              :1;
  unsigned32 ShareT                              :1;
  unsigned32 ShareS                              :1;
  unsigned32 ForceQ                              :1;
  unsigned32 ScaleByQ1                           :1;
  unsigned32 ScaleByQ                            :1;
  unsigned32 TextureShift                        :1;
  unsigned32 WrapT1                              :1;
  unsigned32 WrapS1                              :1;
  unsigned32 WrapT                               :1;
  unsigned32 WrapS                               :1;
  unsigned32 EqualQ                              :1;
  unsigned32 Enable                              :1;
#else
  unsigned32 Enable                              :1;
  unsigned32 EqualQ                              :1;
  unsigned32 WrapS                               :1;
  unsigned32 WrapT                               :1;
  unsigned32 WrapS1                              :1;
  unsigned32 WrapT1                              :1;
  unsigned32 TextureShift                        :1;
  unsigned32 ScaleByQ                            :1;
  unsigned32 ScaleByQ1                           :1;
  unsigned32 ForceQ                              :1;
  unsigned32 ShareS                              :1;
  unsigned32 ShareT                              :1;
  unsigned32 ShareQ                              :1;
  unsigned32 PerPolyMipMap                       :1;
  unsigned32 PerPolyMipMap1                      :1;
  unsigned32 BackfaceCull                        :1;
  unsigned32 TextureShift1                       :1;
  unsigned32                                     :15;
#endif
#ifdef __cplusplus
  DeltaFormatControl(void) { }
  DeltaFormatControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaFormatControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaFormatControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaFormatControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<16|0x1<<15|0x1<<14|0x1<<13|0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct DeltaFormatMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :2;
  unsigned32                                     :3;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :20;
  unsigned32 TextureEnable                       :1;
  unsigned32                                     :5;
#else
  unsigned32                                     :5;
  unsigned32 TextureEnable                       :1;
  unsigned32                                     :20;
  unsigned32 TextureEnable1                      :1;
  unsigned32                                     :3;
  unsigned32                                     :2;
#endif
#ifdef __cplusplus
  DeltaFormatMode(void) { }
  DeltaFormatMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  DeltaFormatMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  DeltaFormatMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  DeltaFormatMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<26|0x1<<5)); }
#endif /* __cplusplus */
};

struct StripeOwnership {
#if BIG_ENDIAN == 1
  unsigned32                                     :24;
  unsigned32 Stripe1                             :3;
  unsigned32 Stripe1Enable                       :1;
  unsigned32 Stripe0                             :3;
  unsigned32 Stripe0Enable                       :1;
#else
  unsigned32 Stripe0Enable                       :1;
  unsigned32 Stripe0                             :3;
  unsigned32 Stripe1Enable                       :1;
  unsigned32 Stripe1                             :3;
  unsigned32                                     :24;
#endif
#ifdef __cplusplus
  StripeOwnership(void) { }
  StripeOwnership(const unsigned32 i) { *((unsigned32 *)this) = i; }
  StripeOwnership& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  StripeOwnership& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  StripeOwnership& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<5|0x1<<4|0x7<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct Extend {
#if BIG_ENDIAN == 1
  unsigned32                                     :21;
  unsigned32 Integer                             :8;
  unsigned32 Fraction                            :3;
#else
  unsigned32 Fraction                            :3;
  unsigned32 Integer                             :8;
  unsigned32                                     :21;
#endif
#ifdef __cplusplus
  Extend(void) { }
  Extend(const unsigned32 i) { *((unsigned32 *)this) = i; }
  Extend& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  Extend& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  Extend& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0xff<<3|0x7<<0)); }
#endif /* __cplusplus */
};

struct MatrixStatus {
#if BIG_ENDIAN == 1
  unsigned32                                     :29;
  unsigned32 BoundingBoxOverrun                  :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 StackOverflow                       :1;
#else
  unsigned32 StackOverflow                       :1;
  unsigned32 StackUnderflow                      :1;
  unsigned32 BoundingBoxOverrun                  :1;
  unsigned32                                     :29;
#endif
#ifdef __cplusplus
  MatrixStatus(void) { }
  MatrixStatus(const unsigned32 i) { *((unsigned32 *)this) = i; }
  MatrixStatus& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  MatrixStatus& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  MatrixStatus& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct GetMatrix {
#if BIG_ENDIAN == 1
  unsigned32                                     :22;
  unsigned32 Level                               :5;
  unsigned32 Select                              :4;
  unsigned32 AnyMatrix                           :1;
#else
  unsigned32 AnyMatrix                           :1;
  unsigned32 Select                              :4;
  unsigned32 Level                               :5;
  unsigned32                                     :22;
#endif
#ifdef __cplusplus
  GetMatrix(void) { }
  GetMatrix(const unsigned32 i) { *((unsigned32 *)this) = i; }
  GetMatrix& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  GetMatrix& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  GetMatrix& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1f<<5|0xf<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct TextureFogMiscGeneralContext {
#if BIG_ENDIAN == 1
  unsigned32                                     :17;
  unsigned32 TextureTexGenSelect                 :3;
  unsigned32 TextureMatrixSelect                 :3;
  unsigned32 TextureModeSelect                   :3;
  unsigned32 Vertex                              :2;
  unsigned32 ValidatedTextureFog                 :1;
  unsigned32 InPrimitive                         :1;
  unsigned32 FogEnable                           :1;
  unsigned32 TextureEnable                       :1;
#else
  unsigned32 TextureEnable                       :1;
  unsigned32 FogEnable                           :1;
  unsigned32 InPrimitive                         :1;
  unsigned32 ValidatedTextureFog                 :1;
  unsigned32 Vertex                              :2;
  unsigned32 TextureModeSelect                   :3;
  unsigned32 TextureMatrixSelect                 :3;
  unsigned32 TextureTexGenSelect                 :3;
  unsigned32                                     :17;
#endif
#ifdef __cplusplus
  TextureFogMiscGeneralContext(void) { }
  TextureFogMiscGeneralContext(const unsigned32 i) { *((unsigned32 *)this) = i; }
  TextureFogMiscGeneralContext& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  TextureFogMiscGeneralContext& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  TextureFogMiscGeneralContext& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<12|0x7<<9|0x7<<6|0x3<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PipeMode {
#if BIG_ENDIAN == 1
  unsigned32                                     :10;
  unsigned32 ObjectIDPerPrimitive                :1;
  unsigned32 ObjectTagEnable                     :1;
  unsigned32 FifoBusyLevel                       :5;
  unsigned32 MaxPrimCount                        :7;
  unsigned32 MinPrimCount                        :5;
  unsigned32 NextPipe                            :1;
  unsigned32 SwitchPipe                          :1;
  unsigned32 UseOnePipeOnly                      :1;
#else
  unsigned32 UseOnePipeOnly                      :1;
  unsigned32 SwitchPipe                          :1;
  unsigned32 NextPipe                            :1;
  unsigned32 MinPrimCount                        :5;
  unsigned32 MaxPrimCount                        :7;
  unsigned32 FifoBusyLevel                       :5;
  unsigned32 ObjectTagEnable                     :1;
  unsigned32 ObjectIDPerPrimitive                :1;
  unsigned32                                     :10;
#endif
#ifdef __cplusplus
  PipeMode(void) { }
  PipeMode(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PipeMode& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PipeMode& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PipeMode& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<21|0x1<<20|0x1f<<15|0x7f<<8|0x1f<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct PipeLoad {
#if BIG_ENDIAN == 1
  unsigned32                                     :19;
  unsigned32 BlendEnable                         :1;
  unsigned32 FogEnable                           :1;
  unsigned32 SpecularEnable                      :1;
  unsigned32 DiffuseEnable                       :1;
  unsigned32 FaceNormalEnable                    :1;
  unsigned32 TextureEnable7                      :1;
  unsigned32 TextureEnable6                      :1;
  unsigned32 TextureEnable5                      :1;
  unsigned32 TextureEnable4                      :1;
  unsigned32 TextureEnable3                      :1;
  unsigned32 TextureEnable2                      :1;
  unsigned32 TextureEnable1                      :1;
  unsigned32 ForceReload                         :1;
#else
  unsigned32 ForceReload                         :1;
  unsigned32 TextureEnable1                      :1;
  unsigned32 TextureEnable2                      :1;
  unsigned32 TextureEnable3                      :1;
  unsigned32 TextureEnable4                      :1;
  unsigned32 TextureEnable5                      :1;
  unsigned32 TextureEnable6                      :1;
  unsigned32 TextureEnable7                      :1;
  unsigned32 FaceNormalEnable                    :1;
  unsigned32 DiffuseEnable                       :1;
  unsigned32 SpecularEnable                      :1;
  unsigned32 FogEnable                           :1;
  unsigned32 BlendEnable                         :1;
  unsigned32                                     :19;
#endif
#ifdef __cplusplus
  PipeLoad(void) { }
  PipeLoad(const unsigned32 i) { *((unsigned32 *)this) = i; }
  PipeLoad& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  PipeLoad& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  PipeLoad& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x1<<12|0x1<<11|0x1<<10|0x1<<9|0x1<<8|0x1<<7|0x1<<6|0x1<<5|0x1<<4|0x1<<3|0x1<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct CommandDMAControl {
#if BIG_ENDIAN == 1
  unsigned32                                     :25;
  unsigned32 BurstSize                           :3;
  unsigned32 ByteSwap                            :2;
  unsigned32 Alignment                           :1;
  unsigned32 Protocol                            :1;
#else
  unsigned32 Protocol                            :1;
  unsigned32 Alignment                           :1;
  unsigned32 ByteSwap                            :2;
  unsigned32 BurstSize                           :3;
  unsigned32                                     :25;
#endif
#ifdef __cplusplus
  CommandDMAControl(void) { }
  CommandDMAControl(const unsigned32 i) { *((unsigned32 *)this) = i; }
  CommandDMAControl& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  CommandDMAControl& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  CommandDMAControl& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x7<<4|0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};

struct CommandState {
#if BIG_ENDIAN == 1
  unsigned32                                     :28;
  unsigned32 Started                             :2;
  unsigned32 Result                              :1;
  unsigned32 Test                                :1;
#else
  unsigned32 Test                                :1;
  unsigned32 Result                              :1;
  unsigned32 Started                             :2;
  unsigned32                                     :28;
#endif
#ifdef __cplusplus
  CommandState(void) { }
  CommandState(const unsigned32 i) { *((unsigned32 *)this) = i; }
  CommandState& operator=(const unsigned32 i) { *((unsigned32 *)this) = i; return (*this); }
  CommandState& operator&=(const unsigned32 i) { *((unsigned32 *)this) &= i; return (*this); }
  CommandState& operator|=(const unsigned32 i) { *((unsigned32 *)this) |= i; return (*this); }
  unsigned32 ReadUnmasked(void) { return *((unsigned32 *)this); }
  operator unsigned32(void) const { return (*((unsigned32 *)this) & (0x3<<2|0x1<<1|0x1<<0)); }
#endif /* __cplusplus */
};
#endif /* _REG_H_ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\rgb525.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: rgb525.h
*
* Content: This module contains the definitions for the IBM RGB525 RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "rgb526.h"
#include "rgb528.h"

//
// IBM RGB525 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _rgb525_regs {
    RAMDAC_REG  palAddrWr;      // loads internal register for palette writes
    RAMDAC_REG  palData;        // read/write to get/set palette data
    RAMDAC_REG  pixelMask;      // mask to AND with input pixel data
    RAMDAC_REG  palAddrRd;      // loads internal register for palette reads
    RAMDAC_REG  indexLow;       // low byte of internal control/cursor register
    RAMDAC_REG  indexHigh;      // high byte of internal control/cursor register
    RAMDAC_REG  indexData;      // read/write to get/set control/cursor data
    RAMDAC_REG  indexCtl;       // controls auto-increment of internal addresses
} RGB525RAMDAC, FAR *pRGB525RAMDAC;

// macro declared by any function wishing to use the RGB525 RAMDAC. MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define RGB525_DECL                                                         \
    pRGB525RAMDAC   pRGB525Regs;                                            \
    if (pDev->ChipID == PERMEDIA2_ID || pDev->ChipID == TIPERMEDIA2_ID) {   \
        pRGB525Regs = (pRGB525RAMDAC)&(pDev->pRegisters->Glint.P2ExtVCReg); \
    } else {                                                                \
        pRGB525Regs = (pRGB525RAMDAC)&(pDev->pRegisters->Glint.ExtVCReg);   \
    }
#else
#define RGB525_DECL \
    pRGB525RAMDAC   pRGB525Regs;                                            \
    if (pGLInfo->dwRenderChipID == PERMEDIA2_ID || pGLInfo->dwRenderChipID == TIPERMEDIA2_ID) {   \
        pRGB525Regs = (pRGB525RAMDAC)&(pRegisters->Glint.P2ExtVCReg);       \
    } else {                                                                \
        pRGB525Regs = (pRGB525RAMDAC)&(pRegisters->Glint.ExtVCReg);         \
    }
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
#define RGB525_PAL_WR_ADDR              ((PULONG)&(pRGB525Regs->palAddrWr.reg))
#define RGB525_PAL_RD_ADDR              ((PULONG)&(pRGB525Regs->palAddrRd.reg))
#define RGB525_PAL_DATA                 ((PULONG)&(pRGB525Regs->palData.reg))
#define RGB525_PIXEL_MASK               ((PULONG)&(pRGB525Regs->pixelMask.reg))
#define RGB525_INDEX_ADDR_LO            ((PULONG)&(pRGB525Regs->indexLow.reg))
#define RGB525_INDEX_ADDR_HI            ((PULONG)&(pRGB525Regs->indexHigh.reg))
#define RGB525_INDEX_DATA               ((PULONG)&(pRGB525Regs->indexData.reg))
#define RGB525_INDEX_CONTROL            ((PULONG)&(pRGB525Regs->indexCtl.reg))

// need a delay between each write to the 525. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. 
#if INCLUDE_DELAY
#if MINIVDD
#define RGB525_DELAY \
{ \
    volatile LONG __junk525; \
    __junk525 = pDev->pRegisters->Glint.LineCount; \
}
#else
#define RGB525_DELAY \
{ \
    volatile LONG __junk525; \
    __junk525 = pRegisters->Glint.LineCount; \
}
#endif
#else
#define RGB525_DELAY
#endif

//
// On rev 1 chips we need to SYNC with GLINT while accessing the 525. This
// is because accesses to the RAMDAC can be corrupted by localbuffer
// activity. Put this macro before accesses that can co-exist with GLINT
// 3D activity, Must have initialized glintInfo before using this.
//
#define RGB525_SYNC_WITH_GLINT \
{ \
    if (GLInfo.wRenderChipRev == GLINT300SX_REV1) \
        SYNC_WITH_GLINT; \
}


// macro to load a given data value into an internal RGB525 register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define RGB525_INDEX_REG(index) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", RGB525_INDEX_ADDR_LO, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    RGB525_DELAY; \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", RGB525_INDEX_ADDR_HI, (index) >> 8)); \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    RGB525_DELAY; \
}

#define RGB525_LOAD_DATA(data) \
{ \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", RGB525_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong (RGB525_INDEX_DATA, (ULONG)(data));    \
    RGB525_DELAY;                                               \
}

#define RGB525_LOAD_INDEX_REG(index, data) \
{ \
    RGB525_INDEX_REG(index);                            \
    VideoDebugPrint(("*(0x%x) <-- 0x%x\n", RGB525_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(RGB525_INDEX_DATA, (ULONG)((data) & 0xff)); \
    RGB525_DELAY; \
}

#define RGB525_READ_INDEX_REG(index, data) \
{ \
    RGB525_INDEX_REG(index);                            \
    data = VideoPortReadRegisterUlong(RGB525_INDEX_DATA) & 0xff;   \
    RGB525_DELAY; \
    VideoDebugPrint(("0x%x <-- *(0x%x)\n", data, RGB525_INDEX_DATA)); \
}

#define RGB525_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_LO, (ULONG)(index));  \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_INDEX_DATA,    (ULONG)(data));   \
    RGB525_DELAY; \
}

// macros to load a given RGB triple into the RGB525 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use RGB525_PALETTE_START and multiple RGB525_LOAD_PALETTE calls to load
// a contiguous set of entries. Use RGB525_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define RGB525_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PAL_WR_ADDR,     (ULONG)(index));    \
    RGB525_DELAY; \
}

#define RGB525_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PAL_RD_ADDR,     (ULONG)(index));    \
    RGB525_DELAY; \
}

#define RGB525_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(red));      \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(green));    \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(blue));     \
    RGB525_DELAY; \
}

#define RGB525_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PAL_WR_ADDR, (ULONG)(index));    \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(red));      \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(green));    \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_PAL_DATA,    (ULONG)(blue));     \
    RGB525_DELAY; \
}

// macro to read back a given RGB triple from the RGB525 palette. Use after
// a call to RGB525_PALETTE_START_RD
//
#define RGB525_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR) (VideoPortReadRegisterUlong(RGB525_PAL_DATA) & 0xff);        \
    RGB525_DELAY; \
    green = (UCHAR) (VideoPortReadRegisterUlong(RGB525_PAL_DATA) & 0xff);        \
    RGB525_DELAY; \
    blue  = (UCHAR) (VideoPortReadRegisterUlong(RGB525_PAL_DATA) & 0xff);        \
    RGB525_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define RGB525_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(RGB525_PIXEL_MASK,  (ULONG)(mask)); \
    RGB525_DELAY; \
}

#define RGB525_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(RGB525_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array
//
#define RGB525_CURSOR_ARRAY_START(offset) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_CONTROL,   (ULONG)(0x1));                      \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_LO,   (ULONG)(((offset)+0x100) & 0xff));  \
    RGB525_DELAY; \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_HI,   (ULONG)(((offset)+0x100) >> 8));    \
    RGB525_DELAY; \
}

#define RGB525_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_DATA, (ULONG)(data)); \
    RGB525_DELAY; \
}

#define RGB525_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(RGB525_INDEX_DATA) & 0xff; \
    RGB525_DELAY; \
}

// macro to move the cursor
//
#define RGB525_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_HI,   (ULONG)0);              \
    RGB525_DELAY; \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

// macro to change the cursor hotspot
//
#define RGB525_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(RGB525_INDEX_ADDR_HI,   (ULONG)(0));    \
    RGB525_DELAY; \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_X_HOT_SPOT,  (ULONG)(x));    \
    RGB525_LOAD_INDEX_REG_LO(RGB525_CURSOR_Y_HOT_SPOT,  (ULONG)(y));    \
}    

//
// RGB525 internal register indexes
//
#define RGB525_REVISION_LEVEL           0x0000
#define RGB525_ID                       0x0001

#define RGB525_MISC_CLK_CTRL            0x0002
#define RGB525_SYNC_CTRL                0x0003
#define RGB525_HSYNC_CTRL               0x0004
#define RGB525_POWER_MANAGEMENT         0x0005
#define RGB525_DAC_OPERATION            0x0006
#define RGB525_PALETTE_CTRL             0x0007
#define RGB525_PIXEL_FORMAT             0x000A
#define RGB525_8BPP_CTRL                0x000B
#define RGB525_16BPP_CTRL               0x000C
#define RGB525_24BPP_CTRL               0x000D
#define RGB525_32BPP_CTRL               0x000E

#define RGB525_PLL_CTRL_1               0x0010
#define RGB525_PLL_CTRL_2               0x0011
#define RGB525_PLL_REF_DIV_COUNT        0x0014
#define RGB525_F0                       0x0020
#define RGB525_F1                       0x0021
#define RGB525_F2                       0x0022
#define RGB525_F3                       0x0023
#define RGB525_F4                       0x0024
#define RGB525_F5                       0x0025
#define RGB525_F6                       0x0026
#define RGB525_F7                       0x0027
#define RGB525_F8                       0x0028
#define RGB525_F9                       0x0029
#define RGB525_F10                      0x002A
#define RGB525_F11                      0x002B
#define RGB525_F12                      0x002C
#define RGB525_F13                      0x002D
#define RGB525_F14                      0x002E
#define RGB525_F15                      0x002F

// RGB525 Internal Cursor Registers
#define RGB525_CURSOR_CONTROL           0x0030
#define RGB525_CURSOR_X_LOW             0x0031
#define RGB525_CURSOR_X_HIGH            0x0032
#define RGB525_CURSOR_Y_LOW             0x0033
#define RGB525_CURSOR_Y_HIGH            0x0034
#define RGB525_CURSOR_X_HOT_SPOT        0x0035
#define RGB525_CURSOR_Y_HOT_SPOT        0x0036
#define RGB525_CURSOR_COLOR_1_RED       0x0040
#define RGB525_CURSOR_COLOR_1_GREEN     0x0041
#define RGB525_CURSOR_COLOR_1_BLUE      0x0042
#define RGB525_CURSOR_COLOR_2_RED       0x0043
#define RGB525_CURSOR_COLOR_2_GREEN     0x0044
#define RGB525_CURSOR_COLOR_2_BLUE      0x0045
#define RGB525_CURSOR_COLOR_3_RED       0x0046
#define RGB525_CURSOR_COLOR_3_GREEN     0x0047
#define RGB525_CURSOR_COLOR_3_BLUE      0x0048
#define RGB525_BORDER_COLOR_RED         0x0060
#define RGB525_BORDER_COLOR_GREEN       0x0061
#define RGB525_BORDER_COLOR_BLUE        0x0062

#define RGB525_MISC_CTRL_1              0x0070
#define RGB525_MISC_CTRL_2              0x0071
#define RGB525_MISC_CTRL_3              0x0072
// M0-M7, N0-N7 need defining

#define RGB525_DAC_SENSE                0x0082
#define RGB525_MISR_RED                 0x0084
#define RGB525_MISR_GREEN               0x0086
#define RGB525_MISR_BLUE                0x0088

#define RGB525_PLL_VCO_DIV_INPUT        0x008E
#define RGB525_PLL_REF_DIV_INPUT        0x008F

#define RGB525_VRAM_MASK_LOW            0x0090
#define RGB525_VRAM_MASK_HIGH           0x0091


//
// Bit definitions for individual internal RGB525 registers
//

// RGB525_REVISION_LEVEL
#define RGB525_PRODUCT_REV_LEVEL        0xf0

// RGB525_ID
#define RGB525_PRODUCT_ID               0x01

// RGB525_MISC_CTRL_1
#define MISR_CNTL_ENABLE                0x80
#define VMSK_CNTL_ENABLE                0x40
#define PADR_RDMT_RDADDR                0x0
#define PADR_RDMT_PAL_STATE             0x20
#define SENS_DSAB_DISABLE               0x10
#define SENS_SEL_BIT3                   0x0
#define SENS_SEL_BIT7                   0x08
#define VRAM_SIZE_32                    0x0
#define VRAM_SIZE_64                    0x01

// RGB525_MISC_CTRL_2
#define PCLK_SEL_LCLK                   0x0
#define PCLK_SEL_PLL                    0x40
#define PCLK_SEL_EXT                    0x80
#define INTL_MODE_ENABLE                0x20
#define BLANK_CNTL_ENABLE               0x10
#define COL_RES_6BIT                    0x0
#define COL_RES_8BIT                    0x04
#define PORT_SEL_VGA                    0x0
#define PORT_SEL_VRAM                   0x01

// RGB525_MISC_CTRL_3
#define SWAP_RB                         0x80
#define SWAP_WORD_LOHI                  0x0
#define SWAP_WORD_HILO                  0x10
#define SWAP_NIB_HILO                   0x0
#define SWAP_NIB_LOHI                   0x02

// RGB525_MISC_CLK_CTRL
#define DDOT_CLK_ENABLE                 0x0
#define DDOT_CLK_DISABLE                0x80
#define SCLK_ENABLE                     0x0
#define SCLK_DISABLE                    0x40
#define B24P_DDOT_PLL                   0x0
#define B24P_DDOT_SCLK                  0x20
#define DDOT_DIV_PLL_1                  0x0
#define DDOT_DIV_PLL_2                  0x02
#define DDOT_DIV_PLL_4                  0x04
#define DDOT_DIV_PLL_8                  0x06
#define DDOT_DIV_PLL_16                 0x08
#define PLL_DISABLE                     0x0
#define PLL_ENABLE                      0x01

// RGB525_SYNC_CTRL
#define DLY_CNTL_ADD                    0x0
#define DLY_SYNC_NOADD                  0x80
#define CSYN_INVT_DISABLE               0x0
#define CSYN_INVT_ENABLE                0x40
#define VSYN_INVT_DISABLE               0x0
#define VSYN_INVT_ENABLE                0x20
#define HSYN_INVT_DISABLE               0x0
#define HSYN_INVT_ENABLE                0x10
#define VSYN_CNTL_NORMAL                0x0
#define VSYN_CNTL_HIGH                  0x04
#define VSYN_CNTL_LOW                   0x08
#define VSYN_CNTL_DISABLE               0x0C
#define HSYN_CNTL_NORMAL                0x0
#define HSYN_CNTL_HIGH                  0x01
#define HSYN_CNTL_LOW                   0x02
#define HSYN_CNTL_DISABLE               0x03

// RGB525_HSYNC_CTRL
#define HSYN_POS(n)                     (n)

// RGB525_POWER_MANAGEMENT
#define SCLK_PWR_NORMAL                 0x0
#define SCLK_PWR_DISABLE                0x10
#define DDOT_PWR_NORMAL                 0x0
#define DDOT_PWR_DISABLE                0x08
#define SYNC_PWR_NORMAL                 0x0
#define SYNC_PWR_DISABLE                0x04
#define ICLK_PWR_NORMAL                 0x0
#define ICLK_PWR_DISABLE                0x02
#define DAC_PWR_NORMAL                  0x0
#define DAC_PWR_DISABLE                 0x01

// RGB525_DAC_OPERATION
#define SOG_DISABLE                     0x0
#define SOG_ENABLE                      0x08
#define BRB_NORMAL                      0x0
#define BRB_ALWAYS                      0x04
#define DSR_DAC_SLOW                    0x0
#define DSR_DAC_FAST                    0x02
#define DPE_DISABLE                     0x0
#define DPE_ENABLE                      0x01

// RGB525_PALETTE_CTRL
#define SIXBIT_LINEAR_ENABLE            0x0
#define SIXBIT_LINEAR_DISABLE           0x80
#define PALETTE_PARITION(n)             (n)

// RGB525_PIXEL_FORMAT
#define PIXEL_FORMAT_4BPP               0x02
#define PIXEL_FORMAT_8BPP               0x03
#define PIXEL_FORMAT_16BPP              0x04
#define PIXEL_FORMAT_24BPP              0x05
#define PIXEL_FORMAT_32BPP              0x06

// RGB525_8BPP_CTRL
#define B8_DCOL_INDIRECT                0x0
#define B8_DCOL_DIRECT                  0x01

// RGB525_16BPP_CTRL
#define B16_DCOL_INDIRECT               0x0
#define B16_DCOL_DYNAMIC                0x40
#define B16_DCOL_DIRECT                 0xC0
#define B16_POL_FORCE_BYPASS            0x0
#define B16_POL_FORCE_LOOKUP            0x20
#define B16_ZIB                         0x0
#define B16_LINEAR                      0x04
#define B16_555                         0x0
#define B16_565                         0x02
#define B16_SPARSE                      0x0
#define B16_CONTIGUOUS                  0x01

// RGB525_24BPP_CTRL
#define B24_DCOL_INDIRECT               0x0
#define B24_DCOL_DIRECT                 0x01

// RGB525_32BPP_CTRL
#define B32_POL_FORCE_BYPASS            0x0
#define B32_POL_FORCE_LOOKUP            0x04
#define B32_DCOL_INDIRECT               0x0
#define B32_DCOL_DYNAMIC                0x01
#define B32_DCOL_DIRECT                 0x03

// RGB525_PLL_CTRL_1
#define REF_SRC_REFCLK                  0x0
#define REF_SRC_EXTCLK                  0x10
#define PLL_EXT_FS_3_0                  0x0
#define PLL_EXT_FS_2_0                  0x01
#define PLL_CNTL2_3_0                   0x02
#define PLL_CNTL2_2_0                   0x03

// RGB525_PLL_CTRL_2
#define PLL_INT_FS_3_0(n)               (n)
#define PLL_INT_FS_2_0(n)               (n)

// RGB525_PLL_REF_DIV_COUNT
#define REF_DIV_COUNT(n)                (n)

// RGB525_F0 - RGB525_F15
#define VCO_DIV_COUNT(n)                (n)

// RGB525_PLL_REFCLK values
#define RGB525_PLL_REFCLK_MHz(n)        ((n)/2)

// RGB525_CURSOR_CONTROL
#define SMLC_PART_0                     0x0
#define SMLC_PART_1                     0x40
#define SMLC_PART_2                     0x80
#define SMLC_PART_3                     0xC0

#define RGBCINDEX_TO_VALUE(whichRGBCursor) (whichRGBCursor << 6)

#define PIX_ORDER_RL                    0x0
#define PIX_ORDER_LR                    0x20
#define LOC_READ_LAST                   0x0
#define LOC_READ_ACTUAL                 0x10
#define UPDT_CNTL_DELAYED               0x0
#define UPDT_CNTL_IMMEDIATE             0x08
#define CURSOR_SIZE_32                  0x0
#define CURSOR_SIZE_64                  0x40
#define CURSOR_MODE_OFF                 0x0
#define CURSOR_MODE_3_COLOR             0x01
#define CURSOR_MODE_2_COLOR_HL          0x02
#define CURSOR_MODE_2_COLOR             0x03

// RGB525_REVISION_LEVEL
#define REVISION_LEVEL                  0xF0    // predefined

// RGB525_ID
#define ID_CODE                         0x01    // predefined
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\rgb528.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: rgb528.h
*
* Content: This module contains the definitions for the IBM RGB528 RAMDAC.
*          The 528 is a superset of the 525 so only define things which have 
*          changed.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// RGB528_REVISION_LEVEL
#define RGB528_PRODUCT_REV_LEVEL        0xf0
#define RGB528A_PRODUCT_REV_LEVEL       0xe0

// RGB528_ID
#define RGB528_PRODUCT_ID               0x02


// RGB525_MISC_CTRL_1 extra value
#define VRAM_SIZE_128                   0x03

// RGB524_REVISION_LEVEL
#define RGB524_PRODUCT_REV_LEVEL        0xf0
#define RGB524A_PRODUCT_REV_LEVEL       0xe0

// RGB524_ID
#define RGB524_PRODUCT_ID               0x02
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\rgb640.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: rgb640.h
*
* Content: This module contains the definitions for the IBM RGB640 RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//
// IBM RGB640 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _rgb640_regs {
    RAMDAC_REG  palAddrWr;      // loads internal register for palette writes
    RAMDAC_REG  palData;        // read/write to get/set palette data
    RAMDAC_REG  pixelMask;      // mask to AND with input pixel data
    RAMDAC_REG  palAddrRd;      // loads internal register for palette reads
    RAMDAC_REG  indexLow;       // low byte of internal control/cursor register
    RAMDAC_REG  indexHigh;      // high byte of internal control/cursor register
    RAMDAC_REG  indexData;      // read/write to get/set control/cursor data
    RAMDAC_REG  Reserved;
} RGB640RAMDAC, *pRGB640RAMDAC;


// structure containing the mapped addresses for each of the RGB640 registers.
// We need this since some chips like the Alpha cannot be accessed by simply
// writing to the memory mapped register. So instead we set up the following
// struct of memory addresses at init time and use these instead. All these
// addresses must be passed to WRITE/READ_FAST_ULONG.
// We also keep software copies of various registers in here so we can turn
// on and off individual bits more easily.
//
typedef struct _rgb640_data {

    // register addresses

    ULONG *       palAddrWr;      // loads internal register for palette writes
    ULONG *       palData;        // read/write to get/set palette data
    ULONG *       pixelMask;      // mask to AND with input pixel data
    ULONG *       palAddrRd;      // loads internal register for palette reads
    ULONG *       indexLow;       // low byte of internal control/cursor register
    ULONG *       indexHigh;      // high byte of internal control/cursor register
    ULONG *       indexData;      // read/write to get/set control/cursor data
    ULONG *       indexCtl;       // controls auto-increment of internal addresses

    // register copies

    ULONG       cursorControl;  // controls enable/disable

} RGB640Data, *pRGB640Data;

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
#define RGB640_PAL_WR_ADDR              pRGB640info->palAddrWr
#define RGB640_PAL_RD_ADDR              pRGB640info->palAddrRd
#define RGB640_PAL_DATA                 pRGB640info->palData
#define RGB640_PIXEL_MASK               pRGB640info->pixelMask
#define RGB640_INDEX_ADDR_LO            pRGB640info->indexLow
#define RGB640_INDEX_ADDR_HI            pRGB640info->indexHigh
#define RGB640_INDEX_DATA               pRGB640info->indexData
#define RGB640_INDEX_CONTROL            pRGB640info->indexCtl


//
// generic read/write routines for 640 registers
//
#define WRITE_640REG_ULONG(r, d) \
{ \
    WRITE_FAST_ULONG(r, (ULONG)(d)); \
    MEMORY_BARRIER(); \
}
    
#define READ_640REG_ULONG(r)    READ_FAST_ULONG(r)
    

// We have to have a delay between all accesses to the RGB640. A simple
// for loop delay is not good enough since writes to GLINT are posted
// and may still get batched together. The only sure way is to do a read
// from bypass space. Arbitrarily, we choose the FBModeSel register since
// we already have a macro to read it. PPC needs 2 reads to give us enough
// time.
//
#define RGB640_DELAY \
{ \
    volatile ULONG __junk;          \
    GLINT_GET_PACKING_MODE(__junk); \
    GLINT_GET_PACKING_MODE(__junk); \
}

// macro to load a given data value into an internal RGB640 register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define RGB640_INDEX_INCREMENT(n) \
{ \
    /*WRITE_640REG_ULONG (RGB640_INDEX_CONTROL, (ULONG)(n));    */\
    RGB640_DELAY;                                               \
}

// macro to load a given data value into an internal RGB640 register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
#define RGB640_INDEX_REG(index) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    RGB640_DELAY; \
}

#define RGB640_LOAD_DATA(data) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)((data) & 0xff)); \
    RGB640_DELAY; \
}

#define RGB640_LOAD_INDEX_REG(index, data) \
{ \
    RGB640_INDEX_REG(index);                            \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)((data) & 0xff)); \
    RGB640_DELAY; \
}

#define RGB640_READ_INDEX_REG(index, data) \
{ \
    RGB640_INDEX_REG(index);                            \
    data = (UCHAR) (READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);   \
    RGB640_DELAY; \
}

#define RGB640_LOAD_INDEX_REG_LO(index, data) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO, (ULONG)(index));  \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA,    (ULONG)(data));   \
    RGB640_DELAY; \
}

// macros to load a given RGB triple into the RGB640 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use RGB640_PALETTE_START and multiple RGB640_LOAD_PALETTE calls to load
// a contiguous set of entries. Use RGB640_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define RGB640_PALETTE_START_WR(index) \
    RGB640_INDEX_REG((index) + 0x4000)

#define RGB640_PALETTE_START_RD(index) \
    RGB640_INDEX_REG((index) + 0x8000)

#define RGB640_LOAD_PALETTE(red, green, blue) \
{ \
    RGB640_LOAD_DATA(red);      \
    RGB640_LOAD_DATA(green);    \
    RGB640_LOAD_DATA(blue);     \
}

#define RGB640_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    RGB640_PALETTE_START_WR(index); \
    RGB640_LOAD_PALETTE(red, green, blue); \
}

// macro to read back a given RGB triple from the RGB640 palette. Use after
// a call to RGB640_PALETTE_START_RD
//
#define RGB640_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);        \
    RGB640_DELAY; \
    green = (UCHAR)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);        \
    RGB640_DELAY; \
    blue  = (UCHAR)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);        \
    RGB640_DELAY; \
}

// Accesses to 1024x30 palette using four accesses

#define RGB640_LOAD_PALETTE10(red, green, blue) \
{ \
    RGB640_LOAD_DATA ((red) >> 2);              \
    RGB640_LOAD_DATA ((green) >> 2);            \
    RGB640_LOAD_DATA ((blue) >> 2);             \
    RGB640_LOAD_DATA ((((red)   & 3) << 4) |    \
                      (((green) & 3) << 2) |    \
                      (((blue)  & 3)     ));    \
}

#define RGB640_LOAD_PALETTE10_INDEX(index, red, green, blue) \
{ \
    RGB640_PALETTE_START_WR(index); \
    RGB640_LOAD_PALETTE10(red, green, blue); \
}

// macro to read back a given RGB triple from the RGB640 palette. Use after
// a call to RGB640_PALETTE_START_RD
//
#define RGB640_READ_PALETTE10(red, green, blue) \
{ \
    USHORT  temp; \
    red   = (USHORT)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff) << 2;   \
    RGB640_DELAY; \
    green = (USHORT)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff) << 2;   \
    RGB640_DELAY; \
    blue  = (USHORT)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff) << 2;   \
    RGB640_DELAY; \
    temp  = (USHORT)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff);        \
    RGB640_DELAY; \
    red   |= (temp >> 4) & 0x3; \
    green |= (temp >> 2) & 0x3; \
    blue  |=  temp       & 0x3; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define RGB640_SET_PIXEL_READMASK(mask) \
{ \
    WRITE_640REG_ULONG(RGB640_PIXEL_MASK,  (ULONG)(mask)); \
    RGB640_DELAY; \
}

#define RGB640_READ_PIXEL_READMASK(mask) \
{ \
    mask = (UCHAR)(READ_640REG_ULONG (RGB640_PIXEL_MASK) & 0xff); \
    RGB640_DELAY; \
}

// macros to load values into the cursor array
//
#define RGB640_CURSOR_ARRAY_START_WR(offset) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO,   (ULONG)(((offset)+0x1000) & 0xff));  \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_HI,   (ULONG)(((offset)+0x1000) >> 8));    \
    RGB640_DELAY; \
}

#define RGB640_CURSOR_ARRAY_START_RD(offset) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO,   (ULONG)(((offset)+0x2000) & 0xff));  \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_HI,   (ULONG)(((offset)+0x2000) >> 8));    \
    RGB640_DELAY; \
}

#define RGB640_LOAD_CURSOR_ARRAY(data) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)(data)); \
    RGB640_DELAY; \
}

#define RGB640_READ_CURSOR_ARRAY(data) \
{ \
    data = (UCHAR)(READ_640REG_ULONG (RGB640_INDEX_DATA) & 0xff); \
    RGB640_DELAY; \
}

// macro to move the cursor
//
#define RGB640_MOVE_CURSOR(x, y) \
{ \
    RGB640_INDEX_REG (RGB640_CURSOR_X_LOW); \
    RGB640_LOAD_DATA ((ULONG)((x) & 0xff)); \
    RGB640_LOAD_DATA ((ULONG)((x) >> 8));   \
    RGB640_LOAD_DATA ((ULONG)((y) & 0xff)); \
    RGB640_LOAD_DATA ((ULONG)((y) >> 8));   \
}

// macro to change the cursor hotspot
//
#define RGB640_CURSOR_HOTSPOT(x, y) \
{ \
    RGB640_INDEX_REG (RGB640_CURSOR_X_HOT_SPOT); \
    RGB640_LOAD_DATA ((ULONG)(x));               \
    RGB640_LOAD_DATA ((ULONG)(y));               \
}
    
// macro to change the cursor color
//
#define RGB640_CURSOR_COLOR(red, green, blue) \
{ \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_HI,   (ULONG)(0x4800 >> 8));    \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_ADDR_LO,   (ULONG)(0x4800 & 0xff));    \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)(red)); \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)(data)); \
    RGB640_DELAY; \
    WRITE_640REG_ULONG(RGB640_INDEX_DATA, (ULONG)(green)); \
    RGB640_DELAY; \
}
    


//
// RGB640 internal register indexes
//

//
// These are the same as for the 525 so we use 525 definitions when getting
// RGBxxx Dac ids.
//
//#define RGB640_REVISION_LEVEL           0x0000
//#define RGB640_ID                       0x0001

#define RGB640_SERIALIZER_PIXEL_07_00   0x0002
#define RGB640_SERIALIZER_PIXEL_15_08   0x0003
#define RGB640_SERIALIZER_PIXEL_23_16   0x0004
#define RGB640_SERIALIZER_PIXEL_31_24   0x0005
#define RGB640_SERIALIZER_WID_03_00     0x0006
#define RGB640_SERIALIZER_WID_07_04     0x0007
#define RGB640_SERIALIZER_MODE          0x0008

#define RGB640_PIXEL_INTERLEAVE         0x0009
#define RGB640_MISC_CONFIG              0x000A
#define RGB640_VGA_CONTROL              0x000B
#define RGB640_DAC_COMPARE_MONITOR_ID   0x000C
#define RGB640_DAC_CONTROL              0x000D
#define RGB640_UPDATE_CONTROL           0x000E
#define RGB640_SYNC_CONTROL             0x000F
#define RGB640_VIDEO_PLL_REF_DIV        0x0010
#define RGB640_VIDEO_PLL_MULT           0x0011
#define RGB640_VIDEO_PLL_OUTPUT_DIV     0x0012
#define RGB640_VIDEO_PLL_CONTROL        0x0013
#define RGB640_VIDEO_AUX_REF_DIV        0x0014
#define RGB640_VIDEO_AUX_MULT           0x0015
#define RGB640_VIDEO_AUX_OUTPUT_DIV     0x0016
#define RGB640_VIDEO_AUX_CONTROL        0x0017

#define RGB640_CHROMA_KEY_0             0x0020
#define RGB640_CHROMA_KEY_MASK_0        0x0021
#define RGB640_CHROMA_KEY_1             0x0022
#define RGB640_CHROMA_KEY_MASK_1        0x0023
#define RGB640_CHROMA_KEY_0             0x0020
#define RGB640_CHROMA_KEY_0             0x0020

// RGB640 Internal Cursor Registers
#define RGB640_CURSOR_XHAIR_CONTROL     0x0030
#define RGB640_CURSOR_BLINK_RATE        0x0031
#define RGB640_CURSOR_BLINK_DUTY_CYCLE  0x0032
#define RGB640_CURSOR_X_LOW             0x0040
#define RGB640_CURSOR_X_HIGH            0x0041
#define RGB640_CURSOR_Y_LOW             0x0042
#define RGB640_CURSOR_Y_HIGH            0x0043
#define RGB640_CURSOR_X_HOT_SPOT        0x0044
#define RGB640_CURSOR_Y_HOT_SPOT        0x0045
#define RGB640_ADV_CURSOR_COLOR_0       0x0046
#define RGB640_ADV_CURSOR_COLOR_1       0x0047
#define RGB640_ADV_CURSOR_COLOR_2       0x0048
#define RGB640_ADV_CURSOR_COLOR_3       0x0049
#define RGB640_ADV_CURSOR_ATTR_TABLE    0x004A
#define RGB640_CURSOR_CONTROL           0x004B
#define RGB640_XHAIR_X_LOW              0x0050
#define RGB640_XHAIR_X_HIGH             0x0051
#define RGB640_XHAIR_Y_LOW              0x0052
#define RGB640_XHAIR_Y_HIGH             0x0053
#define RGB640_XHAIR_PATTERN_COLOR      0x0054
#define RGB640_XHAIR_HORZ_PATTERN       0x0055
#define RGB640_XHAIR_VERT_PATTERN       0x0056
#define RGB640_XHAIR_CONTROL_1          0x0057
#define RGB640_XHAIR_CONTROL_2          0x0058

#define RGB640_YUV_COEFFICIENT_K1       0x0070
#define RGB640_YUV_COEFFICIENT_K2       0x0071
#define RGB640_YUV_COEFFICIENT_K3       0x0072
#define RGB640_YUV_COEFFICIENT_K4       0x0073

#define RGB640_VRAM_MASK_REG_0          0x00F0
#define RGB640_VRAM_MASK_REG_1          0x00F1
#define RGB640_VRAM_MASK_REG_2          0x00F2

#define RGB640_DIAGNOSTICS              0x00FA
#define RGB640_MISR_CONTOL_STATUS       0x00FB
#define RGB640_MISR_SIGNATURE_0         0x00FC
#define RGB640_MISR_SIGNATURE_1         0x00FD
#define RGB640_MISR_SIGNATURE_2         0x00FE
#define RGB640_MISR_SIGNATURE_3         0x00FF

#define RGB640_FRAMEBUFFER_WAT(n)       (0x0100 + (n))
#define RGB640_OVERLAY_WAT(n)           (0x0200 + (n))
#define RGB640_CURSOR_PIXEL_MAP_WR(n)   (0x1000 + (n))
#define RGB640_CURSOR_PIXEL_MAP_RD(n)   (0x2000 + (n))

#define RGB640_MAIN_COLOR_PAL_WR(n)     (0x4000 + (n))

#define RGB640_CURSOR_COLOR_0_WR        0x4800
#define RGB640_CURSOR_COLOR_1_WR        0x4801
#define RGB640_CURSOR_COLOR_2_WR        0x4802
#define RGB640_CURSOR_COLOR_3_WR        0x4803
#define RGB640_ALT_CURSOR_COLOR_0_WR    0x4804
#define RGB640_ALT_CURSOR_COLOR_1_WR    0x4805
#define RGB640_ALT_CURSOR_COLOR_2_WR    0x4806
#define RGB640_ALT_CURSOR_COLOR_3_WR    0x4807
#define RGB640_XHAIR_COLOR_0_WR         0x4808
#define RGB640_XHAIR_COLOR_1_WR         0x4809
#define RGB640_XHAIR_COLOR_2_WR         0x480A
#define RGB640_XHAIR_COLOR_3_WR         0x480B
#define RGB640_ALT_XHAIR_COLOR_0_WR     0x480C
#define RGB640_ALT_XHAIR_COLOR_1_WR     0x480D
#define RGB640_ALT_XHAIR_COLOR_2_WR     0x480E
#define RGB640_ALT_XHAIR_COLOR_3_WR     0x480F

#define RGB640_MAIN_COLOR_PAL_RD(n)     (0x8000 + (n))

#define RGB640_CURSOR_COLOR_0_RD        0x8800
#define RGB640_CURSOR_COLOR_1_RD        0x8801
#define RGB640_CURSOR_COLOR_2_RD        0x8802
#define RGB640_CURSOR_COLOR_3_RD        0x8803
#define RGB640_ALT_CURSOR_COLOR_0_RD    0x8804
#define RGB640_ALT_CURSOR_COLOR_1_RD    0x8805
#define RGB640_ALT_CURSOR_COLOR_2_RD    0x8806
#define RGB640_ALT_CURSOR_COLOR_3_RD    0x8807
#define RGB640_XHAIR_COLOR_0_RD         0x8808
#define RGB640_XHAIR_COLOR_1_RD         0x8809
#define RGB640_XHAIR_COLOR_2_RD         0x880A
#define RGB640_XHAIR_COLOR_3_RD         0x880B
#define RGB640_ALT_XHAIR_COLOR_0_RD     0x880C
#define RGB640_ALT_XHAIR_COLOR_1_RD     0x880D
#define RGB640_ALT_XHAIR_COLOR_2_RD     0x880E
#define RGB640_ALT_XHAIR_COLOR_3_RD     0x880F


//
// Bit definitions for individual internal RGB640 registers
//

// RGB640_REVISION_LEVEL
#define RGB640_IDENTIFICATION_CODE      0x1c

// RGB640_ID
#define RGB640_ID_REVISION_LEVEL        (0x02 | (0x01 << 4))

// Cursor definitions
//

#define RGB640_CURSOR_PARTITION_0       0
#define RGB640_CURSOR_PARTITION_1       (1 << 6)
#define RGB640_CURSOR_PARTITION_2       (2 << 6)
#define RGB640_CURSOR_PARTITION_3       (3 << 6)
#define RGB640_CURSOR_SIZE_32           0x0
#define RGB640_CURSOR_SIZE_64           (1 << 3)
#define RGB640_CURSOR_BLINK_OFF         0
#define RGB640_CURSOR_BLINK_ON          (1 << 5)
#define RGB640_CURSOR_MODE_OFF          0
#define RGB640_CURSOR_MODE_0            1
#define RGB640_CURSOR_MODE_1            2
#define RGB640_CURSOR_MODE_2            3
#define RGB640_CURSOR_MODE_ADVANCED     4

// we only ever use a two color cursor so define registers and enable bits.
// for each 2 bit pixel that defines the cursor shape, bit 0x2 defines the
// foreground and bit 0x1 defines the background.
// NB: the transparent cursor pixel value depends on the cursor mode chosen.
//
#define RGB640_CURSOR_MODE_ON           RGB640_CURSOR_MODE_1
#define RGB640_CURSOR_TRANSPARENT_PEL   0xAA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\tag.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: tag.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __TAG_H
#define __TAG_H

#ifndef _TAG_H_
#define _TAG_H_

#define StartXDom_Tag 0x0000
#define dXDom_Tag 0x0001
#define StartXSub_Tag 0x0002
#define dXSub_Tag 0x0003
#define StartY_Tag 0x0004
#define dY_Tag 0x0005
#define Count_Tag 0x0006
#define Render_Tag 0x0007
#define ContinueNewLine_Tag 0x0008
#define ContinueNewDom_Tag 0x0009
#define ContinueNewSub_Tag 0x000a
#define Continue_Tag 0x000b
#define FlushSpan_Tag 0x000c
#define BitMaskPattern_Tag 0x000d
#define PointTable0_Tag 0x0010
#define PointTable1_Tag 0x0011
#define PointTable2_Tag 0x0012
#define PointTable3_Tag 0x0013
#define RasterizerMode_Tag 0x0014
#define YLimits_Tag 0x0015
#define ScanlineOwnership_Tag 0x0016
#define WaitForCompletion_Tag 0x0017
#define PixelSize_Tag 0x0018
#define XLimits_Tag 0x0019
#define StripeOffsetY_Tag 0x0019
#define RectangleOrigin_Permedia_Tag 0x001a
#define RectangleSize_Tag 0x001b
#define ReadMonitorMode_Tag 0x001f
#define FastBlockLimits_Tag 0x0026
#define FastBlockFill_Tag 0x0027
#define ForceBackgroundColor_Tag 0x0029
#define PackedDataLimits_Tag 0x002a
#define ScissorMode_Tag 0x0030
#define ScissorMinXY_Tag 0x0031
#define ScissorMaxXY_Tag 0x0032
#define ScreenSize_Tag 0x0033
#define AreaStippleMode_Tag 0x0034
#define LineStippleMode_Tag 0x0035
#define LoadLineStippleCounters_Tag 0x0036
#define UpdateLineStippleCounters_Tag 0x0037
#define SaveLineStippleCounters_Tag 0x0038
#define SaveLineStippleState_Tag 0x0038
#define WindowOrigin_Tag 0x0039
#define AreaStipplePattern0_Tag 0x0040
#define AreaStipplePattern1_Tag 0x0041
#define AreaStipplePattern2_Tag 0x0042
#define AreaStipplePattern3_Tag 0x0043
#define AreaStipplePattern4_Tag 0x0044
#define AreaStipplePattern5_Tag 0x0045
#define AreaStipplePattern6_Tag 0x0046
#define AreaStipplePattern7_Tag 0x0047
#define AreaStipplePattern8_Tag 0x0048
#define AreaStipplePattern9_Tag 0x0049
#define AreaStipplePattern10_Tag 0x004a
#define AreaStipplePattern11_Tag 0x004b
#define AreaStipplePattern12_Tag 0x004c
#define AreaStipplePattern13_Tag 0x004d
#define AreaStipplePattern14_Tag 0x004e
#define AreaStipplePattern15_Tag 0x004f
#define AreaStipplePattern16_Tag 0x0050
#define AreaStipplePattern17_Tag 0x0051
#define AreaStipplePattern18_Tag 0x0052
#define AreaStipplePattern19_Tag 0x0053
#define AreaStipplePattern20_Tag 0x0054
#define AreaStipplePattern21_Tag 0x0055
#define AreaStipplePattern22_Tag 0x0056
#define AreaStipplePattern23_Tag 0x0057
#define AreaStipplePattern24_Tag 0x0058
#define AreaStipplePattern25_Tag 0x0059
#define AreaStipplePattern26_Tag 0x005a
#define AreaStipplePattern27_Tag 0x005b
#define AreaStipplePattern28_Tag 0x005c
#define AreaStipplePattern29_Tag 0x005d
#define AreaStipplePattern30_Tag 0x005e
#define AreaStipplePattern31_Tag 0x005f
#define FillFBWriteBufferAddr0_Tag 0x0060
#define FillFBSourceReadBufferAddr_Tag 0x0061
#define FillFBDestReadBufferAddr0_Tag 0x0062
#define FillScissorMinXY_Tag 0x0063
#define FillScissorMaxXY_Tag 0x0064
#define FillForegroundColor0_Tag 0x0065
#define FillBackgroundColor_Tag 0x0066
#define FillConfig2D0_Tag 0x0067
#define FillFBSourceReadBufferOffset_Tag 0x0068
#define FillRectanglePosition_Tag 0x0069
#define FillRender2D_Tag 0x006a
#define FillForegroundColor1_Tag 0x006b
#define FillConfig2D1_Tag 0x006c
#define FillGlyphPosition_Tag 0x006d
#define TextureAddressMode_Tag 0x0070
#define TextureCoordMode_Tag 0x0070
#define SStart_Tag 0x0071
#define dSdx_Tag 0x0072
#define dSdyDom_Tag 0x0073
#define TStart_Tag 0x0074
#define dTdx_Tag 0x0075
#define dTdyDom_Tag 0x0076
#define QStart_Tag 0x0077
#define dQdx_Tag 0x0078
#define dQdyDom_Tag 0x0079
#define LOD_Tag 0x007a
#define dSdy_Tag 0x007b
#define dTdy_Tag 0x007c
#define dQdy_Tag 0x007d
#define S1Start_Tag 0x0080
#define TexelCoordUV_Tag 0x0081
#define dS1dx_Tag 0x0081
#define TexelCoordU_Tag 0x0082
#define dS1dyDom_Tag 0x0082
#define TexelCoordV_Tag 0x0083
#define T1Start_Tag 0x0083
#define dT1dx_Tag 0x0084
#define dT1dyDom_Tag 0x0085
#define Q1Start_Tag 0x0086
#define dQ1dx_Tag 0x0087
#define dQ1dyDom_Tag 0x0088
#define LOD1_Tag 0x0089
#define TextureLODBiasS_Tag 0x008a
#define TextureLODBiasT_Tag 0x008b
#define TextureReadMode_Tag 0x0090
#define TextureFormat_Tag 0x0091
#define TextureCacheControl_Tag 0x0092
#define BorderColor_Tag 0x0095
#define BorderColor0_Tag 0x0095
#define TexelLUTIndex_Tag 0x0098
#define LUTIndex_Tag 0x0098
#define TexelLUTData_Tag 0x0099
#define LUTData_Tag 0x0099
#define TexelLUTAddress_Tag 0x009a
#define LUTAddress_Tag 0x009a
#define TexelLUTTransfer_Tag 0x009b
#define LUTTransfer_Tag 0x009b
#define TextureFilterMode_Tag 0x009c
#define TextureChromaUpper_Tag 0x009d
#define TextureChromaUpper0_Tag 0x009d
#define TextureChromaLower_Tag 0x009e
#define TextureChromaLower0_Tag 0x009e
#define BorderColor1_Tag 0x009f
#define TextureBaseAddress_Tag 0x00a0
#define TextureBaseAddr0_Tag 0x00a0
#define TextureBaseAddressLR_Tag 0x00a1
#define TextureBaseAddr1_Tag 0x00a1
#define TextureBaseAddr2_Tag 0x00a2
#define TextureBaseAddr3_Tag 0x00a3
#define TextureBaseAddr4_Tag 0x00a4
#define TextureBaseAddr5_Tag 0x00a5
#define TextureBaseAddr6_Tag 0x00a6
#define TextureBaseAddr7_Tag 0x00a7
#define TextureBaseAddr8_Tag 0x00a8
#define TextureBaseAddr9_Tag 0x00a9
#define TextureBaseAddr10_Tag 0x00aa
#define TextureBaseAddr11_Tag 0x00ab
#define TextureBaseAddr12_Tag 0x00ac
#define TextureBaseAddr13_Tag 0x00ad
#define TextureBaseAddr14_Tag 0x00ae
#define TextureBaseAddr15_Tag 0x00af
#define TextureBaseAddress_Permedia_Tag 0x00b0
#define TextureMapWidth0_Tag 0x00b0
#define TextureMapFormat_Tag 0x00b1
#define TextureMapWidth1_Tag 0x00b1
#define TextureDataFormat_Tag 0x00b2
#define TextureMapWidth2_Tag 0x00b2
#define TextureMapWidth3_Tag 0x00b3
#define TextureMapWidth4_Tag 0x00b4
#define TextureReadPad_Tag 0x00b5
#define TextureMapWidth5_Tag 0x00b5
#define TextureMapWidth6_Tag 0x00b6
#define TextureMapWidth7_Tag 0x00b7
#define TextureMapWidth8_Tag 0x00b8
#define TextureMapWidth9_Tag 0x00b9
#define TextureMapWidth10_Tag 0x00ba
#define TextureMapWidth11_Tag 0x00bb
#define TextureMapWidth12_Tag 0x00bc
#define TextureMapWidth13_Tag 0x00bd
#define TextureMapWidth14_Tag 0x00be
#define TextureMapWidth15_Tag 0x00bf
#define Texel0_Tag 0x00c0
#define TextureChromaUpper1_Tag 0x00c0
#define TextureChromaLower1_Tag 0x00c1
#define TextureFilter_Tag 0x00cd
#define TextureReadMode_Permedia_Tag 0x00ce
#define TexelLUTMode_Tag 0x00cf
#define TextureColorMode_Tag 0x00d0
#define TextureApplicationMode_Tag 0x00d0
#define TextureEnvColor_Tag 0x00d1
#define FogMode_Tag 0x00d2
#define FogColor_Tag 0x00d3
#define FStart_Tag 0x00d4
#define dFdx_Tag 0x00d5
#define dFdyDom_Tag 0x00d6
#define ZFogBias_Tag 0x00d7
#define KsStart_Tag 0x00d9
#define dKsdx_Tag 0x00da
#define dKsdyDom_Tag 0x00db
#define KdStart_Tag 0x00dc
#define dKddx_Tag 0x00dd
#define dKddyDom_Tag 0x00de
#define TextTGlyphAddr0_Tag 0x00e0
#define TextRender2DGlyph0_Tag 0x00e1
#define TextTGlyphAddr1_Tag 0x00e2
#define TextRender2DGlyph1_Tag 0x00e3
#define TextTGlyphAddr2_Tag 0x00e4
#define TextRender2DGlyph2_Tag 0x00e5
#define TextTGlyphAddr3_Tag 0x00e6
#define TextRender2DGlyph3_Tag 0x00e7
#define TextTGlyphAddr4_Tag 0x00e8
#define TextRender2DGlyph4_Tag 0x00e9
#define TextTGlyphAddr5_Tag 0x00ea
#define TextRender2DGlyph5_Tag 0x00eb
#define TextTGlyphAddr6_Tag 0x00ec
#define TextRender2DGlyph6_Tag 0x00ed
#define TextTGlyphAddr7_Tag 0x00ee
#define TextRender2DGlyph7_Tag 0x00ef
#define RStart_Tag 0x00f0
#define dRdx_Tag 0x00f1
#define dRdyDom_Tag 0x00f2
#define GStart_Tag 0x00f3
#define dGdx_Tag 0x00f4
#define dGdyDom_Tag 0x00f5
#define BStart_Tag 0x00f6
#define dBdx_Tag 0x00f7
#define dBdyDom_Tag 0x00f8
#define AStart_Tag 0x00f9
#define dAdx_Tag 0x00fa
#define dAdyDom_Tag 0x00fb
#define ColorDDAMode_Tag 0x00fc
#define ConstantColor_Tag 0x00fd
#define Color_Tag 0x00fe
#define AlphaTestMode_Tag 0x0100
#define AntialiasMode_Tag 0x0101
#define AlphaBlendMode_Tag 0x0102
#define DitherMode_Tag 0x0103
#define FBSoftwareWriteMask_Tag 0x0104
#define LogicalOpMode_Tag 0x0105
#define RouterMode_Tag 0x0108
#define LBReadMode_Tag 0x0110
#define LBReadFormat_Tag 0x0111
#define LBSourceOffset_Tag 0x0112
#define LBSourceData_Tag 0x0114
#define LBStencil_Tag 0x0115
#define LBDepth_Tag 0x0116
#define LBWindowBase_Tag 0x0117
#define LBWriteMode_Tag 0x0118
#define LBWriteFormat_Tag 0x0119
#define LBWriteBase_Tag 0x011a
#define LBWriteConfig_Tag 0x011b
#define TextureData_Tag 0x011d
#define TextureDownloadOffset_Tag 0x011e
#define LBWindowOffset_Tag 0x011f
#define HostInID_Tag 0x0120
#define Security_Tag 0x0121
#define FlushWriteCombining_Tag 0x0122
#define HostInState_Tag 0x0123
#define HostInDMAAddress_Tag 0x0127
#define HostInState2_Tag 0x0128
#define VertexRename_Tag 0x012f
#define Window_Tag 0x0130
#define StencilMode_Tag 0x0131
#define StencilData_Tag 0x0132
#define Stencil_Tag 0x0133
#define DepthMode_Tag 0x0134
#define Depth_Tag 0x0135
#define ZStartU_Tag 0x0136
#define ZStartL_Tag 0x0137
#define dZdxU_Tag 0x0138
#define dZdxL_Tag 0x0139
#define dZdyDomU_Tag 0x013a
#define dZdyDomL_Tag 0x013b
#define FastClearDepth_Tag 0x013c
#define LBCancelWrite_Tag 0x013d
#define LBWriteData_Tag 0x013e
#define FBReadMode_Tag 0x0150
#define FBSourceOffset_Tag 0x0151
#define FBPixelOffset_Tag 0x0152
#define FBColor_Tag 0x0153
#define FBData_Tag 0x0154
#define FBSourceData_Tag 0x0155
#define FBWindowBase_Tag 0x0156
#define FBWriteMode_Tag 0x0157
#define FBHardwareWriteMask_Tag 0x0158
#define FBBlockColor_Tag 0x0159
#define FBReadPixel_Tag 0x015a
#define FBWritePixel_Tag 0x015b
#define FBWriteBase_Tag 0x015c
#define FBWriteConfig_Tag 0x015d
#define FBReadPad_Tag 0x015e
#define PatternRAMMode_Tag 0x015f
#define PatternRAMData0_Tag 0x0160
#define PatternRAMData1_Tag 0x0161
#define PatternRAMData2_Tag 0x0162
#define PatternRAMData3_Tag 0x0163
#define PatternRAMData4_Tag 0x0164
#define PatternRAMData5_Tag 0x0165
#define PatternRAMData6_Tag 0x0166
#define PatternRAMData7_Tag 0x0167
#define PatternRAMData8_Tag 0x0168
#define PatternRAMData9_Tag 0x0169
#define PatternRAMData10_Tag 0x016a
#define PatternRAMData11_Tag 0x016b
#define PatternRAMData12_Tag 0x016c
#define PatternRAMData13_Tag 0x016d
#define PatternRAMData14_Tag 0x016e
#define PatternRAMData15_Tag 0x016f
#define PatternRAMData16_Tag 0x0170
#define PatternRAMData17_Tag 0x0171
#define PatternRAMData18_Tag 0x0172
#define PatternRAMData19_Tag 0x0173
#define PatternRAMData20_Tag 0x0174
#define PatternRAMData21_Tag 0x0175
#define PatternRAMData22_Tag 0x0176
#define PatternRAMData23_Tag 0x0177
#define PatternRAMData24_Tag 0x0178
#define PatternRAMData25_Tag 0x0179
#define PatternRAMData26_Tag 0x017a
#define PatternRAMData27_Tag 0x017b
#define PatternRAMData28_Tag 0x017c
#define PatternRAMData29_Tag 0x017d
#define PatternRAMData30_Tag 0x017e
#define PatternRAMData31_Tag 0x017f
#define FilterMode_Tag 0x0180
#define StatisticMode_Tag 0x0181
#define MinRegion_Tag 0x0182
#define MaxRegion_Tag 0x0183
#define ResetPickResult_Tag 0x0184
#define MinHitRegion_Tag 0x0185
#define MaxHitRegion_Tag 0x0186
#define PickResult_Tag 0x0187
#define Sync_Tag 0x0188
#define RLEMask_Tag 0x0189
#define FBBlockColorBackU_Tag 0x018b
#define FBBlockColorBackL_Tag 0x018c
#define FBBlockColorU_Tag 0x018d
#define FBBlockColorL_Tag 0x018e
#define SuspendUntilFrameBlank_Tag 0x018f
#define KsRStart_Tag 0x0190
#define dKsRdx_Tag 0x0191
#define dKsRdyDom_Tag 0x0192
#define KsGStart_Tag 0x0193
#define dKsGdx_Tag 0x0194
#define dKsGdyDom_Tag 0x0195
#define KsBStart_Tag 0x0196
#define dKsBdx_Tag 0x0197
#define dKsBdyDom_Tag 0x0198
#define KdRStart_Tag 0x01a0
#define dKdRdx_Tag 0x01a1
#define dKdRdyDom_Tag 0x01a2
#define KdGStart_Tag 0x01a3
#define dKdGdx_Tag 0x01a4
#define dKdGdyDom_Tag 0x01a5
#define KdBStart_Tag 0x01a6
#define dKdBdx_Tag 0x01a7
#define dKdBdyDom_Tag 0x01a8
#define FBSourceBase_Tag 0x01b0
#define FBSourceDelta_Tag 0x01b1
#define Config_Tag 0x01b2
#define ContextDump_Tag 0x01b8
#define ContextRestore_Tag 0x01b9
#define ContextData_Tag 0x01ba
#define TexelLUT0_Tag 0x01d0
#define TexelLUT1_Tag 0x01d1
#define TexelLUT2_Tag 0x01d2
#define TexelLUT3_Tag 0x01d3
#define TexelLUT4_Tag 0x01d4
#define TexelLUT5_Tag 0x01d5
#define TexelLUT6_Tag 0x01d6
#define TexelLUT7_Tag 0x01d7
#define TexelLUT8_Tag 0x01d8
#define TexelLUT9_Tag 0x01d9
#define TexelLUT10_Tag 0x01da
#define TexelLUT11_Tag 0x01db
#define TexelLUT12_Tag 0x01dc
#define TexelLUT13_Tag 0x01dd
#define TexelLUT14_Tag 0x01de
#define TexelLUT15_Tag 0x01df
#define LUT0_Tag 0x01d0
#define LUT1_Tag 0x01d1
#define LUT2_Tag 0x01d2
#define LUT3_Tag 0x01d3
#define LUT4_Tag 0x01d4
#define LUT5_Tag 0x01d5
#define LUT6_Tag 0x01d6
#define LUT7_Tag 0x01d7
#define LUT8_Tag 0x01d8
#define LUT9_Tag 0x01d9
#define LUT10_Tag 0x01da
#define LUT11_Tag 0x01db
#define LUT12_Tag 0x01dc
#define LUT13_Tag 0x01dd
#define LUT14_Tag 0x01de
#define LUT15_Tag 0x01df
#define YUVMode_Tag 0x01e0
#define ChromaUpperBound_Tag 0x01e1
#define ChromaUpper_Tag 0x01e1
#define ChromaLowerBound_Tag 0x01e2
#define ChromaLower_Tag 0x01e2
#define ChromaTestMode_Tag 0x01e3
#define AlphaMapUpperBound_Tag 0x01e3
#define AlphaMapLowerBound_Tag 0x01e4
#define TextureID_Tag 0x01ee
#define TexelLUTID_Tag 0x01ef
#define FeedbackToken_Tag 0x01f0
#define FeedbackX_Tag 0x01f1
#define FeedbackY_Tag 0x01f2
#define FeedbackZ_Tag 0x01f3
#define FeedbackW_Tag 0x01f4
#define FeedbackRed_Tag 0x01f5
#define FeedbackGreen_Tag 0x01f6
#define FeedbackBlue_Tag 0x01f7
#define FeedbackAlpha_Tag 0x01f8
#define FeedbackS_Tag 0x01f9
#define FeedbackT_Tag 0x01fa
#define FeedbackR_Tag 0x01fb
#define FeedbackQ_Tag 0x01fc
#define SelectRecord_Tag 0x01fd
#define PassThrough_Tag 0x01fe
#define EndOfFeedback_Tag 0x01ff
#define V0FixedS_Tag 0x0200
#define V0FloatS1_Tag 0x0200
#define V0FixedT_Tag 0x0201
#define V0FloatT1_Tag 0x0201
#define V0FixedQ_Tag 0x0202
#define V0FloatQ1_Tag 0x0202
#define V0FixedKs_Tag 0x0203
#define V0Reserved0_Tag 0x0203
#define V0FixedKd_Tag 0x0204
#define V0Reserved1_Tag 0x0204
#define V0FixedR_Tag 0x0205
#define V0Reserved2_Tag 0x0205
#define V0FixedG_Tag 0x0206
#define V0Reserved3_Tag 0x0206
#define V0FixedB_Tag 0x0207
#define V0Reserved4_Tag 0x0207
#define V0FixedA_Tag 0x0208
#define V0Reserved5_Tag 0x0208
#define V0FixedF_Tag 0x0209
#define V0FloatPackedDiffuse_Tag 0x0209
#define V0FixedX_Tag 0x020a
#define V0FloatKsR_Tag 0x020a
#define V0FixedY_Tag 0x020b
#define V0FloatKsG_Tag 0x020b
#define V0FixedZ_Tag 0x020c
#define V0FloatKsB_Tag 0x020c
#define V0FixedW_Tag 0x020d
#define V0FloatKdR_Tag 0x020d
#define V0FixedU1_Tag 0x020e
#define V0FixedPacked_Tag 0x020e
#define V0FloatKdG_Tag 0x020e
#define V0FixedU2_Tag 0x020f
#define V0FloatKdB_Tag 0x020f
#define V1FixedS_Tag 0x0210
#define V1FloatS1_Tag 0x0210
#define V1FixedT_Tag 0x0211
#define V1FloatT1_Tag 0x0211
#define V1FixedQ_Tag 0x0212
#define V1FloatQ1_Tag 0x0212
#define V1FixedKs_Tag 0x0213
#define V1Reserved0_Tag 0x0213
#define V1FixedKd_Tag 0x0214
#define V1Reserved1_Tag 0x0214
#define V1FixedR_Tag 0x0215
#define V1Reserved2_Tag 0x0215
#define V1FixedG_Tag 0x0216
#define V1Reserved3_Tag 0x0216
#define V1FixedB_Tag 0x0217
#define V1Reserved4_Tag 0x0217
#define V1FixedA_Tag 0x0218
#define V1Reserved5_Tag 0x0218
#define V1FixedF_Tag 0x0219
#define V1FloatPackedDiffuse_Tag 0x0219
#define V1FixedX_Tag 0x021a
#define V1FloatKsR_Tag 0x021a
#define V1FixedY_Tag 0x021b
#define V1FloatKsG_Tag 0x021b
#define V1FixedZ_Tag 0x021c
#define V1FloatKsB_Tag 0x021c
#define V1FixedW_Tag 0x021d
#define V1FloatKdR_Tag 0x021d
#define V1FixedU1_Tag 0x021e
#define V1FixedPacked_Tag 0x021e
#define V1FloatKdG_Tag 0x021e
#define V1FixedU2_Tag 0x021f
#define V1FloatKdB_Tag 0x021f
#define V2FixedS_Tag 0x0220
#define V2FloatS1_Tag 0x0220
#define V2FixedT_Tag 0x0221
#define V2FloatT1_Tag 0x0221
#define V2FixedQ_Tag 0x0222
#define V2FloatQ1_Tag 0x0222
#define V2FixedKs_Tag 0x0223
#define V2Reserved0_Tag 0x0223
#define V2FixedKd_Tag 0x0224
#define V2Reserved1_Tag 0x0224
#define V2FixedR_Tag 0x0225
#define V2Reserved2_Tag 0x0225
#define V2FixedG_Tag 0x0226
#define V2Reserved3_Tag 0x0226
#define V2FixedB_Tag 0x0227
#define V2Reserved4_Tag 0x0227
#define V2FixedA_Tag 0x0228
#define V2Reserved5_Tag 0x0228
#define V2FixedF_Tag 0x0229
#define V2FloatPackedDiffuse_Tag 0x0229
#define V2FixedX_Tag 0x022a
#define V2FloatKsR_Tag 0x022a
#define V2FixedY_Tag 0x022b
#define V2FloatKsG_Tag 0x022b
#define V2FixedZ_Tag 0x022c
#define V2FloatKsB_Tag 0x022c
#define V2FixedW_Tag 0x022d
#define V2FloatKdR_Tag 0x022d
#define V2FixedU1_Tag 0x022e
#define V2FixedPacked_Tag 0x022e
#define V2FloatKdG_Tag 0x022e
#define V2FixedU2_Tag 0x022f
#define V2FloatKdB_Tag 0x022f
#define V0FloatS_Tag 0x0230
#define V0FloatT_Tag 0x0231
#define V0FloatQ_Tag 0x0232
#define V0FloatKs_Tag 0x0233
#define V0Reserved7_Tag 0x0233
#define V0FloatKd_Tag 0x0234
#define V0Reserved8_Tag 0x0234
#define V0FloatR_Tag 0x0235
#define V0FloatG_Tag 0x0236
#define V0FloatB_Tag 0x0237
#define V0FloatA_Tag 0x0238
#define V0FloatF_Tag 0x0239
#define V0FloatX_Tag 0x023a
#define V0FloatY_Tag 0x023b
#define V0FloatZ_Tag 0x023c
#define V0FloatW_Tag 0x023d
#define V0FloatU1_Tag 0x023e
#define V0FloatPacked_Tag 0x023e
#define V0FloatPackedColour_Tag 0x023e
#define V0FloatU2_Tag 0x023f
#define V0FloatPackedSpecularFog_Tag 0x023f
#define V1FloatS_Tag 0x0240
#define V1FloatT_Tag 0x0241
#define V1FloatQ_Tag 0x0242
#define V1FloatKs_Tag 0x0243
#define V1Reserved7_Tag 0x0243
#define V1FloatKd_Tag 0x0244
#define V1Reserved8_Tag 0x0244
#define V1FloatR_Tag 0x0245
#define V1FloatG_Tag 0x0246
#define V1FloatB_Tag 0x0247
#define V1FloatA_Tag 0x0248
#define V1FloatF_Tag 0x0249
#define V1FloatX_Tag 0x024a
#define V1FloatY_Tag 0x024b
#define V1FloatZ_Tag 0x024c
#define V1FloatW_Tag 0x024d
#define V1FloatU1_Tag 0x024e
#define V1FloatPacked_Tag 0x024e
#define V1FloatPackedColour_Tag 0x024e
#define V1FloatU2_Tag 0x024f
#define V1FloatPackedSpecularFog_Tag 0x024f
#define V2FloatS_Tag 0x0250
#define V2FloatT_Tag 0x0251
#define V2FloatQ_Tag 0x0252
#define V2FloatKs_Tag 0x0253
#define V2Reserved7_Tag 0x0253
#define V2FloatKd_Tag 0x0254
#define V2Reserved8_Tag 0x0254
#define V2FloatR_Tag 0x0255
#define V2FloatG_Tag 0x0256
#define V2FloatB_Tag 0x0257
#define V2FloatA_Tag 0x0258
#define V2FloatF_Tag 0x0259
#define V2FloatX_Tag 0x025a
#define V2FloatY_Tag 0x025b
#define V2FloatZ_Tag 0x025c
#define V2FloatW_Tag 0x025d
#define V2FloatU1_Tag 0x025e
#define V2FloatPacked_Tag 0x025e
#define V2FloatPackedColour_Tag 0x025e
#define V2FloatU2_Tag 0x025f
#define V2FloatPackedSpecularFog_Tag 0x025f
#define DeltaMode_Tag 0x0260
#define DrawTriangle_Tag 0x0261
#define RepeatTriangle_Tag 0x0262
#define DrawLine01_Tag 0x0263
#define DrawLine10_Tag 0x0264
#define RepeatLine_Tag 0x0265
#define DrawPoint_Tag 0x0266
#define ProvokingVertex_Tag 0x0267
#define TextureLODScale_Tag 0x0268
#define TextureLODScale1_Tag 0x0269
#define DeltaControl_Tag 0x026a
#define ProvokingVertexMask_Tag 0x026b
#define RenderE_Tag 0x026c
#define EpilogTag_Tag 0x026d
#define EpilogData_Tag 0x026e
#define BroadcastMask_Tag 0x026f
#define DeltaCoord0_Tag 0x0270
#define DeltaCoord1_Tag 0x0271
#define DeltaCoord2_Tag 0x0272
#define DeltaCoord3_Tag 0x0273
#define DeltaColor0_Tag 0x0274
#define DeltaColor1_Tag 0x0275
#define DeltaColor2_Tag 0x0276
#define DeltaColor3_Tag 0x0277
#define DeltaTexture0_Tag 0x0278
#define DeltaTexture1_Tag 0x0279
#define DeltaTexture2_Tag 0x027a
#define DeltaTexture3_Tag 0x027b
#define DeltaTextureKs0_Tag 0x027c
#define DeltaTextureKs1_Tag 0x027d
#define DeltaTextureKs2_Tag 0x027e
#define DeltaTextureKs3_Tag 0x027f
#define DeltaTextureKd0_Tag 0x0280
#define DeltaTextureKd1_Tag 0x0281
#define DeltaTextureKd2_Tag 0x0282
#define DeltaTextureKd3_Tag 0x0283
#define DeltaCoordZ0_Tag 0x0284
#define DeltaCoordZ1_Tag 0x0285
#define DeltaCoordZ2_Tag 0x0286
#define DeltaCoordZ3_Tag 0x0287
#define V3FloatF_Tag 0x0288
#define V3FloatKs_Tag 0x0289
#define V3FloatKd_Tag 0x028a
#define DeltaTexture01_Tag 0x028b
#define Gw_Tag 0x028c
#define DeltaTexture11_Tag 0x028c
#define Gz_Tag 0x028d
#define DeltaTexture21_Tag 0x028d
#define Gy_Tag 0x028e
#define DeltaTexture31_Tag 0x028e
#define Gx_Tag 0x028f
#define XBias_Tag 0x0290
#define YBias_Tag 0x0291
#define PointMode_Tag 0x0292
#define PointSize_Tag 0x0293
#define AAPointSize_Tag 0x0294
#define LineMode_Tag 0x0295
#define LineWidth_Tag 0x0296
#define LineWidthOffset_Tag 0x0297
#define AALineWidth_Tag 0x0298
#define TriangleMode_Tag 0x0299
#define RectangleMode_Tag 0x029a
#define RectangleWidth_Tag 0x029b
#define RectangleHeight_Tag 0x029c
#define Rectangle2DMode_Tag 0x029d
#define Rectangle2DControl_Tag 0x029e
#define ZBias_Tag 0x029f
#define VertexMachineMode_Tag 0x02a0
#define TransformMode_Tag 0x02a1
#define GeometryMode_Tag 0x02a2
#define NormaliseMode_Tag 0x02a3
#define LightingMode_Tag 0x02a4
#define ColorMaterialMode_Tag 0x02a5
#define MaterialMode_Tag 0x02a6
#define FogVertexMode_Tag 0x02a7
#define TextureModeSelect_Tag 0x02a8
#define TextureMatrixSelect_Tag 0x02a9
#define TextureTexGenSelect_Tag 0x02aa
#define TextureMode_Tag 0x02ab
#define PipeMode_Tag 0x02ac
#define StripeFilterMode_Tag 0x02ad
#define MatrixMode_Tag 0x02ae
#define GammaFilter_Tag 0x02af
#define SelectResult_Tag 0x02b0
#define Begin_Tag 0x02b2
#define End_Tag 0x02b3
#define EdgeFlag_Tag 0x02b4
#define ObjectIDValue_Tag 0x02b5
#define IncrementObjectID_Tag 0x02b6
#define TransformCurrent_Tag 0x02b7
#define SendVector_Tag 0x02b8
#define SaveCurrent_Tag 0x02b9
#define RestoreCurrent_Tag 0x02ba
#define InitNames_Tag 0x02bb
#define PushName_Tag 0x02bc
#define PopName_Tag 0x02bd
#define LoadName_Tag 0x02be
#define Vertex_Tag 0x02c0
#define NextVertex_Tag 0x02d0
#define GeomPoint_Tag 0x02d1
#define GeomLine_Tag 0x02d2
#define GeomTriangle_Tag 0x02d3
#define GeomRectangle_Tag 0x02d4
#define ObjectID_Tag 0x02d5
#define UpdateRasterPos_Tag 0x02d6
#define ClippedColor_Tag 0x02d9
#define VertexColorFeedback_Tag 0x02da
#define ClippedColorFeedback_Tag 0x02db
#define Barycentric_Tag 0x02dc
#define DeltaFormatControl_Tag 0x02eb
#define LineCoord0_Tag 0x02ec
#define DrawLine2D10_Tag 0x02ed
#define LineCoord1_Tag 0x02ee
#define DrawLine2D01_Tag 0x02ef
#define RenderPoint_Tag 0x02f0
#define RenderLine_Tag 0x02f1
#define RenderTriangle_Tag 0x02f2
#define RenderRectangle_Tag 0x02f3
#define DrawRectangle2D_Tag 0x02f4
#define Nz_Tag 0x0300
#define Ny_Tag 0x0301
#define Nx_Tag 0x0302
#define Ca_Tag 0x0303
#define Cb_Tag 0x0304
#define Cg_Tag 0x0305
#define Cr3_Tag 0x0306
#define Cr4_Tag 0x0307
#define Tt2_Tag 0x0308
#define Ts2_Tag 0x0309
#define Vw_Tag 0x030a
#define Vz_Tag 0x030b
#define Vy_Tag 0x030c
#define Vx2_Tag 0x030d
#define Vx3_Tag 0x030e
#define Vx4_Tag 0x030f
#define FNz_Tag 0x0310
#define FNy_Tag 0x0311
#define FNx_Tag 0x0312
#define PackedColor3_Tag 0x0313
#define PackedColor4_Tag 0x0314
#define Tq4_Tag 0x0315
#define Tr4_Tag 0x0316
#define Tt4_Tag 0x0317
#define Ts4_Tag 0x0318
#define RPw_Tag 0x0319
#define RPz_Tag 0x031a
#define RPy_Tag 0x031b
#define RPx2_Tag 0x031c
#define RPx3_Tag 0x031d
#define RPx4_Tag 0x031e
#define Ts1_Tag 0x031f
#define ModelViewMatrix0_Tag 0x0320
#define ModelViewMatrix1_Tag 0x0321
#define ModelViewMatrix2_Tag 0x0322
#define ModelViewMatrix3_Tag 0x0323
#define ModelViewMatrix4_Tag 0x0324
#define ModelViewMatrix5_Tag 0x0325
#define ModelViewMatrix6_Tag 0x0326
#define ModelViewMatrix7_Tag 0x0327
#define ModelViewMatrix8_Tag 0x0328
#define ModelViewMatrix9_Tag 0x0329
#define ModelViewMatrix10_Tag 0x032a
#define ModelViewMatrix11_Tag 0x032b
#define ModelViewMatrix12_Tag 0x032c
#define ModelViewMatrix13_Tag 0x032d
#define ModelViewMatrix14_Tag 0x032e
#define ModelViewMatrix15_Tag 0x032f
#define ModelViewProjectionMatrix0_Tag 0x0330
#define ModelViewProjectionMatrix1_Tag 0x0331
#define ModelViewProjectionMatrix2_Tag 0x0332
#define ModelViewProjectionMatrix3_Tag 0x0333
#define ModelViewProjectionMatrix4_Tag 0x0334
#define ModelViewProjectionMatrix5_Tag 0x0335
#define ModelViewProjectionMatrix6_Tag 0x0336
#define ModelViewProjectionMatrix7_Tag 0x0337
#define ModelViewProjectionMatrix8_Tag 0x0338
#define ModelViewProjectionMatrix9_Tag 0x0339
#define ModelViewProjectionMatrix10_Tag 0x033a
#define ModelViewProjectionMatrix11_Tag 0x033b
#define ModelViewProjectionMatrix12_Tag 0x033c
#define ModelViewProjectionMatrix13_Tag 0x033d
#define ModelViewProjectionMatrix14_Tag 0x033e
#define ModelViewProjectionMatrix15_Tag 0x033f
#define NormalMatrix0_Tag 0x0340
#define NormalMatrix1_Tag 0x0341
#define NormalMatrix2_Tag 0x0342
#define NormalMatrix3_Tag 0x0343
#define NormalMatrix4_Tag 0x0344
#define NormalMatrix5_Tag 0x0345
#define NormalMatrix6_Tag 0x0346
#define NormalMatrix7_Tag 0x0347
#define NormalMatrix8_Tag 0x0348
#define UnusedNormalMatrix9_Tag 0x0349
#define UnusedNormalMatrix10_Tag 0x034a
#define UnusedNormalMatrix11_Tag 0x034b
#define UnusedNormalMatrix12_Tag 0x034c
#define UnusedNormalMatrix13_Tag 0x034d
#define UnusedNormalMatrix14_Tag 0x034e
#define UnusedNormalMatrix15_Tag 0x034f
#define TextureMatrix0_Tag 0x0350
#define TextureMatrix1_Tag 0x0351
#define TextureMatrix2_Tag 0x0352
#define TextureMatrix3_Tag 0x0353
#define TextureMatrix4_Tag 0x0354
#define TextureMatrix5_Tag 0x0355
#define TextureMatrix6_Tag 0x0356
#define TextureMatrix7_Tag 0x0357
#define TextureMatrix8_Tag 0x0358
#define TextureMatrix9_Tag 0x0359
#define TextureMatrix10_Tag 0x035a
#define TextureMatrix11_Tag 0x035b
#define TextureMatrix12_Tag 0x035c
#define TextureMatrix13_Tag 0x035d
#define TextureMatrix14_Tag 0x035e
#define TextureMatrix15_Tag 0x035f
#define TexGen0_Tag 0x0360
#define TexGen1_Tag 0x0361
#define TexGen2_Tag 0x0362
#define TexGen3_Tag 0x0363
#define TexGen4_Tag 0x0364
#define TexGen5_Tag 0x0365
#define TexGen6_Tag 0x0366
#define TexGen7_Tag 0x0367
#define TexGen8_Tag 0x0368
#define TexGen9_Tag 0x0369
#define TexGen10_Tag 0x036a
#define TexGen11_Tag 0x036b
#define TexGen12_Tag 0x036c
#define TexGen13_Tag 0x036d
#define TexGen14_Tag 0x036e
#define TexGen15_Tag 0x036f
#define ViewPortScaleX_Tag 0x0370
#define ViewPortScaleY_Tag 0x0371
#define ViewPortScaleZ_Tag 0x0372
#define ViewPortOffsetX_Tag 0x0373
#define ViewPortOffsetY_Tag 0x0374
#define ViewPortOffsetZ_Tag 0x0375
#define FogDensity_Tag 0x0376
#define FogScale_Tag 0x0377
#define FogEnd_Tag 0x0378
#define PolygonOffsetFactor_Tag 0x0379
#define PolygonOffsetBias_Tag 0x037a
#define LineClipLengthThreshold_Tag 0x037b
#define TriangleClipAreaThreshold_Tag 0x037c
#define RasterPosXIncrement_Tag 0x037d
#define RasterPosYIncrement_Tag 0x037e
#define UserClip0X_Tag 0x0380
#define UserClip0Y_Tag 0x0381
#define UserClip0Z_Tag 0x0382
#define UserClip0W_Tag 0x0383
#define UserClip1X_Tag 0x0384
#define UserClip1Y_Tag 0x0385
#define UserClip1Z_Tag 0x0386
#define UserClip1W_Tag 0x0387
#define UserClip2X_Tag 0x0388
#define UserClip2Y_Tag 0x0389
#define UserClip2Z_Tag 0x038a
#define UserClip2W_Tag 0x038b
#define UserClip3X_Tag 0x038c
#define UserClip3Y_Tag 0x038d
#define UserClip3Z_Tag 0x038e
#define UserClip3W_Tag 0x038f
#define UserClip4X_Tag 0x0390
#define UserClip4Y_Tag 0x0391
#define UserClip4Z_Tag 0x0392
#define UserClip4W_Tag 0x0393
#define UserClip5X_Tag 0x0394
#define UserClip5Y_Tag 0x0395
#define UserClip5Z_Tag 0x0396
#define UserClip5W_Tag 0x0397
#define PackedSpecular_Tag 0x0398
#define PackedDiffuse_Tag 0x0399
#define PackedNormal_Tag 0x039a
#define PackedFaceNormal_Tag 0x039b
#define RasterPosXOffset_Tag 0x039d
#define RasterPosYOffset_Tag 0x039e
#define AttenuationCutOff_Tag 0x039f
#define Light0Mode_Tag 0x03a0
#define Light0AmbientIntensityRed_Tag 0x03a1
#define Light0AmbientIntensityGreen_Tag 0x03a2
#define Light0AmbientIntensityBlue_Tag 0x03a3
#define Light0DiffuseIntensityRed_Tag 0x03a4
#define Light0DiffuseIntensityGreen_Tag 0x03a5
#define Light0DiffuseIntensityBlue_Tag 0x03a6
#define Light0SpecularIntensityRed_Tag 0x03a7
#define Light0SpecularIntensityGreen_Tag 0x03a8
#define Light0SpecularIntensityBlue_Tag 0x03a9
#define Light0PositionX_Tag 0x03aa
#define Light0PositionY_Tag 0x03ab
#define Light0PositionZ_Tag 0x03ac
#define Light0PositionW_Tag 0x03ad
#define Light0SpotlightDirectionX_Tag 0x03ae
#define Light0SpotlightDirectionY_Tag 0x03af
#define Light0SpotlightDirectionZ_Tag 0x03b0
#define Light0SpotlightExponent_Tag 0x03b1
#define Light0CosSpotlightCutoffAngle_Tag 0x03b2
#define Light0ConstantAttenuation_Tag 0x03b3
#define Light0LinearAttenuation_Tag 0x03b4
#define Light0QuadraticAttenuation_Tag 0x03b5
#define Light1Mode_Tag 0x03b6
#define Light1AmbientIntensityRed_Tag 0x03b7
#define Light1AmbientIntensityGreen_Tag 0x03b8
#define Light1AmbientIntensityBlue_Tag 0x03b9
#define Light1DiffuseIntensityRed_Tag 0x03ba
#define Light1DiffuseIntensityGreen_Tag 0x03bb
#define Light1DiffuseIntensityBlue_Tag 0x03bc
#define Light1SpecularIntensityRed_Tag 0x03bd
#define Light1SpecularIntensityGreen_Tag 0x03be
#define Light1SpecularIntensityBlue_Tag 0x03bf
#define Light1PositionX_Tag 0x03c0
#define Light1PositionY_Tag 0x03c1
#define Light1PositionZ_Tag 0x03c2
#define Light1PositionW_Tag 0x03c3
#define Light1SpotlightDirectionX_Tag 0x03c4
#define Light1SpotlightDirectionY_Tag 0x03c5
#define Light1SpotlightDirectionZ_Tag 0x03c6
#define Light1SpotlightExponent_Tag 0x03c7
#define Light1CosSpotlightCutoffAngle_Tag 0x03c8
#define Light1ConstantAttenuation_Tag 0x03c9
#define Light1LinearAttenuation_Tag 0x03ca
#define Light1QuadraticAttenuation_Tag 0x03cb
#define Light2Mode_Tag 0x03cc
#define Light2AmbientIntensityRed_Tag 0x03cd
#define Light2AmbientIntensityGreen_Tag 0x03ce
#define Light2AmbientIntensityBlue_Tag 0x03cf
#define Light2DiffuseIntensityRed_Tag 0x03d0
#define Light2DiffuseIntensityGreen_Tag 0x03d1
#define Light2DiffuseIntensityBlue_Tag 0x03d2
#define Light2SpecularIntensityRed_Tag 0x03d3
#define Light2SpecularIntensityGreen_Tag 0x03d4
#define Light2SpecularIntensityBlue_Tag 0x03d5
#define Light2PositionX_Tag 0x03d6
#define Light2PositionY_Tag 0x03d7
#define Light2PositionZ_Tag 0x03d8
#define Light2PositionW_Tag 0x03d9
#define Light2SpotlightDirectionX_Tag 0x03da
#define Light2SpotlightDirectionY_Tag 0x03db
#define Light2SpotlightDirectionZ_Tag 0x03dc
#define Light2SpotlightExponent_Tag 0x03dd
#define Light2CosSpotlightCutoffAngle_Tag 0x03de
#define Light2ConstantAttenuation_Tag 0x03df
#define Light2LinearAttenuation_Tag 0x03e0
#define Light2QuadraticAttenuation_Tag 0x03e1
#define Light3Mode_Tag 0x03e2
#define Light3AmbientIntensityRed_Tag 0x03e3
#define Light3AmbientIntensityGreen_Tag 0x03e4
#define Light3AmbientIntensityBlue_Tag 0x03e5
#define Light3DiffuseIntensityRed_Tag 0x03e6
#define Light3DiffuseIntensityGreen_Tag 0x03e7
#define Light3DiffuseIntensityBlue_Tag 0x03e8
#define Light3SpecularIntensityRed_Tag 0x03e9
#define Light3SpecularIntensityGreen_Tag 0x03ea
#define Light3SpecularIntensityBlue_Tag 0x03eb
#define Light3PositionX_Tag 0x03ec
#define Light3PositionY_Tag 0x03ed
#define Light3PositionZ_Tag 0x03ee
#define Light3PositionW_Tag 0x03ef
#define Light3SpotlightDirectionX_Tag 0x03f0
#define Light3SpotlightDirectionY_Tag 0x03f1
#define Light3SpotlightDirectionZ_Tag 0x03f2
#define Light3SpotlightExponent_Tag 0x03f3
#define Light3CosSpotlightCutoffAngle_Tag 0x03f4
#define Light3ConstantAttenuation_Tag 0x03f5
#define Light3LinearAttenuation_Tag 0x03f6
#define Light3QuadraticAttenuation_Tag 0x03f7
#define Light4Mode_Tag 0x03f8
#define Light4AmbientIntensityRed_Tag 0x03f9
#define Light4AmbientIntensityGreen_Tag 0x03fa
#define Light4AmbientIntensityBlue_Tag 0x03fb
#define Light4DiffuseIntensityRed_Tag 0x03fc
#define Light4DiffuseIntensityGreen_Tag 0x03fd
#define Light4DiffuseIntensityBlue_Tag 0x03fe
#define Light4SpecularIntensityRed_Tag 0x03ff
#define Light4SpecularIntensityGreen_Tag 0x0400
#define Light4SpecularIntensityBlue_Tag 0x0401
#define Light4PositionX_Tag 0x0402
#define Light4PositionY_Tag 0x0403
#define Light4PositionZ_Tag 0x0404
#define Light4PositionW_Tag 0x0405
#define Light4SpotlightDirectionX_Tag 0x0406
#define Light4SpotlightDirectionY_Tag 0x0407
#define Light4SpotlightDirectionZ_Tag 0x0408
#define Light4SpotlightExponent_Tag 0x0409
#define Light4CosSpotlightCutoffAngle_Tag 0x040a
#define Light4ConstantAttenuation_Tag 0x040b
#define Light4LinearAttenuation_Tag 0x040c
#define Light4QuadraticAttenuation_Tag 0x040d
#define Light5Mode_Tag 0x040e
#define Light5AmbientIntensityRed_Tag 0x040f
#define Light5AmbientIntensityGreen_Tag 0x0410
#define Light5AmbientIntensityBlue_Tag 0x0411
#define Light5DiffuseIntensityRed_Tag 0x0412
#define Light5DiffuseIntensityGreen_Tag 0x0413
#define Light5DiffuseIntensityBlue_Tag 0x0414
#define Light5SpecularIntensityRed_Tag 0x0415
#define Light5SpecularIntensityGreen_Tag 0x0416
#define Light5SpecularIntensityBlue_Tag 0x0417
#define Light5PositionX_Tag 0x0418
#define Light5PositionY_Tag 0x0419
#define Light5PositionZ_Tag 0x041a
#define Light5PositionW_Tag 0x041b
#define Light5SpotlightDirectionX_Tag 0x041c
#define Light5SpotlightDirectionY_Tag 0x041d
#define Light5SpotlightDirectionZ_Tag 0x041e
#define Light5SpotlightExponent_Tag 0x041f
#define Light5CosSpotlightCutoffAngle_Tag 0x0420
#define Light5ConstantAttenuation_Tag 0x0421
#define Light5LinearAttenuation_Tag 0x0422
#define Light5QuadraticAttenuation_Tag 0x0423
#define Light6Mode_Tag 0x0424
#define Light6AmbientIntensityRed_Tag 0x0425
#define Light6AmbientIntensityGreen_Tag 0x0426
#define Light6AmbientIntensityBlue_Tag 0x0427
#define Light6DiffuseIntensityRed_Tag 0x0428
#define Light6DiffuseIntensityGreen_Tag 0x0429
#define Light6DiffuseIntensityBlue_Tag 0x042a
#define Light6SpecularIntensityRed_Tag 0x042b
#define Light6SpecularIntensityGreen_Tag 0x042c
#define Light6SpecularIntensityBlue_Tag 0x042d
#define Light6PositionX_Tag 0x042e
#define Light6PositionY_Tag 0x042f
#define Light6PositionZ_Tag 0x0430
#define Light6PositionW_Tag 0x0431
#define Light6SpotlightDirectionX_Tag 0x0432
#define Light6SpotlightDirectionY_Tag 0x0433
#define Light6SpotlightDirectionZ_Tag 0x0434
#define Light6SpotlightExponent_Tag 0x0435
#define Light6CosSpotlightCutoffAngle_Tag 0x0436
#define Light6ConstantAttenuation_Tag 0x0437
#define Light6LinearAttenuation_Tag 0x0438
#define Light6QuadraticAttenuation_Tag 0x0439
#define Light7Mode_Tag 0x043a
#define Light7AmbientIntensityRed_Tag 0x043b
#define Light7AmbientIntensityGreen_Tag 0x043c
#define Light7AmbientIntensityBlue_Tag 0x043d
#define Light7DiffuseIntensityRed_Tag 0x043e
#define Light7DiffuseIntensityGreen_Tag 0x043f
#define Light7DiffuseIntensityBlue_Tag 0x0440
#define Light7SpecularIntensityRed_Tag 0x0441
#define Light7SpecularIntensityGreen_Tag 0x0442
#define Light7SpecularIntensityBlue_Tag 0x0443
#define Light7PositionX_Tag 0x0444
#define Light7PositionY_Tag 0x0445
#define Light7PositionZ_Tag 0x0446
#define Light7PositionW_Tag 0x0447
#define Light7SpotlightDirectionX_Tag 0x0448
#define Light7SpotlightDirectionY_Tag 0x0449
#define Light7SpotlightDirectionZ_Tag 0x044a
#define Light7SpotlightExponent_Tag 0x044b
#define Light7CosSpotlightCutoffAngle_Tag 0x044c
#define Light7ConstantAttenuation_Tag 0x044d
#define Light7LinearAttenuation_Tag 0x044e
#define Light7QuadraticAttenuation_Tag 0x044f
#define Light8Mode_Tag 0x0450
#define Light8AmbientIntensityRed_Tag 0x0451
#define Light8AmbientIntensityGreen_Tag 0x0452
#define Light8AmbientIntensityBlue_Tag 0x0453
#define Light8DiffuseIntensityRed_Tag 0x0454
#define Light8DiffuseIntensityGreen_Tag 0x0455
#define Light8DiffuseIntensityBlue_Tag 0x0456
#define Light8SpecularIntensityRed_Tag 0x0457
#define Light8SpecularIntensityGreen_Tag 0x0458
#define Light8SpecularIntensityBlue_Tag 0x0459
#define Light8PositionX_Tag 0x045a
#define Light8PositionY_Tag 0x045b
#define Light8PositionZ_Tag 0x045c
#define Light8PositionW_Tag 0x045d
#define Light8SpotlightDirectionX_Tag 0x045e
#define Light8SpotlightDirectionY_Tag 0x045f
#define Light8SpotlightDirectionZ_Tag 0x0460
#define Light8SpotlightExponent_Tag 0x0461
#define Light8CosSpotlightCutoffAngle_Tag 0x0462
#define Light8ConstantAttenuation_Tag 0x0463
#define Light8LinearAttenuation_Tag 0x0464
#define Light8QuadraticAttenuation_Tag 0x0465
#define Light9Mode_Tag 0x0466
#define Light9AmbientIntensityRed_Tag 0x0467
#define Light9AmbientIntensityGreen_Tag 0x0468
#define Light9AmbientIntensityBlue_Tag 0x0469
#define Light9DiffuseIntensityRed_Tag 0x046a
#define Light9DiffuseIntensityGreen_Tag 0x046b
#define Light9DiffuseIntensityBlue_Tag 0x046c
#define Light9SpecularIntensityRed_Tag 0x046d
#define Light9SpecularIntensityGreen_Tag 0x046e
#define Light9SpecularIntensityBlue_Tag 0x046f
#define Light9PositionX_Tag 0x0470
#define Light9PositionY_Tag 0x0471
#define Light9PositionZ_Tag 0x0472
#define Light9PositionW_Tag 0x0473
#define Light9SpotlightDirectionX_Tag 0x0474
#define Light9SpotlightDirectionY_Tag 0x0475
#define Light9SpotlightDirectionZ_Tag 0x0476
#define Light9SpotlightExponent_Tag 0x0477
#define Light9CosSpotlightCutoffAngle_Tag 0x0478
#define Light9ConstantAttenuation_Tag 0x0479
#define Light9LinearAttenuation_Tag 0x047a
#define Light9QuadraticAttenuation_Tag 0x047b
#define Light10Mode_Tag 0x047c
#define Light10AmbientIntensityRed_Tag 0x047d
#define Light10AmbientIntensityGreen_Tag 0x047e
#define Light10AmbientIntensityBlue_Tag 0x047f
#define Light10DiffuseIntensityRed_Tag 0x0480
#define Light10DiffuseIntensityGreen_Tag 0x0481
#define Light10DiffuseIntensityBlue_Tag 0x0482
#define Light10SpecularIntensityRed_Tag 0x0483
#define Light10SpecularIntensityGreen_Tag 0x0484
#define Light10SpecularIntensityBlue_Tag 0x0485
#define Light10PositionX_Tag 0x0486
#define Light10PositionY_Tag 0x0487
#define Light10PositionZ_Tag 0x0488
#define Light10PositionW_Tag 0x0489
#define Light10SpotlightDirectionX_Tag 0x048a
#define Light10SpotlightDirectionY_Tag 0x048b
#define Light10SpotlightDirectionZ_Tag 0x048c
#define Light10SpotlightExponent_Tag 0x048d
#define Light10CosSpotlightCutoffAngle_Tag 0x048e
#define Light10ConstantAttenuation_Tag 0x048f
#define Light10LinearAttenuation_Tag 0x0490
#define Light10QuadraticAttenuation_Tag 0x0491
#define Light11Mode_Tag 0x0492
#define Light11AmbientIntensityRed_Tag 0x0493
#define Light11AmbientIntensityGreen_Tag 0x0494
#define Light11AmbientIntensityBlue_Tag 0x0495
#define Light11DiffuseIntensityRed_Tag 0x0496
#define Light11DiffuseIntensityGreen_Tag 0x0497
#define Light11DiffuseIntensityBlue_Tag 0x0498
#define Light11SpecularIntensityRed_Tag 0x0499
#define Light11SpecularIntensityGreen_Tag 0x049a
#define Light11SpecularIntensityBlue_Tag 0x049b
#define Light11PositionX_Tag 0x049c
#define Light11PositionY_Tag 0x049d
#define Light11PositionZ_Tag 0x049e
#define Light11PositionW_Tag 0x049f
#define Light11SpotlightDirectionX_Tag 0x04a0
#define Light11SpotlightDirectionY_Tag 0x04a1
#define Light11SpotlightDirectionZ_Tag 0x04a2
#define Light11SpotlightExponent_Tag 0x04a3
#define Light11CosSpotlightCutoffAngle_Tag 0x04a4
#define Light11ConstantAttenuation_Tag 0x04a5
#define Light11LinearAttenuation_Tag 0x04a6
#define Light11QuadraticAttenuation_Tag 0x04a7
#define Light12Mode_Tag 0x04a8
#define Light12AmbientIntensityRed_Tag 0x04a9
#define Light12AmbientIntensityGreen_Tag 0x04aa
#define Light12AmbientIntensityBlue_Tag 0x04ab
#define Light12DiffuseIntensityRed_Tag 0x04ac
#define Light12DiffuseIntensityGreen_Tag 0x04ad
#define Light12DiffuseIntensityBlue_Tag 0x04ae
#define Light12SpecularIntensityRed_Tag 0x04af
#define Light12SpecularIntensityGreen_Tag 0x04b0
#define Light12SpecularIntensityBlue_Tag 0x04b1
#define Light12PositionX_Tag 0x04b2
#define Light12PositionY_Tag 0x04b3
#define Light12PositionZ_Tag 0x04b4
#define Light12PositionW_Tag 0x04b5
#define Light12SpotlightDirectionX_Tag 0x04b6
#define Light12SpotlightDirectionY_Tag 0x04b7
#define Light12SpotlightDirectionZ_Tag 0x04b8
#define Light12SpotlightExponent_Tag 0x04b9
#define Light12CosSpotlightCutoffAngle_Tag 0x04ba
#define Light12ConstantAttenuation_Tag 0x04bb
#define Light12LinearAttenuation_Tag 0x04bc
#define Light12QuadraticAttenuation_Tag 0x04bd
#define Light13Mode_Tag 0x04be
#define Light13AmbientIntensityRed_Tag 0x04bf
#define Light13AmbientIntensityGreen_Tag 0x04c0
#define Light13AmbientIntensityBlue_Tag 0x04c1
#define Light13DiffuseIntensityRed_Tag 0x04c2
#define Light13DiffuseIntensityGreen_Tag 0x04c3
#define Light13DiffuseIntensityBlue_Tag 0x04c4
#define Light13SpecularIntensityRed_Tag 0x04c5
#define Light13SpecularIntensityGreen_Tag 0x04c6
#define Light13SpecularIntensityBlue_Tag 0x04c7
#define Light13PositionX_Tag 0x04c8
#define Light13PositionY_Tag 0x04c9
#define Light13PositionZ_Tag 0x04ca
#define Light13PositionW_Tag 0x04cb
#define Light13SpotlightDirectionX_Tag 0x04cc
#define Light13SpotlightDirectionY_Tag 0x04cd
#define Light13SpotlightDirectionZ_Tag 0x04ce
#define Light13SpotlightExponent_Tag 0x04cf
#define Light13CosSpotlightCutoffAngle_Tag 0x04d0
#define Light13ConstantAttenuation_Tag 0x04d1
#define Light13LinearAttenuation_Tag 0x04d2
#define Light13QuadraticAttenuation_Tag 0x04d3
#define Light14Mode_Tag 0x04d4
#define Light14AmbientIntensityRed_Tag 0x04d5
#define Light14AmbientIntensityGreen_Tag 0x04d6
#define Light14AmbientIntensityBlue_Tag 0x04d7
#define Light14DiffuseIntensityRed_Tag 0x04d8
#define Light14DiffuseIntensityGreen_Tag 0x04d9
#define Light14DiffuseIntensityBlue_Tag 0x04da
#define Light14SpecularIntensityRed_Tag 0x04db
#define Light14SpecularIntensityGreen_Tag 0x04dc
#define Light14SpecularIntensityBlue_Tag 0x04dd
#define Light14PositionX_Tag 0x04de
#define Light14PositionY_Tag 0x04df
#define Light14PositionZ_Tag 0x04e0
#define Light14PositionW_Tag 0x04e1
#define Light14SpotlightDirectionX_Tag 0x04e2
#define Light14SpotlightDirectionY_Tag 0x04e3
#define Light14SpotlightDirectionZ_Tag 0x04e4
#define Light14SpotlightExponent_Tag 0x04e5
#define Light14CosSpotlightCutoffAngle_Tag 0x04e6
#define Light14ConstantAttenuation_Tag 0x04e7
#define Light14LinearAttenuation_Tag 0x04e8
#define Light14QuadraticAttenuation_Tag 0x04e9
#define Light15Mode_Tag 0x04ea
#define Light15AmbientIntensityRed_Tag 0x04eb
#define Light15AmbientIntensityGreen_Tag 0x04ec
#define Light15AmbientIntensityBlue_Tag 0x04ed
#define Light15DiffuseIntensityRed_Tag 0x04ee
#define Light15DiffuseIntensityGreen_Tag 0x04ef
#define Light15DiffuseIntensityBlue_Tag 0x04f0
#define Light15SpecularIntensityRed_Tag 0x04f1
#define Light15SpecularIntensityGreen_Tag 0x04f2
#define Light15SpecularIntensityBlue_Tag 0x04f3
#define Light15PositionX_Tag 0x04f4
#define Light15PositionY_Tag 0x04f5
#define Light15PositionZ_Tag 0x04f6
#define Light15PositionW_Tag 0x04f7
#define Light15SpotlightDirectionX_Tag 0x04f8
#define Light15SpotlightDirectionY_Tag 0x04f9
#define Light15SpotlightDirectionZ_Tag 0x04fa
#define Light15SpotlightExponent_Tag 0x04fb
#define Light15CosSpotlightCutoffAngle_Tag 0x04fc
#define Light15ConstantAttenuation_Tag 0x04fd
#define Light15LinearAttenuation_Tag 0x04fe
#define Light15QuadraticAttenuation_Tag 0x04ff
#define SceneAmbientColorRed_Tag 0x0500
#define SceneAmbientColorGreen_Tag 0x0501
#define SceneAmbientColorBlue_Tag 0x0502
#define FrontAmbientColorRed_Tag 0x0510
#define FrontAmbientColorGreen_Tag 0x0511
#define FrontAmbientColorBlue_Tag 0x0512
#define FrontDiffuseColorRed_Tag 0x0513
#define FrontDiffuseColorGreen_Tag 0x0514
#define FrontDiffuseColorBlue_Tag 0x0515
#define FrontAlpha_Tag 0x0516
#define FrontSpecularColorRed_Tag 0x0517
#define FrontSpecularColorGreen_Tag 0x0518
#define FrontSpecularColorBlue_Tag 0x0519
#define FrontEmissiveColorRed_Tag 0x051a
#define FrontEmissiveColorGreen_Tag 0x051b
#define FrontEmissiveColorBlue_Tag 0x051c
#define FrontSpecularExponent_Tag 0x051d
#define BackAmbientColorRed_Tag 0x0520
#define BackAmbientColorGreen_Tag 0x0521
#define BackAmbientColorBlue_Tag 0x0522
#define BackDiffuseColorRed_Tag 0x0523
#define BackDiffuseColorGreen_Tag 0x0524
#define BackDiffuseColorBlue_Tag 0x0525
#define BackAlpha_Tag 0x0526
#define BackSpecularColorRed_Tag 0x0527
#define BackSpecularColorGreen_Tag 0x0528
#define BackSpecularColorBlue_Tag 0x0529
#define BackEmissiveColorRed_Tag 0x052a
#define BackEmissiveColorGreen_Tag 0x052b
#define BackEmissiveColorBlue_Tag 0x052c
#define BackSpecularExponent_Tag 0x052d
#define DMAAddr_Tag 0x0530
#define DMACount_Tag 0x0531
#define CommandInterrupt_Tag 0x0532
#define DMACall_Tag 0x0533
#define DMAReturn_Tag 0x0534
#define DMARectangleRead_Tag 0x0535
#define DMARectangleReadAddress_Tag 0x0536
#define DMARectangleReadLinePitch_Tag 0x0537
#define DMARectangleReadTarget_Tag 0x0538
#define DMARectangleWrite_Tag 0x0539
#define DMARectangleWriteAddress_Tag 0x053a
#define DMARectangleWriteLinePitch_Tag 0x053b
#define DMAOutputAddress_Tag 0x053c
#define DMAOutputCount_Tag 0x053d
#define DMAReadGlintSource_Tag 0x053e
#define DMAContinue_Tag 0x053f
#define VertexArray_Tag 0x0540
#define VertexArrayIndexed_Tag 0x0541
#define DMAFeedback_Tag 0x0542
#define BeginContextFence_Tag 0x0543
#define EndContextFence_Tag 0x0544
#define CommandTest_Tag 0x0545
#define TransformModeAnd_Tag 0x0550
#define TransformModeOr_Tag 0x0551
#define GeometryModeAnd_Tag 0x0552
#define GeometryModeOr_Tag 0x0553
#define NormaliseModeAnd_Tag 0x0554
#define NormaliseModeOr_Tag 0x0555
#define LightingModeAnd_Tag 0x0556
#define LightingModeOr_Tag 0x0557
#define ColorMaterialModeAnd_Tag 0x0558
#define ColorMaterialModeOr_Tag 0x0559
#define DeltaModeAnd_Tag 0x055a
#define DeltaModeOr_Tag 0x055b
#define PointModeAnd_Tag 0x055c
#define PointModeOr_Tag 0x055d
#define LineModeAnd_Tag 0x055e
#define LineModeOr_Tag 0x055f
#define TriangleModeAnd_Tag 0x0560
#define TriangleModeOr_Tag 0x0561
#define MaterialModeAnd_Tag 0x0562
#define MaterialModeOr_Tag 0x0563
#define DeltaControlAnd_Tag 0x0564
#define DeltaControlOr_Tag 0x0565
#define DeltaFormatControlAnd_Tag 0x0566
#define DeltaFormatControlOr_Tag 0x0567
#define PipeModeAnd_Tag 0x0568
#define PipeModeOr_Tag 0x0569
#define FogVertexModeAnd_Tag 0x056a
#define FogVertexModeOr_Tag 0x056b
#define TextureModeAnd_Tag 0x056c
#define TextureModeOr_Tag 0x056d
#define StripeFilterModeAnd_Tag 0x056e
#define StripeFilterModeOr_Tag 0x056f
#define WindowAnd_Tag 0x0570
#define WindowOr_Tag 0x0571
#define LBReadModeAnd_Tag 0x0572
#define LBReadModeOr_Tag 0x0573
#define RasterizerModeAnd_Tag 0x0574
#define RasterizerModeOr_Tag 0x0575
#define ScissorModeAnd_Tag 0x0576
#define ScissorModeOr_Tag 0x0577
#define LineStippleModeAnd_Tag 0x0578
#define LineStippleModeOr_Tag 0x0579
#define AreaStippleModeAnd_Tag 0x057a
#define AreaStippleModeOr_Tag 0x057b
#define ColorDDAModeAnd_Tag 0x057c
#define ColorDDAModeOr_Tag 0x057d
#define AlphaTestModeAnd_Tag 0x057e
#define AlphaTestModeOr_Tag 0x057f
#define AntialiasModeAnd_Tag 0x0580
#define AntialiasModeOr_Tag 0x0581
#define FogModeAnd_Tag 0x0582
#define FogModeOr_Tag 0x0583
#define TextureCoordModeAnd_Tag 0x0584
#define TextureCoordModeOr_Tag 0x0585
#define TextureReadMode0And_Tag 0x0586
#define TextureReadMode0Or_Tag 0x0587
#define TextureFormatAnd_Tag 0x0588
#define TextureFormatOr_Tag 0x0589
#define TextureApplicationModeAnd_Tag 0x058a
#define TextureApplicationModeOr_Tag 0x058b
#define StencilModeAnd_Tag 0x058c
#define StencilModeOr_Tag 0x058d
#define DepthModeAnd_Tag 0x058e
#define DepthModeOr_Tag 0x058f
#define LBWriteModeAnd_Tag 0x0590
#define LBWriteModeOr_Tag 0x0591
#define FBDestReadModeAnd_Tag 0x0592
#define FBDestReadModeOr_Tag 0x0593
#define FBSourceReadModeAnd_Tag 0x0594
#define FBSourceReadModeOr_Tag 0x0595
#define AlphaBlendColorModeAnd_Tag 0x0596
#define AlphaBlendColorModeOr_Tag 0x0597
#define ChromaTestModeAnd_Tag 0x0598
#define ChromaTestModeOr_Tag 0x0599
#define DitherModeAnd_Tag 0x059a
#define DitherModeOr_Tag 0x059b
#define LogicalOpModeAnd_Tag 0x059c
#define LogicalOpModeOr_Tag 0x059d
#define FBWriteModeAnd_Tag 0x059e
#define FBWriteModeOr_Tag 0x059f
#define FilterModeAnd_Tag 0x05a0
#define FilterModeOr_Tag 0x05a1
#define StatisticModeAnd_Tag 0x05a2
#define StatisticModeOr_Tag 0x05a3
#define FBDestReadEnablesAnd_Tag 0x05a4
#define FBDestReadEnablesOr_Tag 0x05a5
#define AlphaBlendAlphaModeAnd_Tag 0x05a6
#define AlphaBlendAlphaModeOr_Tag 0x05a7
#define TextureReadMode1And_Tag 0x05a8
#define TextureReadMode1Or_Tag 0x05a9
#define TextureFilterModeAnd_Tag 0x05aa
#define TextureFilterModeOr_Tag 0x05ab
#define LUTModeAnd_Tag 0x05ae
#define LUTModeOr_Tag 0x05af
#define FBDestReadBufferAddr0_Tag 0x05d0
#define FBDestReadBufferAddr1_Tag 0x05d1
#define FBDestReadBufferAddr2_Tag 0x05d2
#define FBDestReadBufferAddr3_Tag 0x05d3
#define FBDestReadBufferOffset0_Tag 0x05d4
#define FBDestReadBufferOffset1_Tag 0x05d5
#define FBDestReadBufferOffset2_Tag 0x05d6
#define FBDestReadBufferOffset3_Tag 0x05d7
#define FBDestReadBufferWidth0_Tag 0x05d8
#define FBDestReadBufferWidth1_Tag 0x05d9
#define FBDestReadBufferWidth2_Tag 0x05da
#define FBDestReadBufferWidth3_Tag 0x05db
#define FBDestReadMode_Tag 0x05dc
#define FBDestReadEnables_Tag 0x05dd
#define FBSourceReadMode_Tag 0x05e0
#define FBSourceReadBufferAddr_Tag 0x05e1
#define FBSourceReadBufferOffset_Tag 0x05e2
#define FBSourceReadBufferWidth_Tag 0x05e3
#define MergeSpanData_Tag 0x05e7
#define PCIWindowBase0_Tag 0x05e8
#define PCIWindowBase1_Tag 0x05e9
#define PCIWindowBase2_Tag 0x05ea
#define PCIWindowBase3_Tag 0x05eb
#define PCIWindowBase4_Tag 0x05ec
#define PCIWindowBase5_Tag 0x05ed
#define PCIWindowBase6_Tag 0x05ee
#define PCIWindowBase7_Tag 0x05ef
#define AlphaSourceColor_Tag 0x05f0
#define AlphaDestColor_Tag 0x05f1
#define ChromaPassColor_Tag 0x05f2
#define ChromaFailColor_Tag 0x05f3
#define AlphaBlendColorMode_Tag 0x05f4
#define AlphaBlendAlphaMode_Tag 0x05f5
#define ConstantColorDDA_Tag 0x05f6
#define D3DAlphaTestMode_Tag 0x05f8
#define FBWriteBufferAddr0_Tag 0x0600
#define FBWriteBufferAddr1_Tag 0x0601
#define FBWriteBufferAddr2_Tag 0x0602
#define FBWriteBufferAddr3_Tag 0x0603
#define FBWriteBufferOffset0_Tag 0x0604
#define FBWriteBufferOffset1_Tag 0x0605
#define FBWriteBufferOffset2_Tag 0x0606
#define FBWriteBufferOffset3_Tag 0x0607
#define FBWriteBufferWidth0_Tag 0x0608
#define FBWriteBufferWidth1_Tag 0x0609
#define FBWriteBufferWidth2_Tag 0x060a
#define FBWriteBufferWidth3_Tag 0x060b
#define FBBlockColor0_Tag 0x060c
#define FBBlockColor1_Tag 0x060d
#define FBBlockColor2_Tag 0x060e
#define FBBlockColor3_Tag 0x060f
#define FBBlockColorBack0_Tag 0x0610
#define FBBlockColorBack1_Tag 0x0611
#define FBBlockColorBack2_Tag 0x0612
#define FBBlockColorBack3_Tag 0x0613
#define FBBlockColorBack_Tag 0x0614
#define SizeOfFramebuffer_Tag 0x0615
#define VTGAddress_Tag 0x0616
#define VTGData_Tag 0x0617
#define ForegroundColor_Tag 0x0618
#define BackgroundColor_Tag 0x0619
#define DownloadAddress_Tag 0x061a
#define DownloadData_Tag 0x061b
#define FBBlockColorExt_Tag 0x061c
#define FBBlockColorBackExt_Tag 0x061d
#define FBWriteMaskExt_Tag 0x061e
#define FogTable0_Tag 0x0620
#define FogTable1_Tag 0x0621
#define FogTable2_Tag 0x0622
#define FogTable3_Tag 0x0623
#define FogTable4_Tag 0x0624
#define FogTable5_Tag 0x0625
#define FogTable6_Tag 0x0626
#define FogTable7_Tag 0x0627
#define FogTable8_Tag 0x0628
#define FogTable9_Tag 0x0629
#define FogTable10_Tag 0x062a
#define FogTable11_Tag 0x062b
#define FogTable12_Tag 0x062c
#define FogTable13_Tag 0x062d
#define FogTable14_Tag 0x062e
#define FogTable15_Tag 0x062f
#define FogTable16_Tag 0x0630
#define FogTable17_Tag 0x0631
#define FogTable18_Tag 0x0632
#define FogTable19_Tag 0x0633
#define FogTable20_Tag 0x0634
#define FogTable21_Tag 0x0635
#define FogTable22_Tag 0x0636
#define FogTable23_Tag 0x0637
#define FogTable24_Tag 0x0638
#define FogTable25_Tag 0x0639
#define FogTable26_Tag 0x063a
#define FogTable27_Tag 0x063b
#define FogTable28_Tag 0x063c
#define FogTable29_Tag 0x063d
#define FogTable30_Tag 0x063e
#define FogTable31_Tag 0x063f
#define FogTable32_Tag 0x0640
#define FogTable33_Tag 0x0641
#define FogTable34_Tag 0x0642
#define FogTable35_Tag 0x0643
#define FogTable36_Tag 0x0644
#define FogTable37_Tag 0x0645
#define FogTable38_Tag 0x0646
#define FogTable39_Tag 0x0647
#define FogTable40_Tag 0x0648
#define FogTable41_Tag 0x0649
#define FogTable42_Tag 0x064a
#define FogTable43_Tag 0x064b
#define FogTable44_Tag 0x064c
#define FogTable45_Tag 0x064d
#define FogTable46_Tag 0x064e
#define FogTable47_Tag 0x064f
#define FogTable48_Tag 0x0650
#define FogTable49_Tag 0x0651
#define FogTable50_Tag 0x0652
#define FogTable51_Tag 0x0653
#define FogTable52_Tag 0x0654
#define FogTable53_Tag 0x0655
#define FogTable54_Tag 0x0656
#define FogTable55_Tag 0x0657
#define FogTable56_Tag 0x0658
#define FogTable57_Tag 0x0659
#define FogTable58_Tag 0x065a
#define FogTable59_Tag 0x065b
#define FogTable60_Tag 0x065c
#define FogTable61_Tag 0x065d
#define FogTable62_Tag 0x065e
#define FogTable63_Tag 0x065f
#define TextureCompositeMode_Tag 0x0660
#define TextureCompositeColorMode0_Tag 0x0661
#define TextureCompositeAlphaMode0_Tag 0x0662
#define TextureCompositeColorMode1_Tag 0x0663
#define TextureCompositeAlphaMode1_Tag 0x0664
#define TextureCompositeFactor0_Tag 0x0665
#define TextureCompositeFactor1_Tag 0x0666
#define TextureIndexMode0_Tag 0x0667
#define TextureIndexMode1_Tag 0x0668
#define LodRange0_Tag 0x0669
#define LodRange1_Tag 0x066a
#define InvalidateCache_Tag 0x066b
#define SetLogicalTexturePage_Tag 0x066c
#define UpdateLogicalTextureInfo_Tag 0x066d
#define TouchLogicalPage_Tag 0x066e
#define LUTMode_Tag 0x066f
#define TextureCompositeColorMode0And_Tag 0x0670
#define TextureCompositeColorMode0Or_Tag 0x0671
#define TextureCompositeAlphaMode0And_Tag 0x0672
#define TextureCompositeAlphaMode0Or_Tag 0x0673
#define TextureCompositeColorMode1And_Tag 0x0674
#define TextureCompositeColorMode1Or_Tag 0x0675
#define TextureCompositeAlphaMode1And_Tag 0x0676
#define TextureCompositeAlphaMode1Or_Tag 0x0677
#define TextureIndexMode0And_Tag 0x0678
#define TextureIndexMode0Or_Tag 0x0679
#define TextureIndexMode1And_Tag 0x067a
#define TextureIndexMode1Or_Tag 0x067b
#define StencilDataAnd_Tag 0x067c
#define TextureReadMode0_Tag 0x0680
#define TextureReadMode1_Tag 0x0681
#define TextureMapSize_Tag 0x0685
#define TextureCacheReplacementMode_Tag 0x0686
#define StencilDataOr_Tag 0x068d
#define HeadPhysicalPageAllocation0_Tag 0x0690
#define HeadPhysicalPageAllocation1_Tag 0x0691
#define HeadPhysicalPageAllocation2_Tag 0x0692
#define HeadPhysicalPageAllocation3_Tag 0x0693
#define TailPhysicalPageAllocation0_Tag 0x0694
#define TailPhysicalPageAllocation1_Tag 0x0695
#define TailPhysicalPageAllocation2_Tag 0x0696
#define TailPhysicalPageAllocation3_Tag 0x0697
#define PhysicalPageAllocationTableAddr_Tag 0x0698
#define BasePageOfWorkingSet_Tag 0x0699
#define LogicalTexturePageTableAddr_Tag 0x069a
#define LogicalTexturePageTableLength_Tag 0x069b
#define BasePageOfWorkingSetHost_Tag 0x069c
#define LBDestReadMode_Tag 0x06a0
#define LBDestReadEnables_Tag 0x06a1
#define LBDestReadBufferAddr_Tag 0x06a2
#define LBDestReadBufferOffset_Tag 0x06a3
#define LBSourceReadMode_Tag 0x06a4
#define LBSourceReadBufferAddr_Tag 0x06a5
#define LBSourceReadBufferOffset_Tag 0x06a6
#define GIDMode_Tag 0x06a7
#define LBWriteBufferAddr_Tag 0x06a8
#define LBWriteBufferOffset_Tag 0x06a9
#define LBClearDataL_Tag 0x06aa
#define LBClearDataU_Tag 0x06ab
#define LBDestReadModeAnd_Tag 0x06b0
#define LBDestReadModeOr_Tag 0x06b1
#define LBDestReadEnablesAnd_Tag 0x06b2
#define LBDestReadEnablesOr_Tag 0x06b3
#define LBSourceReadModeAnd_Tag 0x06b4
#define LBSourceReadModeOr_Tag 0x06b5
#define GIDModeAnd_Tag 0x06b6
#define GIDModeOr_Tag 0x06b7
#define ReadMonitorModeAnd_Tag 0x06b8
#define ReadMonitorModeOr_Tag 0x06b9
#define RectanglePosition_Tag 0x06c0
#define GlyphPosition_Tag 0x06c1
#define RenderPatchOffset_Tag 0x06c2
#define Config2D_Tag 0x06c3
#define Packed8Pixels_Tag 0x06c6
#define Packed16Pixels_Tag 0x06c7
#define Render2D_Tag 0x06c8
#define Render2DGlyph_Tag 0x06c9
#define DownloadTarget_Tag 0x06ca
#define DownloadGlyphWidth_Tag 0x06cb
#define GlyphData_Tag 0x06cc
#define Packed4Pixels_Tag 0x06cd
#define RLData_Tag 0x06ce
#define RLCount_Tag 0x06cf
#define SClkProfileMask0_Tag 0x06d0
#define SClkProfileMask1_Tag 0x06d1
#define SClkProfileCount0_Tag 0x06d2
#define SClkProfileCount1_Tag 0x06d3
#define KClkProfileMask0_Tag 0x06d4
#define KClkProfileMask1_Tag 0x06d5
#define KClkProfileMask2_Tag 0x06d6
#define KClkProfileMask3_Tag 0x06d7
#define KClkProfileCount0_Tag 0x06d8
#define KClkProfileCount1_Tag 0x06d9
#define KClkProfileCount2_Tag 0x06da
#define KClkProfileCount3_Tag 0x06db
#define IndexBaseAddress_Tag 0x06e0
#define VertexBaseAddress_Tag 0x06e1
#define IndexedTriangleList_Tag 0x06e2
#define IndexedTriangleFan_Tag 0x06e3
#define IndexedTriangleStrip_Tag 0x06e4
#define IndexedLineList_Tag 0x06e5
#define IndexedLineStrip_Tag 0x06e6
#define IndexedPointList_Tag 0x06e7
#define IndexedPolygon_Tag 0x06e8
#define VertexTriangleList_Tag 0x06e9
#define VertexTriangleFan_Tag 0x06ea
#define VertexTriangleStrip_Tag 0x06eb
#define VertexLineList_Tag 0x06ec
#define VertexLineStrip_Tag 0x06ed
#define VertexPointList_Tag 0x06ee
#define VertexPolygon_Tag 0x06ef
#define DMAMemoryControl_Tag 0x06f0
#define VertexValid_Tag 0x06f1
#define VertexFormat_Tag 0x06f2
#define VertexControl_Tag 0x06f3
#define RetainedRender_Tag 0x06f4
#define IndexedVertex_Tag 0x06f5
#define IndexedDoubleVertex_Tag 0x06f6
#define Vertex0_Tag 0x06f7
#define Vertex1_Tag 0x06f8
#define Vertex2_Tag 0x06f9
#define VertexData0_Tag 0x06fa
#define VertexData1_Tag 0x06fb
#define VertexData2_Tag 0x06fc
#define VertexData_Tag 0x06fd
#define VertexTagList0_Tag 0x0700
#define VertexTagList1_Tag 0x0701
#define VertexTagList2_Tag 0x0702
#define VertexTagList3_Tag 0x0703
#define VertexTagList4_Tag 0x0704
#define VertexTagList5_Tag 0x0705
#define VertexTagList6_Tag 0x0706
#define VertexTagList7_Tag 0x0707
#define VertexTagList8_Tag 0x0708
#define VertexTagList9_Tag 0x0709
#define VertexTagList10_Tag 0x070a
#define VertexTagList11_Tag 0x070b
#define VertexTagList12_Tag 0x070c
#define VertexTagList13_Tag 0x070d
#define VertexTagList14_Tag 0x070e
#define VertexTagList15_Tag 0x070f
#define VertexTagList16_Tag 0x0710
#define VertexTagList17_Tag 0x0711
#define VertexTagList18_Tag 0x0712
#define VertexTagList19_Tag 0x0713
#define VertexTagList20_Tag 0x0714
#define VertexTagList21_Tag 0x0715
#define VertexTagList22_Tag 0x0716
#define VertexTagList23_Tag 0x0717
#define VertexTagList24_Tag 0x0718
#define VertexTagList25_Tag 0x0719
#define VertexTagList26_Tag 0x071a
#define VertexTagList27_Tag 0x071b
#define VertexTagList28_Tag 0x071c
#define VertexTagList29_Tag 0x071d
#define VertexTagList30_Tag 0x071e
#define VertexTagList31_Tag 0x071f
#define SetPipe_Tag 0x0810
#define RestartPipe_Tag 0x0811
#define DeltaMultiTexture0A_Tag 0x0840
#define DeltaMultiTexture0B_Tag 0x0841
#define DeltaMultiTexture0C_Tag 0x0842
#define DeltaMultiTexture0D_Tag 0x0843
#define DeltaMultiTexture0E_Tag 0x0844
#define DeltaMultiTexture0F_Tag 0x0845
#define DeltaMultiTexture0G_Tag 0x0846
#define DeltaMultiTexture0H_Tag 0x0847
#define DeltaMultiTexture1A_Tag 0x0848
#define DeltaMultiTexture1B_Tag 0x0849
#define DeltaMultiTexture1C_Tag 0x084a
#define DeltaMultiTexture1D_Tag 0x084b
#define DeltaMultiTexture1E_Tag 0x084c
#define DeltaMultiTexture1F_Tag 0x084d
#define DeltaMultiTexture1G_Tag 0x084e
#define DeltaMultiTexture1H_Tag 0x084f
#define DeltaMultiTexture2A_Tag 0x0850
#define DeltaMultiTexture2B_Tag 0x0851
#define DeltaMultiTexture2C_Tag 0x0852
#define DeltaMultiTexture2D_Tag 0x0853
#define DeltaMultiTexture2E_Tag 0x0854
#define DeltaMultiTexture2F_Tag 0x0855
#define DeltaMultiTexture2G_Tag 0x0856
#define DeltaMultiTexture2H_Tag 0x0857
#define DeltaMultiTexture3A_Tag 0x0858
#define DeltaMultiTexture3B_Tag 0x0859
#define DeltaMultiTexture3C_Tag 0x085a
#define DeltaMultiTexture3D_Tag 0x085b
#define DeltaMultiTexture3E_Tag 0x085c
#define DeltaMultiTexture3F_Tag 0x085d
#define DeltaMultiTexture3G_Tag 0x085e
#define DeltaMultiTexture3H_Tag 0x085f
#define TAq_Tag 0x0870
#define TAr_Tag 0x0871
#define TAt_Tag 0x0872
#define TAs1_Tag 0x0873
#define TAs2_Tag 0x0874
#define TAs3_Tag 0x0875
#define TAs4_Tag 0x0876
#define TAs3q_Tag 0x0877
#define TBq_Tag 0x0878
#define TBr_Tag 0x0879
#define TBt_Tag 0x087a
#define TBs1_Tag 0x087b
#define TBs2_Tag 0x087c
#define TBs3_Tag 0x087d
#define TBs4_Tag 0x087e
#define TBs3q_Tag 0x087f
#define TCq_Tag 0x0880
#define TCr_Tag 0x0881
#define TCt_Tag 0x0882
#define TCs1_Tag 0x0883
#define TCs2_Tag 0x0884
#define TCs3_Tag 0x0885
#define TCs4_Tag 0x0886
#define TCs3q_Tag 0x0887
#define TDq_Tag 0x0888
#define TDr_Tag 0x0889
#define TDt_Tag 0x088a
#define TDs1_Tag 0x088b
#define TDs2_Tag 0x088c
#define TDs3_Tag 0x088d
#define TDs4_Tag 0x088e
#define TDs3q_Tag 0x088f
#define TEq_Tag 0x0890
#define TEr_Tag 0x0891
#define TEt_Tag 0x0892
#define TEs1_Tag 0x0893
#define TEs2_Tag 0x0894
#define TEs3_Tag 0x0895
#define TEs4_Tag 0x0896
#define TEs3q_Tag 0x0897
#define TFq_Tag 0x0898
#define TFr_Tag 0x0899
#define TFt_Tag 0x089a
#define TFs1_Tag 0x089b
#define TFs2_Tag 0x089c
#define TFs3_Tag 0x089d
#define TFs4_Tag 0x089e
#define TFs3q_Tag 0x089f
#define TGq_Tag 0x08a0
#define TGr_Tag 0x08a1
#define TGt_Tag 0x08a2
#define TGs1_Tag 0x08a3
#define TGs2_Tag 0x08a4
#define TGs3_Tag 0x08a5
#define TGs4_Tag 0x08a6
#define TGs3q_Tag 0x08a7
#define THq_Tag 0x08a8
#define THr_Tag 0x08a9
#define THt_Tag 0x08aa
#define THs1_Tag 0x08ab
#define THs2_Tag 0x08ac
#define THs3_Tag 0x08ad
#define THs4_Tag 0x08ae
#define THs3q_Tag 0x08af
#define StripeOwnership_Tag 0x08b0
#define StripeFilterYOffset_Tag 0x08b1
#define PointExtend_Tag 0x08b2
#define AAPointExtend_Tag 0x08b3
#define LineExtend_Tag 0x08b4
#define AALineExtend_Tag 0x08b5
#define TriangleExtend_Tag 0x08b6
#define AATriangleExtend_Tag 0x08b7
#define StripeYBias_Tag 0x08b8
#define VBFactor0_Tag 0x08bc
#define VBFactor1_Tag 0x08bd
#define NBFactor0_Tag 0x08be
#define NBFactor1_Tag 0x08bf
#define MatrixModeAnd_Tag 0x08c0
#define MatrixModeOr_Tag 0x08c1
#define PipeLoadAnd_Tag 0x08c2
#define PipeLoadOr_Tag 0x08c3
#define MatrixSelect_Tag 0x08d0
#define MatrixStatus_Tag 0x08d1
#define SetUnitMatrix_Tag 0x08d2
#define LoadMatrix_Tag 0x08d3
#define MultiplyMatrix_Tag 0x08d4
#define ResetMatrixStack_Tag 0x08d5
#define PushMatrix_Tag 0x08d6
#define PopMatrix_Tag 0x08d7
#define GetMatrix_Tag 0x08d8
#define InvertCurrentMatrix_Tag 0x08d9
#define ComputeMatrices_Tag 0x08da
#define PipeLoad_Tag 0x08dc
#define CurrentMatrix0_Tag 0x08e0
#define CurrentMatrix1_Tag 0x08e1
#define CurrentMatrix2_Tag 0x08e2
#define CurrentMatrix3_Tag 0x08e3
#define CurrentMatrix4_Tag 0x08e4
#define CurrentMatrix5_Tag 0x08e5
#define CurrentMatrix6_Tag 0x08e6
#define CurrentMatrix7_Tag 0x08e7
#define CurrentMatrix8_Tag 0x08e8
#define CurrentMatrix9_Tag 0x08e9
#define CurrentMatrix10_Tag 0x08ea
#define CurrentMatrix11_Tag 0x08eb
#define CurrentMatrix12_Tag 0x08ec
#define CurrentMatrix13_Tag 0x08ed
#define CurrentMatrix14_Tag 0x08ee
#define CurrentMatrix15_Tag 0x08ef
#define LightNumber_Tag 0x08f0
#define LightPositionX_Tag 0x08f1
#define LightPositionY_Tag 0x08f2
#define LightPositionZ_Tag 0x08f3
#define LightPositionW_Tag 0x08f4
#define SpotLightDirectionX_Tag 0x08f5
#define SpotLightDirectionY_Tag 0x08f6
#define SpotLightDirectionZ_Tag 0x08f7
#define BoundingBoxMinX_Tag 0x08fa
#define BoundingBoxMinY_Tag 0x08fb
#define BoundingBoxMinZ_Tag 0x08fc
#define BoundingBoxMaxX_Tag 0x08fd
#define BoundingBoxMaxY_Tag 0x08fe
#define BoundingBoxMaxZ_Tag 0x08ff
#define StartBoundingVolume_Tag 0x0910
#define BoundingVertexX_Tag 0x0913
#define BoundingVertexY_Tag 0x0914
#define BoundingVertexZ_Tag 0x0915
#define BNz_Tag 0x0920
#define BNy_Tag 0x0921
#define BNx_Tag 0x0922
#define BVw_Tag 0x0923
#define BVz_Tag 0x0924
#define BVy_Tag 0x0925
#define BVx2_Tag 0x0926
#define BVx3_Tag 0x0927
#define BVx4_Tag 0x0928
#define BlendVertex_Tag 0x0930
#define BlendNormal_Tag 0x0931

#define N_Tag 0x800

#endif // _TAG_H_

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\rgb526.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: rgb526.h
*
* Content: This module contains the definitions for the IBM RGB526 RAMDAC.
*          The 526 is a superset of the 525 so only define things which have 
*          changed.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// RGB526_REVISION_LEVEL
#define RGB526_PRODUCT_REV_LEVEL        0xc0
#define RGB526DB_PRODUCT_REV_LEVEL      0x80

// RGB526_ID
#define RGB526_PRODUCT_ID               0x02

//
// Key Support
//
#define RGB526_KEY_VALUE                0x68
#define RGB526_KEY_MASK                 0x6c
#define RGB526_KEY_CONTROL              0x78

// RGB526_32BPP_CTRL in addition to those on the RGB525
#define B32_DCOL_B8_INDIRECT            0x00    // overlay goes thru palette
#define B32_DCOL_B8_DIRECT              0x40    // overlay bypasses palette

#define RGB526_SYSTEM_CLOCK_CTRL        0x0008

#define RGB526_SYSCLK_REFDIVCOUNT       0x0015
#define RGB526_SYSCLK_VCODIVIDER        0x0016

#define RGB526_SYSCLK_N                 0x0015
#define RGB526_SYSCLK_M                 0x0016
#define RGB526_SYSCLK_P                 0x0017
#define RGB526_SYSCLK_C                 0x0018
#define RGB526_M0                       0x0020
#define RGB526_N0                       0x0021
#define RGB526_P0                       0x0022
#define RGB526_C0                       0x0023
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\surf_fmt.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: surf_fmt.h
*
* Content: 
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __SURF_FMAT
#define __SURF_FMAT


#define LOG_2_32 5
#define LOG_2_16 4
#define LOG_2_8 3
#define LOG_2_4 2
#define LOG_2_2 1
#define LOG_2_1 0

typedef enum tagTextureColorComponents
{
    RGB_COMPONENTS = 2,
    RGBA_COMPONENTS = 3,
    COMPONENTS_DONT_CARE = 100
} TextureColorComponents;

typedef enum tagSurfDeviceFormat
{
    SURF_8888 = 0,
    SURF_5551_FRONT = 1,
    SURF_4444 = 2,
    SURF_4444_FRONT = 3,
    SURF_4444_BACK = 4,
    SURF_332_FRONT = 5,
    SURF_332_BACK = 6,
    SURF_121_FRONT = 7,
    SURF_121_BACK = 8,
    SURF_2321_FRONT = 9,
    SURF_2321_BACK = 10,
    SURF_232_FRONTOFF = 11,
    SURF_232_BACKOFF = 12,
    SURF_5551_BACK = 13,
    SURF_CI8 = 14,
    SURF_CI4 = 15,
    SURF_565_FRONT = 16,
    SURF_565_BACK = 17,
    SURF_YUV444 = 18,
    SURF_YUV422 = 19,

    // NB: These surface formats are needed for the luminance
    // texturemap formats.  Note that you should never load the below
    // values into the blitter's, etc. because the texture filter unit
    // is the only one that knows about these formats.  This is why the 
    // formats start at 100
    SURF_L8 = 100,
    SURF_A8L8 = 101,
    SURF_A4L4 = 102,
    SURF_A8 = 103,

    // More fantasy formats.  This time they are for Mediamatics playback
    SURF_MVCA = 104,
    SURF_MVSU = 105,
    SURF_MVSB = 106,
    SURF_FORMAT_INVALID = 0xFFFFFFFF
} SurfDeviceFormat;

typedef enum tagSurfFilterDeviceFormat
{
    SURF_FILTER_A4L4 = 0,
    SURF_FILTER_L8 = 1,
    SURF_FILTER_I8 = 2,
    SURF_FILTER_A8 = 3,
    SURF_FILTER_332 = 4,
    SURF_FILTER_A8L8 = 5,
    SURF_FILTER_5551 = 6,
    SURF_FILTER_565 = 7,
    SURF_FILTER_4444 = 8,
    SURF_FILTER_888 = 9,
    SURF_FILTER_8888_OR_YUV = 10,
    SURF_FILTER_INVALID = 0xFFFFFFFF
} SurfFilterDeviceFormat;    

typedef enum tagSurfDitherDeviceFormat
{
    SURF_DITHER_8888    = P3RX_DITHERMODE_COLORFORMAT_8888,
    SURF_DITHER_4444    = P3RX_DITHERMODE_COLORFORMAT_4444,
    SURF_DITHER_5551    = P3RX_DITHERMODE_COLORFORMAT_5551,
    SURF_DITHER_565     = P3RX_DITHERMODE_COLORFORMAT_565,
    SURF_DITHER_332     = P3RX_DITHERMODE_COLORFORMAT_332,
    SURF_DITHER_I8      = P3RX_DITHERMODE_COLORFORMAT_CI,
    SURF_DITHER_INVALID = 0xFFFFFFFF
} SurfDitherDeviceFormat;

// A structure representing a particular surface format to use.
typedef const struct tagSURF_FORMAT
{
    SurfDeviceFormat            DeviceFormat;        // The number in the manual for this format
    DWORD                       dwBitsPerPixel;        // The bits per pixel
    DWORD                       dwChipPixelSize;    // The pixel size register on the chip
    TextureColorComponents      ColorComponents;    // The number of color components for this format
    DWORD                       dwLogPixelDepth;    // The log of the pixel depth (log2(16), etc)
    DWORD                       dwRedMask;            // The Red Mask
    DWORD                       dwGreenMask;        // The Green Mask
    DWORD                       dwBlueMask;            // The Blue Mask
    DWORD                       dwAlphaMask;        // The Alpha Mask
    BOOL                        bAlpha;                // Are we using the alpha in this format?
    SurfFilterDeviceFormat      FilterFormat;        // For feeding the P3RX filter unit.
    SurfDitherDeviceFormat      DitherFormat;        // For feeding the P3RX dither unit.
    char                        *pszStringFormat;    // Human-readable string for debugging.
} P3_SURF_FORMAT;

#define SURFFORMAT_FORMAT_BITS(pSurfFormat) (((DWORD)(pSurfFormat)->DeviceFormat) & 0xF)
#define SURFFORMAT_FORMATEXTENSION_BITS(pSurfFormat) (((DWORD)(pSurfFormat)->DeviceFormat & 0x10) >> 4)
#define SURFFORMAT_PIXELSIZE(pSurfFormat) ((pSurfFormat)->dwChipPixelSize)

#define MAX_SURFACE_FORMATS 50

#endif // __SURF_FMAT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\softcopy.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: softcopy.h
*
* Content:
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifdef __SOFTCOPY
#pragma message ("FILE : "__FILE__" : Multiple Inclusion");
#endif

#define __SOFTCOPY

#ifndef __EREG
#include "ereg.h"
#endif
// For the gigi specific registers.
#ifndef __GIGIREGL
#include "gigiregl.h"
#endif
#ifndef _REG_H_
#include "reg.h"
#endif

#define P3_LOD_LEVELS 16
#define G3_TEXTURE_STAGES 8

typedef struct {
    // Common Local Buffer Registers
    __GlintLBReadModeFmat               LBReadMode;
    __GlintLBReadFormatFmat             LBReadFormat;
    __GlintLBWriteModeFmat              LBWriteMode;

    // Common Frame Buffer Registers
    __GlintFBReadModeFmat               FBReadMode;
    __GlintFBWriteModeFmat              FBWriteMode;
    __GlintLogicalOpModeFmat            LogicalOpMode;
    __GlintDitherModeFmat               DitherMode;
    __GlintColorDDAModeFmat             ColorDDAMode;

    // Common Depth/Stencil/Window Registers
    __GlintDepthModeFmat                DepthMode;
    __GlintStencilModeFmat              StencilMode;
    __GlintStencilDataFmat              StencilData;
    __GigiWindowFmat                    PermediaWindow;

    // Alpha/Fog registers
    __GigiAlphaBlendModeFmat            PermediaAlphaBlendMode;

    // Fog unit
    __GlintFogModeFmat                  FogMode;

    // YUV Unit
    __GigiYUVModeFmat                   PermediaYUVMode;

    // Permedia Texture Registers
    __GigiTextureColorModeFmat          PermediaTextureColorMode;
    __GigiTextureAddrModeFmat           PermediaTextureAddressMode;
    __GigiTextureReadModeFmat           PermediaTextureReadMode;
    __GigiTextureDataFormatFmat         PermediaTextureDataFormat;
    __GigiTextureMapFormatFmat          PermediaTextureMapFormat;

    // Scissor/Stipple unit
    __GigiScissorMinXYFmat              ScissorMinXY;
    __GigiScissorMaxXYFmat              ScissorMaxXY;
    __GigiScreenSizeFmat                ScreenSize;

    // ****************

    // P3 Registers
    // Frame buffer
    struct FBWriteBufferWidth               P3RXFBWriteBufferWidth0;
    struct FBDestReadBufferWidth            P3RXFBDestReadBufferWidth0;                
    struct FBSourceReadBufferWidth          P3RXFBSourceReadBufferWidth;
    struct FBDestReadEnables                P3RXFBDestReadEnables;
    struct FBWriteMode                      P3RXFBWriteMode;
    struct ChromaTestMode                   P3RXChromaTestMode;

    // Local buffer
    struct LBSourceReadMode                 P3RXLBSourceReadMode;
    struct LBDestReadMode                   P3RXLBDestReadMode;
    struct LBWriteMode                      P3RXLBWriteMode;
    struct DepthMode                        P3RXDepthMode;
    struct LBReadFormat                     P3RXLBReadFormat;
    struct LBWriteFormat                    P3RXLBWriteFormat;
    
    // Textures
    struct TextureReadMode                  P3RXTextureReadMode0;
    struct TextureReadMode                  P3RXTextureReadMode1;
    struct TextureIndexMode                 P3RXTextureIndexMode0;
    struct TextureIndexMode                 P3RXTextureIndexMode1;
    struct TextureMapWidth                  P3RXTextureMapWidth[P3_LOD_LEVELS];
    struct TextureCoordMode                 P3RXTextureCoordMode;
    struct TextureApplicationMode           P3RXTextureApplicationMode;
    struct TextureFilterMode                P3RXTextureFilterMode;
    struct TextureCompositeRGBAMode         P3RXTextureCompositeColorMode0;
    struct TextureCompositeRGBAMode         P3RXTextureCompositeColorMode1;
    struct TextureCompositeRGBAMode         P3RXTextureCompositeAlphaMode0;
    struct TextureCompositeRGBAMode         P3RXTextureCompositeAlphaMode1;
    struct LUTMode                          P3RXLUTMode;
    struct TextureCacheReplacementMode      P3RXTextureCacheReplacementMode;

    // Stencil
    struct StencilMode                      P3RXStencilMode;
    struct StencilData                      P3RXStencilData;
    struct Window                           P3RXWindow;

    // Fog
    struct FogMode                          P3RXFogMode;

    // Alpha
    struct AlphaTestMode                    P3RXAlphaTestMode;
    struct AlphaBlendAlphaMode              P3RXAlphaBlendAlphaMode;
    struct AlphaBlendColorMode              P3RXAlphaBlendColorMode;

    // Framebuffer
    struct FBDestReadMode                   P3RXFBDestReadMode;
    struct FBSourceReadMode                 P3RXFBSourceReadMode;

    // Rasterizer
    struct RasterizerMode                   P3RXRasterizerMode;
    struct ScanlineOwnership                P3RXScanlineOwnership;

    // Scissor
    __GlintXYFmat                           P3RXScissorMinXY;
    __GlintXYFmat                           P3RXScissorMaxXY;

    // P3 Specific registers
    
    // Delta
    union
    {
        struct GMDeltaMode                  GammaDeltaMode;
        struct P3DeltaMode                  P3RX_P3DeltaMode;
        __GigiDeltaModeFmat                 DeltaMode;
    };

    struct DeltaControl                     P3RX_P3DeltaControl;
    struct VertexControl                    P3RX_P3VertexControl;

    // P4 Specific registers
    struct DeltaFormatControl               P4DeltaFormatControl;

    // GAMMA Registers
    struct Gamma3GeometryMode               G3GeometryMode;
    struct GeometryMode                     G1GeometryMode;
    struct TransformMode                    GammaTransformMode;
    struct NormaliseMode                    GammaNormaliseMode;
    struct LightingMode                     GammaLightingMode;
    struct MaterialMode                     GammaMaterialMode;
    struct ColorMaterialMode                GammaColorMaterialMode;
    struct StripeFilterMode                 GammaStripeFilterMode;
    struct MatrixMode                       GammaMatrixMode;
    struct PipeMode                         GammaPipeMode;
    struct PipeLoad                         GammaPipeLoad;
    struct VertexMachineMode                GammaVertexMachineMode;
    struct TextureMode                      GammaTextureMode[G3_TEXTURE_STAGES];
    struct FogVertexMode                    GammaFogVertexMode;

    // Total 30 DWORDS : 120 Bytes

    struct LineStippleMode                  PXRXLineStippleMode;
} P3_SOFTWARECOPY;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\tvp3026.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: tvp3026.h
*
* Content:  This module contains the definitions for the TI TVP3026 RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define ADbgpf VideoDebugPrint

//
// TI TVP3026 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _tvp3026_regs {
    volatile RAMDAC_REG  pciAddrWr;      // 0x00 - palette/cursor RAM write address, Index Register
    volatile RAMDAC_REG  palData;        // 0x01 - palette RAM data
    volatile RAMDAC_REG  pixelMask;      // 0x02 - pixel read mask
    volatile RAMDAC_REG  pcAddrRd;          // 0x03 - palette/cursor RAM read address
    
    volatile RAMDAC_REG  curAddrWr;      // 0x04 - cursor/overscan color write address
    volatile RAMDAC_REG  curData;          // 0x05 - cursor/overscan color data
    volatile RAMDAC_REG  Reserverd1;     // 0x06 - reserved
    volatile RAMDAC_REG  curAddrRd;         // 0x07 - cursor/overscan color read address

    volatile RAMDAC_REG  Reserverd2;     // 0x08 - reserved
    volatile RAMDAC_REG  curCtl;           // 0x09 - direct cursor control
    volatile RAMDAC_REG  indexData;      // 0x0A - indexed data
    volatile RAMDAC_REG  curRAMData;     // 0x0B - cursor RAM data
    
    volatile RAMDAC_REG  cursorXLow;     // 0x0C - cursor position X low byte 
    volatile RAMDAC_REG  cursorXHigh;    // 0x0D - cursor position X high byte 
    volatile RAMDAC_REG  cursorYLow;     // 0x0E - cursor position Y low byte 
    volatile RAMDAC_REG  cursorYHigh;    // 0x0F - cursor position Y high byte 
} TVP3026RAMDAC, *pTVP3026RAMDAC;

// macro declared by any function wishing to use the TI TVP3026 RAMDAC . MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define TVP3026_DECL \
    pTVP3026RAMDAC   pTVP3026Regs = (pTVP3026RAMDAC)&(pDev->pRegisters->Glint.ExtVCReg)
#else
#define TVP3026_DECL \
    pTVP3026RAMDAC   pTVP3026Regs = (pTVP3026RAMDAC)&(pRegisters->Glint.ExtVCReg)
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
//  Palette Access
#define __TVP3026_PAL_WR_ADDR                 ((PULONG)&(pTVP3026Regs->pciAddrWr.reg))
#define __TVP3026_PAL_RD_ADDR                 ((PULONG)&(pTVP3026Regs->palAddrRd.reg))
#define __TVP3026_PAL_DATA                    ((volatile PULONG)&(pTVP3026Regs->palData.reg))

// Pixel mask
#define __TVP3026_PIXEL_MASK                ((PULONG)&(pTVP3026Regs->pixelMask.reg))

// Access to the indexed registers
#define __TVP3026_INDEX_ADDR                ((PULONG)&(pTVP3026Regs->pciAddrWr.reg))
#define __TVP3026_INDEX_DATA                  ((PULONG)&(pTVP3026Regs->indexData.reg))

// Access to the Cursor
#define __TVP3026_CUR_RAM_WR_ADDR            ((PULONG)&(pTVP3026Regs->pciAddrWr.reg))
#define __TVP3026_CUR_RAM_RD_ADDR             ((PULONG)&(pTVP3026Regs->palAddrRd.reg))
#define __TVP3026_CUR_RAM_DATA                ((PULONG)&(pTVP3026Regs->curRAMData.reg))

#define __TVP3026_CUR_WR_ADDR                ((PULONG)&(pTVP3026Regs->curAddrWr.reg))
#define __TVP3026_CUR_RD_ADDR                 ((PULONG)&(pTVP3026Regs->curAddrRd.reg))
#define __TVP3026_CUR_DATA                    ((PULONG)&(pTVP3026Regs->curData.reg))

#define __TVP3026_CUR_CTL                   ((PULONG)&(pTVP3026Regs->curCtl.reg))

// Access to the overscan color
#define __TVP3026_OVRC_WR_ADDR                ((PULONG)&(pTVP3026Regs->curAddrWr.reg))
#define __TVP3026_OVRC_RD_ADDR                 ((PULONG)&(pTVP3026Regs->curAddrRd.reg))
#define __TVP3026_OVRC_DATA                    ((PULONG)&(pTVP3026Regs->curData.reg))

// Cursor position control
#define __TVP3026_CUR_X_LSB                    ((PULONG)&(pTVP3026Regs->cursorXLow.reg))
#define __TVP3026_CUR_X_MSB                 ((PULONG)&(pTVP3026Regs->cursorXHigh.reg))
#define __TVP3026_CUR_Y_LSB                    ((PULONG)&(pTVP3026Regs->cursorYLow.reg))
#define __TVP3026_CUR_Y_MSB                     ((PULONG)&(pTVP3026Regs->cursorYHigh.reg))



// ----------------------Values for some direct registers-----------------------

/********************************************************************************/
/*              DIRECT REGISTER - CURSOR AND OVERSCAN COLOR                     */
/********************************************************************************/
//  ** TVP3026_OVRC_WR_ADDR
//  ** TVP3026_OVRC_RD_ADDR 
//  ** TVP3026_CUR_WR_ADDR
//  ** TVP3026_CUR_RD_ADDR
//      Default - undefined
#define TVP3026_OVERSCAN_COLOR                  0x00
#define TVP3026_CURSOR_COLOR0                   0x01
#define TVP3026_CURSOR_COLOR1                   0x02
#define TVP3026_CURSOR_COLOR2                   0x03

/********************************************************************************/
/*              DIRECT REGISTER - CURSOR CONTROL                                */
/********************************************************************************/
//  ** TVP3026_CUR_CTL
//      Default - 0x00
#define TVP3026_CURSOR_OFF                      0x00    // Cursor off
#define TVP3026_CURSOR_COLOR                    0x01    // 2-bits select color
#define TVP3026_CURSOR_XGA                      0x02    // 2-bits select XOR
#define TVP3026_CURSOR_XWIN                     0x03    // 2-bits select transparency/color


/********************************************************************************/
/*              DIRECT REGISTER - CURSOR POSITION CONTROL                       */
/********************************************************************************/
//  ** TVP3026_CUR_X_LSB 
//  ** TVP3026_CUR_X_MSB 
//  ** TVP3026_CUR_Y_LSB 
//  ** TVP3026_CUR_Y_MSB 
//      Default - undefined
// Values written into those registers represent the BOTTOM-RIGHT corner
// of the cursor. If 0 is in X or Y position - the cursor is off the screen
// Only 12 bits are used, giving the range from 0 to 4095 ( 0x0000 - 0x0FFF)
// The size of the cursor is (64,64) (0x40, 0x40)
#define TVP3026_CURSOR_OFFSCREEN                0x00    // Cursor offscreen


// ------------------------Indirect indexed registers map--------------------------
/********************************************************************************/
/*              INDIRECT REGISTER - SILICON REVISION                            */
/********************************************************************************/
#define __TVP3026_SILICON_REVISION              0x01    // Chip revision: 
                                                        //  bits 4-7 - major number, 0-3 - minor number
// TVP3026_REVISION_LEVEL
#define TVP3026_REVISION_LEVEL                  0x01    // predefined

// TVP3030_REVISION_LEVEL
#define TVP3030_REVISION_LEVEL                  0x00    // predefined

/********************************************************************************/
/*              INDIRECT REGISTER - CHIP ID                                     */
/********************************************************************************/
#define __TVP3026_CHIP_ID                   0x3F    //  
//      Default - 0x26

#define TVP3026_ID_CODE                     0x26    // predefined
#define TVP3030_ID_CODE                     0x30    // predefined

/********************************************************************************/
/*              INDIRECT REGISTER - CURSOR CONTROL                              */
/********************************************************************************/
#define __TVP3026_CURSOR_CONTROL                    0x06    // Indirect cursor control - 
//      Default - 0x00
#define TVP3026_CURSOR_USE_DIRECT_CCR           (1 << 7)// Enable Direct Cursor Control Register
#define TVP3026_CURSOR_USE_INDEX_CCR            (0 << 7)// Disable Direct Cursor Control Register

#define TVP3026_CURSOR_INTERLACE_ODD            (1 << 6)// Detect odd field as 1
#define TVP3026_CURSOR_INTERLACE_EVEN           (0 << 6)// Detect even field as 1

#define TVP3026_CURSOR_INTERLACE_ON             (1 << 5)// Enable interlaced cursor
#define TVP3026_CURSOR_INTERLACE_OFF            (0 << 5)// Disable interlaced cursor

#define TVP3026_CURSOR_VBLANK_4096              (1 << 4)// Blank is detected after 4096
#define TVP3026_CURSOR_VBLANK_2048              (0 << 4)//      or 2048 dot clocks

#define TVP3026_CURSOR_RAM_ADDRESS(x)            (((x) & 0x03) << 2)// High bits of cursor RAM address
#define TVP3026_CURSOR_RAM_MASK                 ((0x03) << 2)       // Mask for high bits of cursor RAM address
// CURSOR_OFF                           0x00    // Cursor off
// CURSOR_COLOR                         0x01    // 2-bits select color
// CURSOR_XGA                           0x02    // 2-bits select XOR
// CURSOR_XWIN                          0x03    // 2-bits select transparency/color



/********************************************************************************/
/*              INDIRECT REGISTER - LATCH CONTROL                               */
/********************************************************************************/
#define __TVP3026_LATCH_CONTROL                 0x0F    //  Latch control register - 
//      Default - 0x06
#define TVP3026_LATCH_ALL_MODES                 0x06    // All modes except packed-24
#define TVP3026_LATCH_4_3                       0x07    // 4:3 or 8:3 packed-24 
#define TVP3026_LATCH_5_2                       0x20    // 5:2  packed-24 
#define TVP3026_LATCH_5_4_1                     0x1F    // 5:4  packed-24 x1 horz zoom
#define TVP3026_LATCH_5_4_2                     0x1E    // 5:4  packed-24 x2 horz zoom
#define TVP3026_LATCH_5_4_4                     0x1C    // 5:4  packed-24 x4 horz zoom
#define TVP3026_LATCH_5_4_8                     0x18    // 5:4  packed-24 x8 horz zoom


/********************************************************************************/
/*              INDIRECT REGISTER - TRUE COLOR CONTROL                          */
/********************************************************************************/
#define __TVP3026_TRUE_COLOR                    0x18    //  True Color control
//      Default - 0x80

/********************************************************************************/
/*              INDIRECT REGISTER - MULTIPLEX CONTROL                           */
/********************************************************************************/
#define __TVP3026_MULTIPLEX_CONTROL             0x19    //  Multiplex control
//      Default - 0x98

/********************************************************************************/
/*              INDIRECT REGISTER - CLOCK SELECTION                             */
/********************************************************************************/
#define __TVP3026_CLOCK                         0x1A    //  
//      Default - 0x07
#define TVP3026_SCLK_ENABLE                     (1 << 7)// Enable SCLK output
#define TVP3026_SCLK_DISABLE                    (0 << 7)// Disable SCLK output
#define TVP3026_VCLK_ZERO                       (7 << 4)// VCLK forced to Logical "0"
#define TVP3026_VCLK_DOTCLOCK                   (0 << 4)// VCLK is equal to Dot clock
#define TVP3026_VCLK_DOTCLOCK_DIV2              (1 << 4)// VCLK is equal to Dot clock/2
#define TVP3026_VCLK_DOTCLOCK_DIV4              (2 << 4)// VCLK is equal to Dot clock/4
#define TVP3026_VCLK_DOTCLOCK_DIV8              (3 << 4)// VCLK is equal to Dot clock/8
#define TVP3026_VCLK_DOTCLOCK_DIV16             (4 << 4)// VCLK is equal to Dot clock/16
#define TVP3026_VCLK_DOTCLOCK_DIV32             (5 << 4)// VCLK is equal to Dot clock/32
#define TVP3026_VCLK_DOTCLOCK_DIV64             (6 << 4)// VCLK is equal to Dot clock/64

#define TVP3026_CLK_CLK0                        (0 << 0)// Select CLK0 as clock source
#define TVP3026_CLK_CLK1                        (1 << 0)// Select CLK1 as clock source
#define TVP3026_CLK_CLK2_TTL                    (2 << 0)// Select CLK2 as clock source
#define TVP3026_CLK_CLK2N_TTL                   (3 << 0)// Select /CLK2 as clock source
#define TVP3026_CLK_CLK2_ECL                    (4 << 0)// Select CLK2 and /CLK2 as ECL clock source
#define TVP3026_CLK_PIXEL_PLL                   (5 << 0)// Select Pixel Clock PLL as clock source
#define TVP3026_CLK_DISABLE                     (6 << 0)// Disable clock source / Power-save mode
#define TVP3026_CLK_CLK0_VGA                    (7 << 0)// Select CLK0 as clock source with VGA latching

/********************************************************************************/
/*              INDIRECT REGISTER - PALETTE PAGE                                */
/********************************************************************************/
#define __TVP3026_PALETTE_PAGE                  0x1C    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - GENERAL CONTROL                             */
/********************************************************************************/
#define __TVP3026_GENERAL_CONTROL               0x1D    //  
//      Default - 0x00
#define TVP3026_OVERSCAN_ENABLE                 (1 << 6)// Enable overscan coloring
#define TVP3026_OVERSCAN_DISABLE                (0 << 6)// Disable overscan coloring
#define TVP3026_SYNC_ENABLE                     (1 << 5)// Enable SYNC signal on IOG
#define TVP3026_SYNC_DISABLE                    (0 << 5)// Disable SYNC signal on IOG
#define TVP3026_PEDESTAL_ON                     (1 << 4)// Enable 7.5 IRE blanking pedestal 
#define TVP3026_PEDESTAL_OFF                    (0 << 4)// Disable blanking pedestal
#define TVP3026_BIG_ENDIAN                      (1 << 3)// Big Endian format on pixel bus
#define TVP3026_LITTLE_ENDIAN                   (0 << 3)// Little Endian format on pixel bus
#define TVP3026_VSYNC_INVERT                    (1 << 1)// Invert VSYNC signal on VSYNCOUT
#define TVP3026_VSYNC_NORMAL                    (0 << 1)// Do not invert VSYNC signal on VSYNCOUT
#define TVP3026_HSYNC_INVERT                    (1 << 0)// Invert HSYNC signal on HSYNCOUT
#define TVP3026_HSYNC_NORMAL                    (0 << 0)// Do not invert HSYNC signal on HSYNCOUT

/********************************************************************************/
/*              INDIRECT REGISTER - MISC CONTROL                                */
/********************************************************************************/
#define __TVP3026_MISC_CONTROL                  0x1E    //  
//      Default - 0x00
#define TVP3026_PSEL_INVERT                     (1 << 5)// PSEL == 1 - Pseudo/True Color
#define TVP3026_PSEL_NORMAL                     (0 << 5)// PSEL == 1 - Direct Color
#define TVP3026_PSEL_ENABLE                     (1 << 4)// PSEL controls Color Switching
#define TVP3026_PSEL_DISABLE                    (0 << 4)// PSEL is disabled
#define TVP3026_DAC_8BIT                        (1 << 3)// DAC is in 8-bit mode
#define TVP3026_DAC_6BIT                        (0 << 3)// DAC is in 6-bit mode
#define TVP3026_DAC_6BITPIN_DISABLE             (1 << 2)// Disable 6/8 pin and use bit 3 of this register
#define TVP3026_DAC_6BITPIN_ENABLE              (0 << 2)// Use 6/8 pin and ignore bit 3 of this register
#define TVP3026_DAC_POWER_ON                    (0 << 0)// Turn DAC Power on 
#define TVP3026_DAC_POWER_OFF                   (1 << 0)// Turn DAC Power off 

/********************************************************************************/
/*              INDIRECT REGISTER - GP I/O CONTROL                              */
/********************************************************************************/
#define __TVP3026_GP_CONTROL                0x2A    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - GP I/O DATA                                 */
/********************************************************************************/
#define __TVP3026_GP_DATA                   0x2B    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - PLL ADDRESS                                 */
/********************************************************************************/
#define __TVP3026_PLL_ADDRESS               0x2C    //  
//      Default - undefined
#define TVP3026_PIXEL_CLOCK_START           0xFC// Start Pixel Clock Programming
#define TVP3026_MCLK_START                  0xF3// Start MCLK Programming
#define TVP3026_LOOP_CLOCK_START            0xCF// Start Loop Clock Programming

/********************************************************************************/
/*              INDIRECT REGISTER - PLL PIXEL DATA                              */
/********************************************************************************/
#define __TVP3026_PLL_PIX_DATA              0x2D    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - PLL MEMORY DATA                             */
/********************************************************************************/
#define __TVP3026_PLL_MEM_DATA              0x2E    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - PLL LOOP DATA                               */
/********************************************************************************/
#define __TVP3026_PLL_LOOP_DATA             0x2F    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY OVERLAY LOW                       */
/********************************************************************************/
#define __TVP3026_CCOVR_LOW                 0x30    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY OVERLAY HIGH                      */
/********************************************************************************/
#define __TVP3026_CCOVR_HIGH                0x31    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED LOW                           */
/********************************************************************************/
#define __TVP3026_CCRED_LOW                 0x32    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED HIGH                          */
/********************************************************************************/
#define __TVP3026_CCRED_HIGH                0x33    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY GREEN LOW                         */
/********************************************************************************/
#define __TVP3026_CCGREEN_LOW               0x34    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED HIGH                          */
/********************************************************************************/
#define __TVP3026_CCGREEN_HIGH              0x35    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY BLUE LOW                          */
/********************************************************************************/
#define __TVP3026_CCBLUE_LOW                0x36    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY BLUE HIGH                         */
/********************************************************************************/
#define __TVP3026_CCBLUE_HIGH               0x37    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY CONTROL                           */
/********************************************************************************/
#define __TVP3026_CC_CONTROL                0x38    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - MCLK/LOOP CONTROL                           */
/********************************************************************************/
#define __TVP3026_MCLK_CONTROL              0x39    //  
//      Default - 0x18
#define TVP3026_RCLK_LOOP                       (1 << 5)// RCLK is made from LCLK - all other modes
#define TVP3026_RCLK_PIXEL                      (0 << 5)// RCLK is clocked by Pixel Clock (VGA Mode)
#define TVP3026_MCLK_PLL                        (1 << 4)// MCLK from PLL - normal mode
#define TVP3026_MCLK_DOT                        (0 << 4)// MCLK from dot clock - during freq. change
#define TVP3026_MCLK_STROBE_HIGH                (1 << 3)// Strobe high for bit 4
#define TVP3026_MCLK_STROBE_LOW                 (0 << 3)// Strobe low for bit 4
#define TVP3026_LOOP_DIVIDE2                    (0 << 0)// Divide Loop clock by 2
#define TVP3026_LOOP_DIVIDE4                    (1 << 0)// Divide Loop clock by 4
#define TVP3026_LOOP_DIVIDE6                    (2 << 0)// Divide Loop clock by 6
#define TVP3026_LOOP_DIVIDE8                    (3 << 0)// Divide Loop clock by 8
#define TVP3026_LOOP_DIVIDE10                   (4 << 0)// Divide Loop clock by 10
#define TVP3026_LOOP_DIVIDE12                   (5 << 0)// Divide Loop clock by 12
#define TVP3026_LOOP_DIVIDE14                   (6 << 0)// Divide Loop clock by 14
#define TVP3026_LOOP_DIVIDE16                   (7 << 0)// Divide Loop clock by 16

/********************************************************************************/
/*              INDIRECT REGISTER - SENSE TEST                                  */
/********************************************************************************/
#define __TVP3026_SENSE_TEST                0x3A    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - TEST MODE DATA                                  */
/********************************************************************************/
#define __TVP3026_TEST_MODE                 0x3B    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - CRC REMAINDER LSB                           */
/********************************************************************************/
#define __TVP3026_CRC_LSB                   0x3C    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - CRC REMAINDER MSB                           */
/********************************************************************************/
#define __TVP3026_CRC_MSB                   0x3D    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - CRC BITS SELECT                             */
/********************************************************************************/
#define __TVP3026_CRC_SELECT                0x3E    //  
//      Default - undefined

/********************************************************************************/
/*              INDIRECT REGISTER - SOFTWARE RESET                                      */
/********************************************************************************/
#define __TVP3026_SOFT_RESET                0xFF    //  
//      Default - undefined




//
// On rev 1 chips we need to SYNC with GLINT while accessing the RAMDAC. This
// is because accesses to the RAMDAC can be corrupted by localbuffer
// activity. Put this macro before accesses that can co-exist with GLINT
// 3D activity, Must have initialized glintInfo before using this.
//
#define TVP3026_SYNC_WITH_GLINT \
{ \
    if (GLInfo.wRenderChipRev == GLINT300SX_REV1) \
        SYNC_WITH_GLINT; \
}




/*
// We never need a delay between each write to the 3026. The only way to guarantee
// that the write has completed used to be to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
//#define TVP3026_DELAY \
//{ \
//    volatile LONG __junk; \
//    __junk = pDev->pRegisters->Glint.FBModeSel; \
//}
//#else
*/
#define TVP3026_DELAY

// macro to load a given data value into an internal TVP3026 register.
//
#define TVP3026_WRITE_CURRENT_INDEX TVP3026_SET_INDEX_REG
#define TVP3026_SET_INDEX_REG(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_INDEX_ADDR, (ULONG)((index) & 0xff)); \
    TVP3026_DELAY; \
}

#define TVP3026_READ_CURRENT_INDEX(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP3026_INDEX_ADDR) & 0xff; \
    TVP3026_DELAY; \
}

#define TVP3026_WRITE_INDEX_REG(index, data) \
{ \
    TVP3026_SET_INDEX_REG(index);                            \
    ADbgpf(("*(0x%X) <-- 0x%X\n", __TVP3026_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(__TVP3026_INDEX_DATA, (ULONG)((data) & 0xff)); \
    TVP3026_DELAY; \
}

#define TVP3026_READ_INDEX_REG(index, data) \
{ \
    TVP3026_SET_INDEX_REG(index); \
    data = VideoPortReadRegisterUlong(__TVP3026_INDEX_DATA) & 0xff;   \
    TVP3026_DELAY; \
    ADbgpf(("0x%X <-- *(0x%X)\n", data, __TVP3026_INDEX_DATA)); \
}


// macros to write a given RGB triplet into cursors 0, 1 and 2
#define TVP3026_SET_CURSOR_COLOR0(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_WR_ADDR,   (ULONG)(TVP3026_CURSOR_COLOR0));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(red));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(green));  \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(blue));   \
    TVP3026_DELAY; \
}

#define TVP3026_SET_CURSOR_COLOR1(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_WR_ADDR,   (ULONG)(TVP3026_CURSOR_COLOR1));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(red));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(green));  \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(blue));   \
    TVP3026_DELAY; \
}

#define TVP3026_SET_CURSOR_COLOR2(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_WR_ADDR,   (ULONG)(TVP3026_CURSOR_COLOR2));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(red));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(green));  \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_DATA,    (ULONG)(blue));   \
    TVP3026_DELAY; \
}

#define TVP3026_SET_OVERSCAN_COLOR(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_OVRC_WR_ADDR,   (ULONG)(TVP3026_OVERSCAN_COLOR));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_OVRC_DATA,    (ULONG)(red));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_OVRC_DATA,    (ULONG)(green));  \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_OVRC_DATA,    (ULONG)(blue));   \
    TVP3026_DELAY; \
}



// macros to load a given RGB triple into the TVP3026 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use TVP3026_PALETTE_START and multiple TVP3026_LOAD_PALETTE calls to load
// a contiguous set of entries. Use TVP3026_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define TVP3026_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_WR_ADDR,     (ULONG)(index));    \
    TVP3026_DELAY; \
}

#define TVP3026_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_RD_ADDR,     (ULONG)(index));    \
    TVP3026_DELAY; \
}

#define TVP3026_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(red));      \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(green));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(blue));     \
    TVP3026_DELAY; \
}

#define TVP3026_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_WR_ADDR, (ULONG)(index));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(red));      \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(green));    \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_PAL_DATA,    (ULONG)(blue));     \
    TVP3026_DELAY; \
}

// macro to read back a given RGB triple from the TVP3026 palette. Use after
// a call to TVP3026_PALETTE_START_RD
//
#define TVP3026_READ_PALETTE(red, green, blue) \
{ \
    red   = VideoPortReadRegisterUlong(__TVP3026_PAL_DATA) & 0xff;        \
    TVP3026_DELAY; \
    green = VideoPortReadRegisterUlong(__TVP3026_PAL_DATA) & 0xff;        \
    TVP3026_DELAY; \
    blue  = VideoPortReadRegisterUlong(__TVP3026_PAL_DATA) & 0xff;        \
    TVP3026_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define TVP3026_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_PIXEL_MASK,  (ULONG)(mask)); \
    TVP3026_DELAY; \
}

#define TVP3026_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(__TVP3026_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array
//
#define TVP3026_CURSOR_ARRAY_START(offset) \
{ \
    volatile LONG   __temp;                                     \
    TVP3026_READ_INDEX_REG(__TVP3026_CURSOR_CONTROL, __temp);   \
    __temp &= ~TVP3026_CURSOR_RAM_MASK ;                        \
    __temp |= TVP3026_CURSOR_RAM_ADDRESS((offset)>> 8) ;        \
    TVP3026_WRITE_INDEX_REG(__TVP3026_CURSOR_CONTROL, __temp);  \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_RAM_WR_ADDR,   (ULONG)((offset)& 0xff));   \
    TVP3026_DELAY; \
}

#define TVP3026_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_RAM_DATA, (ULONG)(data)); \
    TVP3026_DELAY; \
}

#define TVP3026_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP3026_CUR_RAM_DATA) & 0xff; \
    TVP3026_DELAY; \
}

#define TVP3026_LOAD_CURSOR_CTRL(data) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_CTL, (ULONG)(data)); \
    TVP3026_DELAY; \
}

// macro to move the cursor
//
#define TVP3026_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_X_LSB,     (ULONG)((x) & 0xff));   \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_X_MSB,     (ULONG)((x) >> 8));     \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_Y_LSB,      (ULONG)((y) & 0xff));   \
    TVP3026_DELAY; \
    VideoPortWriteRegisterUlong(__TVP3026_CUR_Y_MSB,        (ULONG)((y) >> 8));     \
    TVP3026_DELAY; \
}

// macro to change the cursor hotspot
//
#define TVP3026_CURSOR_HOTSPOT(x, y) \
{ \
    TVP3026_DELAY; \
}
    
#define TVP3026_IS_FOUND(bFound)        \
{\
    volatile LONG   __revLevel;        \
    volatile LONG   __productID;    \
    volatile LONG   __oldValue;     \
    __oldValue = VideoPortReadRegisterUlong(__TVP3026_INDEX_ADDR);\
    TVP3026_DELAY; \
    TVP3026_READ_INDEX_REG (__TVP3026_SILICON_REVISION, __revLevel);\
    TVP3026_READ_INDEX_REG (__TVP3026_CHIP_ID,              __productID);    \
    bFound = (    (__revLevel >= TVP3026_REVISION_LEVEL) &&              \
                (__productID == TVP3026_ID_CODE)) ? TRUE : FALSE ;    \
    VideoPortWriteRegisterUlong(__TVP3026_INDEX_ADDR, __oldValue );    \
    TVP3026_DELAY; \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\inc\tvp4020.h ===
/******************************Module*Header*******************************\
*
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* !!                                                                         !!
* !!                     WARNING: NOT DDK SAMPLE CODE                        !!
* !!                                                                         !!
* !! This source code is provided for completeness only and should not be    !!
* !! used as sample code for display driver development.  Only those sources !!
* !! marked as sample code for a given driver component should be used for   !!
* !! development purposes.                                                   !!
* !!                                                                         !!
* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
*
* Module Name: tvp4020.h
*
* Content:  This module contains the definitions for the P2 internal RAMDAC.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define ADbgpf VideoDebugPrint

//
// TI TVP4020 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _tvp4020_regs {
    RAMDAC_REG  pciAddrWr;      // 0x00 - palette/cursor RAM write address, Index Register
    RAMDAC_REG  palData;        // 0x01 - palette RAM data
    RAMDAC_REG  pixelMask;      // 0x02 - pixel read mask
    RAMDAC_REG  pciAddrRd;         // 0x03 - palette/cursor RAM read address
    
    RAMDAC_REG  curColAddr;     // 0x04 - cursor color address
    RAMDAC_REG  curColData;       // 0x05 - cursor color data
    RAMDAC_REG  Reserved1;      // 0x06 - reserved
    RAMDAC_REG  Reserved2;      // 0x07 - reserved

    RAMDAC_REG  Reserved3;      // 0x08 - reserved
    RAMDAC_REG  Reserved4;         // 0x09 - reserved
    RAMDAC_REG  indexData;      // 0x0A - indexed data
    RAMDAC_REG  curRAMData;     // 0x0B - cursor RAM data
    
    RAMDAC_REG  cursorXLow;     // 0x0C - cursor position X low byte 
    RAMDAC_REG  cursorXHigh;    // 0x0D - cursor position X high byte 
    RAMDAC_REG  cursorYLow;     // 0x0E - cursor position Y low byte 
    RAMDAC_REG  cursorYHigh;    // 0x0F - cursor position Y high byte 
} TVP4020RAMDAC, *pTVP4020RAMDAC;

// macro declared by any function wishing to use the P2 internal RAMDAC . MUST be declared
// after GLINT_DECL.
//
#if MINIVDD
#define TVP4020_DECL \
    pTVP4020RAMDAC   pTVP4020Regs = (pTVP4020RAMDAC)&(pDev->pRegisters->Glint.ExtVCReg)
#else
#define TVP4020_DECL \
    pTVP4020RAMDAC   pTVP4020Regs = (pTVP4020RAMDAC)&(pRegisters->Glint.ExtVCReg)
#endif

// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
//  Palette Access
#define __TVP4020_PAL_WR_ADDR                 ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_PAL_RD_ADDR                 ((PULONG)&(pTVP4020Regs->pciAddrRd.reg))
#define __TVP4020_PAL_DATA                    ((PULONG)&(pTVP4020Regs->palData.reg))

// Pixel mask
#define __TVP4020_PIXEL_MASK                ((PULONG)&(pTVP4020Regs->pixelMask.reg))

// Access to the indexed registers
#define __TVP4020_INDEX_ADDR                ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_INDEX_DATA                  ((PULONG)&(pTVP4020Regs->indexData.reg))

// Access to the Cursor
#define __TVP4020_CUR_RAM_WR_ADDR            ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_CUR_RAM_RD_ADDR             ((PULONG)&(pTVP4020Regs->palAddrRd.reg))
#define __TVP4020_CUR_RAM_DATA                ((PULONG)&(pTVP4020Regs->curRAMData.reg))

#define __TVP4020_CUR_COL_ADDR                ((PULONG)&(pTVP4020Regs->curColAddr.reg))
#define __TVP4020_CUR_COL_DATA                 ((PULONG)&(pTVP4020Regs->curColData.reg))

// Cursor position control
#define __TVP4020_CUR_X_LSB                    ((PULONG)&(pTVP4020Regs->cursorXLow.reg))
#define __TVP4020_CUR_X_MSB                 ((PULONG)&(pTVP4020Regs->cursorXHigh.reg))
#define __TVP4020_CUR_Y_LSB                    ((PULONG)&(pTVP4020Regs->cursorYLow.reg))
#define __TVP4020_CUR_Y_MSB                     ((PULONG)&(pTVP4020Regs->cursorYHigh.reg))



// ----------------------Values for some direct registers-----------------------

/********************************************************************************/
/*              DIRECT REGISTER - CURSOR POSITION CONTROL                       */
/********************************************************************************/
//  ** TVP4020_CUR_X_LSB 
//  ** TVP4020_CUR_X_MSB 
//  ** TVP4020_CUR_Y_LSB 
//  ** TVP4020_CUR_Y_MSB 
//      Default - undefined
// Values written into those registers represent the BOTTOM-RIGHT corner
// of the cursor. If 0 is in X or Y position - the cursor is off the screen
// Only 12 bits are used, giving the range from 0 to 4095 ( 0x0000 - 0x0FFF)
// The size of the cursor is (64,64) (0x40, 0x40)
#define TVP4020_CURSOR_OFFSCREEN                0x00    // Cursor offscreen

/********************************************************************************/
/*              DIRECT REGISTER - CURSOR COLORS                                 */
/********************************************************************************/

#define TVP4020_CURSOR_COLOR0                   0x01
#define TVP4020_CURSOR_COLOR1                   0x02
#define TVP4020_CURSOR_COLOR2                   0x03

// ------------------------Indirect indexed registers map--------------------------

/********************************************************************************/
/*              INDIRECT REGISTER - CURSOR CONTROL                              */
/********************************************************************************/
#define __TVP4020_CURSOR_CONTROL                0x06    // Indirect cursor control - 
//      Default - 0x00

#define TVP4020_CURSOR_SIZE_32                  (0 << 6)// 32x32 cursor
#define TVP4020_CURSOR_SIZE_64                  (1 << 6)// 32x32 cursor

#define TVP4020_CURSOR_32_SEL(i)                   ((i) << 4)// one of 4 32x32 cursors  DABO: changed to << 4

#define TVP4020_CURSOR_RAM_ADDRESS(x)            (((x) & 0x03) << 2)// High bits of cursor RAM address
#define TVP4020_CURSOR_RAM_MASK                 ((0x03) << 2)       // Mask for high bits of cursor RAM address

// DABO: Added constants for cursor mode
#define TVP4020_CURSOR_OFF                      0x00    // Cursor off
#define TVP4020_CURSOR_COLOR                    0x01    // 2-bits select color
#define TVP4020_CURSOR_XGA                      0x02    // 2-bits select XOR
#define TVP4020_CURSOR_XWIN                     0x03    // 2-bits select transparency/color



/********************************************************************************/
/*              INDIRECT REGISTER - COLOR MODE REGISTER                         */
/********************************************************************************/
#define __TVP4020_COLOR_MODE                    0x18    //  Color Mode Register
//      Default - 0x00

#define TVP4020_TRUE_COLOR_ENABLE               (1 << 7)// True Color data accesses LUT
#define TVP4020_TRUE_COLOR_DISABLE              (0 << 7)// Non true color accesses LUT

#define TVP4020_RGB_MODE                        (1 << 5)// RGB mode  DABO: Swapped 0/1 (0=BGR, 1=RGB)
#define TVP4020_BGR_MODE                        (0 << 5)// BGR mode

#define TVP4020_VGA_SELECT                      (0 << 4)// select VGA mode
#define TVP4020_GRAPHICS_SELECT                 (1 << 4)// select graphics modes

#define TVP4020_PIXEL_MODE_CI8                  (0 << 0)// pseudo color or VGA mode
#define TVP4020_PIXEL_MODE_332                  (1 << 0)// 332 true color
#define TVP4020_PIXEL_MODE_2320                 (2 << 0)// 232 off
#define TVP4020_PIXEL_MODE_2321                 (3 << 0)//
#define TVP4020_PIXEL_MODE_5551                 (4 << 0)// 
#define TVP4020_PIXEL_MODE_4444                 (5 << 0)// 
#define TVP4020_PIXEL_MODE_565                  (6 << 0)// 
#define TVP4020_PIXEL_MODE_8888                 (8 << 0)// 
#define TVP4020_PIXEL_MODE_PACKED               (9 << 0)// 24 bit packed

/********************************************************************************/
/*              INDIRECT REGISTER - MODE CONTROL REGISTER                       */
/********************************************************************************/
#define __TVP4020_MODE_CONTROL                  0x19    //  Mode control
//      Default - 0x00

#define TVP4020_PRIMARY_INPUT                   (0 << 4)// Primary input throuh palette
#define TVP4020_SECONDARY_INPUT                 (1 << 4)// Secondary input throuh palette

#define TVP4020_5551_DBL_BUFFER                 (1 << 2)// Enable 5551 dbl buffer
#define TVP4020_5551_PACKED                     (0 << 2)// Packed 555 mode

#define TVP4020_ENABLE_STATIC_DBL_BUFFER        (1 << 1)// Static dbl buffer enabled
#define TVP4020_DISABLE_STATIC_DBL_BUFFER       (1 << 1)// Static dbl buffer disabled

#define TVP4020_SELECT_FRONT_MODE               (0 << 0)// Front mode
#define TVP4020_SELECT_BACK_MODE                (1 << 0)// Back mode

/********************************************************************************/
/*              INDIRECT REGISTER - PALETTE PAGE                                */
/********************************************************************************/
#define __TVP4020_PALETTE_PAGE                  0x1C    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - MISC CONTROL                                */
/********************************************************************************/
#define __TVP4020_MISC_CONTROL                  0x1E    //  
//      Default - 0x00
#define TVP4020_SYNC_ENABLE                     (1 << 5)// Output SYNC info onto IOG
#define TVP4020_SYNC_DISABLE                    (0 << 5)// No SYNC IOG output

#define TVP4020_PEDESTAL_0                      (0 << 4)// 0 IRE blanking pedestal
#define TVP4020_PEDESTAL_75                     (1 << 4)// 7.5 IRE blanking pedestal

#define TVP4020_VSYNC_INVERT                    (1 << 3)// invert VSYNC output polarity
#define TVP4020_VSYNC_NORMAL                    (0 << 3)// normal VSYNC output polarity

#define TVP4020_HSYNC_INVERT                    (1 << 2)// invert HSYNC output polarity
#define TVP4020_HSYNC_NORMAL                    (0 << 3)// normal HSYNC output polarity

#define TVP4020_DAC_8BIT                        (1 << 1)// DAC is in 8-bit mode
#define TVP4020_DAC_6BIT                        (0 << 1)// DAC is in 6-bit mode

#define TVP4020_DAC_POWER_ON                    (0 << 0)// Turn DAC Power on 
#define TVP4020_DAC_POWER_OFF                   (1 << 0)// Turn DAC Power off 

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY CONTROL                           */
/********************************************************************************/
#define __TVP4020_CK_CONTROL                0x40    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY OVERLAY                           */
/********************************************************************************/
#define __TVP4020_CK_OVR_REG                0x41    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED                               */
/********************************************************************************/
#define __TVP4020_CK_RED_REG                0x42    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY GREEN                             */
/********************************************************************************/
#define __TVP4020_CK_GREEN_REG              0x43    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY BLUE                              */
/********************************************************************************/
#define __TVP4020_CK_BLUE_REG               0x44    //  
//      Default - 0x00

/********************************************************************************/
/*              INDIRECT REGISTER - PIXEL CLOCK PLL                            */
/********************************************************************************/

#define __TVP4020_PIXCLK_REG_A1             0x20
#define __TVP4020_PIXCLK_REG_A2             0x21
#define __TVP4020_PIXCLK_REG_A3             0x22
#define __TVP4020_PIXCLK_REG_B1             0x23
#define __TVP4020_PIXCLK_REG_B2             0x24
#define __TVP4020_PIXCLK_REG_B3             0x25
#define __TVP4020_PIXCLK_REG_C1             0x26
#define __TVP4020_PIXCLK_REG_C2             0x27
#define __TVP4020_PIXCLK_REG_C3             0x28

#define __TVP4020_PIXCLK_STATUS             0x29

/********************************************************************************/
/*              INDIRECT REGISTER - MEMORU CLOCK PLL                            */
/********************************************************************************/

#define __TVP4020_MEMCLK_REG_1              0x30
#define __TVP4020_MEMCLK_REG_2              0x31
#define __TVP4020_MEMCLK_REG_3              0x32

#define __TVP4020_MEMCLK_STATUS             0x33



#if 0
// need a delay between each write to the 4020. The only way to guarantee
// that the write has completed is to read from a GLINT control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
#define TVP4020_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}
#else
#define TVP4020_DELAY
#endif

// macro to load a given data value into an internal TVP4020 register.
//
#define TVP4020_WRITE_CURRENT_INDEX TVP4020_SET_INDEX_REG
#define TVP4020_SET_INDEX_REG(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_INDEX_ADDR, (ULONG)((index) & 0xff)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_CURRENT_INDEX(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP4020_INDEX_ADDR) & 0xff; \
    TVP4020_DELAY; \
}

#define TVP4020_WRITE_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index);                            \
    ADbgpf(("*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(__TVP4020_INDEX_DATA, (ULONG)((data) & 0xff)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index); \
    data = VideoPortReadRegisterUlong(__TVP4020_INDEX_DATA) & 0xff;   \
    TVP4020_DELAY; \
    ADbgpf(("0x%X <-- *(0x%X)\n", data, __TVP4020_INDEX_DATA)); \
}

// DABO: For compatibility with TVP3026
#define TVP4020_LOAD_CURSOR_CTRL(data) \
{ \
    volatile LONG   __temp;                                    \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    __temp &= ~(0x03) ;                                        \
    __temp |= ((data) & 0x03) ;                                \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp); \
}

// macros to write a given RGB triplet into cursors 0, 1 and 2
#define TVP4020_SET_CURSOR_COLOR0(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR0));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
    TVP4020_DELAY; \
}

#define TVP4020_SET_CURSOR_COLOR1(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR1));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
    TVP4020_DELAY; \
}

#define TVP4020_SET_CURSOR_COLOR2(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR2));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
    TVP4020_DELAY; \
}



// macros to load a given RGB triple into the TVP4020 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use TVP4020_PALETTE_START and multiple TVP4020_LOAD_PALETTE calls to load
// a contiguous set of entries. Use TVP4020_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define TVP4020_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_WR_ADDR,     (ULONG)(index));    \
    TVP4020_DELAY; \
}

#define TVP4020_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_RD_ADDR,     (ULONG)(index));    \
    TVP4020_DELAY; \
}

#define TVP4020_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
    TVP4020_DELAY; \
}

#define TVP4020_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_WR_ADDR, (ULONG)(index));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
    TVP4020_DELAY; \
}

// macro to read back a given RGB triple from the TVP4020 palette. Use after
// a call to TVP4020_PALETTE_START_RD
//
#define TVP4020_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
}

// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define TVP4020_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PIXEL_MASK,  (ULONG)(mask)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(__TVP4020_PIXEL_MASK) & 0xff; \
}

// macros to load values into the cursor array
//
#define TVP4020_CURSOR_ARRAY_START(offset) \
{ \
    volatile LONG   __temp;                                     \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);   \
    __temp &= ~TVP4020_CURSOR_RAM_MASK ;                        \
    __temp |= TVP4020_CURSOR_RAM_ADDRESS((offset)>> 8) ;        \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_RAM_WR_ADDR,   (ULONG)((offset)& 0xff));   \
    TVP4020_DELAY; \
}
// DABO: Need a similar macro to set the read address for cursor RAM?

#define TVP4020_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_RAM_DATA, (ULONG)(data)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP4020_CUR_RAM_DATA) & 0xff; \
    TVP4020_DELAY; \
}

// macro to move the cursor
//
#define TVP4020_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_X_LSB,     (ULONG)((x) & 0xff));   \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_X_MSB,     (ULONG)((x) >> 8));     \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_Y_LSB,      (ULONG)((y) & 0xff));   \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_Y_MSB,        (ULONG)((y) >> 8));     \
    TVP4020_DELAY; \
}

// macro to change the cursor hotspot
//
#define TVP4020_CURSOR_HOTSPOT(x, y) \
{ \
    TVP4020_DELAY; \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\interupt.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   interupt.c
*
* Abstract:
*
*    This module contains code to control interrupts for Permedia 3. 
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

#pragma alloc_text(PAGE,Perm3InitializeInterruptBlock)

BOOLEAN
Perm3VideoInterrupt(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Permedia3 interrupt service routine. 

    THIS ROUTINE CANNOT BE PAGED

Arguments:

    HwDeviceExtension
        Supplies a pointer to the miniport's device extension.

Return Value:

    Return FALSE if it is not our interrupt. Otherwise, we'll dismiss the 
    interrupt on Permedia 3 before returning TRUE.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PINTERRUPT_CONTROL_BLOCK pBlock;
    ULONG intrFlags;
    ULONG enableFlags;
    ULONG backIndex;
    ULONG bHaveCommandBlockMutex = FALSE;
    ULONG errFlags = 0;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    pBlock = &hwDeviceExtension->InterruptControl.ControlBlock;

    if(!hwDeviceExtension->InterruptControl.bInterruptsInitialized) {
   
        //
        // This is not our interrupt since we don't generate interrupt
        // before the interrpt block got initialized
        //

        return(FALSE);
    }

    if (hwDeviceExtension->PreviousPowerState != VideoPowerOn) {

        //
        // We reach here because we are sharing IRQ with other devices
        // and another device on the chain is in D0 and functioning
        //

        return(FALSE);
    }

    //
    // Find out what caused the interrupt. We AND with the enabled interrupts
    // since the flags are set if the event occurred even though no interrupt
    // was enabled.
    //

    intrFlags = VideoPortReadRegisterUlong(INT_FLAGS);
    enableFlags = VideoPortReadRegisterUlong(INT_ENABLE);

    intrFlags &= enableFlags;

    if (intrFlags == 0) {

        return FALSE;
    }

    //
    // Clear the interrupts we detected.
    //

    VideoPortWriteRegisterUlong(INT_FLAGS, intrFlags);
    VideoPortReadRegisterUlong(INT_FLAGS);

    if((pBlock->Control & PXRX_CHECK_VFIFO_IN_VBLANK) || 
        (intrFlags & INTR_ERROR_SET)) {

        errFlags = VideoPortReadRegisterUlong(ERROR_FLAGS);

        //
        // Keep a record of the errors. It will help us to debug
        // hardware issues
        //

        if (errFlags & ERROR_VFIFO_UNDERRUN) {
            hwDeviceExtension->UnderflowErrors++; 
        }

        if (errFlags & ERROR_OUT_FIFO) {
            hwDeviceExtension->OutputFifoErrors++;
        }

        if (errFlags & ERROR_IN_FIFO) {
            hwDeviceExtension->InputFifoErrors++; 
        }

        if (errFlags) {
            hwDeviceExtension->TotalErrors++;
        }

    }

    //
    // Handle VBLANK interrupt
    //

    if (intrFlags & INTR_VBLANK_SET) {
   
        //
        // Need this only on very first interrupt but it's not a big thing.
        //

        pBlock->Control |= VBLANK_INTERRUPT_AVAILABLE;

        //
        // Get General Mutex
        //

        REQUEST_INTR_CMD_BLOCK_MUTEX((&(pBlock->General)), bHaveCommandBlockMutex);

        if(bHaveCommandBlockMutex) {
       
            ULONG ulValue;

            //
            // DirectDraw needs to have it's VBLANK flag set, when it
            // sets the DIRECTDRAW_VBLANK_ENABLED bit.
            //

            if( pBlock->Control & (DIRECTDRAW_VBLANK_ENABLED | PXRX_SEND_ON_VBLANK_ENABLED | PXRX_CHECK_VFIFO_IN_VBLANK) ) {
           
                if( pBlock->Control & DIRECTDRAW_VBLANK_ENABLED ) {
	
                    pBlock->DDRAW_VBLANK = TRUE;
                }

                //
                // Don't need to do anything here. The actual processing is
                // lower down, outside of the VBlank mutex.
                //

            } else {

                //
                // Disable VBLANK interrupts. DD enables them when it needs to
                //

                VideoPortWriteRegisterUlong(INT_ENABLE, (enableFlags & ~INTR_ENABLE_VBLANK));
            }

            //
            // If DMA was suspended till VBLANK then simulate a DMA interrupt
            // to start it off again.
            //

            if (pBlock->Control & SUSPEND_DMA_TILL_VBLANK) {
           
                pBlock->Control &= ~SUSPEND_DMA_TILL_VBLANK;

                //
                // execute the DMA interrupt code
                //

                intrFlags |= INTR_ERROR_SET;  
            }

            RELEASE_INTR_CMD_BLOCK_MUTEX((&(pBlock->General)));
        }


        if( (pBlock->Control & PXRX_CHECK_VFIFO_IN_VBLANK) &&
            (--hwDeviceExtension->VideoFifoControlCountdown == 0) ) {
       
            //
            // It's time to check the error flags for an underrun (we don't
            // keep the error interrupt turned on for long because Perm3
            // generates a lot of spurious host-in DMA errors)
            //

            if(enableFlags & INTR_ERROR_SET) {
           
                //
                // Turn off the error interrupts now and rely on the periodic VBLANK check
                //

                enableFlags &= ~INTR_ERROR_SET;
                VideoPortWriteRegisterUlong(INT_ENABLE, enableFlags);
            }

            //
            // Set-up counter for our periodic check
            //

            hwDeviceExtension->VideoFifoControlCountdown = NUM_VBLANKS_BETWEEN_VFIFO_CHECKS;

            if(errFlags & ERROR_VFIFO_UNDERRUN) {
               
                if((enableFlags & INTR_ERROR_SET) == 0) {
                   
                    //
                    // We've got a video FIFO underrun error: turn on error
                    // interrupts for a little while in order to catch any
                    // other errors ASAP
                    //

                    hwDeviceExtension->VideoFifoControlCountdown = NUM_VBLANKS_AFTER_VFIFO_ERROR;

                    VideoPortWriteRegisterUlong(INT_ENABLE, 
                                                enableFlags | INTR_ERROR_SET);
                }
            }
        }
    }

    //
    // Handle underrun error
    //

    if(errFlags & ERROR_VFIFO_UNDERRUN) {
       
        ULONG highWater, lowWater;

        //
        // Clear the error
        //

        VideoPortWriteRegisterUlong(ERROR_FLAGS, ERROR_VFIFO_UNDERRUN);

        //
        // Lower the video FIFO thresholds. If the new upper threshold is 0
        // (indicating the thresholds are currently both 1) then we can't
        // go any lower, so just leave the underrun bit set (that way at
        // least we won't get any more error interrupts)
        //

        highWater = ((hwDeviceExtension->VideoFifoControl >> 8) & 0xff) - 1;

        if(highWater) {
           
            //
            // Load up the new FIFO control and clear the underrun bit.
            // The lower threshold is set to 8 if the upper threshold
            // is >= 15, otherwise it's set to 1/2 the  upper threshold
            //

            lowWater = highWater >= 15 ? 8 : ((highWater + 1) >> 1);

            hwDeviceExtension->VideoFifoControl = (1 << 16) | 
                                                  (highWater << 8) | 
                                                   lowWater; 

            do {
               
                VideoPortWriteRegisterUlong(VIDEO_FIFO_CTL, 
                                            hwDeviceExtension->VideoFifoControl);

            } while(VideoPortReadRegisterUlong(VIDEO_FIFO_CTL) & (1 << 16));

            VideoDebugPrint((3, "Perm3: Setting new Video Fifo thresholds to %d and %d\n", highWater, lowWater));
        } 
    }

    //
    // Handle outfifo error
    //

    if(errFlags & ERROR_OUT_FIFO) {

        //
        // If we got here by generating an OutputFIFO error, clear it
        //

        VideoPortWriteRegisterUlong(ERROR_FLAGS, ERROR_OUT_FIFO);

#ifdef MASK_OUTFIFO_ERROR_INTERRUPT
        enableFlags &= ~INTR_ERROR_SET;
        VideoPortWriteRegisterUlong(INT_ENABLE, enableFlags);
#endif

    }


    //
    // The error interrupt occurs each time the display driver adds an entry
    // to the queue. We treat it exactly as though we had received a DMA
    // interrupt.
    //
   
    if (intrFlags & (INTR_DMA_SET | INTR_ERROR_SET)) {

        //
        // if suspended till VBLANK we can't do any DMA.
        //

        if (pBlock->Control & SUSPEND_DMA_TILL_VBLANK) {
       
            VideoDebugPrint(( 1, "Perm3: DMA suspended till VBLANK\n"));
            return(TRUE);
        }

        //
        // If the previous DMA has not completed we can't do anything. We've
        // cleared the interrupt flag for this interrupt so even if the DMA
        // completes before we return, we'll immediately get another
        // interrupt. Since we will be getting another interrupt we do not
        // have to clear the InterruptPending flag.
        //

        if (VideoPortReadRegisterUlong(DMA_COUNT) != 0) {

            //
            // DMA in progress, leaving
            //

            return(TRUE);
        }

        //
        // We may return without starting any DMA and hence not expecting any
        // interrupt so clear the InterruptPending flag. This will force the
        // display driver to wake us. MUST DO THIS BEFORE CHECKING THE QUEUE.
        // Since the display driver adds entries and then checks the flag, we
        // must do it in the reverse order.
        //

        pBlock->InterruptPending = 0;

        //
        // if the DMA queue is empty then we have nothing to do
        //

        backIndex = pBlock->backIndex;

        if (pBlock->frontIndex == backIndex) {
       
            //
            // Queue is empty, leaving.
            //

            return(TRUE);
        }

        //
        // Since we know we'll get a DMA interrupt, we don't need a wakeup so
        // set the InterruptPending flag to true.
        //

        pBlock->InterruptPending = 1;

        //
        // kick off DMA for the next Q entry and remove it. DO NOT remove from
        // the queue first because on a multi-processor machine the display
        // driver could modify the now free queue entry before we read it.
        //
       
        VideoPortWriteRegisterUlong(DMA_ADDRESS, pBlock->dmaQueue[backIndex].address);
        VideoPortWriteRegisterUlong(DMA_COUNT,   pBlock->dmaQueue[backIndex].count);

        //
        // Keep track of where the last DMA to start was from:
        //

        pBlock->lastAddr = pBlock->dmaQueue[backIndex].address;

        //
        // now remove the entry from the queue
        //

        if (++backIndex == pBlock->endIndex)
            backIndex = 0;

        pBlock->backIndex = backIndex;
    }

    return TRUE;
}

BOOLEAN
Perm3InitializeInterruptBlock(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

Routine Description:

    Do any initialization needed for interrupts, such as allocating the shared
    memory control block.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value: 

    TRUE 

--*/

{
    PVOID HwDeviceExtension = (PVOID)hwDeviceExtension;
    PINTERRUPT_CONTROL_BLOCK pBlock;
    PVOID SavedPtr;
    PVOID pkdpc;

    //
    //  This is set to zero since it is on longer used
    //

    hwDeviceExtension->InterruptControl.PhysAddress.LowPart = 
    hwDeviceExtension->InterruptControl.PhysAddress.HighPart = 0;
   
    //
    // Set up the control block
    //
    
    pBlock = &hwDeviceExtension->InterruptControl.ControlBlock;    

    //
    // Initialize the circular DMA queue
    //

    pBlock->frontIndex = pBlock->backIndex  = 0;
    pBlock->maximumIndex = MAX_DMA_QUEUE_ENTRIES - 1;

    //
    // The size of the queue we actually use is dynamically configurable but
    // initialize it to be as small as possible. This default size will work
    // for all interrupt driven DMA buffers regardless of how many buffers
    // are actually available.
    //

    pBlock->endIndex = 2;

    //
    // Initially no interrupts are available. Later we try to enable the
    // interrupts and if they happen the interrupt handler will set the
    // available bits in this word. So it's a sort of auto-sensing mechanism.
    //

    pBlock->Control = 0;
    pBlock->InterruptPending = 0;

    //
    // Initialize the VBLANK interrupt command field
    //

    pBlock->VBCommand = NO_COMMAND;

    //
    // Initialize the General update in VBLANK fields (only used by P2)
    //

    pBlock->General.bDisplayDriverHasAccess = FALSE;
    pBlock->General.bMiniportHasAccess = FALSE;

    VideoPortZeroMemory( &pBlock->pxrxDMA, sizeof(pBlock->pxrxDMA) );

    hwDeviceExtension->InterruptControl.bInterruptsInitialized = TRUE;

    hwDeviceExtension->OutputFifoErrors = 0;
    hwDeviceExtension->InputFifoErrors = 0; 
    hwDeviceExtension->UnderflowErrors = 0; 
    hwDeviceExtension->TotalErrors = 0;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\interupt.h ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   interupt.h
*
* Abstract:
*
*   This module contains the definitions for the shared memory used by
*   the interrupt control routines.
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

//
// we manage a queue of DMA buffers that are to be loaded under interrupt control.
// Each entry has a physical address and a count to be loaded into Permedia 3. 
// The command can be used to indicate other things to do in the DMA interrupt.
//

typedef struct _glint_dma_queue {
    ULONG   command;
    ULONG   address;
    ULONG   count;
} DMABufferQueue;


typedef struct PXRXdmaInfo_Tag {

    volatile ULONG   scheme;          // Used by the interrupt handler only

    volatile ULONG   hostInId;        // Current internal HostIn id, 
                                      // used by the HIid DMA scheme

    volatile ULONG   fifoCount;       // Current internal FIFO count, 
                                      // used by various DMA schemes

    volatile ULONG   NTbuff;          // Current buffer number (0 or 1)

    volatile ULONG   *NTptr;          // 32/64 bit ptr    
                                      // Last address written to by NT
                                      // (but not necesserily the end of
                                      // a completed buffer)

    volatile ULONG   *NTdone;         // 32/64 bit ptr    
                                      // Last address NT has finished with 
                                      // (end of  a buffer, but not
                                      //  necessarily sent to P3 yet)

    volatile ULONG   *P3at;           // 32/64 bit ptr  
                                      // Last address sent to the P3

    volatile BOOLEAN bFlushRequired;  // Is a flush required to empty 
                                      // the FBwrite unit's cache?

    ULONG            *DMAaddrL[2];    // 32/64 bit ptr 
                                      // Linear address of the start
                                      //  of each DMA buffer

    ULONG            *DMAaddrEndL[2]; // 32/64 bit ptr
                                      // Linear address of the end of 
                                      // each DMA buffer

    ULONG            DMAaddrP[2];     // 32 bit ptr 
                                      // Physical address of the start of 
                                      // each DMA buffer

    ULONG            DMAaddrEndP[2];  // 32 bit ptr
                                      // Physical address of the end of 
                                      // each DMA buffer

} PXRXdmaInfo;

// interrupt status bits
typedef enum {
    DMA_INTERRUPT_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
    SUSPEND_DMA_TILL_VBLANK     = 0x04, // Stop doing DMA till after next VBLANK
    DIRECTDRAW_VBLANK_ENABLED   = 0x08, // Set flag for DirectDraw on VBLANK
    PXRX_SEND_ON_VBLANK_ENABLED = 0x10, // Set flag for PXRX DMA on VBLANK
    PXRX_CHECK_VFIFO_IN_VBLANK  = 0x20, // Set flag for VFIFO underrun checking on VBLANK
} INTERRUPT_CONTROL;

// commands to the interrupt controller on the next VBLANK
typedef enum {
    NO_COMMAND = 0,
    COLOR_SPACE_BUFFER_0,
    COLOR_SPACE_BUFFER_1,
} VBLANK_CONTROL_COMMAND;

// Display driver structure for 'general use'.
typedef struct _pointer_interrupt_control
{
    volatile ULONG bDisplayDriverHasAccess;
    volatile ULONG bMiniportHasAccess;
    volatile ULONG bInterruptPending;
    volatile ULONG bHidden;
    volatile ULONG CursorMode;
    volatile ULONG x, y;
} PTR_INTR_CTL;

// Display driver structure for 'pointer use'.
typedef struct _general_interrupt_control
{
    volatile ULONG    bDisplayDriverHasAccess;
    volatile ULONG    bMiniportHasAccess;
} GEN_INTR_CTL;

#define MAX_DMA_QUEUE_ENTRIES   10

typedef struct _glint_interrupt_control {

    // contains various status bits. ** MUST BE THE FIRST FIELD **
    volatile INTERRUPT_CONTROL   Control;

    // profiling counters for Permedia3 busy time
    ULONG   PerfCounterShift;    
    ULONG   BusyTime;   // at DMA interrupt add (TimeNow-StartTime) to this
    ULONG   StartTime;  // set this when DMACount is loaded
    ULONG   IdleTime;
    ULONG   IdleStart;

    // commands to perform on the next VBLANK
    volatile VBLANK_CONTROL_COMMAND   VBCommand;

    // flag to indicate whether we expect another DMA interrupt
    volatile ULONG InterruptPending;
    
    volatile ULONG    DDRAW_VBLANK;                // flag for DirectDraw to indicate that a VBLANK occured.
    volatile ULONG    bOverlayEnabled;             // TRUE if the overlay is on at all
    volatile ULONG    bVBLANKUpdateOverlay;        // TRUE if the overlay needs to be updated by the VBLANK routine.
    volatile ULONG    VBLANKUpdateOverlayWidth;    // overlay width (updated in vblank)
    volatile ULONG    VBLANKUpdateOverlayHeight;   // overlay height (updated in vblank)

    // Volatile structures are required to enforce single-threading
    // We need 1 for general display use and 1 for pointer use, because
    // the pointer is synchronous.
    volatile PTR_INTR_CTL    Pointer;
    volatile GEN_INTR_CTL    General;

    // dummy DMA buffer to cause an interrupt but transfer no data
    ULONG   dummyDMAAddress;
    ULONG   dummyDMACount;

    // index offsets into the queue for the front, back and end. Using separate
    // front and back offsets allows the display driver to add and the interrupt
    // controller to remove entries without a need for locking code.
    volatile ULONG   frontIndex;
    ULONG   backIndex;
    ULONG   endIndex;
    ULONG   maximumIndex;

    // For P3RX 2D DMA:
    ULONG        lastAddr;
    PXRXdmaInfo    pxrxDMA;

    // array to contain the DMA queue
    DMABufferQueue  dmaQueue[MAX_DMA_QUEUE_ENTRIES];
} INTERRUPT_CONTROL_BLOCK, *PINTERRUPT_CONTROL_BLOCK;

#define REQUEST_INTR_CMD_BLOCK_MUTEX(pBlock, bHaveMutex) \
{ \
    pBlock->bMiniportHasAccess = TRUE; \
    if(!pBlock->bDisplayDriverHasAccess) \
    { \
        bHaveMutex = TRUE; \
    } \
    else \
    { \
        bHaveMutex = FALSE; \
        pBlock->bMiniportHasAccess = FALSE; \
    } \
}

#define RELEASE_INTR_CMD_BLOCK_MUTEX(pBlock) \
{ \
    pBlock->bMiniportHasAccess = FALSE; \
}

//
// structure containing information about the interrupt control block
//
typedef struct _interrupt_control_buffer_ {

    PHYSICAL_ADDRESS        PhysAddress;
    INTERRUPT_CONTROL_BLOCK ControlBlock;
    PVOID                   kdpc;
    BOOLEAN                 bInterruptsInitialized;
} PERM3_INTERRUPT_CTRLBUF, *PPERM3_INTERRUPT_CTRLBUF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\i2c.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
* 
*   i2c.c
* 
* Abstract:
* 
*   This module contains the code that implements the i2c interface feature
* 
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"
#include "i2c.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetCookie)
#pragma alloc_text(PAGE,I2CBusOpenCRT)
#pragma alloc_text(PAGE,I2CBusOpenDFP)
#pragma alloc_text(PAGE,I2CBusOpen)
#pragma alloc_text(PAGE,I2CBusAccessCRT)
#pragma alloc_text(PAGE,I2CBusAccessDFP)
#pragma alloc_text(PAGE,I2CBusAccess)
#pragma alloc_text(PAGE,I2CNull)
#pragma alloc_text(PAGE,I2CRead)
#pragma alloc_text(PAGE,I2CWrite)
#pragma alloc_text(PAGE,I2CStart)
#pragma alloc_text(PAGE,I2CStop)
#pragma alloc_text(PAGE,InterfaceReference)
#pragma alloc_text(PAGE,InterfaceDereference)
#pragma alloc_text(PAGE,Perm3QueryInterface)
#endif

VIDEO_I2C_CONTROL
I2CCallbacksCRT = {
    I2CWriteClock, 
    I2CWriteData, 
    I2CReadClock, 
    I2CReadData, 
    0
    };

VIDEO_I2C_CONTROL
I2CCallbacksDFP = {
    I2CWriteClockDFP,
    I2CWriteDataDFP,
    I2CReadClockDFP, 
    I2CReadDataDFP, 
    0
    };

BOOLEAN
GetCookie(
    PVOID DeviceObject,
    PULONG Cookie
    )
{
    *Cookie = 0x12345678;
    return TRUE;
}

VP_STATUS
I2CBusOpenCRT(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl
    )

{
    return I2CBusOpen(DeviceObject, bOpen, I2CControl, &I2CCallbacksCRT);
}

VP_STATUS
I2CBusOpenDFP(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl
    )

{
    return I2CBusOpen(DeviceObject, bOpen, I2CControl, &I2CCallbacksDFP);
}

VP_STATUS
I2CBusOpen(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks
    )

{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    VP_STATUS Status = STATUS_UNSUCCESSFUL;

    hwDeviceExtension = VideoPortGetAssociatedDeviceExtension(DeviceObject);

    VideoPortAcquireDeviceLock(hwDeviceExtension);

    I2CControl->Status = I2C_STATUS_NOERROR;

    if (bOpen) {

        if (I2CControl->ClockRate > MAX_CLOCK_RATE) {
            I2CControl->ClockRate = MAX_CLOCK_RATE;
        }

        I2CCallbacks->I2CDelay = (MAX_CLOCK_RATE / I2CControl->ClockRate) * 10;

        if (GetCookie(DeviceObject, &I2CControl->dwCookie)) {

            Status = STATUS_SUCCESS;
        }

    } else {

        I2CControl->dwCookie = 0;
        Status = STATUS_SUCCESS;
    }

    VideoPortReleaseDeviceLock(hwDeviceExtension);

    return Status;
}

VP_STATUS
I2CBusAccessCRT(
    PVOID DeviceObject,
    PI2CControl I2CControl
    )

{
    return I2CBusAccess(DeviceObject, I2CControl, &I2CCallbacksCRT);
}

VP_STATUS
I2CBusAccessDFP(
    PVOID DeviceObject,
    PI2CControl I2CControl
    )

{
    return I2CBusAccess(DeviceObject, I2CControl, &I2CCallbacksDFP);
}

VP_STATUS
I2CBusAccess(
    PVOID DeviceObject,
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks
    )

{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    VP_STATUS Status = STATUS_UNSUCCESSFUL;

    hwDeviceExtension = VideoPortGetAssociatedDeviceExtension(DeviceObject);

    VideoPortAcquireDeviceLock(hwDeviceExtension);

    I2CControl->Status = I2C_STATUS_NOERROR;

    if (I2CControl->ClockRate > MAX_CLOCK_RATE) {
        I2CControl->ClockRate = MAX_CLOCK_RATE;
    }

    I2CCallbacks->I2CDelay = (MAX_CLOCK_RATE / I2CControl->ClockRate) * 10;

    switch(I2CControl->Command) {

    case I2C_COMMAND_NULL:

        I2CNull(I2CControl, I2CCallbacks, hwDeviceExtension);
        break;

    case I2C_COMMAND_READ:

        I2CRead(I2CControl, I2CCallbacks, hwDeviceExtension);
        break;

    case I2C_COMMAND_WRITE:

        I2CWrite(I2CControl, I2CCallbacks, hwDeviceExtension);
        break;

    case I2C_COMMAND_RESET:

        //
        // A reset is just a stop.
        //

        I2CStop(I2CControl, I2CCallbacks, hwDeviceExtension);
        break;

    case I2C_COMMAND_STATUS:

        break;

    default:
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    VideoPortReleaseDeviceLock(hwDeviceExtension);

    return I2CControl->Status;
}

ULONG
I2CNull(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    I2CControl->Status = I2C_STATUS_NOERROR;

    if (I2CControl->Flags & I2C_FLAGS_DATACHAINING) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    if (I2CControl->Flags & I2C_FLAGS_START) {
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    if (I2CControl->Flags & I2C_FLAGS_STOP) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
    }

    return I2CControl->Status;
}

ULONG
I2CRead(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    BOOLEAN Result;

    I2CControl->Status = I2C_STATUS_NOERROR;

    if (I2CControl->Flags & I2C_FLAGS_DATACHAINING) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    if (I2CControl->Flags & I2C_FLAGS_START) {
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    Result = hwDeviceExtension->I2CInterface.I2CRead(
                 hwDeviceExtension,
                 I2CCallbacks,
                 &I2CControl->Data,
                 1,
                 (I2CControl->Flags & I2C_FLAGS_ACK) ? FALSE : TRUE);

    if (Result == TRUE) {
        I2CControl->Status = I2C_STATUS_NOERROR;
    } else {
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    if (I2CControl->Flags & I2C_FLAGS_STOP) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
    }

    return I2CControl->Status;
}

ULONG
I2CWrite(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    BOOLEAN Result;

    I2CControl->Status = I2C_STATUS_NOERROR;

    if (I2CControl->Flags & I2C_FLAGS_DATACHAINING) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    if (I2CControl->Flags & I2C_FLAGS_START) {
        hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);
    }

    Result = hwDeviceExtension->I2CInterface.I2CWrite(
                 hwDeviceExtension,
                 I2CCallbacks,
                 &I2CControl->Data,
                 1);

    if (Result == TRUE) {
        I2CControl->Status = I2C_STATUS_NOERROR;
    } else {
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    if (I2CControl->Flags & I2C_FLAGS_STOP) {
        hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);
    }

    return I2CControl->Status;
}

ULONG
I2CStop(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    BOOLEAN Result;

    Result = hwDeviceExtension->I2CInterface.I2CStop(hwDeviceExtension, I2CCallbacks);

    if (Result == TRUE) {
        I2CControl->Status = I2C_STATUS_NOERROR;
    } else {
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    return I2CControl->Status;
}

ULONG
I2CStart(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

{
    BOOLEAN Result;

    Result = hwDeviceExtension->I2CInterface.I2CStart(hwDeviceExtension, I2CCallbacks);

    if (Result == TRUE) {
        I2CControl->Status = I2C_STATUS_NOERROR;
    } else {
        I2CControl->Status = I2C_STATUS_ERROR;
    }

    return I2CControl->Status;
}

VOID
InterfaceReference(
    IN PVOID pContext
    )

{
    return;
}

VOID
InterfaceDereference(
    IN PVOID pContext
    )

{
    return;
}


VP_STATUS
Perm3QueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE pQueryInterface
    )

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS Status;
    ULONG HwID;

    if (IsEqualGUID(pQueryInterface->InterfaceType, &GUID_I2C_INTERFACE)) {

        I2CINTERFACE *Interface = (I2CINTERFACE *)pQueryInterface->Interface;

        if ((pQueryInterface->Size == sizeof(I2CINTERFACE)) &&
            (pQueryInterface->Version == 2))
        {

            //
            // Get interface pointers for i2c interface help functions
            //

            if (hwDeviceExtension->I2CInterfaceAcquired == FALSE) {

                hwDeviceExtension->I2CInterface.Size = sizeof(VIDEO_PORT_I2C_INTERFACE_2);
                hwDeviceExtension->I2CInterface.Version = VIDEO_PORT_I2C_INTERFACE_VERSION_2;

                Status = VideoPortQueryServices(
                             hwDeviceExtension,
                             VideoPortServicesI2C,
                             (PINTERFACE)&hwDeviceExtension->I2CInterface);

                if (Status != NO_ERROR) {

                    VideoDebugPrint((1, "Perm3QueryInterface: Failed to acquire I2C services\n"));
                    return Status;
                }

                hwDeviceExtension->I2CInterfaceAcquired = TRUE;
            }

            if (((ULONG_PTR)pQueryInterface->InterfaceSpecificData != 0) &&
                ((ULONG_PTR)pQueryInterface->InterfaceSpecificData != -1)) {

                //
                // Get the HwID for the child requesting this interface
                //

                HwID = VideoPortGetAssociatedDeviceID(
                           pQueryInterface->InterfaceSpecificData);

            } else {

                if (hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED) {
                    HwID = PERM3_DFP_MONITOR;
                } else {
                    HwID = PERM3_DDC_MONITOR;
                }
            }

            //
            // Initialize the interface
            //

            Interface->_vddInterface.Size = sizeof(I2CINTERFACE);
            Interface->_vddInterface.Version = 2;
            Interface->_vddInterface.Context = HwDeviceExtension;

            Interface->_vddInterface.InterfaceReference = InterfaceReference;
            Interface->_vddInterface.InterfaceDereference = InterfaceDereference;

            if (HwID == PERM3_DDC_MONITOR) {

                Interface->i2cOpen = I2CBusOpenCRT;
                Interface->i2cAccess = I2CBusAccessCRT;

            } else if (HwID == PERM3_DFP_MONITOR) {

                Interface->i2cOpen = I2CBusOpenDFP;
                Interface->i2cAccess = I2CBusAccessDFP;
            }

            //
            // Reference the interface before handing it out
            //

            Interface->_vddInterface.InterfaceReference(Interface->_vddInterface.Context);

            Status = NO_ERROR;

        } else {

            VideoDebugPrint((1, "Perm3QueryInterface: Size or version incorrect\n"));
            Status = ERROR_INVALID_PARAMETER;
        }

    } else {

        VideoDebugPrint((1, "Perm3QueryInteface: Unsupported Interface\n"));
        Status = ERROR_INVALID_PARAMETER;
    }

    VideoDebugPrint((1, "Perm3QueryInterface: Status = 0x%x\n", Status));
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\i2c.h ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
* 
*   i2c.h
* 
* Abstract:
* 
*   This module contains the code that implements the i2c interface feature
* 
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#define STATUS_SUCCESS                   0x00000000
#define STATUS_UNSUCCESSFUL              0xC0000001

#define MAX_CLOCK_RATE 1000000

#define INITGUID
typedef ULONG NTSTATUS;

#include <i2cgpio.h>

BOOLEAN
GetCookie(
    PVOID DeviceObject,
    PULONG Cookie
    );

VP_STATUS
I2CBusOpenCRT(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl
    );

VP_STATUS
I2CBusOpenDFP(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl
    );

VP_STATUS
I2CBusAccessCRT(
    PVOID DeviceObject,
    PI2CControl I2CControl
    );

VP_STATUS
I2CBusAccessDFP(
    PVOID DeviceObject,
    PI2CControl I2CControl
    );

VOID
InterfaceReference(
    IN PVOID pContext
    );

VOID
InterfaceDereference(
    IN PVOID pContext
    );

ULONG
I2CNull(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG
I2CRead(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG
I2CWrite(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG
I2CStop(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG
I2CStart(
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VP_STATUS
I2CBusOpen(
    PVOID DeviceObject,
    BOOLEAN bOpen,
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks
    );

VP_STATUS
I2CBusAccess(
    PVOID DeviceObject,
    PI2CControl I2CControl,
    PVIDEO_I2C_CONTROL I2CCallbacks
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\p3rd.h ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   p3rd.h
*
* Abstract:
*
*   This module contains the definitions for the 3Dlabs P3 RAMDAC
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

//
// RAMDAC registers live on 64 bit boundaries. Leave it up to individual
// RAMDAC definitions to determine what registers are available and how
// many bits wide the registers really are.
//

typedef struct {
    volatile ULONG   reg;
    volatile ULONG   pad;
} RAMDAC_REG;

//
// structure with all the direct access registers
//

typedef struct _p3rd_regs {

    RAMDAC_REG    RDPaletteWriteAddress;
    RAMDAC_REG    RDPaletteData;
    RAMDAC_REG    RDPixelMask;
    RAMDAC_REG    RDPaletteAddressRead;
    RAMDAC_REG    RDIndexLow;
    RAMDAC_REG    RDIndexHigh;
    RAMDAC_REG    RDIndexedData;
    RAMDAC_REG    RDIndexControl;
} P3RDRAMDAC;

//
// Use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//

#define P3RD_PAL_WR_ADDR   ((PULONG)&(pP3RDRegs->RDPaletteWriteAddress.reg))
#define P3RD_PAL_RD_ADDR   ((PULONG)&(pP3RDRegs->RDPaletteAddressRead.reg))
#define P3RD_PAL_DATA      ((PULONG)&(pP3RDRegs->RDPaletteData.reg))
#define P3RD_PIXEL_MASK    ((PULONG)&(pP3RDRegs->RDPixelMask.reg))
#define P3RD_INDEX_ADDR_LO ((PULONG)&(pP3RDRegs->RDIndexLow.reg))
#define P3RD_INDEX_ADDR_HI ((PULONG)&(pP3RDRegs->RDIndexHigh.reg))
#define P3RD_INDEX_DATA    ((PULONG)&(pP3RDRegs->RDIndexedData.reg))
#define P3RD_INDEX_CONTROL ((PULONG)&(pP3RDRegs->RDIndexControl.reg))

//
// bit field definitions for the direct access registers
//

#define P3RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

//
// Indexed register definitions accessed via P3RD_LOAD_INDEX_REG() 
// and P3RD_READ_INDEX_REG()
//

#define P3RD_MISC_CONTROL               0x0000
#define P3RD_SYNC_CONTROL               0x0001
#define P3RD_DAC_CONTROL                0x0002
#define P3RD_PIXEL_SIZE                 0x0003
#define P3RD_COLOR_FORMAT               0x0004
#define P3RD_CURSOR_MODE                0x0005
#define P3RD_CURSOR_CONTROL             0x0006
#define P3RD_CURSOR_X_LOW               0x0007
#define P3RD_CURSOR_X_HIGH              0x0008
#define P3RD_CURSOR_Y_LOW               0x0009
#define P3RD_CURSOR_Y_HIGH              0x000a
#define P3RD_CURSOR_HOTSPOT_X           0x000b
#define P3RD_CURSOR_HOTSPOT_Y           0x000c
#define P3RD_OVERLAY_KEY                0x000d
#define P3RD_PAN                        0x000e
#define P3RD_SENSE                      0x000f
#define P3RD_CHECK_CONTROL              0x0018
#define P3RD_CHECK_PIXEL_RED            0x0019
#define P3RD_CHECK_PIXEL_GREEN          0x001a
#define P3RD_CHECK_PIXEL_BLUE           0x001b
#define P3RD_CHECK_LUT_RED              0x001c
#define P3RD_CHECK_LUT_GREEN            0x001d
#define P3RD_CHECK_LUT_BLUE             0x001e
#define P3RD_SCRATCH                    0x001f
#define P3RD_VIDEO_OVERLAY_CONTROL      0x0020
#define P3RD_VIDEO_OVERLAY_X_START_LOW  0x0021
#define P3RD_VIDEO_OVERLAY_X_START_HIGH 0x0022
#define P3RD_VIDEO_OVERLAY_Y_START_LOW  0x0023
#define P3RD_VIDEO_OVERLAY_Y_START_HIGH 0x0024
#define P3RD_VIDEO_OVERLAY_X_END_LOW    0x0025
#define P3RD_VIDEO_OVERLAY_X_END_HIGH   0x0026
#define P3RD_VIDEO_OVERLAY_Y_END_LOW    0x0027
#define P3RD_VIDEO_OVERLAY_Y_END_HIGH   0x0028
#define P3RD_VIDEO_OVERLAY_KEY_R        0x0029
#define P3RD_VIDEO_OVERLAY_KEY_G        0x002A
#define P3RD_VIDEO_OVERLAY_KEY_B        0x002B
#define P3RD_VIDEO_OVERLAY_BLEND        0x002C

#define P3RD_DCLK_SETUP_1               0x01f0
#define P3RD_DCLK_SETUP_2               0x01f1
#define P3RD_KCLK_SETUP_1               0x01f2
#define P3RD_KCLK_SETUP_2               0x01f3
#define P3RD_DCLK_CONTROL               0x0200
#define P3RD_DCLK0_PRE_SCALE            0x0201
#define P3RD_DCLK0_FEEDBACK_SCALE       0x0202
#define P3RD_DCLK0_POST_SCALE           0x0203
#define P3RD_DCLK1_PRE_SCALE            0x0204
#define P3RD_DCLK1_FEEDBACK_SCALE       0x0205
#define P3RD_DCLK1_POST_SCALE           0x0206
#define P3RD_DCLK2_PRE_SCALE            0x0207
#define P3RD_DCLK2_FEEDBACK_SCALE       0x0208
#define P3RD_DCLK2_POST_SCALE           0x0209
#define P3RD_DCLK3_PRE_SCALE            0x020a
#define P3RD_DCLK3_FEEDBACK_SCALE       0x020b
#define P3RD_DCLK3_POST_SCALE           0x020c
#define P3RD_KCLK_CONTROL               0x020d
#define P3RD_KCLK_PRE_SCALE             0x020e
#define P3RD_KCLK_FEEDBACK_SCALE        0x020f
#define P3RD_KCLK_POST_SCALE            0x0210
#define P3RD_MCLK_CONTROL               0x0211
#define P3RD_SCLK_CONTROL               0x0215
#define P3RD_CURSOR_PALETTE_START       0x0303        // 303..32f
#define P3RD_CURSOR_PATTERN_START       0x0400        // 400..7ff

//
// Defaults for the MCLK and KCLK clock source registers
//

#define P3RD_DEFAULT_MCLK_SRC P3RD_MCLK_CONTROL_KCLK
#define P3RD_DEFAULT_SCLK_SRC P3RD_SCLK_CONTROL_KCLK

//
// Bit field definitions for the indexed registers
//

#define P3RD_MISC_CONTROL_STEREO_DBL_BUFFER_ENABLED   0x80
#define P3RD_MISC_CONTROL_VSB_OUTPUT_ENABLED          0x40
#define P3RD_MISC_CONTROL_PIXEL_DBL_BUFFER_ENABLED    0x20
#define P3RD_MISC_CONTROL_OVERLAYS_ENABLED            0x10
#define P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED        0x08
#define P3RD_MISC_CONTROL_LAST_READ_ADDRESS_ENABLED   0x04
#define P3RD_MISC_CONTROL_PIXEL_DOUBLE                0x02
#define P3RD_MISC_CONTROL_HIGHCOLORRES                0x01

#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW    0x00
#define P3RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH   0x08
#define P3RD_SYNC_CONTROL_VSYNC_INACTIVE      0x20
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW    0x00
#define P3RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH   0x01
#define P3RD_SYNC_CONTROL_HSYNC_INACTIVE      0x04

#define P3RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED    0x80

#define P3RD_PIXEL_SIZE_8BPP            0x00
#define P3RD_PIXEL_SIZE_16BPP           0x01
#define P3RD_PIXEL_SIZE_24_BPP          0x04
#define P3RD_PIXEL_SIZE_32BPP           0x02

#define P3RD_COLOR_FORMAT_CI8           0x0e
#define P3RD_COLOR_FORMAT_8BPP          0x05
#define P3RD_COLOR_FORMAT_15BPP         0x01
#define P3RD_COLOR_FORMAT_16BPP         0x10
#define P3RD_COLOR_FORMAT_32BPP         0x00
#define P3RD_COLOR_FORMAT_LINEAR_EXT    0x40
#define P3RD_COLOR_FORMAT_RGB           0x20

#define P3RD_CURSOR_MODE_REVERSE        0x40
#define P3RD_CURSOR_MODE_WINDOWS        0x00
#define P3RD_CURSOR_MODE_X              0x10
#define P3RD_CURSOR_MODE_3COLOR         0x20
#define P3RD_CURSOR_MODE_15COLOR        0x30
#define P3RD_CURSOR_MODE_64x64          0x00
#define P3RD_CURSOR_MODE_P0_32x32x2     0x02
#define P3RD_CURSOR_MODE_P1_32x32x2     0x04
#define P3RD_CURSOR_MODE_P2_32x32x2     0x06
#define P3RD_CURSOR_MODE_P3_32x32x2     0x08
#define P3RD_CURSOR_MODE_P01_32x32x4    0x0a
#define P3RD_CURSOR_MODE_P23_32x32x4    0x0c
#define P3RD_CURSOR_MODE_ENABLED        0x01

#define P3RD_CURSOR_CONTROL_RPOS_ENABLED 0x04
#define P3RD_CURSOR_CONTROL_DOUBLE_Y     0x02
#define P3RD_CURSOR_CONTROL_DOUBLE_X     0x01

#define P3RD_DCLK_CONTROL_LOCKED         0x02    // read-only
#define P3RD_DCLK_CONTROL_ENABLED        0x01
#define P3RD_DCLK_CONTROL_RUN            0x08

#define P3RD_KCLK_CONTROL_LOCKED         0x02    // read-only
#define P3RD_KCLK_CONTROL_ENABLED        0x01
#define P3RD_KCLK_CONTROL_RUN            (0x2<<2)
#define P3RD_KCLK_CONTROL_PCLK           (0x0<<4)
#define P3RD_KCLK_CONTROL_HALF_PCLK      (0x1<<4)
#define P3RD_KCLK_CONTROL_PLL            (0x2<<4)

#define P3RD_MCLK_CONTROL_ENABLED        0x01
#define P3RD_MCLK_CONTROL_DRIVE_LOW      (0x0<<2)
#define P3RD_MCLK_CONTROL_DRIVE_HIGH     (0x1<<2)
#define P3RD_MCLK_CONTROL_RUN            (0x2<<2)
#define P3RD_MCLK_CONTROL_LOW_POWER      (0x3<<2)
#define P3RD_MCLK_CONTROL_HALF_PCLK      (0x1<<4)
#define P3RD_MCLK_CONTROL_PCLK           (0x0<<4)
#define P3RD_MCLK_CONTROL_HALF_EXTMCLK   (0x3<<4)
#define P3RD_MCLK_CONTROL_EXTMCLK        (0x4<<4)
#define P3RD_MCLK_CONTROL_HALF_KCLK      (0x5<<4)
#define P3RD_MCLK_CONTROL_KCLK           (0x6<<4)

#define P3RD_SCLK_CONTROL_ENABLED        0x01
#define P3RD_SCLK_CONTROL_DRIVE_LOW      (0x0<<2)
#define P3RD_SCLK_CONTROL_DRIVE_HIGH     (0x1<<2)
#define P3RD_SCLK_CONTROL_RUN            (0x2<<2)
#define P3RD_SCLK_CONTROL_LOW_POWER      (0x3<<2)
#define P3RD_SCLK_CONTROL_HALF_PCLK      (0x1<<4)
#define P3RD_SCLK_CONTROL_PCLK           (0x0<<4)
#define P3RD_SCLK_CONTROL_HALF_EXTSCLK   (0x3<<4)
#define P3RD_SCLK_CONTROL_EXTSCLK        (0x4<<4)
#define P3RD_SCLK_CONTROL_HALF_KCLK      (0x5<<4)
#define P3RD_SCLK_CONTROL_KCLK           (0x6<<4)

#define P3RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}


#if 0

//
// Need a delay between each write to the P3RD. The only way to guarantee
// that the write has completed is to read from a Permedia 3 control register.
// Reading forces any posted writes to be flushed out. PPC needs 2 reads
// to give us enough time.
//

#define P3RD_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}

#else
#define P3RD_DELAY
#endif

//
// Macro to load a given data value into an internal P3RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//

#define P3RD_INDEX_REG(index) \
{ \
    /*VideoDebugPrint((0, "*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_LO, (index) & 0xff)); */\
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P3RD_DELAY; \
    /*VideoDebugPrint((0, "*(0x%x) <-- 0x%x\n", P3RD_INDEX_ADDR_HI, (index) >> 8)); */\
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_DATA(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_LOAD_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    /*VideoDebugPrint((0, "*(0x%x) <-- 0x%x\n", P3RD_INDEX_DATA, (data) & 0xff)); */\
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P3RD_DELAY; \
}

#define P3RD_READ_INDEX_REG(index, data) \
{ \
    P3RD_INDEX_REG(index);                            \
    data = VideoPortReadRegisterUlong(P3RD_INDEX_DATA) & 0xff;   \
    P3RD_DELAY; \
    /*VideoDebugPrint((0, "0x%x <-- *(0x%x)\n", data, P3RD_INDEX_DATA));*/ \
}

#define P3RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA,    (ULONG)(data));   \
    P3RD_DELAY; \
}

//
// Macros to load a given RGB triple into the P3RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P3RD_PALETTE_START and multiple P3RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P3RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//

#define P3RD_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

#define P3RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PAL_WR_ADDR, (ULONG)(index));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(red));      \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(green));    \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_PAL_DATA,    (ULONG)(blue));     \
    P3RD_DELAY; \
}

//
// Macro to read back a given RGB triple from the P3RD palette. Use after
// a call to P3RD_PALETTE_START_RD
//

#define P3RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);    \
    P3RD_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);    \
    P3RD_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(P3RD_PAL_DATA) & 0xff);    \
    P3RD_DELAY; \
}

//
// Macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//

#define P3RD_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(P3RD_PIXEL_MASK,  (ULONG)(mask)); \
    P3RD_DELAY; \
}

#define P3RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(P3RD_PIXEL_MASK) & 0xff; \
}

//
// Macros to load values into the cursor array usage is
// P3RD_CURSOR_ARRAR_START() followed by n iterations of 
// P3RD_LOAD_CURSOR_ARRAY() or P3RD_READ_CURSOR_ARRAY()
//

#define P3RD_CURSOR_ARRAY_START(offset) \
{ \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) & 0xff));  \
    P3RD_DELAY; \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)(((offset)+P3RD_CURSOR_PATTERN_START) >> 8));    \
    P3RD_DELAY; \
}

#define P3RD_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)(data)); \
    P3RD_DELAY; \
}

#define P3RD_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(P3RD_INDEX_DATA) & 0xff; \
    P3RD_DELAY; \
}

#define P3RD_SET_CURSOR_MODE(data) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_LO, (ULONG)((P3RD_CURSOR_MODE) & 0xff)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)((P3RD_CURSOR_MODE) >> 8)); \
    VideoPortWriteRegisterUlong(P3RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
}

//    
// Macro to move the cursor
//

#define P3RD_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI, (ULONG)0);              \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

//    
// Macro to change the cursor hotspot
//

#define P3RD_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}

//    
// Macro to change the cursor color
//

#define P3RD_CURSOR_COLOR(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P3RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P3RD_DELAY; \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P3RD_LOAD_INDEX_REG_LO(P3RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}

//
// Warning the Perm3 has an upside down cursor LUT, which means that
// items read from LUT entry 0 are actually read from entry 14.
// Therefore we have some macros to calculate the right value.
//

#define P3RD_REVERSE_LUT_INDEX    1
#if P3RD_REVERSE_LUT_INDEX
#define P3RD_CALCULATE_LUT_INDEX(x) (14 - x)
#else  
#define P3RD_CALCULATE_LUT_INDEX(x) (x)
#endif 

//    
// Check to see whether byte doubling is required. If, at 8BPP, any of the
// VESA horizontal parameters have the bottom bit set then we need to put
// the chip into 64-bit, byte-doubling mode.
//    

#define P3RD_CHECK_8BPP_NEED64BITDAC(VESATmgs)((BOOLEAN)((GetHtotFromVESA(VESATmgs) |   \
                                                          GetHssFromVESA(VESATmgs)  |   \
                                                          GetHseFromVESA(VESATmgs)  |   \
                                                          GetHbeFromVESA(VESATmgs)  ) & 0x1))

//    
// Check whether the current mode needs to be pixel doubled (i.e are we at
// 8BPP andwe fufill the above criteria.
//    

#define P3RD_CHECK_BYTE_DOUBLING(hwDeviceExtension,pixelDepth,VESATmgs)     \
                                 (pixelDepth <= 8 &&                        \
                                  P3RD_CHECK_8BPP_NEED64BITDAC(&VESATimings))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\perm3.h ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   perm3.h
*
* Abstract:
*
*   This module contains the definitions for the Permedia3 miniport driver.
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

//
// This line will cause the DEFINE_GUID lines in i2cgpio.h actually do something
//

#define INITGUID

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"
#include "interupt.h"

#define GAMMA_CORRECTION 1
#define MASK_OUTFIFO_ERROR_INTERRUPT 1
//
// Define an assert macro for debugging
//

#if DBG
#define PERM3_ASSERT(x, y) if (!(x)) { VideoDebugPrint((0, (y))); ASSERT(FALSE); }
#else
#define PERM3_ASSERT(x, y)
#endif

//
// Include definitions for all supported RAMDACS
//

#include "p3rd.h"

//
// We use 'Int 10' to do mode switching on the x86. 
//

#if defined(i386)
    #define INT10_MODE_SET  1
#endif

//
// Default clock speed in Hz for the reference board. The actual speed
// is looked up in the registry. Use this if no registry entry is found
// or the registry entry is zero.
//

#define PERMEDIA3_DEFAULT_CLOCK_SPEED       ( 80 * (1000*1000))
#define PERMEDIA3_DEFAULT_CLOCK_SPEED_ALT   ( 80 * (1000*1000))
#define PERMEDIA3_MAX_CLOCK_SPEED           (250 * (1000*1000))
#define PERMEDIA3_DEFAULT_MCLK_SPEED        ( 80 * (1000*1000))
#define PERMEDIA3_DEFAULT_SCLK_SPEED        ( 70 * (1000*1000))

//
// Maximum pixelclock values that the RAMDAC can handle (in 100's hz).
//

#define P3_MAX_PIXELCLOCK 2700000      // RAMDAC rated at 270 Mhz
#define P4_REVB_MAX_PIXELCLOCK 3000000 // RAMDAC rated at 300 Mhz

//
// Maximum amount of video data per second, that the rasterizer
// chip can send to the RAMDAC (limited by SDRAM/SGRAM throuput).
//

#define P3_MAX_PIXELDATA  15000000   // 1500 million bytes/sec (in 100's bytes)

//
// Base address numbers for the Perm3 PCI regions in which we're interested.
// These are indexes into the AccessRanges array we get from probing the
// device. 
//

#define PCI_CTRL_BASE_INDEX       0
#define PCI_LB_BASE_INDEX         1
#define PCI_FB_BASE_INDEX         2

#define ROM_MAPPED_LENGTH       0x10000

#define VENDOR_ID_3DLABS        0x3D3D
#define PERMEDIA3_ID            0x000A
#define PERMEDIA4_ID            0x000C

//
// Capabilities flags
//
// These are private flags passed to the Permedia 3 display driver. They're
// put in the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to the display driver via an 'VIDEO_QUERY_AVAIL_MODES' or
// 'VIDEO_QUERY_CURRENT_MODE' IOCTL.
//
// NOTE: These definitions must match those in the Permedia 3 display driver's
//       'driver.h'!

typedef enum {
    CAPS_ZOOM_X_BY2      = 0x00000001,   // Hardware has zoomed by 2 in X
    CAPS_ZOOM_Y_BY2      = 0x00000002,   // Hardware has zoomed by 2 in Y
    CAPS_QUEUED_DMA      = 0x00000008,   // DMA address/count via the FIFO
    CAPS_LOGICAL_DMA     = 0x00000010,   // DMA through logical address table
    CAPS_USE_AGP_DMA     = 0x00000020,   // AGP DMA can be used.
    CAPS_P3RD_POINTER    = 0x00000040,   // Use the 3Dlabs P3RD RAMDAC
    CAPS_STEREO          = 0x00000080,   // Stereo mode enabled.
    CAPS_SW_POINTER      = 0x00010000,   // No hardware pointer; use software simulation
    CAPS_GLYPH_EXPAND    = 0x00020000,   // Use glyph-expand method to draw text.
    CAPS_FAST_FILL_BUG   = 0x00080000,   // chip fast fill bug exists
    CAPS_INTERRUPTS      = 0x00100000,   // interrupts supported
    CAPS_DMA_AVAILABLE   = 0x00200000,   // DMA is supported
    CAPS_DISABLE_OVERLAY = 0x00400000,   // chip do not support overlay
} CAPS;

//
// The capabilities of a Perm3 board. 
//

typedef enum {
    PERM3_NOCAPS             = 0x00000000, // No additional capabilities
    PERM3_SGRAM              = 0x00000001, // SGRAM board (else SDRAM)
    PERM3_DFP                = 0x00000002, // Digital flat panel
    PERM3_DFP_MON_ATTACHED   = 0x00000010, // DFP Monitor is attached
    PERM3_USE_BYTE_DOUBLING  = 0x00000040  // Current mode requires byte-doubling
} PERM3_CAPS;

//
// Supported board definitions.
//

typedef enum _PERM3_BOARDS {
    PERMEDIA3_BOARD = 17,
} PERM3_BOARDS;

//
// Chip type definitions
//

typedef enum _PERM3_CHIPSETS {
    PERMEDIA3 = 5,
} PERM3_CHIPSET;

//
// Supported RAMDAC definitions.
//

typedef enum _PERM3_RAMDACS {
    P3RD_RAMDAC = 14,
} PERM3_RAMDACS;

//
// macros to add padding words to the structures. For the core registers we use
// the tag ids when specifying the pad. So we must multiply by 8 to get a byte
// pad. We need to add an id to make each pad field in the struct unique. The
// id is irrelevant as long as it's different from every other id used in the
// same struct. 
//

#define PAD(id, n)              UCHAR   pad##id[n]
#define PADRANGE(id, n)         PAD(id, (n)-sizeof(PERM3_REG))
#define PADCORERANGE(id, n)     PADRANGE(id, (n)<<3)

//
// Perm3 registers are 32 bits wide and live on 64-bit boundaries.
//

typedef struct {
    ULONG   reg;
    ULONG   pad;
} PERM3_REG;

//
// Permedia 3 PCI Region 0 Address MAP:
//
// All registers are on 64-bit boundaries so we have to define a number of
// padding words. The number given in the comments are offsets from the start
// of the PCI region.
//

typedef struct _perm3_region0_map {

    // Control Status Registers:
    PERM3_REG       ResetStatus;                // 0000h
    PERM3_REG       IntEnable;                  // 0008h
    PERM3_REG       IntFlags;                   // 0010h
    PERM3_REG       InFIFOSpace;                // 0018h
    PERM3_REG       OutFIFOWords;               // 0020h
    PERM3_REG       DMAAddress;                 // 0028h
    PERM3_REG       DMACount;                   // 0030h
    PERM3_REG       ErrorFlags;                 // 0038h
    PERM3_REG       VClkCtl;                    // 0040h
    PERM3_REG       TestRegister;               // 0048h
    union a0 {
        // GLINT
        struct b0 {
            PERM3_REG       Aperture0;          // 0050h
            PERM3_REG       Aperture1;          // 0058h
        };
        // PERMEDIA
        struct b1 {
            PERM3_REG       ApertureOne;        // 0050h
            PERM3_REG       ApertureTwo;        // 0058h
        };
    };
    PERM3_REG       DMAControl;                 // 0060h
    PERM3_REG       DisconnectControl;          // 0068h

    // PERMEDIA only
    PERM3_REG       ChipConfig;                 // 0070h
    PERM3_REG       AGPControl;                 // 0078h - Px/Rx
    PERM3_REG       OutDMAAddress;              // 0080h
    PERM3_REG       OutDMACount;                // 0088h
    PERM3_REG       AGPTexBaseAddress;          // 0090h

    PADRANGE(201, 0xA0-0x90);
    PERM3_REG       ByDMAAddress;               // 00A0h
    PADRANGE(202, 0xB8-0xA0);

    PERM3_REG       ByDMAStride;                // 00B8h
    PERM3_REG       ByDMAMemAddr;               // 00C0h
    PERM3_REG       ByDMASize;                  // 00C8h
    PERM3_REG       ByDMAByteMask;              // 00D0h
    PERM3_REG       ByDMAControl;               // 00D8h
    PADRANGE(203, 0xE8-0xD8);

    PERM3_REG       ByDMAComplete;              // 00E8h
    PADRANGE(204, 0x100-0xE8);

    // Paged texture management registers.
    PERM3_REG        HostTextureAddress;        // 0100h
    PERM3_REG        TextureDownloadControl;    // 0108h
    PERM3_REG        TextureOperation;          // 0110h
    PERM3_REG        LogicalTexturePage;        // 0118h
    PERM3_REG        TextureDMAAddress;         // 0120h
    PERM3_REG        TextureFIFOSpace;          // 0128h
    PADRANGE(205, 0x300-0x128);

    PERM3_REG        ByAperture1Mode;           // 0300h
    PERM3_REG        ByAperture1Stride;         // 0308h
    PADRANGE(206, 0x328-0x308);

    PERM3_REG        ByAperture2Mode;           // 0328h
    PERM3_REG        ByAperture2Stride;         // 0330h
    PADRANGE(207, 0x350-0x330);

    PERM3_REG        ByDMAReadMode;             // 0350h - Px/Rx only
    PERM3_REG        ByDMAReadStride;           // 0358h - Px/Rx only
    PADRANGE(208, 0x800-0x358);

    //
    // GLINTdelta registers. Registers with the same functionality as on GLINT
    // are at the same offset. XXX are not real registers.
    //

    PERM3_REG       DeltaReset;                 // 0800h
    PERM3_REG       DeltaIntEnable;             // 0808h
    PERM3_REG       DeltaIntFlags;              // 0810h
    PERM3_REG       DeltaInFIFOSpaceXXX;        // 0818h
    PERM3_REG       DeltaOutFIFOWordsXXX;       // 0820h
    PERM3_REG       DeltaDMAAddressXXX;         // 0828h
    PERM3_REG       DeltaDMACountXXX;           // 0830h
    PERM3_REG       DeltaErrorFlags;            // 0838h
    PERM3_REG       DeltaVClkCtlXXX;            // 0840h
    PERM3_REG       DeltaTestRegister;          // 0848h
    PERM3_REG       DeltaAperture0XXX;          // 0850h
    PERM3_REG       DeltaAperture1XXX;          // 0858h
    PERM3_REG       DeltaDMAControlXXX;         // 0860h
    PERM3_REG       DeltaDisconnectControl;     // 0868h

    //
    // GLINTgamma registers
    //

    PERM3_REG        GammaChipConfig;            // 0870h
    PERM3_REG        GammaCSRAperture;           // 0878h
    PADRANGE(3, 0x0c00-0x878);
    PERM3_REG        GammaPageTableAddr;         // 0c00h
    PERM3_REG        GammaPageTableLength;       // 0c08h
    PADRANGE(301, 0x0c38-0x0c08);
    PERM3_REG        GammaDelayTimer;            // 0c38h
    PERM3_REG        GammaCommandMode;           // 0c40h
    PERM3_REG        GammaCommandIntEnable;      // 0c48h
    PERM3_REG        GammaCommandIntFlags;       // 0c50h
    PERM3_REG        GammaCommandErrorFlags;     // 0c58h
    PERM3_REG        GammaCommandStatus;         // 0c60h
    PERM3_REG        GammaCommandFaultingAddr;   // 0c68h
    PERM3_REG        GammaVertexFaultingAddr;    // 0c70h
    PADRANGE(302, 0x0c88-0x0c70);
    PERM3_REG        GammaWriteFaultingAddr;     // 0c88h
    PADRANGE(303, 0x0c98-0x0c88);
    PERM3_REG        GammaFeedbackSelectCount;   // 0c98h
    PADRANGE(304, 0x0cb8-0x0c98);
    PERM3_REG        GammaProcessorMode;         // 0cb8h
    PADRANGE(305, 0x0d00-0x0cb8);
    PERM3_REG        GammaVGAShadow;             // 0d00h
    PERM3_REG        GammaMultiGLINTAperture;    // 0d08h    
    PERM3_REG        GammaMultiGLINT1;           // 0d10h
    PERM3_REG        GammaMultiGLINT2;           // 0d18h
    PADRANGE(306, 0x0f00-0x0d18);
    PERM3_REG        GammaSerialAccess;          // 0f00h
    PADRANGE(307, 0x1000-0x0f00);

    // Localbuffer Registers
    union x0 {                                   // 1000h
        PERM3_REG   LBMemoryCtl;                 // GLINT
        PERM3_REG   Reboot;                      // PERMEDIA
    };
    PERM3_REG       LBMemoryEDO;                 // 1008h
    PADRANGE(308, 0x1018-0x1008);

    // PERMEDIA3 only
    PERM3_REG       LocalMemCaps;                // 1018h
    PERM3_REG       LocalMemTiming;              // 1020h
    PERM3_REG       LocalMemControl;             // 1028h
    PERM3_REG       LocalMemRefresh;             // 1030h
    PERM3_REG       LocalMemPowerDown;           // 1038h

    // PERMEDIA & PERMEDIA2 only
    PERM3_REG       MemControl;                  // 1040h

    // PERMEDIA3 only
    PADRANGE(4, 0x1068-0x1040);
    PERM3_REG       LocalMemProfileMask0;        // 1068h
    PERM3_REG       LocalMemProfileCount0;       // 1070h
    PERM3_REG       LocalMemProfileMask1;        // 1078h

    // PERMEDIA & PERMEDIA2 only
    PERM3_REG       BootAddress;                 // 1080h   [= LocalMemProfileCount1 on PxRx]
    PADRANGE(5, 0x10C0-0x1080);
    PERM3_REG       MemConfig;                   // 10C0h
    PADRANGE(6, 0x1100-0x10C0);
    PERM3_REG       BypassWriteMask;             // 1100h
    PADRANGE(7, 0x1140-0x1100);
    PERM3_REG       FramebufferWriteMask;        // 1140h
    PADRANGE(8, 0x1180-0x1140);
    PERM3_REG       Count;                       // 1180h
    PADRANGE(9, 0x1800-0x1180);

    // Framebuffer Registers
    PERM3_REG       FBMemoryCtl;                 // 1800h
    PERM3_REG       FBModeSel;                   // 1808h
    PERM3_REG       FBGCWrMask;                  // 1810h
    PERM3_REG       FBGCColorMask;               // 1818h
    PERM3_REG       FBTXMemCtl;                  // 1820h
    PADRANGE(10, 0x2000-0x1820);
               
    // Graphics Core FIFO Interface
    PERM3_REG       FIFOInterface;               // 2000h
    PADRANGE(11, 0x3000-0x2000);

    // Internal Video Registers
    union x1 {
        // GLINT
        struct s1 {
            PERM3_REG   VTGHLimit;               // 3000h
            PERM3_REG   VTGHSyncStart;           // 3008h
            PERM3_REG   VTGHSyncEnd;             // 3010h
            PERM3_REG   VTGHBlankEnd;            // 3018h
            PERM3_REG   VTGVLimit;               // 3020h
            PERM3_REG   VTGVSyncStart;           // 3028h
            PERM3_REG   VTGVSyncEnd;             // 3030h
            PERM3_REG   VTGVBlankEnd;            // 3038h
            PERM3_REG   VTGHGateStart;           // 3040h
            PERM3_REG   VTGHGateEnd;             // 3048h
            PERM3_REG   VTGVGateStart;           // 3050h
            PERM3_REG   VTGVGateEnd;             // 3058h
            PERM3_REG   VTGPolarity;             // 3060h
            PERM3_REG   VTGFrameRowAddr;         // 3068h
            PERM3_REG   VTGVLineNumber;          // 3070h
            PERM3_REG   VTGSerialClk;            // 3078h
            PERM3_REG   VTGModeCtl;              // 3080h
        };
        // PERMEDIA
        struct s2 {
            PERM3_REG   ScreenBase;              // 3000h
            PERM3_REG   ScreenStride;            // 3008h
            PERM3_REG   HTotal;                  // 3010h
            PERM3_REG   HgEnd;                   // 3018h
            PERM3_REG   HbEnd;                   // 3020h
            PERM3_REG   HsStart;                 // 3028h
            PERM3_REG   HsEnd;                   // 3030h
            PERM3_REG   VTotal;                  // 3038h
            PERM3_REG   VbEnd;                   // 3040h
            PERM3_REG   VsStart;                 // 3048h
            PERM3_REG   VsEnd;                   // 3050h
            PERM3_REG   VideoControl;            // 3058h
            PERM3_REG   InterruptLine;           // 3060h
            PERM3_REG   DDCData;                 // 3068h
            PERM3_REG   LineCount;               // 3070h
            PERM3_REG   VFifoCtl;                // 3078h
            PERM3_REG   ScreenBaseRight;         // 3080h
        };
    };

    PERM3_REG   MiscControl;                     // 3088h

    PADRANGE(111, 0x3100-0x3088);

    PERM3_REG  VideoOverlayUpdate;               // 0x3100
    PERM3_REG  VideoOverlayMode;                 // 0x3108
    PERM3_REG  VideoOverlayFifoControl;          // 0x3110
    PERM3_REG  VideoOverlayIndex;                // 0x3118
    PERM3_REG  VideoOverlayBase0;                // 0x3120
    PERM3_REG  VideoOverlayBase1;                // 0x3128
    PERM3_REG  VideoOverlayBase2;                // 0x3130
    PERM3_REG  VideoOverlayStride;               // 0x3138
    PERM3_REG  VideoOverlayWidth;                // 0x3140
    PERM3_REG  VideoOverlayHeight;               // 0x3148
    PERM3_REG  VideoOverlayOrigin;               // 0x3150
    PERM3_REG  VideoOverlayShrinkXDelta;         // 0x3158
    PERM3_REG  VideoOverlayZoomXDelta;           // 0x3160
    PERM3_REG  VideoOverlayYDelta;               // 0x3168
    PERM3_REG  VideoOverlayFieldOffset;          // 0x3170
    PERM3_REG  VideoOverlayStatus;               // 0x3178

    //
    // External Video Control Registers
    // Need to cast this to a struct for a particular video generator
    //

    PADRANGE(12, 0x4000-0x3178);
    PERM3_REG       ExternalVideo;               // 4000h
    PADRANGE(13, 0x4080-0x4000);

    //
    // Mentor Dual-TX clock chip registers
    //

    PERM3_REG       MentorICDControl;            // 4080h

    //
    // for future: MentorDoubleWrite is at 40C0: 0 = single write, 1 = double
    //             NB must have 2-way interleaved memory

    PADRANGE(14, 0x4800-0x4080);

    PERM3_REG       GloriaControl;               // 4800h

    PADRANGE(15, 0x5000-0x4800);
    PERM3_REG       DemonProDWAndStatus;         // 5000h - Pro
    PADRANGE(151, 0x5800-0x5000);

    //
    // P2 video streams registers
    //

    PERM3_REG        VSConfiguration;            // 5800h
    PERM3_REG        VSStatus;                   // 5808h
    PERM3_REG        VSSerialBusControl;         // 5810h
    PADRANGE(16, 0x5A00-0x5810);
    PERM3_REG        VSBControl;                 // 5A00h
    PADRANGE(161, 0x6000-0x5A00);

    union x2 {
        struct s3 {
            PERM3_REG   RacerDoubleWrite;        // 6000h
            PERM3_REG   RacerBankSelect;         // 6008h
            PERM3_REG   DualTxVgaSwitch;         // 6010h
            PERM3_REG   DDC1ReadAddress;         // 6018h
        };
        struct s4 {

            //
            // the following array is actually 1024 bytes long
            //

            UCHAR       PermediaVgaCtrl[4*sizeof(PERM3_REG)];
        };
    };
    PADRANGE(17, 0x7000-0x6018);
    union {
        PERM3_REG       DemonProUBufB;           // 7000h - Pro
        PERM3_REG        TextureDataFifo;
    };
    PADRANGE(171, 0x8000-0x7000);

} Perm3ControlRegMap, *pPerm3ControlRegMap;

//
// Permedia 3 Interrupt Control Bits
//

// InterruptEnable register
#define INTR_DISABLE_ALL        0
#define INTR_ENABLE_DMA         (1 << 0)
#define INTR_ENABLE_SYNC        (1 << 1)
#define INTR_ENABLE_EXTERNAL    (1 << 2)
#define INTR_ENABLE_ERROR       (1 << 3)
#define INTR_ENABLE_VBLANK      (1 << 4)
#define INTR_ENABLE_GCOMMAND    (1 << 13)

// InterruptFlags register
#define INTR_DMA_SET            (1 << 0)
#define INTR_SYNC_SET           (1 << 1)
#define INTR_EXTERNAL_SET       (1 << 2)
#define INTR_ERROR_SET          (1 << 3)
#define INTR_VBLANK_SET         (1 << 4)
#define INTR_TEXTURE_FAULT_SET  (1 << 6)
#define INTR_GCOMMAND_SET       (1 << 13)

#define INTR_CLEAR_ALL          (0x1f | (1 << 13))
#define INTR_CLEAR_DMA          (1 << 0)
#define INTR_CLEAR_SYNC         (1 << 1)
#define INTR_CLEAR_EXTERNAL     (1 << 2)
#define INTR_CLEAR_ERROR        (1 << 3)
#define INTR_CLEAR_VBLANK       (1 << 4)

// Error Flags
#define ERROR_IN_FIFO           (1 << 0)
#define ERROR_OUT_FIFO          (1 << 1)
#define ERROR_MESSAGE           (1 << 2)
#define DMA_ERROR               (1 << 3)
#define ERROR_VFIFO_UNDERRUN    (1 << 4)

//
// Macros which takes a Perm3 tag name or control register name and translates
// it to a register address. Data must be written to these addresses using
// VideoPortWriteRegisterUlong and read using VideoPortReadRegisterUlong.
// e.g. dma_count = VideoPortReadRegisterUlong(DMA_COUNT);
//

#define CTRL_REG_ADDR(reg)       ((PULONG)&(pCtrlRegs->reg))
#define CTRL_REG_OFFSET(regAddr) ((ULONG)(((ULONG_PTR)regAddr) - ((ULONG_PTR)pCtrlRegs)))

//
// Defines for the different control registers needed by Permedia 3. 
// These macros can be used as the address part.  
//

#define RESET_STATUS            CTRL_REG_ADDR(ResetStatus) 
#define INT_ENABLE              CTRL_REG_ADDR(IntEnable) 
#define INT_FLAGS               CTRL_REG_ADDR(IntFlags) 
#define IN_FIFO_SPACE           CTRL_REG_ADDR(InFIFOSpace) 
#define OUT_FIFO_WORDS          CTRL_REG_ADDR(OutFIFOWords) 
#define DMA_ADDRESS             CTRL_REG_ADDR(DMAAddress) 
#define DMA_COUNT               CTRL_REG_ADDR(DMACount) 
#define DMA_OUT_ADDRESS         CTRL_REG_ADDR(OutDMAAddress)
#define DMA_OUT_COUNT           CTRL_REG_ADDR(OutDMACount)
#define ERROR_FLAGS             CTRL_REG_ADDR(ErrorFlags) 
#define V_CLK_CTL               CTRL_REG_ADDR(VClkCtl) 
#define TEST_REGISTER           CTRL_REG_ADDR(TestRegister) 
#define APERTURE_0              CTRL_REG_ADDR(Aperture0) 
#define APERTURE_1              CTRL_REG_ADDR(Aperture1) 
#define DMA_CONTROL             CTRL_REG_ADDR(DMAControl) 
#define LB_MEMORY_CTL           CTRL_REG_ADDR(LBMemoryCtl) 
#define LB_MEMORY_EDO           CTRL_REG_ADDR(LBMemoryEDO) 
#define FB_MEMORY_CTL           CTRL_REG_ADDR(FBMemoryCtl) 
#define FB_MODE_SEL             CTRL_REG_ADDR(FBModeSel) 
#define FB_GC_WRITEMASK         CTRL_REG_ADDR(FBGCWrMask) 
#define FB_GC_COLORMASK         CTRL_REG_ADDR(FBGCColorMask) 
#define FB_TX_MEM_CTL           CTRL_REG_ADDR(FBTXMemCtl) 
#define FIFO_INTERFACE          CTRL_REG_ADDR(FIFOInterface) 
#define DISCONNECT_CONTROL      CTRL_REG_ADDR(DisconnectControl)
#define BY_DMACOMPLETE          CTRL_REG_ADDR(ByDMAComplete) 
#define AGP_TEX_BASE_ADDRESS    CTRL_REG_ADDR(AGPTexBaseAddress)

// Bypass mode registers

#define BY_APERTURE1_MODE       CTRL_REG_ADDR(ByAperture1Mode)
#define BY_APERTURE1_STRIDE     CTRL_REG_ADDR(ByAperture1Stride)
#define BY_APERTURE2_MODE       CTRL_REG_ADDR(ByAperture2Mode)
#define BY_APERTURE2_STRIDE     CTRL_REG_ADDR(ByAperture2Stride)
#define BY_DMA_READ_MODE        CTRL_REG_ADDR(ByDMAReadMode)
#define BY_DMA_READ_STRIDE      CTRL_REG_ADDR(ByDMAReadStride)

// Delta control registers

#define DELTA_RESET_STATUS      CTRL_REG_ADDR(DeltaReset) 
#define DELTA_INT_ENABLE        CTRL_REG_ADDR(DeltaIntEnable) 
#define DELTA_INT_FLAGS         CTRL_REG_ADDR(DeltaIntFlags) 

// Permedia 3 Registers

#define APERTURE_ONE            CTRL_REG_ADDR(ApertureOne) 
#define APERTURE_TWO            CTRL_REG_ADDR(ApertureTwo)
#define BYPASS_WRITE_MASK       CTRL_REG_ADDR(BypassWriteMask)
#define FRAMEBUFFER_WRITE_MASK  CTRL_REG_ADDR(FramebufferWriteMask)
#define MEM_CONTROL             CTRL_REG_ADDR(MemControl)
#define BOOT_ADDRESS            CTRL_REG_ADDR(BootAddress)
#define MEM_CONFIG              CTRL_REG_ADDR(MemConfig) 
#define CHIP_CONFIG             CTRL_REG_ADDR(ChipConfig) 
#define AGP_CONTROL             CTRL_REG_ADDR(AGPControl) 
#define SGRAM_REBOOT            CTRL_REG_ADDR(Reboot) 
#define SCREEN_BASE             CTRL_REG_ADDR(ScreenBase) 
#define SCREEN_BASE_RIGHT       CTRL_REG_ADDR(ScreenBaseRight)
#define SCREEN_STRIDE           CTRL_REG_ADDR(ScreenStride) 
#define H_TOTAL                 CTRL_REG_ADDR(HTotal) 
#define HG_END                  CTRL_REG_ADDR(HgEnd) 
#define HB_END                  CTRL_REG_ADDR(HbEnd) 
#define HS_START                CTRL_REG_ADDR(HsStart) 
#define HS_END                  CTRL_REG_ADDR(HsEnd) 
#define V_TOTAL                 CTRL_REG_ADDR(VTotal) 
#define VB_END                  CTRL_REG_ADDR(VbEnd) 
#define VS_START                CTRL_REG_ADDR(VsStart) 
#define VS_END                  CTRL_REG_ADDR(VsEnd) 
#define VIDEO_CONTROL           CTRL_REG_ADDR(VideoControl) 
#define INTERRUPT_LINE          CTRL_REG_ADDR(InterruptLine) 
#define DDC_DATA                CTRL_REG_ADDR(DDCData) 
#define LINE_COUNT              CTRL_REG_ADDR(LineCount)
#define VIDEO_FIFO_CTL          CTRL_REG_ADDR(VFifoCtl)
#define MISC_CONTROL            CTRL_REG_ADDR(MiscControl) 


// Permedia 3 Video Streams registers

#define VSTREAM_CONFIG          CTRL_REG_ADDR(VSConfiguration)
#define VSTREAM_SERIAL_CONTROL  CTRL_REG_ADDR(VSSerialBusControl) 
#define VSTREAM_B_CONTROL       CTRL_REG_ADDR(VSBControl) 

#define VSTREAM_CONFIG_UNITMODE_MASK        (0x7 << 0)
#define VSTREAM_CONFIG_UNITMODE_FP          (0x6 << 0)
#define VSTREAM_CONFIG_UNITMODE_CRT         (0x0 << 0)
#define VSTREAM_SERIAL_CONTROL_DATAIN       (0x1 << 0)
#define VSTREAM_SERIAL_CONTROL_CLKIN        (0x1 << 1)
#define VSTREAM_SERIAL_CONTROL_DATAOUT      (0x1 << 2)
#define VSTREAM_SERIAL_CONTROL_CLKOUT       (0x1 << 3)
#define VSTREAM_B_CONTROL_RAMDAC_ENABLE     (0x1 << 14)
#define VSTREAM_B_CONTROL_RAMDAC_DISABLE    (0x0 << 14)

//
// Memory mapped VGA access
//

#define PERMEDIA_MMVGA_INDEX_REG    ((PVOID)(&(pCtrlRegs->PermediaVgaCtrl[0x3C4])))
#define PERMEDIA_MMVGA_DATA_REG     (&(pCtrlRegs->PermediaVgaCtrl[0x3C5]))
#define PERMEDIA_MMVGA_STAT_REG     (&(pCtrlRegs->PermediaVgaCtrl[0x3DA]))

#define PERMEDIA_VGA_CTRL_INDEX     5
#define PERMEDIA_VGA_ENABLE         (1 << 3)
#define PERMEDIA_VGA_STAT_VSYNC     (1 << 3)
#define PERMEDIA_VGA_LOCK_INDEX1    6
#define PERMEDIA_VGA_LOCK_INDEX2    7
#define PERMEDIA_VGA_LOCK_DATA1     0x0
#define PERMEDIA_VGA_LOCK_DATA2     0x0
#define PERMEDIA_VGA_UNLOCK_DATA1   0x3D
#define PERMEDIA_VGA_UNLOCK_DATA2   0xDB

//
// Lock VGA registers, only applicable to P3 and later, note that we only
// need to write to 1 of the LOCK registers not both
//

#define LOCK_VGA_REGISTERS() {                                                                \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, PERMEDIA_VGA_LOCK_INDEX1 );    \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_DATA_REG,  PERMEDIA_VGA_LOCK_DATA1 );    \
}

//
// Unlock VGA registers, only applicable to P3 and later. We have to write
// special magic code to unlock the registers. Note that this should be done
// using 2 short writes rather than 4 byte ones, but I've left it in for
// readability.
//

#define UNLOCK_VGA_REGISTERS() {                                                            \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, PERMEDIA_VGA_LOCK_INDEX1 );    \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_DATA_REG,  PERMEDIA_VGA_UNLOCK_DATA1 );    \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, PERMEDIA_VGA_LOCK_INDEX2 );    \
        VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_DATA_REG,  PERMEDIA_VGA_UNLOCK_DATA2 );    \
}

#define VC_FORCED_HIGH     0
#define VC_ACTIVE_HIGH     1
#define VC_FORCED_LOW      2
#define VC_ACTIVE_LOW      3
#define VC_HSYNC(x)        (x << 3)
#define VC_VSYNC(x)        (x << 5)
#define VC_ON              1
#define VC_OFF             0
#define VC_DPMS_MASK       (VC_HSYNC(3) | VC_VSYNC(3) | VC_ON)

#define VC_DPMS_STANDBY    (VC_HSYNC(VC_FORCED_LOW)  | VC_VSYNC(VC_ACTIVE_HIGH) | VC_OFF)
#define VC_DPMS_SUSPEND    (VC_HSYNC(VC_ACTIVE_HIGH) | VC_VSYNC(VC_FORCED_LOW)  | VC_OFF)
#define VC_DPMS_OFF        (VC_HSYNC(VC_FORCED_LOW)  | VC_VSYNC(VC_FORCED_LOW)  | VC_OFF)

//
// DisconnectControl bits
//

#define DISCONNECT_INPUT_FIFO_ENABLE    0x1
#define DISCONNECT_OUTPUT_FIFO_ENABLE   0x2
#define DISCONNECT_INOUT_ENABLE         (DISCONNECT_INPUT_FIFO_ENABLE | \
                                         DISCONNECT_OUTPUT_FIFO_ENABLE)

// PXRX memory timing registers
#define PXRX_LOCAL_MEM_CAPS          CTRL_REG_ADDR(LocalMemCaps)
#define PXRX_LOCAL_MEM_CONTROL       CTRL_REG_ADDR(LocalMemControl)
#define PXRX_LOCAL_MEM_POWER_DOWN    CTRL_REG_ADDR(LocalMemPowerDown)
#define PXRX_LOCAL_MEM_REFRESH       CTRL_REG_ADDR(LocalMemRefresh)
#define PXRX_LOCAL_MEM_TIMING        CTRL_REG_ADDR(LocalMemTiming)

// Values for the MISC_CONTROL
#define PXRX_MISC_CONTROL_STRIPE_MODE_DISABLE    (0 << 0)    // Stripe mode
#define PXRX_MISC_CONTROL_STRIPE_MODE_PRIMARY    (1 << 0)
#define PXRX_MISC_CONTROL_STRIPE_MODE_SECONDARY  (2 << 0)

#define PXRX_MISC_CONTROL_STRIPE_SIZE_1          (0 << 4)    // Stripe size
#define PXRX_MISC_CONTROL_STRIPE_SIZE_2          (1 << 4)
#define PXRX_MISC_CONTROL_STRIPE_SIZE_4          (2 << 4)
#define PXRX_MISC_CONTROL_STRIPE_SIZE_8          (3 << 4)
#define PXRX_MISC_CONTROL_STRIPE_SIZE_16         (4 << 4)

#define PXRX_MISC_CONTROL_BYTE_DBL_DISABLE       (0 << 7)    // Byte doubling
#define PXRX_MISC_CONTROL_BYTE_DBL_ENABLE        (1 << 7)

//
// Characteristics of each mode
//

typedef struct _PERM3_VIDEO_MODES {

    // Leave INT10 fields in for later chips which have VGA
    USHORT Int10ModeNumberContiguous;
    USHORT Int10ModeNumberNoncontiguous;
    ULONG ScreenStrideContiguous;
    VIDEO_MODE_INFORMATION ModeInformation;

} PERM3_VIDEO_MODES, *PPERM3_VIDEO_MODES;

//
// Mode-set specific information.
//

typedef struct _PERM3_VIDEO_FREQUENCIES {
    ULONG BitsPerPel;
    ULONG ScreenWidth;
    ULONG ScreenHeight;
    ULONG ScreenFrequency;
    PPERM3_VIDEO_MODES ModeEntry;
    ULONG ModeIndex;
    UCHAR ModeValid;
    ULONG PixelClock;
} PERM3_VIDEO_FREQUENCIES, *PPERM3_VIDEO_FREQUENCIES;

//
// Monitor & screen mode information:
// structure of timing data contained in the registry
//

typedef struct {
    USHORT   HTot;   // Hor Total Time
    UCHAR    HFP;    // Hor Front Porch
    UCHAR    HST;    // Hor Sync Time
    UCHAR    HBP;    // Hor Back Porch
    UCHAR    HSP;    // Hor Sync Polarity
    USHORT   VTot;   // Ver Total Time   
    UCHAR    VFP;    // Ver Front Porch  
    UCHAR    VST;    // Ver Sync Time    
    UCHAR    VBP;    // Ver Back Porch   
    UCHAR    VSP;    // Ver Sync Polarity
    ULONG    pClk;   // Pixel clock
} VESA_TIMING_STANDARD;

typedef struct {
    ULONG    width;
    ULONG    height;
    ULONG    refresh;
} MODE_INFO;

typedef struct {
    MODE_INFO               basic;
    VESA_TIMING_STANDARD    vesa;
} TIMING_INFO;

#define MI_FLAGS_READ_DDC          (1 << 3)
#define MI_FLAGS_DOES_DDC          (1 << 4)
#define MI_FLAGS_FUDGED_VH         (1 << 5)
#define MI_FLAGS_FUDGED_PCLK       (1 << 6)
#define MI_FLAGS_FUDGED_XY         (1 << 7)
#define MI_FLAGS_LIMIT_XY          (1 << 8)

typedef struct {
    ULONG flags;
    char  id[8];
    char  name[16];         // name[14] but need to ensure dword packing
    ULONG fhMin, fhMax;
    ULONG fvMin, fvMax;
    ULONG pClkMin, pClkMax;
    ULONG timingNum;
    ULONG xMin, xMax, yMin, yMax;
    ULONG timingMax;
    TIMING_INFO *timingList;
    PERM3_VIDEO_FREQUENCIES  *frequencyTable;
    ULONG numAvailableModes;
    ULONG numTotalModes;
} MONITOR_INFO;

typedef struct {
    ULONG fH, fV;
    ULONG pClk;
} FREQUENCIES;

//
// Framebuffer Aperture Information: currently only of interest to GeoTwin
// boards to allow for upload DMA directly from FB0 to FB1 and vice versa
//

typedef struct FrameBuffer_Aperture_Info
{
    PHYSICAL_ADDRESS pphysBaseAddr;
    ULONG            cjLength;
}
FBAPI;

//
// PCI device information. Used in an IOCTL return. Ensure this is the same
// as in the display driver 
// Never rearrange the existing order, just append to the end (see
// IOCTL_VIDEO_QUERY_DEVICE_INFO in display driver)
//

typedef struct _Perm3_Device_Info {
    ULONG SubsystemId;
    ULONG SubsystemVendorId;
    ULONG VendorId;
    ULONG DeviceId;
    ULONG RevisionId;
    ULONG DeltaRevId;
    ULONG GammaRevId;
    ULONG BoardId;
    ULONG LocalbufferLength;
    ULONG LocalbufferWidth;
    ULONG ActualDacId;
    FBAPI FBAperture[2];         // Physical addresses for geo twin framebuffers
    PVOID FBApertureVirtual[2];  // Virtual addresses for geo twin framebuffers
    PVOID FBApertureMapped [2];  // Mapped physical/logical addresses for geo twin framebuffers
    PUCHAR pCNB20;
    PHYSICAL_ADDRESS pphysFrameBuffer; // physical address of the framebuffer (use FBAperture instead for geo twins)
} Perm3_Device_Info;

// Definition of the IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER

typedef struct _GENERAL_DMA_BUFFER {
    PHYSICAL_ADDRESS    physAddr;        // physical address of DMA buffer
    PVOID               virtAddr;        // mapped virtual address
    ULONG               size;            // size in bytes
    BOOLEAN             cacheEnabled;    // Whether buffer is cached
} GENERAL_DMA_BUFFER, *PGENERAL_DMA_BUFFER;

// 
// The following are the definition for the LUT cache. The aim of the LUT cache
// is to stop sparkling from occurring, bu only writing those LUT entries that
// have changed to the chip, we can only do this by remembering what is already
// down there. The 'mystify' screen saver on P2 demonstrates the problem.
//

#define LUT_CACHE_INIT()        {VideoPortZeroMemory (&(hwDeviceExtension->LUTCache), sizeof (hwDeviceExtension->LUTCache));}
#define LUT_CACHE_SETSIZE(sz)    {hwDeviceExtension->LUTCache.LUTCache.NumEntries = (sz);}
#define LUT_CACHE_SETFIRST(frst){hwDeviceExtension->LUTCache.LUTCache.FirstEntry = (frst);}

#define LUT_CACHE_SETRGB(idx,zr,zg,zb) {    \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Red   = (UCHAR) (zr); \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Green = (UCHAR) (zg); \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Blue  = (UCHAR) (zb); \
}


typedef struct {
    VIDEO_CLUT LUTCache;             // Header  plus 1 LUT entry
    VIDEO_CLUTDATA LUTData [255];    // the other 255 LUT entries
} LUT_CACHE;

//
// Possible regions:
//   Gamma ctl 
//   Perm3 ctl
//   LB
//   FB
//

#define MAX_RESERVED_REGIONS 4

#define MAX_REGISTER_INITIALIZATION_TABLE_ENTRIES 10
#define MAX_REGISTER_INITIALIZATION_TABLE_ULONGS (2 * MAX_REGISTER_INITIALIZATION_TABLE_ENTRIES)

//
// Define device extension structure. This is device dependent/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {
    pPerm3ControlRegMap ctrlRegBase[1];
    PVOID pFramebuffer;
    PVOID pRamdac;
    PHYSICAL_ADDRESS PhysicalFrameAddress;
    ULONG FrameLength;
    PHYSICAL_ADDRESS PhysicalRegisterAddress;
    ULONG RegisterLength;
    UCHAR RegisterSpace;
    ULONG SavedControlAddress;
    PPERM3_VIDEO_MODES ActiveModeEntry;
    PERM3_VIDEO_FREQUENCIES ActiveFrequencyEntry;
    PCI_SLOT_NUMBER pciSlot;
    ULONG DacId;
    ULONG ChipClockSpeed;
    ULONG ChipClockSpeedAlt;
    ULONG GlintGammaClockSpeed;
    ULONG PXRXLastClockSpeed;
    ULONG RefClockSpeed;
    ULONG Capabilities;
    ULONG AdapterMemorySize;
    ULONG PhysicalFrameIoSpace;
    BOOLEAN bIsAGP;

    Perm3_Device_Info deviceInfo;

    ULONG BiosVersionMajorNumber;
    ULONG BiosVersionMinorNumber;

    //
    // Shared memory for comms with the display driver
    //

    PERM3_INTERRUPT_CTRLBUF InterruptControl;

    //
    // Shared memory for comms with the display driver
    //

    PERM3_INTERRUPT_CTRLBUF InterruptTextureControl;

    //
    // DMA Buffer definitions
    //

    GENERAL_DMA_BUFFER LineDMABuffer;
    GENERAL_DMA_BUFFER P3RXDMABuffer;

    //
    // PCI Config Information
    //

    ULONG bVGAEnabled;
    VIDEO_ACCESS_RANGE PciAccessRange[MAX_RESERVED_REGIONS+1];

    //
    // Initialization table
    //

    ULONG aulInitializationTable[MAX_REGISTER_INITIALIZATION_TABLE_ULONGS];
    ULONG culTableEntries;

    //
    // Extended BIOS initialisation variables
    //

    BOOLEAN bHaveExtendedClocks;
    ULONG ulPXRXCoreClock;
    ULONG ulPXRXMemoryClock;
    ULONG ulPXRXMemoryClockSrc;
    ULONG ulPXRXSetupClock;
    ULONG ulPXRXSetupClockSrc;
    ULONG ulPXRXGammaClock;
    ULONG ulPXRXCoreClockAlt;

    //
    // LUT cache
    //

    LUT_CACHE LUTCache;

    ULONG IntEnable;
    ULONG VideoFifoControlCountdown;

    BOOLEAN bVTGRunning;
    PPERM3_VIDEO_FREQUENCIES pFrequencyDefault;

    //
    // State save variables (for power management)
    //

    ULONG VideoControlMonitorON;
    ULONG VideoControl;
    ULONG PreviousPowerState;
    BOOLEAN bMonitorPoweredOn;
    ULONG VideoFifoControl;

    //
    // Monitor configuration stuff:
    //

    MONITOR_INFO monitorInfo;

    //
    // Perm3 Capabilities
    //

    PERM3_CAPS Perm3Capabilities;

    //
    // Error detected in interrupt routine
    //

    ULONG OutputFifoErrors;
    ULONG InputFifoErrors; 
    ULONG UnderflowErrors; 
    ULONG TotalErrors;

    //
    // I2C Support
    //

    BOOLEAN I2CInterfaceAcquired;
    VIDEO_PORT_I2C_INTERFACE_2 I2CInterface;

    ULONG (*WinXpVideoPortGetAssociatedDeviceID)(PVOID);
    VP_STATUS (*WinXpSp1VideoPortRegisterBugcheckCallback)(PVOID,ULONG,PVIDEO_BUGCHECK_CALLBACK,ULONG);

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

#define VideoPortGetAssociatedDeviceID \
        hwDeviceExtension->WinXpVideoPortGetAssociatedDeviceID

// PCI configuration region device specific defines
#define AGP_CAP_ID            2       // PCIsig AGP Cap ID
#define AGP_CAP_PTR_OFFSET    0x34    // offset to start of capabilities list

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF
#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * (VIDEO_MAX_COLOR_REGISTER+1)))

//
// Data
//

extern PERM3_VIDEO_MODES Perm3Modes[];
extern const ULONG NumPerm3VideoModes;

extern VIDEO_ACCESS_RANGE Perm3LegacyResourceList[];
extern ULONG Perm3LegacyResourceEntries;

//
// PXRX Registry Strings
//

#define PERM3_REG_STRING_CORECLKSPEED      L"PXRX.CoreClockSpeed"
#define PERM3_REG_STRING_CORECLKSPEEDALT   L"PXRX.CoreClockSpeedAlt"
#define PERM3_REG_STRING_REFCLKSPEED       L"PXRX.RefClockSpeed"

//
// IOCTL and structure definitions for mapping DMA buffers
//

#define IOCTL_VIDEO_QUERY_NUM_DMA_BUFFERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DMA_BUFFERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD1, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DEVICE_INFO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_DWORD \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_SAVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_COLOR_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDB, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Extract timings from VESA structure in a form that can be programmed into
// the Perm3 timing generator.
//

#define  GetHtotFromVESA(VESATmgs) ((VESATmgs)->HTot)
#define  GetHssFromVESA(VESATmgs)  ((VESATmgs)->HFP)
#define  GetHseFromVESA(VESATmgs)  ((VESATmgs)->HFP + (VESATmgs)->HST)
#define  GetHbeFromVESA(VESATmgs)  ((VESATmgs)->HFP + (VESATmgs)->HST + (VESATmgs)->HBP)
#define  GetHspFromVESA(VESATmgs)  ((VESATmgs)->HSP)
#define  GetVtotFromVESA(VESATmgs) ((VESATmgs)->VTot)
#define  GetVssFromVESA(VESATmgs)  ((VESATmgs)->VFP)
#define  GetVseFromVESA(VESATmgs)  ((VESATmgs)->VFP + (VESATmgs)->VST)
#define  GetVbeFromVESA(VESATmgs)  ((VESATmgs)->VFP + (VESATmgs)->VST + (VESATmgs)->VBP)
#define  GetVspFromVESA(VESATmgs)  ((VESATmgs)->VSP)

//
// Permedia 3 programs the video fifo thresholds using an iterative method
// to get the optimal values. Originally I tried this using the error
// interrupt to capture video fifo underruns, unfortunately the Perm3
// generates a number of spurious (I think) host-in DMA errors too
// which makes it too expansive to keep error interrupts on all the time.
// Instead we do a periodic check using the vblank interrupt (this can be
// kept on all the time as it's not too frequent)
//

#define NUM_VBLANKS_BETWEEN_VFIFO_CHECKS 10
#define NUM_VBLANKS_AFTER_VFIFO_ERROR 2

#define SUBVENDORID_3DLABS        0x3D3D // Sub-system Vendor ID
#define SUBDEVICEID_P3_VX1_PCI    0x0121 // Sub-system Device ID: P3+16MB SDRAM
#define SUBDEVICEID_P3_VX1_AGP    0x0125 // Sub-system Device ID: P3+32MB SDRAM (VX1)
#define SUBDEVICEID_P3_VX1_1600SW 0x0800 // Sub-system Device ID: P3+32MB SDRAM (VX1-1600SW)
#define SUBDEVICEID_P3_32D_AGP    0x0127 // Sub-system Device ID: P3+32MB SDRAM (Permedia3 Create!)
#define SUBDEVICEID_P4_VX1_AGP    0x0144 // Sub-system Device ID: P4+32MB SDRAM (VX1)

//
// All our child IDs begin 0x1357bd so they are readily identifiable as our own
//

#define PERM3_DDC_MONITOR    (0x1357bd00)
#define PERM3_NONDDC_MONITOR (0x1357bd01)
#define PERM3_DFP_MONITOR    (0x1357bd02)

//
// Function prototypes
//

//
// Functions in perm3.c
//

VP_STATUS
Perm3FindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
Perm3Initialize(
    PVOID HwDeviceExtension
    );

VP_STATUS
Perm3QueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE pQueryInterface
    );

VOID
ConstructValidModesList(
    PVOID HwDeviceExtension,
    MONITOR_INFO *mi
    );

VOID
InitializePostRegisters(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN
Perm3ResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

VP_STATUS
Perm3SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize,
    BOOLEAN ForceRAMDACWrite,
    BOOLEAN UpdateCache
    );

VP_STATUS
Perm3RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VOID 
BuildInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VOID 
CopyROMInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVOID pvROMAddress
    );

VOID 
GenerateInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VOID 
ProcessInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

ULONG 
UlongToString(
    ULONG i, 
    PWSTR pwsz
    );

ULONG 
ProbeRAMSize(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PULONG FBAddr, 
    ULONG FBMappedSize
    );

BOOLEAN Perm3AssignResources(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN 
Perm3ConfigurePci(
    PVOID HwDeviceExtension
    );

ULONG 
GetBoardCapabilities(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG SubsystemID, 
    ULONG SubdeviceID
    );

VOID 
SetHardwareInfoRegistries(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN 
MapResource(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

//
// Functions in perm3io.c
//

BOOLEAN
Perm3StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VOID
Perm3GetClockSpeeds(
    PVOID HwDeviceExtension
    );

VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG RequestedMode
    );

VP_STATUS 
SetCurrentVideoMode(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG modeNumber, 
    BOOLEAN bZeroMemory
    );

VP_STATUS
Perm3RetrieveGammaCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VOID 
ReadChipClockSpeedFromROM (
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG * pChipClkSpeed
    );


//
// Functions in video.c
//

BOOLEAN
InitializeVideo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PPERM3_VIDEO_FREQUENCIES VideoMode
    );

VOID 
SwitchToHiResMode(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    BOOLEAN bHiRes
    );

BOOLEAN 
Program_P3RD(
    PHW_DEVICE_EXTENSION, 
    PPERM3_VIDEO_FREQUENCIES,  
    ULONG, 
    ULONG, 
    ULONG, 
    PULONG, 
    PULONG, 
    PULONG
    );

ULONG 
P3RD_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,
    ULONG ReqClock,
    ULONG *rM,
    ULONG *rN,
    ULONG *rP
    );

ULONG 
P4RD_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,
    ULONG ReqClock,
    ULONG *rM,
    ULONG *rN,
    ULONG *rP
    );

//
// Functions in power.c
//

VP_STATUS
Perm3GetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

VP_STATUS
Perm3SetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

ULONG 
Perm3GetChildDescriptor(PVOID HwDeviceExtension, 
    PVIDEO_CHILD_ENUM_INFO pChildInfo, 
    PVIDEO_CHILD_TYPE pChildType,
    PUCHAR pChildDescriptor, 
    PULONG pUId, 
    PULONG Unused);

VOID 
ProgramDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN
GetDFPEdid(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PUCHAR EdidBuffer,
    LONG  EdidSize
    );

VOID 
I2CWriteClock(
    PVOID HwDeviceExtension, 
    UCHAR data
    );

VOID 
I2CWriteData(
    PVOID HwDeviceExtension, 
    UCHAR data
    );

BOOLEAN 
I2CReadClock(
    PVOID HwDeviceExtension
    );

BOOLEAN 
I2CReadData(
    PVOID HwDeviceExtension
    );

VOID 
I2CWriteClockDFP(
    PVOID HwDeviceExtension, 
    UCHAR data
    );

VOID 
I2CWriteDataDFP(
    PVOID HwDeviceExtension, 
    UCHAR data
    );

BOOLEAN 
I2CReadClockDFP(
    PVOID HwDeviceExtension
    );

BOOLEAN 
I2CReadDataDFP(
    PVOID HwDeviceExtension
    );

//
// Functions in interupt.c
//

BOOLEAN
Perm3InitializeInterruptBlock(
    PVOID   HwDeviceExtension
    );

BOOLEAN
Perm3VideoInterrupt(
    PVOID HwDeviceExtension
    );

//
// Functions in perm3dat.c
//

BOOLEAN GetVideoTiming (
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG xRes, 
    ULONG yRes, 
    ULONG Freq, 
    ULONG Depth,
    VESA_TIMING_STANDARD *VESATimings
    );

BOOLEAN
BuildFrequencyList( 
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    MONITOR_INFO* 
    );

BOOLEAN
BuildFrequencyListFromVESA( 
    MONITOR_INFO *mi, 
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN 
BuildFrequencyListForSGIDFP( 
    MONITOR_INFO *mi, 
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );
 
BOOLEAN    
GrowTimingList( 
    PVOID HwDeviceExtension,
    MONITOR_INFO *mi 
    );

BOOLEAN   
CopyMonitorTimings( 
    PVOID HwDeviceExtension,
    MONITOR_INFO *srcMI, 
    MONITOR_INFO *destMI 
    );

VOID 
testExtendRanges( 
    MONITOR_INFO *mi, 
    TIMING_INFO *ti, 
    FREQUENCIES *freq 
    );

//
// bugcheck callback support
//

#if (_WIN32_WINNT < 0x502)
#define BUGCHECK_DATA_SIZE_RESERVED 48
#endif
#define PERM3_BUGCHECK_DATA_SIZE (4000 - BUGCHECK_DATA_SIZE_RESERVED) //bytes

VOID
Perm3BugcheckCallback(
    PVOID HwDeviceExtension,
    ULONG BugcheckCode,
    PUCHAR Buffer,
    ULONG BufferSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\perm3.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   perm3.c
*
* Abstract:
*
*   This module contains the code that implements the Permedia 3 miniport 
*   driver
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"
#include "string.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,Perm3FindAdapter)
#pragma alloc_text(PAGE,Perm3AssignResources)
#pragma alloc_text(PAGE,Perm3ConfigurePci)
#pragma alloc_text(PAGE,GetBoardCapabilities)
#pragma alloc_text(PAGE,Perm3Initialize)
#pragma alloc_text(PAGE,SetHardwareInfoRegistries)
#pragma alloc_text(PAGE,UlongToString)
#pragma alloc_text(PAGE,MapResource)
#pragma alloc_text(PAGE,ProbeRAMSize)
#pragma alloc_text(PAGE,InitializePostRegisters)
#pragma alloc_text(PAGE,ConstructValidModesList)
#pragma alloc_text(PAGE,Perm3RegistryCallback)
#pragma alloc_text(PAGE,BuildInitializationTable)
#pragma alloc_text(PAGE,CopyROMInitializationTable)
#pragma alloc_text(PAGE,GenerateInitializationTable)
#pragma alloc_text(PAGE,ProcessInitializationTable)
#endif

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*+++

Routine Description:

    DriverEntry is the initial entry point into the video miniport driver.

Arguments:

    Context1
        First context value passed by the operating system. This is the 
        value with which the miniport driver calls VideoPortInitialize().

    Context2
        Second context value passed by the operating system. This is the 
        value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

---*/

{
    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));


    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter = Perm3FindAdapter;
    hwInitData.HwInitialize = Perm3Initialize;
    hwInitData.HwStartIO = Perm3StartIO;
    hwInitData.HwResetHw = Perm3ResetHW;
    hwInitData.HwInterrupt = Perm3VideoInterrupt;
    hwInitData.HwGetPowerState = Perm3GetPowerState;
    hwInitData.HwSetPowerState = Perm3SetPowerState;
    hwInitData.HwGetVideoChildDescriptor = Perm3GetChildDescriptor;
    hwInitData.HwQueryInterface = Perm3QueryInterface;

    //
    // Declare the legacy resources
    //

    hwInitData.HwLegacyResourceList = Perm3LegacyResourceList;
    hwInitData.HwLegacyResourceCount = Perm3LegacyResourceEntries;

    //
    // This device only supports the PCI bus.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    //
    // Determine the size required for the device extension.
    //
  
    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    initializationStatus = VideoPortInitialize (Context1,
                                                Context2,
                                                &hwInitData,
                                                NULL);

#ifdef SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA
//
//  This check will only be compiled under a Windows XP build environment where
//  the size of VIDEO_HW_INITIALIZATION_DATA has changed relative to Windows 2000
//  and therefore SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA is defined in order to
//  be able to load (in case of need) under Windows 2000
//
    if(initializationStatus != NO_ERROR) {
  
        //
        // This is to make sure the driver could load on Win2k as well
        //

        hwInitData.HwInitDataSize = SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA;

        //
        // We will only support QueryInterface on WinXP
        //

        hwInitData.HwQueryInterface = NULL;

        initializationStatus = VideoPortInitialize(Context1,
                                                   Context2,
                                                   &hwInitData,
                                                   NULL);
    }
#endif // SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA

    return initializationStatus;

} // end DriverEntry()

VP_STATUS 
Perm3FindAdapter (
    PVOID HwDeviceExtension, 
    PVOID HwContext, 
    PWSTR ArgumentString, 
    PVIDEO_PORT_CONFIG_INFO ConfigInfo, 
    PUCHAR Again
    )

/*+++

Routine Description:

    This routine gets the access ranges for a device on an enumerable
    bus and, if necessary, determines the device type.

Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

    HwContext
        Is NULL and should be ignored by the miniport.

    ArgumentString
        Suuplies a NULL terminated ASCII string. This string originates
        from the user. This pointer can be NULL.

    ConfigInfo
        Points to a VIDEO_PORT_CONFIG_INFO structure. The video port driver 
        allocates memory for and initializes this structure with any known 
        configuration information, such as values the miniport driver set 
        in the VIDEO_HW_INITIALIZATION_DATA and the SystemIoBusNumber. 

    Again
        Should be ignored by the miniport driver. 

Return Value:

    This routine must return one of the following status codes:

    NO_ERROR
        Indicates success.

    ERROR_INVALID_PARAMETER
        Indicates that the adapter could not be properly configured or
        information was inconsistent. (NOTE: This does not mean that the
        adapter could not be initialized. Miniports must not attempt to
        initialize the adapter in this routine.)

    ERROR_DEV_NOT_EXIST
        Indicates, for a non-enumerable bus, that the miniport driver could
        not find the device.

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    VideoDebugPrint((3, "Perm3: Perm3FindAdapter called for bus %d. hwDeviceExtension at 0x%x\n", 
                         ConfigInfo->SystemIoBusNumber, hwDeviceExtension));

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting.
    //

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) {

        VideoDebugPrint((0, "Perm3: bad size for VIDEO_PORT_CONFIG_INFO\n"));
        return (ERROR_INVALID_PARAMETER);
    }

    if(!Perm3ConfigurePci(hwDeviceExtension)) {

        VideoDebugPrint((0, "Perm3: Perm3ConfigurePci failed! \n"));
        return (ERROR_INVALID_PARAMETER);
    }

    if (!Perm3AssignResources(hwDeviceExtension)) {

        VideoDebugPrint((0, "Perm3: Perm3AssignResources failed! \n"));
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // For I2C support we want to be able to associate a hwId with a
    // child device.  Use the new VideoPortGetAssociatedDeviceID call
    // to get this information.
    //
    // This call will return NULL on Win2k but this is ok, because we
    // won't expose QueryInterface on Win2k, and thus will not try
    // to use this function.
    //

    hwDeviceExtension->WinXpVideoPortGetAssociatedDeviceID =
        ConfigInfo->VideoPortGetProcAddress(hwDeviceExtension,
                                            "VideoPortGetAssociatedDeviceID");

    hwDeviceExtension->WinXpSp1VideoPortRegisterBugcheckCallback =
        ConfigInfo->VideoPortGetProcAddress(hwDeviceExtension,
                                            "VideoPortRegisterBugcheckCallback");

    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength = 0x00020000;

    //
    // Will be initialized in BuildInitializationTable
    //

    hwDeviceExtension->culTableEntries = 0;

    //
    // Will be initialized in ConstructValidModesList
    //

    hwDeviceExtension->pFrequencyDefault = NULL;

    //
    // We'll set this TRUE when in InitializeVideo after programming the VTG
    //

    hwDeviceExtension->bVTGRunning = FALSE;

    //
    // Set up the defaults to indicate that we couldn't allocate a buffer 
    //

    hwDeviceExtension->LineDMABuffer.virtAddr = 0;
    hwDeviceExtension->LineDMABuffer.size = 0;
    hwDeviceExtension->LineDMABuffer.cacheEnabled = FALSE;
    hwDeviceExtension->BiosVersionMajorNumber = 0xffffffff;
    hwDeviceExtension->BiosVersionMinorNumber = 0xffffffff;
    hwDeviceExtension->ChipClockSpeed = 0;
    hwDeviceExtension->ChipClockSpeedAlt = 0;
    hwDeviceExtension->RefClockSpeed = 0;
    hwDeviceExtension->bMonitorPoweredOn = TRUE;
    hwDeviceExtension->PreviousPowerState = VideoPowerOn;

    if ((ConfigInfo->BusInterruptLevel | ConfigInfo->BusInterruptVector) != 0) {

        hwDeviceExtension->Capabilities |= CAPS_INTERRUPTS;
    }

    if (hwDeviceExtension->deviceInfo.DeviceId == PERMEDIA4_ID) {
        hwDeviceExtension->Capabilities |= CAPS_DISABLE_OVERLAY;
    }

    //
    // If the support is present; register a bugcheck callback
    //
    // Release Note:
    //
    // Due to the way that data is collected, the size of the bugcheck data
    // collection buffer needs to be padded by BUGCHECK_DATA_SIZE_RESERVED.
    // Thus if you want to collect X bytes of data, you need to request
    // X + BUGCHECK_DATA_SIZE_RESERVED.
    // For XPSP1 and Windows Server 2003 the limit for X is 0xF70 bytes.
    //

    if (hwDeviceExtension->WinXpSp1VideoPortRegisterBugcheckCallback) {

        hwDeviceExtension->WinXpSp1VideoPortRegisterBugcheckCallback(
            hwDeviceExtension,
            0xEA,
            Perm3BugcheckCallback,
            PERM3_BUGCHECK_DATA_SIZE + BUGCHECK_DATA_SIZE_RESERVED);
    }

    return(NO_ERROR);

} // end Perm3FindAdapter()

BOOLEAN 
Perm3AssignResources(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:

    This routine allocates resources required by a device

---*/

{
    VIDEO_ACCESS_RANGE *aAccessRanges = hwDeviceExtension->PciAccessRange;
    ULONG cAccessRanges = sizeof(hwDeviceExtension->PciAccessRange) / sizeof(VIDEO_ACCESS_RANGE);
    VP_STATUS status;
    
    VideoPortZeroMemory((PVOID)aAccessRanges, 
                        cAccessRanges * sizeof(VIDEO_ACCESS_RANGE));

    status = VideoPortGetAccessRanges(hwDeviceExtension, 
                                      0, 
                                      NULL, 
                                      cAccessRanges, 
                                      aAccessRanges,
                                      NULL, 
                                      NULL, 
                                      (PULONG) &(hwDeviceExtension->pciSlot));

    if (status != NO_ERROR) {
            
        VideoDebugPrint((0, "Perm3: VideoPortGetAccessRanges failed. error 0x%x\n", status));
        return(FALSE);
    }

    return(TRUE);
}

BOOLEAN 
Perm3ConfigurePci(
    PVOID HwDeviceExtension
    )

/*+++

Routine Description:

    This routine gets information from PCI config space and turn on memory 
    and busmaster enable bits.

Return Value:

     TRUE if successful

---*/
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PCI_COMMON_CONFIG PciConfig;
    PCI_COMMON_CONFIG *PciData = &PciConfig;
    ULONG ul;
    UCHAR *ajPciData;
    UCHAR ChipCapPtr;

    //
    // When accessing the chip's PCI config region, be sure not to
    // touch the indirect access registers. Gamma has an EEPROM access 
    // reigter @ 0x80, Perm3 have indirect access registers from 0xF8.
    //

    ul = VideoPortGetBusData(hwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             PciData, 
                             0, 
                             80);

    if(ul == 0) {

        VideoDebugPrint((0, "Perm3: VideoPortGetBusData Failed \n"));
        return (FALSE);
    }     

    hwDeviceExtension->deviceInfo.VendorId = PciConfig.VendorID;
    hwDeviceExtension->deviceInfo.DeviceId = PciConfig.DeviceID;
    hwDeviceExtension->deviceInfo.RevisionId = PciConfig.RevisionID;
    hwDeviceExtension->deviceInfo.SubsystemId = PciConfig.u.type0.SubSystemID;
    hwDeviceExtension->deviceInfo.SubsystemVendorId = PciConfig.u.type0.SubVendorID;
    hwDeviceExtension->deviceInfo.GammaRevId = 0;
    hwDeviceExtension->deviceInfo.DeltaRevId = 0;

    //
    // in multi-adapter systems we need to check if the device is 
    // decoding VGA resource
    //

    VideoPortGetVgaStatus( HwDeviceExtension, &ul);
    hwDeviceExtension->bVGAEnabled = (ul & DEVICE_VGA_ENABLED) ? TRUE : FALSE;

    //
    // Find the board capabilities
    //

    hwDeviceExtension->Perm3Capabilities =
                       GetBoardCapabilities(hwDeviceExtension, 
                                            PciData->u.type0.SubVendorID, 
                                            PciData->u.type0.SubSystemID);

    //
    // Determin if it is a AGP card by searching the AGP_CAP_ID
    //

    ajPciData = (UCHAR *)PciData;
    ChipCapPtr = ajPciData[AGP_CAP_PTR_OFFSET];

    hwDeviceExtension->bIsAGP = FALSE;

    while (ChipCapPtr && (ajPciData[ChipCapPtr] != AGP_CAP_ID)) {

        //
        // follow the next ptr    
        //

        ChipCapPtr = ajPciData[ChipCapPtr+1];
    }

    if(ajPciData[ChipCapPtr] == AGP_CAP_ID) {

        hwDeviceExtension->bIsAGP = TRUE;
    }

    PciData->LatencyTimer = 0xff;
    PciData->Command |= (PCI_ENABLE_MEMORY_SPACE | PCI_ENABLE_BUS_MASTER);

    ul = VideoPortSetBusData(HwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             PciData, 
                             0, 
                             PCI_COMMON_HDR_LENGTH);    

    if (ul < PCI_COMMON_HDR_LENGTH) {
        return (FALSE);
    }

    return (TRUE);
}

ULONG
GetBoardCapabilities(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG SubvendorID, 
    ULONG SubdeviceID
    )
/*+++

Routine Description:

    Return a list of capabilities of the perm3 board. 

---*/
{
    PERM3_CAPS Perm3Caps = 0;

    if (SubvendorID == SUBVENDORID_3DLABS) {
   
        //
        // Check for SGRAM and DFP
        //
        switch (SubdeviceID) {

            case SUBDEVICEID_P3_VX1_1600SW:       
                Perm3Caps |= PERM3_DFP; 
                break;
        }

    }

    return (Perm3Caps);
}


BOOLEAN 
Perm3Initialize(
    PVOID HwDeviceExtension
    )

/*+++

Routine Description:

    This routine does one time initialization of the device

Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

Return Value:

    TRUE if successful

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS vpStatus;
    ULONG ul;
    pPerm3ControlRegMap pCtrlRegs;

    VideoDebugPrint((3, "Perm3: Perm3Initialize called, hwDeviceExtension = %p\n", hwDeviceExtension));

    //
    // Map the control register, framebufer and initialize memory control 
    // registers on the way
    //

    if(!MapResource(hwDeviceExtension)) {

        VideoDebugPrint((0, "Perm3: failed to map the framebuffer and control registers\n"));
        return(FALSE);
    }

    //
    // At this time ctrlRegBase should be initialized
    //

    pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
    hwDeviceExtension->pRamdac = &(pCtrlRegs->ExternalVideo);

    hwDeviceExtension->DacId = P3RD_RAMDAC;
    hwDeviceExtension->deviceInfo.ActualDacId = P3RD_RAMDAC;
    hwDeviceExtension->deviceInfo.BoardId = PERMEDIA3_BOARD;

    if(!hwDeviceExtension->bIsAGP) {

        ul = VideoPortReadRegisterUlong(CHIP_CONFIG);
        ul &= ~(1 << 9);
        VideoPortWriteRegisterUlong(CHIP_CONFIG, ul);
    }

    //
    // Save hardware information to the registry
    //

    SetHardwareInfoRegistries(hwDeviceExtension);

    ConstructValidModesList(hwDeviceExtension, 
                            &hwDeviceExtension->monitorInfo);

    if (hwDeviceExtension->monitorInfo.numAvailableModes == 0) {
   
        VideoDebugPrint((0, "Perm3: No video modes available\n"));
        return(FALSE);
    }

    //
    // if we have interrupts available do any interrupt initialization.
    //

    if (hwDeviceExtension->Capabilities & CAPS_INTERRUPTS) {

        if (!Perm3InitializeInterruptBlock(hwDeviceExtension))
            hwDeviceExtension->Capabilities &= ~CAPS_INTERRUPTS;
    }

    return TRUE;

} // end Perm3Initialize()


VOID
SetHardwareInfoRegistries(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:

    Determine the hardware information and save them in the registry

---*/
{
    PWSTR pwszChip, pwszDAC, pwszAdapterString, pwszBiosString, pwsz;
    ULONG cbChip, cbDAC, cbAdapterString, cbBiosString, ul;
    WCHAR StringBuffer[60];
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // Get the device name
    //

    cbChip = sizeof(L"3Dlabs PERMEDIA 3");
    pwszChip = L"3Dlabs PERMEDIA 3";

    //
    // Get the board name
    //

    if(hwDeviceExtension->deviceInfo.SubsystemVendorId == SUBVENDORID_3DLABS){
                                 
        switch (hwDeviceExtension->deviceInfo.SubsystemId) {
           
            case SUBDEVICEID_P3_32D_AGP:
                cbAdapterString = sizeof(L"3Dlabs Permedia3 Create!");
                pwszAdapterString = L"3Dlabs Permedia3 Create!";
                break;

            case SUBDEVICEID_P3_VX1_AGP:
            case SUBDEVICEID_P3_VX1_PCI:
                cbAdapterString = sizeof(L"3Dlabs Oxygen VX1");
                pwszAdapterString = L"3Dlabs Oxygen VX1";
                break;

            case SUBDEVICEID_P3_VX1_1600SW:
                cbAdapterString = sizeof(L"3Dlabs Oxygen VX1 1600SW");
                pwszAdapterString = L"3Dlabs Oxygen VX1 1600SW";
                break;

            default:
                cbAdapterString = sizeof(L"3Dlabs PERMEDIA 3");
                pwszAdapterString = L"3Dlabs PERMEDIA 3";
                break;
        }

    } else {
      
        //
        // Non-3Dlabs board, just call it a P3
        //

        cbAdapterString = sizeof(L"PERMEDIA 3");
        pwszAdapterString = L"PERMEDIA 3";
    }
    
    //
    // Get the RAMDAC name
    //

    pwszDAC = L"3Dlabs P3RD";
    cbDAC = sizeof(L"3Dlabs P3RD");

    //
    // get the BIOS version number string
    //

    pwszBiosString = StringBuffer;
    cbBiosString = sizeof(L"Version ");
    VideoPortMoveMemory((PVOID)StringBuffer, (PVOID)(L"Version "), cbBiosString);

    pwsz = pwszBiosString + (cbBiosString >> 1) - 1; // position on L'\0';

    if(hwDeviceExtension->BiosVersionMajorNumber != 0xffffffff) {
   
        ul = UlongToString(hwDeviceExtension->BiosVersionMajorNumber, pwsz);
        cbBiosString += ul << 1;
        pwsz += ul;

        *pwsz++ = L'.';
        cbBiosString += sizeof(L'.');

        ul = UlongToString(hwDeviceExtension->BiosVersionMinorNumber, pwsz);
        cbBiosString += ul << 1;
    }

    //
    // We now have a complete hardware description of the hardware.
    // Save the information to the registry so it can be used by
    // configuration programs - such as the display applet.
    //

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   pwszDAC,
                                   cbDAC);

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    VideoPortSetRegistryParameters(hwDeviceExtension,
                                   L"HardwareInformation.BiosString",
                                   pwszBiosString,
                                   cbBiosString);
}

ULONG 
UlongToString(
    ULONG i, 
    PWSTR pwsz
    )

/*+++

Arguments:

    i
        Input number

    pwsz
        Output wide string: it is the user's responsibility to ensure this
        is wide enough

Return Value:

    Number of wide characters returned in pwsz

---*/

{
    ULONG j, k;
    BOOLEAN bSignificantDigit = FALSE;
    ULONG cwch = 0;

    if(i == 0) {

        *pwsz++ = L'0';
        ++cwch;

    } else {

        //
        // maxmium 10^n representable in a ulong
        //

        j = 1000000000;

        while(i || j) {
        
            if(i && i >= j) {
           
                k = i / j;
                i -= k * j;
                bSignificantDigit = TRUE;

            } else {

                k = 0;
            }

            if(k || bSignificantDigit) {
            
                *pwsz++ = L'0' + (WCHAR)k;
                ++cwch;
            }

            j /= 10;
        }
    }

    *pwsz = L'\0';

    return(cwch);
}
 

BOOLEAN 
MapResource(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:

    Get the mapped addresses of the control registers and framebuffer 


Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

Return Value: 

    TRUE if successful

---*/

{
    VIDEO_ACCESS_RANGE *pciAccessRange = hwDeviceExtension->PciAccessRange;
    ULONG fbMappedSize, fbRealSize;
    ULONG sz;
    pPerm3ControlRegMap pCtrlRegs;

    //
    //  Map Control Registers
    //

    pCtrlRegs = 
         VideoPortGetDeviceBase(hwDeviceExtension,
                                pciAccessRange[PCI_CTRL_BASE_INDEX].RangeStart,
                                pciAccessRange[PCI_CTRL_BASE_INDEX].RangeLength,
                                pciAccessRange[PCI_CTRL_BASE_INDEX].RangeInIoSpace);

    if (pCtrlRegs == NULL) {

        VideoDebugPrint((0, "Perm3: map control register failed\n"));
        return FALSE;
    }

    hwDeviceExtension->ctrlRegBase[0] = pCtrlRegs;

    //
    // Map Framebuffer
    //
    
    pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

    hwDeviceExtension->pFramebuffer = 
            VideoPortGetDeviceBase(hwDeviceExtension, 
                                   pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                                   pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                                   pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace);

    if(hwDeviceExtension->pFramebuffer == NULL) {

        //
        // If we failed to map the whole range for some reason then try to
        // map part of it. We reduce the amount we map till we succeed
        // or the size gets to zero in which case we really have failed.
        //

        for (sz = pciAccessRange[PCI_FB_BASE_INDEX].RangeLength; 
             sz > 0; 
             sz -= 1024*1024) {
       
            pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            hwDeviceExtension->pFramebuffer = 
                    VideoPortGetDeviceBase(hwDeviceExtension, 
                                           pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                                           sz,
                                           pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace);

            if(hwDeviceExtension->pFramebuffer != NULL) {
                pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = sz;
                break;
            }
        }

        //
        // if sz is zero, well we tried ...
        //

        if (sz == 0) {

            VideoDebugPrint((0, "Perm3: map framebuffer failed\n"));
            return(FALSE);
        }   
    }

    VideoDebugPrint((3, "Perm3: FB mapped at 0x%x for length 0x%x (%s)\n", 
                         hwDeviceExtension->pFramebuffer, 
                         pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                         pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace ? "I/O Ports" : "MemMapped"));

    //
    // Initialize the RAM registers and then probe the framebuffer size
    //

    InitializePostRegisters(hwDeviceExtension);

    fbMappedSize = pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    if ((fbRealSize = ProbeRAMSize (hwDeviceExtension, 
                                    hwDeviceExtension->pFramebuffer, 
                                    fbMappedSize)) == 0 ) {

        VideoPortFreeDeviceBase(hwDeviceExtension, 
                                hwDeviceExtension->pFramebuffer);

        VideoDebugPrint((0, "perm3: ProbeRAMSize returned 0\n"));
        return (FALSE);
    }

    if (fbRealSize < fbMappedSize) {

        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = fbRealSize;

        VideoDebugPrint((3, "perm3: RAM dynamically resized to length 0x%x\n",
                             fbRealSize));
    }

    //
    // Finally, if the RAM size is actually smaller than the region that
    // we mapped, remap to the smaller size to save on page table entries.
    //

    if (fbMappedSize > pciAccessRange[PCI_FB_BASE_INDEX].RangeLength) {
   
        VideoPortFreeDeviceBase(hwDeviceExtension, 
                                hwDeviceExtension->pFramebuffer);

        pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

        if ((hwDeviceExtension->pFramebuffer =
                     VideoPortGetDeviceBase(hwDeviceExtension,
                                            pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                                            pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                                            pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace
                                            )) == NULL) {
            //
            // This shouldn't happen but we'd better check
            //

            VideoDebugPrint((0, "Perm3: Remap of framebuffer to smaller size failed!\n"));
            return FALSE;
        }

        VideoDebugPrint((3, "Perm3: Remapped framebuffer memory to 0x%x, size 0x%x\n",
                             hwDeviceExtension->pFramebuffer,
                             pciAccessRange[PCI_FB_BASE_INDEX].RangeLength));
    }

    //
    // Record the size of the video memory.
    //

    hwDeviceExtension->PhysicalFrameIoSpace = 0;
    hwDeviceExtension->AdapterMemorySize = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    //
    // Record Frame buffer information
    //

    hwDeviceExtension->PhysicalFrameAddress = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeStart;
    hwDeviceExtension->FrameLength = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    //
    // Record Control Register information
    //

    hwDeviceExtension->PhysicalRegisterAddress = 
                       pciAccessRange[PCI_CTRL_BASE_INDEX].RangeStart;
    hwDeviceExtension->RegisterLength = 
                       pciAccessRange[PCI_CTRL_BASE_INDEX].RangeLength;
    hwDeviceExtension->RegisterSpace = 
                       pciAccessRange[PCI_CTRL_BASE_INDEX].RangeInIoSpace;

    return(TRUE);
}

    
ULONG 
ProbeRAMSize(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PULONG FBBaseAddress, 
    ULONG FBMappedSize
    )
/*+++

Routine Description:

    Dynamically size the on-board memory for the Permedia3

Arguments:

    HwDeviceExtension
        Supplies a pointer to the miniport's device extension.

    FBBaseAddress
        Starting address of framebuffer 

    FBMappedSize
        Mapped size

Return Value:

    Size, in bytes, of the memory.

---*/

{
    PULONG pV, pVStart, pVEnd;
    ULONG  realFBLength, testPattern, probeSize, temp, startLong1, startLong2;
    ULONG_PTR ulPtr;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // Dynamically size the SGRAM/SDRAM. Sample every 128K. We start
    // at the end of memory and work our way up writing the address into 
    // memory at that address. We do this every 'probeSize' DWORDS.
    // We then validate the data by reading it back again, starting from
    // the end of memory working our way up until we read a value back 
    // from memory that matches the address that we are at.
    //
    // Note that this algorithm does a destructive test of memory !!
    //

    testPattern = 0x55aa33cc;
    probeSize = (128 * 1024 / sizeof(ULONG));   // In DWords
    pVStart = (PULONG)FBBaseAddress;
    pVEnd = (PULONG)((ULONG_PTR)pVStart + (ULONG_PTR)FBMappedSize);

    //
    // Check out address zero, just in case the memory is really messed up.
    // We also save away the first 2 long words and restore them at the end, 
    // otherwise our boot screen looks wonky.
    //

    startLong1 = VideoPortReadRegisterUlong(pVStart);
    startLong2 = VideoPortReadRegisterUlong(pVStart+1);
    VideoPortWriteRegisterUlong(pVStart, testPattern);
    VideoPortWriteRegisterUlong(pVStart+1, 0);

    if ((temp = VideoPortReadRegisterUlong(pVStart)) != testPattern) {
   
        VideoDebugPrint((0, "Perm3: Cannot access SGRAM/SDRAM. Expected 0x%x, got 0x%x\n", testPattern, temp));
        realFBLength = 0;

    } else {
   
        //
        // Restore first 2 long words otherwise we end up with a corrupt
        // VGA boot screen
        //

        VideoPortWriteRegisterUlong(pVStart, startLong1);
        VideoPortWriteRegisterUlong(pVStart+1, startLong2);

        //
        // Write the memory address at the memory address, starting from the
        // end of memory and working our way down.
        //

        for (pV = pVEnd - probeSize; pV >= pVStart; pV -= probeSize) {

            ulPtr = (ULONG_PTR)pV & 0xFFFFFFFF;
            VideoPortWriteRegisterUlong(pV, (ULONG) ulPtr);
        }

        //
        // Read the data at the memory address, starting from the end of memory
        // and working our way down. If the address is correct then we stop and
        // work out the memory size.
        //

        for (pV = pVEnd - probeSize; pV >= pVStart; pV -= probeSize) {
       
            ulPtr = (ULONG_PTR)pV & 0xFFFFFFFF;

            if (VideoPortReadRegisterUlong(pV) == (ULONG) ulPtr) {
                pV += probeSize;
                break;
            }
        }
        
        realFBLength = (ULONG)((PUCHAR) pV - (PUCHAR) pVStart);
    }

    //
    // Restore first 2 long words again, otherwise we end up with a corrupt
    // VGA boot screen
    //

    VideoPortWriteRegisterUlong(pVStart, startLong1);
    VideoPortWriteRegisterUlong(pVStart+1, startLong2);

    VideoDebugPrint((3, "Perm3: ProbeRAMSize returning length %d (0x%x) bytes\n", realFBLength, realFBLength));
    return (realFBLength);
}

VOID
InitializePostRegisters(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
{
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // Build the initialization table if it is empty
    //

    if (hwDeviceExtension->culTableEntries == 0) {

        BuildInitializationTable(hwDeviceExtension);
    }

    ASSERT(hwDeviceExtension->culTableEntries != 0); 
    
    ProcessInitializationTable(hwDeviceExtension);

    VideoPortWriteRegisterUlong(APERTURE_ONE, 0x0);
    VideoPortWriteRegisterUlong(APERTURE_TWO, 0x0);
    VideoPortWriteRegisterUlong(BYPASS_WRITE_MASK, 0xFFFFFFFF);
}


VOID
ConstructValidModesList(
    PVOID HwDeviceExtension,
    MONITOR_INFO *mi
    )

/*+++

Routine Description:

    Here we prune valid modes, based on rules according to the chip
    capabilities and memory requirements.

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PPERM3_VIDEO_FREQUENCIES FrequencyEntry;
    PPERM3_VIDEO_MODES ModeEntry;
    BOOLEAN AllowForZBuffer;
    LONG AdapterMemorySize;
    ULONG ModeIndex, i;
    ULONG localBufferSizeInBytes = 2;

    AllowForZBuffer = TRUE;

    mi->numAvailableModes = 0;

    //
    // Since there are a number of frequencies possible for each
    // distinct resolution/colour depth, we cycle through the
    // frequency table and find the appropriate mode entry for that
    // frequency entry.
    //

    if (!BuildFrequencyList(hwDeviceExtension, mi))
        return;

    for (FrequencyEntry = mi->frequencyTable, ModeIndex = 0;
         FrequencyEntry->BitsPerPel != 0;
         FrequencyEntry++, ModeIndex++) {

        //
        // Find the mode for this entry.  First, assume we won't find one.
        //

        FrequencyEntry->ModeValid = FALSE;
        FrequencyEntry->ModeIndex = ModeIndex;

        for (ModeEntry = Perm3Modes, i = 0;  
             i < NumPerm3VideoModes; 
             ModeEntry++, i++) {

            if ((FrequencyEntry->BitsPerPel ==
                    ModeEntry->ModeInformation.BitsPerPlane) &&
                (FrequencyEntry->ScreenHeight ==
                    ModeEntry->ModeInformation.VisScreenHeight) &&
                (FrequencyEntry->ScreenWidth ==
                    ModeEntry->ModeInformation.VisScreenWidth)) {

                AdapterMemorySize = (LONG)hwDeviceExtension->AdapterMemorySize;

                //
                // Allow for a Z buffer on Permedia3. It's always 16 bits deep.
                //

                if (AllowForZBuffer) {
                    AdapterMemorySize -= 
                          (LONG)(ModeEntry->ModeInformation.VisScreenWidth *
                                 ModeEntry->ModeInformation.VisScreenHeight *
                                 localBufferSizeInBytes);
                }

                //
                // If we need to be double buffered then we only have half this
                // remainder for the visible screen. 12bpp is special since
                // each pixel contains both front and back.
                //

                if ((FrequencyEntry->BitsPerPel != 12))
                    AdapterMemorySize /= 2;

                //
                // We've found a mode table entry that matches this frequency
                // table entry.  Now we'll figure out if we can actually do
                // this mode/frequency combination.  For now, assume we'll
                // succeed.
                //

                FrequencyEntry->ModeEntry = ModeEntry;
                FrequencyEntry->ModeValid = TRUE;

                VideoDebugPrint((3, "Perm3: Trying mode: %dbpp, w x h %d x %d @ %dHz... ",
                                ModeEntry->ModeInformation.BitsPerPlane,
                                ModeEntry->ModeInformation.VisScreenWidth,
                                ModeEntry->ModeInformation.VisScreenHeight,
                                FrequencyEntry->ScreenFrequency
                                ));

                //
                // Rule: Refuses to handle <60Hz refresh.
                //

                if( (FrequencyEntry->ScreenFrequency < 60) && 
                    !(hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED) ) {

                    FrequencyEntry->ModeValid = FALSE;
                }

                if( (hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED) &&
                    (FrequencyEntry->BitsPerPel == 8) ) {

                     FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Rule: On Perm3, if this is an eight-bit mode that requires
                // us to use byte doubling then the pixel-clock validation is 
                // more strict because we have to double the pixel clock.
                //

                if (FrequencyEntry->BitsPerPel == 8) {

                    VESA_TIMING_STANDARD  VESATimings;

                    //
                    // Get the timing parameters for this mode.
                    //

                    if (GetVideoTiming(HwDeviceExtension,
                                        ModeEntry->ModeInformation.VisScreenWidth,
                                        ModeEntry->ModeInformation.VisScreenHeight,
                                        FrequencyEntry->ScreenFrequency,
                                        FrequencyEntry->BitsPerPel,
                                        &VESATimings)) {

                        if ( P3RD_CHECK_BYTE_DOUBLING (hwDeviceExtension, 
                                                       FrequencyEntry->BitsPerPel, 
                                                       &VESATimings) &&
                            (VESATimings.pClk << 1) > P3_MAX_PIXELCLOCK ) {

                            VideoDebugPrint((3, "Perm3: Bad 8BPP pixelclock\n"));
                            FrequencyEntry->ModeValid = FALSE;
                        }

                    } else {

                            VideoDebugPrint((0, "Perm3: GetVideoTiming failed\n"));
                            FrequencyEntry->ModeValid = FALSE;
                        }
                    }

                //
                // Rule: Do not support 15BPP (555 mode)
                //

                if ( FrequencyEntry->BitsPerPel == 15 ) {

                    FrequencyEntry->ModeValid = FALSE;
                }  

                ModeEntry->ModeInformation.ScreenStride = ModeEntry->ScreenStrideContiguous;

                //
                // Rule: We have to have enough memory to handle the mode.                
                //

                if ((LONG)(ModeEntry->ModeInformation.VisScreenHeight *
                           ModeEntry->ModeInformation.ScreenStride) >
                           AdapterMemorySize) {

                    FrequencyEntry->ModeValid = FALSE;
                }

                //
                // Rule: No 12 bpp, only need 60Hz at 1280 true color.
                //

                {
                    ULONG pixelData;
                    ULONG DacDepth = FrequencyEntry->BitsPerPel;

                    //
                    // We need the proper pixel size to calculate timing values
                    //

                    if (DacDepth == 15) {
                        DacDepth = 16;
                    } else if (DacDepth == 12) {
                        DacDepth = 32;
                    }
                    
                    pixelData = FrequencyEntry->PixelClock * (DacDepth / 8);

                    if ((( FrequencyEntry->PixelClock > P3_MAX_PIXELCLOCK || 
                             pixelData > P3_MAX_PIXELDATA ))) {
                   
                        FrequencyEntry->ModeValid = FALSE;
                    }
               }

                //
                // Do not supports 24bpp
                //

                if(FrequencyEntry->BitsPerPel == 24) {
               
                    FrequencyEntry->ModeValid = FALSE;
                }

                //
                // For Permedia4, no mode smaller than 640x400 is supported
                //

                if (hwDeviceExtension->deviceInfo.DeviceId == PERMEDIA4_ID ) {

                    if ((FrequencyEntry->ScreenWidth < 640) ||
                        (FrequencyEntry->ScreenHeight < 400)) {

                        FrequencyEntry->ModeValid = FALSE;
                    }
                }

                //
                // Don't forget to count it if it's still a valid mode after
                // applying all those rules.
                //

                if ( FrequencyEntry->ModeValid ) {

                    if (hwDeviceExtension->pFrequencyDefault == NULL &&
                        ModeEntry->ModeInformation.BitsPerPlane == 8 &&
                        ModeEntry->ModeInformation.VisScreenWidth == 640 &&
                        ModeEntry->ModeInformation.VisScreenHeight == 480 ) {
                   
                        hwDeviceExtension->pFrequencyDefault = FrequencyEntry;
                    }

                    ModeEntry->ModeInformation.ModeIndex = mi->numAvailableModes++;
                }
                             
                //
                // We've found a mode for this frequency entry, so we
                // can break out of the mode loop:
                //

                break;
                                     
            }
        }
    }

    mi->numTotalModes = ModeIndex;

    VideoDebugPrint((3, "perm3: %d total modes\n", ModeIndex));
    VideoDebugPrint((3, "perm3: %d total valid modes\n", mi->numAvailableModes));
}


VP_STATUS
Perm3RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*+++

Routine Description:

    This routine is used to read back various registry values.

Arguments:

    HwDeviceExtension 
        Supplies a pointer to the miniport's device extension.

    Context 
        Context value passed to the get registry parameters routine.
        If this is not null assume it's a ULONG* and save the data value in it.

    ValueName
        Name of the value requested.

    ValueData
        Pointer to the requested data.

    ValueLength
        Length of the requested data.

Return Value:

    If the variable doesn't exist return an error,
    else if a context is supplied assume it's a PULONG and fill in the value
    and return no error, else if the value is non-zero return an error.

---*/

{
    if (ValueLength) {

        if (Context) {

            *(ULONG *)Context = *(PULONG)ValueData;

        } else if (*((PULONG)ValueData) != 0) {

            return ERROR_INVALID_PARAMETER;
        }

        return NO_ERROR;

    } else {

        return ERROR_INVALID_PARAMETER;
    }

} // end Perm3RegistryCallback()


BOOLEAN
Perm3ResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )

/*+++

Routine Description:

    This routine resets the adapter to character mode.

    THIS FUNCTION CANNOT BE PAGED.

Arguments:

    hwDeviceExtension
        Points to the miniport's per-adapter storage area. 

    Columns
        Specifies the number of columns of the mode to be set up.

    Rows
       Specifies the number of rows of the mode to be set up.

Return Value:

    We always return FALSE to force the HAL to do an INT10 reset.

---*/

{
    //
    // return false so the HAL does an INT10 mode 3
    //

    return(FALSE);
}

VOID
BuildInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )  

/*+++

Routine Description:

    Read the ROM, if any is present, and extract any data needed for 
    chip set-up

Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

---*/

{
    PVOID romAddress;
    
    romAddress = VideoPortGetRomImage(hwDeviceExtension,
                                      NULL,
                                      0,
                                      ROM_MAPPED_LENGTH);


    if (romAddress) {
   
        //
        // We'll take a copy of the initialization table in the exansion 
        // ROM now so that we can run through the initialization ourselves, 
        // later on
        //

        CopyROMInitializationTable(hwDeviceExtension, romAddress);

        //
        // Free the ROM address since we do not need it anymore.
        //

        romAddress = VideoPortGetRomImage(hwDeviceExtension, NULL, 0, 0);
                                          
    }

    if (hwDeviceExtension->culTableEntries == 0) {
   
        //
        // No initialization table, but Perm3 really needs one in order
        // to come out of sleep mode correctly. 
        //

        GenerateInitializationTable(hwDeviceExtension);
    }
}

VOID 
CopyROMInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    PVOID pvROMAddress
    )

/*+++

Routine Description:

    This function should be called for devices that have an expansion ROM
    which contains a register initialisation table. The function assumes
    the ROM is present.

Arguments:

    HwDeviceExtension
        Points to the device extension of the device whose ROM is to be read

    pvROMAddress
        Base address of the expansion ROM. This function assumes that the 
        offset to the initialization table is defined at 0x1c from the 
        beginning of ROM

---*/

{
    PULONG pulROMTable;
    PULONG pul;
    ULONG cEntries;
    ULONG ul, regHdr;

    hwDeviceExtension->culTableEntries = 0;

    //
    // The 2-byte offset to the initialization table is given at 0x1c
    // from the start of ROM
    //

    ul = VideoPortReadRegisterUshort((USHORT *)(0x1c + (PCHAR)pvROMAddress));
    pulROMTable = (PULONG)(ul + (PCHAR)pvROMAddress);
    
    //
    // The table header (32 bits) has an identification code and a count
    // of the number of entries in the table
    //

    regHdr = VideoPortReadRegisterUlong(pulROMTable++);

    while ((regHdr >> 16) == 0x3d3d) {
   
        ULONG BiosID = (regHdr >> 8) & 0xFF;

        switch (BiosID){
        
            case 0:

                //
                //    BIOS partition 0
                //    ----------------
                //    This BIOS region holds the memory timings for Perm3 chip.
                //    We also look up the version number.
                //

                //
                // the 2-byte BIOS version number in in the form of
                // <MajorNum>.<MinorNum>
                //

                hwDeviceExtension->BiosVersionMajorNumber =
                                  (ULONG)VideoPortReadRegisterUchar((PCHAR)(0x7 + (PCHAR)pvROMAddress) ); 
                                      
                hwDeviceExtension->BiosVersionMinorNumber = 
                                  (ULONG)VideoPortReadRegisterUchar((PCHAR)(0x8 + (PCHAR)pvROMAddress)); 

                //
                // number of register address & data pairs
                //

                cEntries = regHdr & 0xffff;

                if(cEntries > 0) {
               
                    //
                    // This assert, and the one after the copy should ensure
                    // we don't write past the end of the table
                    //

                    PERM3_ASSERT( cEntries * sizeof(ULONG) * 2 <= sizeof(hwDeviceExtension->aulInitializationTable), 
                                  "Perm3: too many initialization entries\n");

                    //
                    // Each entry contains two 32-bit words
                    //

                    pul = hwDeviceExtension->aulInitializationTable;
                    ul = cEntries << 1;

                    //
                    // Make sure we don't run out of the range
                    //

                    if( ul <= MAX_REGISTER_INITIALIZATION_TABLE_ULONGS &&
                        ul * sizeof(ULONG) + (ULONG)((PCHAR)pulROMTable - (PCHAR)pvROMAddress) <=
                              ROM_MAPPED_LENGTH ) {

                        while(ul--) {
                            *pul++ = VideoPortReadRegisterUlong(pulROMTable);
                            ++pulROMTable;
                        }

                        hwDeviceExtension->culTableEntries = 
                                          (ULONG)(pul - (ULONG *)hwDeviceExtension->aulInitializationTable) >> 1;

                        PERM3_ASSERT( cEntries == hwDeviceExtension->culTableEntries, 
                                      "Perm3: generated different size init table to that expected\n");

#if DBG
                        //
                        // Output the initialization table
                        //

                        pul = hwDeviceExtension->aulInitializationTable;
                        ul = hwDeviceExtension->culTableEntries;
     
                        while(ul--) {
                   
                            ULONG ulReg;
                            ULONG ulRegData;

                            ulReg = *pul++;
                            ulRegData = *pul++;
                            VideoDebugPrint((3, "Perm3: CopyROMInitializationTable: register %08.8Xh with %08.8Xh\n", 
                                             ulReg, ulRegData));
                        }
#endif
                    }

                }

                break;

            case 1:

                //
                //    BIOS partition 1
                //    ----------------
                //    This BIOS region holds the extended clock settings
                //    for Perm3 chips.
                //

                PERM3_ASSERT((regHdr & 0xffff) == 0x0103,  
                              "Perm3: Extended table doesn't have right cnt/ID\n");

                if ((ULONG)((PUCHAR)pulROMTable - (PUCHAR)pvROMAddress) + 5 * sizeof(ULONG) <=
                              ROM_MAPPED_LENGTH) {

                    //
                    // Some Perm3 boards have a whole set of clocks defined in
                    // the BIOS. The high nibble defines the source for the
                    // clock, this isn't relevant for anything but MCLK and
                    // SCLK on Perm3.
                    //

                    hwDeviceExtension->bHaveExtendedClocks  = TRUE;

                    hwDeviceExtension->ulPXRXCoreClock = 
                        ( VideoPortReadRegisterUlong(pulROMTable++) & 0xFFFFFF ) * 1000 * 1000;

                    hwDeviceExtension->ulPXRXMemoryClock = 
                        VideoPortReadRegisterUlong(pulROMTable++);

                    hwDeviceExtension->ulPXRXMemoryClockSrc = 
                        (hwDeviceExtension->ulPXRXMemoryClock >> 28) << 4;

                    hwDeviceExtension->ulPXRXMemoryClock = 
                        (hwDeviceExtension->ulPXRXMemoryClock & 0xFFFFFF) * 1000 * 1000;

                    hwDeviceExtension->ulPXRXSetupClock = 
                        VideoPortReadRegisterUlong(pulROMTable++);

                    hwDeviceExtension->ulPXRXSetupClockSrc = 
                        (hwDeviceExtension->ulPXRXSetupClock >> 28) << 4;

                    hwDeviceExtension->ulPXRXSetupClock = 
                        (hwDeviceExtension->ulPXRXSetupClock & 0xFFFFFF) * 1000 * 1000;

                    hwDeviceExtension->ulPXRXGammaClock = 
                        (VideoPortReadRegisterUlong(pulROMTable++) & 0xFFFFFF) * 1000 * 1000;

                    hwDeviceExtension->ulPXRXCoreClockAlt = 
                        (VideoPortReadRegisterUlong(pulROMTable++) & 0xFFFFFF) * 1000 * 1000;

                    VideoDebugPrint((3, "Perm3: core clock %d, core clock alt %d\n", 
                                         hwDeviceExtension->ulPXRXCoreClock, 
                                         hwDeviceExtension->ulPXRXCoreClockAlt));

                    VideoDebugPrint((3, "Perm3: Mem clock %d, mem clock src 0x%x\n", 
                                         hwDeviceExtension->ulPXRXMemoryClock, 
                                         hwDeviceExtension->ulPXRXMemoryClockSrc));

                    VideoDebugPrint((3, "Perm3: setup clock %d, setup clock src 0x%x\n", 
                                         hwDeviceExtension->ulPXRXSetupClock, 
                                         hwDeviceExtension->ulPXRXSetupClockSrc));

                    VideoDebugPrint((3, "Perm3: Gamma clock %d\n", 
                                         hwDeviceExtension->ulPXRXGammaClock));

                }

                break;
        
            default:
                VideoDebugPrint((3, "Perm3: Extended table doesn't have right cnt/ID !\n"));
        }
    
        if ((ULONG)((PUCHAR)pulROMTable - (PUCHAR)pvROMAddress) >= 
                                             ROM_MAPPED_LENGTH) {

            break;
        }
                     
        regHdr = VideoPortReadRegisterUlong(pulROMTable++);
    }
}

VOID 
GenerateInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:

    Creates a register initialization table (called if we can't read one
    from ROM). If VGA is enabled the registers are already initialized so
    we just read them back, otherwise we have to use default values

Arguments:

    HwDeviceExtension
        Points to the driver's per-device storage area.

---*/

{
    ULONG   cEntries;
    PULONG  pul;
    ULONG   ul;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    hwDeviceExtension->culTableEntries = 0;

    cEntries = 4;

    //
    // This assert, and the one after the copy should ensure we don't
    // write past the end of the table
    //

    PERM3_ASSERT(cEntries * sizeof(ULONG) * 2 <= sizeof(hwDeviceExtension->aulInitializationTable), 
                 "Perm3: too many initialization entries\n");

    //
    // Each entry contains two 32-bit words
    //

    pul = hwDeviceExtension->aulInitializationTable;

    if (hwDeviceExtension->bVGAEnabled) {
       
        //
        // No initialization table but VGA is running so our key
        // registers have been initialized to sensible values
        //

        //
        // key entries are: ROM control, Boot Address, Memory Config
        // and VStream Config
        //

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_CAPS);
        *pul++ = VideoPortReadRegisterUlong(PXRX_LOCAL_MEM_CAPS);

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_CONTROL);
        *pul++ = VideoPortReadRegisterUlong(PXRX_LOCAL_MEM_CONTROL);

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_REFRESH);
        *pul++ = VideoPortReadRegisterUlong(PXRX_LOCAL_MEM_REFRESH);

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_TIMING);
        *pul++ = VideoPortReadRegisterUlong(PXRX_LOCAL_MEM_TIMING);

    } else {

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_CAPS);
        *pul++ = 0x30E311B8;

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_CONTROL);
        *pul++ = 0x08000002; // figures for 80 MHz

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_REFRESH);
        *pul++ = 0x0000006B;

        *pul++ = CTRL_REG_OFFSET(PXRX_LOCAL_MEM_TIMING);
        *pul++ = 0x08501204;
    }

    hwDeviceExtension->culTableEntries = 
            (ULONG)(pul - (ULONG *)hwDeviceExtension->aulInitializationTable) >> 1;

#if DBG

    if (cEntries != hwDeviceExtension->culTableEntries)
        VideoDebugPrint((0, "Perm3: generated different size init table to that expected\n"));

    //
    // Output the initialization table
    //

    pul = hwDeviceExtension->aulInitializationTable;
    ul = hwDeviceExtension->culTableEntries;

    while(ul--) {
    
        ULONG ulReg;
        ULONG ulRegData;

        ulReg = *pul++;
        ulRegData = *pul++;
        VideoDebugPrint((3, "Perm3: GenerateInitializationTable: register %08.8Xh with %08.8Xh\n", 
                             ulReg, ulRegData));
    }

#endif

}

VOID 
ProcessInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*+++

Routine Description:
    This function processes the register initialization table

---*/

{
    PULONG  pul;
    ULONG   cul;
    ULONG   ulRegAddr, ulRegData;
    PULONG  pulReg;
    ULONG   BaseAddrSelect;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    pul = (PULONG)hwDeviceExtension->aulInitializationTable;
    cul = hwDeviceExtension->culTableEntries;

    while(cul--) {
   
        ulRegAddr = *pul++;
        ulRegData = *pul++;

        BaseAddrSelect = ulRegAddr >> 29;

        if(BaseAddrSelect == 0) {
       
            //
            // The offset is from the start of the control registers
            //

            pulReg = (PULONG)((ULONG_PTR)pCtrlRegs + (ulRegAddr & 0x3FFFFF));

        } else {

            continue;
        }

        VideoDebugPrint((3, "ProcessInitializationTable: initializing (region %d) register %08.8Xh with %08.8Xh\n", 
                             BaseAddrSelect, pulReg, ulRegData));

        VideoPortWriteRegisterUlong(pulReg, ulRegData);
    }

    //
    // We need a small delay after initializing the above registers
    //

    VideoPortStallExecution(5);

}

/*++

Routine Description:

    This function is called when a bugcheck EA occurs due to a failure in
    the perm3 display driver.  The callback allows the driver to collect
    information that will make diagnosing the problem easier.  This data
    is then added to the dump file that the system creates when the crash
    occurs.

Arguments:

    HwDeviceExtension
    Points to the device extension of the device whose ROM is to be read

    BugcheckCode
    The bugcheck code for which this callback is being invoked.  Currently
    this will always be 0xEA.

    Buffer
    The location into which you should write the data you want to append
    to the dump file.

    BufferSize
    The size of the buffer supplied.

Returns:

    none

Notes:

    This routine can be called at any time, and at any IRQL level.
    Thus you must not touch any pageable code or data in this function.

    USE_SYSTEM_RESERVED_SPACE code is for testing the usage of reserved
    space during the bugcheck callback
    
    HANG_IN_CALLBACK code is for testing the bugcheck recovery mechanism's
    response to a hang occuring in the bugcheck callback.

--*/

//#define HANG_IN_CALLBACK
//#define USE_SYSTEM_RESERVED_SPACE

VOID
Perm3BugcheckCallback(
    PVOID HwDeviceExtension,
    ULONG BugcheckCode,
    PUCHAR Buffer,
    ULONG BufferSize
    )

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG DataSize;
    
    //
    // Copy the data you want to append to the minidump here.  You may want
    // to collect data on the hardware state, driver state, or any other
    // data that may help you diagnose the 0xEA via the dump file.
    //

    static char szStart[] = "This is the sample perm3 bugcheck data!";
    static char szEnd[]   = "End of Data!";
    
    if (BufferSize <= BUGCHECK_DATA_SIZE_RESERVED) return;
    
    DataSize = min(PERM3_BUGCHECK_DATA_SIZE, 
                   BufferSize - BUGCHECK_DATA_SIZE_RESERVED);
    
#ifdef USE_SYSTEM_RESERVED_SPACE
    ++DataSize;
#endif //USE_SYSTEM_RESERVED_SPACE
    
    if (DataSize > (sizeof(szStart) + sizeof(szEnd))) {
        memset(Buffer, (int)'.', DataSize);
        memcpy(Buffer, szStart, sizeof(szStart) - 1);
        memcpy(Buffer + DataSize - sizeof(szEnd), szEnd, sizeof(szEnd));
    }
    else {
        strncpy(Buffer, szStart, DataSize);
    }
        
#ifdef HANG_IN_CALLBACK
    while (1);
#endif // HANG_IN_CALLBACK
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\bitblt.c ===
/******************************Module*Header*******************************\
* Module Name: bitblt.c
*
* Contains the high-level DrvBitBlt and DrvCopyBits functions.  The low-
* level stuff lives in 'bltio.c'.
*
* Note: Since we've implemented device-bitmaps, any surface that GDI passes
*       to us can have 3 values for its 'iType': STYPE_BITMAP, STYPE_DEVICE
*       or STYPE_DEVBITMAP.  We filter device-bitmaps that we've stored
*       as DIBs fairly high in the code, so after we adjust its 'pptlSrc',
*       we can treat STYPE_DEVBITMAP surfaces the same as STYPE_DEVICE
*       surfaces (e.g., a blt from an off-screen device bitmap to the screen
*       gets treated as a normal screen-to-screen blt).  So throughout
*       this code, we will compare a surface's 'iType' to STYPE_BITMAP:
*       if it's equal, we've got a true DIB, and if it's unequal, we have
*       a screen-to-screen operation.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if !GDI_BANKING || DBG

// This table is big, so include it only when we need it...

/******************************Public*Data*********************************\
* ROP3 translation table
*
* Translates the usual ternary rop into A-vector notation.  Each bit in
* this new notation corresponds to a term in a polynomial translation of
* the rop.
*
* Rop(D,S,P) = a + a D + a S + a P + a  DS + a  DP + a  SP + a   DSP
*               0   d     s     p     ds      dp      sp      dsp
*
\**************************************************************************/

BYTE gajRop3[] =
{
    0x00, 0xff, 0xb2, 0x4d, 0xd4, 0x2b, 0x66, 0x99,
    0x90, 0x6f, 0x22, 0xdd, 0x44, 0xbb, 0xf6, 0x09,
    0xe8, 0x17, 0x5a, 0xa5, 0x3c, 0xc3, 0x8e, 0x71,
    0x78, 0x87, 0xca, 0x35, 0xac, 0x53, 0x1e, 0xe1,
    0xa0, 0x5f, 0x12, 0xed, 0x74, 0x8b, 0xc6, 0x39,
    0x30, 0xcf, 0x82, 0x7d, 0xe4, 0x1b, 0x56, 0xa9,
    0x48, 0xb7, 0xfa, 0x05, 0x9c, 0x63, 0x2e, 0xd1,
    0xd8, 0x27, 0x6a, 0x95, 0x0c, 0xf3, 0xbe, 0x41,
    0xc0, 0x3f, 0x72, 0x8d, 0x14, 0xeb, 0xa6, 0x59,
    0x50, 0xaf, 0xe2, 0x1d, 0x84, 0x7b, 0x36, 0xc9,
    0x28, 0xd7, 0x9a, 0x65, 0xfc, 0x03, 0x4e, 0xb1,
    0xb8, 0x47, 0x0a, 0xf5, 0x6c, 0x93, 0xde, 0x21,
    0x60, 0x9f, 0xd2, 0x2d, 0xb4, 0x4b, 0x06, 0xf9,
    0xf0, 0x0f, 0x42, 0xbd, 0x24, 0xdb, 0x96, 0x69,
    0x88, 0x77, 0x3a, 0xc5, 0x5c, 0xa3, 0xee, 0x11,
    0x18, 0xe7, 0xaa, 0x55, 0xcc, 0x33, 0x7e, 0x81,
    0x80, 0x7f, 0x32, 0xcd, 0x54, 0xab, 0xe6, 0x19,
    0x10, 0xef, 0xa2, 0x5d, 0xc4, 0x3b, 0x76, 0x89,
    0x68, 0x97, 0xda, 0x25, 0xbc, 0x43, 0x0e, 0xf1,
    0xf8, 0x07, 0x4a, 0xb5, 0x2c, 0xd3, 0x9e, 0x61,
    0x20, 0xdf, 0x92, 0x6d, 0xf4, 0x0b, 0x46, 0xb9,
    0xb0, 0x4f, 0x02, 0xfd, 0x64, 0x9b, 0xd6, 0x29,
    0xc8, 0x37, 0x7a, 0x85, 0x1c, 0xe3, 0xae, 0x51,
    0x58, 0xa7, 0xea, 0x15, 0x8c, 0x73, 0x3e, 0xc1,
    0x40, 0xbf, 0xf2, 0x0d, 0x94, 0x6b, 0x26, 0xd9,
    0xd0, 0x2f, 0x62, 0x9d, 0x04, 0xfb, 0xb6, 0x49,
    0xa8, 0x57, 0x1a, 0xe5, 0x7c, 0x83, 0xce, 0x31,
    0x38, 0xc7, 0x8a, 0x75, 0xec, 0x13, 0x5e, 0xa1,
    0xe0, 0x1f, 0x52, 0xad, 0x34, 0xcb, 0x86, 0x79,
    0x70, 0x8f, 0xc2, 0x3d, 0xa4, 0x5b, 0x16, 0xe9,
    0x08, 0xf7, 0xba, 0x45, 0xdc, 0x23, 0x6e, 0x91,
    0x98, 0x67, 0x2a, 0xd5, 0x4c, 0xb3, 0xfe, 0x01
};

BYTE gaRop3FromMix[] =
{
    0xFF,  // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE          - Allow rop = gaRop3FromMix[mix & 0xFF]
};

#define AVEC_NOT            0x01
#define AVEC_D              0x02
#define AVEC_S              0x04
#define AVEC_P              0x08
#define AVEC_DS             0x10
#define AVEC_DP             0x20
#define AVEC_SP             0x40
#define AVEC_DSP            0x80
#define AVEC_NEED_SOURCE    (AVEC_S | AVEC_DS | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_PATTERN   (AVEC_P | AVEC_DP | AVEC_SP | AVEC_DSP)
#define AVEC_NEED_DEST      (AVEC_D | AVEC_DS | AVEC_DP | AVEC_DSP)

#endif // GDI_BANKING

/******************************Public*Table********************************\
* BYTE gaulHwMixFromRop2[]
*
* Table to convert from a Source and Destination Rop2 to the hardware's
* mix.
\**************************************************************************/

ULONG gaulHwMixFromRop2[] = {
    LOGICAL_0,                      // 00 -- 0      BLACKNESS
    NOT_SCREEN_AND_NOT_NEW,         // 11 -- DSon   NOTSRCERASE
    SCREEN_AND_NOT_NEW,             // 22 -- DSna
    NOT_NEW,                        // 33 -- Sn     NOSRCCOPY
    NOT_SCREEN_AND_NEW,             // 44 -- SDna   SRCERASE
    NOT_SCREEN,                     // 55 -- Dn     DSTINVERT
    SCREEN_XOR_NEW,                 // 66 -- DSx    SRCINVERT
    NOT_SCREEN_OR_NOT_NEW,          // 77 -- DSan
    SCREEN_AND_NEW,                 // 88 -- DSa    SRCAND
    NOT_SCREEN_XOR_NEW,             // 99 -- DSxn
    LEAVE_ALONE,                    // AA -- D
    SCREEN_OR_NOT_NEW,              // BB -- DSno   MERGEPAINT
    OVERPAINT,                      // CC -- S      SRCCOPY
    NOT_SCREEN_OR_NEW,              // DD -- SDno
    SCREEN_OR_NEW,                  // EE -- DSo    SRCPAINT
    LOGICAL_1                       // FF -- 1      WHITENESS
};

/******************************Public*Table********************************\
* BYTE gajHwMixFromMix[]
*
* Table to convert from a GDI mix value to the hardware's mix.
*
* Ordered so that the mix may be calculated from gajHwMixFromMix[mix & 0xf]
* or gajHwMixFromMix[mix & 0xff].
\**************************************************************************/

BYTE gajHwMixFromMix[] = {
    LOGICAL_1,                      // 0  -- 1
    LOGICAL_0,                      // 1  -- 0
    NOT_SCREEN_AND_NOT_NEW,         // 2  -- DPon
    SCREEN_AND_NOT_NEW,             // 3  -- DPna
    NOT_NEW,                        // 4  -- Pn
    NOT_SCREEN_AND_NEW,             // 5  -- PDna
    NOT_SCREEN,                     // 6  -- Dn
    SCREEN_XOR_NEW,                 // 7  -- DPx
    NOT_SCREEN_OR_NOT_NEW,          // 8  -- DPan
    SCREEN_AND_NEW,                 // 9  -- DPa
    NOT_SCREEN_XOR_NEW,             // 10 -- DPxn
    LEAVE_ALONE,                    // 11 -- D
    SCREEN_OR_NOT_NEW,              // 12 -- DPno
    OVERPAINT,                      // 13 -- P
    NOT_SCREEN_OR_NEW,              // 14 -- PDno
    SCREEN_OR_NEW,                  // 15 -- DPo
    LOGICAL_1                       // 16 -- 1
};

/******************************Public*Table********************************\
* BYTE gajLeftMask[] and BYTE gajRightMask[]
*
* Edge tables for vXferScreenTo1bpp.
\**************************************************************************/

BYTE gajLeftMask[]  = { 0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01 };
BYTE gajRightMask[] = { 0xff, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };

/******************************Public*Routine******************************\
* BOOL bIntersect
*
* If 'prcl1' and 'prcl2' intersect, has a return value of TRUE and returns
* the intersection in 'prclResult'.  If they don't intersect, has a return
* value of FALSE, and 'prclResult' is undefined.
*
\**************************************************************************/

BOOL bIntersect(
RECTL*  prcl1,
RECTL*  prcl2,
RECTL*  prclResult)
{
    prclResult->left  = max(prcl1->left,  prcl2->left);
    prclResult->right = min(prcl1->right, prcl2->right);

    if (prclResult->left < prclResult->right)
    {
        prclResult->top    = max(prcl1->top,    prcl2->top);
        prclResult->bottom = min(prcl1->bottom, prcl2->bottom);

        if (prclResult->top < prclResult->bottom)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* LONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
\**************************************************************************/

LONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    LONG    cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* VOID vXferScreenTo1bpp
*
* Performs a SRCCOPY transfer from the screen (when it's 8bpp) to a 1bpp
* bitmap.
*
\**************************************************************************/

#if defined(i386)

VOID vXferScreenTo1bpp(         // Type FNXFER
PDEV*       ppdev,
LONG        c,                  // Count of rectangles, can't be zero
RECTL*      prcl,               // List of destination rectangles, in relative
                                //   coordinates
ULONG       ulHwForeMix,        // Not used
ULONG       ulHwBackMix,        // Not used
SURFOBJ*    psoDst,             // Destination surface
POINTL*     pptlSrc,            // Original unclipped source point
RECTL*      prclDst,            // Original unclipped destination rectangle
XLATEOBJ*   pxlo)               // Provides colour-compressions information
{

    LONG    cPelSize;
    VOID*   pfnCompute;
    SURFOBJ soTmp;
    ULONG*  pulXlate;
    ULONG   ulForeColor;
    POINTL  ptlSrc;
    RECTL   rclTmp;
    BYTE*   pjDst;
    BYTE    jLeftMask;
    BYTE    jRightMask;
    BYTE    jNotLeftMask;
    BYTE    jNotRightMask;
    LONG    cjMiddle;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    LONG    cyTmpScans;
    LONG    cyThis;
    LONG    cyToGo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(psoDst->iBitmapFormat == BMF_1BPP, "Only 1bpp destinations");
    ASSERTDD(TMP_BUFFER_SIZE >= (ppdev->cxMemory << ppdev->cPelSize),
                "Temp buffer has to be larger than widest possible scan");

    // When the destination is a 1bpp bitmap, the foreground colour
    // maps to '1', and any other colour maps to '0'.

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // When the source is 8bpp or less, we find the forground colour
        // by searching the translate table for the only '1':

        pulXlate = pxlo->pulXlate;
        while (*pulXlate != 1)
            pulXlate++;

        ulForeColor = pulXlate - pxlo->pulXlate;
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This routine only supports 8, 16 or 32bpp");

        // When the source has a depth greater than 8bpp, the foreground
        // colour will be the first entry in the translate table we get
        // from calling 'piVector':

        pulXlate = XLATEOBJ_piVector(pxlo);

        ulForeColor = 0;
        if (pulXlate != NULL)           // This check isn't really needed...
            ulForeColor = pulXlate[0];
    }

    // We use the temporary buffer to keep a copy of the source
    // rectangle:

    soTmp.pvScan0 = ppdev->pvTmpBuffer;

    do {
        // ptlSrc points to the upper-left corner of the screen rectangle
        // for the current batch:

        ptlSrc.x = prcl->left + (pptlSrc->x - prclDst->left);
        ptlSrc.y = prcl->top  + (pptlSrc->y - prclDst->top);

        // vGetBits takes absolute coordinates for the source point:

        ptlSrc.x += ppdev->xOffset;
        ptlSrc.y += ppdev->yOffset;

        pjDst = (BYTE*) psoDst->pvScan0 + (prcl->top * psoDst->lDelta)
                                        + (prcl->left >> 3);

        cPelSize = ppdev->cPelSize;

        soTmp.lDelta = (((prcl->right + 7L) & ~7L) - (prcl->left & ~7L))
                       << cPelSize;

        // Our temporary buffer, into which we read a copy of the source,
        // may be smaller than the source rectangle.  In that case, we
        // process the source rectangle in batches.
        //
        // cyTmpScans is the number of scans we can do in each batch.
        // cyToGo is the total number of scans we have to do for this
        // rectangle.
        //
        // We take the buffer size less four so that the right edge case
        // can safely read one dword past the end:

        cyTmpScans = (TMP_BUFFER_SIZE - 4) / soTmp.lDelta;
        cyToGo     = prcl->bottom - prcl->top;

        ASSERTDD(cyTmpScans > 0, "Buffer too small for largest possible scan");

        // Initialize variables that don't change within the batch loop:

        rclTmp.top    = 0;
        rclTmp.left   = prcl->left & 7L;
        rclTmp.right  = (prcl->right - prcl->left) + rclTmp.left;

        // Note that we have to be careful with the right mask so that it
        // isn't zero.  A right mask of zero would mean that we'd always be
        // touching one byte past the end of the scan (even though we
        // wouldn't actually be modifying that byte), and we must never
        // access memory past the end of the bitmap (because we can access
        // violate if the bitmap end is exactly page-aligned).

        jLeftMask     = gajLeftMask[rclTmp.left & 7];
        jRightMask    = gajRightMask[rclTmp.right & 7];
        cjMiddle      = ((rclTmp.right - 1) >> 3) - (rclTmp.left >> 3) - 1;

        if (cjMiddle < 0)
        {
            // The blt starts and ends in the same byte:

            jLeftMask &= jRightMask;
            jRightMask = 0;
            cjMiddle   = 0;
        }

        jNotLeftMask  = ~jLeftMask;
        jNotRightMask = ~jRightMask;
        lDstDelta     = psoDst->lDelta - cjMiddle - 2;
                                // Delta from the end of the destination
                                //  to the start on the next scan, accounting
                                //  for 'left' and 'right' bytes

        lSrcDelta     = soTmp.lDelta - ((8 * (cjMiddle + 2)) << cPelSize);
                                // Compute source delta for special cases
                                //  like when cjMiddle gets bumped up to '0',
                                //  and to correct aligned cases

        do {
            // This is the loop that breaks the source rectangle into
            // manageable batches.

            cyThis  = cyTmpScans;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            rclTmp.bottom = cyThis;

            vGetBits(ppdev, &soTmp, &rclTmp, &ptlSrc);

            ptlSrc.y += cyThis;         // Get ready for next batch loop

            _asm {
                mov     eax,ulForeColor     ;eax = foreground colour
                                            ;ebx = temporary storage
                                            ;ecx = count of middle dst bytes
                                            ;dl  = destination byte accumulator
                                            ;dh  = temporary storage
                mov     esi,soTmp.pvScan0   ;esi = source pointer
                mov     edi,pjDst           ;edi = destination pointer

                ; Figure out the appropriate compute routine:

                mov     ebx,cPelSize
                mov     pfnCompute,offset Compute_Destination_Byte_From_8bpp
                dec     ebx
                jl      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_16bpp
                dec     ebx
                jl      short Do_Left_Byte
                mov     pfnCompute,offset Compute_Destination_Byte_From_32bpp

            Do_Left_Byte:
                call    pfnCompute
                and     dl,jLeftMask
                mov     dh,jNotLeftMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi
                mov     ecx,cjMiddle
                dec     ecx
                jl      short Do_Right_Byte

            Do_Middle_Bytes:
                call    pfnCompute
                mov     [edi],dl
                inc     edi
                dec     ecx
                jge     short Do_Middle_Bytes

            Do_Right_Byte:
                call    pfnCompute
                and     dl,jRightMask
                mov     dh,jNotRightMask
                and     dh,[edi]
                or      dh,dl
                mov     [edi],dh
                inc     edi

                add     edi,lDstDelta
                add     esi,lSrcDelta
                dec     cyThis
                jnz     short Do_Left_Byte

                mov     pjDst,edi               ;save for next batch

                jmp     All_Done

            Compute_Destination_Byte_From_8bpp:
                mov     bl,[esi]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 0

                mov     bl,[esi+1]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 1

                mov     bl,[esi+2]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 2

                mov     bl,[esi+3]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 3

                mov     bl,[esi+4]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 4

                mov     bl,[esi+5]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 5

                mov     bl,[esi+6]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 6

                mov     bl,[esi+7]
                sub     bl,al
                cmp     bl,1
                adc     dl,dl                   ;bit 7

                add     esi,8                   ;advance the source
                ret

            Compute_Destination_Byte_From_16bpp:
                mov     bx,[esi]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 0

                mov     bx,[esi+2]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 1

                mov     bx,[esi+4]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 2

                mov     bx,[esi+6]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 3

                mov     bx,[esi+8]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 4

                mov     bx,[esi+10]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 5

                mov     bx,[esi+12]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 6

                mov     bx,[esi+14]
                sub     bx,ax
                cmp     bx,1
                adc     dl,dl                   ;bit 7

                add     esi,16                  ;advance the source
                ret

            Compute_Destination_Byte_From_32bpp:
                mov     ebx,[esi]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 0

                mov     ebx,[esi+4]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 1

                mov     ebx,[esi+8]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 2

                mov     ebx,[esi+12]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 3

                mov     ebx,[esi+16]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 4

                mov     ebx,[esi+20]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 5

                mov     ebx,[esi+24]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 6

                mov     ebx,[esi+28]
                sub     ebx,eax
                cmp     ebx,1
                adc     dl,dl                   ;bit 7

                add     esi,32                  ;advance the source
                ret

            All_Done:
            }
        } while (cyToGo > 0);

        prcl++;
    } while (--c != 0);
}

#endif // i386

/******************************Public*Routine******************************\
* VOID vMaskRopB8orE2
*
* Performs a 'b8' or 'e2' rop3 when the source is 1bpp or the same colour
* depth as the display with no translate (can be either a DIB or off-screen
* DFB).  Uses the hardware in three passes.
*
\**************************************************************************/

VOID vMaskRopB8orE2(            // Type FNMASK
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of destination rectangles, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // SCREEN_AND_NEW if rop b8,
                                //   SCREEN_AND_NOT_NEW if rop e2
ULONG           ulHwBackMix,    // Not used
SURFOBJ*        psoMsk,         // Not used
POINTL*         pptlMsk,        // Not used
SURFOBJ*        psoSrc,         // Source surface of blt (1bpp or native)
POINTL*         pptlSrc,        // Original unclipped source point
RECTL*          prclDst,        // Original unclipped destination rectangle
ULONG           iSolidColor,    // Colour, 0xffffffff is pattern should be used
RBRUSH*         prb,            // Pointer to our brush realization, if needed
POINTL*         pptlBrush,      // Pattern alignment if needed
XLATEOBJ*       pxlo)           // Translation data if needed
{
    FNFILL*         pfnFill;
    FNXFER*         pfnXfer;
    RBRUSH_COLOR    rbc;

    ASSERTDD((psoSrc->iType == STYPE_BITMAP) || !OVERLAP(prclDst, pptlSrc),
             "Can't overlap on screen-to-screen operations!");
    ASSERTDD((psoSrc->iBitmapFormat == BMF_1BPP) ||
             (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
             "Can handle xlates only on 1bpp transfers");
    ASSERTDD((psoSrc->iBitmapFormat == BMF_1BPP) ||
             (psoSrc->iType != STYPE_BITMAP)     ||
             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
             "Can handle only 1bpp or native sources");
    ASSERTDD((ulHwForeMix == SCREEN_AND_NOT_NEW) ||
             (ulHwForeMix == SCREEN_AND_NEW),
             "Unexpected mix");

    if (iSolidColor != -1)
    {
        pfnFill         = ppdev->pfnFillSolid;
        rbc.iSolidColor = iSolidColor;
    }
    else
    {
        pfnFill = ppdev->pfnFillPat;
        rbc.prb = prb;
    }

    // 'b8' is 'DSDPxax', and that's exactly what we do:

    pfnFill(ppdev, c, prcl, SCREEN_XOR_NEW, SCREEN_XOR_NEW, rbc, pptlBrush);

    if (psoSrc->iType != STYPE_BITMAP)
        ppdev->pfnCopyBlt(ppdev, c, prcl, ulHwForeMix, pptlSrc, prclDst);
    else
    {
        if (psoSrc->iBitmapFormat == BMF_1BPP)
            pfnXfer = ppdev->pfnXfer1bpp;
        else
            pfnXfer = ppdev->pfnXferNative;

        pfnXfer(ppdev, c, prcl, ulHwForeMix, ulHwForeMix, psoSrc, pptlSrc,
                prclDst, pxlo);
    }

    pfnFill(ppdev, c, prcl, SCREEN_XOR_NEW, SCREEN_XOR_NEW, rbc, pptlBrush);
}

/******************************Public*Routine******************************\
* VOID vMaskRop69or96
*
* Performs a '69' or '96' rop3 when the source is 1bpp or the same colour
* depth as the display with no translate (can be either a DIB or off-screen
* DFB).  Uses the hardware in two passes.
*
\**************************************************************************/

VOID vMaskRop69or96(            // Type FNMASK
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of destination rectangles, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // NOT_SCREEN_XOR_NEW if rop 69,
                                //  SCREEN_XOR_NEW if rop 96
ULONG           ulHwBackMix,    // Not used
SURFOBJ*        psoMsk,         // Not used
POINTL*         pptlMsk,        // Not used
SURFOBJ*        psoSrc,         // Source surface of blt (1bpp or native)
POINTL*         pptlSrc,        // Original unclipped source point
RECTL*          prclDst,        // Original unclipped destination rectangle
ULONG           iSolidColor,    // Colour, 0xffffffff is pattern should be used
RBRUSH*         prb,            // Pointer to our brush realization, if needed
POINTL*         pptlBrush,      // Pattern alignment if needed
XLATEOBJ*       pxlo)           // Translation data if needed
{
    FNFILL*         pfnFill;
    FNXFER*         pfnXfer;
    RBRUSH_COLOR    rbc;

    ASSERTDD((psoSrc->iType == STYPE_BITMAP) || !OVERLAP(prclDst, pptlSrc),
             "Can't overlap on screen-to-screen operations!");
    ASSERTDD((psoSrc->iBitmapFormat == BMF_1BPP) ||
             (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
             "Can handle xlates only on 1bpp transfers");
    ASSERTDD((psoSrc->iBitmapFormat == BMF_1BPP) ||
             (psoSrc->iType != STYPE_BITMAP)     ||
             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
             "Can handle only 1bpp or native sources");
    ASSERTDD((ulHwForeMix == NOT_SCREEN_XOR_NEW) ||
             (ulHwForeMix == SCREEN_XOR_NEW),
             "Unexpected mix");

    if (iSolidColor != -1)
    {
        pfnFill         = ppdev->pfnFillSolid;
        rbc.iSolidColor = iSolidColor;
    }
    else
    {
        pfnFill = ppdev->pfnFillPat;
        rbc.prb = prb;
    }

    // '69' is 'PDSxxn', and that is exactly what we do:

    if (psoSrc->iType != STYPE_BITMAP)
        ppdev->pfnCopyBlt(ppdev, c, prcl, SCREEN_XOR_NEW, pptlSrc, prclDst);
    else
    {
        if (psoSrc->iBitmapFormat == BMF_1BPP)
            pfnXfer = ppdev->pfnXfer1bpp;
        else
            pfnXfer = ppdev->pfnXferNative;

        pfnXfer(ppdev, c, prcl, SCREEN_XOR_NEW, SCREEN_XOR_NEW, psoSrc, pptlSrc,
                prclDst, pxlo);
    }

    // XOR is commutative, but we do the bitmap transfer first so that
    // we don't have to sit around waiting for the patblt to finish:

    pfnFill(ppdev, c, prcl, ulHwForeMix, ulHwForeMix, rbc, pptlBrush);
}

/******************************Public*Routine******************************\
* VOID vMaskRopAACCorCCAA
*
* Performs an 'AACC' or 'CCAA' simple MaskBlt in three passes using the
* hardware when the source is in off-screen memory.
*
\**************************************************************************/

VOID vMaskRopAACCorCCAA(        // Type FNMASK
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // Array of relative coordinates destination
                                //   rectangles
ULONG           ulHwForeMix,    // Foreground mix
ULONG           ulHwBackMix,    // Background mix
SURFOBJ*        psoMsk,         // Mask surface
POINTL*         pptlMsk,        // Original unclipped mask source point
SURFOBJ*        psoSrc,         // Not used
POINTL*         pptlSrc,        // Original unclipped source point
RECTL*          prclDst,        // Original unclipped destination rectangle
ULONG           iSolidColor,    // Not used
RBRUSH*         prb,            // Not used
POINTL*         pptlBrush,      // Not used
XLATEOBJ*       pxlo)           // Not used
{
    XLATEOBJ    xlo;
    XLATECOLORS xlc;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(pptlMsk != NULL, "Can't have a NULL pptlmask");
    ASSERTDD(psoMsk->iBitmapFormat == BMF_1BPP, "Can only be a 1bpp mask");
    ASSERTDD(!OVERLAP(prclDst, pptlSrc), "Source and dest can't overlap!");
    ASSERTDD((ulHwForeMix == SCREEN_AND_NEW) ||
             (ulHwForeMix == SCREEN_AND_NOT_NEW),
             "Unexpected mix");

    // Fake up a translate:

    xlc.iForeColor = (ULONG) -1;
    xlc.iBackColor = 0;
    xlo.pulXlate   = (ULONG*) &xlc;

    // First XOR the source, then AND the mask, then XOR the source again:

    ppdev->pfnCopyBlt(ppdev, c, prcl, SCREEN_XOR_NEW, pptlSrc, prclDst);

    ppdev->pfnXfer1bpp(ppdev, c, prcl, ulHwForeMix, ulHwForeMix, psoMsk,
                       pptlMsk, prclDst, &xlo);

    ppdev->pfnCopyBlt(ppdev, c, prcl, SCREEN_XOR_NEW, pptlSrc, prclDst);
}

/******************************Public*Routine******************************\
* BOOL bPuntBlt
*
* Has GDI do any drawing operations that we don't specifically handle
* in the driver.
*
\**************************************************************************/

BOOL bPuntBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    #if DBG
    {
        //////////////////////////////////////////////////////////////////////
        // Diagnostics
        //
        // Since calling the engine to do any drawing can be rather painful,
        // particularly when the source is an off-screen DFB (since GDI will
        // have to allocate a DIB and call us to make a temporary copy before
        // it can even start drawing), we'll try to avoid it as much as
        // possible.
        //
        // Here we simply spew out information describing the blt whenever
        // this routine gets called (checked builds only, of course):

        ULONG ulClip;
        PDEV* ppdev;
        ULONG ulAvec;

        if (psoDst->iType != STYPE_BITMAP)
            ppdev = (PDEV*) psoDst->dhpdev;
        else
            ppdev = (PDEV*) psoSrc->dhpdev;

        ulClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

        DISPDBG((1, ">> Punt << Dst format: %li Dst type: %li Clip: %li Rop: %lx",
            psoDst->iBitmapFormat, psoDst->iType, ulClip, rop4));

        if (psoSrc != NULL)
            DISPDBG((1, "        << Src format: %li Src type: %li",
                psoSrc->iBitmapFormat, psoSrc->iType));

        if ((pxlo != NULL) && !(pxlo->flXlate & XO_TRIVIAL) && (psoSrc != NULL))
        {
            if (((psoSrc->iType == STYPE_BITMAP) &&
                 (psoSrc->iBitmapFormat != ppdev->iBitmapFormat)) ||
                ((psoDst->iType == STYPE_BITMAP) &&
                 (psoDst->iBitmapFormat != ppdev->iBitmapFormat)))
            {
                // Don't bother printing the 'xlate' message when the source
                // is a different bitmap format from the destination -- in
                // those cases we know there always has to be a translate.
            }
            else
            {
                DISPDBG((1, "        << With xlate"));
            }
        }

        // The high 2 bytes of rop4 is not guaranteed to be zero. So in order
        // to get the low 8 bits as index, we have to &ffff before do >>
        ulAvec = gajRop3[rop4 & 0xff] | gajRop3[(rop4 & 0xffff) >> 8];

        if ((ulAvec & AVEC_NEED_PATTERN) && (pbo->iSolidColor == -1))
        {
            if (pbo->pvRbrush == NULL)
                DISPDBG((1, "        << With brush -- Not created"));
            else
                DISPDBG((1, "        << With brush -- Created Ok"));
        }
    }
    #endif

    #if GDI_BANKING
    {
        //////////////////////////////////////////////////////////////////////
        // Banked Framebuffer bPuntBlt
        //
        // This section of code handles a PuntBlt when GDI can directly draw
        // on the framebuffer, but the drawing has to be done in banks:

        BANK     bnk;
        PDEV*    ppdev;
        BOOL     b;
        HSURF    hsurfTmp;
        SURFOBJ* psoTmp;
        SIZEL    sizl;
        POINTL   ptlSrc;
        RECTL    rclTmp;
        RECTL    rclDst;

        // We copy the original destination rectangle, and use that in every
        // GDI call-back instead of the original because sometimes GDI is
        // sneaky and points 'prclDst' to '&pco->rclBounds'.  Because we
        // modify 'rclBounds', that would affect 'prclDst', which we don't
        // want to happen:

        rclDst = *prclDst;

        if ((psoSrc == NULL) || (psoSrc->iType == STYPE_BITMAP))
        {
            ASSERTDD(psoDst->iType != STYPE_BITMAP,
                     "Dest should be the screen when given a DIB source");

            // Do a memory-to-screen blt:

            ppdev = (PDEV*) psoDst->dhpdev;

            vBankStart(ppdev, &rclDst, pco, &bnk);

            b = TRUE;
            do {
                b &= EngBitBlt(bnk.pso, psoSrc, psoMsk, bnk.pco, pxlo,
                               &rclDst, pptlSrc, pptlMsk, pbo, pptlBrush,
                               rop4);

            } while (bBankEnum(&bnk));
        }
        else
        {
            // The screen is the source (it may be the destination too...)

            ppdev = (PDEV*) psoSrc->dhpdev;

            ptlSrc.x = pptlSrc->x + ppdev->xOffset;
            ptlSrc.y = pptlSrc->y + ppdev->yOffset;

            if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
            {
                // We have to intersect the destination rectangle with
                // the clip bounds if there is one (consider the case
                // where the app asked to blt a really, really big
                // rectangle from the screen -- prclDst would be really,
                // really big but pco->rclBounds would be the actual
                // area of interest):

                rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
                rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
                rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
                rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

                // Correspondingly, we have to offset the source point:

                ptlSrc.x += (rclDst.left - prclDst->left);
                ptlSrc.y += (rclDst.top - prclDst->top);
            }

            // We're now either going to do a screen-to-screen or screen-to-DIB
            // blt.  In either case, we're going to create a temporary copy of
            // the source.  (Why do we do this when GDI could do it for us?
            // GDI would create a temporary copy of the DIB for every bank
            // call-back!)

            sizl.cx = rclDst.right  - rclDst.left;
            sizl.cy = rclDst.bottom - rclDst.top;

            // Don't forget to convert from relative to absolute coordinates
            // on the source!  (vBankStart takes care of that for the
            // destination.)

            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;
            rclTmp.left   = 0;
            rclTmp.top    = 0;

            // GDI does guarantee us that the blt extents have already been
            // clipped to the surface boundaries (we don't have to worry
            // here about trying to read where there isn't video memory).
            // Let's just assert to make sure:

            ASSERTDD((ptlSrc.x >= 0) &&
                     (ptlSrc.y >= 0) &&
                     (ptlSrc.x + sizl.cx <= ppdev->cxMemory) &&
                     (ptlSrc.y + sizl.cy <= ppdev->cyMemory),
                     "Source rectangle out of bounds!");

            hsurfTmp = (HSURF) EngCreateBitmap(sizl,
                                               0,    // Let GDI choose ulWidth
                                               ppdev->iBitmapFormat,
                                               0,    // Don't need any options
                                               NULL);// Let GDI allocate

            if (hsurfTmp != 0)
            {
                psoTmp = EngLockSurface(hsurfTmp);

                if (psoTmp != NULL)
                {
                    vGetBits(ppdev, psoTmp, &rclTmp, &ptlSrc);

                    if (psoDst->iType == STYPE_BITMAP)
                    {
                        // It was a Screen-to-DIB blt; now it's a DIB-to-DIB
                        // blt.  Note that the source point is (0, 0) in our
                        // temporary surface:

                        b = EngBitBlt(psoDst, psoTmp, psoMsk, pco, pxlo,
                                      &rclDst, (POINTL*) &rclTmp, pptlMsk,
                                      pbo, pptlBrush, rop4);
                    }
                    else
                    {
                        // It was a Screen-to-Screen blt; now it's a DIB-to-
                        // screen blt.  Note that the source point is (0, 0)
                        // in our temporary surface:

                        vBankStart(ppdev, &rclDst, pco, &bnk);

                        b = TRUE;
                        do {
                            b &= EngBitBlt(bnk.pso, psoTmp, psoMsk, bnk.pco,
                                           pxlo, &rclDst, (POINTL*) &rclTmp,
                                           pptlMsk, pbo, pptlBrush, rop4);

                        } while (bBankEnum(&bnk));
                    }

                    EngUnlockSurface(psoTmp);
                }

                EngDeleteSurface(hsurfTmp);
            }
        }

        return(b);
    }
    #else
    {
        //////////////////////////////////////////////////////////////////////
        // Really Slow bPuntBlt
        //
        // Here we handle a PuntBlt when GDI can't draw directly on the
        // framebuffer (as on the Alpha, which can't do it because of its
        // 32 bit bus).  If you thought the banked version was slow, just
        // look at this one.  Guaranteed, there will be at least one bitmap
        // allocation and extra copy involved; there could be two if it's a
        // screen-to-screen operation.

        PDEV*   ppdev;
        POINTL  ptlSrc;
        RECTL   rclDst;
        SIZEL   sizl;
        ULONG   ulAvec;
        BOOL    bSrcIsScreen;
        HSURF   hsurfSrc;
        RECTL   rclTmp;
        BOOL    b;
        LONG    lDelta;
        BYTE*   pjBits;
        BYTE*   pjScan0;
        HSURF   hsurfDst;
        RECTL   rclScreen;

        b = FALSE;          // Fore error cases, assume we'll fail

        rclDst = *prclDst;
        if (pptlSrc != NULL)
            ptlSrc = *pptlSrc;

        if ((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL))
        {
            // We have to intersect the destination rectangle with
            // the clip bounds if there is one (consider the case
            // where the app asked to blt a really, really big
            // rectangle from the screen -- prclDst would be really,
            // really big but pco->rclBounds would be the actual
            // area of interest):

            rclDst.left   = max(rclDst.left,   pco->rclBounds.left);
            rclDst.top    = max(rclDst.top,    pco->rclBounds.top);
            rclDst.right  = min(rclDst.right,  pco->rclBounds.right);
            rclDst.bottom = min(rclDst.bottom, pco->rclBounds.bottom);

            ptlSrc.x += (rclDst.left - prclDst->left);
            ptlSrc.y += (rclDst.top  - prclDst->top);
        }

        sizl.cx = rclDst.right  - rclDst.left;
        sizl.cy = rclDst.bottom - rclDst.top;

        // The high 2 bytes of rop4 is not guaranteed to be zero. So in order
        // to get the low 8 bits as index, we have to &ffff before do >>
        ulAvec = gajRop3[rop4 & 0xff] | gajRop3[(rop4 & 0xffff) >> 8];

        bSrcIsScreen = ((ulAvec & AVEC_NEED_SOURCE) &&
                        (psoSrc->iType != STYPE_BITMAP));

        if (bSrcIsScreen)
        {
            ppdev = (PDEV*) psoSrc->dhpdev;

            // We need to create a copy of the source rectangle:

            hsurfSrc = (HSURF) EngCreateBitmap(sizl, 0, ppdev->iBitmapFormat,
                                               0, NULL);
            if (hsurfSrc == 0)
                goto Error_0;

            psoSrc = EngLockSurface(hsurfSrc);
            if (psoSrc == NULL)
                goto Error_1;

            rclTmp.left   = 0;
            rclTmp.top    = 0;
            rclTmp.right  = sizl.cx;
            rclTmp.bottom = sizl.cy;

            // vGetBits takes absolute coordinates for the source point:

            ptlSrc.x += ppdev->xOffset;
            ptlSrc.y += ppdev->yOffset;

            vGetBits(ppdev, psoSrc, &rclTmp, &ptlSrc);

            // The source will now come from (0, 0) of our temporary source
            // surface:

            ptlSrc.x = 0;
            ptlSrc.y = 0;
        }

        if (psoDst->iType == STYPE_BITMAP)
        {
            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);
        }
        else
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            // We need to create a temporary work buffer.  We have to do
            // some fudging with the offsets so that the upper-left corner
            // of the (relative coordinates) clip object bounds passed to
            // GDI will be transformed to the upper-left corner of our
            // temporary bitmap.

            // The alignment doesn't have to be as tight as this at 16bpp
            // and 32bpp, but it won't hurt:

            lDelta = (((rclDst.right + 3) & ~3L) - (rclDst.left & ~3L))
                   << ppdev->cPelSize;

            // We're actually only allocating a bitmap that is 'sizl.cx' x
            // 'sizl.cy' in size:

            pjBits = EngAllocMem(0, lDelta * sizl.cy, ALLOC_TAG);
            if (pjBits == NULL)
                goto Error_2;

            // We now adjust the surface's 'pvScan0' so that when GDI thinks
            // it's writing to pixel (rclDst.top, rclDst.left), it will
            // actually be writing to the upper-left pixel of our temporary
            // bitmap:

            pjScan0 = pjBits - (rclDst.top * lDelta)
                             - ((rclDst.left & ~3L) << ppdev->cPelSize);

            ASSERTDD((((ULONG) pjScan0) & 3) == 0,
                    "pvScan0 must be dword aligned!");

            // The checked build of GDI sometimes checks on blts that
            // prclDst->right <= pso->sizl.cx, so we lie to it about
            // the size of our bitmap:

            sizl.cx = rclDst.right;
            sizl.cy = rclDst.bottom;

            hsurfDst = (HSURF) EngCreateBitmap(
                        sizl,                   // Bitmap covers rectangle
                        lDelta,                 // Use this delta
                        ppdev->iBitmapFormat,   // Same colour depth
                        BMF_TOPDOWN,            // Must have a positive delta
                        pjScan0);               // Where (0, 0) would be

            if ((hsurfDst == 0) ||
                (!EngAssociateSurface(hsurfDst, ppdev->hdevEng, 0)))
                goto Error_3;

            psoDst = EngLockSurface(hsurfDst);
            if (psoDst == NULL)
                goto Error_4;

            // Make sure that the rectangle we Get/Put from/to the screen
            // is in absolute coordinates:

            rclScreen.left   = rclDst.left   + ppdev->xOffset;
            rclScreen.right  = rclDst.right  + ppdev->xOffset;
            rclScreen.top    = rclDst.top    + ppdev->yOffset;
            rclScreen.bottom = rclDst.bottom + ppdev->yOffset;

            // It would be nice to get a copy of the destination rectangle
            // only when the ROP involves the destination (or when the source
            // is an RLE), but we can't do that.  If the brush is truly NULL,
            // GDI will immediately return TRUE from EngBitBlt, without
            // modifying the temporary bitmap -- and we would proceed to
            // copy the uninitialized temporary bitmap back to the screen.

            vGetBits(ppdev, psoDst, &rclDst, (POINTL*) &rclScreen);

            b = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, &rclDst, &ptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

            vPutBits(ppdev, psoDst, &rclScreen, (POINTL*) &rclDst);

            EngUnlockSurface(psoDst);

        Error_4:

            EngDeleteSurface(hsurfDst);

        Error_3:

            EngFreeMem(pjBits);
        }

        Error_2:

        if (bSrcIsScreen)
        {
            EngUnlockSurface(psoSrc);

        Error_1:

            EngDeleteSurface(hsurfSrc);
        }

        Error_0:

        return(b);
    }
    #endif
}

/******************************Public*Routine******************************\
* BOOL DrvBitBlt
*
* Implements the workhorse routine of a display driver.
*
\**************************************************************************/

BOOL DrvBitBlt(
SURFOBJ*    psoDst,
SURFOBJ*    psoSrc,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    PDEV*           ppdev;
    DSURF*          pdsurfDst;
    DSURF*          pdsurfSrc;
    POINTL          ptlSrc;
    BYTE            jClip;
    BOOL            bMore;
    ULONG           ulHwForeMix;
    ULONG           ulHwBackMix;
    CLIPENUM        ce;
    LONG            c;
    RECTL           rcl;
    ULONG           rop2;
    ULONG           rop3;
    FNFILL*         pfnFill;
    FNMASK*         pfnMask;
    RBRUSH_COLOR    rbc;         // Realized brush or solid colour
    ULONG           iSolidColor;
    RBRUSH*         prb;
    XLATECOLORS     xlc;
    XLATEOBJ        xlo;
    ULONG*          pulXlate;
    ULONG           ulTmp;
    FNXFER*         pfnXfer;
    ULONG           iSrcBitmapFormat;
    ULONG           iDir;

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (psoSrc == NULL)
    {
        ///////////////////////////////////////////////////////////////////
        // Fills
        ///////////////////////////////////////////////////////////////////

        // Fills are this function's "raison d'etre" (which is French
        // for "purple armadillo"), so we handle them as quickly as
        // possible:

        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD((psoDst->iType == STYPE_DEVICE) ||
                 (psoDst->iType == STYPE_DEVBITMAP),
                 "Expect only device destinations when no source");

        if (pdsurfDst->dt == DT_SCREEN)
        {
            ppdev = (PDEV*) psoDst->dhpdev;

            ppdev->xOffset = pdsurfDst->poh->x;
            ppdev->yOffset = pdsurfDst->poh->y;

            // Make sure it doesn't involve a mask (i.e., it's really a
            // Rop3):

            if ((rop4 >> 8) == (rop4 & 0xff))
            {
                rop2 = (BYTE) (rop4 & 0xff);

                // We now want to see if we can convert this Rop3 to a Rop2
                // between the Destination and the Pattern.  We could do
                // a byte look-up on 'Rop3', but that would involve a
                // 1/4 Kbyte table which sort of big.  So we twiddle
                // the bits of the Rop3 to get a Rop2.

                if ((((rop2 >> 2) ^ (rop2)) & 0x33) == 0)
                {
                    // The ROP3 doesn't require a source...

                    rop2 >>= 2;
                    rop2 &= 0xf;  // Effectively rop2 between Dest and Pattern

                    // Admittedly, we're doing a lookup here to convert the
                    // rop2 to the hardware mix, but it's only 16 entries
                    // long:

                    ulHwForeMix = gaulHwMixFromRop2[rop2];
                    ulHwBackMix = ulHwForeMix;

                    ppdev->bRealizeTransparent = FALSE;

                    // The nice thing about the mix values for this hardware
                    // is that they are ordered so that values 0 through 3
                    // are the ones that don't require a source.  So we can
                    // do a simple logical-and operation on the hardware mix
                    // to see if we need to get a brush:

                    // NOTE: The following check depends on the actual ordering
                    //       of the mix values for the hardware!  If your mixes
                    //       are ordered differently, you may have to make this
                    //       into a 16-case switch statement on (rop2 + 1),
                    //       comparing it to each of the R2_ rops declared in
                    //       windows.h.

                Fill_It:

                    pfnFill = ppdev->pfnFillSolid;
                    if (ulHwForeMix & MIX_NEEDSPATTERN)
                    {
                        rbc.iSolidColor = pbo->iSolidColor;
                        if (rbc.iSolidColor == -1)
                        {
                            // Try and realize the pattern brush; by doing
                            // this call-back, GDI will eventually call us
                            // again through DrvRealizeBrush:

                            rbc.prb = pbo->pvRbrush;
                            if (rbc.prb == NULL)
                            {
                                rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                                if (rbc.prb == NULL)
                                {
                                    // If we couldn't realize the brush, punt
                                    // the call (it may have been a non 8x8
                                    // brush or something, which we can't be
                                    // bothered to handle, so let GDI do the
                                    // drawing):

                                    goto Punt_It;
                                }
                            }
                            pfnFill = ppdev->pfnFillPat;
                        }
                    }

                    // Note that these 2 'if's are more efficient than
                    // a switch statement:

                    if (jClip == DC_TRIVIAL)
                    {
                        pfnFill(ppdev, 1, prclDst, ulHwForeMix, ulHwBackMix,
                                rbc, pptlBrush);
                        goto All_Done;
                    }
                    else if (jClip == DC_RECT)
                    {
                        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            pfnFill(ppdev, 1, &rcl, ulHwForeMix, ulHwBackMix,
                                    rbc, pptlBrush);
                        goto All_Done;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                           CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                  (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                                pfnFill(ppdev, c, ce.arcl, ulHwForeMix,
                                        ulHwBackMix, rbc, pptlBrush);

                        } while (bMore);
                        goto All_Done;
                    }
                }
            }
        }
    }

    if ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVBITMAP))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_DIB)
        {
            // Here we consider putting a DIB DFB back into off-screen
            // memory.  If there's a translate, it's probably not worth
            // moving since we won't be able to use the hardware to do
            // the blt (a similar argument could be made for weird rops
            // and stuff that we'll only end up having GDI simulate, but
            // those should happen infrequently enough that I don't care).

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                ppdev = (PDEV*) psoSrc->dhpdev;

                // See 'DrvCopyBits' for some more comments on how this
                // moving-it-back-into-off-screen-memory thing works:

                if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                {
                    if (--pdsurfSrc->cBlt == 0)
                    {
                        if (bMoveDibToOffscreenDfbIfRoom(ppdev, pdsurfSrc))
                            goto Continue_It;
                    }
                }
                else
                {
                    // Some space was freed up in off-screen memory,
                    // so reset the counter for this DFB:

                    pdsurfSrc->iUniq = ppdev->iHeapUniq;
                    pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                }
            }

            psoSrc = pdsurfSrc->pso;

            // Handle the case where the source is a DIB DFB and the
            // destination is a regular bitmap:

            if (psoDst->iType == STYPE_BITMAP)
                goto EngBitBlt_It;

        }
    }

Continue_It:

    if (psoDst->iType == STYPE_DEVBITMAP)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        if (pdsurfDst->dt == DT_DIB)
        {
            psoDst = pdsurfDst->pso;

            // If the destination is a DIB, we can only handle this
            // call if the source is not a DIB:

            if ((psoSrc == NULL) || (psoSrc->iType == STYPE_BITMAP))
                goto EngBitBlt_It;
        }
    }

    // At this point, we know that either the source or the destination is
    // not a DIB.  Check for a DFB to screen, DFB to DFB, or screen to DFB
    // case:

    if ((psoSrc != NULL) &&
        (psoDst->iType != STYPE_BITMAP) &&
        (psoSrc->iType != STYPE_BITMAP))
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        pdsurfDst = (DSURF*) psoDst->dhsurf;

        ASSERTDD(pdsurfSrc->dt == DT_SCREEN, "Expected screen source");
        ASSERTDD(pdsurfDst->dt == DT_SCREEN, "Expected screen destination");

        ptlSrc.x = pptlSrc->x - (pdsurfDst->poh->x - pdsurfSrc->poh->x);
        ptlSrc.y = pptlSrc->y - (pdsurfDst->poh->y - pdsurfSrc->poh->y);

        pptlSrc  = &ptlSrc;
        psoSrc   = psoDst;
    }

    if (psoDst->iType != STYPE_BITMAP)
    {
        pdsurfDst = (DSURF*) psoDst->dhsurf;
        ppdev     = (PDEV*)  psoDst->dhpdev;

        ppdev->xOffset = pdsurfDst->poh->x;
        ppdev->yOffset = pdsurfDst->poh->y;
    }
    else
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        ppdev     = (PDEV*)  psoSrc->dhpdev;

        ppdev->xOffset = pdsurfSrc->poh->x;
        ppdev->yOffset = pdsurfSrc->poh->y;
    }

    if ((rop4 >> 8) == (rop4 & 0xff))
    {
        // Since we've already handled the cases where the ROP4 is really
        // a ROP3 and no source is required, we can assert...

        ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                 "Expected no-source case to already have been handled");

        ///////////////////////////////////////////////////////////////////
        // Bitmap transfers
        ///////////////////////////////////////////////////////////////////

        // Since the foreground and background ROPs are the same, we
        // don't have to worry about no stinking masks (it's a simple
        // Rop3).

        rop3 = (rop4 & 0xff);   // Make it into a Rop3 (we keep the rop4
                                //  around in case we decide to punt)

        if (psoDst->iType != STYPE_BITMAP)
        {
            // The destination is the screen:

            if ((rop3 >> 4) == (rop3 & 0xf))
            {
                // The ROP3 doesn't require a pattern:

                rop2 = rop3 & 0xf;      // Make it into a Rop2

                if (psoSrc->iType == STYPE_BITMAP)
                {
                    //////////////////////////////////////////////////
                    // DIB-to-screen blt

                    // This section handles 1bpp, 4bpp and 8bpp sources.
                    // 1bpp should have 'ulHwForeMix' and 'ulHwBackMix' the
                    // same values, and 4bpp and 8bpp ignore 'ulHwBackMix'.

                    ulHwForeMix = gaulHwMixFromRop2[rop2];
                    ulHwBackMix = ulHwForeMix;

                    iSrcBitmapFormat = psoSrc->iBitmapFormat;
                    if (iSrcBitmapFormat == BMF_1BPP)
                    {
                        pfnXfer = ppdev->pfnXfer1bpp;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == ppdev->iBitmapFormat) &&
                             ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
                    {
                        // Plain SRCCOPY blts will be somewhat faster on the S3
                        // if we go through the memory aperture, but
                        // DrvCopyBits should take care of that case, so we
                        // won't bother checking for it here.

                        pfnXfer = ppdev->pfnXferNative;
                        goto Xfer_It;
                    }
                    else if ((iSrcBitmapFormat == BMF_4BPP) &&
                             (ppdev->iBitmapFormat == BMF_8BPP))
                    {
                        pfnXfer = ppdev->pfnXfer4bpp;
                        goto Xfer_It;
                    }
                }
                else // psoSrc->iType != STYPE_BITMAP
                {
                    if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
                    {
                        //////////////////////////////////////////////////
                        // Screen-to-screen blt with no translate

                        ulHwForeMix = gaulHwMixFromRop2[rop2];

                        if (jClip == DC_TRIVIAL)
                        {
                            (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, ulHwForeMix,
                                pptlSrc, prclDst);
                            goto All_Done;
                        }
                        else if (jClip == DC_RECT)
                        {
                            if (bIntersect(prclDst, &pco->rclBounds, &rcl))
                            {
                                (ppdev->pfnCopyBlt)(ppdev, 1, &rcl, ulHwForeMix,
                                    pptlSrc, prclDst);
                            }
                            goto All_Done;
                        }
                        else
                        {
                            // Don't forget that we'll have to draw the
                            // rectangles in the correct direction:

                            if (pptlSrc->y >= prclDst->top)
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTDOWN;
                                else
                                    iDir = CD_LEFTDOWN;
                            }
                            else
                            {
                                if (pptlSrc->x >= prclDst->left)
                                    iDir = CD_RIGHTUP;
                                else
                                    iDir = CD_LEFTUP;
                            }

                            CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                               iDir, 0);

                            do {
                                bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                                      (ULONG*) &ce);

                                c = cIntersect(prclDst, ce.arcl, ce.c);

                                if (c != 0)
                                {
                                    (ppdev->pfnCopyBlt)(ppdev, c, ce.arcl,
                                        ulHwForeMix, pptlSrc, prclDst);
                                }

                            } while (bMore);
                            goto All_Done;
                        }
                    }
                }
            }
            else if (psoSrc->iBitmapFormat == BMF_1BPP)
            {
                pulXlate = pxlo->pulXlate;

                if (((pulXlate[0] == 0) && (pulXlate[1] == ppdev->ulWhite)) ||
                    ((pulXlate[1] == 0) && (pulXlate[0] == ppdev->ulWhite)))
                {
                    // When the brush is solid, and the bitmap colours are
                    // black and white, we can handle any rop3 by converting
                    // it to a monochrome blt with separate foreground and
                    // background mixes.
                    //
                    // (Note that with the S3 801/805/928/964, we could handle
                    // patterns too, using the same trick we use in MaskCopy.
                    // This only works for black and white source bitmaps,
                    // which is the most common call, but unfortunately a
                    // certain program which benchmarks these rops messed up
                    // and gives non-black and white colours.  Since I'll
                    // handle those cases using multiple passes, I won't
                    // bother to implement this special trick.)

                    ulHwForeMix = gaulHwMixFromRop2[((rop3 >> 4) & 0xC) |
                                                    ((rop3 >> 2) & 0x3)];
                    ulHwBackMix = gaulHwMixFromRop2[((rop3 >> 2) & 0xC) |
                                                    ((rop3     ) & 0x3)];
                    pptlMsk = pptlSrc;
                    psoMsk  = psoSrc;
                    if (pulXlate[1] == 0)
                    {
                        ulTmp       = ulHwForeMix;
                        ulHwForeMix = ulHwBackMix;
                        ulHwBackMix = ulTmp;
                    }

                    // Fall through if the brush isn't solid:

                    if ( (((ulHwForeMix | ulHwBackMix) & MIX_NEEDSPATTERN) == 0)
                       ||(pbo->iSolidColor != -1) )
                    {
                        goto Handle_Fill_Mask;
                    }
                }
            }

            // Here we special case some often used rop3's that we can
            // do in two or three passes using the hardware.
            //
            // We only handle 1bpp sources, or sources that are the same
            // pixel depth as the screen (either a bitmap or an off-screen
            // DFB) with no xlate:

            if ((psoSrc->iBitmapFormat == BMF_1BPP) ||
                 (((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                  ((psoSrc->iType != STYPE_BITMAP) ||
                   (psoSrc->iBitmapFormat == ppdev->iBitmapFormat))))
            {
                if ((psoSrc->iType != STYPE_BITMAP) &&
                    (OVERLAP(prclDst, pptlSrc)))
                {
                    // We don't handle overlapping rectangles on a
                    // screen-to-screen operation:

                    goto Punt_It;
                }

                if (rop3 == 0xb8)
                {
                    ulHwForeMix = SCREEN_AND_NEW;
                    pfnMask     = vMaskRopB8orE2;
                }
                else if (rop3 == 0xe2)
                {
                    ulHwForeMix = SCREEN_AND_NOT_NEW;
                    pfnMask     = vMaskRopB8orE2;
                }
                else if (rop3 == 0x69)
                {
                    ulHwForeMix = NOT_SCREEN_XOR_NEW;
                    pfnMask     = vMaskRop69or96;
                }
                else if (rop3 == 0x96)
                {
                    ulHwForeMix = SCREEN_XOR_NEW;
                    pfnMask     = vMaskRop69or96;
                }
                else
                {
                    goto Punt_It;
                }

                // All the rop3's that we've special cased need a pattern,
                // so it's safe to realize a brush:

                iSolidColor = pbo->iSolidColor;
                if (iSolidColor == -1)
                {
                    prb = pbo->pvRbrush;
                    if (prb == NULL)
                    {
                        ppdev->bRealizeTransparent = FALSE;
                        prb = BRUSHOBJ_pvGetRbrush(pbo);
                        if (prb == NULL)
                            goto Punt_It;
                    }
                }

                goto Mask_It;
            }
        }
        else
        {
            #if defined(i386)
            {
                // We special case screen to monochrome blts because they
                // happen fairly often.  We only handle SRCCOPY rops and
                // monochrome destinations (to handle a true 1bpp DIB
                // destination, we would have to do near-colour searches
                // on every colour; as it is, the foreground colour gets
                // mapped to '1', and everything else gets mapped to '0'):

                if ((psoDst->iBitmapFormat == BMF_1BPP) &&
                    (rop3 == 0xcc) &&
                    (pxlo->flXlate & XO_TO_MONO))
                {
                    pfnXfer = vXferScreenTo1bpp;
                    psoSrc  = psoDst;               // A misnomer, I admit
                    goto Xfer_It;
                }
            }
            #endif // i386
        }
    }

    // We're going to handle some true ROP4s, where there's a foreground
    // ROP3 and a background ROP3 associated with the 1bpp mask.

    else if (psoMsk != NULL)
    {
        // At this point, we've made sure that we have a true ROP4.
        // This is important because we're about to dereference the
        // mask.  I'll assert to make sure that I haven't inadvertently
        // broken the logic for this:

        ASSERTDD((rop4 & 0xff) != (rop4 >> 8), "This handles true ROP4's only");

        ///////////////////////////////////////////////////////////////////
        // True ROP4's
        ///////////////////////////////////////////////////////////////////

        // Handle ROP4 where no source is required for either Rop3:

        if ((((rop4 >> 2) ^ (rop4)) & 0x3333) == 0)
        {
            ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2)  & 0xf];
            ulHwBackMix = gaulHwMixFromRop2[(rop4 >> 10) & 0xf];

Handle_Fill_Mask:

            pfnXfer = ppdev->pfnXfer1bpp;
            if ((ulHwForeMix & MIX_NEEDSPATTERN) ||
                (ulHwBackMix & MIX_NEEDSPATTERN))
            {
                // Fake up a 1bpp XLATEOBJ (note that we should only
                // dereference 'pbo' when it's required by the mix):

                xlc.iForeColor = pbo->iSolidColor;
                xlc.iBackColor = xlc.iForeColor;

                if (xlc.iForeColor == -1)
                    goto Punt_It;       // We don't handle non-solid brushes
            }

            // Note that when neither the foreground nor the background mix
            // requires a source, the colours in 'xlc' are allowed to be
            // garbage.

            xlo.pulXlate = (ULONG*) &xlc;
            pxlo         = &xlo;
            psoSrc       = psoMsk;
            pptlSrc      = pptlMsk;
            goto Xfer_It;
        }
        else if ((((rop4 >> 4) ^ (rop4)) & 0x0f0f) == 0) // No pattern required
        {
            // We're about to dereference 'psoSrc' and 'pptlSrc' --
            // since we already handled the case where neither ROP3
            // required the source, the ROP4 must require a source,
            // so we're safe.

            ASSERTDD((psoSrc != NULL) && (pptlSrc != NULL),
                     "No source case should already have been handled!");

            // The operation has to be screen-to-screen, and the rectangles
            // cannot overlap:

            if ((psoSrc->iType != STYPE_BITMAP)                  &&
                (psoDst->iType != STYPE_BITMAP)                  &&
                ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
                !OVERLAP(prclDst, pptlSrc))
            {
                if (ppdev->flCaps & CAPS_MASKBLT_CAPABLE)
                {
                    ulHwForeMix = gaulHwMixFromRop2[rop4 & 0xf];
                    ulHwBackMix = gaulHwMixFromRop2[(rop4 >> 8) & 0xf];

                    pfnMask = ppdev->pfnMaskCopy;
                    goto Mask_It;
                }
                else
                {
                    // We don't have hardware capabilities for doing it in
                    // one pass, but we can still do it in three passes
                    // using the hardware if it's a standard MaskBlt rop:

                    if (rop4 == 0xccaa)
                        ulHwForeMix = SCREEN_AND_NEW;

                    else if (rop4 == 0xaacc)
                        ulHwForeMix = SCREEN_AND_NOT_NEW;

                    else
                        goto Punt_It;

                    pfnMask = vMaskRopAACCorCCAA;
                    goto Mask_It;
                }
            }
        }
    }
    else if ((rop4 & 0xff00) == (0xaa00) &&
             ((((rop4 >> 2) ^ (rop4)) & 0x33) == 0))
    {
        // The only time GDI will ask us to do a true rop4 using the brush
        // mask is when the brush is 1bpp, and the background rop is AA
        // (meaning it's a NOP):

        ASSERTDD(psoMsk == NULL, "This should be the NULL mask case");

        ulHwForeMix = gaulHwMixFromRop2[(rop4 >> 2) & 0xf];
        ulHwBackMix = LEAVE_ALONE;

        ppdev->bRealizeTransparent = TRUE;

        goto Fill_It;
    }

    // Just fall through to Punt_It...

Punt_It:
    return(bPuntBlt(psoDst,
                    psoSrc,
                    psoMsk,
                    pco,
                    pxlo,
                    prclDst,
                    pptlSrc,
                    pptlMsk,
                    pbo,
                    pptlBrush,
                    rop4));

//////////////////////////////////////////////////////////////////////
// Common bitmap transfer

Xfer_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnXfer(ppdev, 1, prclDst, ulHwForeMix, ulHwBackMix, psoSrc, pptlSrc,
                prclDst, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnXfer(ppdev, 1, &rcl, ulHwForeMix, ulHwBackMix, psoSrc, pptlSrc,
                    prclDst, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnXfer(ppdev, c, ce.arcl, ulHwForeMix, ulHwBackMix, psoSrc,
                        pptlSrc, prclDst, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

//////////////////////////////////////////////////////////////////////
// Common masked blt

Mask_It:
    if (jClip == DC_TRIVIAL)
    {
        pfnMask(ppdev, 1, prclDst, ulHwForeMix, ulHwBackMix,
                psoMsk, pptlMsk, psoSrc, pptlSrc, prclDst,
                iSolidColor, prb, pptlBrush, pxlo);
        goto All_Done;
    }
    else if (jClip == DC_RECT)
    {
        if (bIntersect(prclDst, &pco->rclBounds, &rcl))
            pfnMask(ppdev, 1, &rcl, ulHwForeMix, ulHwBackMix,
                    psoMsk, pptlMsk, psoSrc, pptlSrc, prclDst,
                    iSolidColor, prb, pptlBrush, pxlo);
        goto All_Done;
    }
    else
    {
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                           CD_ANY, 0);

        do {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce),
                                  (ULONG*) &ce);

            c = cIntersect(prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                pfnMask(ppdev, c, ce.arcl, ulHwForeMix, ulHwBackMix,
                        psoMsk, pptlMsk, psoSrc, pptlSrc, prclDst,
                        iSolidColor, prb, pptlBrush, pxlo);
            }

        } while (bMore);
        goto All_Done;
    }

////////////////////////////////////////////////////////////////////////
// Common DIB blt

EngBitBlt_It:

    // Our driver doesn't handle any blt's between two DIBs.  Normally
    // a driver doesn't have to worry about this, but we do because
    // we have DFBs that may get moved from off-screen memory to a DIB,
    // where we have GDI do all the drawing.  GDI does DIB drawing at
    // a reasonable speed (unless one of the surfaces is a device-
    // managed surface...)
    //
    // If either the source or destination surface in an EngBitBlt
    // call-back is a device-managed surface (meaning it's not a DIB
    // that GDI can draw with), GDI will automatically allocate memory
    // and call the driver's DrvCopyBits routine to create a DIB copy
    // that it can use.  So this means that this could handle all 'punts',
    // and we could conceivably get rid of bPuntBlt.  But this would have
    // a bad performance impact because of the extra memory allocations
    // and bitmap copies -- you really don't want to do this unless you
    // have to (or your surface was created such that GDI can draw
    // directly onto it) -- I've been burned by this because it's not
    // obvious that the performance impact is so bad.
    //
    // That being said, we only call EngBitBlt when all the surfaces
    // are DIBs:

    return(EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst,
                     pptlSrc, pptlMsk, pbo, pptlBrush, rop4));

All_Done:
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL DrvCopyBits
*
* Do fast bitmap copies.
*
* Note that GDI will (usually) automatically adjust the blt extents to
* adjust for any rectangular clipping, so we'll rarely see DC_RECT
* clipping in this routine (and as such, we don't bother special casing
* it).
*
* I'm not sure if the performance benefit from this routine is actually
* worth the increase in code size, since SRCCOPY BitBlts are hardly the
* most common drawing operation we'll get.  But what the heck.
*
* On the S3 it's faster to do straight SRCCOPY bitblt's through the
* memory aperture than to use the data transfer register; as such, this
* routine is the logical place to put this special case.
*
\**************************************************************************/

BOOL DrvCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    PDEV*   ppdev;
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    RECTL   rcl;
    POINTL  ptl;
    OH*     pohSrc;
    OH*     pohDst;

    // DrvCopyBits is a fast-path for SRCCOPY blts.  But it can still be
    // pretty complicated: there can be translates, clipping, RLEs,
    // bitmaps that aren't the same format as the screen, plus
    // screen-to-screen, DIB-to-screen or screen-to-DIB operations,
    // not to mention DFBs (device format bitmaps).
    //
    // Rather than making this routine almost as big as DrvBitBlt, I'll
    // handle here only the speed-critical cases, and punt the rest to
    // our DrvBitBlt routine.
    //
    // We'll try to handle anything that doesn't involve clipping:

    if (((pco  == NULL) || (pco->iDComplexity == DC_TRIVIAL)) &&
        ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)))
    {
        if (psoDst->iType != STYPE_BITMAP)
        {
            // We know the destination is either a DFB or the screen:

            ppdev     = (PDEV*)  psoDst->dhpdev;
            pdsurfDst = (DSURF*) psoDst->dhsurf;

            // See if the source is a plain DIB:

            if (psoSrc->iType != STYPE_BITMAP)
            {
                pdsurfSrc = (DSURF*) psoSrc->dhsurf;

                // Make sure the destination is really the screen or an
                // off-screen DFB (i.e., not a DFB that we've converted
                // to a DIB):

                if (pdsurfDst->dt == DT_SCREEN)
                {
                    ASSERTDD(psoSrc->iType != STYPE_BITMAP, "Can't be a DIB");

                    if (pdsurfSrc->dt == DT_SCREEN)
                    {

                    Screen_To_Screen:

                        //////////////////////////////////////////////////////
                        // Screen-to-screen

                        ASSERTDD((psoSrc->iType != STYPE_BITMAP) &&
                                 (pdsurfSrc->dt == DT_SCREEN)    &&
                                 (psoDst->iType != STYPE_BITMAP) &&
                                 (pdsurfDst->dt == DT_SCREEN),
                                 "Should be a screen-to-screen case");

                        // pfnCopyBlt takes relative coordinates (relative
                        // to the destination surface, that is), so we have
                        // to change the start point to be relative to the
                        // destination surface too:

                        pohSrc = pdsurfSrc->poh;
                        pohDst = pdsurfDst->poh;

                        ptl.x = pptlSrc->x - (pohDst->x - pohSrc->x);
                        ptl.y = pptlSrc->y - (pohDst->y - pohSrc->y);

                        ppdev->xOffset = pohDst->x;
                        ppdev->yOffset = pohDst->y;

                        (ppdev->pfnCopyBlt)(ppdev, 1, prclDst, OVERPAINT, &ptl,
                            prclDst);
                        return(TRUE);
                    }
                    else // (pdsurfSrc->dt != DT_SCREEN)
                    {
                        // Ah ha, the source is a DFB that's really a DIB.

                        ASSERTDD(psoDst->iType != STYPE_BITMAP,
                                "Destination can't be a DIB here");

                        /////////////////////////////////////////////////////
                        // Put It Back Into Off-screen?
                        //
                        // We take this opportunity to decide if we want to
                        // put the DIB back into off-screen memory.  This is
                        // a pretty good place to do it because we have to
                        // copy the bits to some portion of the screen,
                        // anyway.  So we would incur only an extra screen-to-
                        // screen blt at this time, much of which will be
                        // over-lapped with the CPU.
                        //
                        // The simple approach we have taken is to move a DIB
                        // back into off-screen memory only if there's already
                        // room -- we won't throw stuff out to make space
                        // (because it's tough to know what ones to throw out,
                        // and it's easy to get into thrashing scenarios).
                        //
                        // Because it takes some time to see if there's room
                        // in off-screen memory, we only check one in
                        // HEAP_COUNT_DOWN times if there's room.  To bias
                        // in favour of bitmaps that are often blt, the
                        // counters are reset every time any space is freed
                        // up in off-screen memory.  We also don't bother
                        // checking if no space has been freed since the
                        // last time we checked for this DIB.

                        if (pdsurfSrc->iUniq == ppdev->iHeapUniq)
                        {
                            if (--pdsurfSrc->cBlt == 0)
                            {
                                if (bMoveDibToOffscreenDfbIfRoom(ppdev,
                                                                 pdsurfSrc))
                                    goto Screen_To_Screen;
                            }
                        }
                        else
                        {
                            // Some space was freed up in off-screen memory,
                            // so reset the counter for this DFB:

                            pdsurfSrc->iUniq = ppdev->iHeapUniq;
                            pdsurfSrc->cBlt  = HEAP_COUNT_DOWN;
                        }

                        // Since the destination is definitely the screen,
                        // we don't have to worry about creating a DIB to
                        // DIB copy case (for which we would have to call
                        // EngCopyBits):

                        psoSrc = pdsurfSrc->pso;

                        goto DIB_To_Screen;
                    }
                }
                else // (pdsurfDst->dt != DT_SCREEN)
                {
                    // Because the source is not a DIB, we don't have to
                    // worry about creating a DIB to DIB case here (although
                    // we'll have to check later to see if the source is
                    // really a DIB that's masquerading as a DFB...)

                    ASSERTDD(psoSrc->iType != STYPE_BITMAP,
                             "Source can't be a DIB here");

                    psoDst = pdsurfDst->pso;

                    goto Screen_To_DIB;
                }
            }
            else if (psoSrc->iBitmapFormat == ppdev->iBitmapFormat)
            {
                // Make sure the destination is really the screen:

                if (pdsurfDst->dt == DT_SCREEN)
                {

                DIB_To_Screen:

                    //////////////////////////////////////////////////////
                    // DIB-to-screen

                    ASSERTDD((psoDst->iType != STYPE_BITMAP) &&
                             (pdsurfDst->dt == DT_SCREEN)    &&
                             (psoSrc->iType == STYPE_BITMAP) &&
                             (psoSrc->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a DIB-to-screen case");

                    // vPutBits takes absolute screen coordinates, so
                    // we have to muck with the destination rectangle:

                    pohDst = pdsurfDst->poh;

                    rcl.left   = prclDst->left   + pohDst->x;
                    rcl.right  = prclDst->right  + pohDst->x;
                    rcl.top    = prclDst->top    + pohDst->y;
                    rcl.bottom = prclDst->bottom + pohDst->y;

                    // We use the memory aperture to do the transfer,
                    // because that is supposed to be faster for SRCCOPY
                    // blts than using the data-transfer register:

                    vPutBits(ppdev, psoSrc, &rcl, pptlSrc);
                    return(TRUE);
                }
            }
        }
        else // (psoDst->iType == STYPE_BITMAP)
        {

        Screen_To_DIB:

            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            ppdev     = (PDEV*)  psoSrc->dhpdev;

            if (psoDst->iBitmapFormat == ppdev->iBitmapFormat)
            {
                if (pdsurfSrc->dt == DT_SCREEN)
                {
                    //////////////////////////////////////////////////////
                    // Screen-to-DIB

                    ASSERTDD((psoSrc->iType != STYPE_BITMAP) &&
                             (pdsurfSrc->dt == DT_SCREEN)    &&
                             (psoDst->iType == STYPE_BITMAP) &&
                             (psoDst->iBitmapFormat == ppdev->iBitmapFormat),
                             "Should be a screen-to-DIB case");

                    // vGetBits takes absolute screen coordinates, so we have
                    // to muck with the source point:

                    pohSrc = pdsurfSrc->poh;

                    ptl.x = pptlSrc->x + pohSrc->x;
                    ptl.y = pptlSrc->y + pohSrc->y;

                    vGetBits(ppdev, psoDst, prclDst, &ptl);
                    return(TRUE);
                }
                else
                {
                    // The source is a DFB that's really a DIB.  Since we
                    // know that the destination is a DIB, we've got a DIB
                    // to DIB operation, and should call EngCopyBits:

                    psoSrc = pdsurfSrc->pso;
                    goto EngCopyBits_It;
                }
            }
        }
    }

    // We can't call DrvBitBlt if we've accidentally converted both
    // surfaces to DIBs, because it isn't equipped to handle it:

    ASSERTDD((psoSrc->iType != STYPE_BITMAP) ||
             (psoDst->iType != STYPE_BITMAP),
             "Accidentally converted both surfaces to DIBs");

    /////////////////////////////////////////////////////////////////
    // A DrvCopyBits is after all just a simplified DrvBitBlt:

    return(DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                     NULL, NULL, 0x0000CCCC));

EngCopyBits_It:

    ASSERTDD((psoDst->iType == STYPE_BITMAP) &&
             (psoSrc->iType == STYPE_BITMAP),
             "Both surfaces should be DIBs to call EngCopyBits");

    return(EngCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\perm3dat.c ===
/**************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   perm3dat.c
*
* Abstract:
*
*  This module contains all the global data used by the Permedia3 driver.
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

//
// DATA STRUCTURES
// ===============
//

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGEDATA")
#endif


//
//              RangeStart        RangeLength
//              |                 |      RangeInIoSpace
//              |                 |      |  RangeVisible
//        +-----+-----+           |      |  |  RangeShareable
//        |           |           |      |  |  |  RangePassive
//        v           v           v      v  v  v  v
VIDEO_ACCESS_RANGE Perm3LegacyResourceList[] = 
{
    {0x000C0000, 0x00000000, 0x00010000, 0, 0, 0, 0}, // ROM location
    {0x000A0000, 0x00000000, 0x00020000, 0, 0, 1, 0}, // Frame buffer
    {0x000003B0, 0x00000000, 0x0000000B, 1, 1, 1, 0}, // VGA regs
    {0x000003C0, 0x00000000, 0x0000001F, 1, 1, 1, 0}, // VGA regs
};

ULONG Perm3LegacyResourceEntries = sizeof Perm3LegacyResourceList / sizeof Perm3LegacyResourceList[0];

//
// Video mode table - Lists the information about each individual mode.
//
// Note that any new modes should be added here and to the appropriate
// PERM3_VIDEO_FREQUENCIES tables.
//

PERM3_VIDEO_MODES Perm3Modes[] = {
    {                   // 320x200x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      320,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          320,                            // X Resolution, in pixels
          200,                            // Y Resolution, in pixels
          320,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                   // 320x240x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      320,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          320,                            // X Resolution, in pixels
          240,                            // Y Resolution, in pixels
          320,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                   // 512x384x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      512,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          512,                            // X Resolution, in pixels
          384,                            // Y Resolution, in pixels
          512,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                   // 640x400x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      640,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          400,                            // Y Resolution, in pixels
          640,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                   // 640x480x8bpp

      0x0201,           // 'Contiguous' Int 10 mode number (for high-colour)
      0x0201,           // 'Noncontiguous' Int 10 mode number
      640,              // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          480,                            // Y Resolution, in pixels
          640,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                           // 800x600x8bpp
      0x0103,
      0x0203,
      800,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          800,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1024x768x8bpp
      0x0205,
      0x0205,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          1024,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1152x864x8bpp
      0x0207,
      0x0207,
      1152,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          1152,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1280x800x8bpp
      0x0207,
      0x0207,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          800,
          1280,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1280x960x8bpp
      0x0207,
      0x0207,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          1280,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1280x1024x8bpp
      0x0107,
      0x0107,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          1280,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1600x1000x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1000,
          1600,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1600x1024x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1024,
          1600,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1600x1200x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          1600,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1920x1080x8bpp
      0x0120,
      0x0120,
      1920,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          1920,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 1920x1200x8bpp
      0x0120,
      0x0120,
      1920,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1200,
          1920,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                   // 320x200x16bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          200,
          640,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x240x16bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          640,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 512x384x16bpp
      0x0111,
      0x0211,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          1024,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x400x16bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          400,
          1280,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x480x16bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          1280,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 800x600x16bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1024x768x16bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1152x864x16bpp
      0x0118,
      0x0222,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          2304,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x800x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          800,
          2560,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x960x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          2560,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x1024x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          2560,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1000x16bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1000,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1024x16bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1024,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1200x16bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1080x16bpp
      0x0121,
      0x0121,
      3840,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          3840,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1200x16bpp
      0x0121,
      0x0121,
      3840,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1200,
          3840,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,   // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x200x15bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          200,
          640,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x240x15bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          640,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 512x384x15bpp
      0x0111,
      0x0211,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          1024,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x400x15bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          400,
          1280,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x480x15bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          1280,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 800x600x15bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1024x768x15bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1152x864x15bpp
      0x0118,
      0x0222,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          2304,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x800x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          800,
          2560,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x960x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          2560,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x1024x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          2560,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1000x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1000,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1024x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1024,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1200x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1080x15bpp
      0x0121,
      0x0121,
      3840,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          3840,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1200x15bpp
      0x0121,
      0x0121,
      3840,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1200,
          3840,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,   // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x480x12bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2560,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 800x600x12bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          3200,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1024x768x12bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1152x864x12bpp
      0x0118,
      0x0222,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          4608,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

     {                   // 1280x960x12bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          5120,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x1024x12bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1200x12bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1080x12bpp
      0x0122,
      0x0122,
      7680,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          7680,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,   // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x200x32bpp
      0x0112,
      0x0220,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          200,
          1280,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 320x240x32bpp
      0x0112,
      0x0220,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          1280,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 512x384x32bpp
      0x0112,
      0x0220,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          2048,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x400x32bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          400,
          2560,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 640x480x32bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2560,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 800x600x32bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          3200,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1024x768x32bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1152x864x32bpp
      0x0118,
      0x0222,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          864,
          4608,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x800x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          800,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x960x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          960,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1280x1024x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1000x32bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1000,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1024x32bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1024,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1600x1200x32bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1080x32bpp
      0x0122,
      0x0122,
      7680,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1080,
          7680,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                   // 1920x1200x32bpp
      0x0122,
      0x0122,
      7680,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1920,
          1200,
          7680,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,   // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                                     // 640x480x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      1920,                               // 'Contiguous' screen stride (640 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          480,                            // Y Resolution, in pixels
          1920,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 800x600x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      2400,                               // 'Contiguous' screen stride (800 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          800,                            // X Resolution, in pixels
          600,                            // Y Resolution, in pixels
          2400,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1024x768x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3072,                               // 'Contiguous' screen stride (1024 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1024,                           // X Resolution, in pixels
          768,                            // Y Resolution, in pixels
          3072,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1152x864x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3456,                               // 'Contiguous' screen stride (1152 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1152,                           // X Resolution, in pixels
          864,                            // Y Resolution, in pixels
          3072,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1280x1024x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3840,                               // 'Contiguous' screen stride (1280 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          3840,                           // X Resolution, in pixels
          1280,                           // Y Resolution, in pixels
          1024,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1600x1200x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      4800,                               // 'Contiguous' screen stride (1600 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1600,                           // X Resolution, in pixels
          1280,                           // Y Resolution, in pixels
          4800,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },
};

const ULONG NumPerm3VideoModes = sizeof(Perm3Modes) / sizeof(Perm3Modes[0]);

ULONG Perm3DepthList [] = { 8, 15, 16, 24, 32 };

#define Perm3DepthCnt (sizeof(Perm3DepthList) / sizeof(Perm3DepthList[0]))

/*+++

    Data format is:
        Horizontal total time (chars)
        Horizontal right border + front porch (chars)
        Horizontal sync time (chars)
        Horizontal back porch + left border (chars)
        Horizontal sync polarity

        Vertical total time (lines)
        Vertical bottom border + front porch (lines)
        Vertical sync time (lines)
        Vertical back porch + top border (lines)
        Vertical sync polarity

        Pixel clock
---*/

#define NEG        0
#define POS        1

//
// This is our hybrid of DMTF modes and GTF modes which we call the 'VESA' 
// mode list:
//

TIMING_INFO VESA_LIST[] =
{

//  The first entry in the list must be 640x480x60 as this is the mode Windows
//  defaults to when it has somehow been set to an invalid or non-existant mode.

    {{ 640, 480, 60},    { 100,  2, 12,  6, NEG,  525,10, 2, 33, NEG,  251750}},    // DMTF

//  Don't bother for now.
//  {{ 640, 480, 72},    { 104,  3,  5, 16, NEG,  520, 9, 3, 28, NEG,  315000}},    // DMTF

    {{ 640, 480, 75},    { 105,  2,  8, 15, NEG,  500, 1, 3, 16, NEG,  315000}},    // DMTF
    {{ 640, 480, 85},    { 104,  7,  7, 10, NEG,  509, 1, 3, 25, NEG,  360000}},    // DMTF
    {{ 640, 480,100},    { 106,  5,  8, 13, NEG,  509, 1, 3, 25, NEG,  431630}},    // GTF

//           <--320 x 400-->      <--320 x 200-->     <320x400/2>
//  320x200x60 has an fH of 25kHz which is too slow for most monitors
//  {{ 320, 200, 60},    {  48,  0,  4,  4, NEG,  208, 1, 3,  4, POS,   47810}},    // GTF (hybrid of 320 x 400)
    {{ 320, 200, 75},    {  50,  1,  4,  5, NEG,  210, 1, 3,  6, POS,   62700}},    // GTF (hybrid of 320 x 400)
//  {{ 320, 200, 85},    {  52,  2,  4,  6, NEG,  211, 1, 3,  7, POS,   74435}},    // GTF (hybrid of 320 x 400)
//  {{ 320, 200,100},    {  52,  2,  4,  6, NEG,  213, 1, 3,  9, POS,   88190}},    // GTF (hybrid of 320 x 400)

//  {{ 320, 240, 60},    {  50,  1,  4,  5, NEG,  249, 1, 3,  5, POS,   59640}},    // GTF (hybrid of 320 x 480)
    {{ 320, 240, 75},    {  52,  2,  4,  6, NEG,  251, 1, 3,  7, POS,   78310}},    // GTF (hybrid of 320 x 480)
//  {{ 320, 240, 85},    {  52,  2,  4,  6, NEG,  253, 1, 3,  9, POS,   89285}},    // GTF (hybrid of 320 x 480)
//  {{ 320, 240,100},    {  52,  2,  4,  6, NEG,  255, 1, 3, 11, POS,  105870}},    // GTF (hybrid of 320 x 480)

//  DX does not work as these require a screen stride.
//  {{ 400, 300, 60},    {  64,  2,  5,  7, NEG,  311, 1, 3,  7, POS,   86580}},    // GTF (hybrid of 400 x 600)
//  {{ 400, 300, 75},    {  66,  3,  5,  8, NEG,  314, 1, 3, 10, POS,  113040}},    // GTF (hybrid of 400 x 600)
//  {{ 400, 300, 85},    {  66,  3,  5,  8, NEG,  316, 1, 3, 12, POS,  133230}},    // GTF (hybrid of 400 x 600)
//  {{ 400, 300,100},    {  66,  3,  5,  8, NEG,  319, 1, 3, 15, POS,  158220}},    // GTF (hybrid of 400 x 600)

//  512x384x60 has an fH of 24kHz which is too slow for most monitors
//  {{ 512, 384, 60},    {  78,  1,  6,  7, NEG,  398, 1, 3, 10, POS,  149010}},    // GTF
    {{ 512, 384, 75},    {  80,  2,  6,  8, NEG,  402, 1, 3, 14, POS,  192960}},    // GTF
//  {{ 512, 384, 85},    {  82,  2,  7,  9, NEG,  404, 1, 3, 16, POS,  225270}},    // GTF
//  {{ 512, 384,100},    {  82,  2,  7,  9, NEG,  407, 1, 3, 19, POS,  266990}},    // GTF

//  Don't bother for now.
//  {{ 640, 350, 85},    { 104,  4,  8, 12, POS,  445,32, 3, 60, NEG,  315000}},    // DMTF

//  {{ 640, 400, 60},    {  98,  1,  8,  9, NEG,  415, 1, 3, 11, POS,  195220}},    // GTF
    {{ 640, 400, 75},    { 100,  2,  8, 10, NEG,  418, 1, 3, 14, POS,  250800}},    // GTF
//  {{ 640, 400, 85},    { 104,  4,  8, 12, NEG,  445, 1, 3, 41, POS,  315000}},    // DMTF
//  {{ 640, 400,100},    { 104,  4,  8, 12, NEG,  424, 1, 3, 20, POS,  352770}},    // GTF

//  DX does not work as this requires a screen stride.
//  {{ 720, 400, 85},    { 104,  4,  8, 12, NEG,  446, 1, 3, 42, POS,  355000}},    // DMTF

//  Don't bother for now.
//  {{ 800, 600, 56},    { 128,  3,  9, 16, POS,  625, 1, 2, 22, POS,  360000}},    // DMTF
    {{ 800, 600, 60},    { 132,  5, 16, 11, POS,  628, 1, 4, 23, POS,  400000}},    // DMTF
//  {{ 800, 600, 72},    { 130,  7, 15,  8, POS,  666,37, 6, 23, POS,  500000}},    // DMTF
    {{ 800, 600, 75},    { 132,  2, 10, 20, POS,  625, 1, 3, 21, POS,  495000}},    // DMTF
    {{ 800, 600, 85},    { 131,  4,  8, 19, POS,  631, 1, 3, 27, POS,  562500}},    // DMTF
    {{ 800, 600,100},    { 134,  6, 11, 17, NEG,  636, 1, 3, 32, POS,  681790}},    // GTF

//  DX does not work as these require a screen stride.
//  {{ 856, 480, 60},    { 133,  2, 11, 13, NEG,  497, 1, 3, 13, POS,  317280}},    // GTF
//  {{ 856, 480, 75},    { 137,  4, 11, 15, NEG,  502, 1, 3, 18, POS,  412640}},    // GTF
//  {{ 856, 480, 85},    { 139,  5, 11, 16, NEG,  505, 1, 3, 21, POS,  477330}},    // GTF
//  {{ 856, 480,100},    { 141,  6, 11, 17, NEG,  509, 1, 3, 25, POS,  574150}},    // GTF

    {{1024, 768, 60},    { 168,  3, 17, 20, NEG,  806, 3, 6, 29, NEG,  650000}},    // DMTF
//  Don't bother for now.
//  {{1024, 768, 70},    { 166,  3, 17, 18, NEG,  806, 3, 6, 29, NEG,  750000}},    // DMTF
    {{1024, 768, 75},    { 164,  2, 12, 22, POS,  800, 1, 3, 28, POS,  787500}},    // DMTF
    {{1024, 768, 85},    { 172,  6, 12, 26, POS,  808, 1, 3, 36, POS,  945000}},    // DMTF
    {{1024, 768,100},    { 174,  9, 14, 23, NEG,  814, 1, 3, 42, POS, 1133090}},    // GTF
    {{1024, 768,120},    { 176, 10, 14, 24, NEG,  823, 1, 3, 51, POS, 1390540}},    // GTF

    {{1152, 864, 60},    { 190,  8, 15, 23, NEG,  895, 1, 3, 27, POS,  816240}},    // GTF
    {{1152, 864, 75},    { 200,  8, 16, 32, POS,  900, 1, 3, 32, POS, 1080000}},    // DMTF
    {{1152, 864, 85},    { 194,  9, 16, 25, NEG,  907, 1, 3, 39, POS, 1196510}},    // GTF
    {{1152, 864,100},    { 196, 10, 16, 26, NEG,  915, 1, 3, 47, POS, 1434720}},    // GTF
    {{1152, 864,120},    { 198, 11, 16, 27, NEG,  926, 1, 3, 58, POS, 1760140}},    // GTF

    {{1280, 960, 60},    { 225, 12, 14, 39, POS, 1000, 1, 3, 36, POS, 1080000}},    // DMTF
    {{1280, 960, 75},    { 216, 11, 17, 28, NEG, 1002, 1, 3, 38, POS, 1298590}},    // GTF
    {{1280, 960, 85},    { 216,  8, 20, 28, POS, 1011, 1, 3, 47, POS, 1485000}},    // DMTF
    {{1280, 960,100},    { 220, 12, 18, 30, NEG, 1017, 1, 3, 53, POS, 1789920}},    // GTF
    {{1280, 960,120},    { 220, 12, 18, 30, NEG, 1029, 1, 3, 65, POS, 2173250}},    // GTF

    {{1280,1024, 60},    { 211,  6, 14, 31, POS, 1066, 1, 3, 38, POS, 1080000}},    // DMTF
    {{1280,1024, 75},    { 211,  2, 18, 31, POS, 1066, 1, 3, 38, POS, 1350000}},    // DMTF
    {{1280,1024, 85},    { 216,  8, 20, 28, POS, 1072, 1, 3, 44, POS, 1575000}},    // DMTF
    {{1280,1024,100},    { 220, 12, 18, 30, NEG, 1085, 1, 3, 57, POS, 1909600}},    // GTF
    {{1280,1024,120},    { 222, 13, 18, 31, NEG, 1097, 1, 3, 69, POS, 2337930}},    // GTF

    {{1600,1200, 60},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 1620000}},    // DMTF
//  Don't bother for now.
//  {{1600,1200, 65},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 1755000}},    // DMTF
//  {{1600,1200, 70},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 1890000}},    // DMTF
    {{1600,1200, 75},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 2025000}},    // DMTF
    {{1600,1200, 85},    { 270,  8, 24, 38, POS, 1250, 1, 3, 46, POS, 2295000}},    // DMTF
    {{1600,1200,100},    { 276, 16, 22, 38, NEG, 1271, 1, 3, 67, POS, 2806370}},    // GTF

    {{1920,1080, 60},    { 322, 15, 26, 41, NEG, 1118, 1, 3, 34, POS, 1727980}},    // GTF
    {{1920,1080, 75},    { 326, 17, 26, 43, NEG, 1128, 1, 3, 44, POS, 2206370}},    // GTF
    {{1920,1080, 85},    { 328, 18, 26, 44, NEG, 1134, 1, 3, 50, POS, 2529270}},    // GTF
    {{1920,1080,100},    { 330, 19, 26, 45, NEG, 1144, 1, 3, 60, POS, 3020160}},    // GTF

    {{1920,1200, 60},    { 324, 16, 26, 42, NEG, 1242, 1, 3, 38, POS, 1931560}},    // GTF
    {{1920,1200, 75},    { 328, 18, 26, 44, NEG, 1253, 1, 3, 49, POS, 2465900}},    // GTF
    {{1920,1200, 85},    { 330, 19, 26, 45, NEG, 1260, 1, 3, 56, POS, 2827440}},    // GTF
    {{1920,1200,100},    { 332, 19, 27, 46, NEG, 1271, 1, 3, 67, POS, 3375780}},    // GTF
};

TIMING_INFO SGIDFP_LIST[] =
{
    {{1600,1024, 60},    { 302, 30, 24, 48, POS, 1067, 3, 3, 37, POS, 1069100}},
};

#undef NEG
#undef POS

#define VESA_COUNT      (sizeof(VESA_LIST) / sizeof(VESA_LIST[0]))
#define SGIDFP_COUNT   (sizeof(SGIDFP_LIST) / sizeof(SGIDFP_LIST[0]))

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif


//
// THE CODE
// ========
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetVideoTiming)
#pragma alloc_text(PAGE,CopyMonitorTimings)
#pragma alloc_text(PAGE,GrowTimingList)
#pragma alloc_text(PAGE,testExtendRanges)
#pragma alloc_text(PAGE,BuildFrequencyList)
#pragma alloc_text(PAGE,BuildFrequencyListForSGIDFP)
#pragma alloc_text(PAGE,BuildFrequencyListFromVESA)
#endif // ALLOC_PRAGMA

BOOLEAN 
GetVideoTiming( 
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG xRes, 
    ULONG yRes, 
    ULONG Freq, 
    ULONG Depth,
    VESA_TIMING_STANDARD *VESATimings
    ) 

/*+++

Routine Description:

    Given a width, height and frequency this function will return a 
    VESA timing information.

    The information is extracted from the VESA_LIST.

---*/

{
    TIMING_INFO *list = hwDeviceExtension->monitorInfo.timingList;
    ULONG count = hwDeviceExtension->monitorInfo.timingNum;
    ULONG i;
    BOOLEAN retVal;

    retVal = FALSE; 

    //
    // Loop through the table looking for a match
    //

    for( i = 0; !retVal && (i < count); i++ ) {

        //
        // Comparewidth, height and frequency
        //

        if( list[i].basic.width == xRes  &&
            list[i].basic.height == yRes &&
            list[i].basic.refresh == Freq ) {

            //
            // We got a match
            //

            *VESATimings = list[i].vesa;

            retVal = TRUE;
        }
    }

    //
    // Fix up pixel clock, just in case it hasn't been set
    //

    if (retVal && VESATimings->pClk == 0) {

        VideoDebugPrint((0, "Perm3: Pixel clock is zero - recalculating!"));

        VESATimings->pClk = 
            (8 * VESATimings->HTot * VESATimings->VTot * Freq) / 100;
    }

    return retVal;
}


BOOLEAN
CopyMonitorTimings( 
    PVOID HwDeviceExtension,
    MONITOR_INFO *srcMI, 
    MONITOR_INFO *mi 
    ) 
{
    ULONG i, j, k;
    VP_STATUS status;

    if( mi->timingList ) {

        VideoPortReleaseBuffer(HwDeviceExtension, mi->timingList);
        mi->timingList = NULL;
    }

    if( mi->frequencyTable ) {

        VideoPortReleaseBuffer(HwDeviceExtension, mi->frequencyTable);
        mi->frequencyTable = NULL;
    }

    *mi = *srcMI;

    status = VideoPortAllocateBuffer(HwDeviceExtension, 
                                     sizeof(*mi->timingList ) * (mi->timingNum + 1),
                                     &(mi->timingList));

    if (status != NO_ERROR) {
        return FALSE;
    }
   
    status = VideoPortAllocateBuffer(HwDeviceExtension, 
                                     sizeof(*mi->frequencyTable) * 
                                     (mi->timingNum + 1) * Perm3DepthCnt, 
                                     &(mi->frequencyTable));

    if (status != NO_ERROR) {

        VideoPortReleaseBuffer(HwDeviceExtension, mi->timingList);
        mi->timingList = NULL;
        return FALSE;
    }

    VideoPortZeroMemory(mi->frequencyTable, 
                        sizeof(*mi->frequencyTable) * (mi->timingNum + 1) * Perm3DepthCnt );

    mi->timingMax = mi->timingNum;

    for( i = k = 0; i < mi->timingNum; i++ ) {

        mi->timingList[i] = srcMI->timingList[i];
        
        for( j = 0; j < Perm3DepthCnt; j++, k++ ) {
	
            mi->frequencyTable[k].BitsPerPel      = Perm3DepthList[j];
            mi->frequencyTable[k].ScreenWidth     = mi->timingList[i].basic.width;
            mi->frequencyTable[k].ScreenHeight    = mi->timingList[i].basic.height;
            mi->frequencyTable[k].ScreenFrequency = mi->timingList[i].basic.refresh;
            mi->frequencyTable[k].PixelClock      = mi->timingList[i].vesa.pClk;
        }
    }

    //
    // Ensure the lists are terminted
    //

    mi->frequencyTable[k].BitsPerPel = 0;
    mi->timingList[i].basic.width = 0;
    return TRUE;
}

BOOLEAN 
GrowTimingList( 
    PVOID HwDeviceExtension,
    MONITOR_INFO *mi 
    ) 
{

    ULONG newSize = mi->timingNum + 100;
    TIMING_INFO *newList;
    VP_STATUS status;

    status = VideoPortAllocateBuffer(HwDeviceExtension, 
                                     sizeof(*newList) * newSize, 
                                     &(newList));

    if (status != NO_ERROR) {
        return FALSE;
    }

    VideoPortZeroMemory( newList, sizeof(*newList) * newSize );
    VideoPortMoveMemory( newList, mi->timingList, sizeof(*newList) * mi->timingNum );

    if( mi->timingList )
        VideoPortReleaseBuffer( HwDeviceExtension, mi->timingList );

    mi->timingList = newList;
    mi->timingMax = newSize;
    return TRUE;
}

VOID 
testExtendRanges( 
    MONITOR_INFO *mi, 
    TIMING_INFO *ti, 
    FREQUENCIES *freq 
    ) 
{

    if( mi->flags & MI_FLAGS_FUDGED_VH ) {

        if( freq->fH > mi->fhMax )
            mi->fhMax = freq->fH;
        if( freq->fH < mi->fhMin )
            mi->fhMin = freq->fH;

        if( freq->fV > mi->fvMax )
            mi->fvMax = freq->fV;
        if( freq->fV < mi->fvMin )
            mi->fvMin = freq->fV;
    }

    if( mi->flags & MI_FLAGS_FUDGED_PCLK ) {

        if( freq->pClk < mi->pClkMin ) {
            mi->pClkMin = freq->pClk;
        }

        if( freq->pClk > mi->pClkMax ) {
            mi->pClkMax = freq->pClk;
        }
    }

    if( mi->flags & MI_FLAGS_FUDGED_XY ) {

        if( ti->basic.width < mi->xMin ) {
            mi->xMin = ti->basic.width;
        }

        if( ti->basic.width > mi->xMax ) {
            mi->xMax = ti->basic.width;
        }

        if( ti->basic.height < mi->yMin ) {
            mi->yMin = ti->basic.height;
        }

        if( ti->basic.height > mi->yMax ) {
            mi->yMax = ti->basic.height;
        }
    }
}


BOOLEAN 
BuildFrequencyList( 
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    MONITOR_INFO *mi 
    ) 
{

    MONITOR_INFO newMI;
    ULONG i, j, k;
    BOOLEAN bRet = FALSE;
    BOOLEAN bRet1;
    UCHAR EdidBuffer[256];

    VideoPortZeroMemory(&newMI, sizeof(newMI));

    newMI.flags = mi->flags;
    newMI.flags |= ( MI_FLAGS_FUDGED_VH | 
                     MI_FLAGS_FUDGED_PCLK | 
                     MI_FLAGS_FUDGED_XY);

    newMI.fhMin   = 0xFFFFFFFF;    
    newMI.fhMax   = 0;
    newMI.fvMin   = 0xFFFFFFFF;  
    newMI.fvMax   = 0;
    newMI.pClkMin = 0xFFFFFFFF;   
    newMI.pClkMax = 0;
    newMI.xMin    = 0xFFFFFFFF;    
    newMI.xMax    = 0;
    newMI.yMin    = 0xFFFFFFFF;    
    newMI.yMax    = 0;

    if ((hwDeviceExtension->deviceInfo.SubsystemId == 
                            SUBDEVICEID_P3_VX1_1600SW) &&
        GetDFPEdid(hwDeviceExtension, EdidBuffer, sizeof(EdidBuffer))) {

        bRet1 = BuildFrequencyListForSGIDFP(&newMI, 
                                            hwDeviceExtension);
    } else {

        bRet1 = BuildFrequencyListFromVESA(&newMI, 
                                          hwDeviceExtension);
    }

    if (bRet1) {

        //
        // Copy the lists about:
        //

        if(CopyMonitorTimings((PVOID)hwDeviceExtension, &newMI, mi))
            bRet = TRUE;
    }

    if(newMI.timingList) {

        VideoPortReleaseBuffer((PVOID)hwDeviceExtension, newMI.timingList);
        newMI.timingList = NULL;
    }

    return bRet;
}

BOOLEAN 
BuildFrequencyListFromVESA( 
    MONITOR_INFO *mi, 
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    ) 
{
    ULONG realCount = VESA_COUNT;
    TIMING_INFO *realList = VESA_LIST;
    TIMING_INFO *ti;
    FREQUENCIES freq;

    //
    // loop through the list of resolutions
    //

    for( mi->timingNum = 0; mi->timingNum < realCount; mi->timingNum++ ) {

        if( mi->timingNum >= mi->timingMax ) {

            if(!GrowTimingList((PVOID)hwDeviceExtension, mi)) {
                return FALSE;
            }
        }

        ti = &mi->timingList[mi->timingNum];

        *ti = realList[mi->timingNum];

        if( !ti->vesa.pClk ) {
            ti->vesa.pClk = ((ti->vesa.HTot * ti->vesa.VTot * 8) / 100) * ti->basic.refresh;
        }

        freq.pClk = ti->vesa.pClk;
        freq.fH = (freq.pClk * 100) / (ti->vesa.HTot * 8);
        freq.fV = (freq.pClk * 100) / (ti->vesa.HTot * ti->vesa.VTot * 8);
        testExtendRanges( mi, ti, &freq );
    }

    return TRUE;
}


BOOLEAN 
BuildFrequencyListForSGIDFP( 
    MONITOR_INFO *mi, 
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    ) 
{
    ULONG realCount = SGIDFP_COUNT;
    TIMING_INFO *realList = SGIDFP_LIST;
    TIMING_INFO *ti;
    FREQUENCIES freq;

    //
    // Loop through the list of resolutions
    //

    for( mi->timingNum = 0; mi->timingNum < realCount; mi->timingNum++ ) {

        if( mi->timingNum >= mi->timingMax ) {

            if(!GrowTimingList((PVOID)hwDeviceExtension, mi)) {
                return FALSE;
            }
        }

        ti = &mi->timingList[mi->timingNum];

        *ti = realList[mi->timingNum];

        if( !ti->vesa.pClk ) {

            ti->vesa.pClk = ((ti->vesa.HTot * ti->vesa.VTot * 8) / 100) * ti->basic.refresh;
        }

        freq.pClk = ti->vesa.pClk;
        freq.fH = (freq.pClk * 100) / (ti->vesa.HTot * 8);
        freq.fV = (freq.pClk * 100) / (ti->vesa.HTot * ti->vesa.VTot * 8);
        testExtendRanges( mi, ti, &freq );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\power.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
* 
*   power.c
* 
* Abstract:
* 
*   This module contains the code that implements the power management features
* 
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,Perm3GetPowerState)
#pragma alloc_text(PAGE,Perm3SetPowerState)
#pragma alloc_text(PAGE,Perm3GetChildDescriptor)
#pragma alloc_text(PAGE,ProgramDFP)
#pragma alloc_text(PAGE,GetDFPEdid)
#pragma alloc_text(PAGE,I2CWriteClock)
#pragma alloc_text(PAGE,I2CWriteData)
#pragma alloc_text(PAGE,I2CReadClock)
#pragma alloc_text(PAGE,I2CReadData)
#pragma alloc_text(PAGE,I2CWriteClockDFP)
#pragma alloc_text(PAGE,I2CWriteDataDFP)
#pragma alloc_text(PAGE,I2CReadClockDFP)
#pragma alloc_text(PAGE,I2CReadDataDFP)
#endif

DDC_CONTROL
DDCControlCRT = {
    sizeof(DDC_CONTROL),
    I2CWriteClock, 
    I2CWriteData, 
    I2CReadClock, 
    I2CReadData, 
    0
    };

DDC_CONTROL
DDCControlDFP = {
    sizeof(DDC_CONTROL),
    I2CWriteClockDFP,
    I2CWriteDataDFP,
    I2CReadClockDFP, 
    I2CReadDataDFP, 
    0
    };

VP_STATUS 
Perm3GetPowerState(
    PVOID HwDeviceExtension, 
    ULONG HwId, 
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    )
/*+++

Routine Description:

    Queries whether the device can support the requested power state.
    
Arguments:

    HwDeviceExtension
        Pointer to our hardware device extension structure.

    HwId 
        Points to a 32-bit number that uniquely identifies the device that 
        the miniport should query. 

    VideoPowerControl
        Points to a VIDEO_POWER_MANAGEMENT structure that specifies the 
        power state for which support is being queried.

Return Value:

    NO_ERROR, if the device supports the requested power state, or error code.

---*/

{
    VP_STATUS status;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    VideoDebugPrint((3, "Perm3: Perm3GetPowerState: hwId(0x%x) state = %d\n", 
                         HwId, VideoPowerControl->PowerState ));

    switch(HwId) {

        case PERM3_DDC_MONITOR:
        case PERM3_NONDDC_MONITOR:

            switch ( VideoPowerControl->PowerState ) {

                case VideoPowerOn:
                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerOff:
                case VideoPowerHibernate:
                case VideoPowerShutdown:
                    status = NO_ERROR;
                    break;

                default:

                    VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown monitor PowerState = %d\n", 
                                         VideoPowerControl->PowerState ));
                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }

            break;

        case DISPLAY_ADAPTER_HW_ID:

            switch ( VideoPowerControl->PowerState ) {

                case VideoPowerOn:
                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerOff:
                case VideoPowerHibernate:
                case VideoPowerShutdown:

                    status = NO_ERROR;
                    break;

                default:

                    VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown adapter PowerState = %d\n", 
                                         VideoPowerControl->PowerState ));
                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }

            break;

        default:

            VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown hwId(0x%x)", HwId));
            ASSERT(FALSE);
            status = ERROR_INVALID_PARAMETER;
    }

    return(status);
}

VP_STATUS 
Perm3SetPowerState(
    PVOID HwDeviceExtension, 
    ULONG HwId, 
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    )
/*+++

Routine Description:

    Sets the power state of the specified device.

Arguments:

    HwDeviceExtension 
        Pointer to our hardware device extension structure.

    HwId
        Points to a 32-bit number that uniquely identifies the device 
        for which the miniport should set the power state. 

    VideoPowerControl
        Points to a VIDEO_POWER_MANAGEMENT structure that specifies the 
        power state to be set.

Return Value:

    NO_ERROR

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG Polarity;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    VideoDebugPrint((3, "Perm3: Perm3SetPowerState: hwId(0x%x) state = %d\n", 
                         HwId, VideoPowerControl->PowerState));

    switch(HwId) {
   
        case PERM3_DDC_MONITOR:
        case PERM3_NONDDC_MONITOR:

            Polarity = VideoPortReadRegisterUlong(VIDEO_CONTROL);
            Polarity &= ~VC_DPMS_MASK;

            switch (VideoPowerControl->PowerState) {
       
                case VideoPowerOn:
                     VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                 Polarity | hwDeviceExtension->VideoControlMonitorON);
                     break;

                case VideoPowerStandBy:
                     VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                 Polarity | VC_DPMS_STANDBY);
                     break;

                case VideoPowerSuspend:
                     VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                 Polarity | VC_DPMS_SUSPEND);
                     break;

                case VideoPowerShutdown:
                case VideoPowerOff:
                     VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                 Polarity | VC_DPMS_OFF);
                     break;

                case VideoPowerHibernate:

                     //   
                     // The monitor for the vga enabled video device must
                     // stay on at hibernate.
                     //

                     break;

                default:
                    VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown monitor PowerState(0x%x)\n", 
                                         VideoPowerControl->PowerState));
                    ASSERT(FALSE);
            }

            //
            // Track the current monitor power state
            //

            hwDeviceExtension->bMonitorPoweredOn =
                    (VideoPowerControl->PowerState == VideoPowerOn) ||
                    (VideoPowerControl->PowerState == VideoPowerHibernate);

            break;

        case DISPLAY_ADAPTER_HW_ID:

            switch (VideoPowerControl->PowerState) {
       
                case VideoPowerOn:

                    if ((hwDeviceExtension->PreviousPowerState == VideoPowerOff) ||
                        (hwDeviceExtension->PreviousPowerState == VideoPowerSuspend) ||
                        (hwDeviceExtension->PreviousPowerState == VideoPowerHibernate)){
           
                        //
                        // Turn off the monitor while we power back up so 
                        // the user doesn't see any screen corruption
                        //

                        Polarity = VideoPortReadRegisterUlong(VIDEO_CONTROL);
                        Polarity &= ~VC_DPMS_MASK;
                        VideoPortWriteRegisterUlong(VIDEO_CONTROL, Polarity | VC_DPMS_OFF);

                        //
                        // Miniport driver can not rely on video bios to
                        // initialize the device registers while resuming
                        // from VideoPowerOff and VideoPowerSuspend. 
                        // 
                        // This is also true for the secondary (vga disabled) 
                        // video device while resuming from VideoPowerHibernate
                        // 

                        InitializePostRegisters(hwDeviceExtension);
                    }

                    break;

                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerOff:
                case VideoPowerHibernate:

                    break;

                case VideoPowerShutdown:

                    // 
                    // We need to make sure no interrupts will be generated
                    // after the device being powered down
                    // 

                    VideoPortWriteRegisterUlong(INT_ENABLE, 0);
                    break;

                default:

                    VideoDebugPrint((0, "Perm3: Perm3GetPowerState: Unknown adapter PowerState(0x%x)\n", 
                                         VideoPowerControl->PowerState));
                    ASSERT(FALSE);
            }

            hwDeviceExtension->PreviousPowerState = VideoPowerControl->PowerState;
            break;

        default:

            VideoDebugPrint((0, "Perm3: Perm3SetPowerState: Unknown hwId(0x%x)\n", 
                                 HwId));
            ASSERT(FALSE);
    }

    return(NO_ERROR);
}

ULONG 
Perm3GetChildDescriptor(
    PVOID HwDeviceExtension, 
    PVIDEO_CHILD_ENUM_INFO pChildInfo, 
    PVIDEO_CHILD_TYPE pChildType,
    PUCHAR pChildDescriptor, 
    PULONG pUId, 
    PULONG Unused
    )

/*+++

Routine Description:

    Enumerates all child devices attached to the specified device.

    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension 
        Pointer to our hardware device extension structure.

    ChildEnumInfo
        Pointer to VIDEO_CHILD_ENUM_INFO structure that describes the 
        device being enumerated. 

    pChildType
        Points to a location in which the miniport returns the type of 
        child being enumerated. 

    pChildDescriptor
        Points to a buffer in which the miniport can return data that 
        identifies the device. 

    pUId
        Points to the location in which the miniport returns a unique 
        32-bit identifier for this device. 

    pUnused
        Is unused and must be set to zero. 

Return Value:

    ERROR_MORE_DATA 
        There are more devices to be enumerated. 

    ERROR_NO_MORE_DEVICES 
        There are no more devices to be enumerated. 

    ERROR_INVALID_NAME 
        The miniport could not enumerate the child device identified in 
        ChildEnumInfo but does have more devices to be enumerated. 

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    VideoDebugPrint((3, "Perm3: Perm3GetChildDescriptor called\n"));

    switch(pChildInfo->ChildIndex) {
   
        case 0:

            //
            // Case 0 is used to enumerate devices found by the ACPI firmware.
            // We don't currently support ACPI devices
            //

            break;

        case 1:

            //
            // Treat index 1 as monitor
            //

            *pChildType = Monitor;
             
            //
            // First we search for a DFP monitor
            //

            if (GetDFPEdid(hwDeviceExtension, 
                           pChildDescriptor, 
                           pChildInfo->ChildDescriptorSize)) {

                //
                // found a DFP monitor
                //

                *pUId = PERM3_DFP_MONITOR;

                return(VIDEO_ENUM_MORE_DEVICES);
            } 

            //
            // If we didn't find a DFP, try to detect a DDC CRT monitor
            // 

            if(VideoPortDDCMonitorHelper(HwDeviceExtension, 
                                         &DDCControlCRT, 
                                         pChildDescriptor, 
                                         pChildInfo->ChildDescriptorSize)) {
                //
                // found a DDC monitor
                //

                *pUId = PERM3_DDC_MONITOR;

            } else {

                //
                // failed: assume non-DDC monitor
                //

                *pUId = PERM3_NONDDC_MONITOR;
            }

            return(VIDEO_ENUM_MORE_DEVICES);

    }

    return(ERROR_NO_MORE_DEVICES);
}

VOID
ProgramDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )
/*+++

Routine Description:

    Program the Perm3 chip to use DFP or not use DFP, depending on whether
    PERM3_DFP and PERM3_DFP_MON_ATTACHED are enabled in Perm3Capabilities.

---*/
{
    //
    // We only try this on boards that are DFP-capable.
    //

    if (hwDeviceExtension->Perm3Capabilities & PERM3_DFP) {
   
        ULONG rdMisc, vsConf, vsBCtl;
        pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
        P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;

        //
        // Get values of registers that we are going to trash
        //

        P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, rdMisc);

        //
        // Find out the values of the registers
        //

        vsConf = VideoPortReadRegisterUlong(VSTREAM_CONFIG);
        vsBCtl = VideoPortReadRegisterUlong(VSTREAM_B_CONTROL);

        //
        // Clear these bits
        //

        rdMisc &= ~P3RD_MISC_CONTROL_VSB_OUTPUT_ENABLED;
        vsConf &= ~VSTREAM_CONFIG_UNITMODE_MASK;
        vsBCtl &= ~VSTREAM_B_CONTROL_RAMDAC_ENABLE;

        if (hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED) {

            //        
            // Enable flat panel output as follows:
            //        

            rdMisc |= P3RD_MISC_CONTROL_VSB_OUTPUT_ENABLED;
            vsConf |= VSTREAM_CONFIG_UNITMODE_FP;
            vsBCtl |= VSTREAM_B_CONTROL_RAMDAC_ENABLE;
        } 
        else {
        
            //        
            // set up the registers for non-DFP mode.
            //        

            rdMisc &= (~P3RD_MISC_CONTROL_VSB_OUTPUT_ENABLED);
            vsConf |= VSTREAM_CONFIG_UNITMODE_CRT;
            vsBCtl |= VSTREAM_B_CONTROL_RAMDAC_DISABLE;
        }
        
        VideoDebugPrint((3, "Perm3: P3RD_ProgramDFP: PXRXCaps 0x%x, misc 0x%x, conf 0x%x, ctl 0x%x\n",
                             hwDeviceExtension->Perm3Capabilities, rdMisc, vsConf, vsBCtl));

        //
        // Program the registers
        //

        P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, rdMisc);
        VideoPortWriteRegisterUlong(VSTREAM_CONFIG, vsConf);
        VideoPortWriteRegisterUlong(VSTREAM_B_CONTROL, vsBCtl);
    }
}


VOID 
I2CWriteClock(
    PVOID HwDeviceExtension, 
    UCHAR data
    )
{
    const ULONG nbitClock = 3;
    const ULONG ClockMask = 1 << nbitClock;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;

    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ~ClockMask;
    ul |= (data & 1) << nbitClock;
    VideoPortWriteRegisterUlong(DDC_DATA, ul);
}

VOID 
I2CWriteData(
    PVOID HwDeviceExtension, 
    UCHAR data
    )
{
    const ULONG nbitData = 2;
    const ULONG DataMask = 1 << nbitData;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ~DataMask;
    ul |= ((data & 1) << nbitData);
    VideoPortWriteRegisterUlong(DDC_DATA, ul);
}

BOOLEAN 
I2CReadClock(
    PVOID HwDeviceExtension
    )
{
    const ULONG nbitClock = 1;
    const ULONG ClockMask = 1 << nbitClock;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ClockMask;
    ul >>= nbitClock;

    return((BOOLEAN)ul);
}

BOOLEAN 
I2CReadData(
    PVOID HwDeviceExtension
    )
{
    const ULONG nbitData = 0;
    const ULONG DataMask = 1 << nbitData;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= DataMask;
    ul >>= nbitData;

    return((BOOLEAN)ul);
}


BOOLEAN 
I2CReadDataDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )
{
    ULONG ul;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(VSTREAM_SERIAL_CONTROL);
    ul &= VSTREAM_SERIAL_CONTROL_DATAIN;
    return (ul != 0);
}

BOOLEAN 
I2CReadClockDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )
{
    ULONG ul;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul = VideoPortReadRegisterUlong(VSTREAM_SERIAL_CONTROL);
    ul &= VSTREAM_SERIAL_CONTROL_CLKIN;
    return (ul != 0);
}
VOID
I2CWriteDataDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR data 
    )
{
    ULONG ul = 0x0000E000;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul |= VideoPortReadRegisterUlong(VSTREAM_SERIAL_CONTROL);

    ul &= ~VSTREAM_SERIAL_CONTROL_DATAOUT;
    if(data & 1)
        ul |= VSTREAM_SERIAL_CONTROL_DATAOUT;
    
    VideoPortWriteRegisterUlong (VSTREAM_SERIAL_CONTROL, ul);
}
VOID
I2CWriteClockDFP(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    UCHAR data 
    )
{
    ULONG ul = 0x0000E000;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    ul |= VideoPortReadRegisterUlong(VSTREAM_SERIAL_CONTROL);

    ul &= ~VSTREAM_SERIAL_CONTROL_CLKOUT;
    if (data & 1)
        ul |= VSTREAM_SERIAL_CONTROL_CLKOUT;

    VideoPortWriteRegisterUlong (VSTREAM_SERIAL_CONTROL, ul);
}

BOOLEAN
GetDFPEdid(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PUCHAR EdidBuffer,
    LONG EdidSize
    )
{
    BOOLEAN DFPPresent = FALSE;

    //
    // If this board is capable of driving a DFP then try using DDC to see
    // if there is a monitor there.
    //

    if (hwDeviceExtension->Perm3Capabilities & PERM3_DFP) {

        //
        // Let's say that we have a monitor attached
        //

        hwDeviceExtension->Perm3Capabilities |= PERM3_DFP_MON_ATTACHED;

        //
        // Set up the DFP accordingly
        //

        ProgramDFP(hwDeviceExtension);

        DFPPresent = VideoPortDDCMonitorHelper(hwDeviceExtension, 
                                               &DDCControlDFP,
                                               EdidBuffer, 
                                               EdidSize);
    }

    //
    // If the board doesn't support flat panel or one isn't attached then
    // configure ourselves for non-DFP working.
    //

    if (!DFPPresent) {

        //
        // Well DDC says we don't have a DFP monitor attached, clear this bit
        //

        hwDeviceExtension->Perm3Capabilities &= ~PERM3_DFP_MON_ATTACHED;

        //
        // Set up the DFP accordingly
        //

        ProgramDFP(hwDeviceExtension);
    }

    return (DFPPresent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\video.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   video.c
*
* Abstract:
*
*    This module contains the code to setup the timing values for chips
*    and RAMDACs
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,InitializeVideo)
#pragma alloc_text(PAGE,P3RD_CalculateMNPForClock)
#pragma alloc_text(PAGE,P4RD_CalculateMNPForClock)
#pragma alloc_text(PAGE,SwitchToHiResMode)
#pragma alloc_text(PAGE,Program_P3RD)
#endif

#define ROTATE_LEFT_DWORD(dWord,cnt) (((cnt) < 0) ? (dWord) >> ((-cnt)) : (dWord) << (cnt))
#define ROTATE_RTIGHT_DWORD(dWord,cnt) (((cnt) < 0) ? (dWord) << ((-cnt)) : (dWord) >> (cnt))

#define INITIALFREQERR 100000

BOOLEAN
InitializeVideo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PPERM3_VIDEO_FREQUENCIES VideoMode
    )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION VideoModeInfo = &VideoMode->ModeEntry->ModeInformation;
    LONG dShift, dStrideShift;
    VESA_TIMING_STANDARD VESATimings;
    ULONG ulValue;
    ULONG Htot, Hss, Hse, Hbe, Hsp;
    ULONG Vtot, Vss, Vse, Vbe, Vsp;
    ULONG PixelClock, Freq, MemClock;
    ULONG RefClkSpeed, SystemClock;    // Speed of clocks in 100Hz units
    ULONG VTGPolarity;
    ULONG M, N, P, C, Q;
    ULONG DacDepth, depth, xRes, yRes;
    ULONG xStride;
    ULONG pixelData;
    ULONG ulMiscCtl;
    ULONG highWater, loWater;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    depth = VideoMode->BitsPerPel;
    xRes = VideoMode->ScreenWidth;
    yRes = VideoMode->ScreenHeight;
    Freq = VideoMode->ScreenFrequency;

    //
    // For timing calculations need full depth in bits
    //

    if ((DacDepth = depth) == 15) {

        DacDepth = 16;

    } else if (depth == 12) {

        DacDepth = 32;
    }

    //
    // Convert screen stride from bytes to pixels
    //

    xStride = (8 * VideoModeInfo->ScreenStride) / DacDepth;

    VideoDebugPrint((3, "Perm3: InitializeVideo called: depth %d, xres %d, yres %d, freq %d, xStride %d\n",
                         depth, xRes, yRes, Freq, xStride));

    //
    // Ensure minimum frequency of 60 Hz
    //

    if ((Freq < 60) && 
        !(hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED)) {

        VideoDebugPrint((3, "Perm3: Frequency raised to minimum of 60Hz\n"));
        Freq = 60;
    }

    //
    // Get the video timing, from the registry, if an entry exists, or from
    // the list of defaults, if it doesn't.
    //

    if( !GetVideoTiming(HwDeviceExtension, 
                        xRes, 
                        yRes, 
                        Freq, 
                        DacDepth, 
                        &VESATimings)) {

        VideoDebugPrint((0, "Perm3: GetVideoTiming failed."));
        return (FALSE);
    }

    //
    // We have got a valid set of VESA timigs
    // Extract timings from VESA list in a form that can be programmed into
    // the Perm3 timing generator.
    //

    Htot = GetHtotFromVESA (&VESATimings);
    Hss  = GetHssFromVESA  (&VESATimings);
    Hse  = GetHseFromVESA  (&VESATimings);
    Hbe  = GetHbeFromVESA  (&VESATimings);
    Hsp  = GetHspFromVESA  (&VESATimings);
    Vtot = GetVtotFromVESA (&VESATimings);
    Vss  = GetVssFromVESA  (&VESATimings);
    Vse  = GetVseFromVESA  (&VESATimings);
    Vbe  = GetVbeFromVESA  (&VESATimings);
    Vsp  = GetVspFromVESA  (&VESATimings);

    PixelClock = VESATimings.pClk;

    //
    // At 8BPP, if any of the horizontal parameters have any the bottom
    // bit set then we need to put the chip into 64-bit, pixel-doubling mode.
    //

    hwDeviceExtension->Perm3Capabilities &= ~PERM3_USE_BYTE_DOUBLING;
    
    //
    // If this resolution requires is one that requires pixel doubling then
    // set the flag
    //

    if (P3RD_CHECK_BYTE_DOUBLING(hwDeviceExtension, DacDepth, &VESATimings)) {

        hwDeviceExtension->Perm3Capabilities |= PERM3_USE_BYTE_DOUBLING;
    }

    VideoDebugPrint((3, "Perm3: P3RD %s require pixel-doubling, PXRXCaps 0x%x\n", 
        (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) ? "Do" : "Don't",
        hwDeviceExtension->Perm3Capabilities));

    //
    // if we're zooming by 2 in Y then double the vertical timing values.
    //

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2) {
  
        Vtot *= 2;
        Vss  *= 2;
        Vse  *= 2;
        Vbe  *= 2;
        PixelClock *= 2;
    }

    pixelData = PixelClock * (DacDepth / 8);

    if (pixelData > P3_MAX_PIXELDATA) {

        //
        // Failed pixelData validation
        //

        return (FALSE);
    }

    RefClkSpeed = hwDeviceExtension->RefClockSpeed  / 100;   // 100Hz units
    SystemClock = hwDeviceExtension->ChipClockSpeed / 100;   // 100Hz units

    //
    //  We do some basic initialization before setting up MCLK.
    //

    //
    //  disable the video control register
    //

    hwDeviceExtension->VideoControl = 0;

    VideoPortWriteRegisterUlong( VIDEO_CONTROL, 
                                 hwDeviceExtension->VideoControl );

    SwitchToHiResMode(hwDeviceExtension, TRUE);

    //
    // Setup Ramdac.
    //

    if(!Program_P3RD(HwDeviceExtension, 
                     VideoMode, 
                     Hsp, 
                     Vsp, 
                     RefClkSpeed, 
                     &SystemClock, 
                     &PixelClock, 
                     &MemClock)) {

        return(FALSE);
    }

    //
    // Set the LUT cache size to 256 and the first entry to zero, then
    // write the LUT cache to the LUT
    //

    LUT_CACHE_SETSIZE (256);
    LUT_CACHE_SETFIRST (0);

    (VOID) Perm3SetColorLookup (hwDeviceExtension,
                                &(hwDeviceExtension->LUTCache.LUTCache),
                                sizeof (hwDeviceExtension->LUTCache),
                                TRUE,     // Always update RAMDAC 
                                FALSE);   // Don't Update cache entries
    //
    // Setup VTG
    //

    //
    // We have to set or clear byte doubling for Perm3,depending on 
    //the whether the byte doubling capabilities flag is set.
    //

    ulMiscCtl = VideoPortReadRegisterUlong(MISC_CONTROL);

    ulMiscCtl &= ~PXRX_MISC_CONTROL_BYTE_DBL_ENABLE;
    ulMiscCtl |= (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) ? 
                  PXRX_MISC_CONTROL_BYTE_DBL_ENABLE : 0;

    VideoPortWriteRegisterUlong(MISC_CONTROL, ulMiscCtl);

    //
    // RAMDAC pll pins for VClkCtl            
    //

    ulValue = 3;   

    //
    // dShift is now used as a rotate count (it can be negative), instead of a
    // shift count. This means it won't work with 24-bit packed framebuffer 
    // layouts.
    //

   if (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) {

        //
        // Pretend we have a 64-bit pixel bus
        //

        dShift = DacDepth >> 4;

    } else if (DacDepth > 8) {

        //
        // 128-bit pixel bus
        //

        dShift = DacDepth >> 5; 

    } else  {

        //
        // We need a shift right not left
        //

        dShift = -1;
    }

    //
    // Stride & screenBase in 128-bit units
    //

    dStrideShift = 4;

    //
    // must load HgEnd before ScreenBase
    //

    VideoPortWriteRegisterUlong(HG_END, ROTATE_LEFT_DWORD (Hbe, dShift));
    VideoPortWriteRegisterUlong(V_CLK_CTL, ulValue);

    //
    // We just load the right screenbase with zero (the same as the left).
    // The display driver will update this when stereo buffers have been
    // allocated and stereo apps start running.
    //

    VideoPortWriteRegisterUlong(SCREEN_BASE_RIGHT, 0);
    VideoPortWriteRegisterUlong(SCREEN_BASE,0);
    VideoPortWriteRegisterUlong(SCREEN_STRIDE, (xStride >> dStrideShift) * (DacDepth >> 3)); // 64-bit units
    VideoPortWriteRegisterUlong(H_TOTAL,(ROTATE_LEFT_DWORD (Htot, dShift)) - 1);
    VideoPortWriteRegisterUlong(HS_START, ROTATE_LEFT_DWORD (Hss, dShift));
    VideoPortWriteRegisterUlong(HS_END, ROTATE_LEFT_DWORD (Hse, dShift));
    VideoPortWriteRegisterUlong(HB_END, ROTATE_LEFT_DWORD (Hbe, dShift));
    VideoPortWriteRegisterUlong(V_TOTAL, Vtot - 1);
    VideoPortWriteRegisterUlong(VS_START, Vss - 1);
    VideoPortWriteRegisterUlong(VS_END, Vse - 1);
    VideoPortWriteRegisterUlong(VB_END, Vbe);

    //
    // We need this to ensure that we get interrupts at the right time
    //

    VideoPortWriteRegisterUlong (INTERRUPT_LINE, 0);
            
    //
    // Set up video fifo stuff for Perm3
    //

    if(hwDeviceExtension->Capabilities & CAPS_INTERRUPTS) {
            
        //
        // We can use our reiterative formula. We start by setting
        // the thresholds to sensible values for a lo-res mode
        // (640x480x8) then turn on the FIFO  underrun error interrupt
        // (we do this after the mode change to avoid spurious
        // interrupts). In the interrupt routine we adjust the
        // thresholds whenever we get an underrun error
        //

        loWater = 8;
        highWater = 28;
                
        hwDeviceExtension->VideoFifoControl = (1 << 16) | (highWater << 8) | loWater;

        //
        // we'll want check for video FIFO errors via the error
        // interrupt only for a short time as P3/R3 generates a
        // lot of spurious interrupts too. Use the VBLANK interrupt
        // to time the period that we keep error interrupts enabled
        //

        hwDeviceExtension->VideoFifoControlCountdown = 20 * Freq;

        //
        // Don't actually update this register until we've left 
        // InitializeVideo - we don't want to enable error interrupts 
        // until the mode change has settled
        //

        hwDeviceExtension->IntEnable |= INTR_ERROR_SET | INTR_VBLANK_SET;

        //
        // We want VBLANK interrupts permanently enabled so that we
        // can monitor error flags for video FIFO underruns
        //

        hwDeviceExtension->InterruptControl.ControlBlock.Control |= PXRX_CHECK_VFIFO_IN_VBLANK;

    } else {

        //
        // We don't have interrupts calculate safe thresholds for
        // this mode. The high threshold can be determined using
        // the following formula.
        //

        highWater = ((PixelClock / 80) * (33 * DacDepth)) / MemClock;

        if (highWater < 28) {
               
            highWater = 28 - highWater;

            //
            // Low threshhold should be the lower of highWater/2 or 8.
            //

            loWater = (highWater + 1) / 2;

            if (loWater > 8)
                loWater = 8;

        } else {

            //
            // We don't have an algorithm for this so choose a safe value 
            //

            highWater = 0x01;
            loWater = 0x01;
        }

        hwDeviceExtension->VideoFifoControl = (highWater << 8) | loWater;
    }

    VideoPortWriteRegisterUlong(VIDEO_FIFO_CTL, hwDeviceExtension->VideoFifoControl);
        
    //
    // On a Perm3 set up the memory refresh counter
    // Memory refresh needs to be 64000 times per second.
    //

    ulValue = ((MemClock/640) - 16) / 32;
    VideoPortWriteRegisterUlong(PXRX_LOCAL_MEM_REFRESH, (ulValue << 1) | 1);

    VideoDebugPrint((3, "Perm3: Setting LocalMemRefresh to 0x%x\n", 
                         (ulValue << 1) | 1));

    //
    // enable H & V syncs to active high (the RAMDAC will invert these as necessary)
    // Enable video out.
    //

    VTGPolarity = (1 << 5) | (1 << 3) | 1;
            
    //
    // Set BufferSwapCtl to FreeRunning
    //

    VTGPolarity |= (1 << 9);

    //
    // Set up pixel size, this register is only on PXRX.
    //

    if (DacDepth == 8) {

        VTGPolarity |= (0 << 19);

    } else if (DacDepth == 16) {

        VTGPolarity |= (1 << 19);

    } else if (DacDepth == 32) {

        VTGPolarity |= (2 << 19);
    }

    //
    //  Do not Pitch
    //

    VTGPolarity |= (0 << 18);
            
    //
    // Set the stereo bit if it's enabled.
    //

    if(hwDeviceExtension->Capabilities & CAPS_STEREO) {

        VTGPolarity |= (1 << 11);

        //
        // Set RightEyeCtl bit to 1 as default
        //

        VTGPolarity |= (1 << 12);
    }

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2) {

        VTGPolarity |= (1 << 2);
    }

    hwDeviceExtension->VideoControlMonitorON = VTGPolarity & VC_DPMS_MASK;
    hwDeviceExtension->VideoControl = VTGPolarity;

    VideoPortWriteRegisterUlong( VIDEO_CONTROL, 
                                 hwDeviceExtension->VideoControl );  

    //
    // Record the final chip clock in the registry
    //

    SystemClock *= 100;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.CurrentChipClockSpeed",
                                       &SystemClock,
                                       sizeof(ULONG));
    MemClock *= 100;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.CurrentMemClockSpeed",
                                       &MemClock,
                                       sizeof(ULONG));

    PixelClock *= 100;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                       L"HardwareInformation.CurrentPixelClockSpeed",
                                       &PixelClock,
                                       sizeof(ULONG));
 
    hwDeviceExtension->bVTGRunning = TRUE;

    VideoDebugPrint((3, "Perm3: InitializeVideo Finished\n"));
    return(TRUE);
}

ULONG 
P3RD_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,        // In 100Hz units
    ULONG ReqClock,        // In 100Hz units
    ULONG *rM,             // M Out (feedback scaler)
    ULONG *rN,             // N Out (prescaler)
    ULONG *rP              // P Out (postscaler)
    )

/*+++

Routine Description:

     Calculates prescaler, feedback scaler and postscaler values for the
     STMACRO PLL71FS used by P3RD.

---*/
{
    const ULONG fMinVCO = 2000000;    // min fVCO is 200MHz (in 100Hz units)
    const ULONG fMaxVCO = 6220000;    // max fVCO is 622MHz (in 100Hz units)
    const ULONG fMinINTREF = 10000;   // min fINTREF is 1MHz (in 100Hz units)
    const ULONG fMaxINTREF = 20000;   // max fINTREF is 2MHz (in 100Hz units)
    ULONG M, N, P;
    ULONG fINTREF;
    ULONG fVCO;
    ULONG ActualClock;
    LONG  Error;
    LONG  LowestError = INITIALFREQERR;
    BOOLEAN bFoundFreq = FALSE;
    LONG  cInnerLoopIterations = 0;
    LONG  LoopCount;
    ULONG fVCOLowest, fVCOHighest;

    for(P = 0; P <= 5; ++P) {

        //
        // it's pointless going through the main loop if all values of
        // N produce an fVCO outside the acceptable range
        //

        N = 1;
        M = (N * (1 << P) * ReqClock) / (2 * RefClock);
        fVCOLowest = (2 * RefClock * M) / N;

        N = 255;
        M = (N * (1 << P) * ReqClock) / (2 * RefClock);
        fVCOHighest = (2 * RefClock * M) / N;

        if(fVCOHighest < fMinVCO || fVCOLowest > fMaxVCO) {

            continue;
        }

        for(N = 1; N <= 255; ++N, ++cInnerLoopIterations) {
       
            fINTREF = RefClock / N;

            if(fINTREF < fMinINTREF || fINTREF > fMaxINTREF) {

                if(fINTREF > fMaxINTREF){

                    //
                    // hopefully we'll get into range as the prescale value
                    // increases
                    //

                    continue;

                } else {

                    //
                    // already below minimum and it'll only get worse: move to
                    // the next postscale value
                    //

                    break;
                }
            }

            M = (N * (1 << P) * ReqClock) / (2 * RefClock);

            if(M > 255) {
            
                //
                // M, N & P registers are only 8 bits wide
                //

                break;
            }

            //
            // We can expect rounding errors in calculating M, which will
            // always be rounded down.  So we'll checkout our calculated
            // value of M along with (M+1)
            //

            for(LoopCount = (M == 255) ? 1 : 2; --LoopCount >= 0; ++M) {
            
                fVCO = (2 * RefClock * M) / N;

                if(fVCO >= fMinVCO && fVCO <= fMaxVCO) {
               
                    ActualClock = fVCO / (1 << P);

                    Error = ActualClock - ReqClock;

                    if(Error < 0)
                        Error = -Error;

                    if(Error < LowestError) {

                        bFoundFreq = TRUE;
                        LowestError = Error;
                        *rM = M;
                        *rN = N;
                        *rP = P;

                        if(Error == 0)
                            goto Done;
                    }
                }
            }
        }
    }

Done:
    
    if(bFoundFreq)
        ActualClock = (2 * RefClock * (*rM)) / ((*rN) * (1 << (*rP)));
    else
        ActualClock = 0;
    
    return(ActualClock);
}

ULONG P4RD_CalculateMNPForClock(
    PVOID hwDeviceExtension,
    ULONG RefClock,        // In 100Hz units
    ULONG ReqClock,        // In 100Hz units
    ULONG *rM,             // M Out (feedback scaler)
    ULONG *rN,             // N Out (prescaler)
    ULONG *rP              // P Out (postscaler)
    )

/*+++

Routine Description:

     Calculates prescaler, feedback scaler and postscaler values for the
     nurlogic NLC_PLL260i used by P4RD.

---*/

{
    const ULONG fMinVCO = 2000000;    // min fVCO is 200MHz (in 100Hz units)
    const ULONG fMaxVCO = 4000000;    // max fVCO is 400MHz (in 100Hz units)
    const ULONG fMinINTREF = 10000;   // min fINTREF is 1MHz (in 100Hz units)
    const ULONG fMaxINTREF = 20000;   // max fINTREF is 2MHz (in 100Hz units)
    ULONG M, N, P;
    ULONG fINTREF;
    ULONG fVCO;
    ULONG ActualClock;
    LONG Error;
    LONG LowestError = INITIALFREQERR;
    BOOLEAN bFoundFreq = FALSE;
    LONG cInnerLoopIterations = 0;
    LONG LoopCount;


    //
    // Actual Equations:
    //        fVCO = (RefClock * M)/(N+1)
    //        PIXELCLOCK = fVCO/(1<<p)
    //        200 <= fVCO <= 400
    //        24 <= M <= 80
    //        1 <= N <= 15
    //        0 <= P <= 3
    //        1Mhz < RefClock/(N+1) <= 2Mhz - not used
    //
    // For refclk == 14.318 we have the tighter equations:
    //        32 <= M <= 80
    //        3 <= N <= 12

    #define P4RD_PLL_MIN_P 0
    #define P4RD_PLL_MAX_P 3
    #define P4RD_PLL_MIN_N 1
    #define P4RD_PLL_MAX_N 12
    #define P4RD_PLL_MIN_M 24
    #define P4RD_PLL_MAX_M 80

    for(P = P4RD_PLL_MIN_P; P <= P4RD_PLL_MAX_P; ++P) {

        ULONG fVCOLowest, fVCOHighest;
  
        //
        // It's pointless going through the main loop if all values 
        // of N produce an fVCO outside the acceptable range
        //

        N = P4RD_PLL_MIN_N;
        M = ((N + 1) * (1 << P) * ReqClock) / RefClock;

        fVCOLowest = (RefClock * M) / (N + 1);

        N = P4RD_PLL_MAX_N;
        M = ((N + 1) * (1 << P) * ReqClock) / RefClock;

        fVCOHighest = (RefClock * M) / (N + 1);

        if(fVCOHighest < fMinVCO || fVCOLowest > fMaxVCO) {

            continue;
        }

        for( N = P4RD_PLL_MIN_N; 
             N <= P4RD_PLL_MAX_N; 
             ++N, ++cInnerLoopIterations ) {

            M = ((N + 1) * (1 << P) * ReqClock) / RefClock;

            if(M > P4RD_PLL_MAX_M || M < P4RD_PLL_MIN_M) {
           
                //
                // M is only 7 bits wide
                //

                continue;
            }

            //
            // We can expect rounding errors in calculating M, which
            // will always be rounded down. So we'll checkout our 
            // calculated value of M along with (M+1)
            //

            for( LoopCount = (M == P4RD_PLL_MAX_M) ? 1 : 2; 
                 --LoopCount >= 0; 
                 ++M ) {

                fVCO = (RefClock * M) / (N + 1);

                if(fVCO >= fMinVCO && fVCO <= fMaxVCO) {
               
                    ActualClock = fVCO / (1 << P);
                    Error = ActualClock - ReqClock;

                    if(Error < 0)
                        Error = -Error;
                    //
                    // It is desirable that we use the lowest value of N if the
                    // frequencies are the same.
                    //

                    if((Error < LowestError) || 
                       (Error == LowestError && N < *rN)) {
                    
                        bFoundFreq = TRUE;
                        LowestError = Error;
                        *rM = M;
                        *rN = N;
                        *rP = P;

                        if(Error == 0)
                            goto Done;
                    }
                }
            }
        }
    }

Done:
   
    if(bFoundFreq)
        ActualClock = (RefClock * (*rM)) / (((*rN) + 1) * (1 <<(*rP)));
    else
        ActualClock = 0;

    return(ActualClock);
}


BOOLEAN Program_P3RD(
    PHW_DEVICE_EXTENSION HwDeviceExtension, 
    PPERM3_VIDEO_FREQUENCIES VideoMode, 
    ULONG Hsp, 
    ULONG Vsp,
    ULONG RefClkSpeed, 
    PULONG pSystemClock, 
    PULONG pPixelClock, 
    PULONG pMemClock
    )

/*+++

Routine Description:

       Initializes the P3RD registers and programs the DClk (pixel clock)
       and MClk (system clock) PLLs. After programming the MClk, the
       contents of all registers in the graphics core, the memory controller
       and the video control should be assumed to be undefined

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION VideoModeInfo = &VideoMode->ModeEntry->ModeInformation;
    ULONG DacDepth, depth;
    ULONG index;
    ULONG color;
    ULONG ulValue;
    UCHAR pixelCtrl;
    ULONG mClkSrc = 0, sClkSrc = 0;
    VP_STATUS status;
    ULONG M, N, P;

    //
    // If we are using 64-bit mode then we need to double the pixel 
    // clock and set the pixel doubling bit in the RAMDAC.
    //

    ULONG pixelClock = (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) ? (*pPixelClock) << 1 : (*pPixelClock);        

    //
    // Double the desired system clock as P3 has a divider, which divides 
    // this down again.
    //

    ULONG coreClock = (*pSystemClock << 1);
                                              
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
    P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;

    mClkSrc = (hwDeviceExtension->bHaveExtendedClocks ? hwDeviceExtension->ulPXRXMemoryClockSrc : P3RD_DEFAULT_MCLK_SRC);
    sClkSrc = (hwDeviceExtension->bHaveExtendedClocks ? hwDeviceExtension->ulPXRXSetupClockSrc: P3RD_DEFAULT_SCLK_SRC);

    depth = VideoMode->BitsPerPel;

    //
    // For timing calculations need full depth in bits
    //

    if ((DacDepth = depth) == 15) {
        DacDepth = 16;
    }
    else if (depth == 12) {
        DacDepth = 32;
    }

    //
    // Set up Misc Control
    //

    P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

    ulValue &= ~( P3RD_MISC_CONTROL_HIGHCOLORRES | 
                  P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED |
                  P3RD_MISC_CONTROL_PIXEL_DOUBLE );

    P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, 
                        ulValue | 
                        P3RD_MISC_CONTROL_HIGHCOLORRES | 
                        P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED);

    VideoPortWriteRegisterUlong(P3RD_INDEX_CONTROL,
                                P3RD_IDX_CTL_AUTOINCREMENT_ENABLED);

    ulValue = (Hsp ? P3RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH : P3RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW) |
              (Vsp ? P3RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH : P3RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW);

    P3RD_LOAD_INDEX_REG(P3RD_SYNC_CONTROL, ulValue);
    P3RD_LOAD_INDEX_REG(P3RD_DAC_CONTROL, 
                        P3RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED);

    ulValue = 0;

    if (hwDeviceExtension->Perm3Capabilities & PERM3_USE_BYTE_DOUBLING) {
   
        ulValue |= P3RD_CURSOR_CONTROL_DOUBLE_X;
    }

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2) {
   
        ulValue |= P3RD_CURSOR_CONTROL_DOUBLE_Y;
    }

    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_CONTROL,   ulValue);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_MODE,      0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_X_LOW,     0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_X_HIGH,    0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_Y_LOW,     0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_Y_HIGH,    0xff);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_HOTSPOT_X, 0);
    P3RD_LOAD_INDEX_REG(P3RD_CURSOR_HOTSPOT_Y, 0);
    P3RD_LOAD_INDEX_REG(P3RD_PAN, 0);

    //
    // The first 3-color cursor is the mini cursor which is always
    // black & white. Set it up here

    P3RD_CURSOR_PALETTE_CURSOR_RGB(P3RD_CALCULATE_LUT_INDEX(0), 0x00,0x00,0x00);
    P3RD_CURSOR_PALETTE_CURSOR_RGB(P3RD_CALCULATE_LUT_INDEX(1), 0xff,0xff,0xff);

    //
    // Stop all clocks
    //

    P3RD_LOAD_INDEX_REG(P3RD_DCLK_CONTROL, 0);
    P3RD_LOAD_INDEX_REG(P3RD_KCLK_CONTROL, 0);
    P3RD_LOAD_INDEX_REG(P3RD_MCLK_CONTROL, 0);
    P3RD_LOAD_INDEX_REG(P3RD_SCLK_CONTROL, 0);

    //
    // Belt and braces let's set MCLK to something just in case
    // Let's enable SCLK and MCLK.
    //

    *pMemClock = PERMEDIA3_DEFAULT_MCLK_SPEED / 100;  // Convert from Hz to 100 Hz

    VideoDebugPrint((3, "Perm3: Program_P3RD: mClkSrc 0x%x, sClkSrc 0x%x, mspeed %d00\n", 
                         mClkSrc, sClkSrc, *pMemClock));

    P3RD_LOAD_INDEX_REG(P3RD_MCLK_CONTROL, 
                        P3RD_MCLK_CONTROL_ENABLED | 
                        P3RD_MCLK_CONTROL_RUN | mClkSrc);

    P3RD_LOAD_INDEX_REG(P3RD_SCLK_CONTROL, 
                        P3RD_SCLK_CONTROL_ENABLED | 
                        P3RD_SCLK_CONTROL_RUN | 
                        sClkSrc);

    if (hwDeviceExtension->deviceInfo.DeviceId == PERMEDIA3_ID ) {
	
        pixelClock = P3RD_CalculateMNPForClock(HwDeviceExtension, 
                                               RefClkSpeed, 
                                               pixelClock, 
                                               &M,
                                               &N,
                                               &P);
    } else {
	
        pixelClock = P4RD_CalculateMNPForClock(HwDeviceExtension, 
                                               RefClkSpeed, 
                                               pixelClock, 
                                               &M,
                                               &N,
                                               &P);
    }

    if(pixelClock == 0) {
   
        VideoDebugPrint((0, "Perm3: Program_P3RD: P3RD_CalculateMNPForClock(PixelClock) failed\n"));
        return(FALSE);
    }

    //
    // load both copies of the dot clock with our times (DCLK0 & DCLK1 reserved for VGA only)
    //

    P3RD_LOAD_INDEX_REG(P3RD_DCLK2_PRE_SCALE,      N);
    P3RD_LOAD_INDEX_REG(P3RD_DCLK2_FEEDBACK_SCALE, M);
    P3RD_LOAD_INDEX_REG(P3RD_DCLK2_POST_SCALE,     P);

    P3RD_LOAD_INDEX_REG(P3RD_DCLK3_PRE_SCALE,      N);
    P3RD_LOAD_INDEX_REG(P3RD_DCLK3_FEEDBACK_SCALE, M);
    P3RD_LOAD_INDEX_REG(P3RD_DCLK3_POST_SCALE,     P);

    if (hwDeviceExtension->deviceInfo.DeviceId == PERMEDIA3_ID ) {
	
        coreClock = P3RD_CalculateMNPForClock(HwDeviceExtension, 
                                              RefClkSpeed, 
                                              coreClock, 
                                              &M, 
                                              &N, 
                                              &P);
    } else {

        coreClock = P4RD_CalculateMNPForClock(HwDeviceExtension, 
                                              RefClkSpeed, 
                                              coreClock, 
                                              &M, 
                                              &N, 
                                              &P);
    }

    if(coreClock == 0) {
   
        VideoDebugPrint((0, "Perm3: Program_P3RD: P3RD_CalculateMNPForClock(SystemClock) failed\n"));
        return(FALSE);
    }

    //
    // load the core clock
    //

    P3RD_LOAD_INDEX_REG(P3RD_KCLK_PRE_SCALE,      N);
    P3RD_LOAD_INDEX_REG(P3RD_KCLK_FEEDBACK_SCALE, M);
    P3RD_LOAD_INDEX_REG(P3RD_KCLK_POST_SCALE,     P);

    //
    // Enable the dot clock
    //

    P3RD_LOAD_INDEX_REG(P3RD_DCLK_CONTROL, 
                        P3RD_DCLK_CONTROL_ENABLED | P3RD_DCLK_CONTROL_RUN);

    M = 0x100000;

    do {
   
        P3RD_READ_INDEX_REG(P3RD_DCLK_CONTROL, ulValue);
    }
    while((ulValue & P3RD_DCLK_CONTROL_LOCKED) == FALSE && --M);

    if((ulValue & P3RD_DCLK_CONTROL_LOCKED) == FALSE) {
   
        VideoDebugPrint((0, "Perm3: Program_P3RD: PixelClock failed to lock\n"));
        return(FALSE);
    }

    //
    // Enable the core clock
    //

    P3RD_LOAD_INDEX_REG(P3RD_KCLK_CONTROL, 
                        P3RD_KCLK_CONTROL_ENABLED | 
                        P3RD_KCLK_CONTROL_RUN | 
                        P3RD_KCLK_CONTROL_PLL);

    M = 0x100000;

    do {
   
        P3RD_READ_INDEX_REG(P3RD_KCLK_CONTROL, ulValue);
    }

    while((ulValue & P3RD_KCLK_CONTROL_LOCKED) == FALSE && --M);

    if((ulValue & P3RD_KCLK_CONTROL_LOCKED) == FALSE) {
   
        VideoDebugPrint((0, "Perm3: Program_P3RD: SystemClock failed to lock\n"));
        return(FALSE);
    }

    switch (depth) {
    
      case 8:

        P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
        ulValue &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
        P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
        P3RD_LOAD_INDEX_REG(P3RD_PIXEL_SIZE, P3RD_PIXEL_SIZE_8BPP);

        //
        // Color indexed mode
        //

        P3RD_LOAD_INDEX_REG(P3RD_COLOR_FORMAT, 
                            P3RD_COLOR_FORMAT_CI8 | P3RD_COLOR_FORMAT_RGB);

        break;

      case 15:
      case 16:

        P3RD_LOAD_INDEX_REG(P3RD_PIXEL_SIZE, P3RD_PIXEL_SIZE_16BPP);

#if  GAMMA_CORRECTION
        P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
        ulValue &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
        P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

        //
        // load linear ramp into LUT as default
        //

        for (index = 0; index <= 0xff; ++index) {

            LUT_CACHE_SETRGB (index, index, index, index);
        }

        pixelCtrl = 0;
#else
        P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
        ulValue |= P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
        P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

        pixelCtrl = P3RD_COLOR_FORMAT_LINEAR_EXT;
#endif
        pixelCtrl |= (depth == 16) ? P3RD_COLOR_FORMAT_16BPP : P3RD_COLOR_FORMAT_15BPP;
        pixelCtrl |= P3RD_COLOR_FORMAT_RGB;

        VideoDebugPrint((3, "Perm3: P3RD_COLOR_FORMAT = 0x%x\n", pixelCtrl));

        P3RD_LOAD_INDEX_REG(P3RD_COLOR_FORMAT, pixelCtrl);
        break;

      case 12:
      case 24:
      case 32:

        P3RD_LOAD_INDEX_REG(P3RD_PIXEL_SIZE, P3RD_PIXEL_SIZE_32BPP);

        P3RD_LOAD_INDEX_REG(P3RD_COLOR_FORMAT, 
                            P3RD_COLOR_FORMAT_32BPP | P3RD_COLOR_FORMAT_RGB);

        if (depth == 12) {
        
            USHORT cacheIndex;

            P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
            ulValue &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

            //
            // use auto-increment to load a ramp into entries 0 to 15
            //

            VideoDebugPrint((3, "Perm3: 12 BPP. loading palette\n"));

            for (index = 0, cacheIndex = 0; 
                 index <= 0xff; 
                 index += 0x11, cacheIndex++) {

                LUT_CACHE_SETRGB (index, index, index, index);
            }

            //
            // load ramp in every 16th entry from 16 to 240
            //

            color = 0x11;

            for (index = 0x10; index <= 0xf0; index += 0x10, color += 0x11) {

                LUT_CACHE_SETRGB (index, color, color, color);
            }

            P3RD_SET_PIXEL_READMASK(0x0f);

        } else {

#if  GAMMA_CORRECTION
            P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
            ulValue &= ~P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

            //
            // load linear ramp into LUT as default
            //

            for (index = 0; index <= 0xff; ++index) {
                  LUT_CACHE_SETRGB (index, index, index, index);
            }
#else
            P3RD_READ_INDEX_REG(P3RD_MISC_CONTROL, ulValue);
            ulValue |= P3RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P3RD_LOAD_INDEX_REG(P3RD_MISC_CONTROL, ulValue);

#endif  // GAMMA_CORRECTION

        }

        break;

      default:
          VideoDebugPrint((0, "Perm3: Program_P3RD: bad depth %d \n", depth));

      return(FALSE);

    }

    //
    // Blank the analogue display if we are using a DFP, also re-program the 
    // DFPO because the BIOS may have trashed some of the registers
    // that we programmed at start of day.
    //

    if( hwDeviceExtension->Perm3Capabilities & PERM3_DFP_MON_ATTACHED ) {

        //
        // Only blank the CRT if the mode is less than 60Hz refresh.
        //

        if( VideoMode->ScreenFrequency < 60 ) {

            P3RD_LOAD_INDEX_REG(P3RD_DAC_CONTROL, 1);
        }

        ProgramDFP (hwDeviceExtension);
    }

    //
    // Return these values
    //     *pPixelClock = pixelClock;
    //     *pSystemClock = coreClock;
    //

    switch( mClkSrc ) {
        case P3RD_MCLK_CONTROL_HALF_PCLK:
            *pMemClock = 33 * 10000;
        break;

        case P3RD_MCLK_CONTROL_PCLK:
            *pMemClock = 66 * 10000;
        break;

        case P3RD_MCLK_CONTROL_HALF_EXTMCLK:
            *pMemClock = *pMemClock / 2;
        break;

        case P3RD_MCLK_CONTROL_EXTMCLK:
            //*pMemClock = *pMemClock;
        break;

        case P3RD_MCLK_CONTROL_HALF_KCLK:
            *pMemClock = (coreClock >> 1) / 2;
        break;

        case P3RD_MCLK_CONTROL_KCLK:
            *pMemClock = (coreClock >> 1);
        break;
    }

    return(TRUE);
}

VOID 
SwitchToHiResMode(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    BOOLEAN bHiRes)

/*+++

Routine Description:

    This function switches into and out of hi-res mode

---*/
{
    USHORT usData;
    
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // Enable graphics mode, disable VGA
    //
    // We have to unlock VGA registers on P3 before we can use them
    //

    UNLOCK_VGA_REGISTERS(); 

    VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, PERMEDIA_VGA_CTRL_INDEX);
    usData = (USHORT)VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);

    if(bHiRes) {
        usData &= ~PERMEDIA_VGA_ENABLE;
    } else {
        usData |= PERMEDIA_VGA_ENABLE;
    }

    usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;
    VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);

    //
    // We must lock VGA registers on P3 after use
    //

    LOCK_VGA_REGISTERS(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\bltio.c ===
/******************************Module*Header*******************************\
* Module Name: bltio.c
*
* Contains the low-level in/out blt functions.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify anything in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"


#if DBG

// Useful aid for disabling any ATI extensions for debugging purposes:

BOOL gb8514a = FALSE;

#endif // DBG

/******************************Public*Routine******************************\
* VOID vIoFillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vIoFillSolid(              // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode
ULONG           ulHwBackMix,    // Not used
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ulHwForeMix <= 15, "Weird hardware Rop");

    // It's quite likely that we've just been called from GDI, so it's
    // even more likely that the accelerator's graphics engine has been
    // sitting around idle.  Rather than doing a FIFO_WAIT(3) here and
    // then a FIFO_WAIT(5) before outputing the actual rectangle,
    // we can avoid an 'in' (which can be quite expensive, depending on
    // the card) by doing a single FIFO_WAIT(8) right off the bat:

    IO_FIFO_WAIT(ppdev, 8);
    IO_PIX_CNTL(ppdev, ALL_ONES);
    IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
    IO_FRGD_COLOR(ppdev, rbc.iSolidColor);

    while(TRUE)
    {
        IO_CUR_X(ppdev, prcl->left);
        IO_CUR_Y(ppdev, prcl->top);
        IO_MAJ_AXIS_PCNT(ppdev, prcl->right  - prcl->left - 1);
        IO_MIN_AXIS_PCNT(ppdev, prcl->bottom - prcl->top  - 1);

        IO_CMD(ppdev, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                      DRAW           | DIR_TYPE_XY        |
                      LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                      WRITE);

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 5);
    }
}

/******************************Public*Routine******************************\
* VOID vIoSlowPatRealize
*
* This routine transfers an 8x8 pattern to off-screen display memory, and
* duplicates it to make a 64x64 cached realization which is then used by
* vIoFillPatSlow as the basic building block for doing 'slow' pattern output
* via repeated screen-to-screen blts.
*
\**************************************************************************/

VOID vIoSlowPatRealize(
PDEV*   ppdev,
RBRUSH* prb,                    // Points to brush realization structure
BOOL    bTransparent)           // FALSE for normal patterns; TRUE for
                                //   patterns with a mask when the background
                                //   mix is LEAVE_ALONE.
{
    BRUSHENTRY* pbe;
    LONG        iBrushCache;
    LONG        x;
    LONG        y;
    BYTE*       pjSrc;
    BYTE*       pjDst;
    BYTE        jSrc;
    LONG        i;
    WORD        awBuf[8];

    pbe = prb->pbe;
    if ((pbe == NULL) || (pbe->prbVerify != prb))
    {
        // We have to allocate a new off-screen cache brush entry for
        // the brush:

        iBrushCache = ppdev->iBrushCache;
        pbe         = &ppdev->abe[iBrushCache];

        iBrushCache++;
        if (iBrushCache >= ppdev->cBrushCache)
            iBrushCache = 0;

        ppdev->iBrushCache = iBrushCache;

        // Update our links:

        pbe->prbVerify = prb;
        prb->pbe       = pbe;
    }

    // Load some pointer variables onto the stack, so that we don't have
    // to keep dereferencing their pointers:

    x = pbe->x;
    y = pbe->y;

    prb->bTransparent = bTransparent;

    // I considered doing the colour expansion for 1bpp brushes in
    // software, but by letting the hardware do it, we don't have
    // to do as many OUTs to transfer the pattern.

    if (prb->fl & RBRUSH_2COLOR)
    {
        // We're going to do a colour-expansion ('across the plane')
        // bitblt of the 1bpp 8x8 pattern to the screen.

        if (!bTransparent)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | OVERPAINT);
            IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | OVERPAINT);
            IO_FRGD_COLOR(ppdev, prb->ulForeColor);
            IO_BKGD_COLOR(ppdev, prb->ulBackColor);

            IO_FIFO_WAIT(ppdev, 5);
        }
        else
        {
            IO_FIFO_WAIT(ppdev, 7);

            IO_FRGD_MIX(ppdev, LOGICAL_1);
            IO_BKGD_MIX(ppdev, LOGICAL_0);
        }

        IO_PIX_CNTL(ppdev, CPU_DATA);
        IO_ABS_CUR_X(ppdev, x);
        IO_ABS_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, 7); // Brush is 8 wide
        IO_MIN_AXIS_PCNT(ppdev, 7); // Brush is 8 high

        IO_GP_WAIT(ppdev);

        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16 | WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW        | LAST_PIXEL_ON |
                      MULTIPLE_PIXELS    | WRITE       | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        pjSrc = (BYTE*) &prb->aulPattern[0];
        pjDst = (BYTE*) &awBuf[0];

        // Convert in-line to nibble arrangment:

        // LATER: This should be done in DrvRealizeBrush!

        for (i = 8; i != 0; i--)
        {
            jSrc      = *pjSrc;
            pjSrc    += 2;              // We had an extra byte on every row
            *pjDst++  = jSrc >> 3;
            *pjDst++  = jSrc + jSrc;
        }

        vDataPortOut(ppdev, &awBuf[0], 8);
                // Each word transferred comprises one row of the
                //   pattern, and there are 8 rows in the pattern

        CHECK_DATA_COMPLETE(ppdev);
    }
    else
    {
        ASSERTDD(!bTransparent,
            "Shouldn't have been asked for transparency with a non-1bpp brush");

        IO_FIFO_WAIT(ppdev, 6);

        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, SRC_CPU_DATA | OVERPAINT);
        IO_ABS_CUR_X(ppdev, x);
        IO_ABS_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, 7);     // Brush is 8 wide
        IO_MIN_AXIS_PCNT(ppdev, 7);     // Brush is 8 high

        IO_GP_WAIT(ppdev);

        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                      SINGLE_PIXEL       | WRITE      | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        vDataPortOut(ppdev, &prb->aulPattern[0],
                     ((TOTAL_BRUSH_SIZE / 2) << ppdev->cPelSize));

        CHECK_DATA_COMPLETE(ppdev);
    }

    // Ŀ
    // 023  4      1 We now have an 8x8 colour-expanded copy of
    // Ĵ the pattern sitting in off-screen memory,
    // 5                 represented here by square '0'.
    //                  
    //                   We're now going to expand the pattern to
    //                   72x72 by repeatedly copying larger rectangles
    //                   in the indicated order, and doing a 'rolling'
    //                   blt to copy vertically.
    //                  
    // 

    // Copy '1':

    IO_FIFO_WAIT(ppdev, 7);

    IO_PIX_CNTL(ppdev, ALL_ONES);
    IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | OVERPAINT);

    // Note that 'maj_axis_pcnt' and 'min_axis_pcnt' are already
    // correct.

    IO_ABS_CUR_X(ppdev, x);
    IO_ABS_CUR_Y(ppdev, y);
    IO_ABS_DEST_X(ppdev, x + 64);
    IO_ABS_DEST_Y(ppdev, y);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

    // Copy '2':

    IO_FIFO_WAIT(ppdev, 8);

    IO_ABS_DEST_X(ppdev, x + 8);
    IO_ABS_DEST_Y(ppdev, y);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

    // Copy '3':

    IO_ABS_DEST_X(ppdev, x + 16);
    IO_ABS_DEST_Y(ppdev, y);
    IO_MAJ_AXIS_PCNT(ppdev, 15);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);
    IO_ABS_DEST_X(ppdev, x + 32);

    // Copy '4':

    IO_FIFO_WAIT(ppdev, 8);

    IO_ABS_DEST_Y(ppdev, y);
    IO_MAJ_AXIS_PCNT(ppdev, 31);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

    // Copy '5':

    IO_ABS_DEST_X(ppdev, x);
    IO_ABS_DEST_Y(ppdev, y + 8);
    IO_MAJ_AXIS_PCNT(ppdev, 71);
    IO_MIN_AXIS_PCNT(ppdev, 63);
    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);
}


/******************************Public*Routine******************************\
* VOID vIoFillPatSlow
*
* Uses the screen-to-screen blting ability of the accelerator to fill a
* list of rectangles with a specified pattern.  This routine is 'slow'
* merely in the sense that it doesn't use any built-in hardware pattern
* support that may be built into the accelerator.
*
\**************************************************************************/

VOID vIoFillPatSlow(            // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           ulHwForeMix,    // Hardware mix mode (foreground mix mode if
                                //   the brush has a mask)
ULONG           ulHwBackMix,    // Not used (unless the brush has a mask, in
                                //   which case it's the background mix mode)
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BOOL        bTransparent;
    BOOL        bExponential;
    LONG        x;
    LONG        y;
    LONG        yTmp;
    LONG        cxToGo;
    LONG        cyToGo;
    LONG        cxThis;
    LONG        cyThis;
    LONG        xOrg;
    LONG        yOrg;
    LONG        xBrush;
    LONG        yBrush;
    LONG        cyOriginal;
    BRUSHENTRY* pbe;        // Pointer to brush entry data, which is used
                            //   for keeping track of the location and status
                            //   of the pattern bits cached in off-screen
                            //   memory

    // C'est dommage que je ne connais pas quoi je fais.

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(rbc.prb->pbe != NULL, "Unexpected Null pbe in vIoSlowPatBlt");
    ASSERTDD(ulHwForeMix <= 15, "Weird hardware Rop");
    ASSERTDD((ulHwForeMix == ulHwBackMix) || (ulHwBackMix == LEAVE_ALONE),
             "Only expect transparency from GDI for masked brushes");

    bTransparent = (ulHwForeMix != ulHwBackMix);

    if ((rbc.prb->pbe->prbVerify != rbc.prb) ||
        (rbc.prb->bTransparent != bTransparent))
    {
        vIoSlowPatRealize(ppdev, rbc.prb, bTransparent);
    }

    ASSERTDD(rbc.prb->bTransparent == bTransparent,
             "Not realized with correct transparency");

    if (!bTransparent)
    {
        IO_FIFO_WAIT(ppdev, 2);
        IO_PIX_CNTL(ppdev, ALL_ONES);
        IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | ulHwForeMix);

        // We special case OVERPAINT mixes because we can implement
        // an exponential fill: every blt will double the size of
        // the current rectangle by using the portion of the pattern
        // that has already been done for this rectangle as the source.
        //
        // Note that there's no point in also checking for LOGICAL_0
        // or LOGICAL_1 because those will be taken care of by the
        // solid fill routines, and I can't be bothered to check for
        // NOTNEW:

        bExponential = (ulHwForeMix == OVERPAINT);
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 5);

        IO_PIX_CNTL(ppdev, DISPLAY_MEMORY);
        IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
        IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | LEAVE_ALONE);
        IO_FRGD_COLOR(ppdev, rbc.prb->ulForeColor);
        IO_RD_MASK(ppdev, 1);           // Pick a plane, any plane

        bExponential = FALSE;
    }

    // Note that since we do our brush alignment calculations in
    // relative coordinates, we should keep the brush origin in
    // relative coordinates as well:

    xOrg = pptlBrush->x;
    yOrg = pptlBrush->y;

    pbe    = rbc.prb->pbe;
    xBrush = pbe->x;
    yBrush = pbe->y;

    do {
        x = prcl->left;
        y = prcl->top;

        cxToGo = prcl->right  - x;
        cyToGo = prcl->bottom - y;

        if ((cxToGo <= SLOW_BRUSH_DIMENSION) &&
            (cyToGo <= SLOW_BRUSH_DIMENSION))
        {
            IO_FIFO_WAIT(ppdev, 7);
            IO_ABS_CUR_X(ppdev, ((x - xOrg) & 7) + xBrush);
            IO_ABS_CUR_Y(ppdev, ((y - yOrg) & 7) + yBrush);
            IO_DEST_X(ppdev, x);
            IO_DEST_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, cxToGo - 1);
            IO_MIN_AXIS_PCNT(ppdev, cyToGo - 1);
            IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                          MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);
        }

        else if (bExponential)
        {
            cyThis  = SLOW_BRUSH_DIMENSION;
            cyToGo -= cyThis;
            if (cyToGo < 0)
                cyThis += cyToGo;

            cxThis  = SLOW_BRUSH_DIMENSION;
            cxToGo -= cxThis;
            if (cxToGo < 0)
                cxThis += cxToGo;

            IO_FIFO_WAIT(ppdev, 7);
            IO_MAJ_AXIS_PCNT(ppdev, cxThis - 1);
            IO_MIN_AXIS_PCNT(ppdev, cyThis - 1);
            IO_DEST_X(ppdev, x);
            IO_DEST_Y(ppdev, y);
            IO_ABS_CUR_X(ppdev, ((x - xOrg) & 7) + xBrush);
            IO_ABS_CUR_Y(ppdev, ((y - yOrg) & 7) + yBrush);
            IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                          MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

            IO_FIFO_WAIT(ppdev, 2);
            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);

            x += cxThis;

            while (cxToGo > 0)
            {
                // First, expand out to the right, doubling our size
                // each time:

                cxToGo -= cxThis;
                if (cxToGo < 0)
                    cxThis += cxToGo;

                IO_FIFO_WAIT(ppdev, 4);
                IO_MAJ_AXIS_PCNT(ppdev, cxThis - 1);
                IO_DEST_X(ppdev, x);
                IO_DEST_Y(ppdev, y);
                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

                x      += cxThis;
                cxThis *= 2;
            }

            if (cyToGo > 0)
            {
                // Now do a 'rolling blt' to pattern the rest vertically:

                IO_FIFO_WAIT(ppdev, 5);
                IO_DEST_X(ppdev, prcl->left);
                IO_DEST_Y(ppdev, prcl->top + cyThis);
                IO_MAJ_AXIS_PCNT(ppdev, prcl->right - prcl->left - 1);
                IO_MIN_AXIS_PCNT(ppdev, cyToGo - 1);
                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);
            }
        }
        else
        {
            // We handle arbitrary mixes simply by repeatedly tiling
            // our cached pattern over the entire rectangle:

            IO_FIFO_WAIT(ppdev, 2);
            IO_ABS_CUR_X(ppdev, ((x - xOrg) & 7) + xBrush);
            IO_ABS_CUR_Y(ppdev, ((y - yOrg) & 7) + yBrush);

            cyOriginal = cyToGo;        // Have to remember for later...

            do {
                cxThis  = SLOW_BRUSH_DIMENSION;
                cxToGo -= cxThis;
                if (cxToGo < 0)
                    cxThis += cxToGo;

                IO_FIFO_WAIT(ppdev, 2);
                IO_MAJ_AXIS_PCNT(ppdev, cxThis - 1);
                IO_DEST_X(ppdev, x);

                x     += cxThis;        // Get ready for next column
                cyToGo = cyOriginal;    // Have to reset for each new column
                yTmp   = y;

                do {
                    cyThis  = SLOW_BRUSH_DIMENSION;
                    cyToGo -= cyThis;
                    if (cyToGo < 0)
                        cyThis += cyToGo;

                    IO_FIFO_WAIT(ppdev, 3);
                    IO_DEST_Y(ppdev, yTmp);
                    yTmp += cyThis;
                    IO_MIN_AXIS_PCNT(ppdev, cyThis - 1);
                    IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                                  MULTIPLE_PIXELS | DRAWING_DIR_TBLRXM);

                } while (cyToGo > 0);
            } while (cxToGo > 0);
        }
        prcl++;
    } while (--c != 0);
}

/******************************Public*Routine******************************\
* VOID vIoXfer1bpp
*
* This routine colours expands a monochrome bitmap, possibly with different
* Rop2's for the foreground and background.  It will be called in the
* following cases:
*
* 1) To colour-expand the monochrome text buffer for the vFastText routine.
* 2) To blt a 1bpp source with a simple Rop2 between the source and
*    destination.
* 3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
*    white and black, and the pattern is a solid colour.
* 4) To handle a true Rop4 that works out to be Rop2's between the pattern
*    and destination.
*
* Needless to say, making this routine fast can leverage a lot of
* performance.
*
\**************************************************************************/

VOID vIoXfer1bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       ulHwForeMix,// Foreground hardware mix
ULONG       ulHwBackMix,// Background hardware mix
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    LONG    dxSrc;
    LONG    dySrc;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cjSrc;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    xRotateLeft;
    LONG    cBitsNeededForFirstNibblePair;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ulHwForeMix <= 15, "Weird hardware Rop");
    ASSERTDD(ulHwBackMix <= 15, "Weird hardware Rop");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");

    IO_FIFO_WAIT(ppdev, 5);
    IO_PIX_CNTL(ppdev, CPU_DATA);
    IO_BKGD_MIX(ppdev, BACKGROUND_COLOR | ulHwBackMix);
    IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwForeMix);
    IO_BKGD_COLOR(ppdev, pxlo->pulXlate[0]);
    IO_FRGD_COLOR(ppdev, pxlo->pulXlate[1]);

    dxSrc = pptlSrc->x - prclDst->left;
    dySrc = pptlSrc->y - prclDst->top;  // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    do {
        IO_FIFO_WAIT(ppdev, 6);

        yBottom = prcl->bottom;
        yTop    = prcl->top;
        xRight  = prcl->right;
        xLeft   = prcl->left;

        cBitsNeededForFirstNibblePair = 8 - (xLeft & 7);

        IO_SCISSORS_L(ppdev, xLeft);
        xLeft   = (xLeft) & ~7;

        IO_SCISSORS_R(ppdev, xRight - 1);
        xRight  = (xRight + 7) & ~7;

        IO_CUR_X(ppdev, xLeft);
        IO_CUR_Y(ppdev, yTop);

        cx = xRight - xLeft;
        cy = yBottom - yTop;

        IO_MAJ_AXIS_PCNT(ppdev, cx - 1);
        IO_MIN_AXIS_PCNT(ppdev, cy - 1);

        cjSrc = cx >> 3;                    // We'll be transferring WORDs,
                                            //   but every word accounts for
                                            //   8 pels = 1 byte of the source

        pjSrc = pjSrcScan0 + (yTop + dySrc) * lSrcDelta
                           + ((xLeft + dxSrc) >> 3);
                                            // Start is byte aligned

        xRotateLeft = (dxSrc) & 7;          // Amount by which to rotate left

        IO_GP_WAIT(ppdev);

        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                      MULTIPLE_PIXELS    | WRITE      | BYTE_SWAP);

        CHECK_DATA_READY(ppdev);

        _asm {

            ; eax = scratch
            ; ebx = count of words output per scan
            ; ecx = amount to rotate left
            ; edx = port
            ; esi = source pointer
            ; edi = source delta between end of last scan and start of next

            mov ecx,xRotateLeft
            mov edx,PIX_TRANS
            mov esi,pjSrc
            mov edi,lSrcDelta
            sub edi,cjSrc
            test ecx,ecx
            jz  UnrotatedScanLoop

        RotatedScanLoop:
            mov ebx,cjSrc
            cmp ecx,cBitsNeededForFirstNibblePair
            jge RotatedDontNeedFirstByte

        RotatedWordLoop:
            mov ah,[esi]
        RotatedDontNeedFirstByte:
            mov al,[esi + 1]
            shl eax,cl
            inc esi
            mov al,ah
            shr al,3
            add ah,ah
            out dx,ax
            dec ebx
            jnz RotatedWordLoop

            add esi,edi
            dec cy
            jnz RotatedScanLoop
            jmp AllDone

        UnrotatedScanLoop:
            mov ebx,cjSrc

        UnrotatedWordLoop:
            mov ah,[esi]
            inc esi
            mov al,ah
            shr al,3
            add ah,ah
            out dx,ax
            dec ebx
            jnz UnrotatedWordLoop

            add esi,edi
            dec cy
            jnz UnrotatedScanLoop

        AllDone:
        }

        CHECK_DATA_COMPLETE(ppdev);

        prcl++;
    } while (--c != 0);

    // We always have to reset the clipping:

    IO_FIFO_WAIT(ppdev, 2);
    IO_ABS_SCISSORS_L(ppdev, 0);
    IO_ABS_SCISSORS_R(ppdev, ppdev->cxMemory - 1);
}

/******************************Public*Routine******************************\
* VOID vIoXfer1bppPacked
*
* This is the same routine as 'vIoXfer1bpp', except that it takes
* advantage of the ATI's packed bit transfers to improve speed.
*
* Needless to say, this routine can only be called when running
* on an ATI adapter.
*
\**************************************************************************/

VOID vIoXfer1bppPacked( // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       ulHwForeMix,// Foreground hardware mix
ULONG       ulHwBackMix,// Background hardware mix
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    LONG    dxSrc;
    LONG    dySrc;
    LONG    cy;
    LONG    lSrcDelta;
    LONG    lTmpDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cwSrc;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    xBiasLeft;
    LONG    xBiasRight;

    #if DBG
    {
        if (gb8514a)
        {
            vIoXfer1bpp(ppdev, c, prcl, ulHwForeMix, ulHwBackMix, psoSrc,
                        pptlSrc, prclDst, pxlo);
            return;
        }
    }
    #endif // DBG

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ulHwForeMix <= 15, "Weird hardware Rop");
    ASSERTDD(ulHwBackMix <= 15, "Weird hardware Rop");
    ASSERTDD(pptlSrc != NULL && psoSrc != NULL, "Can't have NULL sources");

    while (INPW(EXT_FIFO_STATUS) & FOURTEEN_WORDS)
        ;

    OUT_WORD(ALU_FG_FN, ulHwForeMix);
    OUT_WORD(ALU_BG_FN, ulHwBackMix);
    OUT_WORD(FRGD_COLOR, pxlo->pulXlate[1]);
    OUT_WORD(BKGD_COLOR, pxlo->pulXlate[0]);

    // Add 'dxSrc' and 'dySrc' to a destination coordinate to get source.
    // Because we will be explicitly dealing with absolute destination
    // coordinates (we're not using the normal accelerator macros), we have
    // to explicitly account for the DFB offset:

    dxSrc = pptlSrc->x - (prclDst->left + ppdev->xOffset);
    dySrc = pptlSrc->y - (prclDst->top  + ppdev->yOffset);

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while (TRUE)
    {
        // Since we're not using the normal accelerator register macros,
        // we have to explicitly account for the DFB offset:

        yBottom = prcl->bottom + ppdev->yOffset;
        yTop    = prcl->top    + ppdev->yOffset;
        xRight  = prcl->right  + ppdev->xOffset;
        xLeft   = prcl->left   + ppdev->xOffset;

        // Make sure we're word aligned on the source, because we're
        // going to be transferring words and we don't want to risk
        // reading past the end of the bitmap:

        xBiasLeft = (xLeft + dxSrc) & 15;
        if (xBiasLeft != 0)
        {
            // Rev 3 ATI chips have goofy timing bugs on 66 MHz DX-2
            // computers where some extended will not be correctly
            // set the first time.  The extended scissors registers
            // have this problem, but setting them twice seems to work:

            OUT_WORD(EXT_SCISSOR_L, xLeft);
            OUT_WORD(EXT_SCISSOR_L, xLeft);
            xLeft -= xBiasLeft;
        }

        // The width has to be a word multiple:

        xBiasRight = (xRight - xLeft) & 15;
        if (xBiasRight != 0)
        {
            OUT_WORD(EXT_SCISSOR_R, xRight - 1);
            OUT_WORD(EXT_SCISSOR_R, xRight - 1);
            xRight += 16 - xBiasRight;
        }

        OUT_WORD(DP_CONFIG, FG_COLOR_SRC_FG | BG_COLOR_SRC_BG | DATA_ORDER |
                            EXT_MONO_SRC_HOST | DRAW | WRITE | DATA_WIDTH);

        OUT_WORD(DEST_X_START, xLeft);
        OUT_WORD(CUR_X, xLeft);
        OUT_WORD(DEST_X_END, xRight);
        OUT_WORD(CUR_Y, yTop);
        OUT_WORD(DEST_Y_END, yBottom);

        cwSrc = (xRight - xLeft) / 16;      // We'll be transferring WORDs
        pjSrc = pjSrcScan0 + (yTop  + dySrc) * lSrcDelta
                           + (xLeft + dxSrc) / 8;
                                            // Start is byte aligned (note
                                            //   that we don't have to add
                                            //   xBiasLeft)

        cy        = yBottom - yTop;
        lTmpDelta = lSrcDelta - 2 * cwSrc;

        // To be safe, we make sure there are always as many free FIFO entries
        // as we'll transfer (note that this implementation isn't particularly
        // efficient, especially for short scans):

        _asm {
            ; eax = used for IN
            ; ebx = count of words remaining on current scan
            ; ecx = used for REP
            ; edx = used for IN and OUT
            ; esi = current source pointer
            ; edi = count of scans

            mov     esi,pjSrc
            mov     edi,cy

        Scan_Loop:
            mov     ebx,cwSrc

        Batch_Loop:
            mov     edx,EXT_FIFO_STATUS
            in      ax,dx
            and     eax,SIXTEEN_WORDS
            jnz     short Batch_Loop

            mov     edx,PIX_TRANS
            sub     ebx,16
            jle     short Finish_Scan

            mov     ecx,16
            rep     outsw
            jmp     short Batch_Loop

        Finish_Scan:
            add     ebx,16
            mov     ecx,ebx
            rep     outsw

            add     esi,lTmpDelta
            dec     edi
            jnz     Scan_Loop
        }

        if ((xBiasLeft | xBiasRight) != 0)
        {
            // Reset the clipping only if we used it:

            while (INPW(EXT_FIFO_STATUS) & FOUR_WORDS)
                ;
            OUT_WORD(EXT_SCISSOR_L, 0);
            OUT_WORD(EXT_SCISSOR_R, ppdev->cxMemory - 1);
            OUT_WORD(EXT_SCISSOR_L, 0);
            OUT_WORD(EXT_SCISSOR_R, ppdev->cxMemory - 1);
        }

        if (--c == 0)
            return;

        prcl++;

        // Do the wait for the next round now:

        while (INPW(EXT_FIFO_STATUS) & TEN_WORDS)
            ;
    }
}

/******************************Public*Routine******************************\
* VOID vIoXfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* NOTE: The screen must be 8bpp for this function to be called!
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

// XLATE_BUFFER_SIZE defines the size of the stack-based buffer we use
// for doing the translate.  Note that in general stack buffers should
// be kept as small as possible.  The OS guarantees us only 8k for stack
// from GDI down to the display driver in low memory situations; if we
// ask for more, we'll access violate.  Note also that at any time the
// stack buffer cannot be larger than a page (4k) -- otherwise we may
// miss touching the 'guard page' and access violate then too.

#define XLATE_BUFFER_SIZE 256

VOID vIoXfer4bpp(       // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       ulHwForeMix,// Hardware mix
ULONG       ulHwBackMix,// Not used
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjScan;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    cxThis;
    LONG    cxToGo;
    LONG    xSrc;
    LONG    iLoop;
    BYTE    jSrc;
    ULONG*  pulXlate;
    BOOL    bResetScissors;
    BYTE    ajBuf[XLATE_BUFFER_SIZE];

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP, "Screen must be 8bpp");
    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ulHwForeMix <= 15, "Weird hardware Rop");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    IO_FIFO_WAIT(ppdev, 7);
    IO_PIX_CNTL(ppdev, ALL_ONES);
    IO_FRGD_MIX(ppdev, SRC_CPU_DATA | ulHwForeMix);

    while(TRUE)
    {
        cy = prcl->bottom - prcl->top;
        cx = prcl->right  - prcl->left;

        bResetScissors = FALSE;
        if (cx & 1)
        {
            // When using word transfers, the 8514/A will 'byte wrap'
            // transfers of odd byte width, such that end words will
            // be split so that on byte is the end of one scan, and the
            // other byte is the start of the next scan.
            //
            // This complicates things too much, so we simply always do
            // word transfers of even byte width by making use of the
            // clipping register:

            bResetScissors = TRUE;
            IO_SCISSORS_R(ppdev, prcl->right - 1);
            IO_MAJ_AXIS_PCNT(ppdev, cx);
        }
        else
        {
            IO_MAJ_AXIS_PCNT(ppdev, cx - 1);
        }

        IO_MIN_AXIS_PCNT(ppdev, cy - 1);
        IO_CUR_X(ppdev, prcl->left);
        IO_CUR_Y(ppdev, prcl->top);

        pulXlate  =  pxlo->pulXlate;
        xSrc      =  prcl->left + dx;
        pjScan    =  pjSrcScan0 + (prcl->top + dy) * lSrcDelta + (xSrc >> 1);

        IO_GP_WAIT(ppdev);
        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                      SINGLE_PIXEL       | WRITE      | BYTE_SWAP);
        CHECK_DATA_READY(ppdev);

        do {
            pjSrc  = pjScan;
            cxToGo = cx;            // # of pels per scan in 4bpp source
            do {
                cxThis  = XLATE_BUFFER_SIZE;
                                    // We can handle XLATE_BUFFER_SIZE number
                                    //   of pels in this xlate batch
                cxToGo -= cxThis;   // cxThis will be the actual number of
                                    //   pels we'll do in this xlate batch
                if (cxToGo < 0)
                    cxThis += cxToGo;

                pjDst = ajBuf;      // Points to our temporary batch buffer

                // We handle alignment ourselves because it's easy to
                // do, rather than pay the cost of setting/resetting
                // the scissors register:

                if (xSrc & 1)
                {
                    // When unaligned, we have to be careful not to read
                    // past the end of the 4bpp bitmap (that could
                    // potentially cause us to access violate):

                    iLoop = cxThis >> 1;        // Each loop handles 2 pels;
                                                //   we'll handle odd pel
                                                //   separately
                    jSrc  = *pjSrc;
                    while (iLoop-- != 0)
                    {
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];
                        jSrc = *(++pjSrc);
                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                    }

                    if (cxThis & 1)
                        *pjDst = (BYTE) pulXlate[jSrc & 0xf];
                }
                else
                {
                    iLoop = (cxThis + 1) >> 1;  // Each loop handles 2 pels
                    do {
                        jSrc = *pjSrc++;

                        *pjDst++ = (BYTE) pulXlate[jSrc >> 4];
                        *pjDst++ = (BYTE) pulXlate[jSrc & 0xf];

                    } while (--iLoop != 0);
                }

                // The number of bytes we'll transfer is equal to the number
                // of pels we've processed in the batch.  Since we're
                // transferring words, we have to round up to get the word
                // count:

                vDataPortOut(ppdev, ajBuf, (cxThis + 1) >> 1);

            } while (cxToGo > 0);

            pjScan += lSrcDelta;        // Advance to next source scan.  Note
                                        //   that we could have computed the
                                        //   value to advance 'pjSrc' directly,
                                        //   but this method is less
                                        //   error-prone.

        } while (--cy != 0);

        CHECK_DATA_COMPLETE(ppdev);

        // Don't forget to restore the right scissors:

        if (bResetScissors)
        {
            IO_FIFO_WAIT(ppdev, 1);
            IO_ABS_SCISSORS_R(ppdev, ppdev->cxMemory - 1);
        }

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 5);
    }
}

/******************************Public*Routine******************************\
* VOID vIoXferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no palette translation.
*
\**************************************************************************/

VOID vIoXferNative(     // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       ulHwForeMix,// Hardware mix
ULONG       ulHwBackMix,// Not used
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    LONG    cwSrc;
    BOOL    bResetScissors;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;

    ASSERTDD((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL),
            "Can handle trivial xlate only");
    ASSERTDD(psoSrc->iBitmapFormat == ppdev->iBitmapFormat,
            "Source must be same colour depth as screen");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ulHwForeMix <= 15, "Weird hardware Rop");

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    IO_FIFO_WAIT(ppdev, 8);
    IO_PIX_CNTL(ppdev, ALL_ONES);
    IO_FRGD_MIX(ppdev, SRC_CPU_DATA | ulHwForeMix);

    while(TRUE)
    {
        bResetScissors = FALSE;

        IO_CUR_Y(ppdev, prcl->top);

        yTop = prcl->top;
        cy   = prcl->bottom - prcl->top;

        IO_MIN_AXIS_PCNT(ppdev, cy - 1);

        xLeft  = prcl->left;
        xRight = prcl->right;

        // Make sure we're word aligned on the source, because we're
        // going to be transferring words and we don't want to risk
        // reading past the end of the bitmap:

        if ((xLeft + dx) & 1)
        {
            IO_SCISSORS_L(ppdev, xLeft);
            xLeft--;
            bResetScissors = TRUE;
        }

        IO_CUR_X(ppdev, xLeft);

        cx = xRight - xLeft;
        if (cx & 1)
        {
            IO_SCISSORS_R(ppdev, xRight - 1);
            cx++;
            bResetScissors = TRUE;
        }

        IO_MAJ_AXIS_PCNT(ppdev, cx - 1);

        cwSrc = ((cx << ppdev->cPelSize) + 1) >> 1;
        pjSrc = pjSrcScan0 + (yTop + dy) * lSrcDelta
                           + ((xLeft + dx) << ppdev->cPelSize);

        IO_GP_WAIT(ppdev);
        IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                      DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                      SINGLE_PIXEL       | WRITE      | BYTE_SWAP);
        CHECK_DATA_READY(ppdev);

        do {
            vDataPortOut(ppdev, pjSrc, cwSrc);
            pjSrc += lSrcDelta;

        } while (--cy != 0);

        CHECK_DATA_COMPLETE(ppdev);

        if (bResetScissors)
        {
            IO_FIFO_WAIT(ppdev, 2);
            IO_ABS_SCISSORS_L(ppdev, 0);
            IO_ABS_SCISSORS_R(ppdev, ppdev->cxMemory - 1);
        }

        if (--c == 0)
            return;

        prcl++;
        IO_FIFO_WAIT(ppdev, 6);
    }
}

/******************************Public*Routine******************************\
* VOID vIoCopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
\**************************************************************************/

VOID vIoCopyBlt(    // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   ulHwMix,    // Hardware mix
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    LONG dx;
    LONG dy;        // Add delta to destination to get source
    LONG cx;
    LONG cy;        // Size of current rectangle - 1

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ulHwMix <= 15, "Weird hardware Rop");

    IO_FIFO_WAIT(ppdev, 2);
    IO_FRGD_MIX(ppdev, SRC_DISPLAY_MEMORY | ulHwMix);
    IO_PIX_CNTL(ppdev, ALL_ONES);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                IO_MAJ_AXIS_PCNT(ppdev, cx);
                IO_DEST_X(ppdev, prcl->left);
                IO_CUR_X(ppdev,  prcl->left + dx);

                cy = prcl->bottom - prcl->top - 1;
                IO_MIN_AXIS_PCNT(ppdev, cy);
                IO_DEST_Y(ppdev, prcl->top);
                IO_CUR_Y(ppdev,  prcl->top + dy);

                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              DRAWING_DIR_TBLRXM);
                prcl++;

            } while (--c != 0);
        }
        else
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                IO_MAJ_AXIS_PCNT(ppdev, cx);
                IO_DEST_X(ppdev, prcl->left + cx);
                IO_CUR_X(ppdev,  prcl->left + cx + dx);

                cy = prcl->bottom - prcl->top - 1;
                IO_MIN_AXIS_PCNT(ppdev, cy);
                IO_DEST_Y(ppdev, prcl->top);
                IO_CUR_Y(ppdev,  prcl->top + dy);

                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              DRAWING_DIR_TBRLXM);
                prcl++;

            } while (--c != 0);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                IO_MAJ_AXIS_PCNT(ppdev, cx);
                IO_DEST_X(ppdev, prcl->left);
                IO_CUR_X(ppdev,  prcl->left + dx);

                cy = prcl->bottom - prcl->top - 1;
                IO_MIN_AXIS_PCNT(ppdev, cy);
                IO_DEST_Y(ppdev, prcl->top + cy);
                IO_CUR_Y(ppdev,  prcl->top + cy + dy);

                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              DRAWING_DIR_BTLRXM);
                prcl++;

            } while (--c != 0);
        }
        else
        {
            do {
                IO_FIFO_WAIT(ppdev, 7);

                cx = prcl->right - prcl->left - 1;
                IO_MAJ_AXIS_PCNT(ppdev, cx);
                IO_DEST_X(ppdev, prcl->left + cx);
                IO_CUR_X(ppdev,  prcl->left + cx + dx);

                cy = prcl->bottom - prcl->top - 1;
                IO_MIN_AXIS_PCNT(ppdev, cy);
                IO_DEST_Y(ppdev, prcl->top + cy);
                IO_CUR_Y(ppdev,  prcl->top + cy + dy);

                IO_CMD(ppdev, BITBLT | DRAW | DIR_TYPE_XY | WRITE |
                              DRAWING_DIR_BTRLXM);
                prcl++;

            } while (--c != 0);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vIoMaskCopy
*
* This routine performs a screen-to-screen masked blt.
*
* NT has a new API called MaskBlt (which has also been added to Win4.0)
* which allows an app to specify a monochrome mask on a colour blt.  This
* API is relatively cool because the programmer no longer has to do two
* separate SRCAND and SRCPAINT calls to do transparency.  We can accelerate
* the call using the hardware, and there is no longer any chance of
* 'flashing' occuring on the screen.
*
* Most often, the colour bitmap for MaskBlt is a compatible-bitmap that
* we've already stashed in off-screen memory.  We do the maskblt by
* transferring the monochrome bitmap via the data transfer register,
* and setting the foreground and background mixes to use the on-screen
* bitmap as appropriate.
*
* If you can implement this call and accelerate it using your hardware,
* please do.  It is really useful for app developers and is a big win.
* Plus, you'll have a head-start for Win4.0 (although the Win4.0 version
* is simpler because they only allow 0xccaa or 0xaacc rops -- the
* foreground and background mixes can only be OVERPAINT or LEAVE_ALONE).
*
\**************************************************************************/

VOID vIoMaskCopy(               // Type FNMASK
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // Array of relative coordinates destination
                                //   rectangles
ULONG           ulHwForeMix,    // Foreground mix
ULONG           ulHwBackMix,    // Background mix
SURFOBJ*        psoMsk,         // Mask surface
POINTL*         pptlMsk,        // Original unclipped mask source point
SURFOBJ*        psoSrc,         // Not used
POINTL*         pptlSrc,        // Original unclipped source point
RECTL*          prclDst,        // Original unclipped destination rectangle
ULONG           iSolidColor,    // Not used
RBRUSH*         prb,            // Not used
POINTL*         pptlBrush,      // Not used
XLATEOBJ*       pxlo)           // Not used
{
    LONG    dxSrc;
    LONG    dySrc;
    LONG    dxMsk;
    LONG    dyMsk;
    LONG    cy;
    LONG    lMskDelta;
    LONG    lTmpDelta;
    BYTE*   pjMskScan0;
    BYTE*   pjMsk;
    LONG    cwMsk;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    xBiasLeft;
    LONG    xBiasRight;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ulHwForeMix <= 15, "Weird hardware Rop");
    ASSERTDD(ulHwBackMix <= 15, "Weird hardware Rop");
    ASSERTDD(pptlMsk != NULL && psoMsk != NULL, "Can't have NULL masks");
    ASSERTDD(psoMsk->iBitmapFormat == BMF_1BPP, "Mask has to be 1bpp");
    ASSERTDD(!OVERLAP(prclDst, pptlSrc), "Source and dest can't overlap!");

    while (INPW(EXT_FIFO_STATUS) & TWO_WORDS)
        ;

    OUT_WORD(ALU_FG_FN, ulHwForeMix);
    OUT_WORD(ALU_BG_FN, ulHwBackMix);

    dxSrc = pptlSrc->x - (prclDst->left + ppdev->xOffset);
    dySrc = pptlSrc->y - (prclDst->top  + ppdev->yOffset);
                // Add to the absolute coordinate destination rectangle to
                //   get the corresponding absolute coordinate source rectangle

    dxMsk = pptlMsk->x - (prclDst->left + ppdev->xOffset);
    dyMsk = pptlMsk->y - (prclDst->top  + ppdev->yOffset);
                // Add to the absolute coordinate destination rectangle to
                //   get the corresponding absolute coordinate mask rectangle

    lMskDelta  = psoMsk->lDelta;
    pjMskScan0 = psoMsk->pvScan0;

    while (TRUE)
    {
        while (INPW(EXT_FIFO_STATUS) & FIFTEEN_WORDS)
            ;

        // Since we're not using the normal accelerator register macros,
        // we have to explicitly account for the DFB offset:

        yBottom = prcl->bottom + ppdev->yOffset;
        yTop    = prcl->top    + ppdev->yOffset;
        xRight  = prcl->right  + ppdev->xOffset;
        xLeft   = prcl->left   + ppdev->xOffset;

        // The start has to be word aligned:

        xBiasLeft = (xLeft + dxMsk) & 15;
        if (xBiasLeft != 0)
        {
            // Rev 3 ATI chips have goofy timing bugs on 66 MHz DX-2
            // computers where some extended will not be correctly
            // set the first time.  The extended scissors registers
            // have this problem, but setting them twice seems to work:

            OUT_WORD(EXT_SCISSOR_L, xLeft);
            OUT_WORD(EXT_SCISSOR_L, xLeft);
            xLeft -= xBiasLeft;
        }

        // The width has to be a word multiple:

        xBiasRight = (xRight - xLeft) & 15;
        if (xBiasRight != 0)
        {
            OUT_WORD(EXT_SCISSOR_R, xRight - 1);
            OUT_WORD(EXT_SCISSOR_R, xRight - 1);
            xRight += 16 - xBiasRight;
        }

        OUT_WORD(DP_CONFIG, FG_COLOR_SRC_BLIT | BG_COLOR_SRC_BLIT | DATA_ORDER |
                            EXT_MONO_SRC_HOST | DRAW | WRITE | DATA_WIDTH);

        OUT_WORD(SRC_X, xLeft + dxSrc);
        OUT_WORD(SRC_X_START, xLeft + dxSrc);
        OUT_WORD(SRC_X_END, xRight + dxSrc);
        OUT_WORD(SRC_Y, yTop + dySrc);
        OUT_WORD(SRC_Y_DIR, TOP_TO_BOTTOM);

        OUT_WORD(DEST_X_START, xLeft);
        OUT_WORD(CUR_X, xLeft);
        OUT_WORD(DEST_X_END, xRight);
        OUT_WORD(CUR_Y, yTop);
        OUT_WORD(DEST_Y_END, yBottom);

        cwMsk = (xRight - xLeft) / 16;      // We'll be transferring WORDs
        pjMsk = pjMskScan0 + (yTop  + dyMsk) * lMskDelta
                           + (xLeft + dxMsk) / 8;
                                            // Start is byte aligned (note
                                            //   that we don't have to add
                                            //   xBiasLeft)

        cy        = yBottom - yTop;
        lTmpDelta = lMskDelta - 2 * cwMsk;

        // To be safe, we make sure there are always as many free FIFO entries
        // as we'll transfer (note that this implementation isn't particularly
        // efficient, especially for short scans):

        _asm {
            ; eax = used for IN
            ; ebx = count of words remaining on current scan
            ; ecx = used for REP
            ; edx = used for IN and OUT
            ; esi = current source pointer
            ; edi = count of scans

            mov     esi,pjMsk
            mov     edi,cy

        Scan_Loop:
            mov     ebx,cwMsk

        Batch_Loop:
            mov     edx,EXT_FIFO_STATUS
            in      ax,dx
            and     eax,SIXTEEN_WORDS
            jnz     short Batch_Loop

            mov     edx,PIX_TRANS
            sub     ebx,16
            jle     short Finish_Scan

            mov     ecx,16
            rep     outsw
            jmp     short Batch_Loop

        Finish_Scan:
            add     ebx,16
            mov     ecx,ebx
            rep     outsw

            add     esi,lTmpDelta
            dec     edi
            jnz     Scan_Loop
        }

        if ((xBiasLeft | xBiasRight) != 0)
        {
            // Reset the clipping only if we used it:

            while (INPW(EXT_FIFO_STATUS) & FOUR_WORDS)
                ;
            OUT_WORD(EXT_SCISSOR_L, 0);
            OUT_WORD(EXT_SCISSOR_R, ppdev->cxMemory - 1);
            OUT_WORD(EXT_SCISSOR_L, 0);
            OUT_WORD(EXT_SCISSOR_R, ppdev->cxMemory - 1);
        }

        if (--c == 0)
            return;

        prcl++;
    }
}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
* LATER: Do we really need this routine?
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,         // Source surface
RECTL*      prclDst,        // Destination rectangle in absolute coordinates!
POINTL*     pptlSrc)        // Source point
{
    LONG xOffset;
    LONG yOffset;

    // This is ugly.  Oh well.

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    ppdev->xOffset = 0;
    ppdev->yOffset = 0;

    vIoXferNative(ppdev, 1, prclDst, OVERPAINT, OVERPAINT, psoSrc, pptlSrc,
                  prclDst, NULL);

    ppdev->xOffset = xOffset;
    ppdev->yOffset = yOffset;
}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the data
* transfer register.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,         // Destination surface
RECTL*      prclDst,        // Destination rectangle
POINTL*     pptlSrc)        // Source point in absolute coordinates!
{
    LONG    cx;
    LONG    cy;
    LONG    lDstDelta;
    BYTE*   pjDst;
    DWORD   wOdd;           // Think of it as a WORD
    ULONG   cwDst;
    ULONG   cjEndByte;

    IO_FIFO_WAIT(ppdev, 7);
    IO_PIX_CNTL(ppdev, ALL_ONES);
    // LATER: Do we have to set FRGD_MIX?
    IO_FRGD_MIX(ppdev, SRC_CPU_DATA | OVERPAINT);
    IO_ABS_CUR_X(ppdev, pptlSrc->x);
    IO_ABS_CUR_Y(ppdev, pptlSrc->y);

    cx = prclDst->right - prclDst->left;
    cy = prclDst->bottom - prclDst->top;

    IO_MAJ_AXIS_PCNT(ppdev, cx - 1);
    IO_MIN_AXIS_PCNT(ppdev, cy - 1);

    IO_CMD(ppdev, RECTANGLE_FILL     | BUS_SIZE_16| WAIT          |
                  DRAWING_DIR_TBLRXM | DRAW       | LAST_PIXEL_ON |
                  READ               | BYTE_SWAP);

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top * lDstDelta
                                        + prclDst->left;
    cwDst     = (cx >> 1);

    WAIT_FOR_DATA_AVAILABLE(ppdev);

    if ((cx & 1) == 0)
    {
        // Even destination scan length.  Life is truly great.

        do {
            vDataPortIn(ppdev, pjDst, cwDst);
            pjDst += lDstDelta;

        } while (--cy != 0);
    }
    else
    {
        // Odd destination scan length.
        //
        // We have to be careful of this case because we want to do WORD
        // transfers, but we can't overwrite either the beginning or ending
        // of the scan.  Note that since it's not legal to write a byte past
        // the end of the bitmap or a byte before the beginning of the bitmap
        // as that may cause an access violation, we cannot temporarily save
        // and restore any extra bytes in the destination bitmap.

        cjEndByte = cx - 1;     // Byte offset from beginning of scan to
                                //   last byte in scan.  This is the offset
                                //   to the odd byte that happens because
                                //   we're inputting WORDs but the length
                                //   of the destination scan is not a
                                //   multiple of two.

        while (TRUE)
        {
            vDataPortIn(ppdev, pjDst, cwDst);
            IO_PIX_TRANS_IN(ppdev, wOdd);
            *(pjDst + cjEndByte) = (BYTE) wOdd;

            if (--cy == 0)
                break;

            pjDst += lDstDelta;
            *(pjDst) = (BYTE) (wOdd >> 8);

            vDataPortIn(ppdev, pjDst + 1, cwDst);
            pjDst += lDstDelta;

            if (--cy == 0)
                break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\mini\perm3io.c ===
/***************************************************************************\
*
*                        ************************
*                        * MINIPORT SAMPLE CODE *
*                        ************************
*
* Module Name:
*
*   perm3io.c
*
* Abstract:
*
*   This module contains the code that implements the Permedia 3 miniport 
*   driver
*
* Environment:
*
*   Kernel mode
*
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.            
* Copyright (c) 1995-2003 Microsoft Corporation.  All Rights Reserved.
*
\***************************************************************************/

#include "perm3.h"

#pragma alloc_text(PAGE,Perm3StartIO)
#pragma alloc_text(PAGE,Perm3RetrieveGammaCallback)
#pragma alloc_text(PAGE,SetCurrentVideoMode)
#pragma alloc_text(PAGE,Perm3SetColorLookup)
#pragma alloc_text(PAGE,Perm3GetClockSpeeds)
#pragma alloc_text(PAGE,ZeroMemAndDac)
#pragma alloc_text(PAGE,ReadChipClockSpeedFromROM)

BOOLEAN
Perm3StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*+++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension
        Supplies a pointer to the miniport's device extension.

    RequestPacket 
        Pointer to the video request packet. This structure contains all 
        the parameters originally passed to EngDeviceIoControl.

Return Value:

    Return TRUE indicating that it has completed the request.

---*/

{
    VP_STATUS status;
    ULONG inIoSpace;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    PVIDEO_CLUT clutBuffer;
    ULONG RequestedMode;
    ULONG modeNumber;
    ULONG ulValue;
    PVIDEOPARAMETERS pVideoParams;
    HANDLE ProcessHandle;
    PPERM3_VIDEO_MODES ModeEntry;
    PERM3_VIDEO_FREQUENCIES FrequencyEntry;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) {

        case IOCTL_VIDEO_QUERY_REGISTRY_DWORD:

            VideoDebugPrint((3, "Perm3: got IOCTL_VIDEO_QUERY_REGISTRY_DWORD\n"));

            if ( RequestPacket->OutputBufferLength <
                 (RequestPacket->StatusBlock->Information = sizeof(ULONG))) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                                    RequestPacket->InputBuffer,
                                                    FALSE,
                                                    Perm3RegistryCallback,
                                                    &ulValue );
            if (status != NO_ERROR) {

                VideoDebugPrint((1, "Perm3: Reading registry entry %S failed\n", 
                                     RequestPacket->InputBuffer));

                status = ERROR_INVALID_PARAMETER;
                break;
            }

            *(PULONG)(RequestPacket->OutputBuffer) = ulValue;
            break;

        case IOCTL_VIDEO_REG_SAVE_GAMMA_LUT:

            VideoDebugPrint((3, "Perm3: got IOCTL_VIDEO_REG_SAVE_GAMMA_LUT\n"));

            if ( RequestPacket->InputBufferLength <
                 (RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE)) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        
            status = VideoPortSetRegistryParameters(HwDeviceExtension,
                                                    L"DisplayGammaLUT",
                                                    RequestPacket->InputBuffer,
                                                    MAX_CLUT_SIZE);

            if (status != NO_ERROR) {

                VideoDebugPrint((0, "Perm3: VideoPortSetRegistryParameters failed to save gamma LUT\n"));
            }

            break;


        case IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT:

            VideoDebugPrint((3, "Perm3: got IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT\n"));

            if ( RequestPacket->OutputBufferLength <
                 (RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE)) {
               
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
        
            status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                                    L"DisplayGammaLUT",
                                                    FALSE,
                                                    Perm3RetrieveGammaCallback,
                                                    RequestPacket->InputBuffer);

            if (status != NO_ERROR) {

                VideoDebugPrint((0, "Perm3: VideoPortGetRegistryParameters failed to retrieve gamma LUT\n"));
            }

            break;

        case IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF:

            {
                PPERM3_INTERRUPT_CTRLBUF pIntrCtrl;
    
                VideoDebugPrint((3, "Perm3: got IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF\n"));

                if (RequestPacket->OutputBufferLength <
                    (RequestPacket->StatusBlock->Information = sizeof(PVOID))) {

                    status = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                pIntrCtrl = &hwDeviceExtension->InterruptControl;

                if (!(hwDeviceExtension->Capabilities & CAPS_INTERRUPTS)) {

                    status = ERROR_INVALID_PARAMETER;
                    break;
                }

                //
                // display driver is in kernel so our address is valid
                //

                *(PVOID*)RequestPacket->OutputBuffer = &pIntrCtrl->ControlBlock;

                status = NO_ERROR;
                break;
            }

        case IOCTL_VIDEO_QUERY_DEVICE_INFO:
  
            VideoDebugPrint((3, "Perm3: QUERY_deviceInfo\n"));

            if ( RequestPacket->OutputBufferLength != 
                 (RequestPacket->StatusBlock->Information = sizeof(Perm3_Device_Info))) {

                VideoDebugPrint((0, "Perm3: the requested size of device info is wrong!\n"));
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            //
            // Copy our local PCI info to the output buffer
            //

            VideoPortMoveMemory( RequestPacket->OutputBuffer, 
                                 &hwDeviceExtension->deviceInfo, 
                                 sizeof(Perm3_Device_Info) );

            status = NO_ERROR;
            break;

        case IOCTL_VIDEO_MAP_VIDEO_MEMORY:
  
            VideoDebugPrint((3, "Perm3: MapVideoMemory\n"));

            if ( (RequestPacket->OutputBufferLength <
                 (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
                 (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            memoryInformation = RequestPacket->OutputBuffer;

            memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress;

            memoryInformation->VideoRamLength = 
                    hwDeviceExtension->FrameLength;

            inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

            //
            // Performance:
            //
            // Enable USWC on the P6 processor.
            //
            // We only do it for the frame buffer. Memory mapped registers
            // usually can not be mapped USWC 
            //

            inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

            status = VideoPortMapMemory(HwDeviceExtension,
                                        hwDeviceExtension->PhysicalFrameAddress,
                                        &(memoryInformation->VideoRamLength),
                                        &inIoSpace,
                                        &(memoryInformation->VideoRamBase));

            if (status != NO_ERROR) {

                VideoDebugPrint((0, "Perm3: VideoPortMapMemory failed with error %d\n", status));
                break;
            }

            memoryInformation->FrameBufferBase   = memoryInformation->VideoRamBase;
            memoryInformation->FrameBufferLength = memoryInformation->VideoRamLength;

            break;


        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

            VideoDebugPrint((3, "Perm3: UnMapVideoMemory\n"));

            if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            status = VideoPortUnmapMemory (HwDeviceExtension, 
                                           ((PVIDEO_MEMORY) (RequestPacket->InputBuffer))->RequestedVirtualAddress, 
                                           0);

            break;

    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((3, "Perm3: QueryPublicAccessRanges\n"));

        {
           PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
           ULONG physicalPortLength;
           PVOID VirtualAddress;
           PHYSICAL_ADDRESS PhysicalAddress;
           ULONG requiredOPSize;

           //
           // Calculate minimum size of return buffer. There is
           // 1 public access range for single graphics chip systems.
           //

           requiredOPSize = sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

           //
           // Validate the output buffer length
           //

           if ( (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = requiredOPSize)) ||
                (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))) {

               status = ERROR_INSUFFICIENT_BUFFER;
               break;
           }
           
           ProcessHandle = (HANDLE)(((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress);
           
           if (ProcessHandle != (HANDLE)0) {
           
                //
                // map 4K area for a process
                //

                VideoDebugPrint((3, "Mapping in 4K area from Control registers\n"));

                VirtualAddress = (PVOID)ProcessHandle;

                PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                PhysicalAddress.LowPart += 0x2000;
                physicalPortLength = 0x1000;

           } else {

                VideoDebugPrint((3, "Mapping in all Control registers\n"));

                VirtualAddress = NULL;

                PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                physicalPortLength = hwDeviceExtension->RegisterLength;
           }

           portAccess = RequestPacket->OutputBuffer;

           portAccess->VirtualAddress  = VirtualAddress;
           portAccess->InIoSpace       = hwDeviceExtension->RegisterSpace;
           portAccess->MappedInIoSpace = portAccess->InIoSpace;

           status = VideoPortMapMemory(HwDeviceExtension,
                                       PhysicalAddress,
                                       &physicalPortLength,
                                       &(portAccess->MappedInIoSpace),
                                       &(portAccess->VirtualAddress));
        }

        break;


    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((3, "Perm3: FreePublicAccessRanges\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = VideoPortUnmapMemory(HwDeviceExtension,
                                      ((PVIDEO_MEMORY)(RequestPacket->InputBuffer))->RequestedVirtualAddress,
                                      0);

        break;


    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((3, "Perm3: QueryAvailableModes\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
                 hwDeviceExtension->monitorInfo.numAvailableModes
                                  * sizeof(VIDEO_MODE_INFORMATION)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            PPERM3_VIDEO_FREQUENCIES pFrequencyEntry;

            modeInformation = RequestPacket->OutputBuffer;

            if (!hwDeviceExtension->monitorInfo.frequencyTable) {

                VideoDebugPrint((0, "Perm3: hwDeviceExtension->monitorInfo.frequencyTable is null!\n"));
                status = ERROR_INVALID_PARAMETER;

            } else {

                for (pFrequencyEntry = hwDeviceExtension->monitorInfo.frequencyTable;
                     pFrequencyEntry->BitsPerPel != 0;
                     pFrequencyEntry++) {

                    if (pFrequencyEntry->ModeValid) {

                        if( pFrequencyEntry->ModeEntry ) {
                            *modeInformation = pFrequencyEntry->ModeEntry->ModeInformation;
                            modeInformation->Frequency = pFrequencyEntry->ScreenFrequency;
                            modeInformation->ModeIndex = pFrequencyEntry->ModeIndex;
                            modeInformation++;
                        }
                    } 
                }

                status = NO_ERROR;
            }
        }

        break;


     case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((3, "Perm3: Query current mode. Current mode is %d\n",
            hwDeviceExtension->ActiveModeEntry->ModeInformation.ModeIndex));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information = sizeof(VIDEO_MODE_INFORMATION))) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                      hwDeviceExtension->ActiveModeEntry->ModeInformation;

            ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->Frequency =
                     hwDeviceExtension->ActiveFrequencyEntry.ScreenFrequency;

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((3, "Perm3: QueryNumAvailableModes (= %d)\n",
                hwDeviceExtension->monitorInfo.numAvailableModes));

        //
        // Find out the size of the data to be put in the the buffer and
        // return that in the status information (whether or not the
        // information is there). If the buffer passed in is not large
        // enough return an appropriate error code.
        //

        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information =
                                                sizeof(VIDEO_NUM_MODES)) ) {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                hwDeviceExtension->monitorInfo.numAvailableModes;

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
                sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((3, "Perm3: SetCurrentMode\n"));

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE)) {
       
            RequestPacket->StatusBlock->Information = sizeof(VIDEO_MODE);
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        RequestedMode = ((PVIDEO_MODE) RequestPacket->InputBuffer)->RequestedMode;
        modeNumber = RequestedMode & ~VIDEO_MODE_NO_ZERO_MEMORY;

        if ((modeNumber >= hwDeviceExtension->monitorInfo.numTotalModes) ||
            !(hwDeviceExtension->monitorInfo.frequencyTable[modeNumber].ModeValid))  {
       
            RequestPacket->StatusBlock->Information = hwDeviceExtension->monitorInfo.numTotalModes;
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        ulValue = ((RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY) == 0);

        status = SetCurrentVideoMode(hwDeviceExtension, modeNumber, (BOOLEAN)ulValue);

        if(status != NO_ERROR) {

            RequestPacket->StatusBlock->Information = modeNumber;
        }

        break;

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((3, "Perm3: SetColorRegs\n"));

        clutBuffer = (PVIDEO_CLUT) RequestPacket->InputBuffer;

        status = Perm3SetColorLookup(hwDeviceExtension,
                                     clutBuffer,
                                     RequestPacket->InputBufferLength,
                                     FALSE,   // Only update if different from cache
                                     TRUE);   // Update cache entries as well as RAMDAC
        break;


    case IOCTL_VIDEO_GET_COLOR_REGISTERS:
        {
            const int cchMinLUTSize = 256 * 3;
            UCHAR *pLUTBuffer = (char *)RequestPacket->OutputBuffer;
            UCHAR red, green, blue;
            int index;

            VideoDebugPrint((3, "Perm3: GetColorRegs\n"));

            if ((int)RequestPacket->OutputBufferLength < cchMinLUTSize) {

                RequestPacket->StatusBlock->Information = cchMinLUTSize;
                status = ERROR_INSUFFICIENT_BUFFER;

            } else {

                P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;

                P3RD_PALETTE_START_RD(0);

                for (index = 0; index < 256; ++index) {

                    P3RD_READ_PALETTE (red, green, blue);
                    *pLUTBuffer++ = red;
                    *pLUTBuffer++ = green;
                    *pLUTBuffer++ = blue;
                }

                status = NO_ERROR;
                RequestPacket->StatusBlock->Information = RequestPacket->OutputBufferLength;
            }
        }
        break;

    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((3, "Perm3: RESET_DEVICE\n"));

        if(hwDeviceExtension->bVGAEnabled) {

            //
            // Only reset the device if the monitor is on.  If it is off,
            // then executing the int10 will turn it back on.
            //

            if (hwDeviceExtension->bMonitorPoweredOn) {

                //
                // Do an Int10 to mode 3 will put the VGA to a known state.
                //

                VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
                biosArguments.Eax = 0x0003;
                VideoPortInt10(HwDeviceExtension, &biosArguments);
           }
        }

        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:

        {
        PVIDEO_SHARE_MEMORY pShareMemory;
        PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
        PHYSICAL_ADDRESS shareAddress;
        PVOID virtualAddress;
        ULONG sharedViewSize;

        VideoDebugPrint((3, "Perm3: ShareVideoMemory\n"));

        if ( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) {

            VideoDebugPrint((0, "Perm3: IOCTL_VIDEO_SHARE_VIDEO_MEMORY: ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        if ( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
             ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) ) {

            VideoDebugPrint((0, "Perm3: IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
            hwDeviceExtension->PhysicalFrameAddress.QuadPart;

        //
        // Performance:
        //
        // Enable USWC. We only do it for the frame buffer.
        // Memory mapped registers usually can not be mapped USWC 
        //

        inIoSpace |= VIDEO_MEMORY_SPACE_P6CACHE;

        //
        // Unlike the MAP_MEMORY IOCTL, in this case we can not map extra
        // address space since the application could actually use the
        // pointer we return to it to touch locations in the address space
        // that do not have actual video memory in them.
        //
        // An app doing this would cause the machine to crash.
        //

        status = VideoPortMapMemory(hwDeviceExtension,
                                    shareAddress,
                                    &sharedViewSize,
                                    &inIoSpace,
                                    &virtualAddress);

        pShareMemoryInformation = RequestPacket->OutputBuffer;
        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        }

        break;

    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:
        {

        PVIDEO_SHARE_MEMORY pShareMemory;

        VideoDebugPrint((3, "Perm3: UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);
        }

        break;

    case IOCTL_VIDEO_QUERY_GENERAL_DMA_BUFFER:

        //
        // Return the line DMA buffer information. The
        // buffer size and virtual address will be zero if
        // the buffer couldn't be allocated.
        //

        if( (RequestPacket->OutputBufferLength < (RequestPacket->StatusBlock->Information = sizeof(GENERAL_DMA_BUFFER))) ||
            (RequestPacket->InputBufferLength != sizeof(ULONG)) ) {

            //
            // They've give us a duff buffer.
            //

            status = ERROR_INSUFFICIENT_BUFFER;

        } else {

            GENERAL_DMA_BUFFER *local = NULL, *remote = (PGENERAL_DMA_BUFFER) RequestPacket->OutputBuffer;
            ULONG *bufferNum = (PULONG) RequestPacket->InputBuffer;

            status = NO_ERROR;
            switch( *bufferNum ) {

                case 1:
                    local = &hwDeviceExtension->LineDMABuffer;
                break;

                case 2:
                    local = &hwDeviceExtension->P3RXDMABuffer;
                break;

                default:
                    status = ERROR_INVALID_PARAMETER;
                break;
            }

            //
            // We need the buffer even if DMA/interrupts don't work
            //

            if(*bufferNum == 2 || 
               (local && hwDeviceExtension->Capabilities & CAPS_DMA_AVAILABLE)) {

                //
                // They've give us a correctly-sized buffer. So copy
                // the relevant buffer info.
                //

                *remote = *local;

            } else {

                remote->physAddr.LowPart = 0;
                remote->virtAddr = 0;
                remote->size = 0;
            }
        }
        
        break;

    case IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS:

        VideoDebugPrint((3, "Perm3: HandleVideoParameters\n"));

        //
        // We don't support a tv connector so just return NO_ERROR here
        //

        pVideoParams = (PVIDEOPARAMETERS) (RequestPacket->InputBuffer);

        if (pVideoParams->dwCommand == VP_COMMAND_GET) {
       
            pVideoParams = (PVIDEOPARAMETERS) (RequestPacket->OutputBuffer);
            pVideoParams->dwFlags = 0;
        }

        RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
        status = NO_ERROR;
        break;
       
    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

#if DBG
        VideoDebugPrint((3, "Perm3: Fell through perm3 startIO routine - invalid command (0x%x)\n", RequestPacket->IoControlCode));
#endif
        status = ERROR_INVALID_FUNCTION;
        break;

    }

    RequestPacket->StatusBlock->Status = status;

    if( status != NO_ERROR )
        RequestPacket->StatusBlock->Information = 0;

    VideoDebugPrint((3, "Perm3: Leaving StartIO routine. Status = 0x%x, Information = 0x%x\n",
                         RequestPacket->StatusBlock->Status, RequestPacket->StatusBlock->Information));


    return TRUE;

} // end Perm3StartIO()

VP_STATUS
Perm3RetrieveGammaCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*+++

Routine Description:

    This routine is used to read back the gamma LUT from the registry.

Arguments:

    HwDeviceExtension
        Supplies a pointer to the miniport's device extension.

    Context
        Context value passed to the get registry paramters routine

    ValueName 
        Name of the value requested.

    ValueData 
        Pointer to the requested data.

    ValueLength 
        Length of the requested data.

Return Value:

    if the variable doesn't exist return an error, else copy the gamma 
    lut into the supplied pointer

---*/

{
    if (ValueLength != MAX_CLUT_SIZE) {
   
        VideoDebugPrint((0, "Perm3: Perm3RetrieveGammaCallback got ValueLength of %d\n", ValueLength));
        return ERROR_INVALID_PARAMETER;
    }

    VideoPortMoveMemory(Context, ValueData, MAX_CLUT_SIZE);

    return NO_ERROR;

} // end Perm3RetrieveGammaCallback()


VP_STATUS 
SetCurrentVideoMode(
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG modeNumber, 
    BOOLEAN bZeroMemory
    )
{
    PERM3_VIDEO_FREQUENCIES FrequencyEntry;
    PPERM3_VIDEO_MODES ModeEntry;
    ULONG ulValue;
    VP_STATUS rc = NO_ERROR;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];

    //
    // set the current mode, but turn off interrupts before we do so to 
    // avoid any spurious video FIFO underrun errors - InitializeVideo can 
    // opt to turn these on by setting hwDeviceExtension->IntEnable which
    // we'll load into INT_ENABLE before exiting from this routine
    //

    hwDeviceExtension->IntEnable = VideoPortReadRegisterUlong(INT_ENABLE);

    VideoPortWriteRegisterUlong( INT_ENABLE, 
                                 hwDeviceExtension->IntEnable & 
                                 ~(INTR_ERROR_SET | INTR_VBLANK_SET));

    //
    // disable stereo support
    //

    hwDeviceExtension->Capabilities &= ~CAPS_STEREO;

    //
    // Re-sample the clock speed. This allows us to change the clock speed
    // on the fly
    //

    Perm3GetClockSpeeds(hwDeviceExtension);

    FrequencyEntry = hwDeviceExtension->monitorInfo.frequencyTable[modeNumber];
    ModeEntry = FrequencyEntry.ModeEntry;

    //
    // At this point, 'ModeEntry' and 'FrequencyEntry' point to the necessary
    // table entries required for setting the requested mode.
    //

    //
    // Zero the DAC and the Screen buffer memory.
    //

    ulValue = modeNumber;

    if(!bZeroMemory)
        ulValue |= VIDEO_MODE_NO_ZERO_MEMORY;

    ZeroMemAndDac(hwDeviceExtension, ulValue);

    ModeEntry->ModeInformation.DriverSpecificAttributeFlags = hwDeviceExtension->Capabilities;

    //
    // For low resolution modes we may have to do various tricks
    // such as line doubling and getting the RAMDAC to zoom.
    // Record any such zoom in the Mode DeviceAttributes field.
    // Primarily this is to allow the display driver to compensate
    // when asked to move the cursor or change its shape.
    //
    // Currently, low res means lower than 512 pixels width.
    //

    if (FrequencyEntry.ScreenWidth < 512) {
      
        //
        // Permedia 3 does line doubling. If using a TVP we must
        // get it to zoom by 2 in X to get the pixel rate up.
        //

        ModeEntry->ModeInformation.DriverSpecificAttributeFlags |= CAPS_ZOOM_Y_BY2;
    }

    if (!InitializeVideo(hwDeviceExtension, &FrequencyEntry)) {
   
        VideoDebugPrint((0, "Perm3: InitializeVideo failed\n"));
        rc = ERROR_INVALID_PARAMETER;
        goto end;
    }        

    //
    // Save the mode since we know the rest will work.
    //

    hwDeviceExtension->ActiveModeEntry = ModeEntry;
    hwDeviceExtension->ActiveFrequencyEntry = FrequencyEntry;

    //
    // Update VIDEO_MODE_INFORMATION fields
    //
    // Now that we've set the mode, we now know the screen stride, and
    // so can update some fields in the VIDEO_MODE_INFORMATION
    // structure for this mode.  The Permedia 3 display driver is expected to
    // call IOCTL_VIDEO_QUERY_CURRENT_MODE to query these corrected
    // values.
    //

    //
    // Calculate the bitmap width (note the '+ 1' on BitsPerPlane is
    // so that '15bpp' works out right). 12bpp is special in that we
    // support it as sparse nibbles within a 32-bit pixel. ScreenStride
    // is in bytes; VideoMemoryBitmapWidth is measured in pixels;
    //

    if (ModeEntry->ModeInformation.BitsPerPlane != 12) {
   
        ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
           ModeEntry->ModeInformation.ScreenStride / ((ModeEntry->ModeInformation.BitsPerPlane + 1) >> 3);

    } else {

        ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
           ModeEntry->ModeInformation.ScreenStride >> 2;
    }

    ulValue = hwDeviceExtension->AdapterMemorySize;

    ModeEntry->ModeInformation.VideoMemoryBitmapHeight = ulValue / ModeEntry->ModeInformation.ScreenStride;

end:

    //
    // set-up the interrupt enable 
    //

    VideoPortWriteRegisterUlong(INT_ENABLE, hwDeviceExtension->IntEnable);
    return(rc);
} 

VP_STATUS
Perm3SetColorLookup(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize,
    BOOLEAN ForceRAMDACWrite,
    BOOLEAN UpdateCache
    )

/*+++

Routine Description:

    This routine sets a specified portion of the color lookup table settings.

Arguments:

    hwDeviceExtension
        Pointer to the miniport driver's device extension.

    ClutBufferSize
        Length of the input buffer supplied by the user.

    ClutBuffer
        Pointer to the structure containing the color lookup table.

    ForceRAMDACWrite
        When it is set to FALSE, only update if different from cache

    UpdateCache
        When it is set to TRUE, update cache entries as well as RAMDAC

Return Value:

    VP_STATUS

---*/

{
    USHORT i, j;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < (sizeof(VIDEO_CLUT) - sizeof(ULONG))) ||
         (ClutBufferSize < (sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1))) ) ) {

        VideoDebugPrint((0, "Perm3: Perm3SetColorLookup: insufficient buffer (was %d, min %d)\n",
                             ClutBufferSize,
                            (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)))));
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
                                     VIDEO_MAX_COLOR_REGISTER + 1) ) {

        VideoDebugPrint((0, "Perm3: Perm3SetColorLookup: invalid parameter\n"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set CLUT registers directly on the hardware. 
    //
    
    {

    P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;
    PVIDEO_CLUT LUTCachePtr = &(hwDeviceExtension->LUTCache.LUTCache);

    //
    // RAMDAC Programming phase
    //

    for (i = 0, j = ClutBuffer->FirstEntry; 
         i < ClutBuffer->NumEntries; 
         i++, j++)  {

        //
        // Update the RAMDAC entry if it has changed or if we have been
        // told to overwrite it.

        if (ForceRAMDACWrite || 
                ( LUTCachePtr->LookupTable[j].RgbLong != 
                  ClutBuffer->LookupTable[i].RgbLong)  ) {

            P3RD_LOAD_PALETTE_INDEX (j,
                                     ClutBuffer->LookupTable[i].RgbArray.Red,
                                     ClutBuffer->LookupTable[i].RgbArray.Green,
                                     ClutBuffer->LookupTable[i].RgbArray.Blue);
        }

        //
        // Update the cache, if instructed to do so
        //

        if (UpdateCache) {

            LUTCachePtr->LookupTable[j].RgbLong = ClutBuffer->LookupTable[i].RgbLong;
        }
    }

    }

    return NO_ERROR;
}

VOID
Perm3GetClockSpeeds(
    PVOID HwDeviceExtension
    )

/*+++

Routine Description:

    Work out the chip clock speed and save in hwDeviceExtension.

Arguments:

    hwDeviceExtension
        Supplies a pointer to the miniport's device extension.

Return Value:

    On return the following values will be in hwDeviceExtension:
        ChipClockSpeed: this is the desired speed for the chip
        RefClockSpeed:  this is the speed of the oscillator input on the board

---*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ulValue;
    VP_STATUS status;

    //
    // force recalculation of clock speeds every time 
    //

    hwDeviceExtension->ChipClockSpeed = 0;
    hwDeviceExtension->RefClockSpeed  = 0;
    hwDeviceExtension->RefClockSpeed = 0;

    //
    // If a clock speed has been specified in the registry then validate it
    //

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            PERM3_REG_STRING_REFCLKSPEED,
                                            FALSE,
                                            Perm3RegistryCallback,
                                            &hwDeviceExtension->RefClockSpeed
                                            );

    if (status != NO_ERROR || hwDeviceExtension->RefClockSpeed == 0) {

        //
        // Use default setting
        //

        hwDeviceExtension->RefClockSpeed = 14318200;
    }

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            PERM3_REG_STRING_CORECLKSPEEDALT,
                                            FALSE,
                                            Perm3RegistryCallback,
                                            &hwDeviceExtension->ChipClockSpeedAlt
                                            );

    if (status != NO_ERROR || hwDeviceExtension->ChipClockSpeedAlt == 0) {
           
        //
        // If we have read the alt core clock speed from ROM then
        // we will have set hwDeviceExtension->bHaveExtendedClocks,
        // so use that value
        //

        if (hwDeviceExtension->bHaveExtendedClocks) {

            hwDeviceExtension->ChipClockSpeedAlt = 
                               hwDeviceExtension->ulPXRXCoreClockAlt;
        }
                
        //
        // If we haven't got a valid value then use the default
        //

        if (hwDeviceExtension->ChipClockSpeedAlt == 0) {

            hwDeviceExtension->ChipClockSpeedAlt = 
                               PERMEDIA3_DEFAULT_CLOCK_SPEED_ALT;
        }

    } else {

        hwDeviceExtension->ChipClockSpeedAlt *= 1000*1000;
    }

    //
    // Can override default chip clock speed in registry.
    //

    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                            PERM3_REG_STRING_CORECLKSPEED,
                                            FALSE,
                                            Perm3RegistryCallback,
                                            &hwDeviceExtension->ChipClockSpeed 
                                            );

    //
    // If a clock speed has been specified in the registry
    // then validate it
    //

    if (status == NO_ERROR && hwDeviceExtension->ChipClockSpeed != 0) {

        hwDeviceExtension->ChipClockSpeed *= (1000*1000); 

        if (hwDeviceExtension->ChipClockSpeed > PERMEDIA3_MAX_CLOCK_SPEED) {

            hwDeviceExtension->ChipClockSpeed = PERMEDIA3_MAX_CLOCK_SPEED;
        }

    } else {
           
        //
        // If the chip clock speed was not set in the registry
        // then read it from the ROM
        //

        if (hwDeviceExtension->ChipClockSpeed == 0) {
               
            //
            // On later BIOSes the core clock is in a different bit
            // of ROM and hwDeviceExtension->bHaveExtendedClocks will
            // be set to say that we have already read it from ROM.
            //

            if (hwDeviceExtension->bHaveExtendedClocks) {
                hwDeviceExtension->ChipClockSpeed = 
                                   hwDeviceExtension->ulPXRXCoreClock;
            } else {
                ReadChipClockSpeedFromROM (
                                   hwDeviceExtension, 
                                   &hwDeviceExtension->ChipClockSpeed );

            }
                
            //
            // If there isn't a clock-speed in the ROM then use
            // the defined default
            //

            if (hwDeviceExtension->ChipClockSpeed == 0) {
                hwDeviceExtension->ChipClockSpeed = 
                                   PERMEDIA3_DEFAULT_CLOCK_SPEED;
            }
        }
    }

    VideoDebugPrint((3, "Perm3: Chip clock speed now set to %d Hz\n",
                         hwDeviceExtension->ChipClockSpeed));

    VideoDebugPrint((3, "Perm3: Chip ALT clock speed now set to %d Hz\n",
                         hwDeviceExtension->ChipClockSpeedAlt));

    VideoDebugPrint((3, "Perm3: Ref  clock speed now set to %d Hz\n",
                         hwDeviceExtension->RefClockSpeed));
}

VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG RequestedMode
    )

/*+++

Routine Description:

    Initialize the DAC to 0 (black) and clear the framebuffer
Arguments:

    hwDeviceExtension 
        Supplies a pointer to the miniport's device extension.

    RequestedMode
        use the VIDEO_MODE_NO_ZERO_MEMORY bit to determine if the
        framebuffer should be cleared

Return Value:

    None

---*/

{
    ULONG  i;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
    P3RDRAMDAC *pP3RDRegs = (P3RDRAMDAC *)hwDeviceExtension->pRamdac;

    //
    // Turn off the screen at the DAC.
    //

    VideoDebugPrint((3, "Perm3: turning off readmask and zeroing LUT\n"));

    P3RD_SET_PIXEL_READMASK (0x0);
    P3RD_PALETTE_START_WR (0);

    for (i = 0; i <= VIDEO_MAX_COLOR_REGISTER; i++) {
        P3RD_LOAD_PALETTE (0, 0, 0);
    }

    if (!(RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY)) {
   
        //
        // Zero the memory. Don't use Perm3 as we would have to save/restore
        // state and that's a pain. This is not time critical.
        //

        VideoPortZeroDeviceMemory(hwDeviceExtension->pFramebuffer,
                                  hwDeviceExtension->FrameLength);

    }

    //
    // Turn on the screen at the DAC
    //

    VideoDebugPrint((3, "Perm3: turning on readmask\n"));

    P3RD_SET_PIXEL_READMASK (0xff);

    LUT_CACHE_INIT();   

    return;

}

VOID
ReadChipClockSpeedFromROM (
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    ULONG * pChipClkSpeed
    )

/*+++

Routine Description:

    Read the chip clock speed (in MHz) from the Video ROM BIOS
    (offset 0xA in the BIOS)    

Arguments:

    hwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    none

---*/

{
    //
    // Read the chip clock speed (in MHz) from the Video ROM BIOS (offset
    // 0xA in the BIOS)    
    // This involves changing the aperture 2 register so aperture better 
    // be completely idle or we could be in trouble; fortunately we only 
    // call this function during a mode change and expect aperture 2 (the 
    // FrameBuffer) to be idle
    //

    UCHAR clkSpeed;
    ULONG Default;
    UCHAR *p = (UCHAR *)hwDeviceExtension->pFramebuffer;
    pPerm3ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase[0];
        
    Default = VideoPortReadRegisterUlong(APERTURE_TWO);
    
    //
    // r/w via aperture 2 actually go to ROM
    //

    VideoPortWriteRegisterUlong(APERTURE_TWO, Default | 0x200);

    //
    //  If we have a valid ROM then read the clock pseed
    //

    if (VideoPortReadRegisterUshort ((USHORT *) p) == 0xAA55) {
   
        //
        // Get the clock speed
        //

        clkSpeed = VideoPortReadRegisterUchar(&(p[0xA]));

        //
        // Some boards, such as ones by Creative, have been know to set offset
        // 0xA to random-ish values. Creative use the following test to determine
        // whether they have a sensible value, so that is what we will use.
        //

        if (clkSpeed > 50) {

            *pChipClkSpeed = clkSpeed;
            *pChipClkSpeed *= (1000*1000); 
        }

        VideoDebugPrint((3, "Perm3: ROM clk speed value 0x%x\n", (ULONG) VideoPortReadRegisterUchar(&(p[0xA]))));

    } else {
   
        VideoDebugPrint((0, "Perm3: Bad BIOS ROM header 0x%x\n", (ULONG) VideoPortReadRegisterUshort ((USHORT *) p)));
    }

    VideoPortWriteRegisterUlong(APERTURE_TWO, Default);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\fillpath.c ===
/******************************Module*Header*******************************\
* Module Name: fillpath.c
*
* DrvFillPath
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

// LATER identify convex polygons and special-case?
// LATER identify vertical edges and special-case?
// LATER move pointed-to variables into automatics in search loops
// LATER punt to the engine with segmented framebuffer callbacks
// LATER handle complex clipping
// LATER coalesce rectangles

#include "precomp.h"

#define TAKING_ALLOC_STATS  0

#define NUM_BUFFER_POINTS   96      // Maximum number of points in a path
                                    //   for which we'll attempt to join
                                    //   all the path records so that the
                                    //   path may still be drawn by FastFill

#if TAKING_ALLOC_STATS
    ULONG BufferHitInFillpath = 0;
    ULONG BufferMissInFillpath = 0;
#endif

// Describe a single non-horizontal edge of a path to fill.
typedef struct _EDGE {
    PVOID pNext;
    INT iScansLeft;
    INT X;
    INT Y;
    INT iErrorTerm;
    INT iErrorAdjustUp;
    INT iErrorAdjustDown;
    INT iXWhole;
    INT iXDirection;
    INT iWindingDirection;
} EDGE, *PEDGE;

// Maximum number of rects we'll fill per call to
// the fill code
#define MAX_PATH_RECTS  50
#define RECT_BYTES      (MAX_PATH_RECTS * sizeof(RECTL))
#define EDGE_BYTES      (TMP_BUFFER_SIZE - RECT_BYTES)
#define MAX_EDGES       (EDGE_BYTES/sizeof(EDGE))

//MIX translation table. Translates a mix 1-16, into an old style Rop 0-255.
extern BYTE gaMix[];

VOID AdvanceAETEdges(EDGE *pAETHead);
VOID XSortAETEdges(EDGE *pAETHead);
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY);
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge, POINTFIX *ppfxEdgeStart,
        POINTFIX *ppfxEdgeEnd, RECTL *pClipRect);
BOOL ConstructGET(EDGE *pGETHead, EDGE *pFreeEdges, PATHOBJ *ppo,
        PATHDATA *pd, BOOL bMore, RECTL *pClipRect);
void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection);

/******************************Public*Routine******************************\
* DrvFillPath
*
* Fill the specified path with the specified brush and ROP.
*
\**************************************************************************/

BOOL DrvFillPath(
SURFOBJ*    pso,
PATHOBJ*    ppo,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
MIX         mix,
FLONG       flOptions)
{
    ULONG rop4;
    BYTE jClipping;     // clipping type
    EDGE *pCurrentEdge;
    EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
    EDGE *pAETHead;     // pointer to AETHead
    EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
    EDGE *pGETHead;     // pointer to GETHead
    EDGE *pFreeEdges;   // pointer to memory free for use to store edges
    ULONG ulNumRects;   // # of rectangles to draw currently in rectangle list
    RECTL *prclRects;   // pointer to start of rectangle draw list
    INT iCurrentY;      // scan line for which we're currently scanning out the
                        //  fill

    ULONG        ulHwForeMix;       // Hardware foreground mix value
    ULONG        ulHwBackMix;       // Hardware background mix value
    RBRUSH_COLOR rbc;               // Realized brush or solid color
    ULONG        iSolidColor;       // Copy of pbo->iSolidColor
    FNFILL      *pfnFill;           // Points to appropriate fill routine

    BOOL         bMore;
    PATHDATA     pd;
    RECTL        ClipRect;
    PDEV        *ppdev;
    DSURF       *pdsurf;

    BOOL         bRetVal=FALSE;     // FALSE until proven TRUE
    BOOL         bMemAlloced=FALSE; // FALSE until proven TRUE

    FLONG        flFirstRecord;
    POINTFIX*    pptfxTmp;
    ULONG        cptfxTmp;
    POINTFIX     aptfxBuf[NUM_BUFFER_POINTS];

    // Set up the clipping
    if (pco == (CLIPOBJ *) NULL) {
        // No CLIPOBJ provided, so we don't have to worry about clipping
        jClipping = DC_TRIVIAL;
    } else {
        // Use the CLIPOBJ-provided clipping
        jClipping = pco->iDComplexity;
    }

    if (jClipping != DC_TRIVIAL) {
        if (jClipping != DC_RECT) {
            goto ReturnFalse;  // there is complex clipping; let GDI fill the path
        }
        // Clip to the clip rectangle
        ClipRect = pco->rclBounds;
    } else {
        // So the y-clipping code doesn't do any clipping
        // /16 so we don't blow the values out when we scale up to GIQ
        ClipRect.top = (LONG_MIN + 1) / 16; // +1 to avoid compiler problem
        ClipRect.bottom = LONG_MAX / 16;
    }

    // There's nothing to do if there are only one or two points
    if (ppo->cCurves <= 2) {
        goto ReturnTrue;
    }

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngFillPath(pdsurf->pso, ppo, pco, pbo, pptlBrush, mix,
                           flOptions));
    }

    // We'll be drawing to the screen or an off-screen DFB; copy the surface's
    // offset now so that we won't need to refer to the DSURF again:

    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = pdsurf->poh->x;
    ppdev->yOffset = pdsurf->poh->y;

    pfnFill = ppdev->pfnFillSolid;
    ulHwForeMix = gajHwMixFromMix[mix & 0xF];
    ulHwBackMix = gajHwMixFromMix[(mix >> 8) & 0xF];
    iSolidColor = 0;                    // Assume we won't need a pattern
    rop4 = (gaRop3FromMix[mix >> 8] << 8) | gaRop3FromMix[mix & 0xff];

    if ((((rop4 & 0xff00) >> 8) != (rop4 & 0x00ff)) ||
        ((((rop4 >> 4) ^ (rop4)) & 0xf0f) != 0))  // Only do if we need a pattern
    {
        iSolidColor     = pbo->iSolidColor;
        rbc.iSolidColor = iSolidColor;
        if (rbc.iSolidColor == -1)
        {
            ppdev->bRealizeTransparent = (ulHwForeMix != ulHwBackMix);
            rbc.prb = pbo->pvRbrush;
            if (rbc.prb == NULL)
            {
                rbc.prb = BRUSHOBJ_pvGetRbrush(pbo);
                if (rbc.prb == NULL)
                    return(FALSE);
            }
            pfnFill = ppdev->pfnFillPat;
        }
    }

    // Enumerate path here first time to check for special
    // cases (rectangles and monotone polygons)

    // It is too difficult to determine interaction between
    // multiple paths, if there is more than one, skip this

    bMore = PATHOBJ_bEnum(ppo, &pd);

    if (jClipping == DC_TRIVIAL)
    {
        // Try going through the fast non-complex fill code.  We'll have
        // to realize the brush first if we're going to handle a pattern:

        if (iSolidColor == -1)
        {
        #if !FASTFILL_PATTERNS
            goto SkipFastFill;
        #else

            // We handle patterns in 'pfnFastFill' only if we can use the S3
            // hardware patterns.

            if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
                goto SkipFastFill;

            // Note: prb->pbe will be NULL and prb->ptlBrushOrg.x will be -1 the
            //       first time an RBRUSH is used.  So we have to check the
            //       alignment *before* dereferencing prb->pbe...

            if ((rbc.prb->ptlBrushOrg.x != pptlBrush->x + ppdev->xOffset) ||
                (rbc.prb->ptlBrushOrg.y != pptlBrush->y + ppdev->yOffset) ||
                (rbc.prb->apbe[IBOARD(ppdev)]->prbVerify != rbc.prb)      ||
                (rbc.prb->bTransparent != ppdev->bRealizeTransparent))
            {
                ppdev->pfnFastPatRealize(ppdev, rbc.prb, pptlBrush,
                                         ppdev->bRealizeTransparent);
            }
        #endif
        }

        if (bMore)
        {
            // FastFill only knows how to take a single contiguous buffer
            // of points.  Unfortunately, GDI sometimes hands us paths
            // that are split over multiple path data records.  Convex
            // figures such as Ellipses, Pies and RoundRects are almost
            // always given in multiple records.  Since probably 90% of
            // multiple record paths could still be done by FastFill, for
            // those cases we simply copy the points into a contiguous
            // buffer...

            // First make sure that the entire path would fit in the
            // temporary buffer, and make sure the path isn't comprised
            // of more than one subpath:

            if ((ppo->cCurves >= NUM_BUFFER_POINTS) ||
                (pd.flags & PD_ENDSUBPATH))
                goto SkipFastFill;

            pptfxTmp = &aptfxBuf[0];

            RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);

            pptfxTmp     += pd.count;
            cptfxTmp      = pd.count;
            flFirstRecord = pd.flags;       // Remember PD_BEGINSUBPATH flag

            do {
                bMore = PATHOBJ_bEnum(ppo, &pd);

                RtlCopyMemory(pptfxTmp, pd.pptfx, sizeof(POINTFIX) * pd.count);
                cptfxTmp += pd.count;
                pptfxTmp += pd.count;
            } while (!(pd.flags & PD_ENDSUBPATH));

            // Fake up the path data record:

            pd.pptfx  = &aptfxBuf[0];
            pd.count  = cptfxTmp;
            pd.flags |= flFirstRecord;

            // If there's more than one subpath, we can't call FastFill:

            if (bMore)
                goto SkipFastFill;
        }

        if ((ppdev->pfnFastFill)(ppdev, pd.count, pd.pptfx, ulHwForeMix,
                                 ulHwBackMix, iSolidColor, rbc.prb))
        {
            return(TRUE);
        }
    }

SkipFastFill:

    // Set up working storage in the temporary buffer

    prclRects = (RECTL*) ppdev->pvTmpBuffer; // storage for list of rectangles to draw

    if (!bMore) {

        RECTL *rectangle;
        INT cPoints = pd.count;

        // The count can't be less than three, because we got all the edges
        // in this subpath, and above we checked that there were at least
        // three edges

        // If the count is four, check to see if the polygon is really a
        // rectangle since we can really speed that up. We'll also check for
        // five with the first and last points the same, because under Win 3.1,
        // it was required to close polygons

        if ((cPoints == 4) ||
           ((cPoints == 5) &&
            (pd.pptfx[0].x == pd.pptfx[4].x) &&
            (pd.pptfx[0].y == pd.pptfx[4].y))) {

            rectangle = prclRects;

      /* we have to start somewhere so assume that most
         applications specify the top left point  first

         we want to check that the first two points are
         either vertically or horizontally aligned.  if
         they are then we check that the last point [3]
         is either horizontally or  vertically  aligned,
         and finally that the 3rd point [2] is  aligned
         with both the first point and the  last  point */

#define FIX_SHIFT 4L
#define FIX_MASK (- (1 << FIX_SHIFT))

         rectangle->top   = pd.pptfx[0].y - 1 & FIX_MASK;
         rectangle->left  = pd.pptfx[0].x - 1 & FIX_MASK;
         rectangle->right = pd.pptfx[1].x - 1 & FIX_MASK;

         if (rectangle->left ^ rectangle->right) {
            if (rectangle->top  ^ (pd.pptfx[1].y - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->left ^ (pd.pptfx[3].x - 1 & FIX_MASK))
               goto not_rectangle;

            if (rectangle->right ^ (pd.pptfx[2].x - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[2].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;
         }
         else {
            if (rectangle->top ^ (pd.pptfx[3].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->bottom = pd.pptfx[1].y - 1 & FIX_MASK;
            if (rectangle->bottom ^ (pd.pptfx[2].y - 1 & FIX_MASK))
               goto not_rectangle;

            rectangle->right = pd.pptfx[2].x - 1 & FIX_MASK;
            if (rectangle->right ^ (pd.pptfx[3].x - 1 & FIX_MASK))
                goto not_rectangle;
         }

      /* if the left is greater than the right then
         swap them so the blt code doesn't wig  out */

         if (rectangle->left > rectangle->right) {
            FIX temp;

            temp = rectangle->left;
            rectangle->left = rectangle->right;
            rectangle->right = temp;
         }
         else {

         /* if left == right there's nothing to draw */

            if (rectangle->left == rectangle->right) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->left  = (rectangle->left  >> FIX_SHIFT) + 1;
         rectangle->right = (rectangle->right >> FIX_SHIFT) + 1;

         if (rectangle->top > rectangle->bottom) {
            FIX temp;

            temp = rectangle->top;
            rectangle->top = rectangle->bottom;
            rectangle->bottom = temp;
         }
         else {
            if (rectangle->top == rectangle->bottom) {
               goto ReturnTrue;
            }
         }

      /* shift the values to get pixel coordinates */

         rectangle->top    = (rectangle->top    >> FIX_SHIFT) + 1;
         rectangle->bottom = (rectangle->bottom >> FIX_SHIFT) + 1;

         // Finally, check for clipping
         if (jClipping == DC_RECT) {
            // Clip to the clip rectangle
            if (!bIntersect(rectangle, &ClipRect, rectangle)) {
                // Totally clipped, nothing to do
                goto ReturnTrue;
            }
         }

      /* if we get here then the polygon is a rectangle,
         set count to 1 and  goto  bottom  to  draw  it */

         ulNumRects = 1;
         goto draw_remaining_rectangles;
      }

not_rectangle:

        ;

    }

    // Do we have enough memory for all the edges?
    // LATER does cCurves include closure?
    if (ppo->cCurves > MAX_EDGES) {
#if TAKING_ALLOC_STATS
            BufferMissInFillpath++;
#endif
        //
        // try to allocate enough memory
        //
        pFreeEdges = (EDGE *) EngAllocMem(0, (ppo->cCurves * sizeof(EDGE)), ALLOC_TAG);

        if (pFreeEdges == NULL)
        {
            goto ReturnFalse;  // too many edges; let GDI fill the path
        }
        else
        {
            bMemAlloced = TRUE;
        }
    }
    else {
#if TAKING_ALLOC_STATS
            BufferHitInFillpath++;
#endif
        pFreeEdges = (EDGE*) ((BYTE*) ppdev->pvTmpBuffer + RECT_BYTES);
            // use our handy temporary buffer (it's big enough)
    }

    // Initialize an empty list of rectangles to fill
    ulNumRects = 0;

    // Enumerate the path edges and build a Global Edge Table (GET) from them
    // in YX-sorted order.
    pGETHead = &GETHead;
    if (!ConstructGET(pGETHead, pFreeEdges, ppo, &pd, bMore, &ClipRect)) {
        goto ReturnFalse;  // outside GDI's 2**27 range
    }

    // Create an empty AET with the head node also a tail sentinel
    pAETHead = &AETHead;
    AETHead.pNext = pAETHead;  // mark that the AET is empty
    AETHead.X = 0x7FFFFFFF;    // this is greater than any valid X value, so
                               //  searches will always terminate

    // Top scan of polygon is the top of the first edge we come to
    iCurrentY = ((EDGE *)GETHead.pNext)->Y;

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out
    while (1) {

        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)
        if (AETHead.pNext != pAETHead) {
            AdvanceAETEdges(pAETHead);
        }

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET
        if (AETHead.pNext == pAETHead) {
            if (GETHead.pNext == pGETHead) {
                // Done if there are no edges in either the AET or the GET
                break;
            }
            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET
            iCurrentY = ((EDGE *)GETHead.pNext)->Y;
        } else {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)
            if (((EDGE *)AETHead.pNext)->pNext != pAETHead) {
                XSortAETEdges(pAETHead);
            }
        }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add
        if (((EDGE *)GETHead.pNext)->Y == iCurrentY) {
            MoveNewEdges(pGETHead, pAETHead, iCurrentY);
        }

        // Scan the AET into rectangles to fill (there's always at least one
        // edge pair in the AET)
        pCurrentEdge = AETHead.pNext;   // point to the first edge
        do {

            INT iLeftEdge;

            // The left edge of any given edge pair is easy to find; it's just
            // wherever we happen to be currently
            iLeftEdge = pCurrentEdge->X;

            // Find the matching right edge according to the current fill rule
            if ((flOptions & FP_WINDINGMODE) != 0) {

                INT iWindingCount;

                // Do winding fill; scan across until we've found equal numbers
                // of up and down edges
                iWindingCount = pCurrentEdge->iWindingDirection;
                do {
                    pCurrentEdge = pCurrentEdge->pNext;
                    iWindingCount += pCurrentEdge->iWindingDirection;
                } while (iWindingCount != 0);
            } else {
                // Odd-even fill; the next edge is the matching right edge
                pCurrentEdge = pCurrentEdge->pNext;
            }

            // See if the resulting span encompasses at least one pixel, and
            // add it to the list of rectangles to draw if so
            if (iLeftEdge < pCurrentEdge->X) {

                // We've got an edge pair to add to the list to be filled; see
                // if there's room for one more rectangle
                if (ulNumRects >= MAX_PATH_RECTS) {
                    // No more room; draw the rectangles in the list and reset
                    // it to empty

                    (*pfnFill)(ppdev, ulNumRects, prclRects, ulHwForeMix,
                               ulHwBackMix, rbc, pptlBrush);

                    // Reset the list to empty
                    ulNumRects = 0;
                }

                // Add the rectangle representing the current edge pair
                if (jClipping == DC_RECT) {
                    // Clipped
                    // Clip to left
                    prclRects[ulNumRects].left = max(iLeftEdge, ClipRect.left);
                    // Clip to right
                    prclRects[ulNumRects].right =
                            min(pCurrentEdge->X, ClipRect.right);
                    // Draw only if not fully clipped
                    if (prclRects[ulNumRects].left <
                            prclRects[ulNumRects].right) {
                        prclRects[ulNumRects].top = iCurrentY;
                        prclRects[ulNumRects].bottom = iCurrentY+1;
                        ulNumRects++;
                    }
                }
                else
                {
                    // Unclipped
                    prclRects[ulNumRects].top = iCurrentY;
                    prclRects[ulNumRects].bottom = iCurrentY+1;
                    prclRects[ulNumRects].left = iLeftEdge;
                    prclRects[ulNumRects].right = pCurrentEdge->X;
                    ulNumRects++;
                }
            }
        } while ((pCurrentEdge = pCurrentEdge->pNext) != pAETHead);

        iCurrentY++;    // next scan
    }

/* draw the remaining rectangles,  if there are any */

draw_remaining_rectangles:

    if (ulNumRects > 0) {
        (*pfnFill)(ppdev, ulNumRects, prclRects, ulHwForeMix, ulHwBackMix,
                   rbc, pptlBrush);
    }

ReturnTrue:
    bRetVal = TRUE; // done successfully

ReturnFalse:

    // bRetVal is originally false.  If you jumped to ReturnFalse from somewhere,
    // then it will remain false, and be returned.

    if (bMemAlloced)
    {
        //
        // we did allocate memory, so release it
        //
        EngFreeMem (pFreeEdges);
    }

    return(bRetVal);
}

// Advance the edges in the AET to the next scan, dropping any for which we've
// done all scans. Assumes there is at least one edge in the AET.
VOID AdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do {

        // Count down this edge's remaining scans
        if (--pCurrentEdge->iScansLeft == 0) {
            // We've done all scans for this edge; drop this edge from the AET
            pLastEdge->pNext = pCurrentEdge->pNext;
        } else {
            // Advance the edge's X coordinate for a 1-scan Y advance
            // Advance by the minimum amount
            pCurrentEdge->X += pCurrentEdge->iXWhole;
            // Advance the error term and see if we got one extra pixel this
            // time
            pCurrentEdge->iErrorTerm += pCurrentEdge->iErrorAdjustUp;
            if (pCurrentEdge->iErrorTerm >= 0) {
                // The error term turned over, so adjust the error term and
                // advance the extra pixel
                pCurrentEdge->iErrorTerm -= pCurrentEdge->iErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->iXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
}

// X-sort the AET, because the edges may have moved around relative to
// one another when we advanced them. We'll use a multipass bubble
// sort, which is actually okay for this application because edges
// rarely move relative to one another, so we usually do just one pass.
// Also, this makes it easy to keep just a singly-linked list. Assumes there
// are at least two edges in the AET.
VOID XSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do {

        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X) {

                // Next edge is to the left of the current edge; swap them
                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

// Moves all edges that start on the current scan from the GET to the AET in
// X-sorted order. Parameters are pointer to head of GET and pointer to dummy
// edge at head of AET, plus current scan line. Assumes there's at least one
// edge to be moved.
VOID MoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, INT iCurrentY)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;

    do {

        // Scan through the AET until the X-sorted insertion point for this
        // edge is found. We can continue from where the last search left
        // off because the edges in the GET are in X sorted order, as is
        // the AET. The search always terminates because the AET sentinel
        // is greater than any valid X
        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X) {
            pCurrentEdge = pCurrentEdge->pNext;
        }

        // We've found the insertion point; add the GET edge to the AET, and
        // remove it from the GET
        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;

    } while (pGETNext->Y == iCurrentY);
}





// Build the Global Edge Table from the path. There must be enough memory in
// the free edge area to hold all edges. The GET is constructed in Y-X order,
// and has a head/tail/sentinel node at pGETHead.

BOOL ConstructGET(
   EDGE     *pGETHead,
   EDGE     *pFreeEdges,
   PATHOBJ  *ppo,
   PATHDATA *pd,
   BOOL      bMore,
   RECTL    *pClipRect)
{
   POINTFIX pfxPathStart;    // point that started the current subpath
   POINTFIX pfxPathPrevious; // point before the current point in a subpath;
                              //  starts the current edge

/* Create an empty GET with the head node also a tail sentinel */

   pGETHead->pNext = pGETHead; // mark that the GET is empty
   pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

/* PATHOBJ_vEnumStart is implicitly  performed  by  engine
   already and first path  is  enumerated  by  the  caller */

next_subpath:

/* Make sure the PATHDATA is not empty (is this necessary) */

   if (pd->count != 0) {

   /* If first point starts a subpath, remember it as such
      and go on to the next point,   so we can get an edge */

      if (pd->flags & PD_BEGINSUBPATH) {

      /* the first point starts the subpath;   remember it */


         pfxPathStart    = *pd->pptfx; /* the subpath starts here          */
         pfxPathPrevious = *pd->pptfx; /* this points starts the next edge */
         pd->pptfx++;                  /* advance to the next point        */
         pd->count--;                  /* count off this point             */
      }


   /* add edges in PATHDATA to GET,  in Y-X  sorted  order */

      while (pd->count--) {
        if ((pFreeEdges =
            AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious, pd->pptfx,
                         pClipRect)) == NULL) {
            goto ReturnFalse;
        }
        pfxPathPrevious = *pd->pptfx; /* current point becomes previous   */
        pd->pptfx++;                  /* advance to the next point        */
      }


   /* If last point ends the subpath, insert the edge that
      connects to first point  (is this built in already?) */

      if (pd->flags & PD_ENDSUBPATH) {
         if ((pFreeEdges = AddEdgeToGET(pGETHead, pFreeEdges, &pfxPathPrevious,
                                   &pfxPathStart, pClipRect)) == NULL) {
            goto ReturnFalse;
        }
      }
   }

/* the initial loop conditions preclude a do, while or for */

   if (bMore) {
       bMore = PATHOBJ_bEnum(ppo, pd);
       goto next_subpath;
   }

    return(TRUE);   // done successfully

ReturnFalse:
    return(FALSE);  // failed
}

// Adds the edge described by the two passed-in points to the Global Edge
// Table, if the edge spans at least one pixel vertically.
EDGE * AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pClipRect)
{
    INT iYStart, iYEnd, iXStart, iXEnd, iYHeight, iXWidth;
    INT yJump, yTop;

    // Set the winding-rule direction of the edge, and put the endpoints in
    // top-to-bottom order
    iYHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (iYHeight == 0) {
        return(pFreeEdge);  // zero height; ignore this edge
    } else if (iYHeight >= 0) {
        iXStart = ppfxEdgeStart->x;
        iYStart = ppfxEdgeStart->y;
        iXEnd = ppfxEdgeEnd->x;
        iYEnd = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = 1;
    } else {
        iYHeight = -iYHeight;
        iXEnd = ppfxEdgeStart->x;
        iYEnd = ppfxEdgeStart->y;
        iXStart = ppfxEdgeEnd->x;
        iYStart = ppfxEdgeEnd->y;
        pFreeEdge->iWindingDirection = -1;
    }

    if (iYHeight & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    // Set the error term and adjustment factors, all in GIQ coordinates for
    // now
    iXWidth = iXEnd - iXStart;
    if (iXWidth >= 0) {
        // Left to right, so we change X as soon as we move at all
        pFreeEdge->iXDirection = 1;
        pFreeEdge->iErrorTerm = -1;
    } else {
        // Right to left, so we don't change X until we've moved a full GIQ
        // coordinate
        iXWidth = -iXWidth;
        pFreeEdge->iXDirection = -1;
        pFreeEdge->iErrorTerm = -iYHeight;
    }

    if (iXWidth & 0x80000000) {
        return(NULL);       // too large; outside 2**27 GDI range
    }

    if (iXWidth >= iYHeight) {
        // Calculate base run length (minimum distance advanced in X for a 1-
        // scan advance in Y)
        pFreeEdge->iXWhole = iXWidth / iYHeight;
        // Add sign back into base run length if going right to left
        if (pFreeEdge->iXDirection == -1) {
            pFreeEdge->iXWhole = -pFreeEdge->iXWhole;
        }
        pFreeEdge->iErrorAdjustUp = iXWidth % iYHeight;
    } else {
        // Base run length is 0, because line is closer to vertical than
        // horizontal
        pFreeEdge->iXWhole = 0;
        pFreeEdge->iErrorAdjustUp = iXWidth;
    }
    pFreeEdge->iErrorAdjustDown = iYHeight;

    // Calculate the number of pixels spanned by this edge, accounting for
    // clipping

    // Top true pixel scan in GIQ coordinates
    // Shifting to divide and multiply by 16 is okay because the clip rect
    // always contains positive numbers
    yTop = max(pClipRect->top << 4, (iYStart + 15) & ~0x0F);
    pFreeEdge->Y = yTop >> 4;    // initial scan line on which to fill edge

    // Calculate # of scans to actually fill, accounting for clipping
    if ((pFreeEdge->iScansLeft = min(pClipRect->bottom, ((iYEnd + 15) >> 4))
            - pFreeEdge->Y) <= 0) {

        return(pFreeEdge);  // no pixels at all are spanned, so we can
                            // ignore this edge
    }

    // If the edge doesn't start on a pixel scan (that is, it starts at a
    // fractional GIQ coordinate), advance it to the first pixel scan it
    // intersects. Ditto if there's top clipping. Also clip to the bottom if
    // needed

    if (iYStart != yTop) {
        // Jump ahead by the Y distance in GIQ coordinates to the first pixel
        // to draw
        yJump = yTop - iYStart;

        // Advance x the minimum amount for the number of scans traversed
        iXStart += pFreeEdge->iXWhole * yJump;

        AdjustErrorTerm(&pFreeEdge->iErrorTerm, pFreeEdge->iErrorAdjustUp,
                        pFreeEdge->iErrorAdjustDown, yJump, &iXStart,
                        pFreeEdge->iXDirection);
    }
    // Turn the calculations into pixel rather than GIQ calculations

    // Move the X coordinate to the nearest pixel, and adjust the error term
    // accordingly
    // Dividing by 16 with a shift is okay because X is always positive
    pFreeEdge->X = (iXStart + 15) >> 4; // convert from GIQ to pixel coordinates

    // LATER adjust only if needed (if prestepped above)?
    if (pFreeEdge->iXDirection == 1) {
        // Left to right
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                (((iXStart + 15) & ~0x0F) - iXStart);
    } else {
        // Right to left
        pFreeEdge->iErrorTerm -= pFreeEdge->iErrorAdjustDown *
                ((iXStart - 1) & 0x0F);
    }

    // Scale the error term down 16 times to switch from GIQ to pixels.
    // Shifts work to do the multiplying because these values are always
    // non-negative
    pFreeEdge->iErrorTerm >>= 4;

    // Insert the edge into the GET in YX-sorted order. The search always ends
    // because the GET has a sentinel with a greater-than-possible Y value
    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X))) {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

// Adjust the error term for a skip ahead in y. This is in ASM because there's
// a multiply/divide that may involve a larger than 32-bit value.

void AdjustErrorTerm(INT *pErrorTerm, INT iErrorAdjustUp, INT iErrorAdjustDown,
        INT yJump, INT *pXStart, INT iXDirection)
{
#if defined(_X86_) || defined(i386)
    // Adjust the error term up by the number of y coordinates we'll skip
    //*pErrorTerm += iErrorAdjustUp * yJump;
    _asm    mov ebx,pErrorTerm
    _asm    mov eax,iErrorAdjustUp
    _asm    mul yJump
    _asm    add eax,[ebx]
    _asm    adc edx,-1      // the error term starts out negative

    // See if the error term turned over even once while skipping
    //if (*pErrorTerm >= 0) {
    _asm    js  short NoErrorTurnover

        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        // NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;
        _asm    div iErrorAdjustDown
        _asm    inc eax
        // Note that EDX is the remainder; (EDX - iErrorAdjustDown) is where
        // the error term ends up ultimately

        // Advance x appropriately for the # of times the error term
        // turned over
        // if (iXDirection == 1) {
        //     *pXStart += NumAdjustDowns;
        // } else {
        //     *pXStart -= NumAdjustDowns;
        // }
        _asm    mov ecx,pXStart
        _asm    cmp iXDirection,1
        _asm    jz  short GoingRight
        _asm    neg eax
GoingRight:
        _asm    add [ecx],eax

        // Adjust the error term down to its proper post-skip value
        // *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
        _asm    sub edx,iErrorAdjustDown
        _asm    mov eax,edx     // put into EAX for storing to pErrorTerm next
        // }
NoErrorTurnover:
        _asm    mov [ebx],eax
#else
    INT NumAdjustDowns;

    // Adjust the error term up by the number of y coordinates we'll skip
    *pErrorTerm += iErrorAdjustUp * yJump;

    // See if the error term turned over even once while skipping
    if (*pErrorTerm >= 0) {
        // # of times we'll turn over the error term and step an extra x
        // coordinate while skipping
        NumAdjustDowns = (*pErrorTerm / iErrorAdjustDown) + 1;

        // Advance x appropriately for the # of times the error term
        // turned over
        if (iXDirection == 1) {
            *pXStart += NumAdjustDowns;
        } else {
            *pXStart -= NumAdjustDowns;
        }

        // Adjust the error term down to its proper post-skip value
        *pErrorTerm -= iErrorAdjustDown * NumAdjustDowns;
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\debug.h ===
/***************************************************************************\
* Module Name: debug.h
*
* Commonly used debugging macros.
*
* Copyright (c) 1992-1995 Microsoft Corporation
\***************************************************************************/

#if DBG

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

#define DISPDBG(arg) DebugPrint arg
#define RIP(x) { DebugPrint(0, x); EngDebugBreak();}
#define ASSERTDD(x, y) if (!(x)) RIP (y)
#define STATEDBG(level)
#define LOGDBG(arg)

#else

#define DISPDBG(arg)
#define RIP(x)
#define ASSERTDD(x, y)
#define STATEDBG(level)
#define LOGDBG(arg)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\color.c ===
/******************************Module*Header*******************************\
* Module Name: color.c
*
* This algorithm for color dithering is patent pending and its use is
* restricted to Microsoft products and drivers for Microsoft products.
* Use in non-Microsoft products or in drivers for non-Microsoft products
* is prohibited without the expressed written consent of Microsoft Corp.
*
* The patent application is the primary reference for the operation of the
* color dithering code.
*
* Note that in the comments and variable names, "vertex" means "vertex of
* either the inner (half intensity) or outer (full intensity) color cube."
* Vertices map to colors 0-7 and 9-15 of the Windows standard (required)
* 16-color palette, where vertices 0-7 are the vertices of the inner color
* cube, and 0 plus 9-15 are the vertices of the full color cube. Vertex 8 is
* 75% gray; this could be used in the dither, but that would break apps that
* depend on the exact Windows 3.1 dithering. This code is Window 3.1
* compatible.
*
* Note that as a result of the compatibility requirement, the dither
* produced by this algorithm is the exact same dither as that produced
* by the default Windows 3.1 16 color and 256 color VGA drivers.
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/**************************************************************************\
* This function takes a value from 0 - 255 and uses it to create an
* 8x8 pile of bits in the form of a 1BPP bitmap.  It can also take an
* RGB value and make an 8x8 bitmap.  These can then be used as brushes
* to simulate color unavaible on the device.
*
* For monochrome the basic algorithm is equivalent to turning on bits
* in the 8x8 array according to the following order:
*
*  00 32 08 40 02 34 10 42
*  48 16 56 24 50 18 58 26
*  12 44 04 36 14 46 06 38
*  60 28 52 20 62 30 54 22
*  03 35 11 43 01 33 09 41
*  51 19 59 27 49 17 57 25
*  15 47 07 39 13 45 05 37
*  63 31 55 23 61 29 53 21
*
* Reference: A Survey of Techniques for the Display of Continous
*            Tone Pictures on Bilevel Displays,;
*            Jarvis, Judice, & Ninke;
*            COMPUTER GRAPHICS AND IMAGE PROCESSING 5, pp 13-40, (1976)
\**************************************************************************/

#define SWAP_RB 0x00000004
#define SWAP_GB 0x00000002
#define SWAP_RG 0x00000001

#define SWAPTHEM(a,b) (ulTemp = a, a = b, b = ulTemp)

// PATTERNSIZE is the number of pixels in a dither pattern.
#define PATTERNSIZE 64

typedef union _PAL_ULONG {
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

// Tells which row to turn a pel on in when dithering for monochrome bitmaps.
static BYTE ajByte[] = {
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7,
    0, 4, 0, 4, 2, 6, 2, 6,
    0, 4, 0, 4, 2, 6, 2, 6,
    1, 5, 1, 5, 3, 7, 3, 7,
    1, 5, 1, 5, 3, 7, 3, 7
};

// The array of monochrome bits used for monc
static BYTE ajBits[] = {
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x40, 0x04, 0x04, 0x40, 0x10, 0x01, 0x01, 0x10,
    0x10, 0x01, 0x01, 0x10, 0x40, 0x04, 0x04, 0x40,
    0x80, 0x08, 0x08, 0x80, 0x20, 0x02, 0x02, 0x20,
    0x20, 0x02, 0x02, 0x20, 0x80, 0x08, 0x08, 0x80
};

// Translates vertices back to the original subspace. Each row is a subspace,
// as encoded in ulSymmetry, and each column is a vertex between 0 and 15.
BYTE jSwapSubSpace[8*16] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    0, 2, 1, 3, 4, 6, 5, 7, 8, 10, 9, 11, 12, 14, 13, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 4, 2, 6, 1, 5, 3, 7, 8, 12, 10, 14, 9, 13, 11, 15,
    0, 2, 4, 6, 1, 3, 5, 7, 8, 10, 12, 14, 9, 11, 13, 15,
    0, 4, 1, 5, 2, 6, 3, 7, 8, 12, 9, 13, 10, 14, 11, 15,
    0, 1, 4, 5, 2, 3, 6, 7, 8, 9, 12, 13, 10, 11, 14, 15,
};

// Converts a nibble value in the range 0-15 to a dword value containing the
// nibble value packed 8 times.
ULONG ulNibbleToDword[16] = {
    0x00000000,
    0x01010101,
    0x02020202,
    0x03030303,
    0x04040404,
    0x05050505,
    0x06060606,
    0xF8F8F8F8,
    0x07070707,
    0xF9F9F9F9,
    0xFAFAFAFA,
    0xFBFBFBFB,
    0xFCFCFCFC,
    0xFDFDFDFD,
    0xFEFEFEFE,
    0xFFFFFFFF
};

// Specifies where in the dither pattern colors should be placed in order
// of increasing intensity.
ULONG aulDitherOrder[] = {
  0, 36,  4, 32, 18, 54, 22, 50,
  2, 38,  6, 34, 16, 52, 20, 48,
  9, 45, 13, 41, 27, 63, 31, 59,
 11, 47, 15, 43, 25, 61, 29, 57,
  1, 37,  5, 33, 19, 55, 23, 51,
  3, 39,  7, 35, 17, 53, 21, 49,
  8, 44, 12, 40, 26, 62, 30, 58,
 10, 46, 14, 42, 24, 60, 28, 56,
};

// Array to convert to 256 color from 16 color. Maps from index that represents
// a 16-color vertex (color) to value that specifies the color index in the
// 256-color palette.
BYTE ajConvert[] =
{
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    248,
    7,
    249,
    250,
    251,
    252,
    253,
    254,
    255
};

/******************************Public*Routine******************************\
* vComputeSubspaces
*
* Calculates the subspace data associated with rgb, stores the data at
* pvVertexData, in the form of an array of VERTEX_DATA structures,
* suitable for vDitherColor. Returns a pointer to the byte after the
* last VERTEX_DATA structure.
*
* Ignores the high byte of rgb.
*
\**************************************************************************/

VERTEX_DATA* vComputeSubspaces(
ULONG           rgb,
VERTEX_DATA*    pvVertexData)
{
    ULONG   ulRedTemp, ulGreenTemp, ulBlueTemp, ulSymmetry;
    ULONG   ulRed, ulGre, ulBlu, ulTemp;
    ULONG   ulVertex0Temp, ulVertex1Temp, ulVertex2Temp, ulVertex3Temp;

    // Split the color into red, green, and blue components
    ulRedTemp   = ((PAL_ULONG *)&rgb)->pal.peRed;
    ulGreenTemp   = ((PAL_ULONG *)&rgb)->pal.peGreen;
    ulBlueTemp   = ((PAL_ULONG *)&rgb)->pal.peBlue;

    // Sort the RGB so that the point is transformed into subspace 0, and
    // keep track of the swaps in ulSymmetry so we can unravel it again
    // later.  We want r >= g >= b (subspace 0).
    ulSymmetry = 0;
    if (ulBlueTemp > ulRedTemp) {
        SWAPTHEM(ulBlueTemp,ulRedTemp);
        ulSymmetry = SWAP_RB;
    }

    if (ulBlueTemp > ulGreenTemp) {
        SWAPTHEM(ulBlueTemp,ulGreenTemp);
        ulSymmetry |= SWAP_GB;
    }

    if (ulGreenTemp > ulRedTemp) {
        SWAPTHEM(ulGreenTemp,ulRedTemp);
        ulSymmetry |= SWAP_RG;
    }

    ulSymmetry <<= 4;   // for lookup purposes

    // Scale the values from 0-255 to 0-64. Note that the scaling is not
    // symmetric at the ends; this is done to match Windows 3.1 dithering
    ulRed = (ulRedTemp + 1) >> 2;
    ulGre = (ulGreenTemp + 1) >> 2;
    ulBlu = (ulBlueTemp + 1) >> 2;

    // Compute the subsubspace within subspace 0 in which the point lies,
    // then calculate the # of pixels to dither in the colors that are the
    // four vertexes of the tetrahedron bounding the color we're emulating.
    // Only vertices with more than zero pixels are stored, and the
    // vertices are stored in order of increasing intensity, saving us the
    // need to sort them later
    if ((ulRedTemp + ulGreenTemp) > 256) {
        // Subsubspace 2 or 3
        if ((ulRedTemp + ulBlueTemp) > 256) {
            // Subsubspace 3
            // Calculate the number of pixels per vertex, still in
            // subsubspace 3, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 3 is:
            // 7, 9, 0x0B, 0x0F
            if ((ulVertex0Temp = (64 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            ulVertex2Temp = ulGre - ulBlu;
            ulVertex3Temp = (ulRed - 64) + ulBlu;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0F];
            }
        } else {
            // Subsubspace 2
            // Calculate the number of pixels per vertex, still in
            // subsubspace 2, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 2 is:
            // 3, 7, 9, 0x0B
            ulVertex1Temp = ulBlu << 1;
            ulVertex2Temp = ulRed - ulGre;
            ulVertex3Temp = (ulRed - 32) + (ulGre - 32);
            if ((ulVertex0Temp = ((PATTERNSIZE - ulVertex1Temp) -
                        ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex1Temp != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x0B];
            }
        }
    } else {
        // Subsubspace 0 or 1
        if (ulRedTemp > 128) {
            // Subsubspace 1
            // Calculate the number of pixels per vertex, still in
            // subsubspace 1, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 1 is:
            // 1, 3, 7, 9
            if ((ulVertex0Temp = ((32 - ulGre) + (32 - ulRed)) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex2Temp = ulBlu << 1;
            ulVertex3Temp = (ulRed - 32) << 1;
            if ((ulVertex1Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex2Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex2Temp != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x09];
            }
        } else {
            // Subsubspace 0
            // Calculate the number of pixels per vertex, still in
            // subsubspace 0, then convert to original subspace. The pixel
            // counts and vertex numbers are matching pairs, stored in
            // ascending intensity order, skipping vertices with zero
            // pixels. The vertex intensity order for subsubspace 0 is:
            // 0, 1, 3, 7
            if ((ulVertex0Temp = (32 - ulRed) << 1) != 0) {
                pvVertexData->ulCount = ulVertex0Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x00];
            }
            if ((ulVertex1Temp = (ulRed - ulGre) << 1) != 0) {
                pvVertexData->ulCount = ulVertex1Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x01];
            }
            ulVertex3Temp = ulBlu << 1;
            if ((ulVertex2Temp = ((PATTERNSIZE - ulVertex0Temp) -
                    ulVertex1Temp) - ulVertex3Temp) != 0) {
                pvVertexData->ulCount = ulVertex2Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x03];
            }
            if (ulVertex3Temp != 0) {
                pvVertexData->ulCount = ulVertex3Temp;
                pvVertexData++->ulVertex = jSwapSubSpace[ulSymmetry + 0x07];
            }
        }
    }

    return(pvVertexData);
}

/******************************Public*Routine******************************\
* vDitherColor
*
* Dithers the ulNumVertices vertices described by vVertexData into pulDest.
*
\**************************************************************************/

VOID vDitherColor(
ULONG*          pulDest,
VERTEX_DATA*    vVertexData,
VERTEX_DATA*    pvVertexDataEnd,
ULONG           ulNumVertices)
{
    ULONG ulTemp, ulNumPixels, ulColor;
    VERTEX_DATA *pvMaxVertex, *pvVertexData;
    ULONG  *pulDitherOrder;
    BYTE    jColor;
    BYTE   *pjDither = (BYTE *)pulDest;

    if (ulNumVertices > 2) {

        // There are 3 or 4 vertices in this dither
        if (ulNumVertices == 3) {

            // There are 3 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[1].ulCount >= vVertexData[2].ulCount) {
                pvMaxVertex = &vVertexData[1];
                ulTemp = vVertexData[1].ulCount;
            } else {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            }

        } else {

            // There are 4 vertices in this dither

            // Find the vertex with the most pixels, and fill the whole
            // destination bitmap with that vertex's color, which is faster
            // than dithering it
            if (vVertexData[2].ulCount >= vVertexData[3].ulCount) {
                pvMaxVertex = &vVertexData[2];
                ulTemp = vVertexData[2].ulCount;
            } else {
                pvMaxVertex = &vVertexData[3];
                ulTemp = vVertexData[3].ulCount;
            }
        }

        if (vVertexData[1].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[1];
            ulTemp = vVertexData[1].ulCount;
        }
        if (vVertexData[0].ulCount > ulTemp) {
            pvMaxVertex = &vVertexData[0];
        }

        // Prepare a dword version of the most common vertex number (color)
        ulColor = ulNibbleToDword[pvMaxVertex->ulVertex];

        // Mark that the vertex we're about to do doesn't need to be done
        // later
        pvMaxVertex->ulVertex = 0xFF;

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Now dither all the remaining vertices in order 0->2 or 0->3
        // (in order of increasing intensity)
        pulDitherOrder = aulDitherOrder;
        pvVertexData = vVertexData;
        do {
            if (pvVertexData->ulVertex == 0xFF) {
                // This is the max vertex, which we already did, but we
                // have to account for it in the dither order
                pulDitherOrder += pvVertexData->ulCount;
            } else {
                jColor = (BYTE) ajConvert[pvVertexData->ulVertex];
                ulNumPixels = pvVertexData->ulCount;
                switch (ulNumPixels & 3) {
                    case 3:
                        pjDither[*(pulDitherOrder+2)] = jColor;
                    case 2:
                        pjDither[*(pulDitherOrder+1)] = jColor;
                    case 1:
                        pjDither[*(pulDitherOrder+0)] = jColor;
                        pulDitherOrder += ulNumPixels & 3;
                    case 0:
                        break;
                }
                if ((ulNumPixels >>= 2) != 0) {
                    do {
                        pjDither[*pulDitherOrder] = jColor;
                        pjDither[*(pulDitherOrder+1)] = jColor;
                        pjDither[*(pulDitherOrder+2)] = jColor;
                        pjDither[*(pulDitherOrder+3)] = jColor;
                        pulDitherOrder += 4;
                    } while (--ulNumPixels);
                }
            }
        } while (++pvVertexData < pvVertexDataEnd);

    } else if (ulNumVertices == 2) {

        // There are exactly two vertices with more than zero pixels; fill
        // in the dither array as follows: block fill with vertex with more
        // points first, then dither in the other vertex
        if (vVertexData[0].ulCount >= vVertexData[1].ulCount) {
            // There are no more vertex 1 than vertex 0 pixels, so do
            // the block fill with vertex 0
            ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
            // Do the dither with vertex 1
            jColor = (BYTE) ajConvert[vVertexData[1].ulVertex];
            ulNumPixels = vVertexData[1].ulCount;
            // Set where to start dithering with vertex 1 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder + vVertexData[0].ulCount;
        } else {
            // There are more vertex 1 pixels, so do the block fill
            // with vertex 1
            ulColor = ulNibbleToDword[vVertexData[1].ulVertex];
            // Do the dither with vertex 0
            jColor = (BYTE) ajConvert[vVertexData[0].ulVertex];
            ulNumPixels = vVertexData[0].ulCount;
            // Set where to start dithering with vertex 0 (vertex 0 is
            // lower intensity, so its pixels come first in the dither
            // order)
            pulDitherOrder = aulDitherOrder;
        }

        // Block fill the dither pattern with the more common vertex
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;

        // Dither in the less common vertex
        switch (ulNumPixels & 3) {
            case 3:
                pjDither[*(pulDitherOrder+2)] = jColor;
            case 2:
                pjDither[*(pulDitherOrder+1)] = jColor;
            case 1:
                pjDither[*(pulDitherOrder+0)] = jColor;
                pulDitherOrder += ulNumPixels & 3;
            case 0:
                break;
        }
        if ((ulNumPixels >>= 2) != 0) {
            do {
                pjDither[*pulDitherOrder] = jColor;
                pjDither[*(pulDitherOrder+1)] = jColor;
                pjDither[*(pulDitherOrder+2)] = jColor;
                pjDither[*(pulDitherOrder+3)] = jColor;
                pulDitherOrder += 4;
            } while (--ulNumPixels);
        }

    } else {

        // There is only one vertex in this dither

        // No sorting or dithering is needed for just one color; we can
        // just generate the final DIB directly
        ulColor = ulNibbleToDword[vVertexData[0].ulVertex];
        *pulDest = ulColor;
        *(pulDest+1) = ulColor;
        *(pulDest+2) = ulColor;
        *(pulDest+3) = ulColor;
        *(pulDest+4) = ulColor;
        *(pulDest+5) = ulColor;
        *(pulDest+6) = ulColor;
        *(pulDest+7) = ulColor;
        *(pulDest+8) = ulColor;
        *(pulDest+9) = ulColor;
        *(pulDest+10) = ulColor;
        *(pulDest+11) = ulColor;
        *(pulDest+12) = ulColor;
        *(pulDest+13) = ulColor;
        *(pulDest+14) = ulColor;
        *(pulDest+15) = ulColor;
    }
}

/******************************Public*Routine******************************\
* DrvDitherColor
*
* Dithers an RGB color to an 8X8 approximation using the reserved VGA
* colours.
*
\**************************************************************************/

ULONG DrvDitherColor(
DHPDEV  dhpdev,
ULONG   iMode,
ULONG   rgb,
ULONG*  pul)
{
    ULONG   ulGrey, ulRed, ulGre, ulBlu, ulTemp;
    VERTEX_DATA vVertexData[4];
    VERTEX_DATA *pvVertexData;

    // Figure out if we need a full color dither or only a monochrome dither.

    // Note: we'll get colour dithers only at 8bpp, because that's the
    //       only colour depth at which we set GCAPS_COLOR_DITHER.

    if (iMode != DM_MONOCHROME)
    {
        // Full color dither

        // Calculate what color subspaces are involved in the dither
        pvVertexData = vComputeSubspaces(rgb, vVertexData);

        // Now that we have found the bounding vertices and the number of
        // pixels to dither for each vertex, we can create the dither pattern

        // Handle 1, 2, and 3 & 4 vertices per dither separately
        ulTemp = pvVertexData - vVertexData;    // # of vertices with more than
                                                //  zero pixels in the dither

        vDitherColor(pul, vVertexData, pvVertexData, ulTemp);
    }
    else
    {
        // Note: we can get monochrome dithers at any colour depth because
        //       we always set GCAPS_MONO_DITHER.

        // For monochrome we will only use the Intensity (grey level)

        RtlFillMemory((PVOID) pul, PATTERNSIZE/2, 0);  // zero the dither bits

        ulRed   = (ULONG) ((PALETTEENTRY *) &rgb)->peRed;
        ulGre = (ULONG) ((PALETTEENTRY *) &rgb)->peGreen;
        ulBlu  = (ULONG) ((PALETTEENTRY *) &rgb)->peBlue;

        // I = .30R + .59G + .11B
        // For convience the following ratios are used:
        //
        //  77/256 = 30.08%
        // 151/256 = 58.98%
        //  28/256 = 10.94%

        ulGrey  = (((ulRed * 77) + (ulGre * 151) + (ulBlu * 28)) >> 8) & 255;

        // Convert the RGBI from 0-255 to 0-64 notation.

        ulGrey = (ulGrey + 1) >> 2;

        while(ulGrey) {
            ulGrey--;
            pul[ajByte[ulGrey]] |= ((ULONG) ajBits[ulGrey]);
        }
    }

    return(DCR_DRIVER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* debug helpers routine
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

#if DBG

ULONG DebugLevel = 0;

/*****************************************************************************
 *
 *   Routine Description:
 *
 *      This function is variable-argument, level-sensitive debug print
 *      routine.
 *      If the specified debug level for the print statement is lower or equal
 *      to the current debug level, the message will be printed.
 *
 *   Arguments:
 *
 *      DebugPrintLevel - Specifies at which debugging level the string should
 *          be printed
 *
 *      DebugMessage - Variable argument ascii c string
 *
 *   Return Value:
 *
 *      None.
 *
 ***************************************************************************/

VOID
DebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    )

{

    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= DebugLevel)
    {
        EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
        EngDebugPrint("", "\n", ap);
    }

    va_end(ap);

}

////////////////////////////////////////////////////////////////////////////
// Miscellaneous Driver Debug Routines
////////////////////////////////////////////////////////////////////////////

LONG gcFifo = 0;                // Number of currently free FIFO entries

#define LARGE_LOOP_COUNT  10000000

/******************************Public*Routine******************************\
* VOID vCheckDataComplete
\**************************************************************************/

VOID vCheckDataReady(
PDEV*   ppdev)
{
    ASSERTDD((IO_GP_STAT(ppdev) & HARDWARE_BUSY),
             "Not ready for data transfer.");
}

/******************************Public*Routine******************************\
* VOID vCheckDataComplete
\**************************************************************************/

VOID vCheckDataComplete(
PDEV*   ppdev)
{
    LONG i;

    // We loop because it may take a while for the hardware to finish
    // digesting all the data we transferred:

    for (i = LARGE_LOOP_COUNT; i > 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & HARDWARE_BUSY))
            return;
    }

    RIP("Data transfer not complete.");
}

/******************************Public*Routine******************************\
* VOID vOutAccel
\**************************************************************************/

VOID vOutAccel(
ULONG   p,
ULONG   v)
{
    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    OUT_WORD(p, v);
}

/******************************Public*Routine******************************\
* VOID vOutDepth
\**************************************************************************/

VOID vOutDepth(
PDEV*   ppdev,
ULONG   p,
ULONG   v)
{
    ASSERTDD(ppdev->iBitmapFormat != BMF_32BPP,
             "We're trying to do non-32bpp output while in 32bpp mode");

    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    OUT_WORD(p, v);
}

/******************************Public*Routine******************************\
* VOID vWriteAccel
\**************************************************************************/

VOID vWriteAccel(
VOID*   p,
ULONG   v)
{
    if (gcFifo-- == 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_WORD(p, v)
}

/******************************Public*Routine******************************\
* VOID vWriteDepth
\**************************************************************************/

VOID vWriteDepth(
PDEV*   ppdev,
VOID*   p,
ULONG   v)
{
    ASSERTDD(ppdev->iBitmapFormat != BMF_32BPP,
             "We're trying to do non-32bpp output while in 32bpp mode");

    gcFifo--;
    if (gcFifo < 0)
    {
        gcFifo = 0;
        RIP("Incorrect FIFO wait count");
    }

    WRITE_WORD(p, v);
}

/******************************Public*Routine******************************\
* VOID vFifoWait
\**************************************************************************/

VOID vFifoWait(
PDEV*   ppdev,
LONG    level)
{
    LONG    i;

    ASSERTDD((level > 0) && (level <= 8), "Illegal wait level");

    gcFifo = level;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & ((FIFO_1_EMPTY << 1) >> (level))))
            return;         // There are 'level' entries free
    }

    RIP("FIFO_WAIT timeout -- The hardware is in a funky state.");
}

/******************************Public*Routine******************************\
* VOID vGpWait
\**************************************************************************/

VOID vGpWait(
PDEV*   ppdev)
{
    LONG    i;

    gcFifo = 8;

    for (i = LARGE_LOOP_COUNT; i != 0; i--)
    {
        if (!(IO_GP_STAT(ppdev) & HARDWARE_BUSY))
            return;         // It isn't busy
    }

    RIP("GP_WAIT timeout -- The hardware is in a funky state.");
}

////////////////////////////////////////////////////////////////////////////

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\brush.c ===
/******************************Module*Header*******************************\
* Module Name: Brush.c
*
* Handles all brush/pattern initialization and realization.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vRealizeDitherPattern
*
* Generates an 8x8 dither pattern, in our internal realization format, for
* the colour ulRGBToDither.  Note that the high byte of ulRGBToDither does
* not need to be set to zero, because vComputeSubspaces ignores it.
\**************************************************************************/

VOID vRealizeDitherPattern(
RBRUSH*     prb,
ULONG       ulRGBToDither)
{
    ULONG           ulNumVertices;
    VERTEX_DATA     vVertexData[4];
    VERTEX_DATA*    pvVertexData;

    // Calculate what colour subspaces are involved in the dither:

    pvVertexData = vComputeSubspaces(ulRGBToDither, vVertexData);

    // Now that we have found the bounding vertices and the number of
    // pixels to dither for each vertex, we can create the dither pattern

    ulNumVertices = pvVertexData - vVertexData;
                      // # of vertices with more than zero pixels in the dither

    // Do the actual dithering:

    vDitherColor(&prb->aulPattern[0], vVertexData, pvVertexData, ulNumVertices);

    prb->fl            = 0;
    prb->ptlBrushOrg.x = -1;
    prb->pbe           = NULL;      // Initialize the fields we need
}

/******************************Public*Routine******************************\
* BOOL DrvRealizeBrush
*
* This function allows us to convert GDI brushes into an internal form
* we can use.  It is called by GDI when we've called BRUSHOBJ_pvGetRbrush
* in some other function like DrvBitBlt, and GDI doesn't happen have a cached
* realization lying around.
*
* Input:
*
*   ppdev->bRealizeTransparent -- Hint for whether or not the brush should be
*                              realized for transparency.  If this hint is
*                              wrong, there will be no error, but the brush
*                              will have to be unnecessarily re-realized.
*
* Note: You should always set 'ppdev->bRealizeTransparent' before calling
*       BRUSHOBJ_pvGetRbrush!
*
\**************************************************************************/

BOOL DrvRealizeBrush(
BRUSHOBJ*   pbo,
SURFOBJ*    psoDst,
SURFOBJ*    psoPattern,
SURFOBJ*    psoMask,
XLATEOBJ*   pxlo,
ULONG       iHatch)
{
    PDEV*   ppdev;
    ULONG   iPatternFormat;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    lSrcDelta;
    LONG    cj;
    LONG    i;
    LONG    j;
    RBRUSH* prb;
    ULONG*  pulXlate;

    ppdev = (PDEV*) psoDst->dhpdev;

    // We only handle brushes if we have an off-screen brush cache
    // available.  If there isn't one, we can simply fail the realization,
    // and eventually GDI will do the drawing for us (although a lot
    // slower than we could have done it):

    if (!(ppdev->flStatus & STAT_BRUSH_CACHE))
        goto ReturnFalse;

    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:

    if (iHatch & RB_DITHERCOLOR)
    {
        // Implementing DITHERONREALIZE increased our score on a certain
        // unmentionable benchmark by 0.4 million 'megapixels'.  Too bad
        // this didn't work in the first version of NT.

        prb = BRUSHOBJ_pvAllocRbrush(pbo,
              sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE << ppdev->cPelSize));
        if (prb == NULL)
            goto ReturnFalse;

        vRealizeDitherPattern(prb, iHatch);
        goto ReturnTrue;
    }

    // We only accelerate 8x8 patterns.  Since Win3.1 and Chicago don't
    // support patterns of any other size, it's a safe bet that 99.9%
    // of the patterns we'll ever get will be 8x8:

    if ((psoPattern->sizlBitmap.cx != 8) ||
        (psoPattern->sizlBitmap.cy != 8))
        goto ReturnFalse;

    // At 8bpp, we handle patterns at 1bpp, 4bpp and 8bpp with/without an xlate.
    // At 16bpp, we handle patterns at 1bpp and 16bpp without an xlate.
    // At 32bpp, we handle patterns at 1bpp and 32bpp without an xlate.

    iPatternFormat = psoPattern->iBitmapFormat;

    if ((iPatternFormat == BMF_1BPP)             ||
        (iPatternFormat == ppdev->iBitmapFormat) ||
        (iPatternFormat == BMF_4BPP) && (ppdev->iBitmapFormat == BMF_8BPP))
    {
        prb = BRUSHOBJ_pvAllocRbrush(pbo,
              sizeof(RBRUSH) + (TOTAL_BRUSH_SIZE << ppdev->cPelSize));
        if (prb == NULL)
            goto ReturnFalse;

        prb->fl            = 0;
        prb->ptlBrushOrg.x = -1;
        prb->pbe           = NULL;      // Initialize the fields we need

        lSrcDelta = psoPattern->lDelta;
        pjSrc     = (BYTE*) psoPattern->pvScan0;
        pjDst     = (BYTE*) &prb->aulPattern[0];

        if (ppdev->iBitmapFormat == iPatternFormat)
        {
            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                DISPDBG((1, "Realizing un-translated brush"));

                // The pattern is the same colour depth as the screen, and
                // there's no translation to be done:

                cj = (8 << ppdev->cPelSize);    // Every pattern is 8 pels wide

                for (i = 8; i != 0; i--)
                {
                    RtlCopyMemory(pjDst, pjSrc, cj);

                    pjSrc += lSrcDelta;
                    pjDst += cj;
                }
            }
            else if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                DISPDBG((1, "Realizing 8bpp translated brush"));

                // The screen is 8bpp, and there's translation to be done:

                pulXlate = pxlo->pulXlate;

                for (i = 8; i != 0; i--)
                {
                    for (j = 8; j != 0; j--)
                    {
                        *pjDst++ = (BYTE) pulXlate[*pjSrc++];
                    }

                    pjSrc += lSrcDelta - 8;
                }
            }
            else
            {
                // I don't feel like writing code to handle translations
                // when our screen is 16bpp or higher (although I probably
                // should; we could allocate a temporary buffer and use
                // GDI to convert, like is done in the VGA driver).

                goto ReturnFalse;
            }
        }
        else if (iPatternFormat == BMF_1BPP)
        {
            DISPDBG((1, "Realizing 1bpp brush"));

            // We word align the monochrome bitmap so that every row starts
            // on a new word (so that we can do word writes later to transfer
            // the bitmap):

            for (i = 8; i != 0; i--)
            {
                *pjDst = *pjSrc;
                pjDst += sizeof(WORD);
                pjSrc += lSrcDelta;
            }

            pulXlate         = pxlo->pulXlate;
            prb->fl         |= RBRUSH_2COLOR;
            prb->ulForeColor = pulXlate[1];
            prb->ulBackColor = pulXlate[0];
        }
        else
        {
            DISPDBG((1, "Realizing 4bpp brush"));

            // The screen is 8bpp and the pattern is 4bpp:

            ASSERTDD((ppdev->iBitmapFormat == BMF_8BPP) &&
                     (iPatternFormat == BMF_4BPP),
                     "Messed up brush logic");

            pulXlate = pxlo->pulXlate;

            for (i = 8; i != 0; i--)
            {
                // Inner loop is repeated only 4 times because each loop
                // handles 2 pixels:

                for (j = 4; j != 0; j--)
                {
                    *pjDst++ = (BYTE) pulXlate[*pjSrc >> 4];
                    *pjDst++ = (BYTE) pulXlate[*pjSrc & 15];
                    pjSrc++;
                }

                pjSrc += lSrcDelta - 4;
            }
        }

ReturnTrue:

    #if SLOWFILL_PATTERNS
    {
        #if FASTFILL_PATTERNS
        if (!(ppdev->flCaps & CAPS_HW_PATTERNS))
        #endif
        {
            // The last time I checked, GDI took some 500 odd instructions to
            // get from here back to whereever we called 'BRUSHOBJ_pvGetRbrush'.
            // We can at least use this time to get some overlap between the
            // CPU and the display hardware: we'll initialize the 72x72 off-
            // screen cache entry now, which will keep the accelerator busy for
            // a while.
            //
            // We don't do this if we have hardware patterns because:
            //
            //   a) S3 hardware patterns require that the off-screen cached
            //      brush be correctly aligned, and at this point we don't have
            //      access to the 'pptlBrush' brush origin (although we could
            //      have copied it into the PDEV before calling
            //      BRUSHOBJ_pvGetRbrush).
            //
            //   b) S3 hardware patterns require only an 8x8 copy of the
            //      pattern; it is not expanded to 72x72, so there isn't even
            //      any opportunity for CPU/accelerator processing overlap.

            vIoSlowPatRealize(ppdev, prb, ppdev->bRealizeTransparent);
        }
    }
    #endif

        return(TRUE);
    }

ReturnFalse:

    if (psoPattern != NULL)
    {
        DISPDBG((1, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                    psoPattern->iType, psoPattern->iBitmapFormat,
                    psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bEnableBrushCache
*
* Allocates off-screen memory for storing the brush cache.
\**************************************************************************/

BOOL bEnableBrushCache(
PDEV*   ppdev)
{
    OH*         poh;            // Points to off-screen chunk of memory
    BRUSHENTRY* pbe;            // Pointer to the brush-cache entry
    LONG        i;

    pbe = &ppdev->abe[0];       // Points to where we'll put the first brush
                                //   cache entry

#if FASTFILL_PATTERNS
    if (ppdev->flCaps & CAPS_HW_PATTERNS)
    {
        LONG x;
        LONG y;

        poh = pohAllocatePermanent(ppdev,
                    (FAST_BRUSH_COUNT + 1) * FAST_BRUSH_ALLOCATION,
                    FAST_BRUSH_ALLOCATION);

        if (poh == NULL)
            goto ReturnTrue;    // See note about why we can return TRUE...

        ppdev->cBrushCache = FAST_BRUSH_COUNT;

        // Hardware brushes require that the x-coordinate start on an 8
        // pixel boundary.  The heap manager doesn't guarantee us any such
        // alignment, so we allocate a bit of extra room so that we can
        // do the alignment ourselves:

        x = (poh->x + 7) & ~7L;
        y = poh->y;

        for (i = FAST_BRUSH_COUNT; i != 0; i--)
        {
            // If we hadn't allocated 'ppdev' with LMEM_ZEROINIT,
            // we would have to initialize pbe->prbVerify too...

            pbe->x = x;
            pbe->y = y;

            x += FAST_BRUSH_ALLOCATION;
            pbe++;
        }
    }
#endif
#if SLOWFILL_PATTERNS && FASTFILL_PATTERNS
    else
#endif
#if SLOWFILL_PATTERNS
    {
        LONG j;

        ppdev->pfnFillPat = vIoFillPatSlow;           // Override FillPatFast

        // Typically, we'll be running at 1024x768x256 on a 1meg board,
        // giving us off-screen memory of the dimension 1024x253 (accounting
        // for the space taken by the hardware pointer).  If we allocate
        // the brush cache as one long one-high row of brushes, the heap
        // manager would shave that amount off the largest chunk of memory
        // we could allocate (meaning the largest bitmap potentially stored
        // in off-screen memory couldn't be larger than 253 - 64 = 189 pels
        // high, but it could be 1024 wide).
        //
        // To make this more square, I want to shave off a left-side chunk
        // for the brush cache, and I want at least 8 brushes cached.
        // Since floor(253/64) = 3, we'll allocate a 3 x 3 cache:

        poh = pohAllocatePermanent(ppdev,
                    SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_ALLOCATION,
                    SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_ALLOCATION);

        if (poh == NULL)
            goto ReturnTrue;    // See note about why we can return TRUE...

        ppdev->cBrushCache = SLOW_BRUSH_COUNT;

        for (i = 0; i < SLOW_BRUSH_CACHE_DIM; i++)
        {
            for (j = 0; j < SLOW_BRUSH_CACHE_DIM; j++)
            {
                pbe->x = poh->x + (i * SLOW_BRUSH_ALLOCATION);
                pbe->y = poh->y + (j * SLOW_BRUSH_ALLOCATION);
                pbe++;
            }
        }
    }
#endif // SLOWFILL_PATTERNS

    // Note that we don't have to remember 'poh' for when we have
    // to disable brushes -- the off-screen heap frees any
    // off-screen heap allocations automatically.

    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it:

    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:

    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:

    DISPDBG((5, "Passed bEnableBrushCache"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableBrushCache
*
* Cleans up anything done in bEnableBrushCache.
\**************************************************************************/

VOID vDisableBrushCache(PDEV* ppdev)
{
    // We ain't gotta do nothin'
}

/******************************Public*Routine******************************\
* VOID vAssertModeBrushCache
*
* Resets the brush cache when we exit out of full-screen.
\**************************************************************************/

VOID vAssertModeBrushCache(
PDEV*   ppdev,
BOOL    bEnable)
{
    BRUSHENTRY* pbe;
    LONG        i;

    if (bEnable)
    {
        // Invalidate the brush cache:

        pbe = &ppdev->abe[0];

        for (i = ppdev->cBrushCache; i != 0; i--)
        {
            pbe->prbVerify = NULL;
            pbe++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\driver.h ===
/******************************Module*Header*******************************\
* Module Name: driver.h
*
* Contains prototypes for the display driver.
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

//////////////////////////////////////////////////////////////////////
// Put all the conditional-compile constants here.  There had better
// not be many!

// Set this bit when GDI's HOOK_SYNCHRONIZEACCESS works so that we don't
// have to worry about synchronizing device-bitmap access.  Note that
// this wasn't an option in the first release of NT:

#define SYNCHRONIZEACCESS_WORKS 1

// We have no hardware patterns:

#define FASTFILL_PATTERNS       0
#define SLOWFILL_PATTERNS       1

// This is the maximum number of boards we'll support in a single
// virtual driver:

#define MAX_BOARDS          1

// We don't do any banking with the 8514/A:

#define GDI_BANKING             0

// Useful for visualizing the 2-d heap:

#define DEBUG_HEAP              0

//////////////////////////////////////////////////////////////////////
// Miscellaneous shared stuff

#define DLL_NAME                L"8514a"    // Name of the DLL in UNICODE
#define STANDARD_DEBUG_PREFIX   "8514/A: "  // All debug output is prefixed
                                            //   by this string
#define ALLOC_TAG               '158D'      // D851
                                            // Four byte tag (characters in
                                            // reverse order) used for memory
                                            // allocations

#define CLIP_LIMIT          50  // We'll be taking 800 bytes of stack space

#define DRIVER_EXTRA_SIZE   0   // Size of the DriverExtra information in the
                                //   DEVMODE structure

#define TMP_BUFFER_SIZE     8192  // Size in bytes of 'pvTmpBuffer'.  Has to
                                  //   be at least enough to store an entire
                                  //   scan line

typedef struct _CLIPENUM {
    LONG    c;
    RECTL   arcl[CLIP_LIMIT];   // Space for enumerating complex clipping

} CLIPENUM;                         /* ce, pce */

typedef struct _PDEV PDEV;      // Handy forward declaration

extern BYTE gaRop3FromMix[];

VOID vSetClipping(PDEV*, RECTL*);
VOID vResetClipping(PDEV*);
VOID vDataPortOut(PDEV*, VOID*, ULONG);
VOID vDataPortOutB(PDEV*, VOID*, ULONG);
VOID vDataPortIn(PDEV*, VOID*, ULONG);

//////////////////////////////////////////////////////////////////////
// Text stuff

typedef struct _XLATECOLORS {       // Specifies foreground and background
ULONG   iBackColor;                 //   colours for faking a 1bpp XLATEOBJ
ULONG   iForeColor;
} XLATECOLORS;                          /* xlc, pxlc */

BOOL bEnableText(PDEV*);
VOID vDisableText(PDEV*);
VOID vAssertModeText(PDEV*, BOOL);

VOID vFastText(GLYPHPOS*, ULONG, BYTE*, ULONG, ULONG, RECTL*, RECTL*,
               FLONG, RECTL*, RECTL*);
VOID vClearMemDword(ULONG*, ULONG);

//////////////////////////////////////////////////////////////////////
// Dither stuff

// Describes a single colour tetrahedron vertex for dithering:

typedef struct _VERTEX_DATA {
    ULONG ulCount;              // Number of pixels in this vertex
    ULONG ulVertex;             // Vertex number
} VERTEX_DATA;                      /* vd, pv */

VERTEX_DATA*    vComputeSubspaces(ULONG, VERTEX_DATA*);
VOID            vDitherColor(ULONG*, VERTEX_DATA*, VERTEX_DATA*, ULONG);

//////////////////////////////////////////////////////////////////////
// Brush stuff

// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:

#define SLOW_BRUSH_CACHE_DIM    3   // Controls the number of brushes cached
                                    //   in off-screen memory, when we don't
                                    //   have the S3 hardware pattern support.
                                    //   We allocate 3 x 3 brushes, so we can
                                    //   cache a total of 9 brushes:
#define SLOW_BRUSH_COUNT        (SLOW_BRUSH_CACHE_DIM * SLOW_BRUSH_CACHE_DIM)
#define SLOW_BRUSH_DIMENSION    64  // After alignment is taken care of,
                                    //   every off-screen brush cache entry
                                    //   will be 64 pels in both dimensions
#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    //   pattern, using the 8 extra for brush
                                    //   alignment

// 'Fast' brushes are used when we have hardware pattern capability:

#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    //   cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry
                                    //   is 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    //   the dimension of each brush allocation

// Common to both implementations:

#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

typedef struct _BRUSHENTRY BRUSHENTRY;

// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
//       in strucs.inc!

typedef struct _RBRUSH {
    FLONG       fl;             // Type flags
    BOOL        bTransparent;   // TRUE if brush was realized for a transparent
                                //   blt (meaning colours are white and black),
                                //   FALSE if not (meaning it's already been
                                //   colour-expanded to the correct colours).
                                //   Value is undefined if the brush isn't
                                //   2 colour.
    BRUSHENTRY* pbe;            // Points to brush-entry that keeps track
                                //   of the cached off-screen brush bits
    ULONG       ulForeColor;    // Foreground colour if 1bpp
    ULONG       ulBackColor;    // Background colour if 1bpp
    POINTL      ptlBrushOrg;    // Brush origin of cached pattern.  Initial
                                //   value should be -1
    ULONG       aulPattern[1];  // Open-ended array for keeping copy of the
      // Don't put anything     //   actual pattern bits in case the brush
      //   after here, or       //   origin changes, or someone else steals
      //   you'll be sorry!     //   our brush entry (declared as a ULONG
                                //   for proper dword alignment)

} RBRUSH;                           /* rb, prb */

typedef struct _BRUSHENTRY {
    RBRUSH*     prbVerify;      // We never dereference this pointer to
                                //   find a brush realization; it is only
                                //   ever used in a compare to verify
                                //   that for a given realized brush, our
                                //   off-screen brush entry is still valid.
    LONG        x;              // x-position of cached pattern
    LONG        y;              // y-position of cached pattern

} BRUSHENTRY;                       /* be, pbe */

typedef union _RBRUSH_COLOR {
    RBRUSH*     prb;
    ULONG       iSolidColor;
} RBRUSH_COLOR;                     /* rbc, prbc */

BOOL bEnableBrushCache(PDEV*);
VOID vDisableBrushCache(PDEV*);
VOID vAssertModeBrushCache(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Heap stuff

typedef enum {
    OFL_INUSE       = 1,    // The device bitmap is no longer located in
                            //   off-screen memory; it's been converted to
                            //   a DIB
    OFL_AVAILABLE   = 2,    // Space is in-use
    OFL_PERMANENT   = 4     // Space is available
} OHFLAGS;                  // Space is permanently allocated; never free it

typedef struct _DSURF DSURF;
typedef struct _OH OH;
typedef struct _OH
{
    OHFLAGS  ofl;           // OH_ flags
    LONG     x;             // x-coordinate of left edge of allocation
    LONG     y;             // y-coordinate of top edge of allocation
    LONG     cx;            // Width in pixels of allocation
    LONG     cy;            // Height in pixels of allocation
    OH*      pohNext;       // When OFL_AVAILABLE, points to the next free node,
                            //   in ascending cxcy value.  This is kept as a
                            //   circular doubly-linked list with a sentinel
                            //   at the end.
                            // When OFL_INUSE, points to the next most recently
                            //   blitted allocation.  This is kept as a circular
                            //   doubly-linked list so that the list can be
                            //   quickly be updated on every blt.
    OH*      pohPrev;       // Opposite of 'pohNext'
    ULONG    cxcy;          // Width and height in a dword for searching
    OH*      pohLeft;       // Adjacent allocation when in-use or available
    OH*      pohUp;
    OH*      pohRight;
    OH*      pohDown;
    DSURF*   pdsurf;        // Points to our DSURF structure
};                              /* oh, poh */

// This is the smallest structure used for memory allocations:

typedef struct _OHALLOC OHALLOC;
typedef struct _OHALLOC
{
    OHALLOC* pohaNext;
    OH       aoh[1];
} OHALLOC;                      /* oha, poha */

typedef struct _HEAP
{
    LONG     cxMax;         // Largest possible free space by area
    LONG     cyMax;
    OH       ohAvailable;   // Head of available list (pohNext points to
                            //   smallest available rectangle, pohPrev
                            //   points to largest available rectangle,
                            //   sorted by cxcy)
    OH       ohDfb;         // Head of the list of all DFBs currently in
                            //   offscreen memory that are eligible to be
                            //   tossed out of the heap (pohNext points to
                            //   the most recently blitted; pohPrev points
                            //   to least recently blitted)
    OH*      pohFreeList;   // List of OH node data structures available
    OHALLOC* pohaChain;     // Chain of allocations
} HEAP;                         /* heap, pheap */

typedef enum {
    DT_SCREEN,              // Surface is kept in screen memory
    DT_DIB                  // Surface is kept as a DIB
} DSURFTYPE;                    /* dt, pdt */

typedef struct _DSURF
{
    DSURFTYPE dt;           // DSURF status (whether off-screen or in a DIB)
    SIZEL     sizl;         // Size of the original bitmap (could be smaller
                            //   than poh->sizl)
    PDEV*     ppdev;        // Need this for deleting the bitmap
    union {
        OH*         poh;    // If DT_SCREEN, points to off-screen heap node
        SURFOBJ*    pso;    // If DT_DIB, points to locked GDI surface
    };

    // The following are used for DT_DIB only...

    ULONG     cBlt;         // Counts down the number of blts necessary at
                            //   the current uniqueness before we'll consider
                            //   putting the DIB back into off-screen memory
    ULONG     iUniq;        // Tells us whether there have been any heap
                            //   'free's since the last time we looked at
                            //   this DIB

} DSURF;                          /* dsurf, pdsurf */

// Off-screen heap allocations have no 'x' alignment:

#define HEAP_X_ALIGNMENT    1

// Number of blts necessary before we'll consider putting a DIB DFB back
// into off-screen memory:

#define HEAP_COUNT_DOWN     6

// Flags for 'pohAllocate':

typedef enum {
    FLOH_ONLY_IF_ROOM       = 0x00000001,   // Don't kick stuff out of off-
                                            //   screen memory to make room
} FLOH;

BOOL bEnableOffscreenHeap(PDEV*);
VOID vDisableOffscreenHeap(PDEV*);
BOOL bAssertModeOffscreenHeap(PDEV*, BOOL);

OH*  pohMoveOffscreenDfbToDib(PDEV*, OH*);
BOOL bMoveDibToOffscreenDfbIfRoom(PDEV*, DSURF*);
OH*  pohAllocatePermanent(PDEV*, LONG, LONG);
BOOL bMoveAllDfbsFromOffscreenToDibs(PDEV* ppdev);

/////////////////////////////////////////////////////////////////////////
// Pointer stuff

BOOL bEnablePointer(PDEV*);
VOID vDisablePointer(PDEV*);
VOID vAssertModePointer(PDEV*, BOOL);

/////////////////////////////////////////////////////////////////////////
// Palette stuff

BOOL bEnablePalette(PDEV*);
VOID vDisablePalette();
VOID vAssertModePalette(PDEV*, BOOL);

BOOL bInitializePalette(PDEV*, DEVINFO*);
VOID vUninitializePalette(PDEV*);

#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * 256))

//////////////////////////////////////////////////////////////////////
// Low-level blt function prototypes

typedef VOID (FNFILL)(PDEV*, LONG, RECTL*, ULONG, ULONG, RBRUSH_COLOR, POINTL*);
typedef VOID (FNXFER)(PDEV*, LONG, RECTL*, ULONG, ULONG, SURFOBJ*, POINTL*,
                      RECTL*, XLATEOBJ*);
typedef VOID (FNCOPY)(PDEV*, LONG, RECTL*, ULONG, POINTL*, RECTL*);
typedef VOID (FNMASK)(PDEV*, LONG, RECTL*, ULONG, ULONG, SURFOBJ*, POINTL*,
                      SURFOBJ*, POINTL*, RECTL*, ULONG, RBRUSH*, POINTL*,
                      XLATEOBJ*);
typedef VOID (FNFASTLINE)(PDEV*, PATHOBJ*, RECTL*, PFNSTRIP*, LONG, ULONG,
                          ULONG);
typedef BOOL (FNFASTFILL)(PDEV*, LONG, POINTFIX*, ULONG, ULONG, ULONG, RBRUSH*);

FNFILL      vIoFillPatFast;
FNFILL      vIoFillPatSlow;
FNFILL      vIoFillSolid;
FNXFER      vIoXfer1bpp;
FNXFER      vIoXfer1bppPacked;
FNXFER      vIoXfer4bpp;
FNXFER      vIoXferNative;
FNCOPY      vIoCopyBlt;
FNMASK      vIoMaskCopy;
FNFASTLINE  vIoFastLine;
FNFASTFILL  bIoFastFill;

VOID vPutBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vGetBits(PDEV*, SURFOBJ*, RECTL*, POINTL*);
VOID vIoSlowPatRealize(PDEV*, RBRUSH*, BOOL);

////////////////////////////////////////////////////////////////////////
// Capabilities flags

typedef enum {
    CAPS_MASKBLT_CAPABLE    = 0x0001,   // Hardware is capable of maskblts
    CAPS_SW_POINTER         = 0x0002,   // No hardware pointer; use software
                                        //   simulation
    CAPS_MINIPORT_POINTER   = 0x0004,   // Use miniport hardware pointer
} CAPS;

// Status flags

typedef enum {
    STAT_GLYPH_CACHE        = 0x0001,   // Glyph cache successfully allocated
    STAT_BRUSH_CACHE        = 0x0002,   // Brush cache successfully allocated
} STATUS;

////////////////////////////////////////////////////////////////////////
// The Physical Device data structure

typedef struct  _PDEV
{
    LONG        xOffset;
    LONG        yOffset;
    ULONG       iBitmapFormat;          // BMF_8BPP or BMF_16BPP or BMF_32BPP
                                        //   (our current colour depth)

    // Enhanced mode register addresses.

    ULONG       ioCur_y;
    ULONG       ioCur_x;
    ULONG       ioDesty_axstp;
    ULONG       ioDestx_diastp;
    ULONG       ioErr_term;
    ULONG       ioMaj_axis_pcnt;
    ULONG       ioGp_stat_cmd;
    ULONG       ioShort_stroke;
    ULONG       ioBkgd_color;
    ULONG       ioFrgd_color;
    ULONG       ioWrt_mask;
    ULONG       ioRd_mask;
    ULONG       ioColor_cmp;
    ULONG       ioBkgd_mix;
    ULONG       ioFrgd_mix;
    ULONG       ioMulti_function;
    ULONG       ioPix_trans;

    CAPS        flCaps;                 // CAPS_ capabilities flags
    STATUS      flStatus;               // STAT_ status flags
    BOOL        bEnabled;               // In graphics mode (not full-screen)

    // -------------------------------------------------------------------
    // NOTE: Changes up to here in the PDEV structure must be reflected in
    // i386\strucs.inc (assuming you're on an x86, of course)!

    LONG        iBoard;                 // Logical multi-board identifier
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen surface
    DSURF*      pdsurfScreen;           // Our private DSURF for the screen

    BYTE*       pjScreen;               // Points to base screen address
    BYTE*       pjMmBase;               // Start of memory mapped I/O

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cxMemory;               // Width of Video RAM
    LONG        cyMemory;               // Height of Video RAM
    ULONG       ulMode;                 // Mode the mini-port driver is in.
    LONG        lDelta;                 // Distance from one scan to the next.

    FLONG       flHooks;                // What we're hooking from GDI
    LONG        cPelSize;               // 0 if 8bpp, 1 if 16bpp, 2 if 32bpp
    ULONG       ulWhite;                // 0xff if 8bpp, 0xffff if 16bpp,
                                        //   0xffffffff if 32bpp
    VOID*       pvTmpBuffer;            // General purpose temporary buffer,
                                        //   TMP_BUFFER_SIZE bytes in size
                                        //   (Remember to synchronize if you
                                        //   use this for device bitmaps or
                                        //   async pointers)

    ////////// Low-level blt function pointers:


    FNFILL*     pfnFillSolid;
    FNFILL*     pfnFillPat;
    FNXFER*     pfnXfer1bpp;
    FNXFER*     pfnXfer4bpp;
    FNXFER*     pfnXferNative;
    FNCOPY*     pfnCopyBlt;
    FNMASK*     pfnMaskCopy;
    FNFASTLINE* pfnFastLine;
    FNFASTFILL* pfnFastFill;

    ////////// Palette stuff:

    PALETTEENTRY* pPal;                 // The palette if palette managed
    HPALETTE    hpalDefault;            // GDI handle to the default palette.
    FLONG       flRed;                  // Red mask for 16/32bpp bitfields
    FLONG       flGreen;                // Green mask for 16/32bpp bitfields
    FLONG       flBlue;                 // Blue mask for 16/32bpp bitfields
    ULONG       cPaletteShift;          // number of bits the 8-8-8 palette must
                                        // be shifted by to fit in the hardware
                                        // palette.

    ////////// Heap stuff:

    HEAP        heap;                   // All our off-screen heap data
    ULONG       iHeapUniq;              // Incremented every time room is freed
                                        //   in the off-screen heap

    ////////// Brush stuff:

    BOOL        bRealizeTransparent;    // Hint to DrvRealizeBrush for whether
                                        //   the brush should be realized as
                                        //   transparent or not
    LONG        iBrushCache;            // Index for next brush to be allocated
    LONG        cBrushCache;            // Total number of brushes cached
    BRUSHENTRY  abe[TOTAL_BRUSH_COUNT]; // Keeps track of brush cache

    ////////// Font Stuff

#define GLYPH_CACHE_X       (ppdev->ptlGlyphCache.x)
#define GLYPH_CACHE_Y       (ppdev->ptlGlyphCache.y)
#define GLYPH_CACHE_CX      32
#define GLYPH_CACHE_CY      32

#define CACHED_GLYPHS_ROWS  4
#define GLYPHS_PER_ROW      (512 / GLYPH_CACHE_CX)

    BYTE        ajGlyphAllocBitVector[CACHED_GLYPHS_ROWS][GLYPHS_PER_ROW];
    CLIPOBJ     *pcoDefault;            // ptr to a default clip obj
    POINTL      ptlGlyphCache;
} PDEV, *PPDEV;

/////////////////////////////////////////////////////////////////////////
// Miscellaneous prototypes:

BOOL bIntersect(RECTL*, RECTL*, RECTL*);
LONG cIntersect(RECTL*, RECTL*, LONG);
BOOL bFastFill(PDEV*, LONG, POINTFIX*, ULONG, ULONG);
DWORD getAvailableModes(HANDLE, PVIDEO_MODE_INFORMATION*, DWORD*);

BOOL bInitializeModeFields(PDEV*, GDIINFO*, DEVINFO*, DEVMODEW*);

BOOL bEnableHardware(PDEV*);
VOID vDisableHardware(PDEV*);
BOOL bAssertModeHardware(PDEV*, BOOL);

extern BYTE gajHwMixFromMix[];

/////////////////////////////////////////////////////////////////////////
// The x86 C compiler insists on making a divide and modulus operation
// into two DIVs, when it can in fact be done in one.  So we use this
// macro.
//
// Note: QUOTIENT_REMAINDER implicitly takes unsigned arguments.

#if defined(i386)

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    __asm mov eax, ulNumerator                                  \
    __asm sub edx, edx                                          \
    __asm div ulDenominator                                     \
    __asm mov ulQuotient, eax                                   \
    __asm mov ulRemainder, edx                                  \
}

#else

#define QUOTIENT_REMAINDER(ulNumerator, ulDenominator, ulQuotient, ulRemainder) \
{                                                               \
    ulQuotient  = (ULONG) ulNumerator / (ULONG) ulDenominator;  \
    ulRemainder = (ULONG) ulNumerator % (ULONG) ulDenominator;  \
}

#endif

/////////////////////////////////////////////////////////////////////////
// OVERLAP - Returns TRUE if the same-size lower-right exclusive
//           rectangles defined by 'pptl' and 'prcl' overlap:

#define OVERLAP(prcl, pptl)                                             \
    (((prcl)->right  > (pptl)->x)                                   &&  \
     ((prcl)->bottom > (pptl)->y)                                   &&  \
     ((prcl)->left   < ((pptl)->x + (prcl)->right - (prcl)->left))  &&  \
     ((prcl)->top    < ((pptl)->y + (prcl)->bottom - (prcl)->top)))

// These Dbg prototypes are thunks for debugging:

VOID    DbgDisableDriver(VOID);
ULONG   DbgGetModes(HANDLE, ULONG, DEVMODEW*);
DHPDEV  DbgEnablePDEV(DEVMODEW*, PWSTR, ULONG, HSURF*, ULONG, ULONG*,
                      ULONG, DEVINFO*, HDEV, PWSTR, HANDLE);
VOID    DbgCompletePDEV(DHPDEV, HDEV);
HSURF   DbgEnableSurface(DHPDEV);
BOOL    DbgStrokePath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, XFORMOBJ*, BRUSHOBJ*,
                      POINTL*, LINEATTRS*, MIX);
BOOL    DbgFillPath(SURFOBJ*, PATHOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*,
                    MIX, FLONG);
BOOL    DbgBitBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                  RECTL*, POINTL*, POINTL*, BRUSHOBJ*, POINTL*, ROP4);
VOID    DbgDisablePDEV(DHPDEV);
VOID    DbgDisableSurface(DHPDEV);
BOOL    DbgAssertMode(DHPDEV, BOOL);
VOID    DbgMovePointer(SURFOBJ*, LONG, LONG, RECTL*);
ULONG   DbgSetPointerShape(SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*, LONG,
                           LONG, LONG, LONG, RECTL*, FLONG);
ULONG   DbgDitherColor(DHPDEV, ULONG, ULONG, ULONG*);
BOOL    DbgSetPalette(DHPDEV, PALOBJ*, FLONG, ULONG, ULONG);
BOOL    DbgCopyBits(SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*, RECTL*, POINTL*);
BOOL    DbgTextOut(SURFOBJ*, STROBJ*, FONTOBJ*, CLIPOBJ*, RECTL*, RECTL*,
                   BRUSHOBJ*, BRUSHOBJ*, POINTL*, MIX);
VOID    DbgDestroyFont(FONTOBJ*);
BOOL    DbgPaint(SURFOBJ*, CLIPOBJ*, BRUSHOBJ*, POINTL*, MIX);
BOOL    DbgRealizeBrush(BRUSHOBJ*, SURFOBJ*, SURFOBJ*, SURFOBJ*, XLATEOBJ*,
                        ULONG);
HBITMAP DbgCreateDeviceBitmap(DHPDEV, SIZEL, ULONG);
VOID    DbgDeleteDeviceBitmap(DHSURF);
BOOL    DbgStretchBlt(SURFOBJ*, SURFOBJ*, SURFOBJ*, CLIPOBJ*, XLATEOBJ*,
                      COLORADJUSTMENT*, POINTL*, RECTL*, RECTL*, POINTL*,
                      ULONG);

//////////////////////////////////////////////////////////////////////////

typedef struct {
    LONG    x;
    LONG    y;
    LONG    z;
} XYZPOINTL;

typedef XYZPOINTL *PXYZPOINTL;
typedef XYZPOINTL XYZPOINT;
typedef XYZPOINT  *PXYZPOINT;

// Font & Text stuff

typedef struct _cachedGlyph {
    HGLYPH      hg;
    struct      _cachedGlyph  *pcgCollisionLink;
    ULONG       fl;
    POINTL      ptlOrigin;
    SIZEL       sizlBitmap;
    ULONG       BmPitchInPels;
    ULONG       BmPitchInBytes;
    XYZPOINTL   xyzGlyph;
} CACHEDGLYPH, *PCACHEDGLYPH;

#define VALID_GLYPH     0x01

#define END_COLLISIONS  0

typedef struct _cachedFont {
    struct _cachedFont *pcfNext;
    ULONG           iUniq;
    ULONG           cGlyphs;
    ULONG           cjMaxGlyph1;
    PCACHEDGLYPH    pCachedGlyphs;
} CACHEDFONT, *PCACHEDFONT;

// Clipping Control Stuff

typedef struct {
    ULONG   c;
    RECTL   arcl[8];
} ENUMRECTS8;

typedef ENUMRECTS8 *PENUMRECTS8;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\fastfill.c ===
/******************************Module*Header*******************************\
* Module Name: fastfill.c
*
* Fills solid-coloured, unclipped, non-complex rectangles.
*
* Copyright (c) 1993-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define RIGHT 0
#define LEFT  1
#define SWAP(a, b, tmp) { tmp = a; a = b; b = tmp; }

typedef struct _EDGEDATA {
LONG      x;                // Current x position
LONG      dx;               // # pixels to advance x on each scan
LONG      lError;           // Current DDA error
LONG      lErrorUp;         // DDA error increment on each scan
LONG      lErrorDown;       // DDA error adjustment
POINTFIX* pptfx;            // Points to start of current edge
LONG      dptfx;            // Delta (in bytes) from pptfx to next point
LONG      cy;               // Number of scans to go for this edge
} EDGEDATA;                         /* ed, ped */

/******************************Public*Routine******************************\
* bFastFill
*
* Draws a non-complex, unclipped polygon.
*
* Returns TRUE if the polygon was drawn; FALSE if the polygon was complex.
*
\**************************************************************************/

BOOL bFastFill(
PPDEV     ppdev,
LONG      cEdges,           // Includes close figure edge
POINTFIX* pptfxFirst,
ULONG     ulHwMix,
ULONG     iSolidColor)
{
    LONG      yTrapezoid;   // Top scan for next trapezoid
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    yTrapezoid = (pptfxTop->y + 15) >> 4;

    // We initialize the hardware for the colour, mix, pixel operation,
    // rectangle height of one, and the y position for the first scan:

    IO_FIFO_WAIT(ppdev, 5);
    IO_CUR_Y(ppdev, yTrapezoid);
    IO_FRGD_COLOR(ppdev, (INT) iSolidColor);
    IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | (WORD) ulHwMix);
    IO_PIX_CNTL(ppdev, ALL_ONES);
    IO_MIN_AXIS_PCNT(ppdev, 0);

    // Make sure we initialize the DDAs appropriately:

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

NextEdge:

    // We loop through this routine on a per-trapezoid basis.

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                    return(TRUE);

                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yTrapezoid:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yTrapezoid;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yTrapezoid'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTDD(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i != 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;
    yTrapezoid    += cyTrapezoid;                   // Top scan in next trap

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0) &&
        (cyTrapezoid > 1))
    {
        LONG lWidth;

    ContinueVertical:

        lWidth = aed[RIGHT].x - aed[LEFT].x - 1;
        if (lWidth >= 0)
        {
            IO_FIFO_WAIT(ppdev, 5);

            IO_MAJ_AXIS_PCNT(ppdev, lWidth);
            IO_MIN_AXIS_PCNT(ppdev, cyTrapezoid - 1);
            IO_CUR_X(ppdev, aed[LEFT].x);
            IO_CMD(ppdev, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                          DRAW           | DIR_TYPE_XY        |
                          LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                          WRITE);
            IO_MIN_AXIS_PCNT(ppdev, 0);
        }
        else if (lWidth == -1)
        {
            // If the rectangle was too thin to light any pels, we still
            // have to advance the y current position:

            IO_FIFO_WAIT(ppdev, 1);
            IO_CUR_Y(ppdev, yTrapezoid - cyTrapezoid + 1);
        }
        else
        {
            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);
            goto ContinueVertical;
        }

        goto NextEdge;
    }

    while (TRUE)
    {
        LONG lWidth;

        // The very first time through, make sure we set x:

        lWidth = aed[RIGHT].x - aed[LEFT].x - 1;
        if (lWidth >= 0)
        {
            IO_FIFO_WAIT(ppdev, 3);
            IO_MAJ_AXIS_PCNT(ppdev, lWidth);
            IO_CUR_X(ppdev, aed[LEFT].x);
            IO_CMD(ppdev, RECTANGLE_FILL | DRAWING_DIR_TBLRXM |
                          DRAW           | DIR_TYPE_XY        |
                          LAST_PIXEL_ON  | MULTIPLE_PIXELS    |
                          WRITE);

    ContinueAfterZero:

            // Advance the right wall:

            aed[RIGHT].x      += aed[RIGHT].dx;
            aed[RIGHT].lError += aed[RIGHT].lErrorUp;

            if (aed[RIGHT].lError >= 0)
            {
                aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                aed[RIGHT].x++;
            }

            // Advance the left wall:

            aed[LEFT].x      += aed[LEFT].dx;
            aed[LEFT].lError += aed[LEFT].lErrorUp;

            if (aed[LEFT].lError >= 0)
            {
                aed[LEFT].lError -= aed[LEFT].lErrorDown;
                aed[LEFT].x++;
            }

            cyTrapezoid--;
            if (cyTrapezoid == 0)
                goto NextEdge;
        }
        else if (lWidth == -1)
        {
            IO_FIFO_WAIT(ppdev, 1);
            IO_CUR_Y(ppdev, yTrapezoid - cyTrapezoid + 1);
            goto ContinueAfterZero;
        }
        else
        {
            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            LONG      lTmp;
            POINTFIX* pptfxTmp;

            SWAP(aed[LEFT].x,          aed[RIGHT].x,          lTmp);
            SWAP(aed[LEFT].dx,         aed[RIGHT].dx,         lTmp);
            SWAP(aed[LEFT].lError,     aed[RIGHT].lError,     lTmp);
            SWAP(aed[LEFT].lErrorUp,   aed[RIGHT].lErrorUp,   lTmp);
            SWAP(aed[LEFT].lErrorDown, aed[RIGHT].lErrorDown, lTmp);
            SWAP(aed[LEFT].cy,         aed[RIGHT].cy,         lTmp);
            SWAP(aed[LEFT].dptfx,      aed[RIGHT].dptfx,      lTmp);
            SWAP(aed[LEFT].pptfx,      aed[RIGHT].pptfx,      pptfxTmp);

            continue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\enable.c ===
/******************************Module*Header*******************************\
* Module Name: enable.c
*
* This module contains the functions that enable and disable the
* driver, the pdev, and the surface.
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Structure****************************\
* GDIINFO ggdiDefault
*
* This contains the default GDIINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

GDIINFO ggdiDefault = {
    GDI_DRIVER_VERSION,
    DT_RASDISPLAY,          // ulTechnology
    0,                      // ulHorzSize (filled in later)
    0,                      // ulVertSize (filled in later)
    0,                      // ulHorzRes (filled in later)
    0,                      // ulVertRes (filled in later)
    0,                      // cBitsPixel (filled in later)
    0,                      // cPlanes (filled in later)
    20,                     // ulNumColors (palette managed)
    0,                      // flRaster (DDI reserved field)

    0,                      // ulLogPixelsX (filled in later)
    0,                      // ulLogPixelsY (filled in later)

    TC_RA_ABLE,             // flTextCaps -- If we had wanted console windows
                            //   to scroll by repainting the entire window,
                            //   instead of doing a screen-to-screen blt, we
                            //   would have set TC_SCROLLBLT (yes, the flag is
                            //   bass-ackwards).

    0,                      // ulDACRed (filled in later)
    0,                      // ulDACGreen (filled in later)
    0,                      // ulDACBlue (filled in later)

    0x0024,                 // ulAspectX
    0x0024,                 // ulAspectY
    0x0033,                 // ulAspectXY (one-to-one aspect ratio)

    1,                      // xStyleStep
    1,                      // yStyleSte;
    3,                      // denStyleStep -- Styles have a one-to-one aspect
                            //   ratio, and every 'dot' is 3 pixels long

    { 0, 0 },               // ptlPhysOffset
    { 0, 0 },               // szlPhysSize

    256,                    // ulNumPalReg

    // These fields are for halftone initialization.  The actual values are
    // a bit magic, but seem to work well on our display.

    {                       // ciDevice
       { 6700, 3300, 0 },   //      Red
       { 2100, 7100, 0 },   //      Green
       { 1400,  800, 0 },   //      Blue
       { 1750, 3950, 0 },   //      Cyan
       { 4050, 2050, 0 },   //      Magenta
       { 4400, 5200, 0 },   //      Yellow
       { 3127, 3290, 0 },   //      AlignmentWhite
       20000,               //      RedGamma
       20000,               //      GreenGamma
       20000,               //      BlueGamma
       0, 0, 0, 0, 0, 0     //      No dye correction for raster displays
    },

    0,                       // ulDevicePelsDPI (for printers only)
    PRIMARY_ORDER_CBA,       // ulPrimaryOrder
    HT_PATSIZE_4x4_M,        // ulHTPatternSize
    HT_FORMAT_8BPP,          // ulHTOutputFormat
    HT_FLAG_ADDITIVE_PRIMS,  // flHTFlags
    0,                       // ulVRefresh (filled in later)
    0,                       // ulBltAlignment
    0,                       // ulPanningHorzRes (filled in later)
    0,                       // ulPanningVertRes (filled in later)
};

/******************************Public*Structure****************************\
* DEVINFO gdevinfoDefault
*
* This contains the default DEVINFO fields that are passed back to GDI
* during DrvEnablePDEV.
*
* NOTE: This structure defaults to values for an 8bpp palette device.
*       Some fields are overwritten for different colour depths.
\**************************************************************************/

#define SYSTM_LOGFONT {16,7,0,0,700,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_DEFAULT_PRECIS,DEFAULT_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"System"}
#define HELVE_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       VARIABLE_PITCH | FF_DONTCARE,L"MS Sans Serif"}
#define COURI_LOGFONT {12,9,0,0,400,0,0,0,ANSI_CHARSET,OUT_DEFAULT_PRECIS,\
                       CLIP_STROKE_PRECIS,PROOF_QUALITY,\
                       FIXED_PITCH | FF_DONTCARE, L"Courier"}

DEVINFO gdevinfoDefault = {
    (GCAPS_OPAQUERECT       |
     GCAPS_DITHERONREALIZE  |
     GCAPS_PALMANAGED       |
     GCAPS_ALTERNATEFILL    |
     GCAPS_WINDINGFILL      |
     GCAPS_MONO_DITHER      |
     GCAPS_COLOR_DITHER),
                                                // flGraphicsFlags
    SYSTM_LOGFONT,                              // lfDefaultFont
    HELVE_LOGFONT,                              // lfAnsiVarFont
    COURI_LOGFONT,                              // lfAnsiFixFont
    0,                                          // cFonts
    BMF_8BPP,                                   // iDitherFormat
    8,                                          // cxDither
    8,                                          // cyDither
    0                                           // hpalDefault (filled in later)
};

/******************************Public*Structure****************************\
* DFVFN gadrvfn[]
*
* Build the driver function table gadrvfn with function index/address
* pairs.  This table tells GDI which DDI calls we support, and their
* location (GDI does an indirect call through this table to call us).
*
* Why haven't we implemented DrvSaveScreenBits?  To save code.
*
* When the driver doesn't hook DrvSaveScreenBits, USER simulates on-
* the-fly by creating a temporary device-format-bitmap, and explicitly
* calling DrvCopyBits to save/restore the bits.  Since we already hook
* DrvCreateDeviceBitmap, we'll end up using off-screen memory to store
* the bits anyway (which would have been the main reason for implementing
* DrvSaveScreenBits).  So we may as well save some working set.
\**************************************************************************/

#if DBG || !SYNCHRONIZEACCESS_WORKS

// On Checked builds, or when we have to synchronize access, thunk
// everything through Dbg calls...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DbgEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DbgCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DbgDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DbgEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DbgDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DbgAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DbgMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DbgSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DbgDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DbgSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DbgCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DbgBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DbgTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DbgGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DbgStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) DbgFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DbgPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DbgRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DbgCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DbgDeleteDeviceBitmap },
    {   INDEX_DrvStretchBlt,            (PFN) DbgStretchBlt         },
    {   INDEX_DrvDisableDriver,         (PFN) DbgDisableDriver      }
};

#else

// On Free builds, directly call the appropriate functions...

DRVFN gadrvfn[] = {
    {   INDEX_DrvEnablePDEV,            (PFN) DrvEnablePDEV         },
    {   INDEX_DrvCompletePDEV,          (PFN) DrvCompletePDEV       },
    {   INDEX_DrvDisablePDEV,           (PFN) DrvDisablePDEV        },
    {   INDEX_DrvEnableSurface,         (PFN) DrvEnableSurface      },
    {   INDEX_DrvDisableSurface,        (PFN) DrvDisableSurface     },
    {   INDEX_DrvAssertMode,            (PFN) DrvAssertMode         },
    {   INDEX_DrvMovePointer,           (PFN) DrvMovePointer        },
    {   INDEX_DrvSetPointerShape,       (PFN) DrvSetPointerShape    },
    {   INDEX_DrvDitherColor,           (PFN) DrvDitherColor        },
    {   INDEX_DrvSetPalette,            (PFN) DrvSetPalette         },
    {   INDEX_DrvCopyBits,              (PFN) DrvCopyBits           },
    {   INDEX_DrvBitBlt,                (PFN) DrvBitBlt             },
    {   INDEX_DrvTextOut,               (PFN) DrvTextOut            },
    {   INDEX_DrvGetModes,              (PFN) DrvGetModes           },
    {   INDEX_DrvStrokePath,            (PFN) DrvStrokePath         },
    {   INDEX_DrvFillPath,              (PFN) DrvFillPath           },
    {   INDEX_DrvPaint,                 (PFN) DrvPaint              },
    {   INDEX_DrvRealizeBrush,          (PFN) DrvRealizeBrush       },
    {   INDEX_DrvCreateDeviceBitmap,    (PFN) DrvCreateDeviceBitmap },
    {   INDEX_DrvDeleteDeviceBitmap,    (PFN) DrvDeleteDeviceBitmap },
    {   INDEX_DrvStretchBlt,            (PFN) DrvStretchBlt         },
    {   INDEX_DrvDisableDriver,         (PFN) DrvDisableDriver      }
};

#endif

ULONG gcdrvfn = sizeof(gadrvfn) / sizeof(DRVFN);

/******************************Public*Routine******************************\
* BOOL DrvEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
\**************************************************************************/

BOOL DrvEnableDriver(
ULONG          iEngineVersion,
ULONG          cj,
DRVENABLEDATA* pded)
{
    // Engine Version is passed down so future drivers can support previous
    // engine versions.  A next generation driver can support both the old
    // and new engine conventions if told what version of engine it is
    // working with.  For the first version the driver does nothing with it.

    // Fill in as much as we can.

    if (cj >= sizeof(DRVENABLEDATA))
        pded->pdrvfn = gadrvfn;

    if (cj >= (sizeof(ULONG) * 2))
        pded->c = gcdrvfn;

    // DDI version this driver was targeted for is passed back to engine.
    // Future graphic's engine may break calls down to old driver format.

    if (cj >= sizeof(ULONG))
        pded->iDriverVersion = DDI_DRIVER_VERSION_NT4;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDisableDriver
*
* Tells the driver it is being disabled.  Release any resources allocated in
* DrvEnableDriver.
*
\**************************************************************************/

VOID DrvDisableDriver(VOID)
{
    return;
}

/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI, based on the mode we've been asked
* to do.  This is the first thing called after DrvEnableDriver, when GDI
* wants to get some information about us.
*
\**************************************************************************/

DHPDEV DrvEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    PDEV*   ppdev;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "DrvEnablePDEV - Buffer size too small"));
        goto ReturnFailure0;
    }

    // Allocate a physical device structure.  Note that we definitely
    // rely on the zero initialization:

    ppdev = (PDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(PDEV), ALLOC_TAG);
    if (ppdev == NULL)
    {
        DISPDBG((0, "DrvEnablePDEV - Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    ppdev->hDriver = hDriver;

    // Get the current screen mode information.  Set up device caps and
    // devinfo:

    if (!bInitializeModeFields(ppdev, (GDIINFO*) pdevcaps, pdi, pdm))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializeModeFields"));
        goto ReturnFailure1;
    }

    // Initialize palette information.

    if (!bInitializePalette(ppdev, pdi))
    {
        DISPDBG((0, "DrvEnablePDEV - Failed bInitializePalette"));
        goto ReturnFailure1;
    }

    return((DHPDEV) ppdev);

ReturnFailure1:
    DrvDisablePDEV((DHPDEV) ppdev);

ReturnFailure0:
    DISPDBG((0, "Failed DrvEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
* Note: In an error, we may call this before DrvEnablePDEV is done.
*
\**************************************************************************/

VOID DrvDisablePDEV(
DHPDEV  dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    vUninitializePalette(ppdev);
    EngFreeMem(ppdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID DrvCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    ((PDEV*) dhpdev)->hdevEng = hdev;
}

/******************************Public*Routine******************************\
* HSURF DrvEnableSurface
*
* Creates the drawing surface and initializes the hardware.  This is called
* after DrvEnablePDEV, and performs the final device initialization.
*
\**************************************************************************/

HSURF DrvEnableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;
    HSURF   hsurf;
    SIZEL   sizl;
    DSURF*  pdsurf;
    VOID*   pvTmpBuffer;

    ppdev = (PDEV*) dhpdev;

    /////////////////////////////////////////////////////////////////////
    // First, create our private surface structure.
    //
    // Whenever we get a call to draw directly to the screen, we'll get
    // passed a pointer to a SURFOBJ whose 'dhpdev' field will point
    // to our PDEV structure, and whose 'dhsurf' field will point to the
    // following DSURF structure.
    //
    // Every device bitmap we create in DrvCreateDeviceBitmap will also
    // have its own unique DSURF structure allocated (but will share the
    // same PDEV).  To make our code more polymorphic for handling drawing
    // to either the screen or an off-screen bitmap, we have the same
    // structure for both.

    pdsurf = EngAllocMem(FL_ZERO_MEMORY, sizeof(DSURF), ALLOC_TAG);
    if (pdsurf == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed pdsurf EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pdsurfScreen = pdsurf;        // Remember it for clean-up

    pdsurf->poh     = &ppdev->heap.ohDfb;// The only thing we use this OH node
    pdsurf->poh->x  = 0;                 //   for is its (x, y) location, and
    pdsurf->poh->y  = 0;                 //   'ohDfb' is otherwise unused
    pdsurf->dt      = DT_SCREEN;         // Not to be confused with a DIB DFB
    pdsurf->sizl.cx = ppdev->cxScreen;
    pdsurf->sizl.cy = ppdev->cyScreen;
    pdsurf->ppdev   = ppdev;

    /////////////////////////////////////////////////////////////////////
    // Next, have GDI create the actual SURFOBJ.
    //
    // Our drawing surface is going to be 'device-managed', meaning that
    // GDI cannot draw on the framebuffer bits directly, and as such we
    // create the surface via EngCreateDeviceSurface.  By doing this, we ensure
    // that GDI will only ever access the bitmaps bits via the Drv calls
    // that we've HOOKed.
    //
    // If we could map the entire framebuffer linearly into main memory
    // (i.e., we didn't have to go through a 64k aperture), it would be
    // beneficial to create the surface via EngCreateBitmap, giving GDI a
    // pointer to the framebuffer bits.  When we pass a call on to GDI
    // where it can't directly read/write to the surface bits because the
    // surface is device managed, it has to create a temporary bitmap and
    // call our DrvCopyBits routine to get/set a copy of the affected bits.
    // Fer example, the OpenGl component prefers to be able to write on the
    // framebuffer bits directly.

    sizl.cx = ppdev->cxScreen;
    sizl.cy = ppdev->cyScreen;

    hsurf = EngCreateDeviceSurface((DHSURF) pdsurf, sizl, ppdev->iBitmapFormat);
    if (hsurf == 0)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngCreateDeviceSurface"));
        goto ReturnFailure;
    }

    ppdev->hsurfScreen = hsurf;             // Remember it for clean-up
    ppdev->bEnabled = TRUE;                 // We'll soon be in graphics mode

    /////////////////////////////////////////////////////////////////////
    // Now associate the surface and the PDEV.
    //
    // We have to associate the surface we just created with our physical
    // device so that it works.
    //

    if (!EngAssociateSurface(hsurf, ppdev->hdevEng, ppdev->flHooks))
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAssociateSurface"));
        goto ReturnFailure;
    }

    // Create our generic temporary buffer, which may be used by any
    // component.  Because this may get swapped out of memory any time
    // the driver is not active, we want to minimize the number of pages
    // it takes up.  We use 'VirtualAlloc' to get an exactly page-aligned
    // allocation (which 'EngAllocMem' will not do):

    pvTmpBuffer = EngAllocMem(0, TMP_BUFFER_SIZE, ALLOC_TAG);
    if (pvTmpBuffer == NULL)
    {
        DISPDBG((0, "DrvEnableSurface - Failed EngAllocMem"));
        goto ReturnFailure;
    }

    ppdev->pvTmpBuffer = pvTmpBuffer;

    /////////////////////////////////////////////////////////////////////
    // Now enable all the subcomponents.
    //
    // Note that the order in which these 'Enable' functions are called
    // may be significant in low off-screen memory conditions, because
    // the off-screen heap manager may fail some of the later
    // allocations...

    // NOTE: It isn't until bEnableHardware that cyMemory is correctly set.

    if (!bEnableHardware(ppdev))
        goto ReturnFailure;

    if (!bEnableOffscreenHeap(ppdev))
        goto ReturnFailure;

    if (!bEnablePointer(ppdev))
        goto ReturnFailure;

    if (!bEnableText(ppdev))
        goto ReturnFailure;

    if (!bEnableBrushCache(ppdev))
        goto ReturnFailure;

    if (!bEnablePalette(ppdev))
        goto ReturnFailure;

    DISPDBG((5, "Passed DrvEnableSurface"));

    return(hsurf);

ReturnFailure:
    DrvDisableSurface((DHPDEV) ppdev);

    DISPDBG((0, "Failed DrvEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDisableSurface
*
* Free resources allocated by DrvEnableSurface.  Release the surface.
*
* Note: In an error case, we may call this before DrvEnableSurface is
*       completely done.
*
\**************************************************************************/

VOID DrvDisableSurface(
DHPDEV dhpdev)
{
    PDEV*   ppdev;

    ppdev = (PDEV*) dhpdev;

    // Note: In an error case, some of the following relies on the
    //       fact that the PDEV is zero-initialized, so fields like
    //       'hsurfScreen' will be zero unless the surface has been
    //       sucessfully initialized, and makes the assumption that
    //       EngDeleteSurface can take '0' as a parameter.

    vDisablePalette(ppdev);
    vDisableBrushCache(ppdev);
    vDisableText(ppdev);
    vDisablePointer(ppdev);
    vDisableOffscreenHeap(ppdev);
    vDisableHardware(ppdev);

    EngFreeMem(ppdev->pvTmpBuffer);
    EngDeleteSurface(ppdev->hsurfScreen);
    EngFreeMem(ppdev->pdsurfScreen);
}

/******************************Public*Routine******************************\
* VOID DrvAssertMode
*
* This asks the device to reset itself to the mode of the pdev passed in.
*
\**************************************************************************/

BOOL DrvAssertMode(
DHPDEV  dhpdev,
BOOL    bEnable)
{
    PDEV* ppdev;

    ppdev = (PDEV*) dhpdev;

    if (!bEnable)
    {
        //////////////////////////////////////////////////////////////
        // Disable - Switch to full-screen mode

        vAssertModePalette(ppdev, FALSE);

        vAssertModeBrushCache(ppdev, FALSE);

        vAssertModeText(ppdev, FALSE);

        vAssertModePointer(ppdev, FALSE);

        if (bAssertModeOffscreenHeap(ppdev, FALSE))
        {
            if (bAssertModeHardware(ppdev, FALSE))
            {
                ppdev->bEnabled = FALSE;

                return(TRUE);
            }

            //////////////////////////////////////////////////////////
            // We failed to switch to full-screen.  So undo everything:

            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
        }                                           //   return code with TRUE

        vAssertModePointer(ppdev, TRUE);

        vAssertModeText(ppdev, TRUE);

        vAssertModeBrushCache(ppdev, TRUE);

        vAssertModePalette(ppdev, TRUE);
    }
    else
    {
        //////////////////////////////////////////////////////////////
        // Enable - Switch back to graphics mode

        // We have to enable every subcomponent in the reverse order
        // in which it was disabled:

        if (bAssertModeHardware(ppdev, TRUE))
        {
            bAssertModeOffscreenHeap(ppdev, TRUE);  // We don't need to check
                                                    //   return code with TRUE
            vAssertModePointer(ppdev, TRUE);

            vAssertModeText(ppdev, TRUE);

            vAssertModeBrushCache(ppdev, TRUE);

            vAssertModePalette(ppdev, TRUE);

            ppdev->bEnabled = TRUE;

            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* ULONG DrvGetModes
*
* Returns the list of available modes for the device.
*
\**************************************************************************/

ULONG DrvGetModes(
HANDLE      hDriver,
ULONG       cjSize,
DEVMODEW*   pdm)
{

    DWORD cModes;
    DWORD cbOutputSize;
    PVIDEO_MODE_INFORMATION pVideoModeInformation;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD cOutputModes = cjSize / (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    DWORD cbModeSize;

    cModes = getAvailableModes(hDriver,
                            (PVIDEO_MODE_INFORMATION *) &pVideoModeInformation,
                            &cbModeSize);
    if (cModes == 0)
    {
        DISPDBG((0, "DrvGetModes failed to get mode information"));
        return(0);
    }

    if (pdm == NULL)
    {
        cbOutputSize = cModes * (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);
    }
    else
    {
        //
        // Now copy the information for the supported modes back into the
        // output buffer
        //

        cbOutputSize = 0;

        pVideoTemp = pVideoModeInformation;

        do
        {
            if (pVideoTemp->Length != 0)
            {
                if (cOutputModes == 0)
                {
                    break;
                }

                //
                // Zero the entire structure to start off with.
                //

                memset(pdm, 0, sizeof(DEVMODEW));

                //
                // Set the name of the device to the name of the DLL.
                //

                memcpy(pdm->dmDeviceName, DLL_NAME, sizeof(DLL_NAME));

                pdm->dmSpecVersion      = DM_SPECVERSION;
                pdm->dmDriverVersion    = DM_SPECVERSION;
                pdm->dmSize             = sizeof(DEVMODEW);
                pdm->dmDriverExtra      = DRIVER_EXTRA_SIZE;

                pdm->dmBitsPerPel       = pVideoTemp->NumberOfPlanes *
                                          pVideoTemp->BitsPerPlane;
                pdm->dmPelsWidth        = pVideoTemp->VisScreenWidth;
                pdm->dmPelsHeight       = pVideoTemp->VisScreenHeight;
                pdm->dmDisplayFrequency = pVideoTemp->Frequency;
                pdm->dmDisplayFlags     = 0;

                pdm->dmFields           = DM_BITSPERPEL       |
                                          DM_PELSWIDTH        |
                                          DM_PELSHEIGHT       |
                                          DM_DISPLAYFREQUENCY |
                                          DM_DISPLAYFLAGS     ;

                //
                // Go to the next DEVMODE entry in the buffer.
                //

                cOutputModes--;

                pdm = (LPDEVMODEW) ( ((ULONG)pdm) + sizeof(DEVMODEW) +
                                                   DRIVER_EXTRA_SIZE);

                cbOutputSize += (sizeof(DEVMODEW) + DRIVER_EXTRA_SIZE);

            }

            pVideoTemp = (PVIDEO_MODE_INFORMATION)
                (((PUCHAR)pVideoTemp) + cbModeSize);


        } while (--cModes);
    }

    EngFreeMem(pVideoModeInformation);

    return(cbOutputSize);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeHardware
*
* Sets the appropriate hardware state for graphics mode or full-screen.
*
\**************************************************************************/

BOOL bAssertModeHardware(
PDEV* ppdev,
BOOL  bEnable)
{
    DWORD ReturnedDataLength;
    ULONG ulReturn;

    if (bEnable)
    {
        // Call the miniport via an IOCTL to set the graphics mode.

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_CURRENT_MODE,
                             &ppdev->ulMode,  // input buffer
                             sizeof(DWORD),
                             NULL,
                             0,
                             &ReturnedDataLength))
        {
            DISPDBG((0, "bAssertModeHardware - Failed set IOCTL"));
            return FALSE;
        }

        // Then set the rest of the default registers:

        vResetClipping(ppdev);

        IO_FIFO_WAIT(ppdev, 1);
        IO_WRT_MASK(ppdev, -1);
    }
    else
    {
        // Call the kernel driver to reset the device to a known state.
        // NTVDM will take things from there:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_RESET_DEVICE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &ulReturn))
        {
            DISPDBG((0, "bAssertModeHardware - Failed reset IOCTL"));
            return FALSE;
        }
    }

    DISPDBG((5, "Passed bAssertModeHardware"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bAtiAccelerator
*
* Returns TRUE if we're running on a Mach8 or compatible accelerator.
* This algorithm was taken from "Programmer's Guide to the Mach-8 Extended
* Registers Supplement," 1992, ATI Technologies Inc, p. 5-2.
*
* It seems like a pretty goofy test to me, but it's what they prescribe
* to 'specifically detect an ATI accelerator product.'
*
\**************************************************************************/

BOOL bAtiAccelerator(
PDEV*   ppdev)
{
    ULONG   ulSave;
    BOOL    bAti;

    bAti = FALSE;

    ulSave = INPW(0x52ee);

    OUTPW(0x52ee, 0x5555);
    IO_GP_WAIT(ppdev);
    if (INPW(0x52ee) == 0x5555)
    {
        OUTPW(0x52ee, 0x2a2a);
        IO_GP_WAIT(ppdev);
        if (INPW(0x52ee) == 0x2a2a)
        {
            bAti = TRUE;
        }
    }

    // Restore the register's original contents:

    OUTPW(0x52ee, ulSave);

    return(bAti);
}

/******************************Public*Routine******************************\
* BOOL bEnableHardware
*
* Puts the hardware in the requested mode and initializes it.  Also
* sets ppdev->cyMemory.
*
\**************************************************************************/

BOOL bEnableHardware(
PDEV*   ppdev)
{
    VIDEO_MEMORY             VideoMemory;
    VIDEO_MEMORY_INFORMATION VideoMemoryInfo;
    DWORD                    ReturnedDataLength;

    // Set all the register addresses (to allow easier porting of code
    // from the S3):

    ppdev->ioCur_y              = CUR_Y;
    ppdev->ioCur_x              = CUR_X;
    ppdev->ioDesty_axstp        = DEST_Y;
    ppdev->ioDestx_diastp       = DEST_X;
    ppdev->ioErr_term           = ERR_TERM;
    ppdev->ioMaj_axis_pcnt      = MAJ_AXIS_PCNT;
    ppdev->ioGp_stat_cmd        = CMD;
    ppdev->ioShort_stroke       = SHORT_STROKE;
    ppdev->ioBkgd_color         = BKGD_COLOR;
    ppdev->ioFrgd_color         = FRGD_COLOR;
    ppdev->ioWrt_mask           = WRT_MASK;
    ppdev->ioRd_mask            = RD_MASK;
    ppdev->ioColor_cmp          = COLOR_CMP;
    ppdev->ioBkgd_mix           = BKGD_MIX;
    ppdev->ioFrgd_mix           = FRGD_MIX;
    ppdev->ioMulti_function     = MULTIFUNC_CNTL;
    ppdev->ioPix_trans          = PIX_TRANS;

    // Now we can set the mode, unlock the accelerator, and reset the
    // clipping:

    if (!bAssertModeHardware(ppdev, TRUE))
        goto ReturnFalse;

    // Get the linear memory address range.

    VideoMemory.RequestedVirtualAddress = NULL;

    // About this IOCTL_VIDEO_MAP_VIDEO_MEMORY call.
    //
    // Since we're an 8514/A driver, we don't care squat about any stinking
    // frame buffer mapping.  The only reason we're calling this IOCTL
    // is because we may be running as an 8514/A using the ATI miniport.
    // And this IOCTL is the only way to get the ATI miniport to return
    // the total number of scans of video memory.  'cyMemory' is needed
    // so we can take advantage of as much off-screen memory as possible
    // for the 2-d heap.  It's also conceivable that we're running at
    // 640x480x256 using the ATI miniport on a 512k card, in which case
    // we can't just assume that 'cyMemory' was 1024.
    //
    // So all we're interested in is the 'VideoRamLength' field returned
    // in 'VideoMemoryInfo'.  Currently, any other side effects of
    // making this call with the ATI miniport (such as the actual memory
    // mapping) are inoccuous, and hopefully this will remain to be so in
    // future ATI miniports.
    //
    // If we're running with the 8514/A miniport, this call does nothing
    // but return 1 meg for the 'FrameLength' size:

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MAP_VIDEO_MEMORY,
                         &VideoMemory,      // input buffer
                         sizeof(VIDEO_MEMORY),
                         &VideoMemoryInfo,  // output buffer
                         sizeof(VideoMemoryInfo),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnableHardware - Error mapping buffer address"));
        goto ReturnFalse;
    }

    // All we were interested in is 'VideoMemoryInfo', so unmap the buffer
    // straight away:

    VideoMemory.RequestedVirtualAddress = VideoMemoryInfo.FrameBufferBase;

    EngDeviceIoControl(ppdev->hDriver,
                    IOCTL_VIDEO_UNMAP_VIDEO_MEMORY,
                    &VideoMemory,
                    sizeof(VIDEO_MEMORY),
                    NULL,
                    0,
                    &ReturnedDataLength);

    // Note that 8514/A registers cannot handle coordinates any larger
    // than 1535:

    ppdev->cyMemory = VideoMemoryInfo.VideoRamLength / ppdev->lDelta;
    ppdev->cyMemory = min(ppdev->cyMemory, 1535);

    DISPDBG((0, "Memory size %li x %li.", ppdev->cxMemory, ppdev->cyMemory));

    // Set up the jump vectors to our low-level blt routines (which ones are
    // used depends on whether we can do memory-mapped IO or not):

    // Have to do IN/OUTs:

    ppdev->pfnFillSolid     = vIoFillSolid;
    ppdev->pfnFillPat       = vIoFillPatSlow;

    ppdev->pfnXfer4bpp      = vIoXfer4bpp;
    ppdev->pfnXferNative    = vIoXferNative;
    ppdev->pfnCopyBlt       = vIoCopyBlt;
    ppdev->pfnFastLine      = vIoFastLine;
    ppdev->pfnFastFill      = bIoFastFill;

    if (!bAtiAccelerator(ppdev))
    {
        ppdev->pfnXfer1bpp  = vIoXfer1bpp;
    }
    else
    {
        DISPDBG((0, "ATI extensions enabled."));

        // Disable vIoMaskCopy() for fixing bug 143531.

//        ppdev->flCaps |= CAPS_MASKBLT_CAPABLE;

        ppdev->pfnMaskCopy  = vIoMaskCopy;
        ppdev->pfnXfer1bpp  = vIoXfer1bppPacked;
    }

    DISPDBG((5, "Passed bEnableHardware"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableHardware"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableHardware
*
* Undoes anything done in bEnableHardware.
*
* Note: In an error case, we may call this before bEnableHardware is
*       completely done.
*
\**************************************************************************/

VOID vDisableHardware(
PDEV*   ppdev)
{
}

/******************************Public*Routine******************************\
* BOOL bDetect8514A
*
* Detects whether or not an 8514/A compatible adapter is present.
*
* This code was stolen from the 8514/A miniport.  It simply checks to see
* if the line-drawing error term register is readable/writable.
*
\**************************************************************************/

BOOL bDetect8514A()
{
    USHORT SubSysCntlRegisterValue;
    USHORT ErrTermRegisterValue;
    USHORT ErrTerm5555;
    USHORT ErrTermAAAA;
    BOOL   b8514A;

    //
    // Remember the original value of any registers we'll muck with.
    //

    SubSysCntlRegisterValue = INPW(SUBSYS_CNTL);
    ErrTermRegisterValue = INPW(ERR_TERM);

    //
    // Reset the draw engine.
    //

    OUTPW(SUBSYS_CNTL, 0x9000);
    OUTPW(SUBSYS_CNTL, 0x5000);

    //
    // We detect an 8514/A by writing a value to the error term register,
    // and reading it back to see if it's the same value we wrote.
    //

    OUTPW(ERR_TERM, 0x5555);
    ErrTerm5555 = INPW(ERR_TERM);

    OUTPW(ERR_TERM, 0xAAAA);
    ErrTermAAAA = INPW(ERR_TERM);

    b8514A = ((ErrTerm5555 == 0x5555) && (ErrTermAAAA == 0xAAAA));

    //
    // Now that we're done mucking with the hardware state, we have to
    // restore everything to the way it was.
    //

    OUTPW(ERR_TERM, ErrTermRegisterValue);

    //
    // Since the SUBSYS_CNTL register is not readable on a true 8514/A,
    // don't try to restore it:
    //

    if (!b8514A)
    {
        OUTPW(SUBSYS_CNTL, SubSysCntlRegisterValue);
    }

    return(b8514A);
}

/******************************Public*Routine******************************\
* BOOL bInitializeModeFields
*
* Initializes a bunch of fields in the pdev, devcaps (aka gdiinfo), and
* devinfo based on the requested mode.
*
\**************************************************************************/

BOOL bInitializeModeFields(
PDEV*     ppdev,
GDIINFO*  pgdi,
DEVINFO*  pdi,
DEVMODEW* pdm)
{
    ULONG                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoModeSelected;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    BOOL                    bSelectDefault;
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   cbModeSize;

    // Verify that we have an 8514/A display.  We do this because we can
    // work with the ATI miniport, which supports some cards (notably the
    // Mach64) that aren't 8514/A compatible.

    if (!bDetect8514A())
    {
        DISPDBG((0, "bInitializeModeFields - 8514/A not detected"));
        goto ReturnFalse;
    }

    // Call the miniport to get mode information

    cModes = getAvailableModes(ppdev->hDriver, &pVideoBuffer, &cbModeSize);
    if (cModes == 0)
        goto ReturnFalse;

    // Now see if the requested mode has a match in that table.

    pVideoModeSelected = NULL;
    pVideoTemp = pVideoBuffer;

    if ((pdm->dmPelsWidth        == 0) &&
        (pdm->dmPelsHeight       == 0) &&
        (pdm->dmBitsPerPel       == 0) &&
        (pdm->dmDisplayFrequency == 0))
    {
        DISPDBG((1, "Default mode requested"));
        bSelectDefault = TRUE;
    }
    else
    {
        DISPDBG((1, "Requested mode..."));
        DISPDBG((1, "   Screen width  -- %li", pdm->dmPelsWidth));
        DISPDBG((1, "   Screen height -- %li", pdm->dmPelsHeight));
        DISPDBG((1, "   Bits per pel  -- %li", pdm->dmBitsPerPel));
        DISPDBG((1, "   Frequency     -- %li", pdm->dmDisplayFrequency));

        bSelectDefault = FALSE;
    }

    while (cModes--)
    {
        if (pVideoTemp->Length != 0)
        {
            DISPDBG((2, "   Checking against miniport mode:"));
            DISPDBG((2, "      Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "      Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "      Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                      pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "      Frequency     -- %li", pVideoTemp->Frequency));

            if (bSelectDefault ||
                ((pVideoTemp->VisScreenWidth  == pdm->dmPelsWidth) &&
                 (pVideoTemp->VisScreenHeight == pdm->dmPelsHeight) &&
                 (pVideoTemp->BitsPerPlane *
                  pVideoTemp->NumberOfPlanes  == pdm->dmBitsPerPel) &&
                 (pVideoTemp->Frequency       == pdm->dmDisplayFrequency)))
            {
                pVideoModeSelected = pVideoTemp;
                DISPDBG((1, "...Found a mode match!"));
                break;
            }
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + cbModeSize);

    }

    // If no mode has been found, return an error

    if (pVideoModeSelected == NULL)
    {
        DISPDBG((1, "...Couldn't find a mode match!"));
        EngFreeMem(pVideoBuffer);
        goto ReturnFalse;
    }

    // We have chosen the one we want.  Save it in a stack buffer and
    // get rid of allocated memory before we forget to free it.

    VideoModeInformation = *pVideoModeSelected;
    EngFreeMem(pVideoBuffer);

    #if DEBUG_HEAP
        VideoModeInformation.VisScreenWidth  = 640;
        VideoModeInformation.VisScreenHeight = 480;
    #endif

    // Set up screen information from the mini-port:

    ppdev->ulMode           = VideoModeInformation.ModeIndex;
    ppdev->cxScreen         = VideoModeInformation.VisScreenWidth;
    ppdev->cyScreen         = VideoModeInformation.VisScreenHeight;
    ppdev->lDelta           = VideoModeInformation.ScreenStride;
    ppdev->flCaps           = 0;    // We've have no capabilities

    // Note that 8514/A registers cannot handle coordinates any larger
    // than 1535:

    ppdev->cxMemory         = min(VideoModeInformation.ScreenStride, 1535);

    // Note: We compute 'cyMemory' later at DrvEnableSurface time.  For now,
    //       set cyMemory to an interesting value to aid in debugging:

    ppdev->cyMemory         = 0xdeadbeef;

    DISPDBG((1, "ScreenStride: %lx", VideoModeInformation.ScreenStride));

    ppdev->flHooks          = (HOOK_BITBLT     |
                               HOOK_TEXTOUT    |
                               HOOK_FILLPATH   |
                               HOOK_COPYBITS   |
                               HOOK_STROKEPATH |
                               HOOK_PAINT      |
                               HOOK_STRETCHBLT);

    // Fill in the GDIINFO data structure with the default 8bpp values:

    *pgdi = ggdiDefault;

    // Now overwrite the defaults with the relevant information returned
    // from the kernel driver:

    pgdi->ulHorzSize        = VideoModeInformation.XMillimeter;
    pgdi->ulVertSize        = VideoModeInformation.YMillimeter;

    pgdi->ulHorzRes         = VideoModeInformation.VisScreenWidth;
    pgdi->ulVertRes         = VideoModeInformation.VisScreenHeight;
    pgdi->ulPanningHorzRes  = VideoModeInformation.VisScreenWidth;
    pgdi->ulPanningVertRes  = VideoModeInformation.VisScreenHeight;

    pgdi->cBitsPixel        = VideoModeInformation.BitsPerPlane;
    pgdi->cPlanes           = VideoModeInformation.NumberOfPlanes;
    pgdi->ulVRefresh        = VideoModeInformation.Frequency;

    pgdi->ulDACRed          = VideoModeInformation.NumberRedBits;
    pgdi->ulDACGreen        = VideoModeInformation.NumberGreenBits;
    pgdi->ulDACBlue         = VideoModeInformation.NumberBlueBits;

    pgdi->ulLogPixelsX      = pdm->dmLogPixels;
    pgdi->ulLogPixelsY      = pdm->dmLogPixels;

    // Fill in the devinfo structure with the default 8bpp values:

    *pdi = gdevinfoDefault;

    ppdev->cPelSize        = 0;
    ppdev->iBitmapFormat   = BMF_8BPP;
    ppdev->ulWhite         = 0xff;

    // Assuming palette is orthogonal - all colors are same size.

    ppdev->cPaletteShift   = 8 - pgdi->ulDACRed;

    DISPDBG((5, "Passed bInitializeModeFields"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializeModeFields"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DWORD getAvailableModes
*
* Calls the miniport to get the list of modes supported by the kernel driver,
* and returns the list of modes supported by the diplay driver among those
*
* returns the number of entries in the videomode buffer.
* 0 means no modes are supported by the miniport or that an error occured.
*
* NOTE: the buffer must be freed up by the caller.
*
\**************************************************************************/

DWORD getAvailableModes(
HANDLE                   hDriver,
PVIDEO_MODE_INFORMATION* modeInformation,
DWORD*                   cbModeSize)
{
    ULONG                   ulTemp;
    VIDEO_NUM_MODES         modes;
    PVIDEO_MODE_INFORMATION pVideoTemp;

    //
    // Get the number of modes supported by the mini-port
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES,
            NULL,
            0,
            &modes,
            sizeof(VIDEO_NUM_MODES),
            &ulTemp))
    {
        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_NUM_AVAIL_MODES"));
        return(0);
    }

    *cbModeSize = modes.ModeInformationLength;

    //
    // Allocate the buffer for the mini-port to write the modes in.
    //

    *modeInformation = (PVIDEO_MODE_INFORMATION)
                        EngAllocMem(FL_ZERO_MEMORY,
                                   modes.NumModes *
                                   modes.ModeInformationLength, ALLOC_TAG);

    if (*modeInformation == (PVIDEO_MODE_INFORMATION) NULL)
    {
        DISPDBG((0, "getAvailableModes - Failed EngAllocMem"));
        return 0;
    }

    //
    // Ask the mini-port to fill in the available modes.
    //

    if (EngDeviceIoControl(hDriver,
            IOCTL_VIDEO_QUERY_AVAIL_MODES,
            NULL,
            0,
            *modeInformation,
            modes.NumModes * modes.ModeInformationLength,
            &ulTemp))
    {

        DISPDBG((0, "getAvailableModes - Failed VIDEO_QUERY_AVAIL_MODES"));

        EngFreeMem(*modeInformation);
        *modeInformation = (PVIDEO_MODE_INFORMATION) NULL;

        return(0);
    }

    //
    // Now see which of these modes are supported by the display driver.
    // As an internal mechanism, set the length to 0 for the modes we
    // DO NOT support.
    //

    ulTemp = modes.NumModes;
    pVideoTemp = *modeInformation;

    //
    // Mode is rejected if it is not one plane, or not graphics, or is not
    // 8 bits per pel.
    //

    while (ulTemp--)
    {
        if ((pVideoTemp->NumberOfPlanes != 1 ) ||
            !(pVideoTemp->AttributeFlags & VIDEO_MODE_GRAPHICS) ||
             (pVideoTemp->BitsPerPlane != 8))
        {
            DISPDBG((2, "Rejecting miniport mode:"));
            DISPDBG((2, "   Screen width  -- %li", pVideoTemp->VisScreenWidth));
            DISPDBG((2, "   Screen height -- %li", pVideoTemp->VisScreenHeight));
            DISPDBG((2, "   Bits per pel  -- %li", pVideoTemp->BitsPerPlane *
                                                   pVideoTemp->NumberOfPlanes));
            DISPDBG((2, "   Frequency     -- %li", pVideoTemp->Frequency));

            pVideoTemp->Length = 0;
        }

        pVideoTemp = (PVIDEO_MODE_INFORMATION)
            (((PUCHAR)pVideoTemp) + modes.ModeInformationLength);
    }

    return(modes.NumModes);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\intline.c ===
/*************************************************************************\
* Module Name: intline.c
*
* Copyright (c) 1993-1994 Microsoft Corporation
* Copyright (c) 1992      Digital Equipment Corporation
\**************************************************************************/

#include "precomp.h"

#define DEFAULT_DRAW_CMD	DRAW_LINE | \
                                DRAW | \
                                DIR_TYPE_XY | \
                                MULTIPLE_PIXELS | \
                                WRITE | \
                                LAST_PIXEL_OFF

/******************************************************************************
 * bIntegerLine
 *
 * This routine attempts to draw a line segment between two points. It
 * will only draw if both end points are whole integers: it does not support
 * fractional endpoints.
 *
 * Returns:
 *   TRUE     if the line segment is drawn
 *   FALSE    otherwise
 *****************************************************************************/

BOOL
bIntegerLine (
PDEV*     ppdev,
ULONG	X1,
ULONG	Y1,
ULONG	X2,
ULONG	Y2
)
{
    LONG		Cmd;
    LONG		DeltaX, DeltaY;
    LONG		ErrorTerm;
    LONG		Major, Minor;

    X1 >>= 4;
    Y1 >>= 4;
    X2 >>= 4;
    Y2 >>= 4;

    Cmd = DEFAULT_DRAW_CMD | PLUS_Y | PLUS_X | MAJOR_Y;

    DeltaX = X2 - X1;
    if (DeltaX < 0) {
        DeltaX = -DeltaX;
        Cmd &= ~PLUS_X;
    }
    DeltaY = Y2 - Y1;
    if (DeltaY < 0) {
        DeltaY = -DeltaY;
        Cmd &= ~PLUS_Y;
    }

    // Compute the major drawing axis

    if (DeltaX > DeltaY) {
        Cmd &= ~MAJOR_Y;
        Major = DeltaX;
        Minor = DeltaY;
    } else {
        Major = DeltaY;
        Minor = DeltaX;
    }


    // Tell the S3 to draw the line

    IO_FIFO_WAIT (ppdev, 7);
    IO_CUR_X (ppdev, X1);
    IO_CUR_Y (ppdev, Y1);
    IO_MAJ_AXIS_PCNT (ppdev, Major);
    IO_AXSTP (ppdev, Minor * 2);
    IO_DIASTP (ppdev, 2 * Minor - 2 * Major);

    // Adjust the error term so that 1/2 always rounds down, to
    // conform with GIQ.

    ErrorTerm = 2 * Minor - Major;
    if (Cmd & MAJOR_Y) {
        if (Cmd & PLUS_X) {
            ErrorTerm--;
        }
    } else {
        if (Cmd & PLUS_Y) {
            ErrorTerm--;
        }
    }

    IO_ERR_TERM (ppdev, ErrorTerm);
    IO_CMD (ppdev, Cmd);

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\paint.c ===
/******************************Module*Header*******************************\
* Module Name: paint.c
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Data*********************************\
* MIX translation table
*
* Translates a mix 1-16, into an old style Rop 0-255.
*
\**************************************************************************/

BYTE gaMix[] =
{
    0xFF,  // R2_WHITE        - Allow rop = gaMix[mix & 0x0F]
    0x00,  // R2_BLACK
    0x05,  // R2_NOTMERGEPEN
    0x0A,  // R2_MASKNOTPEN
    0x0F,  // R2_NOTCOPYPEN
    0x50,  // R2_MASKPENNOT
    0x55,  // R2_NOT
    0x5A,  // R2_XORPEN
    0x5F,  // R2_NOTMASKPEN
    0xA0,  // R2_MASKPEN
    0xA5,  // R2_NOTXORPEN
    0xAA,  // R2_NOP
    0xAF,  // R2_MERGENOTPEN
    0xF0,  // R2_COPYPEN
    0xF5,  // R2_MERGEPENNOT
    0xFA,  // R2_MERGEPEN
    0xFF   // R2_WHITE        - Allow rop = gaMix[mix & 0xFF]
};

/******************************Public*Routine******************************\
* BOOL DrvPaint
*
\**************************************************************************/

BOOL DrvPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    ROP4 rop4;

    rop4 = ((MIX) gaMix[mix >> 8] << 8) | gaMix[mix & 0xf];

    // Since our DrvFillPath routine handles almost all fills, DrvPaint
    // won't get called all that much (mainly via PaintRgn, FillRgn, or
    // complex clipped polygons).  As such, we save some code and simply
    // punt to DrvBitBlt:

    return(DrvBitBlt(pso, NULL, NULL, pco, NULL, &pco->rclBounds, NULL,
                     NULL, pbo, pptlBrush, rop4));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\hw.h ===
/******************************Module*Header*******************************\
* Module Name: hw.h
*
* All the hardware specific driver file stuff.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

////////////////////////////////////////////////////////////////////////
// Chip equates:

#define STATUS_1                        0x3DA
#define VSY_NOT                         0x08

#define CRTC_INDEX                      0x3D4
#define CRTC_DATA                       0x3D5

// Command types:

#define DRAW_LINE                       0x2000
#define RECTANGLE_FILL                  0x4000
#define BITBLT                          0xC000
#define PATTERN_FILL                    0xE000

#define BYTE_SWAP                       0x1000
#define BUS_SIZE_16                     0x0200
#define BUS_SIZE_8                      0x0000
#define WAIT                            0x0100

// Drawing directions (radial):

#define DRAWING_DIRECTION_0             0x0000
#define DRAWING_DIRECTION_45            0x0020
#define DRAWING_DIRECTION_90            0x0040
#define DRAWING_DIRECTION_135           0x0060
#define DRAWING_DIRECTION_180           0x0080
#define DRAWING_DIRECTION_225           0x00A0
#define DRAWING_DIRECTION_270           0x00C0
#define DRAWING_DIRECTION_315           0x00E0

// Drawing directions (x/y):

#define DRAWING_DIR_BTRLXM              0x0000
#define DRAWING_DIR_BTLRXM              0x0020
#define DRAWING_DIR_BTRLYM              0x0040
#define DRAWING_DIR_BTLRYM              0x0060
#define DRAWING_DIR_TBRLXM              0x0080
#define DRAWING_DIR_TBLRXM              0x00A0
#define DRAWING_DIR_TBRLYM              0x00C0
#define DRAWING_DIR_TBLRYM              0x00E0

// Drawing direction bits:

#define PLUS_X                          0x0020
#define PLUS_Y                          0x0080
#define MAJOR_Y                         0x0040

// Draw:

#define DRAW                            0x0010

// Direction type:

#define DIR_TYPE_RADIAL                 0x0008
#define DIR_TYPE_XY                     0x0000

// Last pixel:

#define LAST_PIXEL_OFF                  0x0004
#define LAST_PIXEL_ON                   0x0000

// Pixel mode:

#define MULTIPLE_PIXELS                 0x0002
#define SINGLE_PIXEL                    0x0000

// Read/write:

#define READ                            0x0000
#define WRITE                           0x0001

// Graphics processor status:

#define HARDWARE_BUSY                   0x200
#define READ_DATA_AVAILABLE             0x100

// Fifo status in terms of empty entries:

#define FIFO_1_EMPTY                    0x080
#define FIFO_2_EMPTY                    0x040
#define FIFO_3_EMPTY                    0x020
#define FIFO_4_EMPTY                    0x010
#define FIFO_5_EMPTY                    0x008
#define FIFO_6_EMPTY                    0x004
#define FIFO_7_EMPTY                    0x002
#define FIFO_8_EMPTY                    0x001

// These are the defines for the multifunction control register.
// The 4 MSBs define the function of the register.

#define RECT_HEIGHT                     0x0000

#define CLIP_TOP                        0x1000
#define CLIP_LEFT                       0x2000
#define CLIP_BOTTOM                     0x3000
#define CLIP_RIGHT                      0x4000

#define DATA_EXTENSION                  0xA000
#define MULT_MISC_INDEX                 0xE000
#define READ_SEL_INDEX                  0xF000

#define ALL_ONES                        0x0000
#define CPU_DATA                        0x0080
#define DISPLAY_MEMORY                  0x00C0

// Colour source:

#define BACKGROUND_COLOR                0x00
#define FOREGROUND_COLOR                0x20
#define SRC_CPU_DATA                    0x40
#define SRC_DISPLAY_MEMORY              0x60

// Mix modes:

#define NOT_SCREEN                      0x00
#define LOGICAL_0                       0x01
#define LOGICAL_1                       0x02
#define LEAVE_ALONE                     0x03
#define NOT_NEW                         0x04
#define SCREEN_XOR_NEW                  0x05
#define NOT_SCREEN_XOR_NEW              0x06
#define OVERPAINT                       0x07
#define NOT_SCREEN_OR_NOT_NEW           0x08
#define SCREEN_OR_NOT_NEW               0x09
#define NOT_SCREEN_OR_NEW               0x0A
#define SCREEN_OR_NEW                   0x0B
#define SCREEN_AND_NEW                  0x0C
#define NOT_SCREEN_AND_NEW              0x0D
#define SCREEN_AND_NOT_NEW              0x0E
#define NOT_SCREEN_AND_NOT_NEW          0x0F

// When one of the following bits is set in a hardware mix, it means
// that a pattern is needed (i.e., is none of NOT_SCREEN, LOGICAL_0,
// LOGICAL_1 or LEAVE_ALONE):

#define MIX_NEEDSPATTERN                0x0C

////////////////////////////////////////////////////////////////////
// 8514/A port control
////////////////////////////////////////////////////////////////////

// Accelerator port addresses:

#define SUBSYS_CNTL                     0x42E8
#define CUR_Y                           0x82E8
#define CUR_X                           0x86E8
#define DEST_Y                          0x8AE8
#define DEST_X                          0x8EE8
#define AXSTP                           0x8AE8
#define DIASTP                          0x8EE8
#define ERR_TERM                        0x92E8
#define MAJ_AXIS_PCNT                   0x96E8
#define CMD                             0x9AE8
#define SHORT_STROKE                    0x9EE8
#define BKGD_COLOR                      0xA2E8
#define FRGD_COLOR                      0xA6E8
#define WRT_MASK                        0xAAE8
#define RD_MASK                         0xAEE8
#define COLOR_CMP                       0xB2E8
#define BKGD_MIX                        0xB6E8
#define FRGD_MIX                        0xBAE8
#define MULTIFUNC_CNTL                  0xBEE8
#define MIN_AXIS_PCNT                   0xBEE8
#define SCISSORS_T                      0xBEE8
#define SCISSORS_L                      0xBEE8
#define SCISSORS_B                      0xBEE8
#define SCISSORS_R                      0xBEE8
#define PIX_CNTL                        0xBEE8
#define PIX_TRANS                       0xE2E8

////////////////////////////////////////////////////////////////////
// Macros for accessing accelerator registers:

#if defined(i386)

    /////////////////////////////////////////////////////////////////////////
    // x86

    // Note: Don't cast (x) to a USHORT or compiler optimizations will
    //       be lost (the x86 compiler will convert any argument expressions
    //       to word operations, which will incur a one byte/one cycle
    //       size/performance hit from the resulting 0x66 size prefixes).

    #define OUTPW(p, x)          WRITE_PORT_USHORT((p), (x))
    #define OUTP(p, x)           WRITE_PORT_UCHAR((p), (x))
    #define INPW(p)              READ_PORT_USHORT(p)
    #define INP(p)               READ_PORT_UCHAR(p)

    #define IN_WORD(p)           INPW(p)
    #define OUT_WORD(p, v)       OUTPW((p), (v))

    // Our x86 C compiler was insisting on turning any expression
    // arguments into word operations -- e.g., WRITE_WORD(x + xOffset)
    // where both 'x' and 'xOffset' were dwords would get converted to
    // a word add operation before the word was written to memory.  With a
    // 32-bit segment, every word operation costs us a byte in size and a
    // cycle in performance.
    //
    // The following expression was the only one I could find that gave me
    // the asm I was looking for -- the only word operation is the final
    // word write to memory.

    #define WRITE_WORD(address, x)                                  \
    {                                                               \
        LONG l = (LONG) x;                                          \
        WRITE_REGISTER_USHORT((address), (USHORT) (l));             \
    }

#else

    /////////////////////////////////////////////////////////////////////////
    // Alpha and Mips
    //
    // The code makes extensive use of the inp, inpw, outp and outpw x86
    // intrinsic functions. Since these don't exist on the Alpha platform,
    // map them into something we can handle.  Since the CSRs are mapped
    // on Alpha, we have to add the register base to the register number
    // passed in the source.

    extern UCHAR* gpucCsrBase;

    #define INP(p)               READ_PORT_UCHAR(gpucCsrBase + (p))
    #define INPW(p)              READ_PORT_USHORT(gpucCsrBase + (p))
    #define OUTP(p,v )           WRITE_PORT_UCHAR(gpucCsrBase + (p), (v))
    #define OUTPW(p, v)          WRITE_PORT_USHORT(gpucCsrBase + (p), (v))

    // OUT_WORD is a quick OUT routine where we can explicitly handle
    // MEMORY_BARRIERs ourselves.  It is best to use OUTPW for non-critical
    // code, because it's easy to overwrite the IO cache when MEMORY_BARRIERs
    // aren't bracketing everything.  Note that the IO_ routines provide
    // the necessary abstraction so that you don't usually have to think
    // about memory barriers.

    #define OUT_WORD(p, v)       WRITE_REGISTER_USHORT(gpucCsrBase + (p), (USHORT) (v))
    #define IN_WORD(p)           READ_PORT_USHORT(gpucCsrBase + (p))
    #define WRITE_WORD(p, v)     // Shouldn't be using this on non-x86

    // We redefine 'inp', 'inpw', 'outp' and 'outpw' just in case someone
    // forgets to use the capitalized versions (so that it still works on
    // the Mips/Alpha):

    #define inp(p)               INP(p)
    #define inpw(p)              INPW(p)
    #define outp(p, v)           OUTP((p), (v))
    #define outpw(p, v)          OUTPW((p), (v))

#endif

#define OUT_DWORD(p, x)         // 8514/a doesn't do 32bpp
#define WRITE_DWORD(p, x)       // 8514/a doesn't do 32bpp

// DEPTH32(ppdev) returns TRUE if running at 32bpp, meaning that DEPTH32
// macros must be used, and returns FALSE if running at 8 or 16bpp,
// meaning that DEPTH macros must be used:

#define DEPTH32(ppdev)      (FALSE)

#define MM_BKGD_COLOR32(ppdev, pjMmBase, x)     // Not used
#define MM_FRGD_COLOR32(ppdev, pjMmBase, x)     // Not used
#define MM_WRT_MASK32(ppdev, pjMmBase, x)       // Not used
#define MM_RD_MASK32(ppdev, pjMmBase, x)        // Not used
#define MM_FRGD_MIX(ppdev, pjMmBase, x)         // Not used
#define MM_BKGD_MIX(ppdev, pjMmBase, x)         // Not used

#if DBG

    /////////////////////////////////////////////////////////////////////////
    // Checked Build
    //
    // We hook some of the accelerator macros on checked (debug) builds
    // for sanity checking.

    VOID vOutAccel(ULONG, ULONG);
    VOID vOutDepth(PDEV*, ULONG, ULONG);
    VOID vOutDepth32(PDEV*, ULONG, ULONG);
    VOID vWriteAccel(VOID*, ULONG);
    VOID vWriteDepth(PDEV*, VOID*, ULONG);
    VOID vWriteDepth32(PDEV*, VOID*, ULONG);

    VOID vFifoWait(PDEV*, LONG);
    VOID vGpWait(PDEV*);

    VOID vCheckDataReady(PDEV*);
    VOID vCheckDataComplete(PDEV*);

    #define IN_ACCEL(p)                 IN_WORD(p)
    #define OUT_ACCEL(p, v)             vOutAccel((p), (ULONG) (v))
    #define OUT_DEPTH(ppdev, p, v)      vOutDepth((ppdev), (p), (ULONG) (v))
    #define OUT_DEPTH32(ppdev, p, v)    vOutDepth32((ppdev), (p), (ULONG) (v))
    #define WRITE_ACCEL(p, v)           vWriteAccel((p), (ULONG) (v))
    #define WRITE_DEPTH(ppdev, p, v)    vWriteDepth((ppdev), (p), (ULONG) (v))
    #define WRITE_DEPTH32(ppdev, p, v)  vWriteDepth32((ppdev), (p), (ULONG) (v))

    #define IO_FIFO_WAIT(ppdev, level)  vFifoWait((ppdev), (level))
    #define IO_GP_WAIT(ppdev)           vGpWait(ppdev)

    #define CHECK_DATA_READY(ppdev)     vCheckDataReady(ppdev)
    #define CHECK_DATA_COMPLETE(ppdev)  vCheckDataComplete(ppdev)

#else

    /////////////////////////////////////////////////////////////////////////
    // Free Build
    //
    // For a free (non-debug build), we make everything in-line.

    #define IN_ACCEL(p)                 IN_WORD(p)
    #define OUT_ACCEL(p, v)             OUT_WORD((p), (v))
    #define OUT_DEPTH(ppdev, p, x)      OUT_WORD((p), (x))
    #define OUT_DEPTH32(ppdev, p, x)    OUT_DWORD((p), (x))
    #define WRITE_ACCEL(p, v)           WRITE_WORD((p), (v))
    #define WRITE_DEPTH(ppdev, p, x)    WRITE_WORD((p), (x))
    #define WRITE_DEPTH32(ppdev, p, x)  WRITE_DWORD((p), (x))

    #define IO_FIFO_WAIT(ppdev, level)          \
        while (IO_GP_STAT(ppdev) & ((FIFO_1_EMPTY << 1) >> (level)));

    #define IO_GP_WAIT(ppdev)                   \
        while (IO_GP_STAT(ppdev) & HARDWARE_BUSY);

    #define CHECK_DATA_READY(ppdev)     // Expands to nothing
    #define CHECK_DATA_COMPLETE(ppdev)  // Expands to nothing

#endif

// IO_TEST_WAIT is a useful replacement to IO_FIFO_WAIT that can give
// some indication of how often we have to wait for the hardware to
// finish drawing in key areas:

#define IO_TEST_WAIT(ppdev, level, cTotal, cWait)               \
{                                                               \
    cTotal++;                                                   \
    if (IO_GP_STAT(ppdev) & ((FIFO_1_EMPTY << 1) >> (level)))   \
    {                                                           \
        cWait++;                                                \
        IO_FIFO_WAIT(ppdev, level);                             \
    }                                                           \
}

////////////////////////////////////////////////////////////////////
// Port access using I/O

// The following are ABSOLUTE positioning macros.  They do NOT take
// the surface's offset into account (for off-screen device-format
// bitmaps):

#define IO_ABS_CUR_Y(ppdev, y)              \
    OUT_ACCEL(CUR_Y, (y))

#define IO_ABS_CUR_X(ppdev, x)              \
    OUT_ACCEL(CUR_X, (x))

#define IO_ABS_DEST_Y(ppdev, y)             \
    OUT_ACCEL(DEST_Y, (y))

#define IO_ABS_DEST_X(ppdev, x)             \
    OUT_ACCEL(DEST_X, (x))

#define IO_ABS_SCISSORS_T(ppdev, y)         \
{                                           \
    OUT_ACCEL(SCISSORS_T, (y) | CLIP_TOP);  \
}

#define IO_ABS_SCISSORS_L(ppdev, x)         \
{                                           \
    OUT_ACCEL(SCISSORS_L, (x) | CLIP_LEFT); \
}

#define IO_ABS_SCISSORS_B(ppdev, y)         \
{                                           \
    OUT_ACCEL(SCISSORS_B, (y) | CLIP_BOTTOM);  \
}

#define IO_ABS_SCISSORS_R(ppdev, x)         \
{                                           \
    OUT_ACCEL(SCISSORS_R, (x) | CLIP_RIGHT);\
}

// The following are RELATIVE positioning macros.  They DO take
// the surface's offset into account:

#define IO_CUR_Y(ppdev, y)                  \
    IO_ABS_CUR_Y(ppdev, (y) + ppdev->yOffset)

#define IO_CUR_X(ppdev, x)                  \
    IO_ABS_CUR_X(ppdev, (x) + ppdev->xOffset)

#define IO_DEST_Y(ppdev, y)                 \
    IO_ABS_DEST_Y(ppdev, (y) + ppdev->yOffset)

#define IO_DEST_X(ppdev, x)                 \
    IO_ABS_DEST_X(ppdev, (x) + ppdev->xOffset)

#define IO_SCISSORS_T(ppdev, y)             \
    IO_ABS_SCISSORS_T(ppdev, (y) + ppdev->yOffset)

#define IO_SCISSORS_L(ppdev, x)             \
    IO_ABS_SCISSORS_L(ppdev, (x) + ppdev->xOffset)

#define IO_SCISSORS_B(ppdev, y)             \
    IO_ABS_SCISSORS_B(ppdev, (y) + ppdev->yOffset)

#define IO_SCISSORS_R(ppdev, x)             \
    IO_ABS_SCISSORS_R(ppdev, (x) + ppdev->xOffset)

#define IO_AXSTP(ppdev, x)                  \
    OUT_ACCEL(AXSTP, (x))

#define IO_DIASTP(ppdev, x)                 \
    OUT_ACCEL(DIASTP, (x))

#define IO_ERR_TERM(ppdev, x)               \
    OUT_ACCEL(ERR_TERM, (x))

#define IO_MAJ_AXIS_PCNT(ppdev, x)          \
    OUT_ACCEL(MAJ_AXIS_PCNT, (x))

#define IO_GP_STAT(ppdev)                   \
    IN_ACCEL(CMD)

// Note that we have to put memory barriers before and after the
// command output.  The first memory barrier ensures that all the
// settings registers have been set before the command is executed,
// and the second ensures that no subsequent changes to the settings
// registers will mess up the current command:

#define IO_CMD(ppdev, x)                    \
{                                           \
    OUT_ACCEL(CMD, (x));                    \
}

#define IO_SHORT_STROKE(ppdev, x)           \
    OUT_ACCEL(SHORT_STROKE, (x))

#define IO_BKGD_MIX(ppdev, x)               \
    OUT_ACCEL(BKGD_MIX, (x))

#define IO_FRGD_MIX(ppdev, x)               \
    OUT_ACCEL(FRGD_MIX, (x))

#define IO_MIN_AXIS_PCNT(ppdev, x)          \
{                                           \
    OUT_ACCEL(MIN_AXIS_PCNT, (x) | RECT_HEIGHT);      \
}

#define IO_PIX_CNTL(ppdev, x)               \
{                                           \
    OUT_ACCEL(PIX_CNTL, (x) | DATA_EXTENSION);   \
}

#define IO_READ_SEL(ppdev, x)   // Not used

#define IO_MULT_MISC(ppdev, x)  // Not used

#define IO_RD_REG_DT(ppdev, x)  // Not used

#define IO_PIX_TRANS(ppdev, x)              \
{                                           \
    /* Can't use OUT_ACCEL: */              \
    OUT_WORD(PIX_TRANS, (x));               \
}

// Macros for outputing colour-depth dependent values at 8bpp and 16bpp:

#define IO_BKGD_COLOR(ppdev, x)             \
    OUT_DEPTH(ppdev, BKGD_COLOR, (x))

#define IO_FRGD_COLOR(ppdev, x)             \
    OUT_DEPTH(ppdev, FRGD_COLOR, (x))

#define IO_WRT_MASK(ppdev, x)               \
    OUT_DEPTH(ppdev, WRT_MASK, (x))

#define IO_RD_MASK(ppdev, x)                \
    OUT_DEPTH(ppdev, RD_MASK, (x))

////////////////////////////////////////////////////////////////////
// Thunk this!

#define WAIT_FOR_DATA_AVAILABLE(ppdev)      \
{                                           \
    while (!(IO_GP_STAT(ppdev) & READ_DATA_AVAILABLE))          \
        ;                                   \
}

#define IO_PIX_TRANS_IN(ppdev, x)           \
{                                           \
    (WORD) x = IN_ACCEL(PIX_TRANS);         \
}

#define IO_PIX_TRANS_OUT(ppdev, x)          \
{                                           \
    /* Can't use OUT_ACCEL: */              \
    OUT_WORD(PIX_TRANS, (x));               \
}

///////////////////////////////////////////////////////////////////
// ATI extensions
///////////////////////////////////////////////////////////////////

#define FG_COLOR_SRC        0xE000
#define SHIFT_FG_COLOR_SRC  0x000D
#define DATA_ORDER          0x1000
#define DATA_WIDTH          0x0200
#define BG_COLOR_SRC        0x0180
#define SHIFT_BG_COLOR_SRC  0x0007
#define EXT_MONO_SRC        0x0060
#define SHIFT_EXT_MONO_SRC  0x0005
#define DRAW                0x0010
#define READ_MODE           0x0004
#define POLY_FILL_MODE      0x0002
#define SRC_SWAP            0x0800

#define FG_COLOR_SRC_BG     0x0000
#define FG_COLOR_SRC_FG     0x2000
#define FG_COLOR_SRC_HOST   0x4000
#define FG_COLOR_SRC_BLIT   0x6000
#define FG_COLOR_SRC_GS     0x8000
#define FG_COLOR_SRC_PATT   0xA000
#define FG_COLOR_SRC_CLUH   0xC000
#define FG_COLOR_SRC_CLUB   0xE000

#define BG_COLOR_SRC_BG     0x0000
#define BG_COLOR_SRC_FG     0x0080
#define BG_COLOR_SRC_HOST   0x0100
#define BG_COLOR_SRC_BLIT   0x0180

#define EXT_MONO_SRC_ONE    0x0000
#define EXT_MONO_SRC_PATT   0x0020
#define EXT_MONO_SRC_HOST   0x0040
#define EXT_MONO_SRC_BLIT   0x0060

#define ONE_WORD            0x8000
#define TWO_WORDS           0xC000
#define THREE_WORDS         0xE000
#define FOUR_WORDS          0xF000
#define FIVE_WORDS          0xF800
#define SIX_WORDS           0xFC00
#define SEVEN_WORDS         0xFE00
#define EIGHT_WORDS         0xFF00
#define NINE_WORDS          0xFF80
#define TEN_WORDS           0xFFC0
#define ELEVEN_WORDS        0xFFE0
#define TWELVE_WORDS        0xFFF0
#define THIRTEEN_WORDS      0xFFF8
#define FOURTEEN_WORDS      0xFFFC
#define FIFTEEN_WORDS       0xFFFE
#define SIXTEEN_WORDS       0xFFFF

#define SRC_Y               0x8AE8
#define SRC_X               0x8EE8
#define EXT_FIFO_STATUS     0x9AEE
#define DEST_X_START        0xA6EE
#define DEST_X_END          0xAAEE
#define DEST_Y_END          0xAEEE
#define SRC_X_START         0xB2EE
#define ALU_BG_FN           0xB6EE
#define ALU_FG_FN           0xBAEE
#define SRC_X_END           0xBEEE
#define SRC_Y_DIR           0xC2EE
#define R_V_TOTAL           0xC2EE
#define EXT_SSV             0xC6EE
#define EXT_SHORT_STROKE    0xC6EE
#define R_V_DISP            0xC6EE
#define SCAN_X              0xCAEE
#define R_V_SYNC_STRT       0xCAEE
#define DP_CONFIG           0xCEEE
#define VERT_LINE_CNTR      0xCEEE
#define PATT_LENGTH         0xD2EE
#define R_V_SYNC_WID        0xD2EE
#define PATT_INDEX          0xD6EE
#define EXT_SCISSOR_L       0xDAEE
#define R_SRC_X             0xDAEE
#define EXT_SCISSOR_T       0xDEEE
#define R_SRC_Y             0xDEEE
#define PIX_TRANS           0xE2E8
#define EXT_SCISSOR_R       0xE2EE
#define EXT_SCISSOR_B       0xE6EE
#define SRC_CMP_COLOR       0xEAEE
#define DEST_CMP_FN         0xEEEE
#define LINEDRAW            0xFEEE

#define TOP_TO_BOTTOM       0x01
#define BOTTOM_TO_TOP       0x00
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*)EngAllocMem(FL_ZERO_MEMORY,
                        (sizeof(PALETTEENTRY) * 256), ALLOC_TAG);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

        // Generate 256 (8*4*4) RGB combinations to fill the palette

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = jRed;
            ppalTmp->peGreen = jGre;
            ppalTmp->peBlue  = jBlu;
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jRed += 32))
                if (!(jGre += 32))
                    jBlu += 64;
        }

        // Fill in Windows reserved colours from the WIN 3.0 DDK
        // The Window Manager reserved the first and last 10 colours for
        // painting windows borders and for non-palette managed applications.

        for (ulLoop = 0; ulLoop < 10; ulLoop++)
        {
            // First 10

            ppal[ulLoop]       = gapalBase[ulLoop];

            // Last 10

            ppal[246 + ulLoop] = gapalBase[ulLoop+10];
        }

        // Create handle for palette.

        hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
    }
    else
    {
        ASSERTDD((ppdev->iBitmapFormat == BMF_16BPP) ||
                 (ppdev->iBitmapFormat == BMF_32BPP),
                 "This case handles only 16 or 32bpp");

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl"));
        return (FALSE);
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\heap.c ===
/******************************Module*Header*******************************\
* Module Name: heap.c
*
* This module contains the routines for a 2-d heap.  It is used primarily
* for allocating space for device-format-bitmaps in off-screen memory.
*
* Off-screen bitmaps are a big deal on NT because:
*
*    1) It reduces the working set.  Any bitmap stored in off-screen
*       memory is a bitmap that isn't taking up space in main memory.
*
*    2) There is a speed win by using the accelerator hardware for
*       drawing, in place of NT's GDI code.  NT's GDI is written entirely
*       in 'C++' and perhaps isn't as fast as it could be.
*
*    3) It leads naturally to nifty tricks that can take advantage of
*       the hardware, such as MaskBlt support and cheap double buffering
*       for OpenGL.
*
* The heap algorithm employed herein attempts to solve an unsolvable
* problem: the problem of keeping arbitrary sized bitmaps as packed as
* possible in a 2-d space, when the bitmaps can come and go at random.
*
* This problem is due entirely to the nature of the hardware for which this
* driver is written: the hardware treats everything as 2-d quantities.  If
* the hardware bitmap pitch could be changed so that the bitmaps could be
* packed linearly in memory, the problem would be infinitely easier (it is
* much easier to track the memory, and the accelerator can be used to re-pack
* the heap to avoid segmentation).
*
* If your hardware can treat bitmaps as one dimensional quantities (as can
* the XGA and ATI), by all means please implement a new off-screen heap.
*
* When the heap gets full, old allocations will automatically be punted
* from off-screen and copied to DIBs, which we'll let GDI draw on.
*
* Note that this heap manages reverse-L shape off-screen memory
* configurations (where the scan pitch is longer than the visible screen,
* such as happens at 800x600 when the scan length must be a multiple of
* 1024).
*
* NOTE: All heap operations must be done under some sort of synchronization,
*       whether it's controlled by GDI or explicitly by the driver.  All
*       the routines in this module assume that they have exclusive access
*       to the heap data structures; multiple threads partying in here at
*       the same time would be a Bad Thing.  (By default, GDI does NOT
*       synchronize drawing on device-created bitmaps.)
*
* Copyright (c) 1993-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define OH_ALLOC_SIZE   4000        // Do all memory allocations in 4k chunks
#define OH_QUANTUM      8           // The minimum dimension of an allocation
#define CXCY_SENTINEL   0x7fffffff  // The sentinel at the end of the available
                                    //  list has this very large 'cxcy' value

// This macro results in the available list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/******************************Public*Routine******************************\
* OH* pohNewNode
*
* Allocates a basic memory unit in which we'll pack our data structures.
*
* Since we'll have a lot of OH nodes, most of which we will be
* occasionally traversing, we do our own memory allocation scheme to
* keep them densely packed in memory.
*
* It would be the worst possible thing for the working set to simply
* call EngAllocMem(sizeof(OH)) every time we needed a new node.  There
* would be no locality; OH nodes would get scattered throughout memory,
* and as we traversed the available list for one of our allocations,
* it would be far more likely that we would hit a hard page fault.
\**************************************************************************/

OH* pohNewNode(
PDEV*   ppdev)
{
    LONG     i;
    LONG     cOhs;
    OHALLOC* poha;
    OH*      poh;

    if (ppdev->heap.pohFreeList == NULL)
    {
        // We zero-init to initialize all the OH flags, and to help in
        // debugging (we can afford to do this since we'll be doing this
        // very infrequently):

        poha = EngAllocMem(FL_ZERO_MEMORY, OH_ALLOC_SIZE, ALLOC_TAG);
        if (poha == NULL)
            return(NULL);

        // Insert this OHALLOC at the begining of the OHALLOC chain:

        poha->pohaNext  = ppdev->heap.pohaChain;
        ppdev->heap.pohaChain = poha;

        // This has a '+ 1' because OHALLOC includes an extra OH in its
        // structure declaration:

        cOhs = (OH_ALLOC_SIZE - sizeof(OHALLOC)) / sizeof(OH) + 1;

        // The big OHALLOC allocation is simply a container for a bunch of
        // OH data structures in an array.  The new OH data structures are
        // linked together and added to the OH free list:

        poh = &poha->aoh[0];
        for (i = cOhs - 1; i != 0; i--)
        {
            poh->pohNext = poh + 1;
            poh          = poh + 1;
        }

        poh->pohNext      = NULL;
        ppdev->heap.pohFreeList = &poha->aoh[0];
    }

    poh = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh->pohNext;

    return(poh);
}

/******************************Public*Routine******************************\
* VOID vOhFreeNode
*
* Frees our basic data structure allocation unit by adding it to a free
* list.
*
\**************************************************************************/

VOID vOhFreeNode(
PDEV*   ppdev,
OH*     poh)
{
    if (poh == NULL)
        return;

    poh->pohNext            = ppdev->heap.pohFreeList;
    ppdev->heap.pohFreeList = poh;
    poh->ofl                = 0;
}

/******************************Public*Routine******************************\
* OH* pohFree
*
* Frees an off-screen heap allocation.  The free space will be combined
* with any adjacent free spaces to avoid segmentation of the 2-d heap.
*
* Note: A key idea here is that the data structure for the upper-left-
*       most node must be kept at the same physical CPU memory so that
*       adjacency links are kept correctly (when two free spaces are
*       merged, the lower or right node can be freed).
*
\**************************************************************************/

OH* pohFree(
PDEV*   ppdev,
OH*     poh)
{
    ULONG cxcy;
    OH*   pohBeside;
    OH*   pohNext;
    OH*   pohPrev;

    if (poh == NULL)
        return(NULL);

    DISPDBG((1, "Freeing %li x %li at (%li, %li)",
            poh->cx, poh->cy, poh->x, poh->y));

    #if DEBUG_HEAP
    {
        RECTL           rclBitmap;
        RBRUSH_COLOR    rbc;
        LONG            xOffset;
        LONG            yOffset;

        rclBitmap.left   = poh->x;
        rclBitmap.top    = poh->y;
        rclBitmap.right  = poh->x + poh->cx;
        rclBitmap.bottom = poh->y + poh->cy;

        xOffset = ppdev->xOffset;
        yOffset = ppdev->yOffset;

        ppdev->xOffset = 0;
        ppdev->yOffset = 0;

        ppdev->pfnFillSolid(ppdev, 1, &rclBitmap, LOGICAL_0, LOGICAL_0, rbc,
                            NULL);

        ppdev->xOffset = xOffset;
        ppdev->yOffset = yOffset;
    }
    #endif

    // Update the uniqueness to show that space has been freed, so that
    // we may decide to see if some DIBs can be moved back into off-screen
    // memory:

    ppdev->iHeapUniq++;

MergeLoop:

    ASSERTDD(!(poh->ofl & OFL_PERMANENT), "Can't free permanents for now");

    // Try merging with the right sibling:

    pohBeside = poh->pohRight;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy      == poh->cy)         &&
        (pohBeside->pohUp   == poh->pohUp)      &&
        (pohBeside->pohDown == poh->pohDown)    &&
        (pohBeside->pohRight->pohLeft != pohBeside))
    {
        // Add the right rectangle to ours:

        poh->cx      += pohBeside->cx;
        poh->pohRight = pohBeside->pohRight;

        // Remove 'pohBeside' from the ??? list and free it:

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the lower sibling:

    pohBeside = poh->pohDown;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown->pohUp != pohBeside))
    {
        poh->cy     += pohBeside->cy;
        poh->pohDown = pohBeside->pohDown;

        pohBeside->pohNext->pohPrev = pohBeside->pohPrev;
        pohBeside->pohPrev->pohNext = pohBeside->pohNext;

        vOhFreeNode(ppdev, pohBeside);
        goto MergeLoop;
    }

    // Try merging with the left sibling:

    pohBeside = poh->pohLeft;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cy       == poh->cy)        &&
        (pohBeside->pohUp    == poh->pohUp)     &&
        (pohBeside->pohDown  == poh->pohDown)   &&
        (pohBeside->pohRight == poh)            &&
        (poh->pohRight->pohLeft != poh))
    {
        // We add our rectangle to the one to the left:

        pohBeside->cx      += poh->cx;
        pohBeside->pohRight = poh->pohRight;

        // Remove 'poh' from the ??? list and free it:

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Try merging with the upper sibling:

    pohBeside = poh->pohUp;
    if ((pohBeside->ofl & OFL_AVAILABLE)        &&
        (pohBeside->cx       == poh->cx)        &&
        (pohBeside->pohLeft  == poh->pohLeft)   &&
        (pohBeside->pohRight == poh->pohRight)  &&
        (pohBeside->pohDown  == poh)            &&
        (poh->pohDown->pohUp != poh))
    {
        pohBeside->cy      += poh->cy;
        pohBeside->pohDown  = poh->pohDown;

        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev->pohNext = poh->pohNext;

        vOhFreeNode(ppdev, poh);

        poh = pohBeside;
        goto MergeLoop;
    }

    // Remove the node from the ???list if it was in use (we wouldn't
    // want to do this for a OFL_PERMANENT node that had been freed):

    poh->pohNext->pohPrev = poh->pohPrev;
    poh->pohPrev->pohNext = poh->pohNext;

    cxcy = CXCY(poh->cx, poh->cy);

    // Insert the node into the available list:

    pohNext = ppdev->heap.ohAvailable.pohNext;
    while (pohNext->cxcy < cxcy)
    {
        pohNext = pohNext->pohNext;
    }
    pohPrev = pohNext->pohPrev;

    pohPrev->pohNext    = poh;
    pohNext->pohPrev    = poh;
    poh->pohPrev        = pohPrev;
    poh->pohNext        = pohNext;

    poh->ofl            = OFL_AVAILABLE;
    poh->cxcy           = cxcy;

    // Return the node pointer for the new and improved available rectangle:

    return(poh);
}

/******************************Public*Routine******************************\
* OH* pohAllocate
*
* Allocates space for an off-screen rectangle.  It will attempt to find
* the smallest available free rectangle, and will allocate the block out
* of its upper-left corner.  The remaining two rectangles will be placed
* on the available free space list.
*
* If the rectangle would have been large enough to fit into off-screen
* memory, but there is not enough available free space, we will boot
* bitmaps out of off-screen and into DIBs until there is enough room.
*
\**************************************************************************/

OH* pohAllocate(
PDEV*   ppdev,
LONG    cxThis,             // Width of rectangle to be allocated
LONG    cyThis,             // Height of rectangle to be allocated
FLOH    floh)               // Allocation flags
{
    ULONG cxcyThis;         // Width and height search key
    OH*   pohThis;          // Points to found available rectangle we'll use
    ULONG cxcy;             // Temporary versions
    OH*   pohNext;
    OH*   pohPrev;

    LONG  cxRem;
    LONG  cyRem;

    OH*   pohBelow;
    LONG  cxBelow;
    LONG  cyBelow;

    OH*   pohBeside;
    LONG  cxBeside;
    LONG  cyBeside;

    DISPDBG((1, "Allocating %li x %li...", cxThis, cyThis));

    ASSERTDD((cxThis > 0) && (cyThis > 0), "Illegal allocation size");

    // Increase the width to get the proper alignment (thus ensuring that all
    // allocations will be properly aligned):

    cxThis = (cxThis + (HEAP_X_ALIGNMENT - 1)) & ~(HEAP_X_ALIGNMENT - 1);

    // We can't succeed if the requested rectangle is larger than the
    // largest possible available rectangle:

    if ((cxThis > ppdev->heap.cxMax) || (cyThis > ppdev->heap.cyMax))
        return(NULL);

    // Find the first available rectangle the same size or larger than
    // the requested one:

    cxcyThis = CXCY(cxThis, cyThis);
    pohThis  = ppdev->heap.ohAvailable.pohNext;
    while (pohThis->cxcy < cxcyThis)
    {
        pohThis = pohThis->pohNext;
    }

    while (pohThis->cy < cyThis)
    {
        pohThis = pohThis->pohNext;
    }

    if (pohThis->cxcy == CXCY_SENTINEL)
    {
        // There was no space large enough...

        if (floh & FLOH_ONLY_IF_ROOM)
            return(NULL);

        // We couldn't find an available rectangle that was big enough
        // to fit our request.  So throw things out of the heap until we
        // have room:

        do {
            pohThis = ppdev->heap.ohDfb.pohPrev;  // Least-recently blitted

            ASSERTDD(pohThis != &ppdev->heap.ohDfb, "Ran out of in-use entries");

            // We can safely exit here if we have to:

            pohThis = pohMoveOffscreenDfbToDib(ppdev, pohThis);
            if (pohThis == NULL)
                return(NULL);

        } while ((pohThis->cx < cxThis) || (pohThis->cy < cyThis));
    }

    // We've now found an available rectangle that is the same size or
    // bigger than our requested rectangle.  We're going to use the
    // upper-left corner of our found rectangle, and divide the unused
    // remainder into two rectangles which will go on the available
    // list.

    // Compute the width of the unused rectangle to the right, and the
    // height of the unused rectangle below:

    cyRem = pohThis->cy - cyThis;
    cxRem = pohThis->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow  = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
        cxBelow  = cxThis + cxRem;
        cyBeside = cyThis;
    }
    else
    {
        cxBelow  = cxThis;
        cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and bottom
    // portions if they're greater in dimension than OH_QUANTUM (it hardly
    // makes sense to do the book-work to keep around a 2-pixel wide
    // available space, for example):

    pohBeside = NULL;
    if (cxBeside >= OH_QUANTUM)
    {
        pohBeside = pohNewNode(ppdev);
        if (pohBeside == NULL)
            return(NULL);
    }

    pohBelow = NULL;
    if (cyBelow >= OH_QUANTUM)
    {
        pohBelow = pohNewNode(ppdev);
        if (pohBelow == NULL)
        {
            vOhFreeNode(ppdev, pohBeside);
            return(NULL);
        }

        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBelow, cyBelow);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext   = pohBelow;
        pohNext->pohPrev   = pohBelow;
        pohBelow->pohPrev  = pohPrev;
        pohBelow->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBelow->pohLeft  = pohThis->pohLeft;
        pohBelow->pohUp    = pohThis;
        pohBelow->pohRight = pohThis->pohRight;
        pohBelow->pohDown  = pohThis->pohDown;

        // Update the rest of the new node information:

        pohBelow->cxcy     = cxcy;
        pohBelow->ofl      = OFL_AVAILABLE;
        pohBelow->x        = pohThis->x;
        pohBelow->y        = pohThis->y + cyThis;
        pohBelow->cx       = cxBelow;
        pohBelow->cy       = cyBelow;

        // Modify the current node to reflect the changes we've made:

        pohThis->cy        = cyThis;
    }

    if (cxBeside >= OH_QUANTUM)
    {
        // Insert this rectangle into the available list (which is
        // sorted on ascending cxcy):

        cxcy    = CXCY(cxBeside, cyBeside);
        pohNext = ppdev->heap.ohAvailable.pohNext;
        while (pohNext->cxcy < cxcy)
        {
            pohNext = pohNext->pohNext;
        }
        pohPrev = pohNext->pohPrev;

        pohPrev->pohNext    = pohBeside;
        pohNext->pohPrev    = pohBeside;
        pohBeside->pohPrev  = pohPrev;
        pohBeside->pohNext  = pohNext;

        // Now update the adjacency information:

        pohBeside->pohUp    = pohThis->pohUp;
        pohBeside->pohLeft  = pohThis;
        pohBeside->pohDown  = pohThis->pohDown;
        pohBeside->pohRight = pohThis->pohRight;

        // Update the rest of the new node information:

        pohBeside->cxcy     = cxcy;
        pohBeside->ofl      = OFL_AVAILABLE;
        pohBeside->x        = pohThis->x + cxThis;
        pohBeside->y        = pohThis->y;
        pohBeside->cx       = cxBeside;
        pohBeside->cy       = cyBeside;

        // Modify the current node to reflect the changes we've made:

        pohThis->cx         = cxThis;
    }

    if (pohBelow != NULL)
    {
        pohThis->pohDown = pohBelow;
        if ((pohBeside != NULL) && (cyBeside == pohThis->cy))
            pohBeside->pohDown = pohBelow;
    }
    if (pohBeside != NULL)
    {
        pohThis->pohRight = pohBeside;
        if ((pohBelow != NULL) && (cxBelow == pohThis->cx))
            pohBelow->pohRight  = pohBeside;
    }

    pohThis->ofl                 = OFL_INUSE;
    pohThis->cxcy                = CXCY(pohThis->cx, pohThis->cy);
    pohThis->pdsurf              = NULL;    // Caller is responsible for
                                            //   setting this field

    // Remove this from the available list:

    pohThis->pohPrev->pohNext    = pohThis->pohNext;
    pohThis->pohNext->pohPrev    = pohThis->pohPrev;

    // Now insert this at the head of the DFB list:

    pohThis->pohNext                   = ppdev->heap.ohDfb.pohNext;
    pohThis->pohPrev                   = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohNext->pohPrev = pohThis;
    ppdev->heap.ohDfb.pohNext          = pohThis;

    DISPDBG((1, "   Allocated at (%li, %li)", pohThis->x, pohThis->y));

    return(pohThis);
}

/******************************Public*Routine******************************\
* VOID vCalculateMaxmimum
*
* Traverses the list of in-use and available rectangles to find the one
* with the maximal area.
*
\**************************************************************************/

VOID vCalculateMaximum(
PDEV*   ppdev)
{
    OH*     poh;
    OH*     pohSentinel;
    LONG    lArea;
    LONG    lMaxArea;
    LONG    cxMax;
    LONG    cyMax;
    LONG    i;

    lMaxArea = 0;
    cxMax    = 0;
    cyMax    = 0;

    // First time through, loop through the list of available rectangles:

    pohSentinel = &ppdev->heap.ohAvailable;

    for (i = 2; i != 0; i--)
    {
        for (poh = pohSentinel->pohNext; poh != pohSentinel; poh = poh->pohNext)
        {
            ASSERTDD(!(poh->ofl & OFL_PERMANENT),
                     "Permanent in available/DFB chain?");

            // We don't have worry about this multiply overflowing
            // because we are dealing in physical screen coordinates,
            // which will probably never be more than 15 bits:

            lArea = poh->cx * poh->cy;
            if (lArea > lMaxArea)
            {
                cxMax    = poh->cx;
                cyMax    = poh->cy;
                lMaxArea = lArea;
            }
        }

        // Second time through, loop through the list of in-use rectangles:

        pohSentinel = &ppdev->heap.ohDfb;
    }

    // All that we are interested in is the dimensions of the rectangle
    // that has the largest possible available area (and remember that
    // there might not be any possible available area):

    ppdev->heap.cxMax = cxMax;
    ppdev->heap.cyMax = cyMax;
}

/******************************Public*Routine******************************\
* OH* pohAllocatePermanent
*
* Allocates an off-screen rectangle that can never be booted of the heap.
* It's the caller's responsibility to manage the rectangle, which includes
* what to do with the memory in DrvAssertMode when the display is changed
* to full-screen mode.
*
\**************************************************************************/

OH* pohAllocatePermanent(
PDEV*   ppdev,
LONG    cx,
LONG    cy)
{
    OH*     poh;

    poh = pohAllocate(ppdev, cx, cy, 0);
    if (poh != NULL)
    {
        // Mark the rectangle as permanent:

        poh->ofl = OFL_PERMANENT;

        // Remove the node from the most-recently blitted list:

        poh->pohPrev->pohNext = poh->pohNext;
        poh->pohNext->pohPrev = poh->pohPrev;
        poh->pohPrev = NULL;
        poh->pohNext = NULL;

        // Now calculate the new maximum size rectangle available in the
        // heap:

        vCalculateMaximum(ppdev);
    }

    return(poh);
}

/******************************Public*Routine******************************\
* BOOL bMoveDibToOffscreenDfbIfRoom
*
* Converts the DIB DFB to an off-screen DFB, if there's room for it in
* off-screen memory.
*
* Returns: FALSE if there wasn't room, TRUE if successfully moved.
*
\**************************************************************************/

BOOL bMoveDibToOffscreenDfbIfRoom(
PDEV*   ppdev,
DSURF*  pdsurf)
{
    OH*         poh;
    SURFOBJ*    pso;
    RECTL       rclDst;
    POINTL      ptlSrc;
    HSURF       hsurf;

    ASSERTDD(pdsurf->dt == DT_DIB,
             "Can't move a bitmap off-screen when it's already off-screen");

    // If we're in full-screen mode, we can't move anything to off-screen
    // memory:

    if (!ppdev->bEnabled)
        return(FALSE);

    poh = pohAllocate(ppdev, pdsurf->sizl.cx, pdsurf->sizl.cy,
                      FLOH_ONLY_IF_ROOM);
    if (poh == NULL)
    {
        // There wasn't any free room.

        return(FALSE);
    }

    // 'pdsurf->sizl' is the actual bitmap dimension, not 'poh->cx' or
    // 'poh->cy'.

    rclDst.left   = poh->x;
    rclDst.top    = poh->y;
    rclDst.right  = rclDst.left + pdsurf->sizl.cx;
    rclDst.bottom = rclDst.top  + pdsurf->sizl.cy;

    ptlSrc.x      = 0;
    ptlSrc.y      = 0;

    vPutBits(ppdev, pdsurf->pso, &rclDst, &ptlSrc);

    // Update the data structures to reflect the new off-screen node:

    pso           = pdsurf->pso;
    pdsurf->dt    = DT_SCREEN;
    pdsurf->poh   = poh;
    poh->pdsurf   = pdsurf;

    // Now free the DIB.  Get the hsurf from the SURFOBJ before we unlock
    // it (it's not legal to dereference psoDib when it's unlocked):

    hsurf = pso->hsurf;
    EngUnlockSurface(pso);
    EngDeleteSurface(hsurf);

    return(TRUE);
}

/******************************Public*Routine******************************\
* OH* pohMoveOffscreenDfbToDib
*
* Converts the DFB from being off-screen to being a DIB.
*
* Note: The caller does NOT have to call 'pohFree' on 'poh' after making
*       this call.
*
* Returns: NULL if the function failed (due to a memory allocation).
*          Otherwise, it returns a pointer to the coalesced off-screen heap
*          node that has been made available for subsequent allocations
*          (useful when trying to free enough memory to make a new
*          allocation).
\**************************************************************************/

OH* pohMoveOffscreenDfbToDib(
PDEV*   ppdev,
OH*     poh)
{
    DSURF*   pdsurf;
    HBITMAP  hbmDib;
    SURFOBJ* pso;
    RECTL    rclDst;
    POINTL   ptlSrc;

    DISPDBG((1, "Throwing out %li x %li at (%li, %li)!",
                 poh->cx, poh->cy, poh->x, poh->y));

    pdsurf = poh->pdsurf;

    ASSERTDD((poh->x != 0) || (poh->y != 0),
            "Can't make the visible screen into a DIB");
    ASSERTDD(pdsurf->dt != DT_DIB,
            "Can't make a DIB into even more of a DIB");

    hbmDib = EngCreateBitmap(pdsurf->sizl, 0, ppdev->iBitmapFormat,
                             BMF_TOPDOWN, NULL);
    if (hbmDib)
    {
        if (EngAssociateSurface((HSURF) hbmDib, ppdev->hdevEng, 0))
        {
            pso = EngLockSurface((HSURF) hbmDib);
            if (pso != NULL)
            {
                rclDst.left   = 0;
                rclDst.top    = 0;
                rclDst.right  = pdsurf->sizl.cx;
                rclDst.bottom = pdsurf->sizl.cy;

                ptlSrc.x      = poh->x;
                ptlSrc.y      = poh->y;

                vGetBits(ppdev, pso, &rclDst, &ptlSrc);

                pdsurf->dt    = DT_DIB;
                pdsurf->pso   = pso;

                // Don't even bother checking to see if this DIB should
                // be put back into off-screen memory until the next
                // heap 'free' occurs:

                pdsurf->iUniq = ppdev->iHeapUniq;
                pdsurf->cBlt  = 0;

                // Remove this node from the off-screen DFB list, and free
                // it.  'pohFree' will never return NULL:

                return(pohFree(ppdev, poh));
            }
        }

        // Fail case:

        EngDeleteSurface((HSURF) hbmDib);
    }

    return(NULL);
}

/******************************Public*Routine******************************\
* BOOL bMoveEverythingFromOffscreenToDibs
*
* This function is used when we're about to enter full-screen mode, which
* would wipe all our off-screen bitmaps.  GDI can ask us to draw on
* device bitmaps even when we're in full-screen mode, and we do NOT have
* the option of stalling the call until we switch out of full-screen.
* We have no choice but to move all the off-screen DFBs to DIBs.
*
* Returns TRUE if all DSURFs have been successfully moved.
*
\**************************************************************************/

BOOL bMoveAllDfbsFromOffscreenToDibs(
PDEV*   ppdev)
{
    OH*  poh;
    OH*  pohNext;
    BOOL bRet;

    bRet = TRUE;
    poh  = ppdev->heap.ohDfb.pohNext;
    while (poh != &ppdev->heap.ohDfb)
    {
        pohNext = poh->pohNext;

        // If something's already a DIB, we shouldn't try to make it even
        // more of a DIB:

        if (poh->pdsurf->dt == DT_SCREEN)
        {
            if (!pohMoveOffscreenDfbToDib(ppdev, poh))
                bRet = FALSE;
        }

        poh = pohNext;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* HBITMAP DrvCreateDeviceBitmap
*
* Function called by GDI to create a device-format-bitmap (DFB).  We will
* always try to allocate the bitmap in off-screen; if we can't, we simply
* fail the call and GDI will create and manage the bitmap itself.
*
* Note: We do not have to zero the bitmap bits.  GDI will automatically
*       call us via DrvBitBlt to zero the bits (which is a security
*       consideration).
*
\**************************************************************************/

HBITMAP DrvCreateDeviceBitmap(
DHPDEV  dhpdev,
SIZEL   sizl,
ULONG   iFormat)
{
    PDEV*   ppdev;
    OH*     poh;
    DSURF*  pdsurf;
    HBITMAP hbmDevice;
    FLONG   flHooks;

    ppdev = (PDEV*) dhpdev;

    // If we're in full-screen mode, we hardly have any off-screen memory
    // in which to allocate a DFB.  LATER: We could still allocate an
    // OH node and put the bitmap on the DIB DFB list for later promotion.

    if (!ppdev->bEnabled)
        return(0);

    // We only support device bitmaps that are the same colour depth
    // as our display.
    //
    // Actually, those are the only kind GDI will ever call us with,
    // but we may as well check.  Note that this implies you'll never
    // get a crack at 1bpp bitmaps.

    if (iFormat != ppdev->iBitmapFormat)
        return(0);

    poh = pohAllocate(ppdev, sizl.cx, sizl.cy, 0);
    if (poh != NULL)
    {
        pdsurf = EngAllocMem(0, sizeof(DSURF), ALLOC_TAG);
        if (pdsurf != NULL)
        {
            hbmDevice = EngCreateDeviceBitmap((DHSURF) pdsurf, sizl, iFormat);
            if (hbmDevice != NULL)
            {
                flHooks = ppdev->flHooks;

                #if SYNCHRONIZEACCESS_WORKS
                {
                    // Setting the SYNCHRONIZEACCESS flag tells GDI that we
                    // want all drawing to the bitmaps to be synchronized (GDI
                    // is multi-threaded and by default does not synchronize
                    // device bitmap drawing -- it would be a Bad Thing for us
                    // to have multiple threads using the accelerator at the
                    // same time):

                    flHooks |= HOOK_SYNCHRONIZEACCESS;
                }
                #endif // SYNCHRONIZEACCESS_WORKS

                if (EngAssociateSurface((HSURF) hbmDevice, ppdev->hdevEng,
                                        flHooks))
                {
                    pdsurf->dt    = DT_SCREEN;
                    pdsurf->poh   = poh;
                    pdsurf->sizl  = sizl;
                    pdsurf->ppdev = ppdev;
                    poh->pdsurf   = pdsurf;

                    return(hbmDevice);
                }

                EngDeleteSurface((HSURF) hbmDevice);
            }
            EngFreeMem(pdsurf);
        }
        pohFree(ppdev, poh);
    }

    return(0);
}

/******************************Public*Routine******************************\
* VOID DrvDeleteDeviceBitmap
*
* Deletes a DFB.
*
\**************************************************************************/

VOID DrvDeleteDeviceBitmap(
DHSURF  dhsurf)
{
    DSURF*   pdsurf;
    PDEV*    ppdev;
    SURFOBJ* psoDib;
    HSURF    hsurfDib;

    pdsurf = (DSURF*) dhsurf;
    ppdev  = pdsurf->ppdev;

    if (pdsurf->dt == DT_SCREEN)
    {
        pohFree(ppdev, pdsurf->poh);
    }
    else
    {
        ASSERTDD(pdsurf->dt == DT_DIB, "Expected DIB type");

        psoDib = pdsurf->pso;

        // Get the hsurf from the SURFOBJ before we unlock it (it's not
        // legal to dereference psoDib when it's unlocked):

        hsurfDib = psoDib->hsurf;
        EngUnlockSurface(psoDib);
        EngDeleteSurface(hsurfDib);
    }

    EngFreeMem(pdsurf);
}

/******************************Public*Routine******************************\
* BOOL bAssertModeOffscreenHeap
*
* This function is called whenever we switch in or out of full-screen
* mode.  We have to convert all the off-screen bitmaps to DIBs when
* we switch to full-screen (because we may be asked to draw on them even
* when in full-screen, and the mode switch would probably nuke the video
* memory contents anyway).
*
\**************************************************************************/

BOOL bAssertModeOffscreenHeap(
PDEV*   ppdev,
BOOL    bEnable)
{
    BOOL b;

    b = TRUE;

    if (!bEnable)
    {
        b = bMoveAllDfbsFromOffscreenToDibs(ppdev);
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID vDisableOffscreenHeap
*
* Frees any resources allocated by the off-screen heap.
*
\**************************************************************************/

VOID vDisableOffscreenHeap(
PDEV*   ppdev)
{
    OHALLOC* poha;
    OHALLOC* pohaNext;

    poha = ppdev->heap.pohaChain;
    while (poha != NULL)
    {
        pohaNext = poha->pohaNext;  // Grab the next pointer before it's freed
        EngFreeMem(poha);
        poha = pohaNext;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableOffscreenHeap
*
* Initializes the off-screen heap using all available video memory,
* accounting for the portion taken by the visible screen.
*
* Input: ppdev->cxScreen
*        ppdev->cyScreen
*        ppdev->cxMemory
*        ppdev->cyMemory
*
\**************************************************************************/

BOOL bEnableOffscreenHeap(
PDEV*   ppdev)
{
    OH*     poh;

    DISPDBG((5, "Screen: %li x %li  Memory: %li x %li",
        ppdev->cxScreen, ppdev->cyScreen, ppdev->cxMemory, ppdev->cyMemory));

    ppdev->heap.pohaChain   = NULL;
    ppdev->heap.pohFreeList = NULL;

    // Initialize the available list, which will be a circular
    // doubly-linked list kept in ascending 'cxcy' order, with a
    // 'sentinel' at the end of the list:

    poh = pohNewNode(ppdev);
    if (poh == NULL)
        goto ReturnFalse;

    // The first node describes the entire video memory size:

    poh->pohNext  = &ppdev->heap.ohAvailable;
    poh->pohPrev  = &ppdev->heap.ohAvailable;
    poh->ofl      = OFL_AVAILABLE;
    poh->x        = 0;
    poh->y        = 0;
    poh->cx       = ppdev->cxMemory;
    poh->cy       = ppdev->cyMemory;
    poh->cxcy     = CXCY(ppdev->cxMemory, ppdev->cyMemory);
    poh->pohLeft  = &ppdev->heap.ohAvailable;
    poh->pohUp    = &ppdev->heap.ohAvailable;
    poh->pohRight = &ppdev->heap.ohAvailable;
    poh->pohDown  = &ppdev->heap.ohAvailable;

    // The second node is our available list sentinel:

    ppdev->heap.ohAvailable.pohNext = poh;
    ppdev->heap.ohAvailable.pohPrev = poh;
    ppdev->heap.ohAvailable.cxcy    = CXCY_SENTINEL;
    ppdev->heap.ohAvailable.cx      = 0x7fffffff;
    ppdev->heap.ohAvailable.cy      = 0x7fffffff;
    ppdev->heap.ohAvailable.ofl     = OFL_PERMANENT;
    ppdev->heap.ohDfb.pohLeft       = NULL;
    ppdev->heap.ohDfb.pohUp         = NULL;
    ppdev->heap.ohDfb.pohRight      = NULL;
    ppdev->heap.ohDfb.pohDown       = NULL;

    // Initialize the most-recently-blitted DFB list, which will be
    // a circular doubly-linked list kept in order, with a sentinel at
    // the end.  This node is also used for the screen-surface, for its
    // offset:

    ppdev->heap.ohDfb.pohNext  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.pohPrev  = &ppdev->heap.ohDfb;
    ppdev->heap.ohDfb.ofl      = OFL_PERMANENT;

    // For the moment, make the max really big so that the first
    // allocation we're about to do will succeed:

    ppdev->heap.cxMax = 0x7fffffff;
    ppdev->heap.cyMax = 0x7fffffff;

    // Finally, reserve the upper-left corner for the screen.  We can
    // actually throw away 'poh' because we'll never need it again
    // (not even for disabling the off-screen heap since everything is
    // freed using OHALLOCs):

    poh = pohAllocatePermanent(ppdev, ppdev->cxScreen, ppdev->cyScreen);

    ASSERTDD((poh != NULL) && (poh->x == 0) && (poh->y == 0),
             "We assumed allocator would use the upper-left corner");

    DISPDBG((5, "Passed bEnableOffscreenHeap"));

    if (poh != NULL)
        return(TRUE);

    vDisableOffscreenHeap(ppdev);

ReturnFalse:

    DISPDBG((0, "Failed bEnableOffscreenHeap"));

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\misc.c ===
/******************************Module*Header*******************************\
* Module Name: misc.c
*
* Miscellaneous common routines.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vDataPortOutB
\**************************************************************************/

VOID vDataPortOutB(
PDEV*   ppdev,
VOID*   pb,
ULONG   cj)
{
    ULONG pixtrans = (ULONG) (ppdev->ioPix_trans);

    _asm {
        mov ecx, cj
        mov esi, pb
        mov edx, pixtrans

        rep outsb
    }
}

/******************************Public*Routine******************************\
* VOID vDataPortOut
\**************************************************************************/

VOID vDataPortOut(
PDEV*   ppdev,
VOID*   pw,
ULONG   cw)
{
    ULONG pixtrans = (ULONG) (ppdev->ioPix_trans);

    _asm {
        mov ecx, cw
        mov esi, pw
        mov edx, pixtrans

        rep outsw
    }
}

/******************************Public*Routine******************************\
* VOID vDataPortIn
\**************************************************************************/

VOID vDataPortIn(
PDEV*   ppdev,
VOID*   pw,
ULONG   cw)
{
    ULONG pixtrans = (ULONG) (ppdev->ioPix_trans);

    _asm {
        mov ecx, cw
        mov edi, pw
        mov edx, pixtrans

        rep insw
    }
}

/******************************Public*Routine******************************\
* VOID vResetClipping
\**************************************************************************/

VOID vResetClipping(
PDEV*   ppdev)
{
    IO_FIFO_WAIT(ppdev, 4);

    IO_ABS_SCISSORS_L(ppdev, 0);
    IO_ABS_SCISSORS_T(ppdev, 0);
    IO_ABS_SCISSORS_R(ppdev, ppdev->cxMemory - 1);
    IO_ABS_SCISSORS_B(ppdev, ppdev->cyMemory - 1);
}

/******************************Public*Routine******************************\
* VOID vSetClipping
\**************************************************************************/

VOID vSetClipping(
PDEV*   ppdev,
RECTL*  prclClip)           // In relative coordinates
{
    LONG xOffset;
    LONG yOffset;

    ASSERTDD(prclClip->left + ppdev->xOffset >= 0,
                    "Can't have a negative left!");
    ASSERTDD(prclClip->top + ppdev->yOffset >= 0,
                    "Can't have a negative top!");

    IO_FIFO_WAIT(ppdev, 4);

    xOffset = ppdev->xOffset;
    IO_ABS_SCISSORS_L(ppdev, prclClip->left      + xOffset);
    IO_ABS_SCISSORS_R(ppdev, prclClip->right - 1 + xOffset);
    ASSERTDD(prclClip->right + xOffset <= 1024,
            "Exceeded right scissors bounds");

    yOffset = ppdev->yOffset;
    IO_ABS_SCISSORS_T(ppdev, prclClip->top        + yOffset);
    IO_ABS_SCISSORS_B(ppdev, prclClip->bottom - 1 + yOffset);
    ASSERTDD(prclClip->bottom + yOffset <= 1024,
            "Exceeded bottom scissors bounds");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\lines.c ===
/*************************************************************************\
* Module Name: Lines.c
*
* C template for the ASM version of the line DDA calculator.
*
* Copyright (c) 1990-1994 Microsoft Corporation
* Copyright (c) 1992      Digital Equipment Corporation
\**************************************************************************/

#include "precomp.h"

#define DIVREM(u64,u32,pul) \
    RtlEnlargedUnsignedDivide(*(ULARGE_INTEGER*) &(u64), (u32), (pul))

#define SWAPL(x,y,t)        {t = x; x = y; y = t;} // from wingdip.h
#define ROR_BYTE(x) ((((x) >> 1) & 0x7f) | (((x) & 0x01) << 7))
#define ROL_BYTE(x) ((((x) << 1) & 0xfe) | (((x) & 0x80) >> 7))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define ABS(a)    ((a) < 0 ? -(a) : (a))

FLONG gaflRound[] = {
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // no flips
    FL_H_ROUND_DOWN | FL_V_ROUND_DOWN, // FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_V
    FL_V_ROUND_DOWN,                   // FL_FLIP_V | FL_FLIP_D
    FL_V_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE
    0xbaadf00d,                        // FL_FLIP_SLOPE_ONE | FL_FLIP_D
    FL_H_ROUND_DOWN,                   // FL_FLIP_SLOPE_ONE | FL_FLIP_V
    0xbaadf00d                         // FL_FLIP_SLOPE_ONE | FL_FLIP_V
| FL_FLIP_D
};

BOOL bIntegerLine(PDEV*, ULONG, ULONG, ULONG, ULONG);

/******************************Public*Routine******************************\
* BOOL bLines(ppdev, pptfxFirst, pptfxBuf, cptfx, pls,
*                   prclClip, apfn[], flStart)
*
* Computes the DDA for the line and gets ready to draw it.  Puts the
* pixel data into an array of strips, and calls a strip routine to
* do the actual drawing.
*
* Doing Lines Right
* -----------------
*
* In NT, all lines are given to the device driver in fractional
* coordinates, in a 28.4 fixed point format.  The lower 4 bits are
* fractional for sub-pixel positioning.
*
* Note that you CANNOT! just round the coordinates to integers
* and pass the results to your favorite integer Bresenham routine!!
* (Unless, of course, you have such a high resolution device that
* nobody will notice -- not likely for a display device.)  The
* fractions give a more accurate rendering of the line -- this is
* important for things like our Bezier curves, which would have 'kinks'
* if the points in its polyline approximation were rounded to integers.
*
* Unfortunately, for fractional lines there is more setup work to do
* a DDA than for integer lines.  However, the main loop is exactly
* the same (and can be done entirely with 32 bit math).
*
* If You've Got Hardware That Does Bresenham
* ------------------------------------------
*
* A lot of hardware limits DDA error terms to 'n' bits.  With fractional
* coordinates, 4 bits are given to the fractional part, letting
* you draw in hardware only those lines that lie entirely in a 2^(n-4)
* by 2^(n-4) pixel space.
*
* And you still have to correctly draw those lines with coordinates
* outside that space!  Remember that the screen is only a viewport
* onto a 28.4 by 28.4 space -- if any part of the line is visible
* you MUST render it precisely, regardless of where the end points lie.
* So even if you do it in software, somewhere you'll have to have a
* 32 bit DDA routine.
*
* Our Implementation
* ------------------
*
* We employ a run length slice algorithm: our DDA calculates the
* number of pixels that are in each row (or 'strip') of pixels.
*
* We've separated the running of the DDA and the drawing of pixels:
* we run the DDA for several iterations and store the results in
* a 'strip' buffer (which are the lengths of consecutive pixel rows of
* the line), then we crank up a 'strip drawer' that will draw all the
* strips in the buffer.
*
* We also employ a 'half-flip' to reduce the number of strip
* iterations we need to do in the DDA and strip drawing loops: when a
* (normalized) line's slope is more than 1/2, we do a final flip
* about the line y = (1/2)x.  So now, instead of each strip being
* consecutive horizontal or vertical pixel rows, each strip is composed
* of those pixels aligned in 45 degree rows.  So a line like (0, 0) to
* (128, 128) would generate only one strip.
*
* We also always draw only left-to-right.
*
* Style lines may have arbitrary style patterns.  We specially
* optimize the default patterns (and call them 'masked' styles).
*
* The DDA Derivation
* ------------------
*
* Here is how I like to think of the DDA calculation.
*
* We employ Knuth's "diamond rule": rendering a one-pixel-wide line
* can be thought of as dragging a one-pixel-wide by one-pixel-high
* diamond along the true line.  Pixel centers lie on the integer
* coordinates, and so we light any pixel whose center gets covered
* by the "drag" region (John D. Hobby, Journal of the Association
* for Computing Machinery, Vol. 36, No. 2, April 1989, pp. 209-229).
*
* We must define which pixel gets lit when the true line falls
* exactly half-way between two pixels.  In this case, we follow
* the rule: when two pels are equidistant, the upper or left pel
* is illuminated, unless the slope is exactly one, in which case
* the upper or right pel is illuminated.  (So we make the edges
* of the diamond exclusive, except for the top and left vertices,
* which are inclusive, unless we have slope one.)
*
* This metric decides what pixels should be on any line BEFORE it is
* flipped around for our calculation.  Having a consistent metric
* this way will let our lines blend nicely with our curves.  The
* metric also dictates that we will never have one pixel turned on
* directly above another that's turned on.  We will also never have
* a gap; i.e., there will be exactly one pixel turned on for each
* column between the start and end points.  All that remains to be
* done is to decide how many pixels should be turned on for each row.
*
* So lines we draw will consist of varying numbers of pixels on
* successive rows, for example:
*
*       ******
*             *****
*                  ******
*                        *****
*
* We'll call each set of pixels on a row a "strip".
*
* (Please remember that our coordinate space has the origin as the
* upper left pixel on the screen; postive y is down and positive x
* is right.)
*
* Device coordinates are specified as fixed point 28.4 numbers,
* where the first 28 bits are the integer coordinate, and the last
* 4 bits are the fraction.  So coordinates may be thought of as
* having the form (x, y) = (M/F, N/F) where F is the constant scaling
* factor F = 2^4 = 16, and M and N are 32 bit integers.
*
* Consider the line from (M0/F, N0/F) to (M1/F, N1/F) which runs
* left-to-right and whose slope is in the first octant, and let
* dM = M1 - M0 and dN = N1 - N0.  Then dM >= 0, dN >= 0 and dM >= dN.
*
* Since the slope of the line is less than 1, the edges of the
* drag region are created by the top and bottom vertices of the
* diamond.  At any given pixel row y of the line, we light those
* pixels whose centers are between the left and right edges.
*
* Let mL(n) denote the line representing the left edge of the drag
* region.  On pixel row j, the column of the first pixel to be
* lit is
*
*       iL(j) = ceiling( mL(j * F) / F)
*
* Since the line's slope is less than one:
*
*       iL(j) = ceiling( mL([j + 1/2] F) / F )
*
* Recall the formula for our line:
*
*       n(m) = (dN / dM) (m - M0) + N0
*
*       m(n) = (dM / dN) (n - N0) + M0
*
* Since the line's slope is less than one, the line representing
* the left edge of the drag region is the original line offset
* by 1/2 pixel in the y direction:
*
*       mL(n) = (dM / dN) (n - F/2 - N0) + M0
*
* From this we can figure out the column of the first pixel that
* will be lit on row j, being careful of rounding (if the left
* edge lands exactly on an integer point, the pixel at that
* point is not lit because of our rounding convention):
*
*       iL(j) = floor( mL(j F) / F ) + 1
*
*             = floor( ((dM / dN) (j F - F/2 - N0) + M0) / F ) + 1
*
*             = floor( F dM j - F/2 dM - N0 dM + dN M0) / F dN ) + 1
*
*                      F dM j - [ dM (N0 + F/2) - dN M0 ]
*             = floor( ---------------------------------- ) + 1
*                                   F dN
*
*                      dM j - [ dM (N0 + F/2) - dN M0 ] / F
*             = floor( ------------------------------------ ) + 1       (1)
*                                     dN
*
*             = floor( (dM j + alpha) / dN ) + 1
*
* where
*
*       alpha = - [ dM (N0 + F/2) - dN M0 ] / F
*
* We use equation (1) to calculate the DDA: there are iL(j+1) - iL(j)
* pixels in row j.  Because we are always calculating iL(j) for
* integer quantities of j, we note that the only fractional term
* is constant, and so we can 'throw away' the fractional bits of
* alpha:
*
*       beta = floor( - [ dM (N0 + F/2) - dN M0 ] / F )                 (2)
*
* so
*
*       iL(j) = floor( (dM j + beta) / dN ) + 1                         (3)
*
* for integers j.
*
* Note if iR(j) is the line's rightmost pixel on row j, that
* iR(j) = iL(j + 1) - 1.
*
* Similarly, rewriting equation (1) as a function of column i,
* we can determine, given column i, on which pixel row j is the line
* lit:
*
*                       dN i + [ dM (N0 + F/2) - dN M0 ] / F
*       j(i) = ceiling( ------------------------------------ ) - 1
*                                       dM
*
* Floors are easier to compute, so we can rewrite this:
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F
*       j(i) = floor( ----------------------------------------------- ) - 1
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 ] / F + dM - 1/F - dM
*            = floor( ---------------------------------------------------- )
*                                       dM
*
*                     dN i + [ dM (N0 + F/2) - dN M0 - 1 ] / F
*            = floor( ---------------------------------------- )
*                                       dM
*
* We can once again wave our hands and throw away the fractional bits
* of the remainder term:
*
*       j(i) = floor( (dN i + gamma) / dM )                             (4)
*
* where
*
*       gamma = floor( [ dM (N0 + F/2) - dN M0 - 1 ] / F )              (5)
*
* We now note that
*
*       beta = -gamma - 1 = ~gamma                                      (6)
*
* To draw the pixels of the line, we could evaluate (3) on every scan
* line to determine where the strip starts.  Of course, we don't want
* to do that because that would involve a multiply and divide for every
* scan.  So we do everything incrementally.
*
* We would like to easily compute c , the number of pixels on scan j:
*                                  j
*
*    c  = iL(j + 1) - iL(j)
*     j
*
*       = floor((dM (j + 1) + beta) / dN) - floor((dM j + beta) / dN)   (7)
*
* This may be rewritten as
*
*    c  = floor(i    + r    / dN) - floor(i  + r  / dN)                 (8)
*     j          j+1    j+1                j    j
*
* where i , i    are integers and r  < dN, r    < dN.
*        j   j+1                   j        j+1
*
* Rewriting (7) again:
*
*    c  = floor(i  + r  / dN + dM / dN) - floor(i  + r  / dN)
*     j          j    j                          j    j
*
*
*       = floor((r  + dM) / dN) - floor(r  / dN)
*                 j                      j
*
* This may be rewritten as
*
*    c  = dI + floor((r  + dR) / dN) - floor(r  / dN)
*     j                j                      j
*
* where dI + dR / dN = dM / dN, dI is an integer and dR < dN.
*
* r  is the remainder (or "error") term in the DDA loop: r  / dN
*  j                                                      j
* is the exact fraction of a pixel at which the strip ends.  To go
* on to the next scan and compute c    we need to know r   .
*                                  j+1                  j+1
*
* So in the main loop of the DDA:
*
*    c  = dI + floor((r  + dR) / dN) and r    = (r  + dR) % dN
*     j                j                  j+1     j
*
* and we know r  < dN, r    < dN, and dR < dN.
*              j        j+1
*
* We have derived the DDA only for lines in the first octant; to
* handle other octants we do the common trick of flipping the line
* to the first octant by first making the line left-to-right by
* exchanging the end-points, then flipping about the lines y = 0 and
* y = x, as necessary.  We must record the transformation so we can
* undo them later.
*
* We must also be careful of how the flips affect our rounding.  If
* to get the line to the first octant we flipped about x = 0, we now
* have to be careful to round a y value of 1/2 up instead of down as
* we would for a line originally in the first octant (recall that
* "In the case where two pels are equidistant, the upper or left
* pel is illuminated...").
*
* To account for this rounding when running the DDA, we shift the line
* (or not) in the y direction by the smallest amount possible.  That
* takes care of rounding for the DDA, but we still have to be careful
* about the rounding when determining the first and last pixels to be
* lit in the line.
*
* Determining The First And Last Pixels In The Line
* -------------------------------------------------
*
* Fractional coordinates also make it harder to determine which pixels
* will be the first and last ones in the line.  We've already taken
* the fractional coordinates into account in calculating the DDA, but
* the DDA cannot tell us which are the end pixels because it is quite
* happy to calculate pixels on the line from minus infinity to positive
* infinity.
*
* The diamond rule determines the start and end pixels.  (Recall that
* the sides are exclusive except for the left and top vertices.)
* This convention can be thought of in another way: there are diamonds
* around the pixels, and wherever the true line crosses a diamond,
* that pel is illuminated.
*
* Consider a line where we've done the flips to the first octant, and the
* floor of the start coordinates is the origin:
*
*        +-----------------------> +x
*        |
*        | 0                     1
*        |     0123456789abcdef
*        |
*        |   0 00000000?1111111
*        |   1 00000000 1111111
*        |   2 0000000   111111
*        |   3 000000     11111
*        |   4 00000    ** 1111
*        |   5 0000       ****1
*        |   6 000           1***
*        |   7 00             1  ****
*        |   8 ?                     ***
*        |   9 22             3         ****
*        |   a 222           33             ***
*        |   b 2222         333                ****
*        |   c 22222       3333                    **
*        |   d 222222     33333
*        |   e 2222222   333333
*        |   f 22222222 3333333
*        |
*        | 2                     3
*        v
*        +y
*
* If the start of the line lands on the diamond around pixel 0 (shown by
* the '0' region here), pixel 0 is the first pel in the line.  The same
* is true for the other pels.
*
* A little more work has to be done if the line starts in the
* 'nether-land' between the diamonds (as illustrated by the '*' line):
* the first pel lit is the first diamond crossed by the line (pixel 1 in
* our example).  This calculation is determined by the DDA or slope of
* the line.
*
* If the line starts exactly half way between two adjacent pixels
* (denoted here by the '?' spots), the first pixel is determined by our
* round-down convention (and is dependent on the flips done to
* normalize the line).
*
* Last Pel Exclusive
* ------------------
*
* To eliminate repeatedly lit pels between continuous connected lines,
* we employ a last-pel exclusive convention: if the line ends exactly on
* the diamond around a pel, that pel is not lit.  (This eliminates the
* checks we had in the old code to see if we were re-lighting pels.)
*
* The Half Flip
* -------------
*
* To make our run length algorithm more efficient, we employ a "half
* flip".  If after normalizing to the first octant, the slope is more
* than 1/2, we subtract the y coordinate from the x coordinate.  This
* has the effect of reflecting the coordinates through the line of slope
* 1/2.  Note that the diagonal gets mapped into the x-axis after a half
* flip.
*
* How Many Bits Do We Need, Anyway?
* ---------------------------------
*
* Note that if the line is visible on your screen, you must light up
* exactly the correct pixels, no matter where in the 28.4 x 28.4 device
* space the end points of the line lie (meaning you must handle 32 bit
* DDAs, you can certainly have optimized cases for lesser DDAs).
*
* We move the origin to (floor(M0 / F), floor(N0 / F)), so when we
* calculate gamma from (5), we know that 0 <= M0, N0 < F.  And we
* are in the first octant, so dM >= dN.  Then we know that gamma can
* be in the range [(-1/2)dM, (3/2)dM].  The DDI guarantees us that
* valid lines will have dM and dN values at most 31 bits (unsigned)
* of significance.  So gamma requires 33 bits of significance (we store
* this as a 64 bit number for convenience).
*
* When running through the DDA loop, r  + dR can have a value in the
*                                     j
* range 0 <= r  < 2 dN; thus the result must be a 32 bit unsigned value.
*             j
*
* Testing Lines
* -------------
*
* To be NT compliant, a display driver must exactly adhere to GIQ,
* which means that for any given line, the driver must light exactly
* the same pels as does GDI.  This can be tested using the Guiman tool
* provided elsewhere in the DDK, and 'ZTest', which draws random lines
* on the screen and to a bitmap, and compares the results.
*
* If You've Got Line Hardware
* ---------------------------
*
* If your hardware already adheres to GIQ, you're all set.  Otherwise
* you'll want to look at the S3 sample code and read the following:
*
* 1) You'll want to special case integer-only lines, since they require
*    less processing time and are more common (CAD programs will probably
*    only ever give integer lines).  GDI does not provide a flag saying
*    that all lines in a path are integer lines; consequently, you will
*    have to explicitly check every line.
*
* 2) You are required to correctly draw any line in the 28.4 device
*    space that intersects the viewport.  If you have less than 32 bits
*    of significance in the hardware for the Bresenham terms, extremely
*    long lines would overflow the hardware.  For such (rare) cases, you
*    can fall back to strip-drawing code, of which there is a C version in
*    the S3's lines.cxx (or if your display is a frame buffer, fall back
*    to the engine).
*
* 3) If you can explicitly set the Bresenham terms in your hardware, you
*    can draw non-integer lines using the hardware.  If your hardware has
*    'n' bits of precision, you can draw GIQ lines that are up to 2^(n-5)
*    pels long (4 bits are required for the fractional part, and one bit is
*    used as a sign bit).  Note that integer lines don't require the 4
*    fractional bits, so if you special case them as in 1), you can do
*    integer lines that are up to 2^(n - 1) pels long.  See the S3's
*    fastline.asm for an example.
*
\**************************************************************************/

BOOL bLines(
PDEV*	   ppdev,
POINTFIX*  pptfxFirst,  // Start of first line
POINTFIX*  pptfxBuf,    // Pointer to buffer of all remaining lines
RUN*       prun,        // Pointer to runs if doing complex clipping
ULONG      cptfx,       // Number of points in pptfxBuf or number of runs
                        // in prun
LINESTATE* pls,         // Colour and style info
RECTL*     prclClip,    // Pointer to clip rectangle if doing simple clipping
PFNSTRIP   apfn[],      // Array of strip functions
FLONG      flStart)     // Flags for each line
{

    ULONG     M0;
    ULONG     dM;
    ULONG     N0;
    ULONG     dN;
    ULONG     dN_Original;
    FLONG     fl;
    LONG      x;
    LONG      y;

    LONGLONG     eqBeta;
    LONGLONG     eqGamma;
    LONGLONG     euq;
    LONGLONG     eq;

    ULONG     ulDelta;

    ULONG     x0;
    ULONG     y0;
    ULONG     x1;
    ULONG     cStylePels;    // Major length of line in pixels for styling
    ULONG     xStart;
    POINTL    ptlStart;
    STRIP     strip;
    PFNSTRIP  pfn;
    LONG      cPels;
    LONG*     plStrip;
    LONG*     plStripEnd;
    LONG      cStripsInNextRun;

    POINTFIX* pptfxBufEnd = pptfxBuf + cptfx; // Last point in path record
    STYLEPOS  spThis;                         // Style pos for this line


    do {

/***********************************************************************\
* Start the DDA calculations.                                           *
\***********************************************************************/

        M0 = (LONG) pptfxFirst->x;
        dM = (LONG) pptfxBuf->x;

        N0 = (LONG) pptfxFirst->y;
        dN = (LONG) pptfxBuf->y;

        fl = flStart;

	// Check for non-clipped, non-styled integer endpoint lines - ECR

        if ( ( (fl & (FL_CLIP | FL_STYLED))  == 0 ) &&
	     ( ((M0 | dM | N0 | dN) & (F-1)) == 0 ) )
	{
          if (bIntegerLine(ppdev, M0, N0, dM, dN))
          {
	     goto Next_Line;
          }
        }
	
        if ((LONG) M0 > (LONG) dM)
        {
        // Ensure that we run left-to-right:

            register ULONG ulTmp;
            SWAPL(M0, dM, ulTmp);
            SWAPL(N0, dN, ulTmp);
            fl |= FL_FLIP_H;
        }

    // Compute the deltas:

        dM -= M0;
        dN -= N0;

    // We now have a line running left-to-right from (M0, N0) to
    // (M0 + dM, N0 + dN):

        if ((LONG) dN < 0)
        {
        // Line runs from bottom to top, so flip across y = 0:

            N0 = -(LONG) N0;
            dN = -(LONG) dN;
            fl |= FL_FLIP_V;
        }

        if (dN >= dM)
        {
            if (dN == dM)
            {
            // Have to special case slopes of one:

                fl |= FL_FLIP_SLOPE_ONE;
            }
            else
            {
            // Since line has slope greater than 1, flip across x = y:

                register ULONG ulTmp;
                SWAPL(dM, dN, ulTmp);
                SWAPL(M0, N0, ulTmp);
                fl |= FL_FLIP_D;
            }
        }

        fl |= gaflRound[(fl & FL_ROUND_MASK) >> FL_ROUND_SHIFT];

        x = LFLOOR((LONG) M0);
        y = LFLOOR((LONG) N0);

        M0 = FXFRAC(M0);
        N0 = FXFRAC(N0);

    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ]:

        {
        // eqGamma = dM * (N0 + F/2);

            eqGamma = Int32x32To64(dM, N0 + F/2);

        // eq = M0 * dN;

            eq = Int32x32To64(M0, dN);

            eqGamma -= eq;

            if (fl & FL_V_ROUND_DOWN)   // Adjust so y = 1/2 rounds down
            {
                eqGamma--;
            }

            eqGamma >>= FLOG2;

            eqBeta = ~eqGamma;
        }


/***********************************************************************\
* Figure out which pixels are at the ends of the line.                  *
\***********************************************************************/

    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'.
    //
    // For lines that go left-to-right, we have the following grid:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 xxxxxxxx?.......
    //   |   1 xxxxxxx.........
    //   |   2 xxxxxx..........
    //   |   3 xxxxx...........
    //   |   4 xxxx............
    //   |   5 xxx.............
    //   |   6 xx..............
    //   |   7 x...............
    //   |   8 x...............
    //   |   9 x.....**........
    //   |   a xx......****....
    //   |   b xxx.........****
    //   |   c xxxx............****
    //   |   d xxxxx...........    ****
    //   |   e xxxxxx..........        ****
    //   |   f xxxxxxx.........
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 0.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) - 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one must be handled similarly to the right-to-
    // left case.

        {

        // Calculate x0, x1

            ULONG N1 = FXFRAC(N0 + dN);
	    ULONG M1 = FXFRAC(M0 + dM);

	    x1 = LFLOOR(M0 + dM);

            if (fl & FL_FLIP_H)
            {
            // ---------------------------------------------------------------
            // Line runs right-to-left:  <----

            // Compute x1:

                if (N1 == 0)
                {
                    if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                    {
                        x1++;
                    }
                }
                else if (ABS((LONG) (N1 - F/2)) + M1 > F)
                {
                    x1++;
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                       == (FL_FLIP_SLOPE_ONE))
                {
                // Have to special-case diagonal lines going through our
                // the point exactly equidistant between two horizontal
                // pixels, if we're supposed to round x=1/2 down:

                    if ((N1 > 0) && (M1 == N1 + 8))
                        x1++;

                // Don't you love special cases?  Is this a rhetorical question?

                    if ((M0 > 0) && (N0 == M0 + 8))
                    {
                        x0      = 2;
                        ulDelta = dN;
                        goto right_to_left_compute_y0;
                    }
                }

            // Compute x0:

                x0      = 1;
                ulDelta = 0;
                if (N0 == 0)
                {
                    if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                    {
                        x0      = 2;
                        ulDelta = dN;
                    }
                }
                else if (ABS((LONG) (N0 - F/2)) + M0 > F)
                {
                    x0      = 2;
                    ulDelta = dN;
                }

            // Compute y0:

            right_to_left_compute_y0:

                y0 = 0;

                eq = eqGamma + ulDelta;

                if ((eq>>32) >= 0)
                {
                    if ((eq>>32) > 0 || (ULONG) eq >= 2 * dM - dN)
                        y0 = 2;
                    else if ((ULONG) eq >= dM - dN)
                        y0 = 1;
                }
            }
            else
            {
            // ---------------------------------------------------------------
            // Line runs left-to-right:  ---->

            // Compute x1:

                x1--;

                if (M1 > 0)
                {
                    if (N1 == 0)
                    {
                        if (LROUND(M1, fl & FL_H_ROUND_DOWN))
                            x1++;
                    }
                    else if (ABS((LONG) (N1 - F/2)) <= (LONG) M1)
                    {
                        x1++;
                    }
                }

                if ((fl & (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                       == (FL_FLIP_SLOPE_ONE | FL_H_ROUND_DOWN))
                {
                // Have to special-case diagonal lines going through our
                // the point exactly equidistant between two horizontal
                // pixels, if we're supposed to round x=1/2 down:

                    if ((N1 > 0) && (M1 == N1 + 8))
                        x1--;

                    if ((M0 > 0) && (N0 == M0 + 8))
                    {
                        x0 = 0;
                        goto left_to_right_compute_y0;
                    }
                }

            // Compute x0:

                x0 = 0;
                if (M0 > 0)
                {
                    if (N0 == 0)
                    {
                        if (LROUND(M0, fl & FL_H_ROUND_DOWN))
                            x0 = 1;
                    }
                    else if (ABS((LONG) (N0 - F/2)) <= (LONG) M0)
                    {
                        x0 = 1;
                    }
                }

            // Compute y0:

            left_to_right_compute_y0:

                y0 = 0;
                if ((eqGamma>>32) >= 0 &&
                    (ULONG) eqGamma >= dM - (dN & (-(LONG) x0)))
                {
                    y0 = 1;
                }
            }
        }

        cStylePels = x1 - x0 + 1;
        if ((LONG) cStylePels <= 0)
            goto Next_Line;

        xStart = x0;

/***********************************************************************\
* Complex clipping.                                                     *
\***********************************************************************/
#ifdef SIMPLE_CLIP
        if (fl & FL_COMPLEX_CLIP)
#else
        if (fl & FL_CLIP)
#endif // SIMPLE_CLIP
        {
            dN_Original = dN;

        Continue_Complex_Clipping:

            if (fl & FL_FLIP_H)
            {
            // Line runs right-to-left <-----

                x0 = xStart + cStylePels - prun->iStop - 1;
                x1 = xStart + cStylePels - prun->iStart - 1;
            }
            else
            {
            // Line runs left-to-right ----->

                x0 = xStart + prun->iStart;
                x1 = xStart + prun->iStop;
            }

            prun++;

        // Reset some variables we'll nuke a little later:

            dN          = dN_Original;
            pls->spNext = pls->spComplex;

        // No overflow since large integer math is used.  Both values
        // will be positive:

        // euq = x0 * dN:

            euq = Int32x32To64(x0, dN);

            euq += eqGamma:

        // y0 = euq / dM:

            y0 = DIVREM(euq, dM, NULL);

            ASSERTDD((LONG) y0 >= 0, "y0 weird: Goofed up end pel calc?");
        }

/////////////////////////////////////////////////////////////////////////
// The following clip code works great -- we simply aren't using it yet.
/////////////////////////////////////////////////////////////////////////

#ifdef SIMPLE_CLIP
/***********************************************************************\
* Simple rectangular clipping.                                          *
\***********************************************************************/

        if (fl & FL_SIMPLE_CLIP)
        {
            ULONG y1;
            LONG  xRight;
            LONG  xLeft;
            LONG  yBottom;
            LONG  yTop;

        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.

            RECTL* prcl = &prclClip[(fl & FL_RECTLCLIP_MASK) >>
                                    FL_RECTLCLIP_SHIFT];

        // Normalize to the same point we've normalized for the DDA
        // calculations:

            xRight  = prcl->right  - x;
            xLeft   = prcl->left   - x;
            yBottom = prcl->bottom - y;
            yTop    = prcl->top    - y;

            if (yBottom <= (LONG) y0 ||
                xRight  <= (LONG) x0 ||
                xLeft   >  (LONG) x1)
            {
            Totally_Clipped:

                if (fl & FL_STYLED)
                {
                    pls->spNext += cStylePels;
                    if (pls->spNext >= pls->spTotal2)
                        pls->spNext %= pls->spTotal2;
                }

                goto Next_Line;
            }

            if ((LONG) x1 >= xRight)
                x1 = xRight - 1;

        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).

        // euq = x1 * dN;

            euq = Int32x32To64(x1, dN);

            euq += eqGamma;

        // y1 = euq / dM:

            y1 = DIVREM(euq, dM, NULL);

            if (yTop > (LONG) y1)
                goto Totally_Clipped;

            if (yBottom <= (LONG) y1)
            {
                y1 = yBottom;

            // euq = y1 * dM;

                euq = Int32x32To64(y1, dM);

                euq += eqBeta;

            // x1 = euq / dN:

                x1 = DIVREM(euq, dN, NULL);
            }

        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:

            if (xLeft > (LONG) x0)
            {
                x0 = xLeft;

            // euq = x0 * dN;

                euq = Int32x32To64(x0, dN);

                euq += eqGamma;

            // y0 = euq / dM;

                y0 = DIVREM(euq, dM, NULL);

                if (yBottom <= (LONG) y0)
                    goto Totally_Clipped;
            }

            if (yTop > (LONG) y0)
            {
                y0 = yTop;

            // euq = y0 * dM;

                euq = Int32x32To64(y0, dM);

                euq += eqBeta;

            // x0 = euq / dN + 1;

                x0 = DIVREM(euq, dN) + 1;

                if (xRight <= (LONG) x0)
                    goto Totally_Clipped;
            }

            ASSERTDD(x0 <= x1, "Improper rectangle clip");
        }
#endif // SIMPLE_CLIP

/***********************************************************************\
* Done clipping.  Unflip if necessary.                                 *
\***********************************************************************/

        ptlStart.x = x + x0;
        ptlStart.y = y + y0;

        if (fl & FL_FLIP_D)
        {
            register LONG lTmp;
            SWAPL(ptlStart.x, ptlStart.y, lTmp);
        }


        if (fl & FL_FLIP_V)
        {
            ptlStart.y = -ptlStart.y;
        }

        cPels = x1 - x0 + 1;

/***********************************************************************\
* Style calculations.                                                   *
\***********************************************************************/

        if (fl & FL_STYLED)
        {
            STYLEPOS sp;

            spThis       = pls->spNext;
            pls->spNext += cStylePels;

            {
                if (pls->spNext >= pls->spTotal2)
                    pls->spNext %= pls->spTotal2;

                if (fl & FL_FLIP_H)
                    sp = pls->spNext - x0 + xStart;
                else
                    sp = spThis + x0 - xStart;

                ASSERTDD(fl & FL_ARBITRARYSTYLED, "Oops");

            // Normalize our target style position:

                if ((sp < 0) || (sp >= pls->spTotal2))
                {
                    sp %= pls->spTotal2;

                // The modulus of a negative number is not well-defined
                // in C -- if it's negative we'll adjust it so that it's
                // back in the range [0, spTotal2):

                    if (sp < 0)
                        sp += pls->spTotal2;
                }

            // Since we always draw the line left-to-right, but styling is
            // always done in the direction of the original line, we have
            // to figure out where we are in the style array for the left
            // edge of this line.

                if (fl & FL_FLIP_H)
                {
                // Line originally ran right-to-left:

                    sp = -sp;
                    if (sp < 0)
                        sp += pls->spTotal2;

                    pls->ulStyleMask = ~pls->ulStartMask;
                    pls->pspStart    = &pls->aspRtoL[0];
                    pls->pspEnd      = &pls->aspRtoL[pls->cStyle - 1];
                }
                else
                {
                // Line originally ran left-to-right:

                    pls->ulStyleMask = pls->ulStartMask;
                    pls->pspStart    = &pls->aspLtoR[0];
                    pls->pspEnd      = &pls->aspLtoR[pls->cStyle - 1];
                }

                if (sp >= pls->spTotal)
                {
                    sp -= pls->spTotal;
                    if (pls->cStyle & 1)
                        pls->ulStyleMask = ~pls->ulStyleMask;
                }

                pls->psp = pls->pspStart;
                while (sp >= *pls->psp)
                    sp -= *pls->psp++;

                ASSERTDD(pls->psp <= pls->pspEnd,
                        "Flew off into NeverNeverLand");

                pls->spRemaining = *pls->psp - sp;
                if ((pls->psp - pls->pspStart) & 1)
                    pls->ulStyleMask = ~pls->ulStyleMask;
            }
        }

        plStrip    = &strip.alStrips[0];
        plStripEnd = &strip.alStrips[STRIP_MAX];    // Is exclusive
        cStripsInNextRun   = 0x7fffffff;

	strip.ptlStart = ptlStart;

        if (2 * dN > dM &&
            !(fl & FL_STYLED) &&
            !(fl & FL_DONT_DO_HALF_FLIP))
        {
        // Do a half flip!  Remember that we may doing this on the
        // same line multiple times for complex clipping (meaning the
        // affected variables should be reset for every clip run):

            fl |= FL_FLIP_HALF;

            eqBeta  = eqGamma;

            eqBeta -= dM;

            dN = dM - dN;
            y0 = x0 - y0;       // Note this may overflow, but that's okay
        }

    // Now, run the DDA starting at (ptlStart.x, ptlStart.y)!

        strip.flFlips = fl;
        pfn           = apfn[(fl & FL_STRIP_MASK) >> FL_STRIP_SHIFT];

    // Now calculate the DDA variables needed to figure out how many pixels
    // go in the very first strip:

        {
            register LONG  i;
            register ULONG dI;
            register ULONG dR;
                     ULONG r;

            if (dN == 0)
                i = 0x7fffffff;
            else
            {
            // euq = (y0 + 1) * dM;

                euq = Int32x32To64((y0 + 1), dM);

            // euq += eqBeta;

                euq += eqBeta;

            #if DBG
                if (euq < 0)
                {
                    RIP("Oops!");
                }
            #endif

            // i = (euq / dN) - x0 + 1;
            // r = (euq % dN);

                i = DIVREM(euq, dN, &r);
                i = i - x0 + 1;

                dI = dM / dN;
                dR = dM % dN;               // 0 <= dR < dN

                ASSERTDD(dI > 0, "Weird dI");
            }

            ASSERTDD(i > 0 && i <= 0x7fffffff, "Weird initial strip length");
            ASSERTDD(cPels > 0, "Zero pel line");

/***********************************************************************\
* Run the DDA!                                                          *
\***********************************************************************/

            while(TRUE)
            {
                cPels -= i;
                if (cPels <= 0)
                    break;

                *plStrip++ = i;

                if (plStrip == plStripEnd)
                {
                    strip.cStrips = plStrip - &strip.alStrips[0];
                    (*pfn)(ppdev, &strip, pls);
                    plStrip = &strip.alStrips[0];
                }

                i = dI;
                r += dR;

                if (r >= dN)
                {
                    r -= dN;
                    i++;
                }
            }

            *plStrip++ = cPels + i;

            strip.cStrips = plStrip - &strip.alStrips[0];
            (*pfn)(ppdev, &strip, pls);


        }

    Next_Line:

        if (fl & FL_COMPLEX_CLIP)
        {
            cptfx--;
            if (cptfx != 0)
                goto Continue_Complex_Clipping;

            break;
        }
        else
        {
            pptfxFirst = pptfxBuf;
            pptfxBuf++;
        }

    } while (pptfxBuf < pptfxBufEnd);

    return(TRUE);

}

#ifdef HARDWAREGIQ

/////////////////////////////////////////////////////////////////////////
// The following GIQ code works great -- we simply aren't using it yet.
/////////////////////////////////////////////////////////////////////////

typedef struct _DDALINE         /* dl */
{
    LONG      iDir;
    POINTL    ptlStart;
    LONG      cPels;
    LONG      dMajor;
    LONG      dMinor;
    LONG      lErrorTerm;
} DDALINE;

#define HW_FLIP_D           0x0001L     // Diagonal flip
#define HW_FLIP_V           0x0002L     // Vertical flip
#define HW_FLIP_H           0x0004L     // Horizontal flip
#define HW_FLIP_SLOPE_ONE   0x0008L     // Normalized line has exactly slope one
#define HW_FLIP_MASK        (HW_FLIP_D | HW_FLIP_V | HW_FLIP_H)

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

LONG gaiDir[] = { 0, 1, 7, 6, 3, 2, 4, 5 };

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

/******************************Public*Routine******************************\
* BOOL bHardwareLine(pptfxStart, pptfxEnd, cBits, pdl)
*
* This routine is useful for folks who have line drawing hardware where
* they can explicitly set the Bresenham terms -- they can use this routine
* to draw fractional coordinate GIQ lines with the hardware.
*
* Fractional coordinate lines require an extra 4 bits of precision in the
* Bresenham terms.  For example, if your hardware has 13 bits of precision
* for the terms, you can only draw GIQ lines up to 255 pels long using this
* routine.
*
* Input:
*   pptfxStart  - Points to GIQ coordinate of start of line
*   pptfxEnd    - Points to GIQ coordinate of end of line
*   cBits       - The number of bits of precision your hardware can support.
*
* Output:
*   returns     - TRUE if the line can be drawn directly using the line
*                 hardware (in which case pdl contains the Bresenham terms
*                 for drawing the line).
*                 FALSE if the line is too long, and the strips code must be
*                 used.
*   pdl         - Returns the Bresenham line terms for drawing the line.
*
* DDALINE:
*   iDir        - Direction of the line, as an octant numbered as follows:
*
*                    \ 5 | 6 /
*                     \  |  /
*                    4 \ | / 7
*                       \ /
*                   -----+-----
*                       /|\
*                    3 / | \ 0
*                     /  |  \
*                    / 2 | 1 \
*
*   ptlStart    - Start pixel of line.
*   cPels       - # of pels in line.  *NOTE* You must check if this is <= 0!
*   dMajor      - Major axis delta.
*   dMinor      - Minor axis delta.
*   lErrorTerm  - Error term.
*
* What you do with the last 3 terms may be a little tricky.  They are
* actually the terms for the formula of the normalized line
*
*                     dMinor * x + (lErrorTerm + dMajor)
*       y(x) = floor( ---------------------------------- )
*                                  dMajor
*
* where y(x) is the y coordinate of the pixel to be lit as a function of
* the x-coordinate.
*
* Every time the line advances one in the major direction 'x', dMinor
* gets added to the current error term.  If the resulting value is >= 0,
* we know we have to move one pixel in the minor direction 'y', and
* dMajor must be subtracted from the current error term.
*
* If you're trying to figure out what this means for your hardware, you can
* think of the DDALINE terms as having been computed equivalently as
* follows:
*
*     pdl->dMinor     = 2 * (minor axis delta)
*     pdl->dMajor     = 2 * (major axis delta)
*     pdl->lErrorTerm = - (major axis delta) - fixup
*
* That is, if your documentation tells you that for integer lines, a
* register is supposed to be initialized with the value
* '2 * (minor axis delta)', you'll actually use pdl->dMinor.
*
* Example: Setting up the 8514
*
*     AXSTPSIGN is supposed to be the axial step constant register, defined
*     as 2 * (minor axis delta).  You set:
*
*           AXSTPSIGN = pdl->dMinor
*
*     DGSTPSIGN is supposed to be the diagonal step constant register,
*     defined as 2 * (minor axis delta) - 2 * (major axis delta).  You set:
*
*           DGSTPSIGN = pdl->dMinor - pdl->dMajor
*
*     ERR_TERM is supposed to be the adjusted error term, defined as
*     2 * (minor axis delta) - (major axis delta) - fixup.  You set:
*
*           ERR_TERM = pdl->lErrorTerm + pdl->dMinor
*
* Implementation:
*
*     You'll want to special case integer lines before calling this routine
*     (since they're very common, take less time to the computation of line
*     terms, and can handle longer lines than this routine because 4 bits
*     aren't being given to the fraction).
*
*     If a GIQ line is too long to be handled by this routine, you can just
*     use the slower strip routines for that line.  Note that you cannot
*     just fail the call -- you must be able to accurately draw any line
*     in the 28.4 device space when it intersects the viewport.
*
* Testing:
*
*     Use Guiman, or some other test that draws random fractional coordinate
*     lines and compares them to what GDI itself draws to a bitmap.
*
\**************************************************************************/

BOOL bHardwareLine(
POINTFIX* pptfxStart,       // Start of line
POINTFIX* pptfxEnd,         // End of line
LONG      cBits,            // # bits precision in hardware Bresenham terms
DDALINE*  pdl)              // Returns Bresenham terms for doing line
{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end pixel (inclusive)
    LONG  lGamma;// Bresenham error term at origin

/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
    // Line runs from right to left, so flip across x = 0:

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= HW_FLIP_H;
    }

// Compute the delta.  The DDI says we can never have a valid delta
// with a magnitude more than 2^31 - 1, but the engine never actually
// checks its transforms.  To ensure that we'll never puke on our shoes,
// we check for that case and simply refuse to draw the line:

    dM -= M0;
    if ((LONG) dM < 0)
        return(FALSE);

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {
    // Line runs from bottom to top, so flip across y = 0:

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= HW_FLIP_V;
    }

// Compute another delta:

    dN -= N0;
    if ((LONG) dN < 0)
        return(FALSE);

    if (dN >= dM)
    {
        if (dN == dM)
        {
        // Have to special case slopes of one:

            fl |= HW_FLIP_SLOPE_ONE;
        }
        else
        {
        // Since line has slope greater than 1, flip across x = y:

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= HW_FLIP_D;
        }
    }

// Figure out if we can do the line in hardware, given that we have a
// limited number of bits of precision for the Bresenham terms.
//
// Remember that one bit has to be kept as a sign bit:

    if ((LONG) dM >= (1L << (cBits - 1)))
        return(FALSE);

    fl |= gaflHardwareRound[fl];

/***********************************************************************\
* Calculate the error term at pixel 0.
\***********************************************************************/

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);

    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

// NOTE NOTE NOTE: If this routine were to handle any line in the 28.4
// space, it will overflow its math (the following part requires 36 bits
// of precision)!  But we get here for lines that the hardware can handle
// (see the expression (dM >= (1L << (cBits - 1))) above?), so if cBits
// is less than 28, we're safe.
//
// If you're going to use this routine to handle all lines in the 28.4
// device space, you will HAVE to make sure the math doesn't overflow,
// otherwise you won't be NT compliant!  (See lines.cxx for an example
// how to do that.  You don't have to worry about this if you simply
// default to the strips code for long lines, because those routines
// already do the math correctly.)

// Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
// that M0 and N0 have at most 4 bits of significance (and if the
// arguments are properly ordered, on a 486 each multiply would be no
// more than 13 cycles):

    lGamma = (N0 + F/2) * dM - M0 * dN;

    if (fl & HW_Y_ROUND_DOWN)
        lGamma--;

    lGamma >>= FLOG2;

/***********************************************************************\
* Figure out which pixels are at the ends of the line.
\***********************************************************************/

// The toughest part of GIQ is determining the start and end pels.
//
// Our approach here is to calculate x0 and x1 (the inclusive start
// and end columns of the line respectively, relative to our normalized
// origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
// start point is easily calculated by plugging x0 into our line equation
// (which takes care of whether y = 1/2 rounds up or down in value)
// getting y0, and then undoing the normalizing flips to get back
// into device space.
//
// We look at the fractional parts of the coordinates of the start and
// end points, and call them (M0, N0) and (M1, N1) respectively, where
// 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
// to determine x0:
//
//   +-----------------------> +x
//   |
//   | 0                     1
//   |     0123456789abcdef
//   |
//   |   0 ........?xxxxxxx
//   |   1 ..........xxxxxx
//   |   2 ...........xxxxx
//   |   3 ............xxxx
//   |   4 .............xxx
//   |   5 ..............xx
//   |   6 ...............x
//   |   7 ................
//   |   8 ................
//   |   9 ......**........
//   |   a ........****...x
//   |   b ............****
//   |   c .............xxx****
//   |   d ............xxxx    ****
//   |   e ...........xxxxx        ****
//   |   f ..........xxxxxx
//   |
//   | 2                     3
//   v
//
//   +y
//
// This grid accounts for the appropriate rounding of GIQ and last-pel
// exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
// on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// For the end point, if (M1, N1) lands on an 'x', x1 =
// floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
// floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
// depending on what flips have been done to normalize the line.
//
// Lines of exactly slope one require a special case for both the start
// and end.  For example, if the line ends such that (M1, N1) is (9, 1),
// the line has gone exactly through (8, 0) -- which may be considered
// to be part of 'x' because of rounding!  So slopes of exactly slope
// one going through (8, 0) must also be considered as belonging in 'x'
// when an x value of 1/2 is supposed to round up in value.

// Calculate x0, x1:

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

// Line runs left-to-right:

// Compute x1:

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (ABS((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (HW_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {
    // Have to special-case diagonal lines going through our
    // the point exactly equidistant between two horizontal
    // pixels, if we're supposed to round x=1/2 down:

        if ((N1 > 0) && (M1 == N1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

// Compute x0:

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (ABS((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:

/***********************************************************************\
* Calculate the start pixel.
\***********************************************************************/

// We now compute y0 and adjust the error term.  We know x0, and we know
// the current formula for the pixels to be lit on the line:
//
//                     dN * x + lGamma
//       y(x) = floor( --------------- )
//                           dM
//
// The remainder of this expression is the new error term at (x0, y0).
// Since x0 is going to be either 0 or 1, we don't actually have to do a
// multiply or divide to compute y0.  Finally, we subtract dM from the
// new error term so that it is in the range [-dM, 0).

    y0      = 0;
    lGamma += (dN & (-x0));
    lGamma -= dM;
    if (lGamma >= 0)
    {
        y0      = 1;
        lGamma -= dM;
    }

// Undo our flips to get the start coordinate:

    x += x0;
    y += y0;

    if (fl & HW_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & HW_FLIP_V)
    {
        y = -y;
    }

    if (fl & HW_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    pdl->iDir       = gaiDir[fl & HW_FLIP_MASK];
    pdl->ptlStart.x = x;
    pdl->ptlStart.y = y;
    pdl->cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    pdl->dMajor     = dM;
    pdl->dMinor     = dN;
    pdl->lErrorTerm = lGamma;

    return(TRUE);
}

#endif // HARDWAREGIQ
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\lines.h ===
/******************************Module*Header*******************************\
* Module Name: lines.h
*
* Line drawing constants and structures.
*
* NOTE: This file mirrors LINES.INC.  Changes here must be reflected in
* the .inc file!
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

typedef struct _PDEV PDEV;      // Handy forward declaration

// We have to be careful that we don't overflow any registers when using
// the hardware to draw lines (as opposed to going through the strips
// routines, which will never overflow).  We accomplish this by simply
// checking the bounds of the path; if it is so large that any of the
// hardware terms may overflow, we punt the entire path to the strips
// code (should be pretty rare).

#define MAX_INTEGER_BOUND  (1535)   // S3's line length term is limited to
#define MIN_INTEGER_BOUND  (-512)   //   a maximum value of 2047

// We have special strip routines when all strips have at most this many
// pixels:

#define MAX_SHORT_STROKE_LENGTH 15

// # of strip drawers in every group:

#define NUM_STRIP_DRAW_DIRECTIONS 4

// # of strip drawers for doing either solid lines or styled lines:

#define NUM_STRIP_DRAW_STYLES 8

typedef LONG STYLEPOS;

#define STYLE_MAX_COUNT     16
#define STYLE_MAX_VALUE     0x3fffL
#define RUN_MAX             20
#define STRIP_MAX           100
#define STYLE_DENSITY       3

// Flip and round flags:

#define FL_H_ROUND_DOWN         0x00000080L     // .... .... 1... ....
#define FL_V_ROUND_DOWN         0x00000100L     // .... ...1 .... ....

#define FL_FLIP_D               0x00000005L     // .... .... .... .1.1
#define FL_FLIP_V               0x00000008L     // .... .... .... 1...
#define FL_FLIP_SLOPE_ONE       0x00000010L     // .... .... ...1 ....
#define FL_FLIP_HALF            0x00000002L     // .... .... .... ..1.
#define FL_FLIP_H               0x00000200L     // .... ..1. .... ....

#define FL_ROUND_MASK           0x0000001CL     // .... .... ...1 11..
#define FL_ROUND_SHIFT          2

#define FL_RECTLCLIP_MASK       0x0000000CL     // .... .... .... 11..
#define FL_RECTLCLIP_SHIFT      2

#define FL_STRIP_MASK           0x00000003L     // .... .... .... ..11
#define FL_STRIP_SHIFT          0

#define FL_SIMPLE_CLIP          0x00000020      // .... .... ..1. ....
#define FL_COMPLEX_CLIP         0x00000040      // .... .... .1.. ....
#define FL_CLIP                (FL_SIMPLE_CLIP | FL_COMPLEX_CLIP)

#define FL_ARBITRARYSTYLED      0x00000400L     // .... .1.. .... ....
#define FL_MASKSTYLED           0x00000800L     // .... 1... .... ....
#define FL_STYLED              (FL_ARBITRARYSTYLED | FL_MASKSTYLED)
#define FL_ALTERNATESTYLED      0x00001000L     // ...1 .... .... ....

#define FL_STYLE_MASK           0x00000C00L
#define FL_STYLE_SHIFT          10

// Simpler flag bits in high byte:

#define FL_DONT_DO_HALF_FLIP    0x00002000L     // ..1. .... .... ....
#define FL_PHYSICAL_DEVICE      0x00004000L     // .1.. .... .... ....

// Miscellaneous DDA defines:

#define LROUND(x, flRoundDown) (((x) + F/2 - ((flRoundDown) > 0)) >> 4)
#define F                     16
#define FLOG2                 4
#define LFLOOR(x)             ((x) >> 4)
#define FXFRAC(x)             ((x) & (F - 1))

////////////////////////////////////////////////////////////////////////////
// NOTE: The following structures must exactly match those declared in
//       lines.inc!

typedef struct _STRIP {
    LONG   cStrips;               // # of strips in array
    LONG   flFlips;               // Indicates if line goes up or down
    POINTL ptlStart;             // first point
    LONG   alStrips[STRIP_MAX];   // Array of strips
} STRIP;

typedef struct _LINESTATE {
    STYLEPOS*       pspStart;       // Pointer to start of style array
    STYLEPOS*       pspEnd;         // Pointer to end of style array
    STYLEPOS*       psp;            // Pointer to current style entry

    STYLEPOS        spRemaining;    // To go in current style
    STYLEPOS        spTotal;        // Sum of style array
    STYLEPOS        spTotal2;       // Twice sum of style array
    STYLEPOS        spNext;         // Style state at start of next line
    STYLEPOS        spComplex;      // Style state at start of complex clip line

    STYLEPOS*       aspRtoL;        // Style array in right-to-left order
    STYLEPOS*       aspLtoR;        // Style array in left-to-right order

    ULONG           ulStyleMask;    // Are we working on a gap in the style?
                                    // 0xff if yes, 0x0 if not
    ULONG           xyDensity;      // Density of style
    ULONG           cStyle;         // Size of style array

    ULONG           ulStyleMaskLtoR;// Original style mask, left-to-right order
    ULONG           ulStyleMaskRtoL;// Original style mask, right-to-left order

    BOOL            ulStartMask;    // Determines if first element in style
                                    // array is for a gap or a dash

} LINESTATE;                        /* ls */

// Strip drawer prototype:

typedef VOID (*PFNSTRIP)(PDEV*, STRIP*, LINESTATE*);

// Strip drawers:

VOID vssSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vssSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vrlSolidDiagonalVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

VOID vStripStyledHorizontal(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);
VOID vStripStyledVertical(PDEV* ppdev, STRIP *pStrip, LINESTATE *pLineState);

// External calls:

BOOL bLines(PDEV*, POINTFIX*, POINTFIX*, RUN* prun, ULONG,
            LINESTATE*, RECTL*, PFNSTRIP*, FLONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#include "lines.h"
#include "driver.h"
#include "hw.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* Copyright (c) 1993-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* BOOL DrvStretchBlt
*
\**************************************************************************/

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    DSURF*  pdsurfSrc;
    DSURF*  pdsurfDst;
    PDEV*   ppdev;

    ppdev = (PDEV*) psoDst->dhpdev;

    // It's quicker for GDI to do a StretchBlt when the source surface
    // is not a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.
    //
    // So if the source is one of our off-screen DFBs, we'll immediately
    // and permanently convert it to a DIB:

    if (psoSrc->iType == STYPE_DEVBITMAP)
    {
        pdsurfSrc = (DSURF*) psoSrc->dhsurf;
        if (pdsurfSrc->dt == DT_SCREEN)
        {
            if (!pohMoveOffscreenDfbToDib(ppdev, pdsurfSrc->poh))
                return(FALSE);
        }

        ASSERTDD(pdsurfSrc->dt == DT_DIB, "Can only handle DIB DFBs here");

        psoSrc = pdsurfSrc->pso;
    }

    // Pass the call off to GDI if the destination surface is a device
    // bitmap that we converted to a DIB:

    pdsurfDst = (DSURF*) psoDst->dhsurf;
    if (pdsurfDst->dt == DT_DIB)
    {
        psoDst = pdsurfDst->pso;
        goto Punt_It;
    }

    #if 0   // I would enable this chunk of code, except for the fact that
    {       // GDI does byte writes to the screen, which kills us on ISA
            // buses (it's faster to have GDI write to a temporary DIB,
            // paying the cost of the DIB allocation, and then doing an
            // aligned copy of the final result).

        #if defined(i386)
        {
            OH*     poh;
            BANK    bnk;
            BOOL    b;
            RECTL   rclDraw;

            // Make sure we're not doing a screen-to-screen StretchBlt,
            // because we can't map two banks in at the same time:

            if (psoSrc->iType == STYPE_BITMAP)
            {
                // We'll be drawing to the screen or an off-screen DFB;
                // copy the surface's offset now so that we won't need
                // to refer to the DSURF again:

                poh = pdsurfDst->poh;
                ppdev->xOffset = poh->x;
                ppdev->yOffset = poh->y;

                // The bank manager requires that the 'draw' rectangle be
                // well-ordered:

                rclDraw = *prclDst;
                if (rclDraw.left > rclDraw.right)
                {
                    rclDraw.left   = prclDst->right;
                    rclDraw.right  = prclDst->left;
                }
                if (rclDraw.top > rclDraw.bottom)
                {
                    rclDraw.top    = prclDst->bottom;
                    rclDraw.bottom = prclDst->top;
                }

                vBankStart(ppdev, &rclDraw, pco, &bnk);

                b = TRUE;
                do {
                    b &= EngStretchBlt(bnk.pso, psoSrc, psoMsk, bnk.pco,
                                       pxlo, pca, pptlHTOrg, prclDst,
                                       prclSrc, pptlMsk, iMode);

                } while (bBankEnum(&bnk));

                return(b);
            }
        }
        #endif // i386
    }
    #endif // 0

Punt_It:

    // GDI is nice enough to handle the cases where 'psoDst' and/or 'psoSrc'
    // are device-managed surfaces, but it ain't gonna be fast...

    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\strips.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* All the line code in this driver amounts to a big bag of dirt.  Someday,
* I'm going to rewrite it all.  Not today, though (sigh)...
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vssSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using short-stroke
* vectors.  Is faster than using the radial-line routine, but only works
* when every strip is 15 pels in length or less.
*
\**************************************************************************/

VOID vssSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    xPels, xSumPels, yDir;
    USHORT  Cmd, ssCmd, dirDraw, dirSkip;

    Cmd = DRAW | WRITE | MULTIPLE_PIXELS |
          DIR_TYPE_RADIAL | LAST_PIXEL_OFF |
          BUS_SIZE_16 | BYTE_SWAP;

    cStrips = pStrip->cStrips;

    IO_FIFO_WAIT(ppdev, 3);

    IO_CUR_X(ppdev, pStrip->ptlStart.x);
    IO_CUR_Y(ppdev, pStrip->ptlStart.y);
    IO_CMD(ppdev, Cmd);

    // Setup the drawing direction and the skip direction.

    dirDraw = 0x10;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        yDir = 1;
        dirSkip = 0xC100;
    }
    else
    {
        dirSkip = 0x4100;
        yDir = -1;
    }

    // Output the short stroke commands.

    xSumPels = 0;
    pStrips = pStrip->alStrips;
    for (i = 0; i < cStrips; i++)
    {
        xPels = *pStrips++;
        xSumPels += xPels;
        ssCmd = (USHORT) (dirSkip | dirDraw | xPels);
        IO_FIFO_WAIT(ppdev, 4);
        IO_SHORT_STROKE(ppdev, ssCmd);
    }

    pStrip->ptlStart.x += xSumPels;
    pStrip->ptlStart.y += cStrips * yDir;

}

/******************************Public*Routine******************************\
* VOID vrlSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, yInc, x, y;
    PLONG   pStrips;


    Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
          LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_0 |
          WRITE;

    cStrips = pStrip->cStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    yInc = 1;
    if (pStrip->flFlips & FL_FLIP_V)
        yInc = -1;

    pStrips = pStrip->alStrips;

    for (i = 0; i < cStrips; i++)
    {
        IO_FIFO_WAIT(ppdev, 4);

        IO_CUR_X(ppdev, x);
        IO_CUR_Y(ppdev, y);
        IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
        IO_CMD(ppdev, Cmd);

        x += *pStrips++;
        y += yInc;
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vssSolidVertical
*
* Draws left-to-right y-major near-vertical lines using short-stroke
* vectors.  Is faster than using the radial-line routine, but only works
* when every strip is 15 pels in length or less.
*
\**************************************************************************/

VOID vssSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    yPels, ySumPels, yDir;
    USHORT  Cmd, ssCmd, dirDraw, dirSkip;

    Cmd = DRAW | WRITE | MULTIPLE_PIXELS |
          DIR_TYPE_RADIAL | LAST_PIXEL_OFF |
          BUS_SIZE_16 | BYTE_SWAP;

    cStrips = pStrip->cStrips;

    IO_FIFO_WAIT(ppdev, 3);

    IO_CUR_X(ppdev, pStrip->ptlStart.x);
    IO_CUR_Y(ppdev, pStrip->ptlStart.y);
    IO_CMD(ppdev, Cmd);

    // Setup the drawing direction and the skip direction.

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        yDir = 1;
        dirDraw = 0xD0;
    }
    else
    {
        yDir = -1;
        dirDraw = 0x50;
    }

    dirSkip = 0x0100;

    // Output the short stroke commands.

    ySumPels = 0;
    pStrips = pStrip->alStrips;
    for (i = 0; i < cStrips; i++)
    {
        yPels = *pStrips++;
        ySumPels += yPels;
        ssCmd = (USHORT) (dirSkip | dirDraw | yPels);
        IO_FIFO_WAIT(ppdev, 4);
        IO_SHORT_STROKE(ppdev, ssCmd);
    }

    pStrip->ptlStart.x += cStrips;
    pStrip->ptlStart.y += ySumPels * yDir;

}

/******************************Public*Routine******************************\
* VOID vrlSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y;
    PLONG   pStrips;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_270 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y += *pStrips++;
            x++;
        }

    }
    else
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_90 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y -= *pStrips++;
            x++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vssSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using short-stroke
* vectors.  Is faster than using the radial-line routine, but only
* works when every strip is 15 pels in length or less.
*
\**************************************************************************/

VOID vssSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    Pels, SumPels, yDir;
    USHORT  Cmd, ssCmd, dirDraw, dirSkip;

    Cmd = DRAW | WRITE | MULTIPLE_PIXELS |
          DIR_TYPE_RADIAL | LAST_PIXEL_OFF |
          BUS_SIZE_16 | BYTE_SWAP;

    cStrips = pStrip->cStrips;

    IO_FIFO_WAIT(ppdev, 3);

    IO_CUR_X(ppdev, pStrip->ptlStart.x);
    IO_CUR_Y(ppdev, pStrip->ptlStart.y);
    IO_CMD(ppdev, Cmd);

    // Setup the drawing direction and the skip direction.

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        yDir = 1;
        dirDraw = 0xF0;
        dirSkip = 0x4100;

    }
    else
    {
        yDir = -1;
        dirDraw = 0x30;
        dirSkip = 0xC100;

    }

    // Output the short stroke commands.

    SumPels = 0;
    pStrips = pStrip->alStrips;
    for (i = 0; i < cStrips; i++)
    {
        Pels = *pStrips++;
        SumPels += Pels;
        ssCmd = (USHORT)(dirSkip | dirDraw | Pels);
        IO_FIFO_WAIT(ppdev, 4);
        IO_SHORT_STROKE(ppdev, ssCmd);
    }

    pStrip->ptlStart.x += SumPels;
    pStrip->ptlStart.y += (SumPels - cStrips) * yDir;

}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y;
    PLONG   pStrips;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_315 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y += *pStrips - 1;
            x += *pStrips++;
        }

    }
    else
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_45 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y -= *pStrips - 1;
            x += *pStrips++;
        }
    }

    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}

/******************************Public*Routine******************************\
* VOID vssSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using short-stroke
* vectors.  Is faster than using the radial-line routine, but only
* works when every strip is 15 pels in length or less.
*
\**************************************************************************/

VOID vssSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    i, cStrips;
    PLONG   pStrips;
    LONG    Pels, SumPels, yDir;
    USHORT  Cmd, ssCmd, dirDraw, dirSkip;

    Cmd = DRAW | WRITE | MULTIPLE_PIXELS |
          DIR_TYPE_RADIAL | LAST_PIXEL_OFF |
          BUS_SIZE_16 | BYTE_SWAP;

    cStrips = pStrip->cStrips;

    IO_FIFO_WAIT(ppdev, 3);

    IO_CUR_X(ppdev, pStrip->ptlStart.x);
    IO_CUR_Y(ppdev, pStrip->ptlStart.y);
    IO_CMD(ppdev, Cmd);

    // Setup the drawing direction and the skip direction.

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        yDir = 1;
        dirDraw = 0xF0;
    }
    else
    {
        yDir = -1;
        dirDraw = 0x30;
    }

    dirSkip = 0x8100;

    // Output the short stroke commands.

    SumPels = 0;
    pStrips = pStrip->alStrips;
    for (i = 0; i < cStrips; i++)
    {
        Pels = *pStrips++;
        SumPels += Pels;
        ssCmd = (USHORT)(dirSkip | dirDraw | Pels);
        IO_FIFO_WAIT(ppdev, 4);
        IO_SHORT_STROKE(ppdev, ssCmd);
    }

    pStrip->ptlStart.x += SumPels - cStrips;
    pStrip->ptlStart.y += SumPels * yDir;

}

/******************************Public*Routine******************************\
* VOID vrlSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vrlSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    LONG    cStrips;
    USHORT  Cmd;
    LONG    i, x, y;
    PLONG   pStrips;

    cStrips = pStrip->cStrips;
    pStrips = pStrip->alStrips;

    x = pStrip->ptlStart.x;
    y = pStrip->ptlStart.y;

    if (!(pStrip->flFlips & FL_FLIP_V))
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_315 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y += *pStrips;
            x += *pStrips++ - 1;
        }

    }
    else
    {
        Cmd = DRAW_LINE      | DRAW            | DIR_TYPE_RADIAL |
              LAST_PIXEL_OFF | MULTIPLE_PIXELS | DRAWING_DIRECTION_45 |
              WRITE;

        for (i = 0; i < cStrips; i++)
        {
            IO_FIFO_WAIT(ppdev, 4);

            IO_CUR_X(ppdev, x);
            IO_CUR_Y(ppdev, y);
            IO_MAJ_AXIS_PCNT(ppdev, *pStrips);
            IO_CMD(ppdev, Cmd);

            y -= *pStrips;
            x += *pStrips++ - 1;
        }
    }


    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    LONG    x;
    LONG    y;
    ULONG   dirSkip;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dirSkip = 0x4110;
        dy      = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dirSkip = 0xc110;
        dy      = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    // Warm up the hardware so that it will know we'll be outputing
    // short-stroke vectors, and so that it will have the current position
    // correctly set if we're starting in the middle of a 'dash':

    IO_FIFO_WAIT(ppdev, 3);
    IO_CUR_X(ppdev, x);
    IO_CUR_Y(ppdev, y);
    IO_CMD(ppdev, DRAW              | WRITE             | MULTIPLE_PIXELS |
                  DIR_TYPE_RADIAL   | LAST_PIXEL_OFF    | BUS_SIZE_16     |
                  BYTE_SWAP);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // We're gonna need the current position to be correct when we
    // start outputing short-stroke vectors:

    IO_FIFO_WAIT(ppdev, 2);
    IO_CUR_X(ppdev, x);

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'y'
        // to be the current scan:

        IO_CUR_Y(ppdev, y);
        goto OutputADash;
    }

    // Set 'y' to be the scan we're about to move to, because we've
    // finished with the current strip:

    IO_CUR_Y(ppdev, y + dy);

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        // Short stroke vectors can handle lines that are a maximum of
        // 15 pels long.  When we have to draw a longer consecutive
        // segment than that, we simply break it into 16 pel portions:

        while (cThis > 15)
        {
            // Draw two horizontal strokes together to make up one 16 pel
            // segment:

            IO_FIFO_WAIT(ppdev, 1);
            IO_SHORT_STROKE(ppdev, 0x1f11);
            cThis -= 16;
        }

        // Draw the remaining lit part of the strip:

        IO_FIFO_WAIT(ppdev, 1);
        IO_SHORT_STROKE(ppdev, dirSkip | cThis);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    LONG    x;
    LONG    y;
    ULONG   dirSkip;
    ULONG   dirSkip16;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dirSkip   = 0x0150;
        dirSkip16 = 0x5f51;         // For drawing 16 pels straight up
        dy        = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dirSkip   = 0x01d0;
        dirSkip16 = 0xdfd1;         // For drawing 16 pels straight down
        dy        = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x;   // x position of start of first strip
    y       = pstrip->ptlStart.y;   // y position of start of first strip

    // Warm up the hardware so that it will know we'll be outputing
    // short-stroke vectors, and so that it will have the current position
    // correctly set if we're starting in the middle of a 'dash':

    IO_FIFO_WAIT(ppdev, 3);
    IO_CUR_X(ppdev, x);
    IO_CUR_Y(ppdev, y);
    IO_CMD(ppdev, DRAW              | WRITE             | MULTIPLE_PIXELS |
                  DIR_TYPE_RADIAL   | LAST_PIXEL_OFF    | BUS_SIZE_16     |
                  BYTE_SWAP);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // We're gonna need the current position to be correct when we
    // start outputing short-stroke vectors:

    IO_FIFO_WAIT(ppdev, 2);
    IO_CUR_Y(ppdev, y);

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip, so set 'x'
        // to be the current column:

        IO_CUR_X(ppdev, x);
        goto OutputADash;
    }

    // Set 'x' to be the column we're about to move to, because we've
    // finished with the current strip:

    IO_CUR_X(ppdev, x + 1);

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        // Short stroke vectors can handle lines that are a maximum of
        // 15 pels long.  When we have to draw a longer consecutive
        // segment than that, we simply break it into 16 pel portions:

        while (cThis > 15)
        {
            // Draw two vertical strokes together to make up one 16 pel
            // segment:

            IO_FIFO_WAIT(ppdev, 1);
            IO_SHORT_STROKE(ppdev, dirSkip16);
            cThis -= 16;
        }

        // Draw the remaining lit part of the strip:

        IO_FIFO_WAIT(ppdev, 1);
        IO_SHORT_STROKE(ppdev, dirSkip | cThis);

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x;
    pstrip->ptlStart.y = y;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\stroke.c ===
/******************************Module*Header*******************************\
* Module Name: Stroke.c
*
* DrvStrokePath for S3 driver
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

VOID (*gapfnStrip[])(PDEV*, STRIP*, LINESTATE*) = {
    vrlSolidHorizontal,
    vrlSolidVertical,
    vrlSolidDiagonalHorizontal,
    vrlSolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vssSolidHorizontal,
    vssSolidVertical,
    vssSolidDiagonalHorizontal,
    vssSolidDiagonalVertical,

// Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
// solid lines, and the same number for non-solid lines:

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledVertical,       // Diagonal goes here
    vStripStyledVertical,       // Diagonal goes here

    vStripStyledHorizontal,
    vStripStyledVertical,
    vStripStyledVertical,       // Diagonal goes here
    vStripStyledVertical,       // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

/******************************Public*Routine******************************\
* BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
*
* Strokes the path.
*
\**************************************************************************/

BOOL DrvStrokePath(
    SURFOBJ*   pso,
    PATHOBJ*   ppo,
    CLIPOBJ*   pco,
    XFORMOBJ*  pxo,
    BRUSHOBJ*  pbo,
    POINTL*    pptlBrush,
    LINEATTRS* pla,
    MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE ls;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDEV*     ppdev;
    DSURF*    pdsurf;
    OH*       poh;
    ULONG     ulHwMix;
    RECTL     arclClip[4];                  // For rectangular clipping
    RECTL     rclBounds;
    RECTFX    rcfxBounds;

// Pass the surface off to GDI if it's a device bitmap that we've
// converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt == DT_DIB)
    {
        return(EngStrokePath(pdsurf->pso, ppo, pco, pxo, pbo, pptlBrush,
                             pla, mix));
    }

// We'll be drawing to the screen or an off-screen DFB; copy the surface's
// offset now so that we won't need to refer to the DSURF again:

    poh   = pdsurf->poh;
    ppdev = (PDEV*) pso->dhpdev;
    ppdev->xOffset = poh->x;
    ppdev->yOffset = poh->y;

    ulHwMix = gajHwMixFromMix[mix & 0xf];

// x86 has special case ASM code for accelerating solid lines:

#if defined(i386)

    if ((pla->pstyle == NULL) && !(pla->fl & LA_ALTERNATE))
    {
    // We can accelerate solid lines:

        if (pco->iDComplexity == DC_TRIVIAL)
        {
            ppdev->pfnFastLine(ppdev, ppo, NULL, &gapfnStrip[0], 0,
                               pbo->iSolidColor, ulHwMix);

            return(TRUE);
        }
        else if (pco->iDComplexity == DC_RECT)
        {
        // We have to be sure that we don't overflow the hardware registers
        // for current position, line length, or DDA terms.  We check
        // here to make sure that the current position and line length
        // values won't overflow (for integer lines, this check is
        // sufficient to ensure that the DDA terms won't overflow; for GIQ
        // lines, we specifically check on every line in pfnFastLine that we
        // don't overflow).

            PATHOBJ_vGetBounds(ppo, &rcfxBounds);

            if (rcfxBounds.xLeft   + (ppdev->xOffset * F)
                                                >= (MIN_INTEGER_BOUND * F) &&
                rcfxBounds.xRight  + (ppdev->xOffset * F)
                                                <= (MAX_INTEGER_BOUND * F) &&
                rcfxBounds.yTop    + (ppdev->yOffset * F)
                                                >= (MIN_INTEGER_BOUND * F) &&
                rcfxBounds.yBottom + (ppdev->yOffset * F)
                                                <= (MAX_INTEGER_BOUND * F))
            {
            // Since we're going to be using the scissors registers to
            // do hardware clipping, we'll also have to make sure we don't
            // exceed its bounds.  ATI chips have a maximum limit of 1023,
            // which we could exceed if we're running at 1280x1024, or for
            // off-screen device bitmaps.

                if ((pco->rclBounds.right  + ppdev->xOffset < 1024) &&
                    (pco->rclBounds.bottom + ppdev->yOffset < 1024))
                {
                    arclClip[0]        =  pco->rclBounds;

                // FL_FLIP_D:

                    arclClip[1].top    =  pco->rclBounds.left;
                    arclClip[1].left   =  pco->rclBounds.top;
                    arclClip[1].bottom =  pco->rclBounds.right;
                    arclClip[1].right  =  pco->rclBounds.bottom;

                // FL_FLIP_V:

                    arclClip[2].top    = -pco->rclBounds.bottom + 1;
                    arclClip[2].left   =  pco->rclBounds.left;
                    arclClip[2].bottom = -pco->rclBounds.top + 1;
                    arclClip[2].right  =  pco->rclBounds.right;

                // FL_FLIP_V | FL_FLIP_D:

                    arclClip[3].top    =  pco->rclBounds.left;
                    arclClip[3].left   = -pco->rclBounds.bottom + 1;
                    arclClip[3].bottom =  pco->rclBounds.right;
                    arclClip[3].right  = -pco->rclBounds.top + 1;

                    rclBounds.left   = pco->rclBounds.left;
                    rclBounds.top    = pco->rclBounds.top;
                    rclBounds.right  = pco->rclBounds.right;
                    rclBounds.bottom = pco->rclBounds.bottom;

                    vSetClipping(ppdev, &rclBounds);

                    ppdev->pfnFastLine(ppdev, ppo, &arclClip[0], &gapfnStrip[0],
                                       FL_SIMPLE_CLIP, pbo->iSolidColor, ulHwMix);

                    vResetClipping(ppdev);
                    return(TRUE);
                }
            }
        }
    }

#endif // i386

// Get the device ready:

    if (DEPTH32(ppdev))
    {
        IO_FIFO_WAIT(ppdev, 4);
        MM_FRGD_COLOR32(ppdev, ppdev->pjMmBase, pbo->iSolidColor);
    }
    else
    {
        IO_FIFO_WAIT(ppdev, 3);
        IO_FRGD_COLOR(ppdev, pbo->iSolidColor);
    }

    IO_FRGD_MIX(ppdev, FOREGROUND_COLOR | ulHwMix);
    IO_PIX_CNTL(ppdev, ALL_ONES);

    fl = 0;

// Look after styling initialization:

    if (pla->fl & LA_ALTERNATE)
    {
        ls.cStyle      = 1;
        ls.spTotal     = 1;
        ls.spTotal2    = 2;
        ls.spRemaining = 1;
        ls.aspRtoL     = &gaspAlternateStyle[0];
        ls.aspLtoR     = &gaspAlternateStyle[0];
        ls.spNext      = HIWORD(pla->elStyleState.l);
        ls.xyDensity   = 1;
        fl            |= FL_ARBITRARYSTYLED;
        ls.ulStartMask = 0L;
    }
    else if (pla->pstyle != (FLOAT_LONG*) NULL)
    {
        PFLOAT_LONG pstyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        pstyle = &pla->pstyle[pla->cstyle];

        ls.xyDensity = STYLE_DENSITY;
        ls.spTotal   = 0;
        while (pstyle-- > pla->pstyle)
        {
            ls.spTotal += pstyle->l;
        }
        ls.spTotal *= STYLE_DENSITY;
        ls.spTotal2 = 2 * ls.spTotal;

    // Compute starting style position (this is guaranteed not to overflow):

        ls.spNext = HIWORD(pla->elStyleState.l) * STYLE_DENSITY +
                    LOWORD(pla->elStyleState.l);

        fl        |= FL_ARBITRARYSTYLED;
        ls.cStyle  = pla->cstyle;
        ls.aspRtoL = aspRtoL;
        ls.aspLtoR = aspLtoR;

        if (pla->fl & LA_STARTGAP)
            ls.ulStartMask = 0xffffffffL;
        else
            ls.ulStartMask = 0L;

        pstyle  = pla->pstyle;
        pspDown = &ls.aspRtoL[ls.cStyle - 1];
        pspUp   = &ls.aspLtoR[0];

        while (pspDown >= &ls.aspRtoL[0])
        {
            *pspDown = pstyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            pstyle++;
        }
    }

    apfn = &gapfnStrip[NUM_STRIP_DRAW_STYLES *
                            ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

// Set up to enumerate the path:

#if defined(i386)

// x86 ASM bLines supports DC_RECT clipping:

    if (pco->iDComplexity != DC_COMPLEX)

#else

// Non-x86 ASM bLines don't support DC_RECT clipping:

    if (pco->iDComplexity == DC_TRIVIAL)

#endif

    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*) NULL;
        BOOL      bMore;
        ULONG     cptfx;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

#if defined(i386)

        if (pco->iDComplexity == DC_RECT)
        {
            fl |= FL_SIMPLE_CLIP;

            arclClip[0]        =  pco->rclBounds;

        // FL_FLIP_D:

            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

        // FL_FLIP_V:

            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

        // FL_FLIP_V | FL_FLIP_D:

            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }

#endif // i386

        pd.flags = 0;

        do {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            cptfx = pd.count;
            if (cptfx == 0)
            {
                break;
            }

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if (pd.flags & PD_RESETSTYLE)
                ls.spNext = 0;

            if (cptfx > 0)
            {
                if (!bLines(ppdev,
                            pptfxFirst,
                            pptfxBuf,
                            (RUN*) NULL,
                            cptfx,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {
                if (!bLines(ppdev,
                            &ptfxLast,
                            &ptfxStartFigure,
                            (RUN*) NULL,
                            1,
                            &ls,
                            prclClip,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);

        if (fl & FL_STYLED)
        {
        // Save the style state:

            ULONG ulHigh;
            ULONG ulLow;

        // Masked styles don't normalize the style state.  It's a good
        // thing to do, so let's do it now:

            if ((ULONG) ls.spNext >= (ULONG) ls.spTotal2)
                ls.spNext = (ULONG) ls.spNext % (ULONG) ls.spTotal2;

            ulHigh = ls.spNext / ls.xyDensity;
            ulLow  = ls.spNext % ls.xyDensity;

            pla->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
    // Local state for path enumeration:

        BOOL bMore;
        union {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

    // We use the clip object when non-simple clipping is involved:

        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pla);

        do {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if (cl.cl.c != 0)
            {
                if (fl & FL_STYLED)
                {
                    ls.spComplex = HIWORD(cl.cl.lStyleState) * ls.xyDensity
                                 + LOWORD(cl.cl.lStyleState);
                }
                if (!bLines(ppdev,
                            &cl.cl.ptfxA,
                            &cl.cl.ptfxB,
                            &cl.cl.arun[0],
                            cl.cl.c,
                            &ls,
                            (RECTL*) NULL,
                            apfn,
                            fl))
                    return(FALSE);
            }
        } while (bMore);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: textout.c
*
* There are three basic methods for drawing text with hardware
* acceleration:
*
* 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
*       (probably in off-screen memory), and text is drawn by
*       referring the hardware to the cached glyph locations.
*
* 2) Glyph expansion -- Each individual glyph is colour-expanded
*       directly to the screen from the monochrome glyph bitmap
*       supplied by GDI.
*
* 3) Buffer expansion -- The CPU is used to draw all the glyphs into
*       a 1bpp monochrome bitmap, and the hardware is then used
*       to colour-expand the result.
*
* The fastest method depends on a number of variables, such as the
* colour expansion speed, bus speed, CPU speed, average glyph size,
* and average string length.
*
* For the S3 with normal sized glyphs, I've found that caching the
* glyphs in off-screen memory is typically the slowest method.
* Buffer expansion is typically fastest on the slow ISA bus (or when
* memory-mapped I/O isn't available on the x86), and glyph expansion
* is best on fast buses such as VL and PCI.
*
* Glyph expansion is typically faster than buffer expansion for very
* large glyphs, even on the ISA bus, because less copying by the CPU
* needs to be done.  Unfortunately, large glyphs are pretty rare.
*
* An advantange of the buffer expansion method is that opaque text will
* never flash -- the other two methods typically need to draw the
* opaquing rectangle before laying down the glyphs, which may cause
* a flash if the raster is caught at the wrong time.
*
* This driver implements glyph expansion and buffer expansion --
* methods 2) and 3).  Depending on the hardware capabilities at
* run-time, we'll use whichever one will be faster.
*
* Copyright (c) 1992-1994 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

POINTL gptlZero = { 0, 0 };         // Specifies that the origin of the
                                    //   temporary buffer given to the 1bpp
                                    //   transfer routine for fasttext is
                                    //   at (0, 0)

#define     FIFTEEN_BITS        ((1 << 15)-1)

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangles with the specified colour, honouring
* the requested clipping.  No more than four rectangles should be passed in.
* Intended for drawing the areas of the opaquing rectangle that extend
* beyond the text box.  The rectangles must be in left to right, top to
* bottom order.  Assumes there is at least one rectangle in the list.
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
LONG        crcl,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBRUSH_COLOR    rbc;

    ASSERTDD((crcl > 0) && (crcl <= 4), "Expected 1 to 4 rectangles");
    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                       "Expected a non-null clip object");

    rbc.iSolidColor = iColor;
    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            (ppdev->pfnFillSolid)(ppdev, crcl, prcl, OVERPAINT, OVERPAINT,
                                  rbc, NULL);
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill

        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:

        do {
            // Get a batch of region rectangles:

            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*)&ce);

            // Clip the rect list to each region rect:

            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.

                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:

                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:

                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:

                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles

                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:

                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects

                    if (crclTmp != 0)
                    {
                        (ppdev->pfnFillSolid)(ppdev, crclTmp, &arclTmp[0],
                                             OVERPAINT, OVERPAINT, rbc, NULL);
                    }
                }
            }
        } while (bMore);
    }
}

/******************************Public*Routine******************************\
* BOOL bBufferExpansion
*
* Outputs text using the 'buffer expansion' method.  The CPU draws to a
* 1bpp buffer, and the result is colour-expanded to the screen using the
* hardware.
*
* Note that this is x86 only ('vFastText', which draws the glyphs to the
* 1bpp buffer, is writen in Asm).
*
* If you're just getting your driver working, this is the fastest way to
* bring up working accelerated text.  All you have to do is write the
* 'Xfer1bpp' function that's also used by the blt code.  This
* 'bBufferExpansion' routine shouldn't need to be modified at all.
*
\**************************************************************************/

#if defined(i386)

BOOL bBufferExpansion(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque)
{
    BYTE            jClip;
    BOOL            bMore;              // Flag for clip enumeration
    GLYPHPOS*       pgp;                // Points to the first glyph
    BOOL            bMoreGlyphs;        // Glyph enumeration flag
    ULONG           cGlyph;             // # of glyphs in one batch
    RECTL           arclTmp[4];         // Temporary storage for portions
                                        //   of opaquing rectangle
    RECTL*          prclClip;           // Points to list of clip rectangles
    RECTL*          prclDraw;           // Actual text to be drawn
    RECTL           rclDraw;
    ULONG           crcl;               // Temporary rectangle count
    ULONG           ulBufferBytes;
    ULONG           ulBufferHeight;
    BOOL            bTextPerfectFit;
    ULONG           flDraw;
    BOOL            bTmpAlloc;
    SURFOBJ         so;
    CLIPENUM        ce;
    RBRUSH_COLOR    rbc;
    ULONG           ulHwBackMix;        // Dictates whether opaque or
                                        //   transparent text
    XLATEOBJ        xlo;                // Temporary for passing colours
    XLATECOLORS     xlc;                // Temporary for keeping colours

    jClip = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    // The foreground colour will always be solid:

    xlc.iForeColor = pboFore->iSolidColor;

    ASSERTDD(xlc.iForeColor != -1, "Expected solid foreground colour");

    // See if the temporary buffer is big enough for the text; if
    // not, try to allocate enough memory.  We round up to the
    // nearest dword multiple:

    so.lDelta = ((((pstro->rclBkGround.right + 31) & ~31) -
                              (pstro->rclBkGround.left & ~31)) >> 3);

    ulBufferHeight = pstro->rclBkGround.bottom - pstro->rclBkGround.top;

    ulBufferBytes = so.lDelta * ulBufferHeight;

    if (((ULONG)so.lDelta > FIFTEEN_BITS) ||
        (ulBufferHeight > FIFTEEN_BITS))
    {
        // the math will have overflowed
        return(FALSE);
    }

    // Use our temporary buffer if it's big enough, otherwise
    // allocate a buffer on the fly:

    if (ulBufferBytes >= TMP_BUFFER_SIZE)
    {
        // The textout is so big that I doubt this allocation will
        // cost a significant amount in performance:

        bTmpAlloc  = TRUE;
        so.pvScan0 = EngAllocUserMem(ulBufferBytes, ALLOC_TAG);
        if (so.pvScan0 == NULL)
            return(FALSE);
    }
    else
    {
        bTmpAlloc  = FALSE;
        so.pvScan0 = ppdev->pvTmpBuffer;
    }

    // Set fixed pitch, overlap, and top and bottom 'y' alignment
    // flags:

    if (!(pstro->flAccel & SO_HORIZONTAL) ||
         (pstro->flAccel & SO_REVERSED))
    {
        flDraw = 0;
    }
    else
    {
        flDraw = ((pstro->ulCharInc != 0) ? 0x01 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT)) !=
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT))
                      ? 0x02 : 0) |
                     (((pstro->flAccel & (SO_ZERO_BEARINGS |
                      SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ==
                      (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
                      SO_MAXEXT_EQUAL_BM_SIDE)) ? 0x04 : 0);
    }

    // If there's an opaque rectangle, we'll do as much opaquing
    // as possible as we do the text.  If the opaque rectangle is
    // larger than the text rectangle, then we'll do the fringe
    // areas right now, and the text and associated background
    // areas together later:

    ulHwBackMix = LEAVE_ALONE;
    if (prclOpaque != NULL)
    {
        ulHwBackMix = OVERPAINT;

        // Since we didn't set GCAPS_ARBRUSHOPAQUE (yes, it's
        // missing a 'b'), we don't have to worry about getting
        // anything other that a solid opaquing brush.  I wouldn't
        // recommend handling it anyway, since I'll bet it would
        // break quite a few applications:

        xlc.iBackColor = pboOpaque->iSolidColor;

        ASSERTDD(xlc.iBackColor != -1, "Expected solid background colour");

        // See if we have fringe areas to do.  If so, build a list of
        // rectangles to fill, in right-down order:

        crcl = 0;

        // Top fragment:

        if (pstro->rclBkGround.top > prclOpaque->top)
        {
            arclTmp[crcl].top      = prclOpaque->top;
            arclTmp[crcl].left     = prclOpaque->left;
            arclTmp[crcl].right    = prclOpaque->right;
            arclTmp[crcl++].bottom = pstro->rclBkGround.top;
        }

        // Left fragment:

        if (pstro->rclBkGround.left > prclOpaque->left)
        {
            arclTmp[crcl].top      = pstro->rclBkGround.top;
            arclTmp[crcl].left     = prclOpaque->left;
            arclTmp[crcl].right    = pstro->rclBkGround.left;
            arclTmp[crcl++].bottom = pstro->rclBkGround.bottom;
        }

        // Right fragment:

        if (pstro->rclBkGround.right < prclOpaque->right)
        {
            arclTmp[crcl].top      = pstro->rclBkGround.top;
            arclTmp[crcl].right    = prclOpaque->right;
            arclTmp[crcl].left     = pstro->rclBkGround.right;
            arclTmp[crcl++].bottom = pstro->rclBkGround.bottom;
        }

        // Bottom fragment:

        if (pstro->rclBkGround.bottom < prclOpaque->bottom)
        {
            arclTmp[crcl].bottom = prclOpaque->bottom;
            arclTmp[crcl].left   = prclOpaque->left;
            arclTmp[crcl].right  = prclOpaque->right;
            arclTmp[crcl++].top  = pstro->rclBkGround.bottom;
        }

        // Fill any fringe rectangles we found:

        if (crcl != 0)
        {
            if (jClip == DC_TRIVIAL)
            {
                rbc.iSolidColor = xlc.iBackColor;
                (ppdev->pfnFillSolid)(ppdev, crcl, arclTmp, OVERPAINT,
                                      OVERPAINT, rbc, NULL);
            }
            else
            {
                vClipSolid(ppdev, crcl, arclTmp, xlc.iBackColor, pco);
            }
        }
    }

    // We're done with separate opaquing; any further opaquing will
    // happen as part of the text drawing.

    // Clear the buffer if the text isn't going to set every bit:

    bTextPerfectFit = (pstro->flAccel & (SO_ZERO_BEARINGS |
            SO_FLAG_DEFAULT_PLACEMENT | SO_MAXEXT_EQUAL_BM_SIDE |
            SO_CHAR_INC_EQUAL_BM_BASE)) ==
            (SO_ZERO_BEARINGS | SO_FLAG_DEFAULT_PLACEMENT |
            SO_MAXEXT_EQUAL_BM_SIDE | SO_CHAR_INC_EQUAL_BM_BASE);

    if (!bTextPerfectFit)
    {
        // Note that we already rounded up to a dword multiple size.

        vClearMemDword((ULONG*) so.pvScan0, ulBufferBytes >> 2);
    }

    // Fake up the translate object that will provide the 1bpp
    // transfer routine the foreground and background colours:

    xlo.pulXlate = (ULONG*) &xlc;

    // Draw the text into the temp buffer, and thence to the screen:

    do
    {
        // Get the next batch of glyphs:

        if (pstro->pgp != NULL)
        {
            // There's only the one batch of glyphs, so save ourselves
            // a call:

            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        // LATER: remove double clip intersection from ASM code

        if (cGlyph)
        {
            prclClip = NULL;
            prclDraw = &pstro->rclBkGround;

            if (jClip == DC_TRIVIAL)
            {

            Output_Text:

                vFastText(pgp,
                          cGlyph,
                          so.pvScan0,
                          so.lDelta,
                          pstro->ulCharInc,
                          &pstro->rclBkGround,
                          prclOpaque,
                          flDraw,
                          prclClip,
                          prclExtra);

                if (!bMoreGlyphs)
                {
                    (ppdev->pfnXfer1bpp)(ppdev,
                                         1,
                                         prclDraw,
                                         OVERPAINT,
                                         ulHwBackMix,
                                         &so,
                                         &gptlZero,
                                         &pstro->rclBkGround,
                                         &xlo);
                }
            }
            else if (jClip == DC_RECT)
            {
                if (bIntersect(&pco->rclBounds, &pstro->rclBkGround,
                               &rclDraw))
                {
                    arclTmp[0]        = pco->rclBounds;
                    arclTmp[1].bottom = 0;          // Terminate list
                    prclClip          = &arclTmp[0];
                    prclDraw          = &rclDraw;

                    // Save some code size by jumping to the common
                    // functions calls:

                    goto Output_Text;
                }
            }
            else // jClip == DC_COMPLEX
            {
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES,
                                   CD_ANY, 0);

                do
                {
                    bMore = CLIPOBJ_bEnum(pco,
                                    sizeof(ce) - sizeof(RECTL),
                                    (ULONG*) &ce);

                    ce.c = cIntersect(&pstro->rclBkGround,
                                      ce.arcl, ce.c);

                    if (ce.c != 0)
                    {
                        ce.arcl[ce.c].bottom = 0;   // Terminate list

                        vFastText(pgp,
                                  cGlyph,
                                  so.pvScan0,
                                  so.lDelta,
                                  pstro->ulCharInc,
                                  &pstro->rclBkGround,
                                  prclOpaque,
                                  flDraw,
                                  &ce.arcl[0],
                                  prclExtra);

                        if (!bMoreGlyphs)
                        {
                            (ppdev->pfnXfer1bpp)(ppdev,
                                                 ce.c,
                                                 &ce.arcl[0],
                                                 OVERPAINT,
                                                 ulHwBackMix,
                                                 &so,
                                                 &gptlZero,
                                                 &pstro->rclBkGround,
                                                 &xlo);
                        }
                    }
                } while (bMore);

                break;
            }
        }
    } while (bMoreGlyphs);

    // Free up any memory we allocated for the temp buffer:

    if (bTmpAlloc)
    {
        EngFreeUserMem(so.pvScan0);
    }

    return(TRUE);
}

#endif // defined(i386)

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
* If it's the fastest method, outputs text using the 'glyph expansion'
* method.  Each individual glyph is colour-expanded directly to the
* screen from the monochrome glyph bitmap supplied by GDI.
*
* If it's not the fastest method, calls the routine that implements the
* 'buffer expansion' method.
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,
MIX       mix)
{
    PDEV*           ppdev;
    DSURF*          pdsurf;
    OH*             poh;

    // The DDI spec says we'll only ever get foreground and background
    // mixes of R2_COPYPEN:

    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

    // Pass the surface off to GDI if it's a device bitmap that we've
    // converted to a DIB:

    pdsurf = (DSURF*) pso->dhsurf;

    if (pdsurf->dt != DT_DIB)
    {
      // We'll be drawing to the screen or an off-screen DFB; copy the
      // surface's offset now so that we won't need to refer to the DSURF
      // again:

      poh   = pdsurf->poh;
      ppdev = (PDEV*) pso->dhpdev;

      ppdev->xOffset = poh->x;
      ppdev->yOffset = poh->y;

      // We don't want to use the 'glyph expansion' method, so use
      // the 'buffer expansion' method instead:

      return(bBufferExpansion(ppdev, pstro, pco, prclExtra, prclOpaque,
                              pboFore, pboOpaque));
    }
    else
    {
      // We're drawing to a DFB we've converted to a DIB, so just call GDI
      // to handle it:

      return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                        pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    // Our text algorithms require no initialization.  If we were to
    // do glyph caching, we would probably want to allocate off-screen
    // memory and do a bunch of other stuff here.

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.
}

/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
    // If we were to do off-screen glyph caching, we would probably want
    // to invalidate our cache here, because it will get destroyed when
    // we switch to full-screen.
}

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(FONTOBJ *pfo)
{
    // This call isn't hooked, so GDI will never call it.
    //
    // This merely exists as a stub function for the sample multi-screen
    // support, so that MulDestroyFont can illustrate how multiple screen
    // text supports when the driver caches glyphs.  If this driver did
    // glyph caching, we might have used the 'pvConsumer' field of the
    //  'pfo', which we would have to clean up.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\pointer.c ===
/******************************Module*Header*******************************\
* Module Name: pointer.c
*
* This module contains the pointer support for the display driver.
*
* Copyright (c) 1992-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID DrvMovePointer
*
\**************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
}

/******************************Public*Routine******************************\
* VOID vAssertModeHwPointer
*
\**************************************************************************/

VOID vAssertModeHwPointer(
PDEV*   ppdev,
BOOL    bEnable)
{
}

/******************************Public*Routine******************************\
* VOID DrvSetPointerShape
*
* Sets the new pointer shape.
*
\**************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    return(SPS_DECLINE);
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
PDEV*   ppdev)
{
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\i386\fastfill.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fastfill.asm
;
; Draws fast unclipped, non-complex polygons.
;
; Copyright (c) 1994 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\hw.inc
        .list

        .data

; The number of FIFO slots that are empty after we've done an
; IO_FIFO_WAIT(8):

IO_ALL_EMPTY_FIFO_COUNT    equ 8

; All the state information for running an edge DDA:

EDGEDATA struc
    ed_x                dd ?
    ed_dx               dd ?
    ed_lError           dd ?
    ed_lErrorUp         dd ?
    ed_lErrorDown       dd ?
    ed_pptfx            dd ?
    ed_dptfx            dd ?
    ed_cy               dd ?
EDGEDATA ends

        .code

;---------------------------Public-Routine------------------------------;
; BOOL bIoFastFill(cEdges, pptfxFirst, ulHwForeMix, ulHwBackMix,
;                  iSolidColor, prb)
;
; Draws fast polygons.  Or at least attempts to.
;
; This routine could take great advantage of the ATI SCAN_TO_X
; instruction.  Alas, but I have limited time...
;
; Input:
;
;    ppdev       - Points to the PDEV.
;    cEdges      - Number of edges in 'pptfxFirst' buffer, including the
;                  'close figure' edge (so it's also the same as the number
;                  of points in the list).
;    pptfxFirst  - Points to buffer of edges.  The last point in not
;                  necessarily coincident with the first.
;    ulHwForeMix - Foreground hardware mix.
;    ulHwBackMix - Background hardware mix.
;    iSolidColor - Fill colour.
;    prb         - Not used.
;
; Output:
;
;    eax         - Returns 1 if the polygon was drawn, 0 if the polygon was
;                  too complex.
;-----------------------------------------------------------------------;

cProc bIoFastFill,28,<  \
    uses esi edi ebx,   \
    ppdev:        ptr,  \
    cEdges:       dword,\
    pptfxFirst:   ptr,  \
    ulHwForeMix:  dword,\
    ulHwBackMix:  dword,\
    iSolidColor:  dword,\
    prb:          ptr   >

        local edLeft[size EDGEDATA]:    byte  ;DDA state for left edge
        local edRight[size EDGEDATA]:   byte  ;DDA state for right edge
        local yTrapezoid:               dword ;Current scan of trapezoid, in
                                              ; ABSOLUTE coordinates
        local cyTrapezoid:              dword ;Scans remaining to be drawn in
                                              ; current trapezoid
        local pptfxLast:                dword ;Points to last point in buffer
        local iEdge:                    dword ;Edge number for DDA loop

        local cFifoEmpty:               dword ;Number of remaining free FIFOs
        local xOffset:                  dword ;DFB 'x' offset
        local yOffset:                  dword ;DFB 'y' offset

        mov     esi,pptfxFirst
        mov     ecx,cEdges
        dec     ecx

        mov     edi,esi                 ;edi = pptfxTop = pptfxFirst
        lea     eax,[esi+ecx*8]
        mov     pptfxLast,eax           ;pptfxLast = pptfxFirst + cEdges - 1

        mov     eax,[esi].ptl_y
        mov     ebx,[esi+8].ptl_y
        mov     edx,eax                 ;edx = pptfxFirst->y
        cmp     ebx,eax
        jle     short io_u_collect_all_ups

io_d_collect_all_downs:
        dec     ecx
        jz      short io_setup_for_filling
        add     esi,8
        mov     eax,ebx
        mov     ebx,[esi+8].ptl_y
        cmp     ebx,eax
        jge     short io_d_collect_all_downs

io_d_collect_all_ups:
        dec     ecx
        jz      short io_setup_for_filling_check
        add     esi,8
        mov     eax,ebx
        mov     ebx,[esi+8].ptl_y
        cmp     ebx,eax
        jle     short io_d_collect_all_ups

        mov     edi,esi                 ;edi = pptfxTop = pptfxScan

io_d_collect_all_downs_again:
        cmp     ebx,edx
        jg      short io_return_false
        dec     ecx
        jz      short io_setup_for_filling
        add     esi,8
        mov     eax,ebx
        mov     ebx,[esi+8].ptl_y
        cmp     ebx,eax
        jge     short io_d_collect_all_downs_again

io_return_false:
        sub     eax,eax
        cRet    bIoFastFill

io_u_collect_all_ups:
        add     edi,8
        dec     ecx
        jz      io_setup_for_filling
        mov     eax,ebx
        mov     ebx,[edi+8].ptl_y
        cmp     ebx,eax
        jle     short io_u_collect_all_ups

        mov     esi,edi                 ;esi = pptfxScan = pptfxTop

io_u_collect_all_downs:
        dec     ecx
        jz      io_setup_for_filling
        add     esi,8
        mov     eax,ebx
        mov     ebx,[esi+8].ptl_y
        cmp     ebx,eax
        jge     short io_u_collect_all_downs

io_u_collect_all_ups_again:
        cmp     ebx,edx
        jl      short io_return_false
        dec     ecx
        jz      io_setup_for_filling
        add     esi,8
        mov     eax,ebx
        mov     ebx,[esi+8].ptl_y
        cmp     ebx,eax
        jle     short io_u_collect_all_ups_again

        sub     eax,eax
        cRet    bIoFastFill

io_setup_for_filling_check:
        cmp     ebx,edx
        jge     short io_setup_for_filling
        lea     edi,[esi+8]

        public  io_setup_for_filling
io_setup_for_filling::

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some initialization

        ; edi = pptfxTop

        mov     ecx,[edi].ptl_y
        add     ecx,15
        sar     ecx,4
        mov     yTrapezoid,ecx          ;yTrapezoid = (pptfxTop->y + 15) >> 4

        mov     edLeft.ed_cy,0
        mov     edLeft.ed_dptfx,-8
        mov     edLeft.ed_pptfx,edi

        mov     edRight.ed_cy,0
        mov     edRight.ed_dptfx,8
        mov     edRight.ed_pptfx,edi

        mov     esi,ppdev               ;esi = ppdev

        ; ecx = yTrapezoid
        ; esi = ppdev

        mov     eax,[esi].pdev_yOffset
        mov     yOffset,eax             ;yOffset = ppdev->yOffset
        add     ecx,eax                 ;ecx = yTrapezoid += yOffset
        mov     yTrapezoid,ecx          ;yTrapezoid is kept in absolute
                                        ; coordinates

        mov     ebx,[esi].pdev_xOffset
        mov     xOffset,ebx             ;xOffset = ppdev->xOffset

        ; This will guarantee that we have IO_ALL_EMPTY_FIFO_COUNT slots
        ; available.

        mov     edx,CMD
@@:     in      ax,dx
        and     eax,FIFO_8_EMPTY        ;IO_FIFO_WAIT(8)
        jnz     short @b

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Setup hardware for a solid colour

        public  io_initialize_solid
io_initialize_solid::

                ;ecx = yTrapezoid
                ;esi = ppdev

        mov     cFifoEmpty,IO_ALL_EMPTY_FIFO_COUNT - 4

        mov     eax,ulHwForeMix
        or      eax,FOREGROUND_COLOR
        mov     edx,[esi].pdev_ioFrgd_mix
        out     dx,ax                   ;IO_FRGD_MIX(FOREGROUND_COLOR |
                                        ;            ulHwForeMix)

        mov     eax,DATA_EXTENSION
        mov     edx,PIX_CNTL
        out     dx,ax                   ;IO_PIX_CNTL(ALL_ONES)

        mov     eax,RECT_HEIGHT
        out     dx,ax                   ;IO_MIN_AXIS_PCNT(0)

        mov     eax,iSolidColor
        mov     edx,[esi].pdev_ioFrgd_color
        out     dx,ax                   ;IO_FRGD_COLOR(iSolidColor)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DDA initialization

        public io_new_trapezoid
io_new_trapezoid::
        lea     edi,[edLeft+size EDGEDATA]
        mov     iEdge,1

io_other_edge:
        sub     edi,size EDGEDATA
        cmp     [edi].ed_cy,0
        jg      io_check_if_another_edge

io_need_new_dda:
        dec     cEdges
        jl      io_return_true

        mov     edx,[edi].ed_pptfx      ;edx = ped->pptfx
        mov     ebx,[edx].ptl_x         ;ebx = xStart = ped->pptfx->x
        mov     ecx,[edx].ptl_y         ;ecx = yStart = ped->pptfx->y

        add     edx,[edi].ed_dptfx      ;edx += ped->ed_dptfx

        cmp     edx,pptfxFirst          ;See if edx wrapped around ends of
        jae     short @f                ; the buffer
        mov     edx,pptfxLast
@@:     cmp     edx,pptfxLast
        jbe     short @f
        mov     edx,pptfxFirst
@@:
        mov     [edi].ed_pptfx,edx      ;ped->pptfx = edx
        mov     eax,[edx].ptl_y
        add     eax,15
        sar     eax,4
        add     eax,yOffset             ;Convert to absolute coordinates
        sub     eax,yTrapezoid          ;eax = ((ped->pptfx->y + 15) >> 4)
                                        ;    - yTrapezoid
        jle     short io_need_new_dda   ;Edge has to cross a scan

        mov     [edi].ed_cy,eax         ;ped->cy = eax

        public  io_calculate_deltas
io_calculate_deltas::
        mov     esi,[edx].ptl_y
        sub     esi,ecx                 ;esi = dN = ped->pptfx->y - yStart
        mov     [edi].ed_lErrorDown,esi ;ped->lErrorDown = dN

        mov     eax,[edx].ptl_x
        sub     eax,ebx                 ;eax = dM = ped->pptfx->x - xStart
        jge     short io_to_right

        neg     eax                     ;eax = dM = -dM
        cmp     eax,esi
        jge     short io_x_major_to_left

        sub     esi,eax
        mov     edx,esi                 ;edx = lErrorUp = dN - dM
        mov     eax,-1                  ;eax = dx = -1
        jmp     short io_calc_rest_of_dda

io_x_major_to_left:
        sub     edx,edx
        div     esi                     ;edx = lErrorUp = dM % dN
        neg     eax                     ;eax = dx = - dM / dN
        test    edx,edx
        jz      short io_calc_rest_of_dda
        sub     esi,edx
        mov     edx,esi                 ;edx = lErrorUp = dN - (dM % dN)
        dec     eax                     ;eax = dx = (-dM / dN) - 1
        jmp     short io_calc_rest_of_dda

io_to_right:
        cmp     eax,esi
        jge     short io_x_major_io_to_right

        mov     edx,eax                 ;edx = lErrorUp = dM
        sub     eax,eax                 ;eax = dx = 0
        jmp     short io_calc_rest_of_dda

io_x_major_io_to_right:
        sub     edx,edx
        div     esi                     ;edx = lErrorUp = dM % dN
                                        ;eax = dx = dM / dN

        public  io_calc_rest_of_dda
io_calc_rest_of_dda::
        mov     [edi].ed_lErrorUp,edx   ;ped->lErrorUp = lErrorUp
        mov     [edi].ed_dx,eax         ;ped->dx = dx

        mov     esi,-1                  ;esi = lError = -1 (meaning that the
                                        ; initial error is zero)

                ; eax = dx
                ; ebx = xStart ('x' position of start point of edge)
                ; ecx = yStart ('y' position of start point of edge)
                ; edx = lErrorUp
                ; esi = lError
                ; edi = ped

        and     ecx,15
        jz      short io_on_integer_row

        xor     ecx,0fh                 ;ecx = 15 - (yStart & 15)

io_advance_to_integer_row:
        add     ebx,eax                 ;ebx = x += ped->dx
        add     esi,edx                 ;esi = lError += lErrorUp
        jl      short @f
        sub     esi,[edi].ed_lErrorDown ;esi = lError -= lErrorDown
        inc     ebx                     ;ebx = x++
@@:
        dec     ecx
        jge     short io_advance_to_integer_row

io_on_integer_row:
        mov     edx,ebx                 ;edx = ebx = x
        and     edx,15                  ;edx = (x & 15)
        jz      short io_on_integer_column

        xor     edx,0fh
        inc     edx                     ;edx = 16 - (x & 15)
        imul    edx,[edi].ed_lErrorDown
        sub     esi,edx                 ;esi = lError -= lErrorDown
                                        ;    * (16 - (x & 15))
        add     ebx,15                  ;ebx = x += 15

io_on_integer_column:
        sar     ebx,4
        sar     esi,4
        add     ebx,xOffset
        mov     [edi].ed_x,ebx          ;ped->x = (x >> 4) + ppdev->xOffset
        mov     [edi].ed_lError,esi     ;ped->lError = (lError >> 4)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Get ready to do the DDAs

        public  io_check_if_another_edge
io_check_if_another_edge::
        dec     iEdge
        jge     io_other_edge

        ; This obtuse chunk of code calculates:
        ;
        ;    cyTrapezoid = min(edLeft.ed_cy, edRight.ed_cy)
        ;    edLeft.ed_cy  -= original edRight.ed_cy
        ;    edRight.ed_cy -= original edLeft.ed_cy

        mov     eax,edLeft.ed_cy
        mov     ebx,edRight.ed_cy
        sub     eax,ebx
        sbb     ecx,ecx
        mov     edLeft.ed_cy,eax
        neg     eax
        mov     edRight.ed_cy,eax
        and     ecx,eax
        sub     ebx,ecx
        mov     cyTrapezoid,ebx

        ; We bias the right edge by one because the S3 always expects
        ; widths to be the actual width less one:

        mov     ebx,edLeft.ed_x
        mov     esi,edRight.ed_x
        dec     esi

        mov     ecx,edLeft.ed_lError
        mov     edi,edRight.ed_lError

;----------------------------------------------------------------------;
; Solid draw
;----------------------------------------------------------------------;

        public  io_solid_draw
io_solid_draw::

                ; eax =
                ; ebx = edLeft.ed_x
                ; ecx = edLeft.ed_lError
                ; esi = edRight.ed_x - 1
                ; edi = edRight.ed_lError

        cmp     edLeft.ed_lErrorUp,0
        jnz     io_solid_dda
        cmp     edRight.ed_lErrorUp,0
        jnz     io_solid_dda
        cmp     edLeft.ed_dx,0
        jnz     io_solid_dda
        cmp     edRight.ed_dx,0
        jnz     io_solid_dda
        cmp     cyTrapezoid,1
        je      io_solid_dda

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Vertical-edge special case for solid colours

        public  io_solid_vertical
io_solid_vertical::
        mov     eax,esi
        sub     eax,ebx
        jl      short io_solid_vertical_zero_or_less_width

        sub     cFifoEmpty,5            ;NOTE: If this count is changed, change
                                        ; io_solid_vertical_wait_for_fifo!
        jl      short io_solid_vertical_wait_for_fifo
io_solid_vertical_fifo_clear:
        mov     edx,MAJ_AXIS_PCNT
        out     dx,ax                   ;IO_MAJ_AXIS_PCNT(
                                        ; edRight.x - edLeft.x - 1)

        mov     eax,yTrapezoid
        mov     edx,CUR_Y
        out     dx,ax                   ;IO_CUR_Y(yTrapezoid)

        mov     eax,cyTrapezoid
        add     yTrapezoid,eax          ;yTrapezoid += cyTrapezoid
        dec     eax
        or      eax,RECT_HEIGHT
        mov     edx,MIN_AXIS_PCNT
        out     dx,ax                   ;IO_MIN_AXIS_PCNT(cyTrapezoid - 1)

        mov     eax,ebx
        mov     edx,CUR_X
        out     dx,ax                   ;IO_CUR_X(edLeft.x)

        mov     eax,(RECTANGLE_FILL + DRAWING_DIR_TBLRXM + \
                     DRAW           + WRITE)
        mov     edx,CMD
        out     dx,ax                   ;IO_CMD(...)

        mov     eax,RECT_HEIGHT
        mov     edx,MIN_AXIS_PCNT
        out     dx,ax                   ;IO_MIN_AXIS_PCNT(0)

        ; Save our register variables because an edge can continue into
        ; the next trapezoid (this is significant if we swapped edges):

        inc     esi                     ;undo right bias
        mov     edLeft.ed_x,ebx
        mov     edRight.ed_x,esi

        jmp     io_new_trapezoid

io_solid_vertical_wait_for_fifo:
        push    eax
        mov     edx,CMD
@@:     in      ax,dx
        and     eax,FIFO_8_EMPTY        ;IO_FIFO_WAIT(8)
        jnz     short @b
        mov     cFifoEmpty,IO_ALL_EMPTY_FIFO_COUNT - 6
        pop     eax
        jmp     short io_solid_vertical_fifo_clear

io_solid_vertical_zero_or_less_width:
        inc     eax
        jnz     short io_solid_vertical_swap_edges

        mov     eax,cyTrapezoid
        add     yTrapezoid,eax          ;yTrapezoid += cyTrapezoid
        jmp     io_new_trapezoid

io_solid_vertical_swap_edges:
        push    offset io_solid_vertical
        jmp     io_swap_edges

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Run the DDAs for solid colours

        public  io_solid_dda_loop
io_solid_dda_loop::
        dec     cyTrapezoid
        jz      io_solid_dda_ret

        public  io_solid_dda
io_solid_dda::
        mov     eax,esi
        sub     eax,ebx
        jl      short io_solid_dda_zero_or_less_width

        sub     cFifoEmpty,4            ;NOTE: If this count is changed, change
                                        ; io_solid_wait_for_fifo!
        jl      short io_solid_wait_for_fifo
io_solid_dda_fifo_clear:
        mov     edx,MAJ_AXIS_PCNT
        out     dx,ax                   ;IO_MAJ_AXIS_PCNT(
                                        ;       edRight.x - edLeft.x - 1)

        mov     eax,ebx
        mov     edx,CUR_X
        out     dx,ax                   ;IO_CUR_X(edLeft.x)

        mov     eax,yTrapezoid
        mov     edx,CUR_Y
        out     dx,ax                   ;IO_CUR_Y(yTrapezoid)
        inc     eax
        mov     yTrapezoid,eax          ;yTrapezoid++

        mov     eax,(RECTANGLE_FILL + DRAWING_DIR_TBLRXM + \
                     DRAW           + WRITE)
        mov     edx,CMD
        out     dx,ax                   ;IO_CMD(...)

io_solid_dda_continue_after_zero:
        add     ebx,edLeft.ed_dx
        add     ecx,edLeft.ed_lErrorUp
        jl      short @f

        inc     ebx
        sub     ecx,edLeft.ed_lErrorDown
@@:
        add     esi,edRight.ed_dx
        add     edi,edRight.ed_lErrorUp
        jl      short io_solid_dda_loop

        inc     esi
        sub     edi,edRight.ed_lErrorDown

        dec     cyTrapezoid
        jnz     short io_solid_dda

io_solid_dda_ret:
        inc     esi                     ;undo right bias

        ; Save our register variables because an edge can continue into
        ; the next trapezoid:

        mov     edLeft.ed_x,ebx
        mov     edLeft.ed_lError,ecx
        mov     edRight.ed_x,esi
        mov     edRight.ed_lError,edi

        jmp     io_new_trapezoid

        public  io_solid_wait_for_fifo
io_solid_wait_for_fifo::
        push    eax
        mov     edx,CMD
@@:     in      ax,dx
        and     eax,FIFO_8_EMPTY        ;IO_FIFO_WAIT(8)
        jnz     short @b
        mov     cFifoEmpty,IO_ALL_EMPTY_FIFO_COUNT - 4
        pop     eax
        jmp     short io_solid_dda_fifo_clear

io_solid_dda_zero_or_less_width:
        inc     eax
        jnz     short io_solid_dda_swap_edges

        inc     yTrapezoid              ;yTrapezoid++
        jmp     short io_solid_dda_continue_after_zero

io_solid_dda_swap_edges:
        push    offset io_solid_dda
        jmp     io_swap_edges

;----------------------------------------------------------------------;
; Swap edges
;----------------------------------------------------------------------;

        public  io_swap_edges
io_swap_edges::
        mov     eax,edLeft.ed_cy
        mov     edx,edRight.ed_cy
        mov     edRight.ed_cy,eax
        mov     edLeft.ed_cy,edx        ;xchg 'cy'

        mov     eax,edLeft.ed_dptfx
        mov     edx,edRight.ed_dptfx
        mov     edRight.ed_dptfx,eax
        mov     edLeft.ed_dptfx,edx     ;xchg 'dptfx'

        mov     eax,edLeft.ed_pptfx
        mov     edx,edRight.ed_pptfx
        mov     edRight.ed_pptfx,eax
        mov     edLeft.ed_pptfx,edx     ;xchg 'pptfx'

        mov     eax,edLeft.ed_dx
        mov     edx,edRight.ed_dx
        mov     edRight.ed_dx,eax
        mov     edLeft.ed_dx,edx        ;xchg 'dx'

        mov     eax,edLeft.ed_lErrorUp
        mov     edx,edRight.ed_lErrorUp
        mov     edRight.ed_lErrorUp,eax
        mov     edLeft.ed_lErrorUp,edx  ;xchg 'lErrorUp'

        mov     eax,edLeft.ed_lErrorDown
        mov     edx,edRight.ed_lErrorDown
        mov     edRight.ed_lErrorDown,eax
        mov     edLeft.ed_lErrorDown,edx;xchg 'lErrorDown'

        xchg    ecx,edi                 ;xchg 'lError'

        xchg    ebx,esi                 ;xchg 'x'
        inc     ebx
        dec     esi                     ;don't forget right bias

        PLAIN_RET

io_return_true:
        mov     eax,1
        cRet    bIoFastFill

endProc bIoFastFill

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\thunk.c ===
/******************************Module*Header*******************************\
* Module Name: thunk.c
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1993-1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG

// This entire module is only enabled for Checked builds

#define SYNCH_ENTER()   0   // do nothing
#define SYNCH_LEAVE()   0   // do nothing

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)

VOID DbgDisableDriver(VOID)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableDriver"));

    DrvDisableDriver();

    DISPDBG((6, "DrvDisableDriver done"));
    SYNCH_LEAVE();
}

DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "DrvEnablePDEV done"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "DrvCompletePDEV done"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "DrvDisable done"));
    SYNCH_LEAVE();
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, "DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "DrvEnableSurface done"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "DrvDisableSurface done"));
    SYNCH_LEAVE();
}

BOOL DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, "DrvAssertMode"));

    b = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "DrvAssertMode done"));
    SYNCH_LEAVE();

    return b;
}

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, "DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "DrvGetModes done"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    SYNCH_ENTER();
    DISPDBG((5, "DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((6, "DrvMovePointer done"));
    SYNCH_LEAVE();
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "DrvSetPointerShape done"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, "DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "DrvDitherColor done"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "DrvSetPalette done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "DrvCopyBits done"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvBitBlt"));

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((6, "DrvBitBlt done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "DrvTextOut done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "DrvStrokePath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "DrvFillPath done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((6, "DrvPaint done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, "DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "DrvRealizeBrush done"));

    return(u);
}

VOID DbgDestroyFont(FONTOBJ *pfo)
{
    // Note: GDI synchronizes DrvDestroyFont only with other font calls.
    //       Calls such as DrvBitBlt may be going on at the same time
    //       as this call, but calls such as DrvTextOut are guaranteed
    //       not to happen at the same time.

    DISPDBG((5, "DrvDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "DrvDestroyFont done"));
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    if (gbNull)                     // I would pretend to have created a
        return(FALSE);              //   bitmap when gbNull is set, by we
                                    //   would need some code to back this
                                    //   up so that the system wouldn't
                                    //   crash...

    SYNCH_ENTER();
    DISPDBG((5, "DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "DrvCreateDeviceBitmap done"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((5, "DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "DrvDeleteDeviceBitmap done"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    #if SYNCHRONIZEACCESS_WORKS
    {
        // Our DrvStretchBlt routine calls back to EngStretchBlt, which
        // calls back to our DrvCopyBits routine -- so we have to be
        // re-entrant for synchronization...

        SYNCH_LEAVE();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    #if SYNCHRONIZEACCESS_WORKS
    {
        SYNCH_ENTER();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\i386\lines.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: lines.asm
;
; ASM version of the line DDA calculator.
;
; Copyright (c) 1992-1994 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\lines.inc
        .list

        .data

        public gaflRoundTable
gaflRoundTable       label  dword
        dd      FL_H_ROUND_DOWN + FL_V_ROUND_DOWN       ; no flips
        dd      FL_H_ROUND_DOWN + FL_V_ROUND_DOWN       ; D flip
        dd      FL_H_ROUND_DOWN                         ; V flip
        dd      FL_V_ROUND_DOWN                         ; D & V flip
        dd      FL_V_ROUND_DOWN                         ; slope one
        dd      0baadf00dh
        dd      FL_H_ROUND_DOWN                         ; slope one & V flip
        dd      0baadf00dh

        .code

;--------------------------------Macro----------------------------------;
; testb ebx, <mask>
;
; Substitutes a byte compare if the mask is entirely in the lo-byte or
; hi-byte (thus saving 3 bytes of code space).
;
;-----------------------------------------------------------------------;

TESTB   macro   targ,mask,thirdarg
        local   mask2,delta

ifnb <thirdarg>
        .err    TESTB mask must be enclosed in brackets!
endif

        delta = 0
        mask2 = mask

        if mask2 AND 0ffff0000h
            test targ,mask                      ; If bit set in hi-word,
            exitm                               ; test entire dword
        endif

        if mask2 AND 0ff00h
            if mask2 AND 0ffh                   ; If bit set in lo-byte and
                test targ,mask                  ; hi-byte, test entire dword
                exitm
            endif

            mask2 = mask2 SHR 8
            delta = 1
        endif

ifidni <targ>,<EBX>
        if delta
            test bh,mask2
        else
            test bl,mask2
        endif
        exitm
endif

        .err    Too bad TESTB doesn't support targets other than ebx!
endm

;---------------------------Public-Routine------------------------------;
; bLines(ppdev, pptfxFirst, pptfxBuf, prun, cptfx, pls,
;        prclClip, apfn[], flStart)
;
; Handles lines with trivial or simple clipping.
;
;-----------------------------------------------------------------------;

cProc   bLines,36,< \
    uses esi edi ebx,  \
    ppdev:      ptr,   \
    pptfxFirst: ptr,   \
    pptfxBuf:   ptr,   \
    prun:       ptr,   \
    cptfx:      dword, \
    pls:        ptr,   \
    prclClip:   ptr,   \
    apfn:       ptr,   \
    flStart:    dword  >

        local pptfxBufEnd:           ptr   ; Last point in pptfxBuf
        local M0:                    dword ; Normalized x0 in device coords
        local dM:                    dword ; Delta-x in device coords
        local N0:                    dword ; Normalized y0 in device coords
        local dN:                    dword ; Delta-y in device coords
        local fl:                    dword ; Flags for current line
        local x:                     dword ; Normalized start pixel x-coord
        local y:                     dword ; Normalized start pixel y-coord
        local eqGamma_lo:            dword ; Upper 32 bits of Gamma
        local eqGamma_hi:            dword ; Lower 32 bits of Gamma
        local x0:                    dword ; Start pixel x-offset
        local y0:                    dword ; Start pixel y-offset
        local ulSlopeOneAdjustment:  dword ; Special offset if line of slope 1
        local cStylePels:            dword ; # of pixels in line (before clip)
        local xStart:                dword ; Start pixel x-offset before clip
        local pfn:                   ptr   ; Pointer to strip drawing function
        local cPels:                 dword ; # pixels to be drawn (after clip)
        local i:                     dword ; # pixels in strip
        local r:                     dword ; Remainder (or "error") term
        local d_I:                   dword ; Delta-I
        local d_R:                   dword ; Delta-R
        local plStripEnd:            ptr   ; Last strip in buffer
        local ptlStart[size POINTL]: byte  ; Unnormalized start coord
        local dN_Original:           dword ; dN before half-flip
        local xClipLeft:             dword ; Left side of clip rectangle
        local xClipRight:            dword ; Right side of clip rectangle
        local strip[size STRIPS]:    byte  ; Our strip buffer

        mov     ecx, cptfx
        mov     edx, pptfxBuf
        lea     eax, [edx + ecx * (size POINTL) - (size POINTL)]
        mov     pptfxBufEnd, eax        ; pptfxBufEnd is inclusive of end point

        mov     eax, [edx].ptl_x        ; Load up end point (M1, N1)
        mov     edi, [edx].ptl_y

        mov     edx, pptfxFirst         ; Load up start point (M0, N0)
        mov     esi, [edx].ptl_x
        mov     ecx, [edx].ptl_y

        mov     ebx, flStart

;-----------------------------------------------------------------------;
; Flip to the first octant.                                             ;
;-----------------------------------------------------------------------;

; Register state:       esi = M0
;                       ecx = N0
;                       eax = dM (M1)
;                       edi = dN (N1)
;                       ebx = fl

; Make sure we go left to right:

the_main_loop:
        cmp     esi, eax
        jle     short is_left_to_right  ; skip if M0 <= M1
        xchg    esi, eax                ; swap M0, M1
        xchg    ecx, edi                ; swap N0, N1
        or      ebx, FL_FLIP_H

is_left_to_right:

; Compute the deltas, remembering that the DDI says we should get
; deltas less than 2^31.  If we get more, we ensure we don't crash
; later on by simply skipping the line:

        sub     eax, esi                ; eax = dM
        jo      next_line               ; dM must be less than 2^31
        sub     edi, ecx                ; edi = dN
        jo      next_line               ; dN must be less than 2^31

        jge     short is_top_to_bottom  ; skip if dN >= 0
        neg     ecx                     ; N0 = -N0
        neg     edi                     ; N1 = -N1
        or      ebx, FL_FLIP_V

is_top_to_bottom:
        cmp     edi, eax
        jb      short done_flips        ; skip if dN < dM
        jne     short slope_more_than_one

; We must special case slopes of one:

        or      ebx, FL_FLIP_SLOPE_ONE
        jmp     short done_flips

slope_more_than_one:
        xchg    eax, edi                ; swap dM, dN
        xchg    esi, ecx                ; swap M0, N0
        or      ebx, FL_FLIP_D

done_flips:

        mov     edx, ebx
        and     edx, FL_ROUND_MASK
        .errnz  FL_ROUND_SHIFT - 2
        or      ebx, [gaflRoundTable + edx]  ; get our rounding flags

        mov     dM, eax                 ; save some info
        mov     dN, edi
        mov     fl, ebx

        mov     edx, esi                ; x = LFLOOR(M0)
        sar     edx, FLOG2
        mov     x, edx

        mov     edx, ecx                ; y = LFLOOR(N0)
        sar     edx, FLOG2
        mov     y, edx

;-----------------------------------------------------------------------;
; Compute the fractional remainder term                                 ;
;-----------------------------------------------------------------------;

        public  compute_fractional
compute_fractional::
        and     esi, F - 1              ; M0 = FXFRAC(M0)
        and     ecx, F - 1              ; N0 = FXFRAC(N0)

        mov     M0, esi                 ; save M0, N0 for later
        mov     N0, ecx

        lea     edx, [ecx + F/2]
        mul     edx                     ; [edx:eax] = dM * (N0 + F/2)
        xchg    eax, edi
        mov     ecx, edx                ; [ecx:edi] = dM * (N0 + F/2)
                                        ; (we just nuked N0)

        mul     esi                     ; [edx:eax] = dN * M0

; Now gamma = dM * (N0 + F/2) - dN * M0 - bRoundDown

        .errnz  FL_V_ROUND_DOWN - 8000h
        ror     bh, 8
        sbb     edi, eax
        sbb     ecx, edx

        shrd    edi, ecx, FLOG2
        sar     ecx, FLOG2              ; gamma = [ecx:edi] >>= 4

        mov     eqGamma_hi, ecx
        mov     eqGamma_lo, edi

        mov     eax, N0

; Register state:
;                       eax = N0
;                       ebx = fl
;                       ecx = eqGamma_hi
;                       edx = garbage
;                       esi = M0
;                       edi = eqGamma_lo

        testb   ebx, FL_FLIP_H
        jnz     line_runs_right_to_left

;-----------------------------------------------------------------------;
; Figure out which pixels are at the ends of a left-to-right line.      ;
;                               -------->                               ;
;-----------------------------------------------------------------------;

        public line_runs_left_to_right
line_runs_left_to_right::
        or      esi, esi
        jz      short LtoR_check_slope_one
                                        ; skip ahead if M0 == 0
                                        ;   (in that case, x0 = 0 which is to be
                                        ;   kept in esi, and is already
                                        ;   conventiently zero)

        or      eax, eax
        jnz     short LtoR_N0_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     esi, -F/2
        shr     esi, FLOG2
        jmp     short LtoR_check_slope_one
                                        ; esi = x0 = rounded M0

LtoR_N0_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        cmp     esi, eax
        sbb     esi, esi
        inc     esi                     ; esi = x0 = (abs(N0 - F/2) <= M0)

        public  LtoR_check_slope_one
LtoR_check_slope_one::
        mov     ulSlopeOneAdjustment, 0
        mov     eax, ebx
        and     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        cmp     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        jne     short LtoR_compute_y0_from_x0

; We have to special case lines that are exactly of slope 1 or -1:

        ;
        ;       if (M1 > 0) AMD (N1 == M1 + 8)
        ;

        mov     eax, N0
        add     eax, dN
        and     eax, F - 1              ; eax = N1

        mov     edx, M0
        add     edx, dM
        and     edx, F - 1              ; edx = M1

        jz      short LtoR_slope_one_check_start_point

        add     edx, F/2                ; M1 + 8
        cmp     edx, eax                ; cmp N1, M1 + 8
        jne     short LtoR_slope_one_check_start_point
        mov     ulSlopeOneAdjustment, -1

LtoR_slope_one_check_start_point:

        ;
        ;       if (M0 > 0) AMD (N0 == M0 + 8)
        ;

        mov     eax, M0
        or      eax, eax
        jz      short LtoR_compute_y0_from_x0

        add     eax, F/2
        cmp     eax, N0                 ; cmp M0 + 8, N0
        jne     short LtoR_compute_y0_from_x0

        xor     esi, esi                ; x0 = 0

LtoR_compute_y0_from_x0:

; ecx = eqGamma_hi
; esi = x0
; edi = eqGamma_lo

        mov     eax, dN
        mov     edx, dM

        mov     x0, esi
        mov     y0, 0
        cmp     ecx, 0
        jl      short LtoR_compute_x1

        neg     esi
        and     esi, eax
        sub     edx, esi
        cmp     edi, edx
        mov     edx, dM
        jb      short LtoR_compute_x1   ; Bug fix: Must be unsigned!
        mov     y0, 1                   ; y0 = floor((dN * x0 + eqGamma) / dM)

LtoR_compute_x1:

; Register state:
;                       eax = dN
;                       ebx = fl
;                       ecx = garbage
;                       edx = dM
;                       esi = garbage
;                       edi = garbage

        mov     esi, M0
        add     esi, edx
        mov     ecx, esi
        shr     esi, FLOG2
        dec     esi                     ; x1 = ((M0 + dM) >> 4) - 1
        add     esi, ulSlopeOneAdjustment
        and     ecx, F-1                ; M1 = (M0 + dM) & 15
        jz      done_first_pel_last_pel

        add     eax, N0
        and     eax, F-1                ; N1 = (N0 + dN) & 15
        jnz     short LtoR_N1_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     ecx, -F/2
        shr     ecx, FLOG2              ; ecx = LROUND(M1, fl & FL_ROUND_DOWN)
        add     esi, ecx
        jmp     done_first_pel_last_pel

LtoR_N1_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        cmp     eax, ecx
        jg      done_first_pel_last_pel
        inc     esi
        jmp     done_first_pel_last_pel

;-----------------------------------------------------------------------;
; Figure out which pixels are at the ends of a right-to-left line.      ;
;                               <--------                               ;
;-----------------------------------------------------------------------;

; Compute x0:

        public  line_runs_right_to_left
line_runs_right_to_left::
        mov     x0, 1                   ; x0 = 1
        or      eax, eax
        jnz     short RtoL_N0_not_zero

        xor     edx, edx                ; ulDelta = 0
        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     esi, -F/2
        shr     esi, FLOG2              ; esi = LROUND(M0, fl & FL_H_ROUND_DOWN)
        jz      short RtoL_check_slope_one

        mov     x0, 2
        mov     edx, dN
        jmp     short RtoL_check_slope_one

RtoL_N0_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        add     eax, esi                ; eax = ABS(N0 - F/2) + M0
        xor     edx, edx                ; ulDelta = 0
        cmp     eax, F
        jle     short RtoL_check_slope_one

        mov     x0, 2                   ; x0 = 2
        mov     edx, dN                 ; ulDelta = dN

        public  RtoL_check_slope_one
RtoL_check_slope_one::
        mov     ulSlopeOneAdjustment, 0
        mov     eax, ebx
        and     eax, FL_FLIP_SLOPE_ONE + FL_H_ROUND_DOWN
        cmp     eax, FL_FLIP_SLOPE_ONE
        jne     short RtoL_compute_y0_from_x0

; We have to special case lines that are exactly of slope 1 or -1:

        ;
        ;  if ((N1 > 0) && (M1 == N1 + 8))
        ;

        mov     eax, N0
        add     eax, dN
        and     eax, F - 1              ; eax = N1
        jz      short RtoL_slope_one_check_start_point

        mov     esi, M0
        add     esi, dM
        and     esi, F - 1              ; esi = M1

        add     eax, F/2                ; N1 + 8
        cmp     esi, eax                ; cmp M1, N1 + 8
        jne     short RtoL_slope_one_check_start_point
        mov     ulSlopeOneAdjustment, 1

RtoL_slope_one_check_start_point:

        ;
        ;  if ((N0 > 0) && (M0 == N0 + 8))
        ;

        mov     eax,N0                  ; eax = N0
        or      eax,eax                 ; check for N0 == 0
        jz      short RtoL_compute_y0_from_x0

        mov     esi, M0                 ; esi = M0

        add     eax, F/2                ; N0 + 8
        cmp     eax, esi                ; cmp M0 , N0 + 8
        jne     short RtoL_compute_y0_from_x0

        mov     x0, 2                   ; x0 = 2
        mov     edx, dN                 ; ulDelta = dN

RtoL_compute_y0_from_x0:

; eax = garbage
; ebx = fl
; ecx = eqGamma_hi
; edx = ulDelta
; esi = garbage
; edi = eqGamma_lo

        mov     eax, dN                 ; eax = dN
        mov     y0, 0                   ; y0 = 0

        add     edi, edx
        adc     ecx, 0                  ; eqGamma += ulDelta
                                        ; NOTE: Setting flags here!
        mov     edx, dM                 ; edx = dM
        jl      short RtoL_compute_x1   ; NOTE: Looking at the flags here!
        jg      short RtoL_y0_is_2

        lea     ecx, [edx + edx]
        sub     ecx, eax                ; ecx = 2 * dM - dN
        cmp     edi, ecx
        jae     short RtoL_y0_is_2      ; Bug fix: Must be unsigned!

        sub     ecx, edx                ; ecx = dM - dN
        cmp     edi, ecx
        jb      short RtoL_compute_x1   ; Bug fix: Must be unsigned!

        mov     y0, 1
        jmp     short RtoL_compute_x1

RtoL_y0_is_2:
        mov     y0, 2

RtoL_compute_x1:

; Register state:
;                       eax = dN
;                       ebx = fl
;                       ecx = garbage
;                       edx = dM
;                       esi = garbage
;                       edi = garbage

        mov     esi, M0
        add     esi, edx
        mov     ecx, esi
        shr     esi, FLOG2              ; x1 = (M0 + dM) >> 4
        add     esi, ulSlopeOneAdjustment
        and     ecx, F-1                ; M1 = (M0 + dM) & 15

        add     eax, N0
        and     eax, F-1                ; N1 = (N0 + dN) & 15
        jnz     short RtoL_N1_not_zero

        .errnz  FL_H_ROUND_DOWN - 80h
        ror     bl, 8
        sbb     ecx, -F/2
        shr     ecx, FLOG2              ; ecx = LROUND(M1, fl & FL_ROUND_DOWN)
        add     esi, ecx
        jmp     done_first_pel_last_pel

RtoL_N1_not_zero:
        sub     eax, F/2
        sbb     edx, edx
        xor     eax, edx
        sub     eax, edx
        add     eax, ecx                ; eax = ABS(N1 - F/2) + M1
        cmp     eax, F+1
        sbb     esi, -1

done_first_pel_last_pel:

; Register state:
;                       eax = garbage
;                       ebx = fl
;                       ecx = garbage
;                       edx = garbage
;                       esi = x1
;                       edi = garbage

        mov     ecx, x0
        lea     edx, [esi + 1]
        sub     edx, ecx                ; edx = x1 - x0 + 1

        jle     next_line
        mov     cStylePels, edx
        mov     xStart, ecx

;-----------------------------------------------------------------------;
; See if clipping or styling needs to be done.                          ;
;-----------------------------------------------------------------------;

        testb   ebx, FL_CLIP
        jnz     do_some_clipping

; Register state:
;                       eax = garbage
;                       ebx = fl
;                       ecx = x0
;                       edx = garbage
;                       esi = x1
;                       edi = garbage

done_clipping:
        mov     eax, y0

        sub     esi, ecx
        inc     esi                     ; esi = cPels = x1 - x0 + 1
        mov     cPels, esi

        add     ecx, x                  ; ecx = ptlStart.ptl_x
        add     eax, y                  ; eax = ptlStart.ptl_y

        testb   ebx, FL_FLIP_D
        jz      short do_v_unflip
        xchg    ecx, eax

do_v_unflip:
        testb   ebx, FL_FLIP_V
        jz      short done_unflips
        neg     eax

done_unflips:
        testb   ebx, FL_STYLED
        jnz     do_some_styling

done_styling:
        lea     edx, [strip.ST_alStrips + (STRIP_MAX * 4)]
        mov     plStripEnd, edx

;-----------------------------------------------------------------------;
; Setup to do DDA.                                                      ;
;-----------------------------------------------------------------------;

; Register state:
;                       eax = ptlStart.ptl_y
;                       ebx = fl
;                       ecx = ptlStart.ptl_x
;                       edx = garbage
;                       esi = garbage
;                       edi = garbage

        mov     strip.ST_ptlStart.ptl_x, ecx
        mov     strip.ST_ptlStart.ptl_y, eax

        mov     eax, dM
        mov     ecx, dN
        mov     esi, eqGamma_lo
        mov     edi, eqGamma_hi


; Register state:
;                       eax = dM
;                       ebx = fl
;                       ecx = dN
;                       edx = garbage
;                       esi = eqGamma_lo
;                       edi = eqGamma_hi

        lea     edx, [ecx + ecx]        ; if (2 * dN > dM)
        cmp     edx, eax
        mov     edx, y0                 ; Load y0 again
        jbe     short after_half_flip

        test    ebx, (FL_STYLED + FL_DONT_DO_HALF_FLIP)
        jnz     short after_half_flip

        or      ebx, FL_FLIP_HALF
        mov     fl, ebx

; Do a half flip!

        not     esi
        not     edi
        add     esi, eax
        adc     edi, 0                  ; eqGamma = -eqGamma - 1 + dM

        neg     ecx
        add     ecx, eax                ; dN = dM - dN

        neg     edx
        add     edx, x0                 ; y0 = x0 - y0

after_half_flip:
        mov     strip.ST_flFlips, ebx
        mov     eax, dM

; Register state:
;                       eax = dM
;                       ebx = fl
;                       ecx = dN
;                       edx = y0
;                       esi = eqGamma_lo
;                       edi = eqGamma_hi

        or      ecx, ecx
        jz      short zero_slope

compute_dda_stuff:
        inc     edx
        mul     edx
        stc                             ; set the carry to accomplish -1
        sbb     eax, esi
        sbb     edx, edi                ; (y0 + 1) * dM - eqGamma - 1
        div     ecx

        mov     esi, eax                ; esi = i
        mov     edi, edx                ; edi = r

        xor     edx, edx
        mov     eax, dM
        div     ecx                     ; edx = d_R, eax = d_I
        mov     d_I, eax

        sub     esi, x0
        inc     esi

done_dda_stuff:

; Register state:
;                       eax = d_I
;                       ebx = fl
;                       ecx = dN
;                       edx = d_R
;                       esi = i
;                       edi = r

; We're going to decide if we can call the short-vector routines.  They
; can only take strips that have a maximum length of 15 pixels each.
; We happen to know that the longest strip in our line could be is d_I + 1.

        and     ebx, FL_STRIP_MASK
        mov     eax, apfn

        .errnz  FL_STRIP_SHIFT
        lea     eax, [eax + ebx * 4]

        cmp     d_I, MAX_SHORT_STROKE_LENGTH
        sbb     ebx, ebx                ; ffffffffh when < 15, 0 when >= 15
        and     ebx, NUM_STRIP_DRAW_DIRECTIONS * 4
                                        ; Look four entries further into table

        mov     eax, [eax + ebx]
        mov     pfn, eax

        lea     eax, [strip.ST_alStrips]
        mov     ebx, cPels

;-----------------------------------------------------------------------;
; Do our main DDA loop.                                                 ;
;-----------------------------------------------------------------------;

; Register state:
;                       eax = plStrip
;                       ebx = cPels
;                       ecx = dN
;                       edx = d_R
;                       esi = i
;                       edi = r

dda_loop:
        sub     ebx, esi
        jle     final_strip

        mov     [eax], esi
        add     eax, 4
        cmp     plStripEnd, eax
        jbe     short output_strips

done_output_strips:
        mov     esi, d_I
        add     edi, edx
        cmp     edi, ecx
        jb      short dda_loop

        sub     edi, ecx
        inc     esi
        jmp     short dda_loop

zero_slope:
        mov     esi, 7fffffffh          ; Make run maximum length (cPels
                                        ;   actually decideds how long the line
                                        ;   is)
        mov     d_I, 7fffffffh          ; Make delta maximum length so that
                                        ; we don't try to do short vectors
        mov     eax, cPels              ; We need this when we decide if to do
        dec     eax                     ;   short strip routines.
        jmp     short done_dda_stuff

;-----------------------------------------------------------------------;
; Empty strips buffer.                                                  ;
;-----------------------------------------------------------------------;

output_strips:
        mov     d_R, edx
        mov     cPels, ebx
        mov     i, esi
        mov     r, edi
        mov     dN, ecx

        lea     edx, [strip.ST_alStrips]
        sub     eax, edx
        shr     eax, 2
        mov     strip.ST_cStrips, eax

        mov     eax, ppdev
        lea     edx, [strip]
        mov     ecx, pls

        ptrCall <dword ptr pfn>, \
                <eax, edx, ecx>

        mov     esi, i
        mov     edi, r
        mov     ebx, cPels
        mov     edx, d_R
        mov     ecx, dN
        lea     eax, [strip.ST_alStrips]
        jmp     done_output_strips

;-----------------------------------------------------------------------;
; Empty strips buffer and go on to next line.                           ;
;-----------------------------------------------------------------------;

final_strip:
        add     ebx, esi
        mov     [eax], ebx
        add     eax, 4

very_final_strip:
        lea     edx, [strip.ST_alStrips]
        sub     eax, edx
        shr     eax, 2
        mov     strip.ST_cStrips, eax

        mov     eax, ppdev
        lea     edx, [strip]
        mov     ecx, pls

        ptrCall   <dword ptr pfn>, \
                <eax, edx, ecx>

next_line:
        mov     ebx, flStart
        testb   ebx, FL_COMPLEX_CLIP
        jnz     short see_if_done_complex_clipping

        mov     edx, pptfxBuf
        cmp     edx, pptfxBufEnd
        je      short all_done

        mov     esi, [edx].ptl_x
        mov     ecx, [edx].ptl_y
        add     edx, size POINTL
        mov     pptfxBuf, edx
        mov     eax, [edx].ptl_x
        mov     edi, [edx].ptl_y
        jmp     the_main_loop

all_done:
        mov     eax, 1

        cRet    bLines

see_if_done_complex_clipping:
        mov     ebx, fl
        dec     cptfx
        jz      short all_done
        jmp     continue_complex_clipping

;---------------------------Private-Routine-----------------------------;
; do_some_styling
;
; Inputs:
;       eax = ptlStart.ptl_y
;       ebx = fl
;       ecx = ptlStart.ptl_x
; Preserves:
;       eax, ebx, ecx
; Output:
;       Exits to done_styling.
;
;-----------------------------------------------------------------------;

do_some_styling:
        mov     ptlStart.ptl_x, ecx

        mov     esi, pls
        mov     edi, [esi].LS_spNext    ; spThis
        mov     edx, edi
        add     edx, cStylePels         ; spNext

; For styles, we don't bother to keep the style position normalized.
; (we do ensure that it's positive, though).  If a figure is over 2
; billion pels long, we'll be a pel off in our style state (oops!).

        and     edx, 7fffffffh
        mov     [esi].LS_spNext, edx
        mov     ptlStart.ptl_y, eax

; Do arbitrary styles:

do_arbitrary_style:
        testb   ebx, FL_FLIP_H
        jz      short arbitrary_left_to_right

        sub     edx, x0
        add     edx, xStart
        mov     eax, edx
        xor     edx, edx
        div     [esi].LS_spTotal

        neg     edx
        jge     short continue_right_to_left
        add     edx, [esi].LS_spTotal
        not     eax

continue_right_to_left:
        mov     edi, dword ptr [esi].LS_jStartMask
        not     edi
        mov     ecx, [esi].LS_aspRtoL
        jmp     short compute_arbitrary_stuff

arbitrary_left_to_right:
        add     edi, x0
        sub     edi, xStart
        mov     eax, edi
        xor     edx, edx
        div     [esi].LS_spTotal
        mov     edi, dword ptr [esi].LS_jStartMask
        mov     ecx, [esi].LS_aspLtoR

compute_arbitrary_stuff:
;       eax = sp / spTotal
;       ebx = fl
;       ecx = pspStart
;       edx = sp % spTotal
;       esi = pla
;       edi = jStyleMask

        and     eax, [esi].LS_cStyle        ; if odd length style and second run
        and     al, 1                       ; through style array, flip the
        jz      short odd_style_array_done  ; meaning of the elements
        not     edi

odd_style_array_done:
        mov     [esi].LS_pspStart, ecx
        mov     eax, [esi].LS_cStyle
        lea     eax, [ecx + eax * 4 - 4]
        mov     [esi].LS_pspEnd, eax

find_psp:
        sub     edx, [ecx]
        jl      short found_psp
        add     ecx, 4
        jmp     short find_psp

found_psp:
        mov     [esi].LS_psp, ecx
        neg     edx
        mov     [esi].LS_spRemaining, edx

        sub     ecx, [esi].LS_pspStart
        test    ecx, 4                  ; size STYLEPOS
        jz      short done_arbitrary
        not     edi

done_arbitrary:
        mov     dword ptr [esi].LS_jStyleMask, edi
        mov     eax, ptlStart.ptl_y
        mov     ecx, ptlStart.ptl_x
        jmp     done_styling


;---------------------------Private-Routine-----------------------------;
; do_some_clipping
;
; Inputs:
;       eax = garbage
;       ebx = fl
;       ecx = x0
;       edx = garbage
;       esi = x1
;       edi = garbage
;
; Decides whether to do simple or complex clipping.
;
;-----------------------------------------------------------------------;

        align 4

        public  do_some_clipping
do_some_clipping::
        testb   ebx, FL_COMPLEX_CLIP
        jnz     initialize_complex_clipping

;-----------------------------------------------------------------------;
; simple_clipping
;
; Inputs:
;       ebx = fl
;       ecx = x0
;       esi = x1
; Output:
;       ebx = fl
;       ecx = new x0 (stack variable updated too)
;       esi = new x1
;       y0 stack variable updated
; Uses:
;       All registers
; Exits:
;       to done_clipping
;
; This routine handles clipping the line to the clip rectangle (it's
; faster to handle this case in the driver than to call the engine to
; clip for us).
;
; Fractional end-point lines complicate our lives a bit when doing
; clipping:
;
; 1) For styling, we must know the unclipped line's length in pels, so
;    that we can correctly update the styling state when the line is
;    clipped.  For this reason, I do clipping after doing the hard work
;    of figuring out which pixels are at the ends of the line (this is
;    wasted work if the line is not styled and is completely clipped,
;    but I think it's simpler this way).  Another reason is that we'll
;    have calculated eqGamma already, which we use for the intercept
;    calculations.
;
;    With the assumption that most lines will not be completely clipped
;    away, this strategy isn't too painful.
;
; 2) x0, y0 are not necessarily zero, where (x0, y0) is the start pel of
;    the line.
;
; 3) We know x0, y0 and x1, but not y1.  We haven't needed to calculate
;    y1 until now.  We'll need the actual value, and not an upper bound
;    like y1 = LFLOOR(dM) + 2 because we have to be careful when
;    calculating x(y) that y0 <= y <= y1, otherwise we can cause an
;    overflow on the divide (which, needless to say, is bad).
;
;-----------------------------------------------------------------------;

        public  simple_clipping
simple_clipping::
        mov     edi, prclClip           ; get pointer to normalized clip rect
        and     ebx, FL_RECTLCLIP_MASK  ;   (it's lower-right exclusive)

        .errnz  (FL_RECTLCLIP_SHIFT - 2); ((ebx AND FL_RECTLCLIP_MASK) shr
        .errnz  (size RECTL) - 16       ;   FL_RECTLCLIP_SHIFT) is our index
        lea     edi, [edi + ebx*4]      ;   into the array of rectangles

        mov     edx, [edi].xRight       ; load the rect coordinates
        mov     eax, [edi].xLeft
        mov     ebx, [edi].yBottom
        mov     edi, [edi].yTop

; Translate to our origin and so some quick completely clipped tests:

        sub     edx, x
        cmp     ecx, edx
        jge     totally_clipped         ; totally clipped if x0 >= xRight

        sub     eax, x
        cmp     esi, eax
        jl      totally_clipped         ; totally clipped if x1 < xLeft

        sub     ebx, y
        cmp     y0, ebx
        jge     totally_clipped         ; totally clipped if y0 >= yBottom

        sub     edi, y

; Save some state:

        mov     xClipRight, edx
        mov     xClipLeft, eax

        cmp     esi, edx                ; if (x1 >= xRight) x1 = xRight - 1
        jl      short calculate_y1
        lea     esi, [edx - 1]

calculate_y1:
        mov     eax, esi                ; y1 = (x1 * dN + eqGamma) / dM
        mul     dN
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi
        div     dM

        cmp     edi, eax                ; if (yTop > y1) clipped
        jg      short totally_clipped

        cmp     ebx, eax                ; if (yBottom > y1) know x1
        jg      short x1_computed

        mov     eax, ebx                ; x1 = (yBottom * dM + eqBeta) / dN
        mul     dM
        stc
        sbb     eax, eqGamma_lo
        sbb     edx, eqGamma_hi
        div     dN
        mov     esi, eax

; At this point, we've taken care of calculating the intercepts with the
; right and bottom edges.  Now we work on the left and top edges:

x1_computed:
        mov     edx, y0

        mov     eax, xClipLeft          ; don't have to compute y intercept
        cmp     eax, ecx                ;   at left edge if line starts to
        jle     short top_intercept     ;   right of left edge

        mov     ecx, eax                ; x0 = xLeft
        mul     dN                      ; y0 = (xLeft * dN + eqGamma) / dM
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi
        div     dM

        cmp     ebx, eax                ; if (yBottom <= y0) clipped
        jle     short totally_clipped

        mov     edx, eax
        mov     y0, eax

top_intercept:
        mov     ebx, fl                 ; get ready to leave
        mov     x0, ecx

        cmp     edi, edx                ; if (yTop <= y0) done clipping
        jle     done_clipping

        mov     eax, edi                ; x0 = (yTop * dM + eqBeta) / dN + 1
        mul     dM
        stc
        sbb     eax, eqGamma_lo
        sbb     edx, eqGamma_hi
        div     dN
        lea     ecx, [eax + 1]

        cmp     xClipRight, ecx         ; if (xRight <= x0) clipped
        jle     short totally_clipped

        mov     y0, edi                 ; y0 = yTop
        mov     x0, ecx
        jmp     done_clipping           ; all done!

totally_clipped:

; The line is completely clipped.  See if we have to update our style state:

        mov     ebx, fl
        testb   ebx, FL_STYLED
        jz      next_line

; Adjust our style state:

        mov     esi, pls
        mov     eax, [esi].LS_spNext
        add     eax, cStylePels
        mov     [esi].LS_spNext, eax

        cmp     eax, [esi].LS_spTotal2
        jb      next_line

; Have to normalize first:

        xor     edx, edx
        div     [esi].LS_spTotal2
        mov     [esi].LS_spNext, edx

        jmp     next_line

;-----------------------------------------------------------------------;

initialize_complex_clipping:
        mov     eax, dN                 ; save a copy of original dN
        mov     dN_Original, eax

;---------------------------Private-Routine-----------------------------;
; continue_complex_clipping
;
; Inputs:
;       ebx = fl
; Output:
;       ebx = fl
;       ecx = x0
;       esi = x1
; Uses:
;       All registers.
; Exits:
;       to done_clipping
;
; This routine handles the necessary initialization for the next
; run in the CLIPLINE structure.
;
; NOTE: This routine is jumped to from two places!
;-----------------------------------------------------------------------;

        public  continue_complex_clipping
continue_complex_clipping::
        mov     edi, prun
        mov     ecx, xStart
        testb   ebx, FL_FLIP_H
        jz      short complex_left_to_right

complex_right_to_left:

; Figure out x0 and x1 for right-to-left lines:

        add     ecx, cStylePels
        dec     ecx
        mov     esi, ecx                ; esi = ecx = xStart + cStylePels - 1
        sub     ecx, [edi].RUN_iStop    ; New x0
        sub     esi, [edi].RUN_iStart   ; New x1
        jmp     short complex_reset_variables

complex_left_to_right:

; Figure out x0 and x1 for left-to-right lines:

        mov     esi, ecx                ; esi = ecx = xStart
        add     ecx, [edi].RUN_iStart   ; New x0
        add     esi, [edi].RUN_iStop    ; New x1

complex_reset_variables:
        mov     x0, ecx

; The half flip mucks with some of our variables, and we have to reset
; them every pass.  We would have to reset eqGamma too, but it never
; got saved to memory in its modified form.

        add     edi, size RUN
        mov     prun, edi               ; Increment run pointer for next time

        mov     edi, pls
        mov     eax, [edi].LS_spComplex
        mov     [edi].LS_spNext, eax    ; pls->spNext = pls->spComplex

        mov     eax, dN_Original        ; dN = dN_Original
        mov     dN, eax

        mul     ecx
        add     eax, eqGamma_lo
        adc     edx, eqGamma_hi         ; [edx:eax] = dN*x0 + eqGamma

        div     dM
        mov     y0, eax
        jmp     done_clipping

endProc bLines
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\i386\hw.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: hw.inc
;
; All the hardware specific driver file stuff.  Mirrors some of 'hw.h'.
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

; ////////////////////////////////////////////////////////////////////////
; // Chip equates:

STATUS_1                        equ 03DAh
VSY_NOT                         equ 08h

CRTC_INDEX                      equ 03D4h
CRTC_DATA                       equ 03D5h

S3R8                            equ 038h
S3R9                            equ 039h
S3R1                            equ 031h
S3R5                            equ 035h

CR39                            equ 039h
CR4C                            equ 04Ch
CR4D                            equ 04Dh

HGC_MODE                        equ 045h
HGC_ENABLE                      equ 001h
HGC_DISABLE                     equ 000h


HGC_ORGX_LSB                    equ 047h
HGC_ORGX_MSB                    equ 046h
HGC_ORGY_LSB                    equ 049h
HGC_ORGY_MSB                    equ 048h

HGC_DX                          equ 04Eh
HGC_DY                          equ 04Fh


REG_UNLOCK_1                    equ 048h
CPUA_BASE                       equ 001h

SYSCTL_UNLOCK                   equ 0A0h
SYSCTL_LOCK                     equ 000h

SYS_CNFG                        equ 040h
LAW_CTL                         equ 058h
EX_SCTL_2                       equ 051h
EX_DAC_CT                       equ 055h

MISC_1                          equ 03Ah

; Command types:

DRAW_LINE                       equ 02000h
RECTANGLE_FILL                  equ 04000h
BITBLT                          equ 0C000h
PATTERN_FILL                    equ 0E000h

BYTE_SWAP                       equ 01000h
BUS_SIZE_16                     equ 00200h
BUS_SIZE_8                      equ 00000h
WAIT_CPU                        equ 00100h

; Drawing directions (radial):

DRAWING_DIRECTION_0             equ 0000h
DRAWING_DIRECTION_45            equ 0020h
DRAWING_DIRECTION_90            equ 0040h
DRAWING_DIRECTION_135           equ 0060h
DRAWING_DIRECTION_180           equ 0080h
DRAWING_DIRECTION_225           equ 00A0h
DRAWING_DIRECTION_270           equ 00C0h
DRAWING_DIRECTION_315           equ 00E0h

; Drawing directions (x/y):

DRAWING_DIR_BTRLXM              equ 0000h
DRAWING_DIR_BTLRXM              equ 0020h
DRAWING_DIR_BTRLYM              equ 0040h
DRAWING_DIR_BTLRYM              equ 0060h
DRAWING_DIR_TBRLXM              equ 0080h
DRAWING_DIR_TBLRXM              equ 00A0h
DRAWING_DIR_TBRLYM              equ 00C0h
DRAWING_DIR_TBLRYM              equ 00E0h

; Drawing direction bits:

PLUS_X                          equ 0020h
PLUS_Y                          equ 0080h
MAJOR_Y                         equ 0040h

; Draw:

DRAW                            equ 0010h

; Direction type:

DIR_TYPE_RADIAL                 equ 0008h
DIR_TYPE_XY                     equ 0000h

; Last pixel:

LAST_PIXEL_OFF                  equ 0004h
LAST_PIXEL_ON                   equ 0000h

; Pixel mode:

MULTIPLE_PIXELS                 equ 0002h
SINGLE_PIXEL                    equ 0000h

; Read/write:

READ                            equ 0000h
WRITE                           equ 0001h

; Graphics processor status:

HARDWARE_BUSY                   equ 0200h
READ_DATA_AVAILABLE             equ 0100h
GP_ALL_EMPTY                    equ 0400h

; Fifo status in terms of empty entries:

FIFO_1_EMPTY                    equ 0080h
FIFO_2_EMPTY                    equ 0040h
FIFO_3_EMPTY                    equ 0020h
FIFO_4_EMPTY                    equ 0010h
FIFO_5_EMPTY                    equ 0008h
FIFO_6_EMPTY                    equ 0004h
FIFO_7_EMPTY                    equ 0002h
FIFO_8_EMPTY                    equ 0001h

; These are the defines for the multifunction control register.
; The 4 MSBs define the function of the register.

RECT_HEIGHT                     equ 00000h

CLIP_TOP                        equ 01000h
CLIP_LEFT                       equ 02000h
CLIP_BOTTOM                     equ 03000h
CLIP_RIGHT                      equ 04000h

DATA_EXTENSION                  equ 0A000h
MULT_MISC_INDEX                 equ 0E000h
READ_SEL_INDEX                  equ 0F000h

ALL_ONES                        equ 00000h
CPU_DATA                        equ 00080h
DISPLAY_MEMORY                  equ 000C0h

; Colour source:

BACKGROUND_COLOR                equ 000h
FOREGROUND_COLOR                equ 020h
SRC_CPU_DATA                    equ 040h
SRC_DISPLAY_MEMORY              equ 060h

; Mix modes:

NOT_SCREEN                      equ 00h
LOGICAL_0                       equ 01h
LOGICAL_1                       equ 02h
LEAVE_ALONE                     equ 03h
NOT_NEW                         equ 04h
SCREEN_XOR_NEW                  equ 05h
NOT_SCREEN_XOR_NEW              equ 06h
OVERPAINT                       equ 07h
NOT_SCREEN_OR_NOT_NEW           equ 08h
SCREEN_OR_NOT_NEW               equ 09h
NOT_SCREEN_OR_NEW               equ 0Ah
SCREEN_OR_NEW                   equ 0Bh
SCREEN_AND_NEW                  equ 0Ch
NOT_SCREEN_AND_NEW              equ 0Dh
SCREEN_AND_NOT_NEW              equ 0Eh
NOT_SCREEN_AND_NOT_NEW          equ 0Fh

; When one of the following bits is set in a hardware mix, it means
; that a pattern is needed (i.e., is none of NOT_SCREEN, LOGICAL_0,
; LOGICAL_1 or LEAVE_ALONE):

MIX_NEEDSPATTERN                equ 0Ch

; ////////////////////////////////////////////////////////////////////
; // S3 port control
; ////////////////////////////////////////////////////////////////////

; Accelerator port addresses:

CUR_Y                           equ 082E8h
CUR_X                           equ 086E8h
DEST_Y                          equ 08AE8h
DEST_X                          equ 08EE8h
AXSTP                           equ 08AE8h
DIASTP                          equ 08EE8h
ERR_TERM                        equ 092E8h
MAJ_AXIS_PCNT                   equ 096E8h
CMD                             equ 09AE8h
SHORT_STROKE                    equ 09EE8h
BKGD_COLOR                      equ 0A2E8h
FRGD_COLOR                      equ 0A6E8h
WRT_MASK                        equ 0AAE8h
RD_MASK                         equ 0AEE8h
COLOR_CMP                       equ 0B2E8h
BKGD_MIX                        equ 0B6E8h
FRGD_MIX                        equ 0BAE8h
MULTIFUNC_CNTL                  equ 0BEE8h
MIN_AXIS_PCNT                   equ 0BEE8h
SCISSORS_T                      equ 0BEE8h
SCISSORS_L                      equ 0BEE8h
SCISSORS_B                      equ 0BEE8h
SCISSORS_R                      equ 0BEE8h
PIX_CNTL                        equ 0BEE8h
PIX_TRANS                       equ 0E2E8h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\i386\fasttext.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fasttext.asm
;
; Copyright (c) 1992-1994 Microsoft Corporation
;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
; VOID vFastText(GLYPHPOS * pGlyphPos, ULONG ulGlyphCount, PBYTE pTempBuffer,
;                ULONG ulBufDelta, ULONG ulCharInc,
;                RECTL * prclText, RECTL * prclOpaque,
;                ULONG fDrawFlags, RECTL * prclClip,
;                RECTL * prclExtra);
; pGlyphPos -
; ulGlyphCount - # of glyphs to draw. Must never be 0.
; pTempBuffer -
; ulBufDelta -
; ulCharInc -
; prclText -
; prclOpaque -
; fDrawFlags -
; prclClip -     array of clipping rectangles
; prclExtra -    array of extra rectangles to fill in foreground color
;
; Draws glyphs into a 1bpp buffer using the CPU, so that the hardware
; can later colour-expand to the screen to draw text.
;
;-----------------------------------------------------------------------;
;
; Note: prclClip and prclExtra are null rectangle (yBottom=0) terminated
; arrays.
;
; Note: Assumes the text rectangle has a positive height and width. Will
; not work properly if this is not the case.
;
; Note: The opaquing rectangle is assumed to match the text bounding
; rectangle exactly; prclOpaque is used only to determine whether or
; not opaquing is required.
;
; Note: For maximum performance, we should not bother to draw fully-
; clipped characters to the temp buffer.
;
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc

        .list

;-----------------------------------------------------------------------;

        .data

;-----------------------------------------------------------------------;
; Tables used to branch into glyph-drawing optimizations.
;
; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; should be MOVed even if it's not aligned (intended for use in drawing the
; first glyph in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableNarrow   label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      mov_first_1_wide_rotated_need_last ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_1_wide_rotated_no_last   ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      mov_first_2_wide_rotated_need_last ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_2_wide_rotated_no_last   ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      mov_first_3_wide_rotated_need_last ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_3_wide_rotated_no_last   ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      mov_first_4_wide_rotated_need_last ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      mov_first_4_wide_rotated_no_last   ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where initial byte
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableNarrow    label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_first_1_wide_rotated_need_last  ;nonalign, 1 wide, need last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_1_wide_rotated_no_last    ;nonalign, 1 wide, no last
        dd      mov_first_1_wide_unrotated         ;aligned, 1 wide
        dd      or_first_2_wide_rotated_need_last  ;nonalign, 2 wide, need last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_2_wide_rotated_no_last    ;nonalign, 2 wide, no last
        dd      mov_first_2_wide_unrotated         ;aligned, 2 wide
        dd      or_first_3_wide_rotated_need_last  ;nonalign, 3 wide, need last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_3_wide_rotated_no_last    ;nonalign, 3 wide, no last
        dd      mov_first_3_wide_unrotated         ;aligned, 3 wide
        dd      or_first_4_wide_rotated_need_last  ;nonalign, 4 wide, need last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide
        dd      or_first_4_wide_rotated_no_last    ;nonalign, 4 wide, no last
        dd      mov_first_4_wide_unrotated         ;aligned, 4 wide

; Handles narrow (1-4 bytes wide) glyph drawing, for case where all bytes
; should be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bits 3-2: dest width
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableNarrow        label   dword
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      exit_fast_text                     ;0 wide
        dd      or_all_1_wide_rotated_need_last    ;nonalign, 1 wide, need last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_1_wide_rotated_no_last      ;nonalign, 1 wide, no last
        dd      or_all_1_wide_unrotated            ;aligned, 1 wide
        dd      or_all_2_wide_rotated_need_last    ;nonalign, 2 wide, need last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_2_wide_rotated_no_last      ;nonalign, 2 wide, no last
        dd      or_all_2_wide_unrotated            ;aligned, 2 wide
        dd      or_all_3_wide_rotated_need_last    ;nonalign, 3 wide, need last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_3_wide_rotated_no_last      ;nonalign, 3 wide, no last
        dd      or_all_3_wide_unrotated            ;aligned, 3 wide
        dd      or_all_4_wide_rotated_need_last    ;nonalign, 4 wide, need last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide
        dd      or_all_4_wide_rotated_no_last      ;nonalign, 4 wide, no last
        dd      or_all_4_wide_unrotated            ;aligned, 4 wide

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; MOVed even if it's not aligned (intended for use in drawing the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
MovInitialTableWide     label   dword
        dd      mov_first_N_wide_rotated_need_last      ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      mov_first_N_wide_rotated_no_last        ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where initial byte should be
; ORed if it's not aligned (intended for use in drawing all but the first glyph
; in a string). Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrInitialTableWide      label   dword
        dd      or_first_N_wide_rotated_need_last       ;nonalign, need last
        dd      mov_first_N_wide_unrotated              ;aligned
        dd      or_first_N_wide_rotated_no_last         ;nonalign, no last
        dd      mov_first_N_wide_unrotated              ;aligned

; Handles arbitrarily wide glyph drawing, for case where all bytes should
; be ORed (intended for use in drawing potentially overlapping glyphs).
; Table format is:
;  Bit   1 : 1 if don't need last source byte, 0 if do need last source byte
;  Bit   0 : 1 if no rotation (aligned), 0 if rotation (non-aligned)
        align   4
OrAllTableWide  label   dword
        dd      or_all_N_wide_rotated_need_last ;nonalign, need last
        dd      or_all_N_wide_unrotated         ;aligned
        dd      or_all_N_wide_rotated_no_last   ;nonalign, no last
        dd      or_all_N_wide_unrotated         ;aligned

; Vectors to entry points for drawing various types of text. '*' means works as
; is but could be acclerated with a custom scanning loop.
        align   4
MasterTextTypeTable     label   dword       ;tops aligned  overlap  fixed pitch
        dd      draw_nf_ntb_o_to_temp_start ;      N          N          N *
        dd      draw_f_ntb_o_to_temp_start  ;      N          N          Y *
        dd      draw_nf_ntb_o_to_temp_start ;      N          Y          N
        dd      draw_f_ntb_o_to_temp_start  ;      N          Y          Y
        dd      draw_nf_tb_no_to_temp_start ;      Y          N          N
        dd      draw_f_tb_no_to_temp_start  ;      Y          N          Y
        dd      draw_nf_ntb_o_to_temp_start ;      Y          Y          N *
        dd      draw_f_ntb_o_to_temp_start  ;      Y          Y          Y *

;-----------------------------------------------------------------------;

                .code

_TEXT$01   SEGMENT DWORD USE32 PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;-----------------------------------------------------------------------;

cProc vFastText,40,<\
 uses esi edi ebx,\
 pGlyphPos:ptr,\
 ulGlyphCount:dword,\
 pTempBuffer:ptr,\
 ulBufDelta:dword,\
 ulCharInc:dword,\
 prclText:ptr,\
 prclOpaque:ptr,\
 fDrawFlags:dword,\
 prclClip:dword,\
 prclExtra:dword>

        local ulGlyDelta:dword  ;width per scan of source glyph, in bytes
        local ulWidthInBytes:dword ;width of glyph, in bytes
        local ulTmpWidthInBytes:dword ;working byte-width count
        local ulGlyphX:dword    ;for fixed-pitch text, maintains the current
                                ; glyph's left-edge X coordinate
        local pGlyphLoop:dword  ;pointer to glyph-processing loop
        local ulTempLeft:dword  ;X coordinate on screen of left edge of temp
                                ; buffer
        local ulTempTop:dword   ;Y coordinate on screen of top edge of temp
                                ; buffer
        local ulTmpSrcDelta:dword ;distance from end of one buffer text scan to
                                  ; start of next
        local ulTmpDstDelta:dword ;distance from end of one screen text scan to
                                  ; start of next
        local ulYOrigin:dword   ;Y origin of text in string (all glyphs are at
                                ; the same Y origin)
        local rclClippedBounds[16]:byte ;clipped destination rectangle;
                                        ; defined as "byte" due to assembler
                                        ; limitations

        local pTempBufferSaved:dword

;-----------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; Draws either a fixed or a non-fixed-pitch string to the temporary
; buffer. Assumes this is a horizontal string, so the origins of all glyphs
; are at the same Y coordinate. Draws leftmost glyph entirely with MOVs,
; even if it's not aligned, in order to ensure that the leftmost byte
; gets cleared when we're working with butted characters. For other
; non-aligned glyphs, leftmost byte is ORed, other bytes are MOVed.
;
; Input:
;       pGlyphPos = pointer to array of GLYPHPOS structures to draw
;       ulGlyphCount = # of glyphs to draw
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       ulCharInc = offset from one glyph to next (fixed-pitch only)
;       fDrawFlags = indicate the type of text to be drawn
;       Temp buffer zeroed if text doesn't cover every single pixel
;
; Fixed-pitch means equal spacing between glyph positions, not that all
; glyphs butt together or equal spacing between upper left corners.
;-----------------------------------------------------------------------;

        mov     ebx,prclText
        mov     eax,[ebx].yTop
        mov     ulTempTop,eax   ;Y screen coordinate of top edge of temp buf
        mov     eax,[ebx].xLeft
; !!!!!!        and     eax,not 7
        mov     ulTempLeft,eax  ;X screen coordinate of left edge of temp buf

        mov     eax,fDrawFlags

        jmp     MasterTextTypeTable[eax*4]

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer (we assume the text is
                                        ; right at the top of the text rect
                                        ; and hence the buffer)
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_f_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        jmp     short draw_to_temp_start_entry

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms aligned | no overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,[ebx].gp_x          ;dest X coordinate
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        mov     pGlyphLoop,offset draw_nf_tb_no_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
draw_to_temp_start_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte in temp buffer

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableNarrow[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     MovInitialTableWide[eax*4]
                                        ;branch to draw the first glyph; never
                                        ; need to OR first glyph, because
                                        ; there's nothing there yet

;-----------------------------------------------------------------------;
; Entry point for fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_f_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     ulGlyphX,edi            ;remember where this glyph started
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        jmp     short draw_to_temp_start_entry2

;-----------------------------------------------------------------------;
; Entry point for non-fixed-pitch | tops and bottoms not aligned | overlap.
; Sets up to draw first glyph.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_start::
        mov     ebx,pGlyphPos           ;point to the first glyph to draw
        mov     pGlyphLoop,offset draw_nf_ntb_o_to_temp_loop
                                        ;draw additional characters with this
                                        ; loop
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        sub     edi,ulTempLeft          ;adjust relative to the left of the
                                        ; temp buffer
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi
        shr     edi,3                   ;byte offset of first column of glyph
                                        ; offset of upper left of glyph in temp
                                        ; buffer
draw_to_temp_start_entry2::
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
        mov     ulYOrigin,eax           ;remember the Y origin of all glyphs
                                        ; (necessary because glyph positions
                                        ; after first aren't set for fixed-
                                        ; pitch strings)
        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes per scan

        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the first glyph; OR all
                                        ; glyphs, because text may overlap

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one
        mov     pGlyphPos,ebx           ; we're going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def

        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        jmp     short draw_to_temp_loop_entry

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms aligned | no overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_tb_no_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)
        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer

draw_to_temp_loop_entry::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer
        add     edi,pTempBuffer         ;initial dest byte

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableNarrow[eax*4] ;branch to draw the first glyph;
                                            ; need to OR the 1st byte if
                                            ; non-aligned to avoid overwriting
                                            ; what's already there
@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrInitialTableWide[eax*4] ;branch to draw the next glyph;
                                          ; need to OR the 1st byte if
                                          ; non-aligned to avoid overwriting
                                          ; what's already there

;-----------------------------------------------------------------------;
; Loop to draw all fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_f_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,ulGlyphX            ;last glyph's dest X start in temp buf
        add     edi,ulCharInc           ;this glyph's dest X start in temp buf
        mov     ulGlyphX,edi            ;remember for next glyph
        mov     esi,[esi].gdf_pgb       ;point to glyph bits

        mov     eax,ulYOrigin           ;dest Y coordinate
        jmp     short draw_to_temp_loop_entry2

;-----------------------------------------------------------------------;
; Loop to draw all non-fixed-pitch | tops and bottoms not aligned | overlap
; glyphs after first.
;-----------------------------------------------------------------------;
draw_nf_ntb_o_to_temp_loop::
        dec     ulGlyphCount            ;any more glyphs to draw?
        jz      glyphs_are_done         ;no, done
        mov     ebx,pGlyphPos
        add     ebx,size GLYPHPOS       ;point to the next glyph (the one we're
        mov     pGlyphPos,ebx           ; going to draw this time)

        mov     esi,[ebx].gp_pgdf       ;point to glyph def
        mov     edi,[ebx].gp_x          ;dest X coordinate
        mov     esi,[esi].gdf_pgb       ;point to glyph bits
        sub     edi,ulTempLeft          ;adjust relative to the left edge of
                                        ; the temp buffer
        mov     eax,[ebx].gp_y          ;dest origin Y coordinate
        sub     eax,ulTempTop           ;coord of glyph origin in temp buffer
draw_to_temp_loop_entry2::
        add     edi,[esi].gb_x          ;adjust to position of upper left glyph
                                        ; corner in dest
        mov     ecx,edi                 ;pixel X coordinate in temp buffer
        shr     edi,3                   ;byte offset of first column = dest
                                        ; offset of upper left of glyph in temp
                                        ; buffer

        add     eax,[esi].gb_y          ;adjust to position of upper left glyph
                                        ; corner in dest
        mul     ulBufDelta              ;offset in buffer of top glyph scan
        add     eax,pTempBuffer         ;initial dest byte
        add     edi,eax

        and     ecx,111b                ;bit alignment of upper left in temp

                                        ;calculate scan-to-scan glyph width
        mov     ebx,[esi].gb_cx         ;glyph width in pixels

        lea     eax,[ebx+ecx+7]
        shr     eax,3                   ;# of dest bytes to copy to per scan

        add     ebx,7
        shr     ebx,3                   ;# of source bytes to copy from per
                                        ; scan
        mov     edx,ulBufDelta          ;width of destination buffer in bytes

        cmp     eax,4                   ;do we have special case code for this
                                        ; dest width?
        ja      short @F                ;no, handle as general case
                                        ;yes, handle as special case
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)
        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableNarrow[eax*4] ;branch to draw the next glyph

@@:                                     ;too wide to special case
        mov     ulWidthInBytes,eax      ;# of bytes across dest
        cmp     ebx,eax                 ;carry if more dest than source bytes
                                        ; (last source byte not needed)
        mov     eax,0
        rcl     eax,1                   ;factor last source byte status in
        cmp     cl,1                    ;carry if aligned
        rcl     eax,1                   ;factor in alignment (aligned or not)

        mov     ebx,[esi].gb_cx         ;glyph width in pixels
        add     ebx,7
        shr     ebx,3                   ;glyph width in bytes
        mov     ulGlyDelta,ebx

        mov     ebx,[esi].gb_cy         ;# of scans in glyph
        add     esi,gb_aj               ;point to the first glyph byte

        jmp     OrAllTableWide[eax*4]   ;branch to draw the next glyph

;-----------------------------------------------------------------------;
; Routines to draw all scans of a single glyph into the temp buffer,
; optimized for the following cases:
;
;       1 to 4 byte-wide destination rectangles for each of:
;               No rotation needed
;               Rotation needed, same # of source as dest bytes needed
;               Rotation needed, one less source than dest bytes needed
;
; Additionally, the three cases are handled for 5 and wider cases by a
; general routine for each case.
;
; If rotation is needed, there are three sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) The leftmost byte is ORed into the existing byte. Succeeding bytes are
;    MOVed. This is generally used after the leftmost glyph, because this may
;    not be the first data written to that byte.
; 3) All bytes are ORed. This is for drawing when characters might overlap.
;
; If rotation is not needed, there are two sorts of routines:
;
; 1) The leftmost byte is MOVed, to initialize the byte. Succeeding bytes are
;    MOVed. This is generally used for the leftmost glyph of a string.
; 2) All bytes are ORed. This is for drawing when characters might overlap.
;
; On entry:
;       EBX = # of scans to copy
;       CL  = right rotation
;       EDX = ulBufDelta = width per scan of destination buffer, in bytes
;       ESI = pointer to first glyph byte
;       EDI = pointer to first dest buffer byte
;       DF  = cleared
;       ulGlyDelta = width per scan of source glyph, in bytes (wide case only)
;       ulWidthInBytes = width of glyph, in bytes (required only for 5 and
;               wider cases)
;
; On exit:
;       Any or all of EAX, EBX, ECX, EDX, ESI, and EDI may be trashed.

;-----------------------------------------------------------------------;
; OR first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
or_all_1_wide_rotated_need_last::
or_all_1_wide_rotated_no_last::
or_first_1_wide_rotated_need_last::
or_first_1_wide_rotated_no_last::
or_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        or      [edi],ch
        add     edi,edx
        dec     ebx
        jnz     or_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, rotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_rotated_need_last::
mov_first_1_wide_rotated_no_last::
mov_first_1_wide_rotated_loop::
        mov     ch,[esi]
        inc     esi
        shr     ch,cl
        mov     [edi],ch
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_1_wide_unrotated::
mov_first_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     mov_first_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 1 byte wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_1_wide_unrotated::
or_all_1_wide_unrotated_loop::
        mov     al,[esi]
        inc     esi
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     or_all_1_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_need_last::
or_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],al
        mov     [edi+1],ah
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_need_last::
or_all_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_need_last::
mov_first_2_wide_rotated_need_loop::
        mov     ax,[esi]
        add     esi,2
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_need_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_2_wide_rotated_no_last::
or_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     ah,[esi]
        inc     esi
        shr     eax,cl
        or      [edi],ah
        mov     [edi+1],al
        add     edi,edx
        dec     ebx
        jnz     or_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_2_wide_rotated_no_last::
or_all_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_2_wide_rotated_no_last::
mov_first_2_wide_rotated_loop::
        sub     eax,eax
        mov     al,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_rotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_2_wide_unrotated::
mov_first_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        mov     [edi],ax
        add     edi,edx
        dec     ebx
        jnz     mov_first_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 2 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_2_wide_unrotated::
or_all_2_wide_unrotated_loop::
        mov     ax,[esi]
        add     esi,2
        or      [edi],ax
        add     edi,edx
        dec     ebx
        jnz     or_all_2_wide_unrotated_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        or      [edi],al
        mov     ax,[esi]
        ror     ax,cl
        or      [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        or      [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_need_last::
@@:
        mov     al,[esi]
        shr     al,cl
        mov     [edi],al
        mov     ax,[esi]
        ror     ax,cl
        mov     [edi+1],ah
        mov     ax,[esi+1]
        add     esi,3
        ror     ax,cl
        mov     [edi+2],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        xchg    ah,al
        or      [edi+1],ax
        shr     eax,16
        or      [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_3_wide_rotated_no_last::
        neg     cl
        and     cl,111b         ;convert from right shift to left shift
@@:
        sub     eax,eax
        mov     ax,[esi]
        add     esi,2
        xchg    ah,al
        shl     eax,cl
        mov     [edi+1],ah
        mov     [edi+2],al
        shr     eax,16
        mov     [edi],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_3_wide_unrotated::
@@:
        mov     ax,[esi]
        mov     [edi],ax
        mov     al,[esi+2]
        add     esi,3
        mov     [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 3 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_3_wide_unrotated::
@@:
        mov     ax,[esi]
        or      [edi],ax
        mov     al,[esi+2]
        add     esi,3
        or      [edi+2],al
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    al,ah
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_need_last::
@@:
        mov     eax,[esi]
        add     esi,4
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        mov     [edi+2],ax
        shr     eax,16
        mov     [edi+1],al
        or      [edi],ah
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_4_wide_rotated_no_last::
@@:
        mov     ax,[esi]
        xchg    ah,al
        shl     eax,16
        mov     ah,[esi+2]
        add     esi,3
        shr     eax,cl
        xchg    ah,al
        ror     eax,16
        xchg    ah,al
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        mov     [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, 4 bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_4_wide_unrotated::
@@:
        mov     eax,[esi]
        add     esi,4
        or      [edi],eax
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, n bytes wide dest, rotated, need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_need_last::
        mov     eax,ulWidthInBytes
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        mov     eax,ulWidthInBytes
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first byte outside the loop
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwrnl_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B
        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwrnl_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
ofNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     ofNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
or_all_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
oaNwr_scan_loop:
        mov     al,[esi]        ;do the initial, ORed byte separately
        shr     al,cl
        or      [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        or      [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        or      [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     oaNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, rotated, don't need final source byte.
;-----------------------------------------------------------------------;
mov_first_N_wide_rotated_no_last::
        mov     eax,ulWidthInBytes
        dec     eax             ;one less because we don't advance after the
                                ; last byte
        mov     edx,ulBufDelta
        sub     edx,eax
        mov     ulTmpDstDelta,edx
        dec     eax             ;source doesn't advance after first byte, and
                                ; we do the first & last bytes outside the
                                ; loop; already subtracted 1 above
        mov     edx,ulGlyDelta
        sub     edx,eax
        mov     ulTmpSrcDelta,edx
        mov     ulTmpWidthInBytes,eax
mfNwr_scan_loop:
        mov     al,[esi]        ;do the initial byte separately
        shr     al,cl
        mov     [edi],al
        inc     edi
        mov     edx,ulTmpWidthInBytes
@@:
        mov     ax,[esi]
        inc     esi
        ror     ax,cl
        mov     [edi],ah
        inc     edi
        dec     edx
        jnz     @B

        mov     ah,[esi]        ;do the final byte separately
        sub     al,al
        shr     eax,cl
        mov     [edi],al

        add     esi,ulTmpSrcDelta
        add     edi,ulTmpDstDelta
        dec     ebx
        jnz     mfNwr_scan_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; MOV first byte, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
mov_first_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

odd_width::
        shr     eax,1           ;width in dwords
        jc      short three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;because we won't advance after last byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cl,[esi]
        inc     esi
        mov     [edi],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

two_odd_bytes::
        add     edx,2           ;because we won't advance after last word
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        add     esi,2
        mov     [edi],cx
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

three_odd_bytes::
        add     edx,3           ;because we won't advance after last word/byte
@@:
        mov     ecx,eax
        rep     movsd           ;copy as many dwords as possible
        mov     cx,[esi]
        mov     [edi],cx
        mov     cl,[esi+2]
        add     esi,3
        mov     [edi+2],cl
        add     edi,edx
        dec     ebx
        jnz     @B
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; OR all bytes, N bytes wide dest, unrotated.
;-----------------------------------------------------------------------;
or_all_N_wide_unrotated::
        mov     edx,ulBufDelta
        mov     eax,ulWidthInBytes
        sub     edx,eax
        shr     eax,1           ;width in words
        jc      short or_odd_width ;there's at least one odd byte
        shr     eax,1           ;width in dwords
        jc      short or_two_odd_bytes ;there's an odd word
                                ;copy width is a dword multiple
or_no_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_no_odd_bytes_loop
        jmp     pGlyphLoop

or_odd_width::
        shr     eax,1           ;width in dwords
        jc      short or_three_odd_bytes ;there's an odd word and an odd byte
                                ;there's just an odd byte
        inc     edx             ;skip over last byte too
or_one_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cl,[esi]
        or      [edi],cl
        inc     esi
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_one_odd_bytes_loop
        jmp     pGlyphLoop

or_two_odd_bytes::
        add     edx,2           ;skip over last 2 bytes too
or_two_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        add     esi,2
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_two_odd_bytes_loop
        jmp     pGlyphLoop

or_three_odd_bytes::
        add     edx,3           ;skip over last 3 bytes too
or_three_odd_bytes_loop::
        push    ebx             ;preserve scan count
        mov     ebx,eax
@@:
        mov     ecx,[esi]
        add     esi,4
        or      [edi],ecx
        add     edi,4           ;copy as many dwords as possible
        dec     ebx
        jnz     @B
        mov     cx,[esi]
        or      [edi],cx
        mov     cl,[esi+2]
        or      [edi+2],cl
        add     esi,3
        add     edi,edx
        pop     ebx             ;restore scan count
        dec     ebx
        jnz     or_three_odd_bytes_loop
        jmp     pGlyphLoop

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer.
; Now, draw the extra rectangles to the temp buffer.
;
; Input:
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
glyphs_are_done::
        mov     esi,prclExtra
        test    esi,esi                         ;is prclExtra NULL?
        jz      extra_rects_are_done            ;yes

        ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ; !!! Should handle prclExtra here and set GCAPS_HORIZSTRIKE !!!
        ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

;-----------------------------------------------------------------------;
; At this point, the text is drawn to the temp buffer, and any extra
; rectangles (underline, strikeout) are drawn to the temp buffer.
; Now, draw the temp buffer to the screen.
;
; Input:
;       prclText = pointer to text bounding rectangle
;       prclOpaque = pointer to opaquing rectangle, if there is one
;       ulTempLeft = X coordinate on dest of left edge of temp buffer pointed
;               to by pTempBuffer
;       pTempBuffer = pointer to first byte (upper left corner) of
;               temp buffer into which we're drawing. This should be
;               dword-aligned with the destination
;       ulBufDelta = destination scan-to-scan offset
;       Text drawn to temp buffer
;
;-----------------------------------------------------------------------;
extra_rects_are_done::

;-----------------------------------------------------------------------;
; Clip to the clip rectangle, if necessary.
;-----------------------------------------------------------------------;

        mov     esi,prclText
        mov     edi,prclClip
        test    edi,edi                 ;is there clipping?
        jz      exit_fast_text          ;no

        mov     ebx,pTempBuffer
        mov     pTempBufferSaved,ebx
        jmp     short do_opaque_clip

;-----------------------------------------------------------------------;
; Handle rectangle clipping.
;-----------------------------------------------------------------------;

get_next_clip_rect::
        mov     esi,prclText
        mov     edi,prclClip            ;make sure edi has prclClip
        test    edi,edi                 ;was this null?
        jz      exit_fast_text          ;yep
        add     edi,size RECTL          ;no, next rect
        mov     prclClip,edi            ;don't forget the increment

        mov     ebx,pTempBufferSaved
        mov     pTempBuffer,ebx

do_opaque_clip::
        mov     ebx,[edi].yBottom
        test    ebx,ebx                 ;is it a null rectangle?
        jz      exit_fast_text          ;yes

        mov     ebx,[esi].yBottom
        cmp     [edi].yBottom,ebx ;is the bottom edge of the text box clipped?
        jg      short @F          ;no
        mov     ebx,[edi].yBottom ;yes
@@:
        mov     dword ptr rclClippedBounds.yBottom,ebx ;set the (possibly
                                                       ; clipped) bottom edge
        mov     eax,[esi].yTop
        cmp     [edi].yTop,eax  ;is the top edge of the text box clipped?
        jle     short @F        ;no
                                ;yes
        sub     eax,[edi].yTop
        neg     eax             ;# of scans we just clipped off
        mul     ulBufDelta      ;# of bytes by which to advance through source
        add     pTempBuffer,eax ;advance in source to account for Y clipping
        mov     eax,[edi].yTop  ;new top edge
@@:
        mov     dword ptr rclClippedBounds.yTop,eax ;set the (possibly clipped)
                                                    ; top edge
        cmp     eax,ebx         ;is there a gap between clipped top & bottom?
        jnl     get_next_clip_rect ;no, fully clipped

        mov     edx,[esi].xRight
        cmp     [edi].xRight,edx ;is the right edge of the text box clipped?
        jg      short @F         ;no
        mov     edx,[edi].xRight ;yes
@@:
        mov     dword ptr rclClippedBounds.xRight,edx ;set the (possibly
                                                      ; clipped) right edge
        mov     eax,[esi].xLeft
        cmp     [edi].xLeft,eax ;is the left edge of the text box clipped?
        jle     short @F        ;no
                                ;yes
        mov     ebx,[edi].xLeft ;EBX = new left edge
        and     eax,not 0111b   ;floor the old left edge in its byte
        sub     ebx,eax
        shr     ebx,3           ;# of bytes to advance in source
        add     pTempBuffer,ebx ;advance in source to account for X clipping
        mov     eax,[edi].xLeft ;new left edge
@@:
        mov     dword ptr rclClippedBounds.xLeft,eax ;set the (possibly
                                                     ; clipped) left edge
        cmp     eax,edx         ;is there a gap between clipped left & right?
        jnl     get_next_clip_rect ;no, fully clipped

        lea     esi,rclClippedBounds ;this is now the destination rect

;-----------------------------------------------------------------------;
; ESI->destination text rectangle at this point
;-----------------------------------------------------------------------;
exit_fast_text::

        cRet    vFastText

endProc vFastText

;-----------------------------------------------------------------------;
; VOID vClearMemDword(ULONG * pulBuffer, ULONG ulDwordCount);
;
; Clears ulCount dwords starting at pjBuffer.
;-----------------------------------------------------------------------;

pulBuffer    equ [esp+8]
ulDwordCount equ [esp+12]

cProc vClearMemDword,8,<>

        push    edi
        mov     edi,pulBuffer
        mov     ecx,ulDwordCount
        sub     eax,eax
        rep     stosd
        pop     edi

        cRet  vClearMemDword

endProc vClearMemDword

public draw_f_tb_no_to_temp_start
public draw_nf_tb_no_to_temp_start
public draw_to_temp_start_entry
public draw_f_ntb_o_to_temp_start
public draw_nf_ntb_o_to_temp_start
public draw_to_temp_start_entry2
public draw_f_tb_no_to_temp_loop
public draw_nf_tb_no_to_temp_loop
public draw_to_temp_loop_entry
public draw_f_ntb_o_to_temp_loop
public draw_nf_ntb_o_to_temp_loop
public draw_to_temp_loop_entry2
public or_all_1_wide_rotated_need_last
public or_all_1_wide_rotated_no_last
public or_first_1_wide_rotated_need_last
public or_first_1_wide_rotated_no_last
public or_first_1_wide_rotated_loop
public mov_first_1_wide_rotated_need_last
public mov_first_1_wide_rotated_no_last
public mov_first_1_wide_rotated_loop
public mov_first_1_wide_unrotated
public mov_first_1_wide_unrotated_loop
public or_all_1_wide_unrotated
public or_all_1_wide_unrotated_loop
public or_first_2_wide_rotated_need_last
public or_first_2_wide_rotated_need_loop
public or_all_2_wide_rotated_need_last
public or_all_2_wide_rotated_need_loop
public mov_first_2_wide_rotated_need_last
public mov_first_2_wide_rotated_need_loop
public or_first_2_wide_rotated_no_last
public or_first_2_wide_rotated_loop
public or_all_2_wide_rotated_no_last
public or_all_2_wide_rotated_loop
public mov_first_2_wide_rotated_no_last
public mov_first_2_wide_rotated_loop
public mov_first_2_wide_unrotated
public mov_first_2_wide_unrotated_loop
public or_all_2_wide_unrotated
public or_all_2_wide_unrotated_loop
public or_first_3_wide_rotated_need_last
public or_all_3_wide_rotated_need_last
public mov_first_3_wide_rotated_need_last
public or_first_3_wide_rotated_no_last
public or_all_3_wide_rotated_no_last
public mov_first_3_wide_rotated_no_last
public mov_first_3_wide_unrotated
public or_all_3_wide_unrotated
public or_first_4_wide_rotated_need_last
public or_all_4_wide_rotated_need_last
public mov_first_4_wide_rotated_need_last
public or_first_4_wide_rotated_no_last
public or_all_4_wide_rotated_no_last
public mov_first_4_wide_rotated_no_last
public mov_first_4_wide_unrotated
public or_all_4_wide_unrotated
public or_first_N_wide_rotated_need_last
public or_all_N_wide_rotated_need_last
public mov_first_N_wide_rotated_need_last
public or_first_N_wide_rotated_no_last
public or_all_N_wide_rotated_no_last
public mov_first_N_wide_rotated_no_last
public mov_first_N_wide_unrotated
public odd_width
public two_odd_bytes
public three_odd_bytes
public or_all_N_wide_unrotated
public or_no_odd_bytes_loop
public or_odd_width
public or_one_odd_bytes_loop
public or_two_odd_bytes
public or_two_odd_bytes_loop
public or_three_odd_bytes
public or_three_odd_bytes_loop
public glyphs_are_done
public extra_rects_are_done
public get_next_clip_rect
public do_opaque_clip

_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\i386\fastline.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: fastline.asm
;
; This module draws solid lines using the line hardware of the S3.
; It handles entirely unclipped lines, or lines clipped to a single
; rectangle by using the S3's hardware clipping.
;
; All lines that have integer end-points are drawn directly using the
; line hardware, and any lines having fractional end-points and are
; less than 256 pels long are also drawn directly by the line hardware.
; (Fractional end-point lines require 4 more bits of precision from the
; DDA hardware than do integer end-point lines, and the S3 has but 13
; bits to use.  Lines longer than 255 pels are punted to the general
; purpose strip routines, which won't overflow the hardware).
;
; There are a number of ways unclipped lines can be sped up on the S3:
;
; 1) Optimize NT's GDI.  This isn't an option for everybody.
;
; 2) Use memory-mapped I/O.
;
; 3) If you can't use memory-mapped I/O, you can at least minimize
;    outs and ins because they are so painfully expensive.  One
;    way to do this is to amortize the cost of the in used for checking
;    the FIFO: do one in to make sure a large number of entries on
;    the FIFO are free (perhaps 6), then do the next 6 outs without
;    having to check the FIFO.
;
;    This will be a win on figures not requiring many outs (such as when
;    radial lines are drawn as with a rectangle), assuming the hardware
;    isn't always being overdriven.
;
; 4) In conjunction with 3) above, since short integer lines occur so
;    frequently with CAD programs, it would be beneficial to use short-
;    stroke vectors to do those lines, as they could reduce the number
;    of outs required.  Perhaps any line 10 pels or shorter could be
;    output by using an array lookup to determine the short stroke vectors
;    needed to represent that line.
;
; 5) Numerous other things I haven't thought of.
;
; Other improvements that should be done to make lines faster in general:
;
; 1) Simple clipping should be improved.  Currently, we simply set the
;    clip rectangle and let the hardware do everything.  We should at least
;    perform a trivial clip test to see if there's no chance the line
;    intersects the clip rectangle.
;
;    Also, for single lines it's expensive to do the 4 outs required to
;    set the S3's clip rectangle, draw the line, then do 4 outs to reset
;    the clip rectangle again.  In those cases, it would be faster to do the
;    clipping entirely in software.
;
; 2) This code can be enhanced to also handle styled lines, and to do
;    complex clipping more efficiently than the strips routines.
;
; 3) It is possible to derive the mathematical algorithm for drawing any
;    GIQ line in NT's 32 bit space using the limited bit precision of the
;    S3's hardware.  What this means is that absolutely any GIQ line can
;    be drawn precisely with at most two drawing commands to the line
;    hardware (and so the strips line drawing routine could be eliminated
;    entirely).  Just be careful of your math...
;
; 4) Numerous other things I haven't thought of.
;
; Copyright (c) 1992-1994 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\hw.inc
        include i386\lines.inc
        .list

; Line coordinates are given in 28.4 fixed point format:

        F               equ 16
        FLOG2           equ 4

; The S3's hardware can have 13 bits of significance for the error and
; step terms:

        NUM_DDA_BITS    equ 13

; GIQ lines have to dedicate 4 bits to the fractional term, so the largest
; delta we can handle for GIQ lines is calculated as follows (scaled by F
; so we can do the test in GIQ coordinates), and remembering that one bit
; has to be used as a sign bit:

        MAX_GIQ_DELTA   equ (((1 shl (NUM_DDA_BITS - 5)) - 1) * F)

; The following values must match those in winddi.h!

        PD_BEGINSUBPATH equ 00000001h
        PD_ENDSUBPATH   equ 00000002h
        PD_RESETSTYLE   equ 00000004h
        PD_CLOSEFIGURE  equ 00000008h
        PD_BEZIERS      equ 00000010h

        PATHDATA struc

        pd_flags        dd  ?
        pd_count        dd  ?
        pd_pptfx        dd  ?

        PATHDATA ends

;-------------------------------------------------------------------------;
; I felt a compelling need to use 'ebp' as a 7th general register, and we
; have no nifty macros for dereferencing frame variables off 'esp'.  So
; with this structure I am rolling my own stack frame:

STATE_MEM_SIZE          equ 4           ;4 dwords
PROC_MEM_SIZE           equ 9           ;9 dwords

STACK_FRAME struc

; State variables (don't add/delete fields without modifying STATE_MEM_SIZE!)

sf_ulOurEbp             dd ?
sf_ulOriginalEbx        dd ?
sf_ulOriginalEdi        dd ?
sf_ulOriginalEsi        dd ?

; Frame variables (feel free to add/delete fields):

sf_y0                   dd ?            ;GIQ variables
sf_y1                   dd ?
sf_x1                   dd ?
sf_ptlOrg               db (size POINTL) dup (?)
                                        ;our  origin for normalizing the line
sf_ptfxLast             db (size POINTL) dup (?)
                                        ;the most recent point
sf_ptfxStartFigure      db (size POINTL) dup (?)
                                        ;the figure's 1st point
sf_bMore                dd ?            ;more path records to get?
sf_pptfxEnd             dd ?            ;points to last point in record
sf_pptfx                dd ?            ;points to current point
sf_pd                   db (size PATHDATA) dup (?)
                                        ;pathdata structure
sf_ptfxStart            db (size POINTL) dup (?)
                                        ;temporary spot for saving start point
sf_ptfxEnd              db (size POINTL) dup (?)
                                        ;temporary spot for saving end point
sf_ulCmd                dd ?            ;S3 draw command
sf_cPels                dd ?            ;length of line in pels
sf_bSetCP               dd ?            ;1 if first line in figure, 0 otherwise
sf_ulLastLength         dd ?            ;last value set as LINE_MAX
sf_ulErrorTerm          dd ?            ;error term for line

sf_xOffset              dd ?            ;stack copy of surface offset
sf_yOffset              dd ?
sf_ioGp_stat_cmd        dd ?            ;local copy of gp_stat address
sf_pjMmBase             dd ?            ;local copy of the memory-mapped I/O
                                        ; base address

; Procedure variables (don't add/delete fields without modifying
; PROC_MEM_SIZE!)

sf_ulOriginalEbp        dd ?
sf_ulOriginalReturn     dd ?
sf_ppdev                dd ?
sf_ppo                  dd ?
sf_prclClip             dd ?
sf_apfn                 dd ?
sf_flags                dd ?
sf_color                dd ?
sf_ulHwMix              dd ?

STACK_FRAME ends

        .code

        EXTRNP  PATHOBJ_bEnum,8
        EXTRNP  bLines,36

        ROUND_X_DOWN            equ     01h
        ROUND_Y_DOWN            equ     02h
        ROUND_SLOPE_ONE         equ     04h
        ROUND_X_AND_Y_DOWN      equ     (ROUND_X_DOWN + ROUND_Y_DOWN)
        ROUND_X_DOWN_SLOPE_ONE  equ     (ROUND_X_DOWN + ROUND_SLOPE_ONE)
        ROUND_Y_DOWN_SLOPE_ONE  equ     (ROUND_Y_DOWN + ROUND_SLOPE_ONE)

;--------------------------------Macro----------------------------------;
; GIQ flags
;
; This macros computes the start pixel, the number of pixels to
; be lit, and the initial error term given a GIQ line.  The line must
; have already been normalized such that dM >= dN, dN >= 0.
;
; Input:   ebx - M0
;          ecx - N0
;          esi - dM
;          edi - dN
; Trashes:
;          eax, edx
;          [esp].sf_ptlOrg.ptl_x, [esp].sf_ptlOrg.ptl_y
; Output:
;          [esp].sf_x1  - x-coordinate of last pixel (exclusive)
;          ebx - x-coordinate of first pixel
;          ecx - error term
;          esi - dM
;          edi - dN
;          ebp - y-coordinate of first pixel
;-----------------------------------------------------------------------;

GIQ     macro   flags
        local   compute_x1, compute_error_term

; We normalize our coordinate system so that if the start point is
; (M0/F, N0/F), the origin is at (floor(M0/F), (N0/F)):

        mov     eax,ebx
        mov     ebp,ecx
        sar     eax,FLOG2
        sar     ebp,FLOG2
        mov     [esp].sf_ptlOrg.ptl_x,eax
                                        ;ptlOrg.x = floor(M0 / F)
        mov     [esp].sf_ptlOrg.ptl_y,ebp
                                        ;ptlOrg.y = floor(N0 / F)

; Calculate the correct [esp].sf_x1:

        lea     ebp,[ecx + edi]         ;ebp = N1
        and     ebp,F - 1

    if (flags AND ROUND_X_DOWN)

    if (flags AND ROUND_SLOPE_ONE)
        cmp     ebp,8
        sbb     ebp,-1
    endif

        cmp     ebp,1
        sbb     ebp,8                   ;N1 -= 8
    else
        sub     ebp,8                   ;N1 -= 8
    endif
        sbb     eax,eax
        xor     ebp,eax
        sub     ebp,eax                 ;N1 = ABS(N1)

        lea     edx,[ebx + esi]
        mov     eax,edx
        sar     edx,FLOG2
        and     eax,F - 1
        jz      short @f                ;special case for M1 == 0
        cmp     eax,ebp                 ;cmp M1, N1
        sbb     edx,-1                  ;edx is now one pixel past the actual
@@:                                     ; end coordinate (note that it hasn't
                                        ; been affected by the origin shift)

compute_error_term:

; ebx = M0
; ecx = N0
; edx = x1
; esi = dM
; edi = dN

        and     ecx,F - 1
        mov     [esp].sf_x1,edx         ;save x1

; Calculate our error term for x = 0.
;
; NOTE: Since this routine is used only for lines that are unclipped, we
;       are guaranteed by our screen size that the values will be far less
;       than 32 bits in significance, and so we don't worry about overflow.
;       If this is used for clipped lines, these multiplies will have to
;       be converted to give 64 bit results, because we can have 36 bits of
;       significance!


        lea     ebp,[ecx + 8]           ;ebp = N0 + 8
        mov     eax,esi
        imul    eax,ebp                 ;eax = dM * (N0 + 8)
        mov     ebp,edi

; We have to special case when M0 is 0 -- we know x0 will be zero.
; So we jump ahead a bit to a place where 'ebx' is assumed to contain
; x0 -- and it just so happens 'ebx' is zero in this case:

        and     ebx,F - 1
        jz      short @f
        imul    ebp,ebx                 ;ebp = dN * M0
        sub     eax,ebp

; Calculate the x-coordinate of the first pixel:

    if (flags AND ROUND_X_DOWN)

    if (flags AND ROUND_SLOPE_ONE)
        cmp     ecx,8
        sbb     ecx,-1
    endif

        cmp     ecx,1
        sbb     ecx,8                   ;N0 -= 8
    else
        sub     ecx,8                   ;N0 -= 8
    endif
        sbb     ebp,ebp
        xor     ecx,ebp
        sub     ecx,ebp                 ;N0 = ABS(N0)
        cmp     ebx,ecx
        sbb     ebx,ebx
        not     ebx                     ;ebx = -x0

; Now adjust the error term accordingly:

@@:
    if (flags AND ROUND_Y_DOWN)
        dec     eax
    endif
        sar     eax,FLOG2               ;eax = floor((N0 + 8) dM - M0 dN] / 16)

        mov     ecx,[esp].sf_ptlOrg.ptl_x
        mov     ebp,[esp].sf_ptlOrg.ptl_y

        sub     ecx,ebx                 ;ecx = ptlOrg.ptl_x + x0

        and     ebx,edi
        add     ebx,eax
        sub     ebx,esi                 ;ebx = dN * x0 + initial error - dM
        jl      short @f                ;if the error term >= 0, we have to
        sub     ebx,esi                 ; add 1 to the y position and subtract
        inc     ebp                     ; dM off again
@@:
        xchg    ebx,ecx

endm

;--------------------------------Macro----------------------------------;
; GIQR flags
;
; Same as above, except it handles flips about the line x = y.
;
; Input:   ebx - M0
;          ecx - N0
;          esi - dM
;          edi - dN
; Trashes:
;          eax, edx
;          [esp].sf_ptlOrg.ptl_x, [esp].sf_ptlOrg.ptl_y
; Output:
;          [esp].sf_y1  - y-coordinate of last pixel (exclusive)
;          ebx - x-coordinate of first pixel
;          ecx - error term
;          esi - dM
;          edi - dN
;          ebp - y-coordinate of first pixel
;-----------------------------------------------------------------------;

GIQR    macro   flags

; We normalize our coordinate system so that if the start point is
; (M0/F, N0/F), the origin is at (floor(M0/F), (N0/F)):

        mov     eax,ebx
        mov     ebp,ecx
        sar     eax,FLOG2
        sar     ebp,FLOG2
        mov     [esp].sf_ptlOrg.ptl_x,eax
                                        ;ptlOrg.x = floor(M0 / F)
        mov     [esp].sf_ptlOrg.ptl_y,ebp
                                        ;ptlOrg.y = floor(N0 / F)

; Calculate the correct [esp].sf_y1:

        lea     ebp,[ebx + esi]         ;ebp = M1
        and     ebp,F - 1

    if (flags AND ROUND_Y_DOWN)
        cmp     ebp,1
        sbb     ebp,8                   ;M1 -= 8
    else
        sub     ebp,8                   ;M1 -= 8
    endif
        sbb     eax,eax
        xor     ebp,eax
        sub     ebp,eax                 ;M1 = ABS(M1)

        lea     edx,[ecx + edi]
        mov     eax,edx
        sar     edx,FLOG2
        and     eax,F - 1
        jz      short @f                ;special case for N1 == 0
        cmp     eax,ebp                 ;cmp N1, M1
        sbb     edx,-1                  ;edx is now one pixel past the actual
@@:                                     ; end coordinate (note that it hasn't
                                        ; been affected by the origin shift)
        and     ebx,F - 1
        mov     [esp].sf_y1,edx

; Calculate our error term for y = 0.
;
; NOTE: Since this routine is used only for lines that are unclipped, we
;       are guaranteed by our screen size that the values will be far less
;       than 32 bits in significance, and so we don't worry about overflow.
;       If this is used for clipped lines, these multiplies will have to
;       be converted to give 64 bit results, because we can have 36 bits of
;       significance!

        lea     ebp,[ebx + 8]           ;ebp = M0 + 8
        mov     eax,edi
        imul    eax,ebp                 ;eax = dN * (M0 + 8)
        mov     ebp,esi

; We have to special case when N0 is 0 -- we know y0 will be zero.
; So we jump ahead a bit to a place where 'ecx' is assumed to contain
; y0 -- and it just so happens 'ecx' is zero in this case:

        and     ecx,F - 1
        jz      short @f
        imul    ebp,ecx                 ;ebp = dM * N0
        sub     eax,ebp

; Calculate the x-coordinate of the first pixel:

    if (flags AND ROUND_Y_DOWN)
        cmp     ebx,1
        sbb     ebx,8                   ;M0 -= 8
    else
        sub     ebx,8                   ;M0 -= 8
    endif
        sbb     ebp,ebp
        xor     ebx,ebp
        sub     ebx,ebp                 ;M0 = ABS(M0)
        cmp     ecx,ebx
        sbb     ecx,ecx
        not     ecx                     ;ecx = -y0

; Now adjust the error term accordingly:

@@:
    if (flags AND ROUND_X_DOWN)
        dec     eax
    endif
        sar     eax,FLOG2               ;eax = floor((M0 + 8) dN - N0 dM] / 16)

        mov     ebx,[esp].sf_ptlOrg.ptl_x
        mov     ebp,[esp].sf_ptlOrg.ptl_y

        sub     ebp,ecx                 ;ebp = ptlOrg.ptl_y + y0

        and     ecx,esi
        add     ecx,eax
        sub     ecx,edi                 ;ecx = dM * x0 + initial error - dN
        jl      short @f                ;if the error term >= 0, we have to
        sub     ecx,edi                 ; add 1 to the x position and subtract
        inc     ebx                     ; dN off again
@@:

endm

;---------------------------Public-Routine------------------------------;
; vIoFastLine(ppdev, ppo, prclClip, apfn, flags, color, ulHwMix)
;
; Draws fast lines.  Or at least attempts to.  Uses normal I/O.
;
; Input:
;
;    ppdev     - PDEV pointer
;    ppo       - path to be drawn
;    prclClip  - pointer to rectangle array for passing to 'bLines'
;    apfn      - pointer to strip routines for passing to 'bLines'
;    flags     - status flag for passing to 'bLines'
;    color     - color
;    ulHwMix   - mix
;
;-----------------------------------------------------------------------;

; NOTE: Don't go changing parameters without also changing STACK_FRAME!

cProc vIoFastLine,28,<   \
    uses esi edi ebx,    \
    ebp_ppdev:     ptr,  \
    ebp_ppo:       ptr,  \
    ebp_prclClip:  ptr,  \
    ebp_apfn:      ptr,  \
    ebp_flags:     dword,\
    ebp_color:     dword,\
    ebp_ulHwMix:   dword>

; Leave room for our stack frame.
;
; NOTE: Don't add local variables here -- you can't reference them with
;       ebp anyway!  Add them to the STACK_FRAME structure.

    local aj[(size STACK_FRAME) - 4 * (STATE_MEM_SIZE + PROC_MEM_SIZE)]: byte

; We save 'ebp' on the stack (note that STACK_FRAME accounts for this push):

        push    ebp

        mov     esi,[esp].sf_ppdev

        mov     [esp].sf_ulLastLength,-1;make sure first line in path resets
                                        ; LINE_MAX value

; Warm up the hardware:

        mov     edx,[esi].pdev_ioGp_stat_cmd
@@:     in      ax,dx
        and     eax,FIFO_3_EMPTY
        jnz     short @b                ;IO_FIFO_WAIT(ppdev, 3)

        mov     edx,[esi].pdev_ioFrgd_color
        mov     eax,[esp].sf_color
        out     dx,ax                   ;IO_FRGD_COLOR(ppdev, color)

        mov     edx,[esi].pdev_ioFrgd_mix
        mov     eax,[esp].sf_ulHwMix
        or      eax,FOREGROUND_COLOR
        out     dx,ax                   ;IO_FRGD_MIX(ppdev, FOREGROUND_COLOR |
                                        ;                   ulHwMix)

        mov     edx,[esi].pdev_ioMulti_function
        mov     eax,DATA_EXTENSION
        out     dx,ax                   ;IO_PIX_CNTL(ppdev, ALL_ONES)


; Now get some path stuff:

io_next_record:

        mov     eax,[esp].sf_ppo
        lea     ebx,[esp].sf_pd
        cCall   PATHOBJ_bEnum,<eax,ebx>
        mov     [esp].sf_bMore,eax      ;save away return code for later

        mov     ebx,[esp].sf_pd.pd_count;if 0 points in record, get outta here
        or      ebx,ebx
        jz      io_check_for_closefigure

        lea     ebp,[8 * ebx - 8]
        add     ebp,[esp].sf_pd.pd_pptfx
        mov     [esp].sf_pptfxEnd,ebp   ;points to last point in record

        mov     ecx,[esp].sf_pd.pd_flags
        test    ecx,PD_BEGINSUBPATH
        jz      short io_continue_subpath

; Handle a new sub-path:

        mov     eax,[esp].sf_pd.pd_pptfx
        add     eax,8
        mov     [esp].sf_pptfx,eax

        mov     esi,[ebp].ptl_x         ;remember last point in case we have
        mov     edi,[ebp].ptl_y         ; to continue to another record
        mov     [esp].sf_ptfxLast.ptl_x,esi
        mov     [esp].sf_ptfxLast.ptl_y,edi

        mov     ebx,[eax - 8].ptl_x     ;load up current start and end point
        mov     ecx,[eax - 8].ptl_y
        mov     esi,[eax].ptl_x
        mov     edi,[eax].ptl_y
        mov     [esp].sf_ptfxStartFigure.ptl_x,ebx
        mov     [esp].sf_ptfxStartFigure.ptl_y,ecx

        mov     [esp].sf_bSetCP,1       ;this line is first in figure

        cmp     eax,[esp].sf_pptfxEnd   ;we have to be careful when the only
                                        ; point in the record is the start-
                                        ; figure point (pretty rare)
        jbe     io_new_line
        jmp     short io_next_record

io_continue_subpath:

; This record continues the path:

        mov     eax,[esp].sf_pd.pd_pptfx
        mov     ebx,[esp].sf_ptfxLast.ptl_x ;load up current start point
        mov     ecx,[esp].sf_ptfxLast.ptl_y

        mov     esi,[ebp].ptl_x         ;remember last point in case we have
        mov     edi,[ebp].ptl_y         ; to continue to another record
        mov     [esp].sf_ptfxLast.ptl_x,esi
        mov     [esp].sf_ptfxLast.ptl_y,edi

        mov     esi,[eax].ptl_x         ;load up current end point
        mov     edi,[eax].ptl_y
        mov     [esp].sf_pptfx,eax

        jmp     io_new_line

;/////////////////////////////////////////////////////////////////////
;// Next Line Stuff
;/////////////////////////////////////////////////////////////////////

io_handle_closefigure:
        mov     [esp].sf_pd.pd_flags,0
        mov     ebx,[esp].sf_ptfxLast.ptl_x
        mov     ecx,[esp].sf_ptfxLast.ptl_y
        mov     esi,[esp].sf_ptfxStartFigure.ptl_x
        mov     edi,[esp].sf_ptfxStartFigure.ptl_y

        jmp     io_new_line

; Before getting the next path record, see if we have to do a closefigure:

io_check_for_closefigure:
        test    [esp].sf_pd.pd_flags,PD_CLOSEFIGURE
        jnz     io_handle_closefigure
        mov     esi,[esp].sf_bMore
        or      esi,esi
        jnz     io_next_record

io_all_done:

        pop     ebp
        cRet    vIoFastLine

;/////////////////////////////////////////////////////////////////////
;// Output Integer Line
;/////////////////////////////////////////////////////////////////////

; ebx                  = x
; ecx                  = y
; esi                  = dx
; edi                  = dy
; [esp].sf_ulErrorTerm = incomplete error term (actual value is 'dx - bias')
; [esp].sf_ulCmd       = draw command

; NOTE: The port values retrieved from the PDEV are word values, and word
; moves have a one cycle penalty.  For this reason, the values should
; actually be defined as dwords in the PDEV...

        public  io_int_output_line
io_int_output_line::
        mov     ebp,[esp].sf_ppdev      ;ebp = ppdev
        cmp     [esp].sf_bSetCP,0
        je      short io_int_current_position_already_set

        mov     edx,[ebp].pdev_ioGp_stat_cmd
@@:     in      ax,dx
        and     eax,FIFO_7_EMPTY        ;wait for 7 entries
        jnz     short @b

        mov     edx,[ebp].pdev_ioCur_x
        mov     eax,ebx
        add     eax,[ebp].pdev_xOffset
        out     dx,ax

        mov     edx,[ebp].pdev_ioCur_y
        mov     eax,ecx
        add     eax,[ebp].pdev_yOffset
        out     dx,ax

        mov     [esp].sf_bSetCP,0       ;the next integer line in this figure
                                        ; will have the CP set correctly

        jmp     short io_int_output_common

io_int_current_position_already_set:
        mov     edx,[ebp].pdev_ioGp_stat_cmd
@@:     in      ax,dx
        and     eax,FIFO_5_EMPTY        ;wait for 5 entries
        jnz     short @b

        public  io_int_output_common
io_int_output_common::
        cmp     esi,[esp].sf_ulLastLength
        je      short @f

        mov     edx,[ebp].pdev_ioMaj_axis_pcnt
        mov     eax,esi
        out     dx,ax
        mov     [esp].sf_ulLastLength,eax
@@:
        mov     edx,[ebp].pdev_ioDesty_axstp
        mov     eax,edi
        out     dx,ax                   ;axial = dy

        mov     edx,[ebp].pdev_ioDestx_diastp
        sub     eax,esi
        out     dx,ax                   ;diag = dy - dx

        mov     edx,[esp].sf_ulErrorTerm
        sar     edx,1
        add     eax,edx
        mov     edx,[ebp].pdev_ioErr_term
        out     dx,ax                   ;err = dy - dx + floor((dx - bias) / 2)

        mov     edx,[ebp].pdev_ioGp_stat_cmd
        mov     eax,[esp].sf_ulCmd
        out     dx,ax                   ;draw that puppy

;/////////////////////////////////////////////////////////////////////
;// Main Loop
;/////////////////////////////////////////////////////////////////////

        public  io_next_line
io_next_line::
        mov     eax,[esp].sf_pptfx
        cmp     eax,[esp].sf_pptfxEnd
        jae     io_check_for_closefigure

        mov     ebx,[eax].ptl_x
        mov     ecx,[eax].ptl_y
        mov     esi,[eax+8].ptl_x
        mov     edi,[eax+8].ptl_y
        add     eax,8
        mov     [esp].sf_pptfx,eax

        public  io_new_line
io_new_line::

; Octants are numbered as follows:
;
;        \ 5 | 6 /
;         \  |  /
;        4 \ | / 7
;           \ /
;       -----+-----
;           /|\
;        3 / | \ 0
;         /  |  \
;        / 2 | 1 \
;

; ebx = M0
; ecx = N0
; esi = M1 (dM)
; edi = N1 (dN)

        mov     [esp].sf_ptfxStart.ptl_x,ebx
        mov     [esp].sf_ptfxStart.ptl_y,ecx
        mov     [esp].sf_ptfxEnd.ptl_x,esi
        mov     [esp].sf_ptfxEnd.ptl_y,edi
                                        ;save points in case we have to punt
        mov     eax,ebx
        or      eax,ecx
        or      eax,esi
        or      eax,edi
        and     eax,F-1
        jnz     io_non_integer

;/////////////////////////////////////////////////////////////////////
;// Integer Lines
;/////////////////////////////////////////////////////////////////////

        sar     ebx,FLOG2               ;x0
        sar     ecx,FLOG2               ;y0
        sar     esi,FLOG2               ;x1 (soon to be dx)
        sar     edi,FLOG2               ;y1 (soon to be dy)

        sub     esi,ebx
        jl      io_int_2_3_4_5
        jz      io_int_radial_90_270
        sub     edi,ecx
        jl      io_int_6_7
        jz      io_int_radial_0
        cmp     esi,edi
        jl      io_int_1
        je      io_int_radial_315

io_int_0:
        lea     ebp,[esi - 1]
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_Y + PLUS_X
        mov     [esp].sf_ulErrorTerm,ebp

        jmp     io_int_output_line

        public  io_int_1
io_int_1::
        xchg    esi,edi
        lea     ebp,[esi - 1]
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_Y + PLUS_X + MAJOR_Y
        mov     [esp].sf_ulErrorTerm,ebp

        jmp     io_int_output_line

        public  io_int_2_3_4_5
io_int_2_3_4_5::
        neg     esi
        sub     edi,ecx
        jl      io_int_4_5
        jz      io_int_radial_180
        cmp     esi,edi
        jl      io_int_2
        je      io_int_radial_225

        public  io_int_3
io_int_3::
        lea     ebp,[esi - 1]
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_Y
        mov     [esp].sf_ulErrorTerm,ebp

        jmp     io_int_output_line

        public  io_int_2
io_int_2::
        xchg    esi,edi
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_Y + MAJOR_Y
        mov     [esp].sf_ulErrorTerm,esi

        jmp     io_int_output_line

        public  io_int_4_5
io_int_4_5::
        neg     edi
        cmp     esi,edi
        jl      io_int_5
        je      io_int_radial_135

io_int_4:
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD
        mov     [esp].sf_ulErrorTerm,esi

        jmp     io_int_output_line

        public  io_int_5
io_int_5::
        xchg    esi,edi
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + MAJOR_Y
        mov     [esp].sf_ulErrorTerm,esi

        jmp     io_int_output_line

        public  io_int_6_7
io_int_6_7::
        neg     edi
        cmp     esi,edi
        jg      io_int_7
        je      io_int_radial_45

io_int_6:
        xchg    esi,edi
        lea     ebp,[esi - 1]
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + MAJOR_Y + PLUS_X
        mov     [esp].sf_ulErrorTerm,ebp

        jmp     io_int_output_line

        public  io_int_7
io_int_7::
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_X
        mov     [esp].sf_ulErrorTerm,esi

        jmp     io_int_output_line

;/////////////////////////////////////////////////////////////////////
;// Lines In The 8 Cardinal Directions
;/////////////////////////////////////////////////////////////////////

        public  io_int_radial_45
io_int_radial_45::
        mov     ebp,DRAW_LINE + DRAW + DIR_TYPE_RADIAL + WRITE + \
                    LAST_PIXEL_OFF + MULTIPLE_PIXELS + DRAWING_DIRECTION_45
        jmp     short io_int_output_radial

        public  io_int_radial_135
io_int_radial_135::
        mov     ebp,DRAW_LINE + DRAW + DIR_TYPE_RADIAL + WRITE + \
                    LAST_PIXEL_OFF + MULTIPLE_PIXELS + DRAWING_DIRECTION_135
        jmp     short io_int_output_radial

        public  io_int_radial_225
io_int_radial_225::
        mov     ebp,DRAW_LINE + DRAW + DIR_TYPE_RADIAL + WRITE + \
                    LAST_PIXEL_OFF + MULTIPLE_PIXELS + DRAWING_DIRECTION_225
        jmp     short io_int_output_radial

        public  io_int_radial_315
io_int_radial_315::
        mov     ebp,DRAW_LINE + DRAW + DIR_TYPE_RADIAL + WRITE + \
                    LAST_PIXEL_OFF + MULTIPLE_PIXELS + DRAWING_DIRECTION_315
        jmp     short io_int_output_radial

        public  io_int_radial_90_270
io_int_radial_90_270::
        mov     ebp,DRAW_LINE + DRAW + DIR_TYPE_RADIAL + WRITE + \
                    LAST_PIXEL_OFF + MULTIPLE_PIXELS + DRAWING_DIRECTION_270
        mov     esi,edi
        sub     esi,ecx
        jg      short io_int_output_radial ;if top-to-bottom vertical line
        jz      io_next_line               ;if zero length line

        neg     esi
        mov     ebp,DRAW_LINE + DRAW + DIR_TYPE_RADIAL + WRITE + \
                    LAST_PIXEL_OFF + MULTIPLE_PIXELS + DRAWING_DIRECTION_90
        jmp     short io_int_output_radial

        public  io_int_radial_180
io_int_radial_180::
        mov     ebp,DRAW_LINE + DRAW + DIR_TYPE_RADIAL + WRITE + \
                    LAST_PIXEL_OFF + MULTIPLE_PIXELS + DRAWING_DIRECTION_180
        jmp     short io_int_output_radial

io_int_radial_0:
        mov     ebp,DRAW_LINE + DRAW + DIR_TYPE_RADIAL + WRITE + \
                    LAST_PIXEL_OFF + MULTIPLE_PIXELS + DRAWING_DIRECTION_0

; ebx = x
; ecx = y
; esi = dx (length of radial line since it's normalized)
; ebp = drawing command

        public  io_int_output_radial
io_int_output_radial::
        mov     edi,[esp].sf_ppdev
        cmp     [esp].sf_bSetCP,0
        je      short io_int_radial_continue_figure

        mov     edx,[edi].pdev_ioGp_stat_cmd
@@:     in      ax,dx
        and     eax,FIFO_4_EMPTY
        jnz     short @b

        mov     edx,[edi].pdev_ioCur_x
        mov     eax,ebx
        add     eax,[edi].pdev_xOffset
        out     dx,ax

        mov     edx,[edi].pdev_ioCur_y
        mov     eax,ecx
        add     eax,[edi].pdev_yOffset
        out     dx,ax

        mov     [esp].sf_bSetCP,0       ;the next integer line in this figure
                                        ; will have the CP set correctly

        cmp     esi,[esp].sf_ulLastLength
        je      short @f

        mov     edx,[edi].pdev_ioMaj_axis_pcnt
        mov     eax,esi
        out     dx,ax
        mov     [esp].sf_ulLastLength,eax
@@:
        mov     edx,[edi].pdev_ioGp_stat_cmd
        mov     eax,ebp
        out     dx,ax
        jmp     io_next_line

; Jump to here if we don't have to update the current position first:

        public  io_int_radial_continue_figure
io_int_radial_continue_figure::
        cmp     esi,[esp].sf_ulLastLength
        je      short io_int_radial_skip_length

        mov     edx,[edi].pdev_ioGp_stat_cmd
@@:     in      ax,dx
        and     eax,FIFO_2_EMPTY
        jnz     short @b

        mov     edx,[edi].pdev_ioMaj_axis_pcnt
        mov     eax,esi
        out     dx,ax
        mov     [esp].sf_ulLastLength,eax

        mov     edx,[edi].pdev_ioGp_stat_cmd
        mov     eax,ebp
        out     dx,ax
        jmp     io_next_line

; Jump to here if we don't have to update the current position or the
; line length variable:

        public  io_int_radial_skip_length
io_int_radial_skip_length::
        mov     edx,[edi].pdev_ioGp_stat_cmd
@@:     in      ax,dx
        and     eax,FIFO_1_EMPTY
        jnz     short @b

        mov     edx,[edi].pdev_ioGp_stat_cmd
        mov     eax,ebp
        out     dx,ax
        jmp     io_next_line

;/////////////////////////////////////////////////////////////////////
;// Non-Integer Lines
;/////////////////////////////////////////////////////////////////////

        public  io_non_integer
io_non_integer::
        sub     esi,ebx
        jl      io_not_int_2_3_4_5
        sub     edi,ecx
        jl      io_not_int_6_7
        cmp     esi,edi
        jl      io_not_int_1
        je      io_not_int_0_slope_one

io_not_int_0:
        cmp     esi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQ     ROUND_X_AND_Y_DOWN

io_not_int_0_common:
        add     ecx,edi                 ;err += dN
        mov     [esp].sf_ulErrorTerm,ecx

        mov     eax,[esp].sf_x1
        sub     eax,ebx
        jle     io_next_line
        mov     [esp].sf_cPels,eax
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_Y + PLUS_X

        public  io_not_int_x_major
io_not_int_x_major::
        mov     ecx,[esp].sf_ppdev
        mov     edx,[ecx].pdev_ioGp_stat_cmd
@@:     in      ax,dx
        and     eax,FIFO_7_EMPTY        ;wait for 7 entries
        jnz     short @b

; Fractional end-point lines aren't usually going to have the current
; position already set correctly, so we explicitly set the CP each time:

        mov     edx,[ecx].pdev_ioCur_x
        mov     eax,ebx
        add     eax,[ecx].pdev_xOffset
        out     dx,ax                   ;x0

        mov     edx,[ecx].pdev_ioCur_y
        mov     eax,ebp
        add     eax,[ecx].pdev_yOffset
        out     dx,ax                   ;y0

        mov     [esp].sf_bSetCP,1       ;the next integer line in this figure
                                        ; will not necessarily have the CP set
                                        ; correctly

        mov     eax,[esp].sf_cPels
        cmp     eax,[esp].sf_ulLastLength
        je      short @f

        mov     edx,[ecx].pdev_ioMaj_axis_pcnt
        out     dx,ax                   ;length = cPels
        mov     [esp].sf_ulLastLength,eax
@@:
        mov     edx,[ecx].pdev_ioDesty_axstp
        mov     eax,edi
        out     dx,ax                   ;axial = dN

        mov     edx,[ecx].pdev_ioDestx_diastp
        sub     eax,esi
        out     dx,ax                   ;diag = dN - dM

        mov     edx,[ecx].pdev_ioErr_term
        mov     eax,[esp].sf_ulErrorTerm
        out     dx,ax                   ;error term

        mov     edx,[ecx].pdev_ioGp_stat_cmd
        mov     eax,[esp].sf_ulCmd
        out     dx,ax                   ;output it

        jmp     io_next_line

; Lines of slope one have a special rounding rule: when the line
; runs exactly half way between two pixels, the upper or right pel
; is illuminated.  This translates into x=1/2 rounding up in value,
; and y=1/2 rounding down:

        public  io_not_int_0_slope_one
io_not_int_0_slope_one::
        or      esi,esi
        jz      io_next_line               ;quick check for a zero length GIQ line

        cmp     esi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQ     ROUND_Y_DOWN_SLOPE_ONE
        jmp     io_not_int_0_common

        public  io_not_int_1
io_not_int_1::
        cmp     edi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQR    ROUND_X_AND_Y_DOWN
        add     ecx,esi                 ;err += dM
        mov     [esp].sf_ulErrorTerm,ecx

        mov     eax,[esp].sf_y1
        sub     eax,ebp
        jle     io_next_line
        mov     [esp].sf_cPels,eax
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_Y + PLUS_X + MAJOR_Y

        public  io_not_int_y_major
io_not_int_y_major::
        mov     ecx,[esp].sf_ppdev
        mov     edx,[ecx].pdev_ioGp_stat_cmd
@@:     in      ax,dx
        and     eax,FIFO_7_EMPTY        ;wait for 7 entries
        jnz     short @b

; Fractional end-point lines aren't usually going to have the current
; position already set correctly, so we explicitly set the CP each time:

        mov     edx,[ecx].pdev_ioCur_x
        mov     eax,ebx
        add     eax,[ecx].pdev_xOffset
        out     dx,ax                   ;x0

        mov     edx,[ecx].pdev_ioCur_y
        mov     eax,ebp
        add     eax,[ecx].pdev_yOffset
        out     dx,ax                   ;y0

        mov     [esp].sf_bSetCP,1       ;the next integer line in this figure
                                        ; will not necessarily have the CP set
                                        ; correctly

        mov     eax,[esp].sf_cPels
        cmp     eax,[esp].sf_ulLastLength
        je      short @f

        mov     edx,[ecx].pdev_ioMaj_axis_pcnt
        out     dx,ax                   ;length = cPels
        mov     [esp].sf_ulLastLength,eax
@@:
        mov     edx,[ecx].pdev_ioDesty_axstp
        mov     eax,esi
        out     dx,ax                   ;axial = dM

        mov     edx,[ecx].pdev_ioDestx_diastp
        sub     eax,edi
        out     dx,ax                   ;diag = dM - dN

        mov     edx,[ecx].pdev_ioErr_term
        mov     eax,[esp].sf_ulErrorTerm
        out     dx,ax                   ;error term

        mov     edx,[ecx].pdev_ioGp_stat_cmd
        mov     eax,[esp].sf_ulCmd
        out     dx,ax                   ;output it

        jmp     io_next_line

        public  io_not_int_2_3_4_5
io_not_int_2_3_4_5::
        neg     esi                     ;dM = -dM (now positive)
        neg     ebx                     ;M0 = -M0
        sub     edi,ecx
        jl      io_not_int_4_5
        cmp     esi,edi
        jl      io_not_int_2

io_not_int_3:
        cmp     esi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQ     ROUND_Y_DOWN
        add     ecx,edi                 ;err += dN
        mov     [esp].sf_ulErrorTerm,ecx

        neg     ebx                     ;untransform x0

        mov     eax,[esp].sf_x1
        add     eax,ebx
        jle     io_next_line
        mov     [esp].sf_cPels,eax
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_Y

        jmp     io_not_int_x_major

        public  io_not_int_2
io_not_int_2::
        cmp     edi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQR    ROUND_Y_DOWN
        add     ecx,esi                 ;err += dM
        mov     [esp].sf_ulErrorTerm,ecx

        neg     ebx                     ;untransform x0

        mov     eax,[esp].sf_y1
        sub     eax,ebp
        jle     io_next_line
        mov     [esp].sf_cPels,eax
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_Y + MAJOR_Y

        jmp     io_not_int_y_major

        public  io_not_int_4_5
io_not_int_4_5::
        neg     edi                     ;dN = -dN (now positive)
        neg     ecx                     ;N0 = -N0
        cmp     esi,edi
        jl      io_not_int_5
        je      io_not_int_4_slope_one

        public  io_not_int_4
io_not_int_4::
        cmp     esi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQ     0

io_not_int_4_common:
        add     ecx,edi                 ;err += dN
        mov     [esp].sf_ulErrorTerm,ecx

        neg     ebx                     ;untransform x0
        neg     ebp                     ;untransform y0

        mov     eax,[esp].sf_x1
        add     eax,ebx
        jle     io_next_line
        mov     [esp].sf_cPels,eax
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD

        jmp     io_not_int_x_major

; Lines of slope one have a special rounding rule.

        public  io_not_int_4_slope_one
io_not_int_4_slope_one::
        cmp     esi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQ     ROUND_X_DOWN_SLOPE_ONE
        jmp     io_not_int_4_common

        public  io_not_int_5
io_not_int_5::
        cmp     edi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQR    0
        add     ecx,esi                 ;err += dM
        mov     [esp].sf_ulErrorTerm,ecx

        neg     ebx                     ;untransform x0
        neg     ebp                     ;untransform y0

        mov     eax,[esp].sf_y1
        add     eax,ebp
        jle     io_next_line
        mov     [esp].sf_cPels,eax
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + MAJOR_Y

        jmp     io_not_int_y_major

        public  io_not_int_6_7
io_not_int_6_7::
        neg     edi                     ;dN = -dN (now positive)
        neg     ecx                     ;M0 = -M0
        cmp     esi,edi
        je      io_not_int_7_slope_one
        jg      io_not_int_7

        public  io_not_int_6
io_not_int_6::
        cmp     edi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQR    ROUND_X_DOWN
        add     ecx,esi                 ;err += dM
        mov     [esp].sf_ulErrorTerm,ecx

        neg     ebp                     ;untransform y0

        mov     eax,[esp].sf_y1
        add     eax,ebp
        jle     io_next_line
        mov     [esp].sf_cPels,eax
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + MAJOR_Y + PLUS_X

        jmp     io_not_int_y_major

        public  io_not_int_7
io_not_int_7::
        cmp     esi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQ     ROUND_X_DOWN

io_not_int_7_common:
        add     ecx,edi                 ;err += dN
        mov     [esp].sf_ulErrorTerm,ecx

        neg     ebp                     ;untransform y0

        mov     eax,[esp].sf_x1
        sub     eax,ebx
        jle     io_next_line
        mov     [esp].sf_cPels,eax
        mov     [esp].sf_ulCmd,DEFAULT_DRAW_CMD + PLUS_X

        jmp     io_not_int_x_major

        public  io_not_int_7_slope_one
io_not_int_7_slope_one::
        cmp     esi,MAX_GIQ_DELTA
        jg      io_punt_line

        GIQ     ROUND_X_DOWN_SLOPE_ONE
        jmp     io_not_int_7_common

;/////////////////////////////////////////////////////////////////////
;// Punt Line
;/////////////////////////////////////////////////////////////////////

; If the line is too long, we punt to our strip drawing routine.

        public  io_punt_line
io_punt_line::
        mov     esi,esp
        lea     eax,[esp].sf_ptfxStart
        lea     ebx,[esp].sf_ptfxEnd

        cCall   bLines,<[esi].sf_ppdev, eax, ebx, 0, 1, 0, \
                        [esi].sf_prclClip, [esi].sf_apfn, [esi].sf_flags>

        mov     [esp].sf_bSetCP,1       ;Always reset CP after punting
        mov     [esp].sf_ulLastLength,-1;Always reset line length after punting

        jmp     io_next_line

endProc vIoFastLine

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\i386\lines.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: lines.inc
;
; Line drawing constants and structures.
;
; NOTE: This file mirrors LINES.H.  Changes here must be reflected in
; the .h file!
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

; We have special strip routines when all strips have at most this many
; pixels:

MAX_SHORT_STROKE_LENGTH equ 15

; # of strip drawers in every group:

NUM_STRIP_DRAW_DIRECTIONS equ 4

; # of strip drawers for doing either solid lines or styled lines:

NUM_STRIP_DRAW_STYLES equ 8

STYLE_MAX_COUNT         equ 16
STYLE_MAX_VALUE         equ 3fffh
RUN_MAX                 equ 20
STRIP_MAX               equ 100
STYLE_DENSITY           equ 3

; Flip and round flags:

FL_H_ROUND_DOWN         equ 00000080h   ; Set if x = 1/2 rounds to x = 1
FL_V_ROUND_DOWN         equ 00008000h   ; Set if y = 1/2 rounds to y = 1

FL_FLIP_D               equ 00000005h   ; Diagonal flip
FL_FLIP_V               equ 00000008h   ; Vertical flip
FL_FLIP_SLOPE_ONE       equ 00000010h   ; If slope is exactly one
FL_FLIP_HALF            equ 00000002h   ; Half flip
FL_FLIP_H               equ 00000200h   ; Horizontal (right-to-left) exchange

FL_ROUND_MASK           equ 0000001ch   ; Rounding is dependent on diagonal,
FL_ROUND_SHIFT          equ 2           ;  vertical flips and if slope is one

FL_RECTLCLIP_MASK       equ 0000000ch   ; When we unflip to do clipping, we
FL_RECTLCLIP_SHIFT      equ 2           ;  only have to look at diagonal and
                                        ;  vertical flips

FL_STRIP_MASK           equ 00000003h   ; Which strip drawer we call is based
FL_STRIP_SHIFT          equ 0           ;  on if we did diagonal and/or half
                                        ;  flips

FL_SIMPLE_CLIP          equ 00000020h   ; Denotes our clipping complexity
FL_COMPLEX_CLIP         equ 00000040h
FL_CLIP                 equ (FL_SIMPLE_CLIP + FL_COMPLEX_CLIP)

FL_SET                  equ 00000800h   ; If ROP is such that we don't have to
                                        ;  read video memory
FL_ARBITRARYSTYLED      equ 00000400h   ; If the line is styled
FL_STYLED               equ (FL_ARBITRARYSTYLED)

FL_STRIP_ARRAY_MASK     equ 00000C00h   ; Which strip arrays we look up depends
FL_STRIP_ARRAY_SHIFT    equ 10          ;  on if we're doing style and/or have
                                        ;  a 'set' style ROP

; Simple flag bits in high byte:

FL_DONT_DO_HALF_FLIP    equ 00002000h
FL_PHYSICAL_DEVICE      equ 00004000h

; Miscellaneous DDA defines:

F                       equ 16
FLOG2                   equ 4

;------------------------------------------------------------------------
; NOTE: The following structures must exactly match those declared in
;       lines.h!

STRIPS struc
    ST_cStrips	        dd  ?
    ST_flFlips          dd  ?
    ST_ptlStart         dd  2 dup(?)
    ST_alStrips	        dd  STRIP_MAX dup (?)
STRIPS ends

LINESTATE struc
    LS_pspStart         dd  ?
    LS_pspEnd           dd  ?
    LS_psp              dd  ?
    LS_spRemaining      dd  ?
    LS_spTotal          dd  ?
    LS_spTotal2         dd  ?
    LS_spNext           dd  ?
    LS_spComplex        dd  ?
    LS_aspRtoL          dd  ?
    LS_aspLtoR          dd  ?
    LS_jStyleMask       db  ?
    LS_filler2          db  3 dup (?)
    LS_xyDensity        dd  ?
    LS_cStyle           dd  ?
    LS_ulStyleMaskLtoR  dd  ?
    LS_ulStyleMaskRtoL  dd  ?
    LS_jStartMask       db  ?
    LS_filler3          db  3 dup (?)
LINESTATE ends

RUN struc
    RUN_iStart          dd  ?
    RUN_iStop           dd  ?
RUN ends

DEFAULT_DRAW_CMD	    equ (DRAW_LINE+DRAW+DIR_TYPE_XY+MULTIPLE_PIXELS+WRITE+ \
                             LAST_PIXEL_OFF)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\atint.h ===
/*************************************************************************
 **                                                                     **
 **                             ATINT.H                                 **
 **                                                                     **
 **     Copyright (c) 1992, ATI Technologies Inc.                       **
 *************************************************************************

  Contains information specific to Windows NT, and is common between
  the Install application ANTPANEL, and the Display and Miniport drivers.

  $Revision:   1.19  $
  $Date:   30 Apr 1996 13:20:36  $
  $Author:   reng  $
  $Log:   S:/source/wnt/ms11/displays/archive/atint.h_v  $
 * 
 *    Rev 1.19   30 Apr 1996 13:20:36   reng
 * 1 Meg SDRAM problem; GT cursor problem
 *
 *    Rev 1.18   03 Apr 1996 10:12:26   reng
 * use WINVER to distinguish NT 4.0 from NT 3.51
 *
 *    Rev 1.17   26 Mar 1996 15:27:38   reng
 * New driver sources
 *
 *    Rev 1.16   23 Jan 1996 11:41:36   RWolff
 * Now forces compile-time error if NTDDVDEO.H is not included before
 * this file rather than generating false values of TARGET_BUILD, added
 * DrvEscape() functions used by multiheaded display applet.
 *
 *    Rev 1.15   22 Dec 1995 14:59:32   RWolff
 * Added support for Mach 64 GT internal DAC.
 *
 *    Rev 1.14   21 Dec 1995 14:05:36   RWolff
 * Added TARGET_BUILD definition to identify which version of NT we are
 * building for, rather than using a different definition for each break
 * between versions.
 *
 *    Rev 1.13   23 Nov 1995 11:25:10   RWolff
 * Added multihead support.
 *
 *    Rev 1.12   24 Aug 1995 15:38:04   RWolff
 * Added definitions to report CT and VT ASICs to the display driver.
 *
 *    Rev 1.11   27 Feb 1995 17:46:44   RWOLFF
 * Added flag for packed (relocatable) I/O to ENH_VERSION_NT.FeatureFlags
 * bitmask.
 *
 *    Rev 1.10   24 Feb 1995 12:23:08   RWOLFF
 * Added flag for 24BPP text banding to ModeFlags field of mode
 * information structure.
 *
 *    Rev 1.9   03 Feb 1995 15:14:16   RWOLFF
 * Added Feature Flag to show that dense space is available.
 *
 *    Rev 1.8   30 Jan 1995 11:54:36   RWOLFF
 * Made detection of Daytona vs. older versions of NT automatic, miniport
 * and display driver now use the same version of this file.
 *
 *    Rev 1.7   23 Dec 1994 10:48:34   ASHANMUG
 * ALPHA/Chrontel-DAC
 *
 *    Rev 1.6   31 Aug 1994 16:18:38   RWOLFF
 * Added definiton to go in ENH_VERSION_NT.FeatureFlags to show that
 * TVP3026 cursor handling is needed.
 *
 *    Rev 1.5   04 May 1994 19:24:04   RWOLFF
 * Moved block write flag back to IOCTL_VIDEO_ATI_GET_MODE_INFORMATION
 * because the test can only be run if we have already switched
 * into graphics mode.
 *
 *    Rev 1.4   28 Apr 1994 10:58:52   RWOLFF
 * Moved mode-independent bug/feature flags to IOCTL_VIDEO_ATI_GET_VERSION
 * packet from IOCTL_VIDEO_ATI_GET_MODE_INFORMATION packet.
 *
 *    Rev 1.3   27 Apr 1994 13:52:58   RWOLFF
 * Added definition for MIO bug in ModeFlags bitfield.
 *
 *    Rev 1.2   31 Mar 1994 15:00:52   RWOLFF
 * Added key to be used in DrvEscape() and values to be returned.
 *
 *    Rev 1.1   14 Mar 1994 16:29:08   RWOLFF
 * Added bit definition in ModeFlags for 2M boundary tearing, DPMS IOCTL
 * is now consistent with Daytona.
 *
 *    Rev 1.0   31 Jan 1994 11:29:10   RWOLFF
 * Initial revision.
 *
 *    Rev 1.3   24 Jan 1994 18:01:42   RWOLFF
 * Added definitions for new Mach 32 ASIC (68800LX), changed some Mach 64
 * definitions to accomodate changes in 94/01/19 BIOS document.
 *
 *    Rev 1.2   14 Jan 1994 15:19:32   RWOLFF
 * Added definition for unknown non-Mach32 ASIC, flags to show if block
 * write and memory mapped registers are available, added fields for
 * bus type in ENH_VERSION_NT structure, preliminary structure and
 * definitions for DPMS packet.
 *
 *    Rev 1.1   30 Nov 1993 18:12:12   RWOLFF
 * Renamed definitions for Mach 64 chip.
 *
 *    Rev 1.0   03 Sep 1993 14:27:20   RWOLFF
 * Initial revision.

           Rev 1.5   22 Jan 1993 14:49:34   Chris_Brady
        add card capabilities to GET_INFO Ioctl.

           Rev 1.4   22 Jan 1993 14:46:40   Chris_Brady
        add ATIC_ defines for the card capabilities.

           Rev 1.3   20 Jan 1993 17:47:16   Robert_Wolff
        Added PVERSION_NT type definition, removed obsolete comment.

           Rev 1.2   19 Jan 1993 09:50:58   Chris_Brady
        add ANT_ drawing interface defines.

           Rev 1.1   18 Jan 1993 15:49:34   Chris_Brady
        new GetInof structure.

           Rev 1.0   15 Jan 1993 16:43:08   Chris_Brady
        Initial revision.


------------------------------------------------------------------------*/

//  is in the \ddk\public\sdk\inc  directory
#include <devioctl.h>

// allow the miniport driver to Force seletion of a Programming Interface
enum    {
    ANT_DEFAULT=0,
    ANT_ENGINE_ONLY,
    ANT_APERTURE,
    ANT_VGA
    };

// Private Display driver Functions. Communication from ANTPANEL to
// the Display  ATI*.DLL to the Miniport ATI*.SYS  drivers.
enum   {
    ATI_GET_INFO=1,
    ATI_GET_nextone
    };

// Define the possible ATI graphics card configurations so the Display
// driver can decide the best drawing methods to use.
// size is ULONG 32  bit field
// assigned by miniport to   VERSION_NT.capcard
#define ATIC_FIELD_LONGEST  0x80000000  //just to illustrate size

#define ATIC_APERTURE_LFB   0x0400
#define ATIC_APERTURE_VGA   0x0200
#define ATIC_APERTURE_NONE  0x0100      //neither VGA or LFB found

#define ATIC_CARD_TYPE      0x00F0      //defines from 68801.h << 4
#define ATIC_BUS_TYPE       0x000F      //defines from 68801.H



// used with     IOCTL_VIDEO_ATI_GET_VERSION
// In hex:   BBBBVVMM where
//    BBBB is the build number         (0-32767),
//    VV   is the major version number (0-255)
//    MM   is the minor version number (0-255)
typedef  struct  {
    ULONG       display;                //Display Version number
    ULONG       miniport;               //Miniport Version number
    ULONG       capcard;                //card capabilities
    struct   {
        short   xres;
        short   yres;
        short   color;                  // maximum bits per pixel
        }   resolution[6];
    } VERSION_NT, *PVERSION_NT;

/*
 * Definitions used with the ENH_VERSION_NT structure
 */
#define ENH_REVISION 1  // First revision of ENH_VERSION_NT structure

#define BETA_MINIPORT 0x00000080    // Bit set in InterfaceVersion for unsupported miniport versions

enum {
    CI_38800_1 = 0,         // Mach 8 ASIC, only one revision in use
    CI_68800_3,             // Mach 32 ASIC, first production revision
    CI_68800_6,             // Mach 32 ASIC, second production revision
    CI_68800_AX,            // Mach 32 AX ASIC
    CI_88800_GX,            // Mach 64 GX ASIC
    CI_68800_LX,            // Mach 32 LX ASIC
    CI_OTHER_UNKNOWN=30,    // Unknown ASIC other than Mach 32
    CI_68800_UNKNOWN=31,    // Mach 32 ASIC other than versions above
    CI_M64_VTA
    };

#define FL_CI_38800_1       0x00000001
#define FL_CI_68800_3       0x00000002
#define FL_CI_68800_6       0x00000004
#define FL_CI_68800_AX      0x00000008
#define FL_CI_88800_GX      0x00000010
#define FL_CI_68800_LX      0x00000020
#define FL_CI_OTHER_UNKNOWN 0x40000000
#define FL_CI_68800_UNKNOWN 0x80000000

enum {
    ENGINE_ONLY = 0,    // No aperture available
    AP_LFB,             // Linear framebuffer available
    AP_68800_VGA,       // 64k VGA aperture available
    AP_CX_VGA           // Two 32k VGA apertures available
    };

#define FL_ENGINE_ONLY  0x00000001
#define FL_AP_LFB       0x00000002
#define FL_68800_VGA    0x00000004
#define FL_CX_VGA       0x00000008

#define FL_MM_REGS      0x80000000  /* Memory Mapped registers are available */

/*
 * Values which can be placed in FeatureFlags field of ENH_VERSION_NT.
 *
 * Flags should be added to this field if they represent bugs/features
 * which affect all resolution/pixel depth combinations on a given card.
 */
#define EVN_DPMS            0x00000001  // DPMS is supported
#define EVN_SPLIT_TRANS     0x00000002  // This card has split transfer bug
#define EVN_MIO_BUG         0x00000004  // Card has multiple in/out hardware bug
#define EVN_TVP_DAC_CUR     0x00000008  // Cursor handled by TVP DAC, not the ASIC
#define EVN_IBM514_DAC_CUR  0x00000010  // Cursor handled by IBM DAC, not the ASIC
#define EVN_DENSE_CAPABLE   0x00000020  // Card is capable of using dense space
#define EVN_PACKED_IO       0x00000040  // Card uses packed I/O space
#define EVN_INT_DAC_CUR     0x00000080  /* Cards with internal DAC must use double buffer to avoid flickering cursor */
#define EVN_VT_ASIC         0x00000100  /* VT has extended capabilities our other cards don't */
#define EVN_GT_ASIC         0x00000200  /* GT has extended capabilities our other cards don't */
#define EVN_CT_ASIC         0x00000400  /* Identify CT ASIC */
/*
 * Cards with 1M of SDRAM need special handling (problem occurs on the
 * VTA4, may or may not happen with this configuration on future ASICs).
 */
#define EVN_SDRAM_1M        0x00000800


/*
 * Enhanced information structure for use with IOCTL_VIDEO_ATI_GET_VERSION.
 * This structure will be used if a non-null input buffer is passed when
 * making the call, and the older structure above will be used if a null
 * input buffer is passed.
 */
typedef struct{
    ULONG StructureVersion;     /* Revision of structure being passed in */
    ULONG InterfaceVersion;     /* Revision of private interface being used */
    ULONG ChipIndex;            /* Which accelerator chip is present */
    ULONG ChipFlag;             /* Flag corresponding to chip being used */
    ULONG ApertureType;         /* Best aperture type available */
    ULONG ApertureFlag;         /* Flag corresponding to aperture type */
    ULONG BusType;              /* Type of bus being used */
    ULONG BusFlag;              /* Flag corresponding to bus type */
    ULONG FeatureFlags;         /* Flags for features/bugs of this card */
    ULONG NumCards;             /* Number of ATI cards in the system */
    } ENH_VERSION_NT, *PENH_VERSION_NT;

/*
 * Values which can be placed in ModeFlags field of ATI_MODE_INFO.
 *
 * Flags should be added to this field if they represent bugs/features
 * which affect some but not all resolution/pixel depth combinations
 * on a given card.
 */
#define AMI_ODD_EVEN    0x00000001  // Hardware cursor odd/even bug, undefined
                                    // for cards without hardware cursor
#define AMI_MIN_MODE    0x00000002  // 8514/A compatible minimum mode
#define AMI_2M_BNDRY    0x00000004  // Tearing occurs on 2M boundary
#define AMI_BLOCK_WRITE 0x00000008  // Block write is supported. This is
                                    // mode-independent, but must be tested
                                    // after we have switched into graphics mode.
#define AMI_TEXTBAND    0x00000010  // Text banding in 24BPP mode

/*
 * Mode information structure for use with IOCTL_VIDEO_ATI_GET_MODE_INFORMATION.
 * This structure provides information specific to the video mode in use.
 */
typedef struct{
    ULONG ModeFlags;        /* Flags for features/bugs of this mode */

    LONG VisWidthPix;       /* Visible screen width in pixels */
    LONG VisWidthByte;      /* Visible screen width in bytes */
    LONG VisHeight;         /* Visible screen height */
    LONG BitsPerPixel;
    /*
     * The next 2 fields hold the number of bytes of memory used per pixel
     * (integer and fractional parts). A 4BPP unpacked (1 pixel per byte,
     * ignore unused 4 bits) mode would yield 1 and 0, the same as for 8BPP
     * (1.0 bytes per pixel). A 4BPP packed (2 pixels per byte) mode would
     * yield 0 and 500 (0.500 bytes per pixel). The fractional field will
     * always hold a 3-digit number, since bytes per pixel will always be
     * a multiple of 0.125 (one bit is one-eighth of a byte).
     */
    LONG IntBytesPerPixel;
    LONG FracBytesPerPixel;
    LONG PitchPix;          /* Screen pitch in pixels */
    LONG PitchByte;         /* Screen pitch in bytes */

    /*
     * The following fields refer to the offscreen block to the right of
     * the visible screen. This block is only present when the screen pitch
     * differs from the visible screen width. Its height is always the
     * same as the visible screen height, and its vertical start offset
     * is assumed to be zero.
     *
     * NOTE: If RightWidthPix is zero, this block does not exist for the
     *       current mode, and the other fields in this group are undefined.
     */
    LONG RightWidthPix;     /* Width of block in pixels */
    LONG RightWidthByte;    /* Width of block in bytes */
    LONG RightStartOffPix;  /* Horizontal start offset of block in pixels */
    LONG RightStartOffByte; /* Horizontal start offset of block in bytes */
    LONG RightEndOffPix;    /* Horizontal end offset of block in pixels */
    LONG RightEndOffByte;   /* Horizontal end offset of block in bytes */

    /*
     * The following fields refer to the offscreen block below the visible
     * screen. Values listed as "Hard" refer to the maximum vertical offset
     * for which enough video memory exists to support a full line of pixels.
     * Values listed as "Soft" refer to the maximum vertical offset which
     * can be reached without writing to the GE_OFFSET register.
     *
     * The horizontal start offset is assumed to be zero.
     */
    LONG BottomWidthPix;    /* Width of block in pixels */
    LONG BottomWidthByte;   /* Width of block in bytes */
    LONG BottomStartOff;    /* Vertical start offset of block */
    LONG BottomEndOffSoft;  /* "Soft" vertical end offset of block */
    LONG BottomEndOffHard;  /* "Hard" vertical end offset of block */
    LONG BottomHeightSoft;  /* "Soft" height of block */
    LONG BottomHeightHard;  /* "Hard" height of block */

    } ATI_MODE_INFO, *PATI_MODE_INFO;

//------------------------------------------------------------------------

/*
 * IOCTL codes to allow communication between the miniport driver
 * and higher-level modules. The Windows NT specification allocates
 * function codes 2048-4095 to external vendors.
 */
#define IOCTL_VIDEO_MIN_EXTERNAL_VENDOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAX_EXTERNAL_VENDOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 4095, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_GET_VERSION \
    CTL_CODE(FILE_DEVICE_VIDEO, 2048, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_EM_SYNC_TO_MINIPORT \
    CTL_CODE(FILE_DEVICE_VIDEO, 2049, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_EM_SYNC_FROM_MINIPORT \
    CTL_CODE(FILE_DEVICE_VIDEO, 2050, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ATI_GET_MODE_INFORMATION \
    CTL_CODE(FILE_DEVICE_VIDEO, 2051, METHOD_BUFFERED, FILE_ANY_ACCESS)


/*
 * The following definitions and IOCTLs are standard definitions from
 * the NTDDVDEO.H file in Daytona and later releases of Windows NT.
 * They are provided here to let earlier versions use the DPMS IOCTLs
 * without requiring source changes. Do not edit this section.
 *
 * Structures are made conditional on the absence of one of the
 * power management IOCTLs, rather than on the structure itself,
 * since "#if !defined(<symbol>)" doesn't trigger on symbols that
 * refer to structures, rather than numeric values.
 */

//
// IOCTL_VIDEO_SET_POWER_MANAGEMENT - Tells the device to change the power
//                                    consumption level of the device to the
//                                    new state.
// IOCTL_VIDEO_GET_POWER_MANAGEMENT - Return the current power consumption
//                                    level of the device.
//
// NOTE:
// This IOCTL is based on the VESA DPMS proposal.
// Changes to the DPMS standard will be refelcted in this IOCTL.
//

/*
#if !defined(IOCTL_VIDEO_SET_POWER_MANAGEMENT)
typedef enum _VIDEO_POWER_STATE {
    VideoPowerOn = 1,
    VideoPowerStandBy,
    VideoPowerSuspend,
    VideoPowerOff
} VIDEO_POWER_STATE, *PVIDEO_POWER_STATE;
#endif
*/
#if !defined(IOCTL_VIDEO_SET_POWER_MANAGEMENT)
typedef struct _VIDEO_POWER_MANAGEMENT {
    ULONG Length;
    ULONG DPMSVersion;
    ULONG PowerState;
} VIDEO_POWER_MANAGEMENT, *PVIDEO_POWER_MANAGEMENT;
#endif

//
//Length - Length of the structure in bytes. Also used to do verisioning.
//
//DPMSVersion - Version of the DPMS standard supported by the device.
//              Only used in the "GET" IOCTL.
//
//PowerState - One of the power states listed in VIDEO_POWER_STATE.
//

//
// Note:
// Once the power has been turned off to the device, all other IOCTLs made
// to the miniport will be intercepted by the port driver and will return
// failiure, until the power on the device has been turned back on.
//

/*
 * We use the presence or absence of various IOCTLs to determine
 * the build of Windows NT for which we are compiling the driver.
 * If this file is included, but the file which contains the IOCTLs
 * is not, in a source file, this will result in a false report of
 * the target build, which can cause numerous problems.
 *
 * This conditional block will force a compile error if the file
 * containing the IOCTLs (NTDDVDEO.H in NT 3.51 retail) was not
 * included prior to this file being included.
 */
#if !defined(IOCTL_VIDEO_SET_CURRENT_MODE)
    NTDDVDEO.H must be included before ATINT.H
#endif

#if defined(IOCTL_VIDEO_SET_POWER_MANAGEMENT)
/*
 * There are a number of non-DPMS features which differ between
 * Daytona and earlier versions of Windows NT. To make these
 * conditional compilations automatic, define the value "DAYTONA"
 * (formerly defined in SOURCES, and used to conditionally compile
 * the DPMS structures and IOCTLs) if IOCTL_VIDEO_SET_POWER_MANAGEMENT
 * is defined.
 */
#define DAYTONA 1
#define TARGET_BUILD 350
#else
#define TARGET_BUILD 310
#define IOCTL_VIDEO_SET_POWER_MANAGEMENT \
    CTL_CODE(FILE_DEVICE_VIDEO, 2052, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif
#if !defined(IOCTL_VIDEO_GET_POWER_MANAGEMENT)
#define IOCTL_VIDEO_GET_POWER_MANAGEMENT \
    CTL_CODE(FILE_DEVICE_VIDEO, 2053, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

/*
 * End of DPMS support for pre-Daytona versions of Windows NT.
 */

#define IOCTL_VIDEO_ATI_INIT_AUX_CARD \
    CTL_CODE(FILE_DEVICE_VIDEO, 2054, METHOD_BUFFERED, FILE_ANY_ACCESS)

/*
 * Structures used in DCI support. They were added some time after the
 * initial release of Windows NT 3.5, so we must make them available only
 * if they're not already defined. These "placeholders" are solely to
 * allow the miniport to be compiled - the packets will only be called
 * in later versions of Windows NT 3.5.
 *
 * There are no "placeholders" for the IOCTLs themselves, since their
 * presence or absence is used to determine whether or not to compile
 * the DCI cases in ATIMPStartIO().
 */
#if defined (IOCTL_VIDEO_SHARE_VIDEO_MEMORY)
#undef TARGET_BUILD
#define TARGET_BUILD 351
#else
typedef struct _VIDEO_SHARE_MEMORY_INFORMATION {
    ULONG SharedViewOffset;
    ULONG SharedViewSize;
    PVOID VirtualAddress;
} VIDEO_SHARE_MEMORY_INFORMATION, *PVIDEO_SHARE_MEMORY_INFORMATION;
#endif

#if !defined (IOCTL_VIDEO_SHARE_VIDEO_MEMORY)
typedef struct _VIDEO_SHARE_MEMORY {
    HANDLE ProcessHandle;
    ULONG ViewOffset;
    ULONG ViewSize;
    PVOID RequestedVirtualAddress;
} VIDEO_SHARE_MEMORY, *PVIDEO_SHARE_MEMORY;
#endif

//
// New automatic definition added as of NT 4.0 - use it to check whether
// we are building under 3.51, 4.0, or 5.0.
//
#if (_WIN32_WINNT >= 0x400)
#undef TARGET_BUILD
#define TARGET_BUILD 400
#endif

#if (_WIN32_WINNT >= 0x500)
#undef TARGET_BUILD
#define TARGET_BUILD 500
#endif

/*
 * Keys to be used in DrvEscape() call to handle DPMS and other private
 * ATI functions. These keys fit into a large "hole" between
 * GETSETSCREENPARAMS (3072) and BEGIN_PATH (4096)
 */
#define ESC_SET_POWER_MANAGEMENT    4000
#define ESC_GET_NUM_CARDS           4001
#define ESC_GET_MODES               4002
#define ESC_GET_VGA_ENABLED         4003
#define ESC_SET_CURRENT_FULLSCREEN  4004

/*
 * Values to show whether or not a given function is supported by
 * the DrvEscape entry point.
 */
#define ESC_IS_SUPPORTED    0x00000001  /* Function is supported */
#define ESC_NOT_SUPPORTED   0xFFFFFFFF  /* Unsupported function called */
#define ESC_NOT_IMPLEMENTED 0x00000000  /* QUERYESCSUPPORT called for unimplemented function */



//*********************   end of ATINT.H   ****************************


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\8514a\disp\i386\strucs.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: strucs.inc
;
; Copyright (c) 1993-1994 Microsoft Corporation
;----------------------------------------------------------------------------;

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL          STRUC
ptl_x           DD      0
ptl_y           DD      0
POINTL          ENDS

;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL           STRUC
sizl_cx         DD      0
sizl_cy         DD      0
SIZEL           ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;

RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends

;-----------------------------------------------------------------------;
; Definition of the physical device data structure
;
; NOTE: Changes to this structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

PDEV                struc           ; /* pdev */
pdev_xOffset            dd  ?
pdev_yOffset            dd  ?
pdev_iBitmapFormat      dd  ?

pdev_ioCur_y            dd  ?
pdev_ioCur_x            dd  ?
pdev_ioDesty_axstp      dd  ?
pdev_ioDestx_diastp     dd  ?
pdev_ioErr_term         dd  ?
pdev_ioMaj_axis_pcnt    dd  ?
pdev_ioGp_stat_cmd      dd  ?
pdev_ioShort_stroke     dd  ?
pdev_ioBkgd_color       dd  ?
pdev_ioFrgd_color       dd  ?
pdev_ioWrt_mask         dd  ?
pdev_ioRd_mask          dd  ?
pdev_ioColor_cmp        dd  ?
pdev_ioBkgd_mix         dd  ?
pdev_ioFrgd_mix         dd  ?
pdev_ioMulti_function   dd  ?
pdev_ioPix_trans        dd  ?
PDEV                ends

;-----------------------------------------------------------------------;
; Definition of our realized brush structures.
;
; NOTE: Changes to these structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

RBRUSH              struc           ; /* rb, prb */
rb_fl                   dd  ?
rb_bTransparent         dd  ?
rb_pbe                  dd  ?
rb_ulForeColor          dd  ?
rb_ulBackColor          dd  ?
rb_ptlBrushOrg          db  (size POINTL) dup(?)
rb_aulPattern           dd  ?
RBRUSH              ends

BRUSHENTRY          struc           ; /* be, pbe */
be_prbVerify            dd  ?
be_x                    dd  ?
be_y                    dd  ?
BRUSHENTRY          ends

;-----------------------------------------------------------------------;
; Definitions for text output
;-----------------------------------------------------------------------;

GLYPHPOS    struc           ; /* gp */
gp_hg       dd      ?       ; hglyph (unused by vga)
gp_pgdf     dd      ?       ; glyphdef
gp_x        dd      ?       ; glyph x position
gp_y        dd      ?       ; glyph y position
GLYPHPOS    ends


GLYPHDEF struc              ; /* gdf */
gdf_pgb     dd      ?       ; points to GLYPHBITS
GLYPHDEF ends


GLYPHBITS struc             ; /* gb */
gb_x        dd      ?       ; glyph x offset
gb_y        dd      ?       ; glyph y offset
gb_cx       dd      ?       ; glyph width in pels
gb_cy       dd      ?       ; glyph height in pels
gb_aj       db      ?       ; glyph bit mask
GLYPHBITS ends

;-----------------------------------------------------------------------;
; Macro to do a simple RET, with no stack stuff, in a proc.
;-----------------------------------------------------------------------;

PLAIN_RET macro
        db      0c3h
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\bank.c ===
/******************************Module*Header*******************************\
* Module Name: bank.c
*
* Contains all the banking code for the display driver.
*
* It's helpful not to have to implement all the DDI drawing functionality
* in a driver (who wants to write the code to support true ROP4's with
* arbitrary sized patterns?).  Fortunately, we can punt to GDI for any
* drawing we don't want to do.  And if GDI can write directly on the frame
* buffer bits, performance won't even be toooo bad.
*
* NT's GDI can draw on any standard format frame buffer.  When the entire
* frame buffer can be mapped into main memory, it's very simple to set up:
* the display driver tells GDI the frame buffer format and location, and
* GDI can then just draw directly.
*
* When only one bank of the frame buffer can be mapped into main memory
* at one time (e.g., there is a moveable 64k aperture) things are not
* nearly so easy.  For every bank spanned by a drawing operation, we have
* to set the hardware to the bank, and call back to GDI.  We tell GDI
* to draw only on the mapped-in bank by mucking with the drawing call's
* CLIPOBJ.
*
* This module contains the code for doing all banking support.
*
* This code supports 8, 16 and 32bpp colour depths, arbitrary bank
* sizes, and handles 'broken rasters' (which happens when the bank size
* is not a multiple of the scan length; some scans will end up being
* split over two separate banks).
*
* Note:  If you mess with this code and break it, you can expect to get
*        random access violations on call-backs in internal GDI routines
*        that are very hard to debug.
*
* Copyright (c) 1993-1995 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

VOID vI32BankSelectMode(        // Note: If this function changes, must
PDEV*        ppdev,             //   change Asm routines!
BANKDATA*    pbd,
BANK_MODE    bankm)
{
    BYTE*   pjIoBase;

    if (bankm == BANK_ON)
    {
        // Make sure the processor's graphics engine is idle before we
        // start drawing.  See wait_for_idle_M8.

        pjIoBase = ppdev->pjIoBase;

        I32_CHECK_FIFO_SPACE(ppdev, pjIoBase, 16);

        do {} while (I32_IW(pjIoBase, EXT_GE_STATUS) & GE_ACTIVE);
    }
}

VOID vI32BankMap(
PDEV*       ppdev,
BANKDATA*   pbd,
LONG        iBank)
{
    I32_OW_DIRECT(ppdev->pjIoBase, 0x01CE, ((iBank & 0x0f) << 9) | 0xb2);
    I32_OW_DIRECT(ppdev->pjIoBase, 0x01CE, ((iBank & 0x30) << 4) | 0xae);
}

VOID vI32BankInitialize(
PDEV*       ppdev,
BANKDATA*   pbd)
{
}

////////////////////////////////////////////////////////////////////////////

VOID vM64BankSelectMode(        // Note: If this function changes, must
PDEV*        ppdev,             //   change Asm routines!
BANKDATA*    pbd,
BANK_MODE    bankm)
{
    BYTE*   pjMmBase;

    if (bankm == BANK_ON)
    {
        // Make sure the processor's graphics engine is idle before we
        // start drawing.  See wait_for_idle_M64.

        pjMmBase = ppdev->pjMmBase;

        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);

        do {} while (M64_ID(pjMmBase, GUI_STAT) & 1);
    }
}

VOID vM64BankMap(
PDEV*       ppdev,
BANKDATA*   pbd,
LONG        iBank)
{
    M64_OD_DIRECT(ppdev->pjMmBase, MEM_VGA_WP_SEL,
                                (iBank*2) | ((iBank*2 + 1) << 16));

    M64_OD_DIRECT(ppdev->pjMmBase, MEM_VGA_RP_SEL,
                                (iBank*2) | ((iBank*2 + 1) << 16));
}

VOID vM64BankInitialize(
PDEV*       ppdev,
BANKDATA*   pbd)
{
}

/******************************Public*Routine******************************\
* BOOL bEnableBanking
*
\**************************************************************************/

BOOL bEnableBanking(
PDEV*   ppdev)
{
    CLIPOBJ*            pcoBank;
    SURFOBJ*            psoBank;
    SIZEL               sizl;
    HSURF               hsurf;
    FNBANKINITIALIZE*   pfnBankInitialize;
    LONG                lDelta;
    LONG                cjBank;
    LONG                cPower2;

    // Create a temporary clip object that we'll use for the bank
    // when we're given a Null or DC_TRIVIAL clip object:

    pcoBank = EngCreateClip();
    if (pcoBank == NULL)
        goto ReturnFalse;

    // We break every per-bank GDI call-back into simple rectangles:

    pcoBank->iDComplexity = DC_RECT;
    pcoBank->fjOptions    = OC_BANK_CLIP;

    // Create a GDI surface that we'll wrap around our bank in
    // call-backs:

    sizl.cx = ppdev->cxMemory;
    sizl.cy = ppdev->cyMemory;

    hsurf = (HSURF) EngCreateBitmap(sizl,
                                    ppdev->lDelta,
                                    ppdev->iBitmapFormat,
                                    BMF_TOPDOWN,
                                    ppdev->pjScreen);

    // Note that we hook zero calls -- after all, the entire point
    // of all this is to have GDI do all the drawing on the bank.
    // Once we're done the association, we can leave the surface
    // permanently locked:

    if ((hsurf == 0)                                        ||
        (!EngAssociateSurface(hsurf, ppdev->hdevEng, 0))    ||
        (!(psoBank = EngLockSurface(hsurf))))
    {
        DISPDBG((0, "Failed wrapper surface creation"));

        EngDeleteSurface(hsurf);
        EngDeleteClip(pcoBank);

        goto ReturnFalse;
    }

    ppdev->hsurfPunt  = hsurf;      // Just for 24bpp mach32 with linear aperture
    ppdev->pcoBank    = pcoBank;
    ppdev->psoBank    = psoBank;
    ppdev->pvBankData = &ppdev->aulBankData[0];

    if ((ppdev->iMachType == MACH_MM_32) || (ppdev->iMachType == MACH_IO_32))
    {
        ppdev->bankmOnOverlapped = BANK_ON;
        ppdev->pfnBankMap        = vI32BankMap;
        ppdev->pfnBankSelectMode = vI32BankSelectMode;
        pfnBankInitialize        = vI32BankInitialize;
    }
    else
    {
        ppdev->bankmOnOverlapped = BANK_ON;
        ppdev->pfnBankMap        = vM64BankMap;
        ppdev->pfnBankSelectMode = vM64BankSelectMode;
        pfnBankInitialize        = vM64BankInitialize;
    }

#if !defined(ALPHA)
    // For mach8, we only need the psoBank and function pointers
    // initialized.  Because cjBank will be zero, if we continue
    // we will be in trouble.
    if (ppdev->iAperture == APERTURE_NONE)
       return TRUE;
#endif

    lDelta = ppdev->lDelta;
    cjBank = ppdev->cjBank;

    ASSERTDD(lDelta > 0, "Bad things happen with negative lDeltas");
    ASSERTDD(cjBank > lDelta, "Worse things happen with bad bank sizes");

    if (((lDelta & (lDelta - 1)) != 0) || ((cjBank & (cjBank - 1)) != 0))
    {
        // When either the screen stride or the bank size is not a power
        // of two, we have to use the slower 'bBankComputeNonPower2'
        // function for bank calculations, 'cause there can be broken
        // rasters and stuff:

        ppdev->pfnBankCompute = bBankComputeNonPower2;
    }
    else
    {
        // We can use the super duper fast bank calculator.  Yippie,
        // yahoo!  (I am easily amused.)

        cPower2 = 0;
        while (cjBank != lDelta)
        {
            cjBank >>= 1;
            cPower2++;
        }

        // We've just calculated that cjBank / lDelta = 2 ^ cPower2:

        ppdev->cPower2ScansPerBank = cPower2;

        while (cjBank != 1)
        {
            cjBank >>= 1;
            cPower2++;
        }

        // Continuing on, we've calculated that cjBank = 2 ^ cPower2:

        ppdev->cPower2BankSizeInBytes = cPower2;

        ppdev->pfnBankCompute = bBankComputePower2;
    }

    // Warm up the hardware:

    pfnBankInitialize(ppdev, ppdev->pvBankData);
    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ENABLE);

    DISPDBG((5, "Passed bEnableBanking"));

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bEnableBanking!"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDisableBanking
*
\**************************************************************************/

VOID vDisableBanking(PDEV* ppdev)
{
    HSURF hsurf;

    if (ppdev->psoBank != NULL)
    {
        hsurf = ppdev->psoBank->hsurf;
        EngUnlockSurface(ppdev->psoBank);
        EngDeleteSurface(hsurf);
    }

    if (ppdev->pcoBank != NULL)
        EngDeleteClip(ppdev->pcoBank);
}

/******************************Public*Routine******************************\
* VOID vAssertModeBanking
*
\**************************************************************************/

VOID vAssertModeBanking(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Inform the miniport bank code about the change in state:

    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData,
                             bEnable ? BANK_ENABLE : BANK_DISABLE);
}

/******************************Public*Routine******************************\
* BOOL bBankComputeNonPower2
*
* Given the bounds of the drawing operation described by 'prclDraw',
* computes the bank number and rectangle bounds for the first engine
* call back.
*
* Returns the bank number, 'prclBank' is the bounds for the first
* call-back, and 'pcjOffset' is the adjustment for 'pvScan0'.
*
* This routine does a couple of divides for the bank calculation.  We
* don't use a look-up table for banks because it's not straight forward
* to use with broken rasters, and with large amounts of video memory
* and small banks, the tables could get large.  We'd probably use it
* infrequently enough that the memory manager would be swapping it
* in and out whenever we touched it.
*
* Returns TRUE if prclDraw is entirely contained in one bank; FALSE if
* prclDraw spans multiple banks.
*
\**************************************************************************/

BOOL bBankComputeNonPower2( // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG cjBufferOffset;
    LONG iBank;
    LONG cjBank;
    LONG cjBankOffset;
    LONG cjBankRemainder;
    LONG cjScan;
    LONG cScansInBank;
    LONG cjScanRemainder;
    LONG lDelta;
    BOOL bOneBank;

    bOneBank = FALSE;
    lDelta   = ppdev->lDelta;

    cjBufferOffset  = prclDraw->top * lDelta
                    + (prclDraw->left * ppdev->cjPelSize);

    cjBank          = ppdev->cjBank;

    // iBank        = cjBufferOffset / cjBank;
    // cjBankOffset = cjBufferOffset % cjBank;

    QUOTIENT_REMAINDER(cjBufferOffset, cjBank, iBank, cjBankOffset);

    *piBank         = iBank;
    *pcjOffset      = iBank * cjBank;
    cjBankRemainder = cjBank - cjBankOffset;
    cjScan          = (prclDraw->right - prclDraw->left) * ppdev->cjPelSize;

    if (cjBankRemainder < cjScan)
    {
        // Oh no, we've got a broken raster!

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->left +
                           (cjBankRemainder / ppdev->cjPelSize);
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + 1;
    }
    else
    {
        // cScansInBank    = cjBankRemainder / lDelta;
        // cjScanRemainder = cjBankRemainder % lDelta;

        ASSERTDD(lDelta > 0, "We assume positive lDelta here");

        QUOTIENT_REMAINDER(cjBankRemainder, lDelta,
                           cScansInBank, cjScanRemainder);

        if (cjScanRemainder >= cjScan)
        {
            // The bottom scan of the bank may be broken, but it breaks after
            // any drawing we'll be doing on that scan.  So we can simply
            // add the scan to this bank:

            cScansInBank++;
        }

        prclBank->left   = prclDraw->left;
        prclBank->right  = prclDraw->right;
        prclBank->top    = prclDraw->top;
        prclBank->bottom = prclDraw->top + cScansInBank;

        if (prclBank->bottom >= prclDraw->bottom)
        {
            prclBank->bottom  = prclDraw->bottom;
            bOneBank          = TRUE;
        }
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* BOOL bBankComputePower2
*
* Functions the same as 'bBankComputeNonPower2', except that it is
* an accelerated special case for when both the screen stride and bank
* size are powers of 2.
*
\**************************************************************************/

BOOL bBankComputePower2(    // Type FNBANKCOMPUTE
PDEV*       ppdev,
RECTL*      prclDraw,       // Extents of drawing operation, in absolute
                            //  coordinates
RECTL*      prclBank,       // Returns bounds of drawing operation for this
                            //  bank, in absolute coordinates
LONG*       pcjOffset,      // Returns the byte offset for this bank
LONG*       piBank)         // Returns the bank number
{
    LONG iBank;
    LONG yTopNextBank;
    BOOL bOneBank;

    iBank        = prclDraw->top >> ppdev->cPower2ScansPerBank;
    yTopNextBank = (iBank + 1) << ppdev->cPower2ScansPerBank;
    *piBank      = iBank;
    *pcjOffset   = iBank << ppdev->cPower2BankSizeInBytes;

    prclBank->left   = prclDraw->left;
    prclBank->right  = prclDraw->right;
    prclBank->top    = prclDraw->top;
    prclBank->bottom = yTopNextBank;

    bOneBank = FALSE;
    if (prclBank->bottom >= prclDraw->bottom)
    {
        prclBank->bottom  = prclDraw->bottom;
        bOneBank          = TRUE;
    }

    return(bOneBank);
}

/******************************Public*Routine******************************\
* VOID vBankStart
*
* Given the bounds of the drawing operation described by 'prclDraw' and
* the original clip object, maps in the first bank and returns in
* 'pbnk->pco' and 'pbnk->pso' the CLIPOBJ and SURFOBJ to be passed to the
* engine for the first banked call-back.
*
* Note: This routine only supports the screen being the destination, and
*       not the source.  We have a separate, faster routine for doing
*       SRCCOPY reads from the screen, so it isn't worth the extra code
*       size to implement.
*
\**************************************************************************/

VOID vBankStart(
PDEV*       ppdev,      // Physical device information.
RECTL*      prclDraw,   // Rectangle bounding the draw area, in relative
                        //  coordinates.  Note that 'left' and 'right'
                        //  should be set for correct handling with broken
                        //  rasters.
CLIPOBJ*    pco,        // Original drawing clip object (may be modified).
BANK*       pbnk)       // Resulting bank information.
{
    LONG cjOffset;
    LONG xOffset;
    LONG yOffset;

    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pco = ppdev->pcoBank;

        // Reset the clipping flag to trivial because we may have left
        // it as rectangular in a previous call:

        pco->iDComplexity = DC_TRIVIAL;

        // At the same time we convert to absolute coordinates, make sure
        // we won't try to enumerate past the bounds of the screen:

        pbnk->rclDraw.left       = prclDraw->left   + xOffset;
        pbnk->rclDraw.right      = prclDraw->right  + xOffset;

        pbnk->rclDraw.top
            = max(0,               prclDraw->top    + yOffset);
        pbnk->rclDraw.bottom
            = min(ppdev->cyMemory, prclDraw->bottom + yOffset);
    }
    else
    {
        pbnk->rclSaveBounds    = pco->rclBounds;
        pbnk->iSaveDComplexity = pco->iDComplexity;
        pbnk->fjSaveOptions    = pco->fjOptions;

        // Let GDI know that it has to pay attention to the clip object:

        pco->fjOptions |= OC_BANK_CLIP;

        // We have to honour the original clip object's rclBounds, so
        // intersect the drawing region with it, then convert to absolute
        // coordinates:

        pbnk->rclDraw.left
            = max(prclDraw->left,   pco->rclBounds.left)   + xOffset;
        pbnk->rclDraw.right
            = min(prclDraw->right,  pco->rclBounds.right)  + xOffset;
        pbnk->rclDraw.top
            = max(prclDraw->top,    pco->rclBounds.top)    + yOffset;
        pbnk->rclDraw.bottom
            = min(prclDraw->bottom, pco->rclBounds.bottom) + yOffset;
    }

    if ((pbnk->rclDraw.left > pbnk->rclDraw.right)
     || (pbnk->rclDraw.top  > pbnk->rclDraw.bottom))
    {
        // It's conceivable that we could get a situation where we have
        // an empty draw rectangle.  Make sure we won't puke on our shoes:

        pbnk->rclDraw.left   = 0;
        pbnk->rclDraw.right  = 0;
        pbnk->rclDraw.top    = 0;
        pbnk->rclDraw.bottom = 0;
    }

    if (!ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                               &cjOffset, &pbnk->iBank))
    {
        // The drawing operation spans multiple banks.  If the original
        // clip object was marked as trivial, we have to make sure to
        // change it to rectangular so that GDI knows to pay attention
        // to the bounds of the bank:

        if (pco->iDComplexity == DC_TRIVIAL)
            pco->iDComplexity = DC_RECT;
    }

    pbnk->ppdev = ppdev;
    pbnk->pco   = pco;
    pbnk->pso   = ppdev->psoBank;

    // Convert rclBounds and pvScan0 from absolute coordinates back to
    // relative.  When GDI calculates where to start drawing, it computes
    // pjDst = pso->pvScan0 + y * pso->lDelta + (x * cjPelSize), where 'x'
    // and 'y' are relative coordinates.  We'll muck with pvScan0 to get
    // it pointing to the correct spot in the bank:

    pbnk->pso->pvScan0 = ppdev->pjScreen - cjOffset
                       + yOffset * ppdev->lDelta
                       + (xOffset * ppdev->cjPelSize);

    pbnk->pso->lDelta = ppdev->lDelta;  // Other functions muck with this value

    ASSERTDD((((ULONG_PTR) pbnk->pso->pvScan0) & 3) == 0,
             "Off-screen bitmaps must be dword aligned");

    pco->rclBounds.left   -= xOffset;
    pco->rclBounds.right  -= xOffset;
    pco->rclBounds.top    -= yOffset;
    pco->rclBounds.bottom -= yOffset;

    // Enable banking and map in bank iBank:

    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ON);
    ppdev->pfnBankMap(ppdev, ppdev->pvBankData, pbnk->iBank);
}

/******************************Public*Routine******************************\
* BOOL bBankEnum
*
* If there is another bank to be drawn on, maps in the bank and returns
* TRUE and the CLIPOBJ and SURFOBJ to be passed in the banked call-back.
*
* If there were no more banks to be drawn, returns FALSE.
*
\**************************************************************************/

BOOL bBankEnum(
BANK* pbnk)
{
    LONG     iBank;
    LONG     cjOffset;
    PDEV*    ppdev;
    CLIPOBJ* pco;
    LONG     xOffset;
    LONG     yOffset;

    ppdev   = pbnk->ppdev;
    pco     = pbnk->pco;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;

    // We check here to see if we have to handle the second part of
    // a broken raster.  Recall that pbnk->rclDraw is in absolute
    // coordinates, but pco->rclBounds is in relative coordinates:

    if (pbnk->rclDraw.right - xOffset != pco->rclBounds.right)
    {
        // The clip object's 'top' and 'bottom' are already correct:

        pco->rclBounds.left  = pco->rclBounds.right;
        pco->rclBounds.right = pbnk->rclDraw.right - xOffset;

        pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;
        pbnk->iBank++;

        ppdev->pfnBankMap(ppdev, ppdev->pvBankData, pbnk->iBank);

        return(TRUE);
    }

    if (pbnk->rclDraw.bottom > pco->rclBounds.bottom + yOffset)
    {
        // Advance the drawing area 'top' to account for the bank we've
        // just finished, and map in the new bank:

        pbnk->rclDraw.top = pco->rclBounds.bottom + yOffset;

        ppdev->pfnBankCompute(ppdev, &pbnk->rclDraw, &pco->rclBounds,
                              &cjOffset, &iBank);

        // Convert rclBounds back from absolute to relative coordinates:

        pco->rclBounds.left   -= xOffset;
        pco->rclBounds.right  -= xOffset;
        pco->rclBounds.top    -= yOffset;
        pco->rclBounds.bottom -= yOffset;

        // If we just finished handling a broken raster, we've already
        // got the bank mapped in:

        if (iBank != pbnk->iBank)
        {
            pbnk->iBank = iBank;
            pbnk->pso->pvScan0 = (BYTE*) pbnk->pso->pvScan0 - ppdev->cjBank;

            ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);
        }

        return(TRUE);
    }

    // We're done!  Turn off banking and reset the clip object if necessary:

    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

    if (pco != ppdev->pcoBank)
    {
        pco->rclBounds    = pbnk->rclSaveBounds;
        pco->iDComplexity = pbnk->iSaveDComplexity;
        pco->fjOptions    = pbnk->fjSaveOptions;
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vAlignedCopy
*
* Copies the given portion of a bitmap, using dword alignment for the
* screen.  Note that this routine has no notion of banking.
*
* Updates ppjDst and ppjSrc to point to the beginning of the next scan.
*
\**************************************************************************/

VOID vAlignedCopy(
PDEV*   ppdev,
BYTE**  ppjDst,
LONG    lDstDelta,
BYTE**  ppjSrc,
LONG    lSrcDelta,
LONG    cjScan,
LONG    cyScan,
BOOL    bDstIsScreen)
{
    BYTE* pjDst;
    BYTE* pjSrc;
    LONG  cjMiddle;
    LONG  culMiddle;
    LONG  cjStartPhase;
    LONG  cjEndPhase;

    pjSrc = *ppjSrc;
    pjDst = *ppjDst;

    cjStartPhase = (LONG)(0 - ((bDstIsScreen) ? (ULONG_PTR) pjDst
                                              : (ULONG_PTR) pjSrc)) & 3;
    cjMiddle     = cjScan - cjStartPhase;

    if (cjMiddle < 0)
    {
        cjStartPhase = 0;
        cjMiddle     = cjScan;
    }

    lSrcDelta -= cjScan;
    lDstDelta -= cjScan;            // Account for middle

    cjEndPhase = cjMiddle & 3;
    culMiddle  = cjMiddle >> 2;

    if (DIRECT_ACCESS(ppdev))
    {
        LONG i;

        ///////////////////////////////////////////////////////////////////
        // Portable bus-aligned copy
        //
        // 'memcpy' usually aligns to the destination, so we could call
        // it for that case, but unfortunately we can't be sure.  We
        // always want to align to the frame buffer:

        CP_MEMORY_BARRIER();

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG*) pjDst) = *((ULONG UNALIGNED *) pjSrc);
                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    *((ULONG UNALIGNED *) pjDst) = *((ULONG*) (pjSrc));

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst++ = *pjSrc++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }
    else
    {
        LONG i;

        ///////////////////////////////////////////////////////////////////
        // No direct dword reads bus-aligned copy
        //
        // Because we support the ATI on ancient Jensen Alpha's, we also
        // have to support a sparse view of the frame buffer -- which
        // means using the 'ioaccess.h' macros.
        //
        // We also go through this code path if doing dword reads would
        // crash a non-x86 system.

        MEMORY_BARRIER();

        if (bDstIsScreen)
        {
            // Align to the destination (implying that the source may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    WRITE_REGISTER_ULONG(pjDst, *((ULONG UNALIGNED *) pjSrc));
                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    WRITE_REGISTER_UCHAR(pjDst, *pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }
        else
        {
            // Align to the source (implying that the destination may be
            // unaligned):

            for (; cyScan > 0; cyScan--)
            {
                for (i = cjStartPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                for (i = culMiddle; i > 0; i--)
                {
                    // There are some board 864/964 boards where we can't
                    // do dword reads from the frame buffer without
                    // crashing the system.

                    *((ULONG UNALIGNED *) pjDst) =
                     ((ULONG) READ_REGISTER_UCHAR(pjSrc + 3) << 24) |
                     ((ULONG) READ_REGISTER_UCHAR(pjSrc + 2) << 16) |
                     ((ULONG) READ_REGISTER_UCHAR(pjSrc + 1) << 8)  |
                     ((ULONG) READ_REGISTER_UCHAR(pjSrc));

                    pjSrc += sizeof(ULONG);
                    pjDst += sizeof(ULONG);
                }

                for (i = cjEndPhase; i > 0; i--)
                {
                    *pjDst = READ_REGISTER_UCHAR(pjSrc);
                    pjSrc++;
                    pjDst++;
                }

                pjSrc += lSrcDelta;
                pjDst += lDstDelta;
            }
        }

        *ppjSrc = pjSrc;            // Save the updated pointers
        *ppjDst = pjDst;
    }
}

/******************************Public*Routine******************************\
* VOID vPutBits
*
* Copies the bits from the given surface to the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vPutBits(
PDEV*       ppdev,
SURFOBJ*    psoSrc,
RECTL*      prclDst,            // Absolute coordinates!
POINTL*     pptlSrc)            // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    // We need a local copy of 'rclDraw' because we'll be iteratively
    // modifying 'top' and passing the modified rectangle back into
    // bBankComputeNonPower2:

    rclDraw = *prclDst;

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank:

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ON);
    ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lDstDelta = ppdev->lDelta;
    pjDst     = ppdev->pjScreen + rclDraw.top  * lDstDelta
                                + (rclDraw.left * ppdev->cjPelSize)
                                - cjOffset;

    lSrcDelta = psoSrc->lDelta;
    pjSrc     = (BYTE*) psoSrc->pvScan0 + pptlSrc->y * lSrcDelta
                                        + (pptlSrc->x * ppdev->cjPelSize);

    while (TRUE)
    {
        cjScan = (rclBank.right  - rclBank.left) * ppdev->cjPelSize;
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     TRUE);             // Screen is the destination

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;

            ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = (rclDraw.right - rclBank.right) * ppdev->cjPelSize;

            // Account for the fact that we're now one bank lower in the
            // destination:

            pjDst -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan:

            if (DIRECT_ACCESS(ppdev))
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(ppdev, &pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             TRUE);    // Screen is the destination
            }
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjDst -= ppdev->cjBank;
                iBank = iNewBank;

                ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

            return;
        }
    }
}

/******************************Public*Routine******************************\
* VOID vGetBits
*
* Copies the bits to the given surface from the screen, using the memory
* aperture.  Must be pre-clipped.
*
\**************************************************************************/

VOID vGetBits(
PDEV*       ppdev,
SURFOBJ*    psoDst,
RECTL*      prclDst,        // Absolute coordinates!
POINTL*     pptlSrc)        // Absolute coordinates!
{
    RECTL   rclDraw;
    RECTL   rclBank;
    LONG    iBank;
    LONG    cjOffset;
    LONG    cyScan;
    LONG    lDstDelta;
    LONG    lSrcDelta;
    BYTE*   pjDst;
    BYTE*   pjSrc;
    LONG    cjScan;
    LONG    iNewBank;
    LONG    cjRemainder;

    rclDraw.left   = pptlSrc->x;
    rclDraw.top    = pptlSrc->y;
    rclDraw.right  = rclDraw.left + (prclDst->right  - prclDst->left);
    rclDraw.bottom = rclDraw.top  + (prclDst->bottom - prclDst->top);

    ASSERTDD((rclDraw.left   >= 0) &&
             (rclDraw.top    >= 0) &&
             (rclDraw.right  <= ppdev->cxMemory) &&
             (rclDraw.bottom <= ppdev->cyMemory),
             "Rectangle wasn't fully clipped");

    // Compute the first bank, enable banking, then map in iBank.

    ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset, &iBank);
    ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_ON);
    ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

    // Calculate the pointer to the upper-left corner of both rectangles:

    lSrcDelta = ppdev->lDelta;
    pjSrc     = ppdev->pjScreen + rclDraw.top  * lSrcDelta
                                + (rclDraw.left * ppdev->cjPelSize)
                                - cjOffset;

    lDstDelta = psoDst->lDelta;
    pjDst     = (BYTE*) psoDst->pvScan0 + prclDst->top  * lDstDelta
                                        + (prclDst->left * ppdev->cjPelSize);

    while (TRUE)
    {
        cjScan = (rclBank.right  - rclBank.left) * ppdev->cjPelSize;
        cyScan = (rclBank.bottom - rclBank.top);

        vAlignedCopy(ppdev, &pjDst, lDstDelta, &pjSrc, lSrcDelta, cjScan, cyScan,
                     FALSE);            // Screen is the source

        if (rclDraw.right != rclBank.right)
        {
            // Handle the second part of the broken raster:

            iBank++;

            ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);

            // Number of bytes we've yet to do on the broken scan:

            cjRemainder = (rclDraw.right - rclBank.right) * ppdev->cjPelSize;

            // Account for the fact that we're now one bank lower in the
            // source:

            pjSrc -= ppdev->cjBank;

            // Implicitly back up the source and destination pointers to the
            // unfinished portion of the scan.  Note that we don't have to
            // advance the pointers because they're already pointing to the
            // beginning of the next scan:

            if (DIRECT_ACCESS(ppdev))
            {
                memcpy(pjDst + (cjScan - lDstDelta),
                       pjSrc + (cjScan - lSrcDelta),
                       cjRemainder);
            }
            else
            {
                BYTE* pjTmpDst = pjDst + (cjScan - lDstDelta);
                BYTE* pjTmpSrc = pjSrc + (cjScan - lSrcDelta);

                vAlignedCopy(ppdev, &pjTmpDst, 0, &pjTmpSrc, 0, cjRemainder, 1,
                             FALSE);    // Screen is the source
            }
        }

        if (rclDraw.bottom > rclBank.bottom)
        {
            rclDraw.top = rclBank.bottom;
            ppdev->pfnBankCompute(ppdev, &rclDraw, &rclBank, &cjOffset,
                                  &iNewBank);

            // If we just handled the second part of a broken raster,
            // then we've already got the bank correctly mapped in:

            if (iNewBank != iBank)
            {
                pjSrc -= ppdev->cjBank;
                iBank = iNewBank;

                ppdev->pfnBankMap(ppdev, ppdev->pvBankData, iBank);
            }
        }
        else
        {
            // We're done!  Turn off banking and leave:

            ppdev->pfnBankSelectMode(ppdev, ppdev->pvBankData, BANK_OFF);

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\bltm32.c ===
/******************************Module*Header*******************************\
* Module Name: bltm32.c
*
* Contains the low-level memory-mapped I/O blt functions for the Mach32.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vM32FillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vM32FillSolid(             // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    x;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);

    M32_OW(pjMmBase, FRGD_COLOR, rbc.iSolidColor);
    M32_OW(pjMmBase, ALU_FG_FN,  gaul32HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M32_OW(pjMmBase, DP_CONFIG,  FG_COLOR_SRC_FG | WRITE | DRAW);

    while (TRUE)
    {
        x = xOffset + prcl->left;
        M32_OW(pjMmBase, CUR_X,        x);
        M32_OW(pjMmBase, DEST_X_START, x);
        M32_OW(pjMmBase, DEST_X_END,   xOffset + prcl->right);
        M32_OW(pjMmBase, CUR_Y,        yOffset + prcl->top);

        vM32QuietDown(ppdev, pjMmBase);

        M32_OW(pjMmBase, DEST_Y_END,   yOffset + prcl->bottom);

        if (--c == 0)
            return;

        prcl++;
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
    }
}

/******************************Public*Routine******************************\
* VOID vM32FillPatMonochrome
*
* This routine uses the pattern hardware to draw a monochrome patterned
* list of rectangles.
*
* See Blt_DS_P8x8_ENG_IO_66_D0 and Blt_DS_P8x8_ENG_IO_66_D1.
*
\**************************************************************************/

VOID vM32FillPatMonochrome(     // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwForeMix;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    xPattern;
    LONG    yPattern;
    LONG    xOld;
    LONG    yOld;
    LONG    iLeftShift;
    LONG    iRightShift;
    LONG    i;
    BYTE    j;
    LONG    xLeft;
    ULONG   aulTmp[2];
    WORD*   pwPattern;

    ASSERTDD(ppdev->iAsic == ASIC_68800_6 || ppdev->iAsic == ASIC_68800AX,
             "Wrong ASIC type for monochrome 8x8 patterns");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    xPattern = (pptlBrush->x + xOffset) & 7;
    yPattern = (pptlBrush->y + yOffset) & 7;

    // If the alignment isn't correct, we'll have to change it:

    if ((xPattern != rbc.prb->ptlBrush.x) || (yPattern != rbc.prb->ptlBrush.y))
    {
        // Remember that we've changed the alignment on our cached brush:

        xOld = rbc.prb->ptlBrush.x;
        yOld = rbc.prb->ptlBrush.y;

        rbc.prb->ptlBrush.x = xPattern;
        rbc.prb->ptlBrush.y = yPattern;

        // Now do the alignment:

        yPattern    = (yOld - yPattern);
        iRightShift = (xPattern - xOld) & 7;
        iLeftShift  = 8 - iRightShift;

        pjSrc = (BYTE*) &rbc.prb->aulPattern[0];
        pjDst = (BYTE*) &aulTmp[0];

        for (i = 0; i < 8; i++)
        {
            j = *(pjSrc + (yPattern++ & 7));
            *pjDst++ = (j << iLeftShift) | (j >> iRightShift);
        }

        rbc.prb->aulPattern[0] = aulTmp[0];
        rbc.prb->aulPattern[1] = aulTmp[1];
    }

    ulHwForeMix = gaul32HwMixFromRop2[(rop4 >> 2) & 0xf];

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 16);
    M32_OW(pjMmBase, DP_CONFIG,   FG_COLOR_SRC_FG | EXT_MONO_SRC_PATT | DRAW |
                                  WRITE);
    M32_OW(pjMmBase, ALU_FG_FN,   ulHwForeMix);
    M32_OW(pjMmBase, ALU_BG_FN,   ((rop4 & 0xff00) == 0xaa00) ? LEAVE_ALONE
                                                              : ulHwForeMix);

    M32_OW(pjMmBase, FRGD_COLOR,      rbc.prb->ulForeColor);
    M32_OW(pjMmBase, BKGD_COLOR,      rbc.prb->ulBackColor);
    M32_OW(pjMmBase, PATT_LENGTH,     128);
    M32_OW(pjMmBase, PATT_DATA_INDEX, 16);

    pwPattern = (WORD*) &rbc.prb->aulPattern[0];
    M32_OW(pjMmBase, PATT_DATA, *(pwPattern));
    M32_OW(pjMmBase, PATT_DATA, *(pwPattern + 1));
    M32_OW(pjMmBase, PATT_DATA, *(pwPattern + 2));
    M32_OW(pjMmBase, PATT_DATA, *(pwPattern + 3));

    while(TRUE)
    {
        xLeft = xOffset + prcl->left;
        M32_OW(pjMmBase, CUR_X,        xLeft);
        M32_OW(pjMmBase, DEST_X_START, xLeft);
        M32_OW(pjMmBase, DEST_X_END,   xOffset + prcl->right);
        M32_OW(pjMmBase, CUR_Y,        yOffset + prcl->top);
        M32_OW(pjMmBase, DEST_Y_END,   yOffset + prcl->bottom);

        if (--c == 0)
            break;

        prcl++;
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 5);
    }
}

/******************************Public*Routine******************************\
* VOID vM32FillPatColor
*
* This routine uses the pattern hardware to draw a colour patterned list of
* rectangles.
*
* See Blt_DS_PCOL_ENG_IO_F0_D0 and Blt_DS_PCOL_ENG_IO_F0_D1.
*
\**************************************************************************/

VOID vM32FillPatColor(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cyVenetian;
    LONG    cyRoll;
    WORD*   pwPattern;
    LONG    xPattern;
    LONG    yPattern;

    ASSERTDD(ppdev->iBitmapFormat == BMF_8BPP,
             "Colour patterns work only at 8bpp");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    ulHwMix = gaul32HwMixFromRop2[(rop4 >> 2) & 0xf];

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
    M32_OW(pjMmBase, ALU_FG_FN,    ulHwMix);
    M32_OW(pjMmBase, SRC_Y_DIR,    1);
    M32_OW(pjMmBase, PATT_LENGTH,  7);          // 8 pixel wide pattern

    while (TRUE)
    {
        xLeft  = xOffset + prcl->left;
        xRight = xOffset + prcl->right;
        yTop   = yOffset + prcl->top;
        cy     = prcl->bottom - prcl->top;

        xPattern = (xLeft - pptlBrush->x - xOffset) & 7;
        yPattern = (yTop  - pptlBrush->y - yOffset) & 7;

        if (ulHwMix == OVERPAINT)
        {
            cyVenetian = min(cy, 8);
            cyRoll     = cy - cyVenetian;
        }
        else
        {
            cyVenetian = cy;
            cyRoll     = 0;
        }

        M32_OW(pjMmBase, DP_CONFIG,    FG_COLOR_SRC_PATT | DATA_WIDTH | DRAW | WRITE);
        M32_OW(pjMmBase, PATT_INDEX,   xPattern);
        M32_OW(pjMmBase, DEST_X_START, xLeft);
        M32_OW(pjMmBase, CUR_X,        xLeft);
        M32_OW(pjMmBase, DEST_X_END,   xRight);
        M32_OW(pjMmBase, CUR_Y,        yTop);

        do {
            // Each scan of the pattern is eight bytes:

            pwPattern = (WORD*) ((BYTE*) &rbc.prb->aulPattern[0]
                      + (yPattern << 3));
            yPattern  = (yPattern + 1) & 7;

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);
            M32_OW(pjMmBase, PATT_DATA_INDEX, 0);   // Reset index for download
            M32_OW(pjMmBase, PATT_DATA,  *(pwPattern));
            M32_OW(pjMmBase, PATT_DATA,  *(pwPattern + 1));
            M32_OW(pjMmBase, PATT_DATA,  *(pwPattern + 2));
            M32_OW(pjMmBase, PATT_DATA,  *(pwPattern + 3));
            yTop++;

            vM32QuietDown(ppdev, pjMmBase);

            M32_OW(pjMmBase, DEST_Y_END, yTop);

        } while (--cyVenetian != 0);

        if (cyRoll != 0)
        {
            // When the ROP is PATCOPY, we can take advantage of the fact
            // that we've just laid down an entire row of the pattern, and
            // can do a 'rolling' screen-to-screen blt to draw the rest:

            M32_CHECK_FIFO_SPACE(ppdev, pjMmBase,    7);
            M32_OW(pjMmBase, DP_CONFIG,       FG_COLOR_SRC_BLIT | DATA_WIDTH |
                                              DRAW | WRITE);
            M32_OW(pjMmBase, M32_SRC_X,       xLeft);
            M32_OW(pjMmBase, M32_SRC_X_START, xLeft);
            M32_OW(pjMmBase, M32_SRC_X_END,   xRight);
            M32_OW(pjMmBase, M32_SRC_Y,       yTop - 8);
            M32_OW(pjMmBase, CUR_Y,           yTop);

            vM32QuietDown(ppdev, pjMmBase);

            M32_OW(pjMmBase, DEST_Y_END,      yTop + cyRoll);
        }

        if (--c == 0)
            break;

        prcl++;
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);
    }
}

/******************************Public*Routine******************************\
* VOID vM32Xfer1bpp
*
* This routine colour expands a monochrome bitmap, possibly with different
* Rop2's for the foreground and background.  It will be called in the
* following cases:
*
* 1) To colour-expand the monochrome text buffer for the vFastText routine.
* 2) To blt a 1bpp source with a simple Rop2 between the source and
*    destination.
* 3) To blt a true Rop3 when the source is a 1bpp bitmap that expands to
*    white and black, and the pattern is a solid colour.
* 4) To handle a true Rop4 that works out to be Rop2's between the pattern
*    and destination.
*
* Needless to say, making this routine fast can leverage a lot of
* performance.
*
\**************************************************************************/

VOID vM32Xfer1bpp(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG*  pulXlate;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    LONG    culScan;
    LONG    lSrcSkip;
    ULONG*  pulSrc;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul32HwMixFromRop2[rop4 & 0xf];
    pulXlate    = pxlo->pulXlate;
    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 12);
    M32_OW(pjMmBase, DP_CONFIG, (WORD)(FG_COLOR_SRC_FG | BG_COLOR_SRC_BG | BIT16 |
                            EXT_MONO_SRC_HOST | DRAW | WRITE | LSB_FIRST) );
    M32_OW(pjMmBase, ALU_FG_FN, (WORD) ulHwForeMix );
    M32_OW(pjMmBase, ALU_BG_FN, (WORD) ulHwForeMix );
    M32_OW(pjMmBase, BKGD_COLOR, (WORD) pulXlate[0]);
    M32_OW(pjMmBase, FRGD_COLOR, (WORD) pulXlate[1]);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        // The Mach32 'bit packs' monochrome transfers, but GDI gives
        // us monochrome bitmaps whose scans are always dword aligned.
        // Consequently, we use the Mach32's clip registers to make
        // our transfers a multiple of 32 to match the dword alignment:

        M32_OW(pjMmBase, EXT_SCISSOR_L, (SHORT) (xLeft + xOffset) );
        M32_OW(pjMmBase, EXT_SCISSOR_R, (SHORT) (xRight + xOffset - 1) );

        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        xBias  = (xLeft + dx) & 31;             // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 31) & ~31;   // Ceiling

        M32_OW(pjMmBase, CUR_X,        (WORD) xLeft + xOffset );
        M32_OW(pjMmBase, DEST_X_START, (WORD) xLeft + xOffset );
        M32_OW(pjMmBase, DEST_X_END,   (WORD) (xLeft + xOffset + cx)  );
        M32_OW(pjMmBase, CUR_Y,        (WORD) yTop  + yOffset  );

        M32_OW(pjMmBase, DEST_Y_END, (WORD) (yTop + yOffset + cy) );

        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + ((xLeft + dx) >> 3));
        culScan  = cx >> 5;
        lSrcSkip = lSrcDelta - (culScan << 2);

        ASSERTDD(((ULONG_PTR)pulSrc & 3) == 0, "Source should be dword aligned");

        do {
            i = culScan;
            do {
                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
                M32_OW(pjMmBase, PIX_TRANS, *((USHORT*) pulSrc) );
                M32_OW(pjMmBase, PIX_TRANS, *((USHORT*) pulSrc + 1) );
                pulSrc++;

            } while (--i != 0);

            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

        } while (--cy != 0);

        if (--c == 0)
            break;

        prcl++;
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
    }

    // Don't forget to reset the clip register:

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    M32_OW(pjMmBase, EXT_SCISSOR_L, (SHORT) 0 );
    M32_OW(pjMmBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
}

/******************************Public*Routine******************************\
* VOID vM32XferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vM32XferNative(    // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    ULONG*  pulSrc;
    ULONG   culScan;
    LONG    lSrcSkip;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul32HwMixFromRop2[rop4 & 0xf];
    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);
    M32_OW(pjMmBase, DP_CONFIG, (WORD)(FG_COLOR_SRC_HOST | BIT16 |
                            DRAW | WRITE | LSB_FIRST) );
    M32_OW(pjMmBase, ALU_FG_FN, (WORD) ulHwForeMix );
    M32_OW(pjMmBase, ALU_BG_FN, (WORD) ulHwForeMix );

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        M32_OW(pjMmBase, EXT_SCISSOR_L, (SHORT) (xLeft + xOffset) );
        M32_OW(pjMmBase, EXT_SCISSOR_R, (SHORT) (xRight + xOffset - 1) );

        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        M32_OW(pjMmBase, CUR_X,        (WORD) xLeft + xOffset );
        M32_OW(pjMmBase, DEST_X_START, (WORD) xLeft + xOffset );
        M32_OW(pjMmBase, DEST_X_END,   (WORD) (xLeft + xOffset + cx)  );
        M32_OW(pjMmBase, CUR_Y,        (WORD) yTop  + yOffset  );

        M32_OW(pjMmBase, DEST_Y_END, (WORD) (yTop + yOffset + cy) );

        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + ((xLeft + dx) * ppdev->cjPelSize));
        culScan  = (cx * ppdev->cjPelSize) >> 2;
        lSrcSkip = lSrcDelta - (culScan << 2);

        ASSERTDD(((ULONG_PTR)pulSrc & 3) == 0, "Source should be dword aligned");

        do {
            i = culScan;
            do {
                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
                M32_OW(pjMmBase, PIX_TRANS, *((USHORT*) pulSrc) );
                M32_OW(pjMmBase, PIX_TRANS, *((USHORT*) pulSrc + 1) );
                pulSrc++;

            } while (--i != 0);

            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

        } while (--cy != 0);

        if (--c == 0)
            break;

        prcl++;
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
    }

    // Don't forget to reset the clip register:

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    M32_OW(pjMmBase, EXT_SCISSOR_L, (SHORT) 0 );
    M32_OW(pjMmBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
}

/******************************Public*Routine******************************\
* VOID vM32Xfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vM32Xfer4bpp(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    ULONG   ulHwForeMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    xBias;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    BYTE    jSrc;
    ULONG*  pulXlate;
    LONG    i;
    USHORT  uw;
    LONG    cjSrc;
    LONG    lSrcSkip;
    ULONG   ulFifo;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->iBitmapFormat != BMF_24BPP, "Can't handle 24bpp");

    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulFifo    = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ulHwForeMix = gaul32HwMixFromRop2[rop4 & 0xf];
    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);
    M32_OW(pjMmBase, DP_CONFIG, (WORD)(FG_COLOR_SRC_HOST | BIT16 |
                            DRAW | WRITE | LSB_FIRST) );
    M32_OW(pjMmBase, ALU_FG_FN, (WORD) ulHwForeMix );
    M32_OW(pjMmBase, ALU_BG_FN, (WORD) ulHwForeMix );


    while(TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        M32_OW(pjMmBase, EXT_SCISSOR_L, (SHORT) (xLeft + xOffset) );
        M32_OW(pjMmBase, EXT_SCISSOR_R, (SHORT) (xRight + xOffset - 1) );

        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        M32_OW(pjMmBase, CUR_X,        (WORD) xLeft + xOffset );
        M32_OW(pjMmBase, DEST_X_START, (WORD) xLeft + xOffset );
        M32_OW(pjMmBase, DEST_X_END,   (WORD) (xLeft + xOffset + cx)  );
        M32_OW(pjMmBase, CUR_Y,        (WORD) yTop  + yOffset  );

        M32_OW(pjMmBase, DEST_Y_END, (WORD) (yTop + yOffset + cy) );

        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta
                              + ((xLeft + dx) >> 1);
        cjSrc    = cx >> 1;         // Number of source bytes touched
        lSrcSkip = lSrcDelta - cjSrc;

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            do {
                i = cjSrc;
                do {
                    jSrc = *pjSrc++;
                    uw   = (USHORT) (pulXlate[jSrc >> 4]);
                    uw  |= (USHORT) (pulXlate[jSrc & 0xf] << 8);
                    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                    M32_OW(pjMmBase, PIX_TRANS, uw );
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            do {
                i = cjSrc;
                do {
                    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
                    jSrc = *pjSrc++;
                    uw   = (USHORT) (pulXlate[jSrc >> 4]);
                    M32_OW(pjMmBase, PIX_TRANS, uw );
                    uw   = (USHORT) (pulXlate[jSrc & 0xf]);
                    M32_OW(pjMmBase, PIX_TRANS, uw );
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
    }

    // Don't forget to reset the clip register:

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    M32_OW(pjMmBase, EXT_SCISSOR_L, (SHORT) 0 );
    M32_OW(pjMmBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
}

/******************************Public*Routine******************************\
* VOID vM32Xfer8bpp
*
* Does a 8bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 8bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vM32Xfer8bpp(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    ULONG   ulHwForeMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    xBias;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    ULONG*  pulXlate;
    LONG    i;
    USHORT  uw;
    LONG    cwSrc;
    LONG    cxRem;
    LONG    lSrcSkip;
    ULONG   ulFifo;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_8BPP, "Source must be 8bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->iBitmapFormat != BMF_24BPP, "Can't handle 24bpp");

    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulFifo    = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ulHwForeMix = gaul32HwMixFromRop2[rop4 & 0xf];
    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);
    M32_OW(pjMmBase, DP_CONFIG, (WORD)(FG_COLOR_SRC_HOST | BIT16 |
                            DRAW | WRITE | LSB_FIRST) );
    M32_OW(pjMmBase, ALU_FG_FN, (WORD) ulHwForeMix );
    M32_OW(pjMmBase, ALU_BG_FN, (WORD) ulHwForeMix );


    while(TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        M32_OW(pjMmBase, EXT_SCISSOR_L, (SHORT) (xLeft + xOffset) );
        M32_OW(pjMmBase, EXT_SCISSOR_R, (SHORT) (xRight + xOffset - 1) );

        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        M32_OW(pjMmBase, CUR_X,        (WORD) xLeft + xOffset );
        M32_OW(pjMmBase, DEST_X_START, (WORD) xLeft + xOffset );
        M32_OW(pjMmBase, DEST_X_END,   (WORD) (xLeft + xOffset + cx)  );
        M32_OW(pjMmBase, CUR_Y,        (WORD) yTop  + yOffset  );

        M32_OW(pjMmBase, DEST_Y_END, (WORD) (yTop + yOffset + cy) );

        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta
                              + (xLeft + dx);
        lSrcSkip = lSrcDelta - cx;

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            cwSrc = (cx >> 1);
            cxRem = (cx & 1);

            do {
                for (i = cwSrc; i != 0; i--)
                {
                    uw  = (USHORT) (pulXlate[*pjSrc++]);
                    uw |= (USHORT) (pulXlate[*pjSrc++] << 8);
                    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                    M32_OW(pjMmBase, PIX_TRANS, uw );
                }

                if (cxRem > 0)
                {
                    uw  = (USHORT) (pulXlate[*pjSrc++]);
                    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                    M32_OW(pjMmBase, PIX_TRANS, uw );
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            do {
                for (i = cx; i != 0; i--)
                {
                    uw  = (USHORT) (pulXlate[*pjSrc++]);
                    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 1);
                    M32_OW(pjMmBase, PIX_TRANS, uw );
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 7);
    }

    // Don't forget to reset the clip register:

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    M32_OW(pjMmBase, EXT_SCISSOR_L, (SHORT) 0 );
    M32_OW(pjMmBase, EXT_SCISSOR_R, (SHORT) M32_MAX_SCISSOR );
}

/******************************Public*Routine******************************\
* VOID vM32CopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
* See Blt_DS_SS_ENG_IO_D0 and Blt_DS_SS_TLBR_ENG_IO_D1.
*
\**************************************************************************/

VOID vM32CopyBlt(   // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xLeft;
    LONG    yTop;
    LONG    cx;
    LONG    cy;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 12);

    M32_OW(pjMmBase, DP_CONFIG, FG_COLOR_SRC_BLIT | DRAW | WRITE);
    M32_OW(pjMmBase, ALU_FG_FN, gaul32HwMixFromRop2[rop4 & 0xf]);

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
    {
        M32_OW(pjMmBase, SRC_Y_DIR, 1);
        goto Top_Down_Left_To_Right;
    }

    M32_OW(pjMmBase, SRC_Y_DIR, (prclDst->top <= pptlSrc->y));

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            while (TRUE)
            {
                xLeft = xOffset + prcl->left + dx;  // Destination coordinates
                yTop  = yOffset + prcl->top  + dy;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                M32_OW(pjMmBase, M32_SRC_X,        xLeft);
                M32_OW(pjMmBase, M32_SRC_X_START,  xLeft);
                M32_OW(pjMmBase, M32_SRC_X_END,    xLeft + cx);
                M32_OW(pjMmBase, M32_SRC_Y,        yTop);

                xLeft -= dx;                        // Source coordinates
                yTop  -= dy;

                M32_OW(pjMmBase, CUR_X,            xLeft);
                M32_OW(pjMmBase, DEST_X_START,     xLeft);
                M32_OW(pjMmBase, DEST_X_END,       xLeft + cx);
                M32_OW(pjMmBase, CUR_Y,            yTop);

                vM32QuietDown(ppdev, pjMmBase);

                M32_OW(pjMmBase, DEST_Y_END,       yTop + cy);

                if (--c == 0)
                    break;

                prcl++;
                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
            }
        }
        else
        {
            while (TRUE)
            {
                xLeft = xOffset + prcl->left + dx;  // Destination coordinates
                yTop  = yOffset + prcl->top  + dy;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                M32_OW(pjMmBase, M32_SRC_X,        xLeft + cx);
                M32_OW(pjMmBase, M32_SRC_X_START,  xLeft + cx);
                M32_OW(pjMmBase, M32_SRC_X_END,    xLeft);
                M32_OW(pjMmBase, M32_SRC_Y,        yTop);

                xLeft -= dx;                        // Source coordinates
                yTop  -= dy;

                M32_OW(pjMmBase, CUR_X,            xLeft + cx);
                M32_OW(pjMmBase, DEST_X_START,     xLeft + cx);
                M32_OW(pjMmBase, DEST_X_END,       xLeft);
                M32_OW(pjMmBase, CUR_Y,            yTop);

                vM32QuietDown(ppdev, pjMmBase);

                M32_OW(pjMmBase, DEST_Y_END,       yTop + cy);

                if (--c == 0)
                    break;

                prcl++;
                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
            }
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            while (TRUE)
            {
                xLeft = xOffset + prcl->left + dx;  // Destination coordinates
                yTop  = yOffset + prcl->top  + dy - 1;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                M32_OW(pjMmBase, M32_SRC_X,        xLeft);
                M32_OW(pjMmBase, M32_SRC_X_START,  xLeft);
                M32_OW(pjMmBase, M32_SRC_X_END,    xLeft + cx);
                M32_OW(pjMmBase, M32_SRC_Y,        yTop + cy);

                xLeft -= dx;                        // Source coordinates
                yTop  -= dy;

                M32_OW(pjMmBase, CUR_X,            xLeft);
                M32_OW(pjMmBase, DEST_X_START,     xLeft);
                M32_OW(pjMmBase, DEST_X_END,       xLeft + cx);
                M32_OW(pjMmBase, CUR_Y,            yTop + cy);

                vM32QuietDown(ppdev, pjMmBase);

                M32_OW(pjMmBase, DEST_Y_END,       yTop);

                if (--c == 0)
                    break;

                prcl++;
                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
            }
        }
        else
        {
            while (TRUE)
            {
                xLeft = xOffset + prcl->left + dx;  // Destination coordinates
                yTop  = yOffset + prcl->top  + dy - 1;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                M32_OW(pjMmBase, M32_SRC_X,        xLeft + cx);
                M32_OW(pjMmBase, M32_SRC_X_START,  xLeft + cx);
                M32_OW(pjMmBase, M32_SRC_X_END,    xLeft);
                M32_OW(pjMmBase, M32_SRC_Y,        yTop + cy);

                xLeft -= dx;                        // Source coordinates
                yTop  -= dy;

                M32_OW(pjMmBase, CUR_X,            xLeft + cx);
                M32_OW(pjMmBase, DEST_X_START,     xLeft + cx);
                M32_OW(pjMmBase, DEST_X_END,       xLeft);
                M32_OW(pjMmBase, CUR_Y,            yTop + cy);

                vM32QuietDown(ppdev, pjMmBase);

                M32_OW(pjMmBase, DEST_Y_END,       yTop);

                if (--c == 0)
                    break;

                prcl++;
                M32_CHECK_FIFO_SPACE(ppdev, pjMmBase, 9);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\bltm64-2.c ===
/******************************Module*Header*******************************\
* Module Name: bltm64.c
*
* Contains the low-level memory-mapped I/O blt functions for the Mach64.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vM64FillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vM64FillSolid2(             // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   mix;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    mix      = gaul64HwMixFromRop2[(rop4 >> 2) & 0xf];

    if (mix == 0x70000)
    {
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 5);
        M64_OD(pjMmBase, DP_SET_GUI_ENGINE, 0x20100000 | ppdev->SetGuiEngineDefault);
        M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);

        while (TRUE)
        {
            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(xOffset + prcl->left,
                                                           yOffset + prcl->top));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(prcl->right - prcl->left,
                                                           prcl->bottom - prcl->top));

            if (--c == 0)
                break;

            prcl++;
            M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 3);
        }

        M64_OD(pjMmBase, SRC_CNTL,    0);
    }
    else
    {
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 5);
        M64_OD(pjMmBase, DP_MIX,      mix);
        M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);
        M64_OD(pjMmBase, DP_SRC,      DP_SRC_FrgdClr << 8);

        while (TRUE)
        {
            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(xOffset + prcl->left,
                                                           yOffset + prcl->top));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(prcl->right - prcl->left,
                                                           prcl->bottom - prcl->top));

            if (--c == 0)
                break;

            prcl++;
            M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 2);
        }
    }
}

// Solid fill routines using block write.

VOID vM64FillSolidUMC(             // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    ULONG   mix;
    BOOL    FastFillFlag;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    mix      = gaul64HwMixFromRop2[(rop4 >> 2) & 0xf];

    if (mix == 0x70000)
    {
        FastFillFlag = FALSE;

        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 2);

        M64_OD(pjMmBase, DP_SET_GUI_ENGINE, 0x100000 | ppdev->SetGuiEngineDefault);
//        M64_OD(pjMmBase, DP_MIX, 0x70003);
        M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);
//        M64_OD(pjMmBase, DP_SRC, DP_SRC_FrgdClr << 8);

        while (TRUE)
        {
            if ((dx = prcl->right - prcl->left) > 32)
            {
                FastFillFlag = TRUE;

                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 6);

                M64_OD(pjMmBase, SRC_CNTL, SRC_CNTL_FastFillEna | SRC_CNTL_RegWriteEna);
                M64_OD(pjMmBase, DST_Y_X, 0x00000000);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, 0x00010001);
                M64_OD(pjMmBase, SRC_CNTL, SRC_CNTL_FastFillEna | SRC_CNTL_BlkWriteEna);
                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xOffset + prcl->left, yOffset + prcl->top));
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(dx, prcl->bottom - prcl->top));
            }
            else
            {
                if (FastFillFlag == TRUE)
                {
                    FastFillFlag = FALSE;
                    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 3);
                    M64_OD(pjMmBase, SRC_CNTL, 0);
                }
                else
                {
                    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 2);
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xOffset + prcl->left, yOffset + prcl->top));
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(dx, prcl->bottom - prcl->top));
            }

            if (--c == 0)
                break;

            prcl++;
        }

        if (FastFillFlag == TRUE)
        {
            M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 1);
            M64_OD(pjMmBase, SRC_CNTL, 0);
        }
    }
    else
    {
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 5);
        M64_OD(pjMmBase, DP_MIX,      mix);
        M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);
        M64_OD(pjMmBase, DP_SRC,      DP_SRC_FrgdClr << 8);

        while (TRUE)
        {
            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(xOffset + prcl->left,
                                                           yOffset + prcl->top));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(prcl->right - prcl->left,
                                                           prcl->bottom - prcl->top));

            if (--c == 0)
                break;

            prcl++;
            M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 2);
        }
    }
}

VOID vM64FillSolidUMC24(             // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx, x;
    ULONG   mix;
    BOOL    FastFillFlag;
    BYTE    red, green, blue;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    red   = (BYTE) ((rbc.iSolidColor & ppdev->flRed)   >> REDSHIFT);
    green = (BYTE) ((rbc.iSolidColor & ppdev->flGreen) >> GREENSHIFT);
    blue  = (BYTE) ((rbc.iSolidColor & ppdev->flBlue)  >> BLUESHIFT);

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    mix      = gaul64HwMixFromRop2[(rop4 >> 2) & 0xf];

    if (mix == 0x70000 && red == green && green == blue)
    {
        FastFillFlag = FALSE;

        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 3);

//        M64_OD(pjMmBase, DP_SET_GUI_ENGINE, 0x100000 | ppdev->SetGuiEngineDefault);
        M64_OD(pjMmBase, DP_MIX, 0x70003);
        M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);
        M64_OD(pjMmBase, DP_SRC, DP_SRC_FrgdClr << 8);

        while (TRUE)
        {
            x = (xOffset + prcl->left) * 3;

            if ((dx = (prcl->right - prcl->left)*3) > 96)
            {
                FastFillFlag = TRUE;

                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 6);

                M64_OD(pjMmBase, SRC_CNTL, SRC_CNTL_FastFillEna | SRC_CNTL_RegWriteEna);
                M64_OD(pjMmBase, DST_Y_X, 0x00000000);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, 0x00010001);
                M64_OD(pjMmBase, SRC_CNTL, SRC_CNTL_FastFillEna | SRC_CNTL_BlkWriteEna);
                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(x, yOffset + prcl->top));
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(dx, prcl->bottom - prcl->top));
            }
            else
            {
                if (FastFillFlag == TRUE)
                {
                    FastFillFlag = FALSE;
                    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 3);
                    M64_OD(pjMmBase, SRC_CNTL, 0);
                }
                else
                {
                    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 2);
                }

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(x, yOffset + prcl->top));
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(dx, prcl->bottom - prcl->top));
            }

            if (--c == 0)
                break;

            prcl++;
        }

        if (FastFillFlag == TRUE)
        {
            M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 1);
            M64_OD(pjMmBase, SRC_CNTL, 0);
        }
    }
    else
    {
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 7);
        M64_OD(pjMmBase, DP_MIX,      mix);
        M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);
        M64_OD(pjMmBase, DP_SRC,      DP_SRC_FrgdClr << 8);

        while (TRUE)
        {
            x = (xOffset + prcl->left) * 3;

            M64_OD(pjMmBase, DST_CNTL,         0x83 | ((x/4 % 6) << 8));
            M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x,
                                                           yOffset + prcl->top));
            M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST((prcl->right - prcl->left) * 3,
                                                           prcl->bottom - prcl->top));

            if (--c == 0)
                break;

            prcl++;
            M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 3);
        }

        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 1);
        M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    }
}

VOID vM64FillSolid24_2(           // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    x;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 7);
    M64_OD(pjMmBase, DP_MIX,      gaul64HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);
    M64_OD(pjMmBase, DP_SRC,      DP_SRC_FrgdClr << 8);

    while (TRUE)
    {
        x = (xOffset + prcl->left) * 3;

        M64_OD(pjMmBase, DST_CNTL,         0x83 | ((x/4 % 6) << 8));
        M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x,
                                                       yOffset + prcl->top));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST((prcl->right - prcl->left) * 3,
                                                       prcl->bottom - prcl->top));

        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 3);
    }

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
}

/******************************Public*Routine******************************\
* VOID vM64FillPatMonochrome
*
* This routine uses the pattern hardware to draw a monochrome patterned
* list of rectangles.
*
* See Blt_DS_P8x8_ENG_8G_D0 and Blt_DS_P8x8_ENG_8G_D1.
*
\**************************************************************************/

VOID vM64FillPatMonochrome2(     // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    xPattern;
    LONG    yPattern;
    LONG    iLeftShift;
    LONG    iRightShift;
    LONG    xOld;
    LONG    yOld;
    LONG    i;
    BYTE    j;
    ULONG   ulHwForeMix;
    ULONG   ulHwBackMix;
    LONG    xLeft;
    LONG    yTop;
    ULONG   aulTmp[2];

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    xPattern = (pptlBrush->x + xOffset) & 7;
    yPattern = (pptlBrush->y + yOffset) & 7;

    // If the alignment isn't correct, we'll have to change it:

    if ((xPattern != rbc.prb->ptlBrush.x) || (yPattern != rbc.prb->ptlBrush.y))
    {
        // Remember that we've changed the alignment on our cached brush:

        xOld = rbc.prb->ptlBrush.x;
        yOld = rbc.prb->ptlBrush.y;

        rbc.prb->ptlBrush.x = xPattern;
        rbc.prb->ptlBrush.y = yPattern;

        // Now do the alignment:

        yPattern    = (yOld - yPattern);
        iRightShift = (xPattern - xOld) & 7;
        iLeftShift  = 8 - iRightShift;

        pjSrc = (BYTE*) &rbc.prb->aulPattern[0];
        pjDst = (BYTE*) &aulTmp[0];

        for (i = 0; i < 8; i++)
        {
            j = *(pjSrc + (yPattern++ & 7));
            *pjDst++ = (j << iLeftShift) | (j >> iRightShift);
        }

        rbc.prb->aulPattern[0] = aulTmp[0];
        rbc.prb->aulPattern[1] = aulTmp[1];
    }

    ulHwForeMix = gaul64HwMixFromRop2[(rop4 >> 2) & 0xf];
    ulHwBackMix = ((rop4 & 0xff00) == 0xaa00) ? LEAVE_ALONE : (ulHwForeMix >> 16);

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 9);
    M64_OD(pjMmBase, PAT_CNTL, PAT_CNTL_MonoEna);
    M64_OD(pjMmBase, DP_SRC, DP_SRC_MonoPattern | DP_SRC_FrgdClr << 8);
    M64_OD(pjMmBase, DP_MIX, ulHwBackMix | ulHwForeMix);
    M64_OD(pjMmBase, DP_FRGD_CLR, rbc.prb->ulForeColor);
    M64_OD(pjMmBase, DP_BKGD_CLR, rbc.prb->ulBackColor);
    M64_OD(pjMmBase, PAT_REG0, rbc.prb->aulPattern[0]);
    M64_OD(pjMmBase, PAT_REG1, rbc.prb->aulPattern[1]);

    while(TRUE)
    {
        xLeft = prcl->left;
        yTop  = prcl->top;

        M64_OD(pjMmBase, DST_Y_X,          PACKXY(xLeft + xOffset,
                                                  yTop + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY(prcl->right - xLeft,
                                                  prcl->bottom - prcl->top));
        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 2);
    }
}

VOID vM64FillPatMonochrome24_2(   // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    xPattern;
    LONG    yPattern;
    LONG    iLeftShift;
    LONG    iRightShift;
    LONG    xOld;
    LONG    yOld;
    LONG    i;
    BYTE    j;
    ULONG   ulHwForeMix;
    ULONG   ulHwBackMix;
    LONG    xLeft;
    LONG    yTop;
    ULONG   aulTmp[2];
    LONG    x;

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    xPattern = (pptlBrush->x + xOffset) & 7;
    yPattern = (pptlBrush->y + yOffset) & 7;

    // If the alignment isn't correct, we'll have to change it:

    if ((xPattern != rbc.prb->ptlBrush.x) || (yPattern != rbc.prb->ptlBrush.y))
    {
        // Remember that we've changed the alignment on our cached brush:

        xOld = rbc.prb->ptlBrush.x;
        yOld = rbc.prb->ptlBrush.y;

        rbc.prb->ptlBrush.x = xPattern;
        rbc.prb->ptlBrush.y = yPattern;

        // Now do the alignment:

        yPattern    = (yOld - yPattern);
        iRightShift = (xPattern - xOld) & 7;
        iLeftShift  = 8 - iRightShift;

        pjSrc = (BYTE*) &rbc.prb->aulPattern[0];
        pjDst = (BYTE*) &aulTmp[0];

        for (i = 0; i < 8; i++)
        {
            j = *(pjSrc + (yPattern++ & 7));
            *pjDst++ = (j << iLeftShift) | (j >> iRightShift);
        }

        rbc.prb->aulPattern[0] = aulTmp[0];
        rbc.prb->aulPattern[1] = aulTmp[1];
    }

    ulHwForeMix = gaul64HwMixFromRop2[(rop4 >> 2) & 0xf];
    ulHwBackMix = ((rop4 & 0xff00) == 0xaa00) ? LEAVE_ALONE : (ulHwForeMix >> 16);

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 13);
    M64_OD(pjMmBase, PAT_CNTL, PAT_CNTL_MonoEna);
    M64_OD(pjMmBase, DP_SRC, DP_SRC_MonoPattern | DP_SRC_FrgdClr << 8);
    M64_OD(pjMmBase, DP_MIX, ulHwBackMix | ulHwForeMix);
    M64_OD(pjMmBase, DP_FRGD_CLR, rbc.prb->ulForeColor);
    M64_OD(pjMmBase, DP_BKGD_CLR, rbc.prb->ulBackColor);
    M64_OD(pjMmBase, PAT_REG0, rbc.prb->aulPattern[0]);
    M64_OD(pjMmBase, PAT_REG1, rbc.prb->aulPattern[1]);
    // You must turn off DP_BYTE_PIX_ORDER, or else the pattern is incorrectly
    // aligned.  This took a long time to figure out.
    M64_OD(pjMmBase, DP_PIX_WIDTH, 0x00000202);

    while(TRUE)
    {
        xLeft = prcl->left;
        yTop  = prcl->top;
        x     = (xLeft + xOffset) * 3;

        M64_OD(pjMmBase, DST_CNTL,         0x83 | ((x/4 % 6) << 8));
        M64_OD(pjMmBase, DST_Y_X,          PACKXY(x,
                                                  yTop + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY((prcl->right - xLeft) * 3,
                                                  prcl->bottom - prcl->top));
        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 3);
    }

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 2);
    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth);
}

/******************************Public*Routine******************************\
* VOID vM64FillPatColor
*
* This routine uses the pattern hardware to draw a patterned list of
* rectangles.
*
* See Blt_DS_PCOL_ENG_8G_D0 and Blt_DS_PCOL_ENG_8G_D1.
*
\**************************************************************************/

VOID vM64FillPatColor2(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BRUSHENTRY* pbe;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        yOffset;
    LONG        xLeft;
    LONG        yTop;
    LONG        dx, dy;

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 8);
    M64_OD(pjMmBase, DP_MIX,             gaul64HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,           SRC_CNTL_PatEna);
    M64_OD(pjMmBase, DP_SRC,             DP_SRC_Blit << 8);
    M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, PACKXY(8, 8));

    while (TRUE)
    {
        xLeft = prcl->left;
        yTop  = prcl->top;

        // Offsets into brush:
        dx  = (xLeft - pptlBrush->x) & 7;
        dy  = (yTop  - pptlBrush->y) & 7;

        // See if the brush has already been put into off-screen memory.
        // Also, if pre-rotation is required:

        pbe = rbc.prb->apbe[IBOARD(ppdev)];
        if ((pbe == NULL) || (pbe->prbVerify != rbc.prb) || dx || dy)
        {
            BYTE*       pjBrush;
            BYTE*       pjDst;
            LONG        cx, cx1, cx2, iBrushCache, k;

            // We have to allocate a new off-screen cache brush entry for
            // the brush:

            iBrushCache = ppdev->iBrushCache;
            pbe         = &ppdev->abe[iBrushCache];

            iBrushCache = (iBrushCache + 1) & (TOTAL_BRUSH_COUNT - 1);

            ppdev->iBrushCache = iBrushCache;

            // Update our links:

            pbe->prbVerify           = rbc.prb;
            rbc.prb->apbe[IBOARD(ppdev)] = pbe;

            // Pre-rotate...

            cx  = 8 * ppdev->cjPelSize;
            cx1 = dx * ppdev->cjPelSize;
            cx2 = (8 - dx) * ppdev->cjPelSize;

            pjBrush = (BYTE*) &rbc.prb->aulPattern[0] + dy * cx;
            pjDst = ppdev->pjScreen + pbe->y * ppdev->lDelta
                                    + pbe->x * ppdev->cjPelSize;

            vM64QuietDown(ppdev, pjMmBase);

            for (k = 0; k < 8; k++)
            {
                if (k == 8 - dy)
                    pjBrush = (BYTE*) &rbc.prb->aulPattern[0];
                memcpy( pjDst, pjBrush + cx1, cx2 );
                memcpy( pjDst + cx2, pjBrush, cx1 );
                pjDst   += cx;
                pjBrush += cx;
            }

            if (dx || dy)
                pbe->prbVerify = NULL;
        }

        // N.B. - SRC_Y_X may have a constant value, but don't pull it
        // out of this while loop.  On the GX, SRC_OFF_PITCH causes the
        // engine to recalculate SRC_Y_X, so the SRC_Y_X write must follow
        // SRC_OFF_PITCH.

        M64_OD(pjMmBase, SRC_OFF_PITCH,      pbe->ulOffsetPitch);
        M64_OD(pjMmBase, SRC_Y_X,            0);
        M64_OD(pjMmBase, DST_Y_X,            PACKXY(xLeft + xOffset,
                                                    yTop  + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH,   PACKXY(prcl->right - prcl->left,
                                                    prcl->bottom - prcl->top));
        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 4);
    }
}

VOID vM64FillPatColor24_2(          // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BRUSHENTRY* pbe;
    BYTE*       pjMmBase;
    LONG        xOffset;
    LONG        yOffset;
    LONG        xLeft;
    LONG        yTop;
    LONG        dx, dy;

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 8);
    M64_OD(pjMmBase, DP_MIX,             gaul64HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,           SRC_CNTL_PatEna);
    M64_OD(pjMmBase, DP_SRC,             DP_SRC_Blit << 8);
    M64_OD(pjMmBase, SRC_HEIGHT1_WIDTH1, PACKXY(24, 8));

    while (TRUE)
    {
        xLeft = prcl->left;
        yTop  = prcl->top;

        // Offsets into brush:
        dx  = (xLeft - pptlBrush->x) & 7;
        dy  = (yTop  - pptlBrush->y) & 7;

        // See if the brush has already been put into off-screen memory.
        // Also, if pre-rotation is required:

        pbe = rbc.prb->apbe[IBOARD(ppdev)];
        if ((pbe == NULL) || (pbe->prbVerify != rbc.prb) || dx || dy)
        {
            BYTE*       pjBrush;
            BYTE*       pjDst;
            LONG        cx, cx1, cx2, iBrushCache, k;

            // We have to allocate a new off-screen cache brush entry for
            // the brush:

            iBrushCache = ppdev->iBrushCache;
            pbe         = &ppdev->abe[iBrushCache];

            iBrushCache = (iBrushCache + 1) & (TOTAL_BRUSH_COUNT - 1);

            ppdev->iBrushCache = iBrushCache;

            // Update our links:

            pbe->prbVerify           = rbc.prb;
            rbc.prb->apbe[IBOARD(ppdev)] = pbe;

            // Pre-rotate...

            cx  = 8 * ppdev->cjPelSize;
            cx1 = dx * ppdev->cjPelSize;
            cx2 = (8 - dx) * ppdev->cjPelSize;

            pjBrush = (BYTE*) &rbc.prb->aulPattern[0] + dy * cx;
            pjDst = ppdev->pjScreen + pbe->y * ppdev->lDelta
                                    + pbe->x * ppdev->cjPelSize;

            vM64QuietDown(ppdev, pjMmBase);

            for (k = 0; k < 8; k++)
            {
                if (k == 8 - dy)
                    pjBrush = (BYTE*) &rbc.prb->aulPattern[0];
                memcpy( pjDst, pjBrush + cx1, cx2 );
                memcpy( pjDst + cx2, pjBrush, cx1 );
                pjDst   += cx;
                pjBrush += cx;
            }

            if (dx || dy)
                pbe->prbVerify = NULL;
        }

        M64_OD(pjMmBase, SRC_OFF_PITCH,      pbe->ulOffsetPitch);
        M64_OD(pjMmBase, SRC_Y_X,            0);
        M64_OD(pjMmBase, DST_Y_X,            PACKXY((xLeft + xOffset) * 3,
                                                    yTop  + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH,   PACKXY((prcl->right - prcl->left) * 3,
                                                    prcl->bottom - prcl->top));
        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 4);
    }
}

/******************************Public*Routine******************************\
* VOID vM64Xfer1bpp
*
* This routine colour expands a monochrome bitmap.
*
* See Blt_DS_S1_8G_D0 and Blt_DS_8G_D1.
*
\**************************************************************************/

VOID vM64Xfer1bpp2(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG*  pulXlate;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    LONG    culScan;
    LONG    lSrcSkip;
    ULONG*  pulSrc;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];
    pulXlate    = pxlo->pulXlate;

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 7, ulFifo);
    M64_OD(pjMmBase, DP_BKGD_CLR, pulXlate[0]);
    M64_OD(pjMmBase, DP_FRGD_CLR, pulXlate[1]);
    M64_OD(pjMmBase, DP_MIX,      ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC,      (DP_SRC_Host << 16) | (DP_SRC_FrgdClr << 8) |
                                  (DP_SRC_BkgdClr));

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        // The Mach64 'bit packs' monochrome transfers, but GDI gives
        // us monochrome bitmaps whose scans are always dword aligned.
        // Consequently, we use the Mach64's clip registers to make
        // our transfers a multiple of 32 to match the dword alignment:

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset,
                                                 xRight + xOffset - 1));
        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        xBias  = (xLeft + dx) & 31;             // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 31) & ~31;   // Ceiling

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft + xOffset,
                                              yTop  + yOffset));

        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + ((xLeft + dx) >> 3));
        culScan  = cx >> 5;
        lSrcSkip = lSrcDelta - (culScan << 2);

        ASSERTDD(((DWORD) pulSrc & 3) == 0, "Source should be dword aligned");

        do {
            i = culScan;
            do {
                M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                M64_OD(pjMmBase, HOST_DATA0, *pulSrc);
                pulSrc++;

            } while (--i != 0);

            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcSkip);

        } while (--cy != 0);

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_GUI_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register:

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

VOID vM64DataPortOutD_24bppmono(PDEV* ppdev, PBYTE pb, UINT count, LONG pitch);

VOID vM64Xfer1bppto24_2(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ROP4        rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG*  pulXlate;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    ULONG*  pulSrc;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];
    pulXlate    = pxlo->pulXlate;

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 8, ulFifo);
    M64_OD(pjMmBase, DP_BKGD_CLR, pulXlate[0]);
    M64_OD(pjMmBase, DP_FRGD_CLR, pulXlate[1]);
    M64_OD(pjMmBase, DP_MIX,      ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC,      (DP_SRC_Host << 16) | (DP_SRC_FrgdClr << 8) |
                                  (DP_SRC_BkgdClr));

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;


    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        // The Mach64 'bit packs' monochrome transfers, but GDI gives
        // us monochrome bitmaps whose scans are always dword aligned.
        // Consequently, we use the Mach64's clip registers to make
        // our transfers a multiple of 32 to match the dword alignment:

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR((xLeft + xOffset)*3,
                                                 (xRight + xOffset)*3 - 1));
        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        xBias  = (xLeft + dx) & 31;             // Floor
        xLeft -= xBias;
        cx     = ((xRight - xLeft)*3 + 31) & ~31;   // Ceiling

        M64_OD(pjMmBase, DST_CNTL, 0x83 | (((xLeft + xOffset + MAX_NEGX)*3/4 % 6) << 8));
        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST((xLeft + xOffset)*3,
                                              yTop  + yOffset));

        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pulSrc   = (ULONG*) (pjSrcScan0 + (yTop + dy) * lSrcDelta
                                        + ((xLeft + dx) >> 3));


        do {
            vM64DataPortOutD_24bppmono(ppdev, (PBYTE) pulSrc, cx >> 5, 0);

            pulSrc = (ULONG*) ((BYTE*) pulSrc + lSrcDelta);

        } while (--cy != 0);

        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 4);
    }

    // Don't forget to reset the clip register:

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 1);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

/******************************Public*Routine******************************\
* VOID vM64XferNative
*
* Transfers a bitmap that is the same colour depth as the display to
* the screen via the data transfer register, with no translation.
*
\**************************************************************************/

VOID vM64XferNative2(   // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    ULONG*  pulSrc;
    ULONG   culScan;
    LONG    lSrcSkip;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 6, ulFifo);
    M64_OD(pjMmBase, DP_MIX, ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC, (DP_SRC_Host << 8));

    //
    // The host data pixel width is the same as that of the screen:
    //

    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth |
        ((ppdev->ulMonoPixelWidth & 0xf) << 16));

    dx = (pptlSrc->x - prclDst->left) << ppdev->cPelSize;   // Bytes
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while (TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;
        yTop   = prcl->top;
        cy     = prcl->bottom - yTop;

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset, xRight + xOffset - 1));

        //
        // Convert pixels to bytes.
        //

        xLeft  <<= ppdev->cPelSize;
        xRight <<= ppdev->cPelSize;

        //
        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //

        xBias  = (xLeft + dx) & 3;                      // Floor (bytes)
        xLeft -= xBias;                                 // Bytes
        cx     = (xRight - xLeft + 3) & ~3;             // Ceiling (bytes)

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST((xLeft >> ppdev->cPelSize) + xOffset, yTop + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx >> ppdev->cPelSize, cy));

        pulSrc   = (PULONG)(pjSrcScan0 + (yTop + dy) * lSrcDelta + xLeft + dx);
        culScan  = cx >> 2;                             // Dwords
        lSrcSkip = lSrcDelta - cx;                      // Bytes

        ASSERTDD(((DWORD) pulSrc & 3) == 0, "Source should be dword aligned");

        if (culScan && cy)
        {
            do
            {
                i = culScan;

                do
                {
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, *pulSrc);
                    pulSrc++;
                } while (--i != 0);

                pulSrc = (PULONG)((BYTE*)pulSrc + lSrcSkip);

            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register and the default pixel width:

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 2, ulFifo);
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

VOID vM64XferNative24_2(  // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // Array of relative coordinates destination rectangles
ULONG       rop4,       // rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    ULONG   ulHwForeMix;
    LONG    dx;
    LONG    dy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    cy;
    LONG    cx;
    LONG    xBias;
    ULONG*  pulSrc;
    ULONG   culScan;
    LONG    lSrcSkip;
    LONG    i;
    ULONG   ulFifo;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset * 3;
    yOffset  = ppdev->yOffset;
    ulFifo   = 0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 6, ulFifo);
    M64_OD(pjMmBase, DP_MIX, ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC, (DP_SRC_Host << 8));

    // The host data pixel width is the same as that of the screen:

    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth |
                                   ((ppdev->ulMonoPixelWidth & 0xf) << 16));

    dx = (pptlSrc->x - prclDst->left) * 3;          // Bytes
    dy = pptlSrc->y - prclDst->top;

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    while (TRUE)
    {
        xLeft  = prcl->left * 3;
        xRight = prcl->right * 3;
        yTop   = prcl->top;
        cy     = prcl->bottom - yTop;

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset, xRight + xOffset - 1));

        //
        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //

        xBias  = (xLeft + dx) & 3;              // Floor (bytes)
        xLeft -= xBias;                         // Bytes
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling (bytes)

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft + xOffset, yTop + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pulSrc   = (PULONG)(pjSrcScan0 + (yTop + dy) * lSrcDelta + xLeft + dx);
        culScan  = cx >> 2;                     // Dwords
        lSrcSkip = lSrcDelta - cx;              // Bytes

        ASSERTDD(((DWORD) pulSrc & 3) == 0, "Source should be dword aligned");

        if (culScan && cy)
        {
            do
            {
                i = culScan;

                do
                {
                    M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, *pulSrc);
                    pulSrc++;
                } while (--i != 0);

                pulSrc = (PULONG)((BYTE*)pulSrc + lSrcSkip);

            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_FIFO_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register and the default pixel width:

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 2, ulFifo);
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

/******************************Public*Routine******************************\
* VOID vM64Xfer4bpp
*
* Does a 4bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 4bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vM64Xfer4bpp2(      // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    ULONG   ulHwForeMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    xBias;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    BYTE    jSrc;
    ULONG*  pulXlate;
    LONG    i;
    ULONG   ul;
    LONG    cjSrc;
    LONG    cwSrc;
    LONG    lSrcSkip;
    ULONG   ulFifo;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_4BPP, "Source must be 4bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->iBitmapFormat != BMF_24BPP, "Can't handle 24bpp");

    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulFifo    = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 6, ulFifo);
    M64_OD(pjMmBase, DP_MIX, ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC, (DP_SRC_Host << 8));

    // The host data pixel width is the same as that of the screen:

    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth |
                                   ((ppdev->ulMonoPixelWidth & 0xf) << 16));

    while(TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset,
                                                 xRight + xOffset - 1));
        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft + xOffset,
                                              yTop  + yOffset));

        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta
                              + ((xLeft + dx) >> 1);
        cjSrc    = cx >> 1;         // Number of source bytes touched
        lSrcSkip = lSrcDelta - cjSrc;

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            cwSrc = (cjSrc >> 1);    // Number of whole source words

            do {
                for (i = cwSrc; i != 0; i--)
                {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 8);
                    jSrc = *pjSrc++;
                    ul  |= (pulXlate[jSrc >> 4] << 16);
                    ul  |= (pulXlate[jSrc & 0xf] << 24);
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                // Handle an odd end byte, if there is one:

                if (cjSrc & 1)
                {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 8);
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            do {
                i = cjSrc;
                do {
                    jSrc = *pjSrc++;
                    ul   = (pulXlate[jSrc >> 4]);
                    ul  |= (pulXlate[jSrc & 0xf] << 16);
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else
        {
            // This part handles 32bpp output:

            do {
                i = cjSrc;
                do {
                    jSrc = *pjSrc++;
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 2, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, pulXlate[jSrc >> 4]);
                    M64_OD(pjMmBase, HOST_DATA0, pulXlate[jSrc & 0xf]);
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_GUI_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register and the default pixel width:

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 2, ulFifo);
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

/******************************Public*Routine******************************\
* VOID vM64Xfer8bpp
*
* Does a 8bpp transfer from a bitmap to the screen.
*
* The reason we implement this is that a lot of resources are kept as 8bpp,
* and used to initialize DFBs, some of which we of course keep off-screen.
*
\**************************************************************************/

VOID vM64Xfer8bpp2(         // Type FNXFER
PDEV*       ppdev,
LONG        c,          // Count of rectangles, can't be zero
RECTL*      prcl,       // List of destination rectangles, in relative
                        //   coordinates
ULONG       rop4,       // Rop4
SURFOBJ*    psoSrc,     // Source surface
POINTL*     pptlSrc,    // Original unclipped source point
RECTL*      prclDst,    // Original unclipped destination rectangle
XLATEOBJ*   pxlo)       // Translate that provides colour-expansion information
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    cjPelSize;
    ULONG   ulHwForeMix;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    xBias;
    LONG    dx;
    LONG    dy;
    LONG    cx;
    LONG    cy;
    LONG    lSrcDelta;
    BYTE*   pjSrcScan0;
    BYTE*   pjSrc;
    ULONG*  pulXlate;
    LONG    i;
    ULONG   ul;
    LONG    cdSrc;
    LONG    cwSrc;
    LONG    cxRem;
    LONG    lSrcSkip;
    ULONG   ulFifo;

    ASSERTDD(psoSrc->iBitmapFormat == BMF_8BPP, "Source must be 8bpp");
    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(ppdev->iBitmapFormat != BMF_24BPP, "Can't handle 24bpp");

    pjMmBase  = ppdev->pjMmBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    cjPelSize = ppdev->cjPelSize;
    pulXlate  = pxlo->pulXlate;
    ulFifo    = 0;

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;     // Add to destination to get source

    lSrcDelta  = psoSrc->lDelta;
    pjSrcScan0 = psoSrc->pvScan0;

    ulHwForeMix = gaul64HwMixFromRop2[rop4 & 0xf];

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 6, ulFifo);
    M64_OD(pjMmBase, DP_MIX, ulHwForeMix | (ulHwForeMix >> 16));
    M64_OD(pjMmBase, DP_SRC, (DP_SRC_Host << 8));

    // The host data pixel width is the same as that of the screen:

    M64_OD(pjMmBase, DP_PIX_WIDTH, ppdev->ulMonoPixelWidth |
                                   ((ppdev->ulMonoPixelWidth & 0xf) << 16));

    while(TRUE)
    {
        xLeft  = prcl->left;
        xRight = prcl->right;

        M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(xLeft + xOffset,
                                                 xRight + xOffset - 1));
        yTop = prcl->top;
        cy   = prcl->bottom - yTop;

        // We compute 'xBias' in order to dword-align the source pointer.
        // This way, we don't have to do unaligned reads of the source,
        // and we're guaranteed not to read even a byte past the end of
        // the bitmap.
        //
        // Note that this bias works at 24bpp, too:

        xBias  = (xLeft + dx) & 3;              // Floor
        xLeft -= xBias;
        cx     = (xRight - xLeft + 3) & ~3;     // Ceiling

        M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft + xOffset,
                                              yTop  + yOffset));

        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

        pjSrc    = pjSrcScan0 + (yTop + dy) * lSrcDelta
                              + (xLeft + dx);
        lSrcSkip = lSrcDelta - cx;

        if (cjPelSize == 1)
        {
            // This part handles 8bpp output:

            cdSrc = (cx >> 2);
            cxRem = (cx & 3);

            do {
                for (i = cdSrc; i != 0; i--)
                {
                    ul  = (pulXlate[*pjSrc++]);
                    ul |= (pulXlate[*pjSrc++] << 8);
                    ul |= (pulXlate[*pjSrc++] << 16);
                    ul |= (pulXlate[*pjSrc++] << 24);
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                if (cxRem > 0)
                {
                    ul = (pulXlate[*pjSrc++]);
                    if (cxRem > 1)
                    {
                        ul |= (pulXlate[*pjSrc++] << 8);
                        if (cxRem > 2)
                        {
                            ul |= (pulXlate[*pjSrc++] << 16);
                        }
                    }
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else if (cjPelSize == 2)
        {
            // This part handles 16bpp output:

            cwSrc = (cx >> 1);
            cxRem = (cx & 1);

            do {
                for (i = cwSrc; i != 0; i--)
                {
                    ul  = (pulXlate[*pjSrc++]);
                    ul |= (pulXlate[*pjSrc++] << 16);
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                if (cxRem > 0)
                {
                    ul = (pulXlate[*pjSrc++]);
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                }

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }
        else
        {
            // This part handles 32bpp output:

            do {
                i = cx;
                do {
                    ul = pulXlate[*pjSrc++];
                    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 1, ulFifo);
                    M64_OD(pjMmBase, HOST_DATA0, ul);
                } while (--i != 0);

                pjSrc += lSrcSkip;
            } while (--cy != 0);
        }

        if (--c == 0)
            break;

        prcl++;
        M64_FAST_GUI_CHECK(ppdev, pjMmBase, 3, ulFifo);
    }

    // Don't forget to reset the clip register and the default pixel width:

    M64_FAST_GUI_CHECK(ppdev, pjMmBase, 2, ulFifo);
    M64_OD(pjMmBase, DP_PIX_WIDTH,  ppdev->ulMonoPixelWidth);
    M64_OD(pjMmBase, SC_LEFT_RIGHT, PACKPAIR(0, M64_MAX_SCISSOR_R));
}

/******************************Public*Routine******************************\
* VOID vM64CopyBlt
*
* Does a screen-to-screen blt of a list of rectangles.
*
* See Blt_DS_SS_ENG_8G_D0 and Blt_DS_SS_TLBR_ENG_8G_D1.
*
\**************************************************************************/

VOID vM64CopyBlt2(   // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    cx;
    LONG    cy;
    ULONG   mix;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;
    mix      = gaul64HwMixFromRop2[rop4 & 0xf];

    if (mix == 0x70000)
    {
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 8);
        M64_OD(pjMmBase, DP_SET_GUI_ENGINE, 0xB08000 | ppdev->SetGuiEngineDefault);
        M64_OD(pjMmBase, SRC_CNTL,      0);
    }
    else
    {
        M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 10);
        M64_OD(pjMmBase, SRC_OFF_PITCH, ppdev->ulScreenOffsetAndPitch);
        M64_OD(pjMmBase, DP_SRC,        DP_SRC_Blit << 8);
        M64_OD(pjMmBase, DP_MIX,        gaul64HwMixFromRop2[rop4 & 0xf]);
        M64_OD(pjMmBase, SRC_CNTL,      0);
    }

    dx = pptlSrc->x - prclDst->left;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            while (TRUE)
            {
                xLeft = xOffset + prcl->left;
                yTop  = yOffset + prcl->top;
                cx    = prcl->right - prcl->left;
                cy    = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xLeft + dx, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 4);
            }
        }
        else
        {
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_YDir);

            while (TRUE)
            {
                xRight = xOffset + prcl->right - 1;
                yTop   = yOffset + prcl->top;
                cx     = prcl->right - prcl->left;
                cy     = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xRight + dx, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir);

            while (TRUE)
            {
                xLeft   = xOffset + prcl->left;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = prcl->right - prcl->left;
                cy      = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xLeft + dx, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
        else
        {
            M64_OD(pjMmBase, DST_CNTL, 0);

            while (TRUE)
            {
                xRight  = xOffset + prcl->right - 1;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = prcl->right - prcl->left;
                cy      = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xRight + dx, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
}

VOID vM64CopyBlt24_2( // Type FNCOPY
PDEV*   ppdev,
LONG    c,          // Can't be zero
RECTL*  prcl,       // Array of relative coordinates destination rectangles
ULONG   rop4,       // rop4
POINTL* pptlSrc,    // Original unclipped source point
RECTL*  prclDst)    // Original unclipped destination rectangle
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    dx;
    LONG    dy;
    LONG    xLeft;
    LONG    xRight;
    LONG    yTop;
    LONG    yBottom;
    LONG    cx;
    LONG    cy;

    ASSERTDD(c > 0, "Can't handle zero rectangles");
    ASSERTDD(((rop4 & 0xff00) >> 8) == (rop4 & 0xff),
             "Expect only a rop2");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 10);
    M64_OD(pjMmBase, SRC_OFF_PITCH, ppdev->ulScreenOffsetAndPitch);
    M64_OD(pjMmBase, DP_SRC,        DP_SRC_Blit << 8);
    M64_OD(pjMmBase, DP_MIX,        gaul64HwMixFromRop2[rop4 & 0xf]);
    M64_OD(pjMmBase, SRC_CNTL,      0);

    dx = (pptlSrc->x - prclDst->left) * 3;
    dy = pptlSrc->y - prclDst->top;

    // The accelerator may not be as fast at doing right-to-left copies, so
    // only do them when the rectangles truly overlap:

    if (!OVERLAP(prclDst, pptlSrc))
        goto Top_Down_Left_To_Right;

    if (prclDst->top <= pptlSrc->y)
    {
        if (prclDst->left <= pptlSrc->x)
        {

Top_Down_Left_To_Right:

            while (TRUE)
            {
                xLeft = (xOffset + prcl->left) * 3;
                yTop  = yOffset + prcl->top;
                cx    = (prcl->right - prcl->left) * 3;
                cy    = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xLeft + dx, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 4);
            }
        }
        else
        {
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_YDir);

            while (TRUE)
            {
                xRight = (xOffset + prcl->right) * 3 - 1;
                yTop   = yOffset + prcl->top;
                cx     = (prcl->right - prcl->left) * 3;
                cy     = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yTop));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xRight + dx, yTop + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 4);
            }

            // Since we don't use a default context, we must restore registers:

            M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 1);
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
    else
    {
        if (prclDst->left <= pptlSrc->x)
        {
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir);

            while (TRUE)
            {
                xLeft   = (xOffset + prcl->left) * 3;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = (prcl->right - prcl->left) * 3;
                cy      = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xLeft, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xLeft + dx, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 4);
            }

            // Since we don't use a default context, we must restore registers:

            M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 1);
            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
        else
        {
            M64_OD(pjMmBase, DST_CNTL, 0);

            while (TRUE)
            {
                xRight  = (xOffset + prcl->right) * 3 - 1;
                yBottom = yOffset + prcl->bottom - 1;
                cx      = (prcl->right - prcl->left) * 3;
                cy      = prcl->bottom - prcl->top;

                M64_OD(pjMmBase, DST_Y_X, PACKXY_FAST(xRight, yBottom));
                M64_OD(pjMmBase, SRC_Y_X, PACKXY_FAST(xRight + dx, yBottom + dy));
                M64_OD(pjMmBase, SRC_WIDTH1, cx);
                M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(cx, cy));

                if (--c == 0)
                    break;

                prcl++;
                M64_CHECK_GUI_SPACE(ppdev, pjMmBase, 5);
            }

            // Since we don't use a default context, we must restore registers:

            M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\ati\disp\bltm64.c ===
/******************************Module*Header*******************************\
* Module Name: bltm64.c
*
* Contains the low-level memory-mapped I/O blt functions for the Mach64.
*
* Hopefully, if you're basing your display driver on this code, to
* support all of DrvBitBlt and DrvCopyBits, you'll only have to implement
* the following routines.  You shouldn't have to modify much in
* 'bitblt.c'.  I've tried to make these routines as few, modular, simple,
* and efficient as I could, while still accelerating as many calls as
* possible that would be cost-effective in terms of performance wins
* versus size and effort.
*
* Note: In the following, 'relative' coordinates refers to coordinates
*       that haven't yet had the offscreen bitmap (DFB) offset applied.
*       'Absolute' coordinates have had the offset applied.  For example,
*       we may be told to blt to (1, 1) of the bitmap, but the bitmap may
*       be sitting in offscreen memory starting at coordinate (0, 768) --
*       (1, 1) would be the 'relative' start coordinate, and (1, 769)
*       would be the 'absolute' start coordinate'.
*
* Copyright (c) 1992-1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vM64FillSolid
*
* Fills a list of rectangles with a solid colour.
*
\**************************************************************************/

VOID vM64FillSolid(             // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 6);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

    M64_OD(pjMmBase, DP_MIX,      gaul64HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);
    M64_OD(pjMmBase, DP_SRC,      DP_SRC_FrgdClr << 8);

    while (TRUE)
    {
        M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(xOffset + prcl->left,
                                                       yOffset + prcl->top));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST(prcl->right - prcl->left,
                                                       prcl->bottom - prcl->top));

        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    }
}

VOID vM64FillSolid24(           // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // Drawing colour is rbc.iSolidColor
POINTL*         pptlBrush)      // Not used
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    LONG    x;

    ASSERTDD(c > 0, "Can't handle zero rectangles");

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 8);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );

    M64_OD(pjMmBase, DP_MIX,      gaul64HwMixFromRop2[(rop4 >> 2) & 0xf]);
    M64_OD(pjMmBase, DP_FRGD_CLR, rbc.iSolidColor);
    M64_OD(pjMmBase, DP_SRC,      DP_SRC_FrgdClr << 8);

    while (TRUE)
    {
        x = (xOffset + prcl->left) * 3;

        M64_OD(pjMmBase, DST_CNTL,         0x83 | ((x/4 % 6) << 8));
        M64_OD(pjMmBase, DST_Y_X,          PACKXY_FAST(x,
                                                       yOffset + prcl->top));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY_FAST((prcl->right - prcl->left) * 3,
                                                       prcl->bottom - prcl->top));

        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 4);
    }

    M64_OD(pjMmBase, DST_CNTL, DST_CNTL_XDir | DST_CNTL_YDir);
}

/******************************Public*Routine******************************\
* VOID vM64FillPatMonochrome
*
* This routine uses the pattern hardware to draw a monochrome patterned
* list of rectangles.
*
* See Blt_DS_P8x8_ENG_8G_D0 and Blt_DS_P8x8_ENG_8G_D1.
*
\**************************************************************************/

VOID vM64FillPatMonochrome(     // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pattern alignment
{
    BYTE*   pjMmBase;
    LONG    xOffset;
    LONG    yOffset;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    xPattern;
    LONG    yPattern;
    LONG    iLeftShift;
    LONG    iRightShift;
    LONG    xOld;
    LONG    yOld;
    LONG    i;
    BYTE    j;
    ULONG   ulHwForeMix;
    ULONG   ulHwBackMix;
    LONG    xLeft;
    LONG    yTop;
    ULONG   aulTmp[2];

    pjMmBase = ppdev->pjMmBase;
    xOffset  = ppdev->xOffset;
    yOffset  = ppdev->yOffset;

    xPattern = (pptlBrush->x + xOffset) & 7;
    yPattern = (pptlBrush->y + yOffset) & 7;

    // If the alignment isn't correct, we'll have to change it:

    if ((xPattern != rbc.prb->ptlBrush.x) || (yPattern != rbc.prb->ptlBrush.y))
    {
        // Remember that we've changed the alignment on our cached brush:

        xOld = rbc.prb->ptlBrush.x;
        yOld = rbc.prb->ptlBrush.y;

        rbc.prb->ptlBrush.x = xPattern;
        rbc.prb->ptlBrush.y = yPattern;

        // Now do the alignment:

        yPattern    = (yOld - yPattern);
        iRightShift = (xPattern - xOld) & 7;
        iLeftShift  = 8 - iRightShift;

        pjSrc = (BYTE*) &rbc.prb->aulPattern[0];
        pjDst = (BYTE*) &aulTmp[0];

        for (i = 0; i < 8; i++)
        {
            j = *(pjSrc + (yPattern++ & 7));
            *pjDst++ = (j << iLeftShift) | (j >> iRightShift);
        }

        rbc.prb->aulPattern[0] = aulTmp[0];
        rbc.prb->aulPattern[1] = aulTmp[1];
    }

    ulHwForeMix = gaul64HwMixFromRop2[(rop4 >> 2) & 0xf];
    ulHwBackMix = ((rop4 & 0xff00) == 0xaa00) ? LEAVE_ALONE : (ulHwForeMix >> 16);

    M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 10);
    M64_OD(pjMmBase, CONTEXT_LOAD_CNTL, CONTEXT_LOAD_CmdLoad | ppdev->iDefContext );
    M64_OD(pjMmBase, PAT_CNTL, PAT_CNTL_MonoEna);
    M64_OD(pjMmBase, DP_SRC, DP_SRC_MonoPattern | DP_SRC_FrgdClr << 8);
    M64_OD(pjMmBase, DP_MIX, ulHwBackMix | ulHwForeMix);
    M64_OD(pjMmBase, DP_FRGD_CLR, rbc.prb->ulForeColor);
    M64_OD(pjMmBase, DP_BKGD_CLR, rbc.prb->ulBackColor);
    M64_OD(pjMmBase, PAT_REG0, rbc.prb->aulPattern[0]);
    M64_OD(pjMmBase, PAT_REG1, rbc.prb->aulPattern[1]);

    while(TRUE)
    {
        xLeft = prcl->left;
        yTop  = prcl->top;

        M64_OD(pjMmBase, DST_Y_X,          PACKXY(xLeft + xOffset,
                                                  yTop + yOffset));
        M64_OD(pjMmBase, DST_HEIGHT_WIDTH, PACKXY(prcl->right - xLeft,
                                                  prcl->bottom - prcl->top));
        if (--c == 0)
            break;

        prcl++;
        M64_CHECK_FIFO_SPACE(ppdev, pjMmBase, 2);
    }
}

VOID vM64FillPatMonochrome24(   // Type FNFILL
PDEV*           ppdev,
LONG            c,              // Can't be zero
RECTL*          prcl,           // List of rectangles to be filled, in relative
                                //   coordinates
ULONG           rop4,           // rop4
RBRUSH_COLOR    rbc,            // rbc.prb points to brush realization structure
POINTL*         pptlBrush)      // Pa