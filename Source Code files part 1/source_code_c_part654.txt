-----------------------------------------------*/
HRESULT 
CServerPropAdvanced::GetConfig()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

    m_pConfig = ((CServerProperties *) GetHolder())->GetConfig();

	return hr;
}


/*---------------------------------------------------------------------------
	CServerPropAdvanced::UpdateServerConfiguration()
		Updates the variables in the server handler
---------------------------------------------------------------------------*/
HRESULT
CServerPropAdvanced::UpdateServerConfiguration()
{
	UpdateData();

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// get the server
	SPITFSNode spNode;
	CWinsServerHandler * pServer;

	spNode = GetHolder()->GetNode();
	pServer = GETHANDLER(CWinsServerHandler, spNode);

	// update our settings
	m_pConfig->m_fLogDetailedEvents = m_fLogEvents;
	if (m_fLanNames)
	{
		pServer->m_dwFlags |= FLAG_LANMAN_COMPATIBLE;
	}
	else
	{
		pServer->m_dwFlags &= (~FLAG_LANMAN_COMPATIBLE);
	}

	// version stuff
    LONG lLowWord, lHighWord;
	FillVersionInfo(lLowWord, lHighWord);

	m_pConfig->m_dwVersCountStart_HighWord = lHighWord;
	m_pConfig->m_dwVersCountStart_LowWord = lLowWord;
	
    // burst handling
    m_pConfig->m_fBurstHandling = m_fBurstHandling;
    m_pConfig->m_dwBurstQueSize = GetQueSize();

    // db path
	if (m_fRestart)
	{
		m_pConfig->m_strDbPath = m_strDbPath;
	}

    // now write to server
    DWORD err = m_pConfig->Store();
    if (err != ERROR_SUCCESS)
    {
        // something bad happened
        WinsMessageBox(err);
    }
    else
    {   
        // success update our local copy
        pServer->SetConfig(*m_pConfig);
    }

    return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CServerPropAdvanced::FillVersionInfo(LONG &lLowValue, LONG &lHighValue)
		fills the version info in the related controls 
---------------------------------------------------------------------------*/
void 
CServerPropAdvanced::FillVersionInfo(LONG &lLowValue, LONG &lHighValue)
{
	CString str ;
	m_editVersionCount.GetWindowText(str);

    int j = str.GetLength();

    if ( j > 16 || !j )
    {
        //
        // Invalid string
        //
        return;
    }

    TCHAR sz[] = _T("0000000000000000");
    TCHAR *pch;

    ::_tcscpy(sz + 16 - j, (LPCTSTR)str);
    pch = sz + 8;
    ::_stscanf(pch, _T("%08lX"),&lLowValue);
    *pch = '\0';
    ::_stscanf(sz, _T("%08lX"),&lHighValue);

    return;
}


CString 
CServerPropAdvanced::GetVersionInfo(LONG lLowWord, LONG lHighWord)
{
	CString strVersionCount;

	TCHAR sz[20];
    TCHAR *pch = sz;
    ::wsprintf(sz, _T("%08lX%08lX"), lHighWord, lLowWord);
    // Kill leading zero's
    while (*pch == '0')
    {
        ++pch;
    }
    // At least one digit...
    if (*pch == '\0')
    {
        --pch;
    }

    strVersionCount = pch;

    return strVersionCount;

}

void CServerPropAdvanced::OnCheckLannames() 
{
	SetDirty(TRUE);

	// mark the snap-in as dirty
	SPITFSNode spNode ;
	spNode = GetHolder()->GetNode();
	
	SPITFSNodeMgr spNodeManager;
	SPITFSNode spRootNode;

	spNode->GetNodeMgr(&spNodeManager);
	spNodeManager->GetRootNode(&spRootNode);

	// mark the data as dirty so that we'll ask the user to save.
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
	
}

void CServerPropAdvanced::MarkDirty() 
{
	SetDirty(TRUE);	
}

void CServerPropAdvanced::OnCheckBurstHandling() 
{
    SetDirty(TRUE);
    UpdateBurstHandling();	
}

void CServerPropAdvanced::OnRadioCustom() 
{
    SetDirty(TRUE);
    EnableCustomEntry();	
}

void CServerPropAdvanced::OnRadioHigh() 
{
    SetDirty(TRUE);
    EnableCustomEntry();	
}

void CServerPropAdvanced::OnRadioLow() 
{
    SetDirty(TRUE);
    EnableCustomEntry();	
}

void CServerPropAdvanced::OnRadioMedium() 
{
    SetDirty(TRUE);
    EnableCustomEntry();	
}

void CServerPropAdvanced::OnChangeEditCustomValue() 
{
    SetDirty(TRUE);
}

void CServerPropAdvanced::OnButtonBrowseDatabase() 
{
	// TODO: browse for a path
}

void CServerPropAdvanced::OnChangeEditDatabasePath() 
{
    SetDirty(TRUE);
	m_fRestart = TRUE;
}

void CServerPropAdvanced::UpdateBurstHandling()
{
    if (IsWindow(m_checkBurstHandling.GetSafeHwnd()))
    {
        EnableQueSelection(m_checkBurstHandling.GetCheck());
    }
}

void CServerPropAdvanced::EnableQueSelection(BOOL bEnable)
{
    GetDlgItem(IDC_RADIO_LOW)->EnableWindow(bEnable);
    GetDlgItem(IDC_RADIO_MEDIUM)->EnableWindow(bEnable);
    GetDlgItem(IDC_RADIO_HIGH)->EnableWindow(bEnable);
    GetDlgItem(IDC_RADIO_CUSTOM)->EnableWindow(bEnable);
    GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->EnableWindow(bEnable);

    EnableCustomEntry();
}

void CServerPropAdvanced::EnableCustomEntry()
{
    BOOL bEnable = ((CButton *)GetDlgItem(IDC_RADIO_CUSTOM))->GetCheck() &&
                   m_checkBurstHandling.GetSafeHwnd() &&
                   m_checkBurstHandling.GetCheck();

    GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->EnableWindow(bEnable);
}

void CServerPropAdvanced::SetQueSize()
{   
    UINT uControlID = IDC_RADIO_CUSTOM;

    switch (m_pConfig->m_dwBurstQueSize)
    {
        case BURST_QUE_SIZE_LOW:
            uControlID = IDC_RADIO_LOW;
            m_nQueSelection = 0;
            break;

        case BURST_QUE_SIZE_MEDIUM:
            uControlID = IDC_RADIO_MEDIUM;
            m_nQueSelection = 1;
            break;

        case BURST_QUE_SIZE_HIGH:
            uControlID = IDC_RADIO_HIGH;
            m_nQueSelection = 2;
            break;
        
        default:
            {
                TCHAR szBuf[10];

                _itot(m_pConfig->m_dwBurstQueSize, szBuf, 10);
                m_nQueSelection = 3;
                GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->SetWindowText(szBuf);
            }
            break;
    }

    ((CButton *) GetDlgItem(uControlID))->SetCheck(TRUE);
}

DWORD CServerPropAdvanced::GetQueSize()
{
    DWORD dwSize = 0;

    UpdateData();

    if (IsDlgButtonChecked(IDC_RADIO_LOW))
    {
        dwSize = BURST_QUE_SIZE_LOW;
    }
    else
    if (IsDlgButtonChecked(IDC_RADIO_MEDIUM))
    {
        dwSize = BURST_QUE_SIZE_MEDIUM;
    }
    else
    if (IsDlgButtonChecked(IDC_RADIO_HIGH))
    {
        dwSize = BURST_QUE_SIZE_HIGH;
    }
    else
    {
        // must be custom
        CString strText;

        GetDlgItem(IDC_EDIT_CUSTOM_VALUE)->GetWindowText(strText);
        dwSize = (DWORD) _ttoi(strText);
    }

    return dwSize;
}

/////////////////////////////////////////////////////////////////////////////
//
// CServerProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CServerProperties::CServerProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)

{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
    m_bTheme = TRUE;

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	AddPageToList((CPropertyPageBase*) &m_pageDBRecord);
	AddPageToList((CPropertyPageBase*) &m_pageDBVerification);
	AddPageToList((CPropertyPageBase*) &m_pageAdvanced);

	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}

CServerProperties::~CServerProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageDBRecord, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageDBVerification, FALSE);
	RemovePageFromList((CPropertyPageBase*) &m_pageAdvanced, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\server.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	server.cpp
		WINS server node information. 
		
    FILE HISTORY:
        
*/


#include "stdafx.h"
#include "winssnap.h"
#include "root.h"
#include "Srvlatpp.h"
#include "actreg.h"
#include "reppart.h"
#include "server.h"
#include "svrstats.h"
#include "shlobj.h"
#include "cprogdlg.h"
#include "status.h"
#include "tregkey.h"
#include "verify.h"
#include "pushtrig.h"
#include "ipadddlg.h"
#include <service.h>

#define NB_NAME_MAX_LENGTH      16          // Max length for NetBIOS names
#define LM_NAME_MAX_LENGTH      15          // Maximum length for Lanman-compatible 
											// NetBIOS Name.

#define DOMAINNAME_LENGTH       255
#define HOSTNAME_LENGTH         16

CNameCache g_NameCache;

int BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    int i;

    switch (uMsg)
    {
        case BFFM_INITIALIZED:
            SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
            break;
    }

    return 0;
}
 

/*---------------------------------------------------------------------------
	CNameThread
		Background thread that resolves names
	Author: EricDav
 ---------------------------------------------------------------------------*/
CNameThread::CNameThread()
{
	m_bAutoDelete = FALSE;
    m_hEventHandle = NULL;
    m_pServerInfoArray = NULL;
}

CNameThread::~CNameThread()
{
	if (m_hEventHandle != NULL)
	{
		VERIFY(::CloseHandle(m_hEventHandle));
		m_hEventHandle = NULL;
	}
}

void CNameThread::Init(CServerInfoArray * pServerInfoArray)
{
    m_pServerInfoArray = pServerInfoArray;
}

BOOL CNameThread::Start()
{
	ASSERT(m_hEventHandle == NULL); // cannot call start twice or reuse the same C++ object
	
    m_hEventHandle = ::CreateEvent(NULL,TRUE /*bManualReset*/,FALSE /*signalled*/, NULL);
	if (m_hEventHandle == NULL)
		return FALSE;
	
    return CreateThread();
}

void CNameThread::Abort(BOOL fAutoDelete)
{
	if (!IsRunning() && fAutoDelete)
	{
		delete this;
	}
	else
    {
		m_bAutoDelete = fAutoDelete;

		SetEvent(m_hEventHandle);
	}

}

void CNameThread::AbortAndWait()
{
    Abort(FALSE);

    WaitForSingleObject(m_hThread, INFINITE);
}

BOOL CNameThread::IsRunning()
{
    if (WaitForSingleObject(m_hThread, 0) == WAIT_OBJECT_0)
    {
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

int CNameThread::Run()
{
    Assert(m_pServerInfoArray);

    // 
    // fill in the host names for each owner in the list
    //
    UpdateNameCache();

    if (FCheckForAbort())
        return 29;

    for (int i = 0; i < m_pServerInfoArray->GetSize(); i++)
    {
        if (FCheckForAbort())
            break;

        DWORD dwIp = m_pServerInfoArray->GetAt(i).m_dwIp;
        
        if (dwIp != 0)
        {
            CString strName;

            if (!GetNameFromCache(dwIp, strName))
            {
                GetHostName(dwIp, strName);
            
                CNameCacheEntry cacheEntry;
                cacheEntry.m_dwIp = dwIp;
                cacheEntry.m_strName = strName;
                cacheEntry.m_timeLastUpdate.GetCurrentTime();

                g_NameCache.Add(cacheEntry);

                Trace2("CNameThread::Run - GetHostName for %lx returned %s\n", dwIp, strName);
            }

            if (FCheckForAbort())
                break;

            (*m_pServerInfoArray)[i].m_strName = strName;
        }
    }

    return 29;  // exit code so I can tell when the thread goes away
}

BOOL CNameThread::FCheckForAbort()
{
    if (WaitForSingleObject(m_hEventHandle, 0) == WAIT_OBJECT_0)
    {
        Trace0("CNameThread::Run - abort detected, exiting...\n");
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

void CNameThread::UpdateNameCache()
{
    CTime time;
    time = CTime::GetCurrentTime();

    CTimeSpan timespan(0, 1, 0, 0); // 1 hour

    for (int i = 0; i < g_NameCache.GetSize(); i++)
    {
        if (g_NameCache[i].m_timeLastUpdate < (time - timespan))
        {
            CString strName;
            GetHostName(g_NameCache[i].m_dwIp, strName);

            g_NameCache[i].m_strName = strName;

            if (FCheckForAbort())
                break;
        }
    }
}

BOOL CNameThread::GetNameFromCache(DWORD dwIp, CString & strName)
{
    BOOL fFound = FALSE;

    for (int i = 0; i < g_NameCache.GetSize(); i++)
    {
        if (g_NameCache[i].m_dwIp == dwIp)
        {
            strName = g_NameCache[i].m_strName;
            fFound = TRUE;
            break;
        }
    }

    return fFound;
}

/*---------------------------------------------------------------------------
	Constructor and destructor
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CWinsServerHandler::CWinsServerHandler
(
	ITFSComponentData *	pComponentData, 
	LPCWSTR				pServerName,
	BOOL				fConnected,
	DWORD				dwIp,
	DWORD				dwFlags,
	DWORD				dwRefreshInterval
) : CMTWinsHandler(pComponentData),
	m_dwFlags(dwFlags),
	m_dwRefreshInterval(dwRefreshInterval),
	m_hBinding(NULL)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	m_strServerAddress = pServerName;
	m_fConnected = fConnected;
	m_dwIPAdd = dwIp;
	m_hBinding = NULL;
    m_bExtension = FALSE;

    m_pNameThread = NULL;

    strcpy(szIPMon, "");
}


/*---------------------------------------------------------------------------
	Constructor and destructor
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CWinsServerHandler::~CWinsServerHandler()
{
	HWND            hStatsWnd;

	// Check to see if this node has a stats sheet up.
    hStatsWnd = m_dlgStats.GetSafeHwnd();
    if (hStatsWnd != NULL)
    {
        m_dlgStats.KillRefresherThread();
        WaitForStatisticsWindow(&m_dlgStats);
    }

    // diconnect from server and make the handle invalid
	DisConnectFromWinsServer();

    // kill the name query thread if exists
    if (m_pNameThread)
    {
        m_pNameThread->AbortAndWait();
        delete m_pNameThread;
    }
}

/*!--------------------------------------------------------------------------
	CWinsServerHandler::InitializeNode
		Initializes node specific data
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsServerHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString IPAdd;
	CString strDisp;
	
    if (m_dwIPAdd != 0)
	{
		 MakeIPAddress(m_dwIPAdd, IPAdd);
	     strDisp.Format(IDS_SERVER_NAME_FORMAT, m_strServerAddress, IPAdd);
	}
	else
	{
		strDisp = m_strServerAddress;
	}

	SetDisplayName(strDisp);
	
	if (m_fConnected)
	{
		m_nState = loaded;
	}
	else
	{
		m_nState = notLoaded;
	}

	pNode->SetData(TFS_DATA_IMAGEINDEX, GetImageIndex(FALSE));
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, GetImageIndex(TRUE));

	// Make the node immediately visible
	pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, WINSSNAP_SERVER);
	
	SetColumnStringIDs(&aColumns[WINSSNAP_SERVER][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_SERVER][0]);

	return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnCreateNodeId2
		Returns a unique string for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CWinsServerHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strId = m_strServerAddress + strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::GetImageIndex
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
int 
CWinsServerHandler::GetImageIndex(BOOL bOpenImage) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	int nIndex = 0;

    switch (m_nState)
	{
		case notLoaded:
			nIndex = ICON_IDX_SERVER;
			break;
		
        case loaded:
			nIndex = ICON_IDX_SERVER_CONNECTED;
	        m_strConnected.LoadString(IDS_SERVER_CONNECTED);
			break;
		
        case unableToLoad:
            if (m_dwErr == ERROR_ACCESS_DENIED)
            {
			    nIndex = ICON_IDX_SERVER_NO_ACCESS;
            }
            else
            {
			    nIndex = ICON_IDX_SERVER_LOST_CONNECTION;
            }
	        m_strConnected.LoadString(IDS_SERVER_NOTCONNECTED);
			break;
		
		case loading:
			nIndex = ICON_IDX_SERVER_BUSY;
			break;

        default:
			ASSERT(FALSE);
	}
	
    return nIndex;
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::OnHaveData
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CWinsServerHandler::OnHaveData
(
	ITFSNode * pParentNode, 
	ITFSNode * pNewNode
)
{
    // expand the node so that child nodes appear correctly
    LONG_PTR  dwType = pNewNode->GetData(TFS_DATA_TYPE);

	switch (dwType)
    {
		case WINSSNAP_ACTIVE_REGISTRATIONS:
        {
            CActiveRegistrationsHandler * pActReg = GETHANDLER(CActiveRegistrationsHandler, pNewNode);
            pActReg->SetServer(pParentNode);
			m_spActiveReg.Set(pNewNode);
        }
			break;

		case WINSSNAP_REPLICATION_PARTNERS:
			m_spReplicationPartner.Set(pNewNode);
			break;

		default:
			Assert("Invalid node types passed back to server handler!");
			break;
	}

    pParentNode->AddChild(pNewNode);

    // now tell the view to update themselves
    ExpandNode(pParentNode, TRUE);
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::OnHaveData
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CWinsServerHandler::OnHaveData
(
	ITFSNode * pParentNode, 
	LPARAM	   Data,
	LPARAM	   Type
)
{
	// This is how we get non-node data back from the background thread.
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    switch (Type)
    {
		case WINS_QDATA_SERVER_INFO:
			{	
				CServerData *		pServerInfo = (CServerData *) Data;

				DisConnectFromWinsServer();

				m_hBinding = pServerInfo->m_hBinding;
				
				m_dwIPAdd = pServerInfo->m_dwServerIp;
				m_strServerAddress = pServerInfo->m_strServerName;
				
				m_cConfig = pServerInfo->m_config;

				// update the name string
				if (!m_bExtension)
				{
					SPITFSNode			spRoot;
					CWinsRootHandler *	pRoot;

					m_spNodeMgr->GetRootNode(&spRoot);
					pRoot = GETHANDLER(CWinsRootHandler, spRoot);

					SetDisplay(pParentNode, pRoot->GetShowLongName());
				}

				delete pServerInfo;
			}
			break;
	}
}

/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnAddMenuItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsServerHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType,
	long *					pInsertionAllowed
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	LONG			fFlags = 0, fLoadingFlags = 0, f351Flags = 0, fAdminFlags = 0;
	HRESULT			hr = S_OK;
	CString			strMenuItem;
	BOOL			b351 = FALSE;

	if ( m_nState != loaded )
	{
		fFlags |= MF_GRAYED;
	}
	
    if ( m_nState == loading)
	{
		fLoadingFlags = MF_GRAYED;
	}

    if (!m_cConfig.IsAdmin())
    {
        fAdminFlags = MF_GRAYED;
    }

	if (type == CCT_SCOPE)
	{
     	if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
		{

			strMenuItem.LoadString(IDS_SHOW_SERVER_STATS);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_SHOW_SERVER_STATS,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
									 fFlags );
			ASSERT( SUCCEEDED(hr) );

            // separator
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     0,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     MF_SEPARATOR);
		    ASSERT( SUCCEEDED(hr) );

            // scavenge
			strMenuItem.LoadString(IDS_SERVER_SCAVENGE);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_SERVER_SCAVENGE,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
									 fFlags );
			ASSERT( SUCCEEDED(hr) );

			// check if 351 server is being managed
			if ( m_nState == loaded )
                b351 = CheckIfNT351Server();

			// yes? grey out the consistency check items
			if(b351)
				f351Flags |= MF_GRAYED;
			else
				f351Flags &= ~MF_GRAYED;

            // only available to admins
			strMenuItem.LoadString(IDS_DO_CONSISTENCY_CHECK);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_DO_CONSISTENCY_CHECK,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP,     
									 f351Flags | fFlags | fAdminFlags);
			ASSERT( SUCCEEDED(hr) );

            // only available to admins
			strMenuItem.LoadString(IDS_CHECK_VERSION_CONSISTENCY);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_CHECK_VERSION_CONSISTENCY,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
									 f351Flags | fFlags | fAdminFlags);
			ASSERT( SUCCEEDED(hr) );

            // separator
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     0,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     MF_SEPARATOR);
		    ASSERT( SUCCEEDED(hr) );

            // replication triggers
            strMenuItem.LoadString(IDS_REP_SEND_PUSH_TRIGGER);
	        hr = LoadAndAddMenuItem( pContextMenuCallback, 
							         strMenuItem, 
							         IDS_REP_SEND_PUSH_TRIGGER,
							         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
							         fFlags );
    	    ASSERT( SUCCEEDED(hr) );

            strMenuItem.LoadString(IDS_REP_SEND_PULL_TRIGGER);
	        hr = LoadAndAddMenuItem( pContextMenuCallback, 
							         strMenuItem, 
							         IDS_REP_SEND_PULL_TRIGGER,
							         CCM_INSERTIONPOINTID_PRIMARY_TOP, 
							         fFlags );
	        ASSERT( SUCCEEDED(hr) );

            // separator
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     0,
								     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
								     MF_SEPARATOR);
		    ASSERT( SUCCEEDED(hr) );

            // enable backp and restore database only for local servers
			if(IsLocalConnection() && m_nState == loaded)
				fFlags &= ~MF_GRAYED;
			else
				fFlags |= MF_GRAYED;

			strMenuItem.LoadString(IDS_SERVER_BACKUP);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_SERVER_BACKUP,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
									 fFlags );
			ASSERT( SUCCEEDED(hr) );


			// default is to not show this item
			fFlags |= MF_GRAYED;

			BOOL fServiceRunning = TRUE;
            ::TFSIsServiceRunning(m_strServerAddress, _T("WINS"), &fServiceRunning);

			if (IsLocalConnection() && m_cConfig.IsAdmin())
			{
				// the service call can be costly if doing it remotely, so only do it
				// when we really need to.
				if (!fServiceRunning)
					fFlags &= ~MF_GRAYED;
			}

			strMenuItem.LoadString(IDS_SERVER_RESTORE);
			hr = LoadAndAddMenuItem( pContextMenuCallback, 
									 strMenuItem, 
									 IDS_SERVER_RESTORE,
									 CCM_INSERTIONPOINTID_PRIMARY_TOP, 
									 fFlags );
			ASSERT( SUCCEEDED(hr) );
        }

        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK)
        {
            // start/stop service menu items
	        if ( m_nState == notLoaded ||
                 m_nState == loading)
	        {
		        fFlags = MF_GRAYED;
	        }
            else
            {
                fFlags = 0;
            }

            DWORD dwServiceStatus, dwErrorCode, dwErr;
            dwErr = ::TFSGetServiceStatus(m_strServerAddress, _T("wins"), &dwServiceStatus, &dwErrorCode);
			if (dwErr != ERROR_SUCCESS)
                fFlags |= MF_GRAYED;

            // determining the restart state is the same as the stop flag
            LONG lStartFlag = (dwServiceStatus == SERVICE_STOPPED) ? 0 : MF_GRAYED;
            
            LONG lStopFlag = ( (dwServiceStatus == SERVICE_RUNNING) ||
                               (dwServiceStatus == SERVICE_PAUSED) ) ? 0 : MF_GRAYED;

            LONG lPauseFlag = ( (dwServiceStatus == SERVICE_RUNNING) ||
                                ( (dwServiceStatus != SERVICE_PAUSED) &&
                                  (dwServiceStatus != SERVICE_STOPPED) ) ) ? 0 : MF_GRAYED;
            
            LONG lResumeFlag = (dwServiceStatus == SERVICE_PAUSED) ? 0 : MF_GRAYED;

            strMenuItem.LoadString(IDS_SERVER_START_SERVICE);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_SERVER_START_SERVICE,
								     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
								     fFlags | lStartFlag);

            strMenuItem.LoadString(IDS_SERVER_STOP_SERVICE);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_SERVER_STOP_SERVICE,
								     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
								     fFlags | lStopFlag);

            strMenuItem.LoadString(IDS_SERVER_PAUSE_SERVICE);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_SERVER_PAUSE_SERVICE,
								     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
								     fFlags | lPauseFlag);

            strMenuItem.LoadString(IDS_SERVER_RESUME_SERVICE);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_SERVER_RESUME_SERVICE,
								     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
                                     fFlags | lResumeFlag);

            strMenuItem.LoadString(IDS_SERVER_RESTART_SERVICE);
		    hr = LoadAndAddMenuItem( pContextMenuCallback, 
								     strMenuItem, 
								     IDS_SERVER_RESTART_SERVICE,
								     CCM_INSERTIONPOINTID_PRIMARY_TASK, 
                                     fFlags | lStopFlag);

            /* Don't do this in the snapin, go back to the old command prompt way
			            strMenuItem.LoadString(IDS_SERVER_COMPACT);
			            hr = LoadAndAddMenuItem( pContextMenuCallback, 
									             strMenuItem, 
									             IDS_SERVER_COMPACT,
									             CCM_INSERTIONPOINTID_PRIMARY_TASK, 
									             fFlags );
			            ASSERT( SUCCEEDED(hr) );
            */
        }
    }

	return hr; 
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::OnCommand
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsServerHandler::OnCommand
(
	ITFSNode *			pNode, 
	long				nCommandId, 
	DATA_OBJECT_TYPES	type, 
	LPDATAOBJECT		pDataObject, 
	DWORD				dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

	switch (nCommandId)
	{
		case IDS_SHOW_SERVER_STATS:
			ShowServerStatDialog(pNode);
			break;
		
		case IDS_SERVER_BACKUP:
			DoDBBackup(pNode);
			break;

		case IDS_SERVER_SCAVENGE:
			DoDBScavenge(pNode);
			break;

		case IDS_SERVER_COMPACT:
			DoDBCompact(pNode);
			break;

		case IDS_SERVER_RESTORE:
			DoDBRestore(pNode);
			break;

		case IDS_DO_CONSISTENCY_CHECK:
			OnDoConsistencyCheck(pNode);
			break;

		case IDS_CHECK_VERSION_CONSISTENCY:
			OnDoVersionConsistencyCheck(pNode);
			break;

	    case IDS_REP_SEND_PUSH_TRIGGER:
		    hr = OnSendPushTrigger(pNode);
		    break;

	    case IDS_REP_SEND_PULL_TRIGGER:
		    hr = OnSendPullTrigger(pNode);
		    break;

	    case IDS_SERVER_STOP_SERVICE:
		    hr = OnControlService(pNode, FALSE);
		    break;

	    case IDS_SERVER_START_SERVICE:
		    hr = OnControlService(pNode, TRUE);
		    break;

	    case IDS_SERVER_PAUSE_SERVICE:
		    hr = OnPauseResumeService(pNode, TRUE);
		    break;

	    case IDS_SERVER_RESUME_SERVICE:
		    hr = OnPauseResumeService(pNode, FALSE);
		    break;
	    
        case IDS_SERVER_RESTART_SERVICE:
		    hr = OnRestartService(pNode);
		    break;

        default:
			break;
	}

	return hr;
}


/*!--------------------------------------------------------------------------
	CWinsServerHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsServerHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrOK;
		Assert(FALSE); // should never get here
	}
	else
	{
		// we have property pages in the normal case, but don't put the
		// menu up if we are not loaded yet
		if ( m_nState != loaded )
		{
			hr = hrFalse;
		}
		else
		{
			hr = hrOK;
		}
	}
	return hr;
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::CreatePropertyPages
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsServerHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT	            hr = hrOK;
	HPROPSHEETPAGE      hPage;
	SPIComponentData    spComponentData;

	Assert(pNode->GetData(TFS_DATA_COOKIE) != 0);
	
	//
	// Object gets deleted when the page is destroyed
	//
	m_spNodeMgr->GetComponentData(&spComponentData);

	ConnectToWinsServer(pNode);

	// to read the values from the registry
	DWORD err = m_cConfig.Load(GetBinding());

	// unable to read the registry
	if (err != ERROR_SUCCESS)
	{
		::WinsMessageBox(WIN32_FROM_HRESULT(err));
		return hrOK;
	}

	CServerProperties * pServerProp = 
		new CServerProperties(pNode, spComponentData, m_spTFSCompData, NULL);
	pServerProp->m_pageGeneral.m_uImage = GetImageIndex(FALSE);
    pServerProp->SetConfig(&m_cConfig);

	Assert(lpProvider != NULL);

	return pServerProp->CreateModelessSheet(lpProvider, handle);
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnPropertyChange
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CServerProperties * pServerProp
		= reinterpret_cast<CServerProperties *>(lParam);

	LONG_PTR changeMask = 0;

	// tell the property page to do whatever now that we are back on the
	// main thread
	pServerProp->OnPropertyChange(TRUE, &changeMask);

	pServerProp->AcknowledgeNotify();

	if (changeMask)
		pNode->ChangeNode(changeMask);

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsServer::Command
		Handles commands for the current view
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsServerHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT     hr = S_OK;

	switch (nCommandID)
	{
        case MMCC_STANDARD_VIEW_SELECT:
            break;

        // this may have come from the scope pane handler, so pass it up
        default:
            hr = HandleScopeCommand(cookie, nCommandID, pDataObject);
            break;
    }

    return hr;
}


/*!--------------------------------------------------------------------------
	CWinsServer::AddMenuItems
		Over-ride this to add our view menu item
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsServerHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT             hr = S_OK;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);

    return hr;
}


/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------
	CWinsServerHandler::ShowServerStatDialog(ITFSNode* pNode)
		Displays the ServerStatistics Window
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::ShowServerStatDialog(ITFSNode* pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CThemeContextActivator themeActivator;

	m_dlgStats.SetNode(pNode);
	m_dlgStats.SetServer(m_strServerAddress);

	CreateNewStatisticsWindow(&m_dlgStats,
							  ::FindMMCMainWindow(),
							  IDD_STATS_NARROW);
						  

	HRESULT hr = hrOK;

	return hr;
}


/*!--------------------------------------------------------------------------
	CWinsServerHandler::OnDelete
		The base handler calls this when MMC sends a MMCN_DELETE for a 
		scope pane item.  We just call our delete command handler.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::OnDelete
(
	ITFSNode *	pNode, 
	LPARAM		arg, 
	LPARAM		lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT					hr = S_OK;
    LONG					err = 0 ;
    CString					strMessage, strTemp;
	SPITFSNode				spParent;
	CWinsStatusHandler		*pStat = NULL;
	CWinsRootHandler		*pRoot = NULL;
    CThemeContextActivator themeActivator;

	strTemp = m_strServerAddress;

	AfxFormatString1(strMessage, 
					IDS_DELETE_SERVER,
					m_strServerAddress);

	if (AfxMessageBox(strMessage, MB_YESNO) != IDYES)
		return NOERROR;

	pNode->GetParent(&spParent);
	pRoot = GETHANDLER(CWinsRootHandler, spParent);

	// remove the node from the status node as well
	pStat = GETHANDLER(CWinsStatusHandler, pRoot->m_spStatusNode);
	pStat->DeleteNode(pRoot->m_spStatusNode, this);
	
	// remove this node from the list, there's nothing we need to tell
	// the server, it's just our local list of servers
	spParent->RemoveChild(pNode);

	return hr;
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::LoadColumns()
		Description
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::LoadColumns(ITFSComponent * pComponent, 
								MMC_COOKIE  cookie, 
								LPARAM      arg, 
								LPARAM      lParam)
{
	HRESULT hr = hrOK;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	SPIHeaderCtrl spHeaderCtrl;
	pComponent->GetHeaderCtrl(&spHeaderCtrl);

	CString str;
	int i = 0;

	CString strTemp;
	
	strTemp = m_strServerAddress;
	
	while( i< ARRAYLEN(aColumnWidths[1]))
	{
		if (i == 0)
		{
			AfxFormatString1(str, IDS_WINSSERVER_NAME, strTemp);

			int nTest = spHeaderCtrl->InsertColumn(i, 
									   const_cast<LPTSTR>((LPCWSTR)str), 
									   LVCFMT_LEFT,
									   aColumnWidths[1][0]);
			i++;
		}
		else
		{
			str.LoadString(IDS_DESCRIPTION);
			int nTest = spHeaderCtrl->InsertColumn(1, 
									   const_cast<LPTSTR>((LPCWSTR)str), 
									   LVCFMT_LEFT,
									   aColumnWidths[1][1]);
			i++;
		}

		if(aColumns[0][i] == 0)
			break;
	}
	return hrOK;
}


/*!--------------------------------------------------------------------------
	CWinsServerHandler::GetStatistics()
		Gets the statistics from the server
	Author: v-shubk
---------------------------------------------------------------------------*/
DWORD   
CWinsServerHandler::GetStatistics(ITFSNode * pNode, PWINSINTF_RESULTS_T * ppStats)
{
	DWORD dwStatus = ERROR_SUCCESS;
	CString strName, strIP;

    if (ppStats)
        *ppStats = NULL; 

	if (m_dwStatus != ERROR_SUCCESS)
		m_dwStatus = ConnectToWinsServer(pNode);
	
	if (m_dwStatus == ERROR_SUCCESS)
	{
		m_wrResults.WinsStat.NoOfPnrs = 0;
		m_wrResults.WinsStat.pRplPnrs = 0;
		m_wrResults.NoOfWorkerThds = 1;

#ifdef WINS_CLIENT_APIS
		dwStatus = ::WinsStatus(m_hBinding, WINSINTF_E_STAT, &m_wrResults);
#else
		dwStatus = ::WinsStatus(WINSINTF_E_STAT, &m_wrResults);
#endif WINS_CLIENT_APIS

	    if (dwStatus == ERROR_SUCCESS)
        {
            if (ppStats)
                *ppStats = &m_wrResults; 
        }
    }
    else
    {
        dwStatus = m_dwStatus;
    }

    return dwStatus;
}


/*!--------------------------------------------------------------------------
	CWinsServerHandler::ClearStatistics()
		Clears the statistics from the server
	Author: v-shubk
---------------------------------------------------------------------------*/
DWORD
CWinsServerHandler::ClearStatistics(ITFSNode *pNode)
{
	DWORD dwStatus = ERROR_SUCCESS;

	CString strName, strIP;

	if (m_dwStatus != ERROR_SUCCESS)
		m_dwStatus = ConnectToWinsServer(pNode);
	
	if (m_dwStatus == ERROR_SUCCESS)
	{
#ifdef WINS_CLIENT_APIS
		dwStatus = ::WinsResetCounters(m_hBinding);
#else
		dwStatus = ::WinsResetCounters();
#endif WINS_CLIENT_APIS
	}
    else
    {
        dwStatus = m_dwStatus;
    }

    return dwStatus;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::ConnectToWinsServer()
		Connects to the wins server
	Author: v-shubk
---------------------------------------------------------------------------*/
DWORD
CWinsServerHandler::ConnectToWinsServer(ITFSNode *pNode)
{
	HRESULT hr = hrOK;

	CString					strServerName, strIP;
	DWORD					dwStatus = ERROR_SUCCESS;
    WINSINTF_ADD_T			waWinsAddress;
	WINSINTF_BIND_DATA_T    wbdBindData;

    // build some information about the server
    strServerName = GetServerAddress();
    DWORD dwIP = GetServerIP();
    MakeIPAddress(dwIP, strIP);

    DisConnectFromWinsServer();

    // now that the server name and ip are valid, call
	// WINSBind function directly.
	do
	{
        char szNetBIOSName[128] = {0};

        // call WinsBind function with the IP address
		wbdBindData.fTcpIp = 1;
		wbdBindData.pPipeName = NULL;
        wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) strIP;

		BEGIN_WAIT_CURSOR

		if ((m_hBinding = ::WinsBind(&wbdBindData)) == NULL)
		{
			m_dwStatus = ::GetLastError();
			break;
		}

#ifdef WINS_CLIENT_APIS
		m_dwStatus = ::WinsGetNameAndAdd(m_hBinding, &waWinsAddress, (LPBYTE) szNetBIOSName);
#else
		m_dwStatus = ::WinsGetNameAndAdd(&waWinsAddress, (LPBYTE) szNetBIOSName);
#endif WINS_CLIENT_APIS

		END_WAIT_CURSOR

    } while (FALSE);

    return m_dwStatus;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::DoDBBackup()
		backs up the database
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::DoDBBackup(ITFSNode *pNode)
{
	HRESULT hr = hrOK;

	DWORD dwStatus = ConnectToWinsServer(pNode);

    CString strBackupPath;
	CString strHelpText;
	strHelpText.LoadString(IDS_SELECT_BACKUP_FOLDER);

	if (GetFolderName(strBackupPath, strHelpText))
    {
	    dwStatus = BackupDatabase(strBackupPath);
	    
	    if (dwStatus == ERROR_SUCCESS)
	    {
            CThemeContextActivator themeActivator;

		    AfxMessageBox(IDS_DB_BACKUP_SUCCESS, MB_ICONINFORMATION | MB_OK);
		
            // don't update the default path just because they selected a path here
            //if (m_cConfig.m_strBackupPath.CompareNoCase(strBackupPath) != 0)
		    //{
			//    m_cConfig.m_strBackupPath = strBackupPath;
			//    m_cConfig.Store();
		    //}
	    }
	    else
        {
		    ::WinsMessageBox(dwStatus, MB_OK);
        }
    }

	return HRESULT_FROM_WIN32(dwStatus);
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::BackupDatabase(CString strBackupPath)
		Calls WINS API for backing the database
	Author: v-shubk
---------------------------------------------------------------------------*/
DWORD
CWinsServerHandler::BackupDatabase(CString strBackupPath)
{
	BOOL    fIncremental = FALSE;
    BOOL    fDefaultCharUsed = FALSE;
	DWORD   dwStatus = ERROR_SUCCESS; 
    char    szTemp[MAX_PATH] = {0};

    // INTL$ Should this be ACP or OEMCP?
    WideToMBCS(strBackupPath, szTemp, CP_ACP, 0, &fDefaultCharUsed);

    if (fDefaultCharUsed)
    {
        // could not convert this string...  error out
        dwStatus = IDS_ERR_CANT_CONVERT_STRING;
    }
    else
    {
    	BEGIN_WAIT_CURSOR

#ifdef WINS_CLIENT_APIS
	    dwStatus = ::WinsBackup(m_hBinding, (unsigned char *)szTemp, (short)fIncremental);
#else
	    dwStatus = ::WinsBackup((unsigned char *)szTemp, (short)fIncremental);
#endif WINS_CLIENT_APIS

	    END_WAIT_CURSOR
    }

	return dwStatus;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::DoDBCompact()
		backs up the database
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::DoDBCompact(ITFSNode *pNode)
{
	HRESULT     hr = hrOK;
    CThemeContextActivator themeActivator;

	// tell the user that we need to stop WINS in order to do this
    if (AfxMessageBox(IDS_WARN_SERVICE_STOP, MB_YESNO) == IDNO)
        return hr;

	CDBCompactProgress dlgCompactProgress;

	dlgCompactProgress.m_dwIpAddress = m_dwIPAdd;
	dlgCompactProgress.m_strServerName = m_strServerAddress;
	dlgCompactProgress.m_hBinding = GetBinding();
	dlgCompactProgress.m_pConfig = &m_cConfig;

	dlgCompactProgress.DoModal();

	// since the service gets restarted, the new binding handle is in the object
	m_hBinding = dlgCompactProgress.m_hBinding;

	return hr;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::DoDBRestore()	
		Restores the database
	Author:v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::DoDBRestore(ITFSNode *pNode)
{
    DWORD   dwStatus = 0; 
	DWORD   err = ERROR_SUCCESS;
	HRESULT hr = hrOK;

    CString strRestorePath;
	CString strHelpText;
	strHelpText.LoadString(IDS_SELECT_RESTORE_FOLDER);

	if (GetFolderName(strRestorePath, strHelpText))
    {
        BOOL fOldBackup = m_cConfig.m_fBackupOnTermination;

        if (!strRestorePath.IsEmpty())
	    {
		    BEGIN_WAIT_CURSOR

            // need to disable backup on shutdown since we need to shutdown
            // the server to do this and we don't want it to backup and stomp
            // over what we may want to restore.
            if (fOldBackup)
            {
                m_cConfig.m_fBackupOnTermination = FALSE;
                m_cConfig.Store();
            }

            DisConnectFromWinsServer();

            // convert the string from unicode to DBCS for the WINS API
            char szTemp[MAX_PATH * 2] = {0};
            BOOL fDefaultCharUsed = FALSE;

            // INTL$ should this be ACP or OEMCP?
            WideToMBCS(strRestorePath, szTemp, CP_ACP, 0, &fDefaultCharUsed);

            // if there is no code page available for conversion, error out
            if (fDefaultCharUsed)
            {
                dwStatus = IDS_ERR_CANT_CONVERT_STRING;
            }
            else
            {
                dwStatus = ::WinsRestore((LPBYTE) szTemp);
            }

		    END_WAIT_CURSOR

            if (dwStatus == ERROR_SUCCESS)
		    {
			    // re-start the WINS service that was stopped
			    CString strServiceDesc;
			    strServiceDesc.LoadString(IDS_SERVICE_NAME);
			    err = TFSStartServiceEx(m_strServerAddress, _T("wins"), _T("WINS Service"), strServiceDesc);
			    
			    // connect to the server again
			    ConnectToWinsServer(pNode);
                CThemeContextActivator themeActivator;

                // let the user know everything went OK.
                AfxMessageBox(IDS_DB_RESTORE_SUCCESS, MB_ICONINFORMATION | MB_OK);
            }
		    else
		    {
			    ::WinsMessageBox(dwStatus, MB_OK);
		    }

            hr = HRESULT_FROM_WIN32(dwStatus);

            // restore the backup on shutdown flag if necessary
            if (fOldBackup)
            {
                m_cConfig.m_fBackupOnTermination = TRUE;
                m_cConfig.Store();
            }

		    if (SUCCEEDED(hr))
		    {
			    // need to refresh the server node because this can only be triggered
			    // if the service wasn't running
			    if (m_pNameThread)
			    {
				    m_pNameThread->Abort();
				    m_pNameThread = NULL;
			    }

			    OnRefresh(pNode, NULL, 0, 0, 0);
		    }
	    }
    }

    return hr;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnControlService
        -
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsServerHandler::OnControlService
(
    ITFSNode *  pNode,
    BOOL        fStart
)
{
    HRESULT hr = hrOK;
    DWORD   err = ERROR_SUCCESS;
	CString strServiceDesc;
	
    strServiceDesc.LoadString(IDS_SERVICE_NAME);

    if (fStart)
    {
		err = TFSStartServiceEx(m_strServerAddress, _T("wins"), _T("WINS Service"), strServiceDesc);
    }
    else
    {
		err = TFSStopServiceEx(m_strServerAddress, _T("wins"), _T("WINS Service"), strServiceDesc);
    }

    if (err == ERROR_SUCCESS)
    {
		// need to refresh the server node because this can only be triggered
		// if the service wasn't running
		if (m_pNameThread)
		{
			m_pNameThread->Abort();
			m_pNameThread = NULL;
		}

        if (!fStart)
            m_fSilent = TRUE;

		OnRefresh(pNode, NULL, 0, 0, 0);
    }
    else
    {
        WinsMessageBox(err);
        hr = HRESULT_FROM_WIN32(err);
    }
    
    return hr;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnPauseResumeService
        -
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsServerHandler::OnPauseResumeService
(
    ITFSNode *  pNode,
    BOOL        fPause
)
{
    HRESULT hr = hrOK;
    DWORD   err = ERROR_SUCCESS;
	CString strServiceDesc;
	
    strServiceDesc.LoadString(IDS_SERVICE_NAME);

    if (fPause)
    {
		err = TFSPauseService(m_strServerAddress, _T("wins"), strServiceDesc);
    }
    else
    {
		err = TFSResumeService(m_strServerAddress, _T("wins"), strServiceDesc);
    }

    if (err != ERROR_SUCCESS)
    {
        WinsMessageBox(err);
        hr = HRESULT_FROM_WIN32(err);
    }
    
    return hr;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnRestartService
        -
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsServerHandler::OnRestartService
(
    ITFSNode *  pNode
)
{
    HRESULT hr = hrOK;
    DWORD   err = ERROR_SUCCESS;
	CString strServiceDesc;
	
    strServiceDesc.LoadString(IDS_SERVICE_NAME);

	err = TFSStopServiceEx(m_strServerAddress, _T("wins"), _T("WINS Service"), strServiceDesc);
    if (err != ERROR_SUCCESS)
    {
        WinsMessageBox(err);
        hr = HRESULT_FROM_WIN32(err);
    }

    if (SUCCEEDED(hr))
    {
		err = TFSStartServiceEx(m_strServerAddress, _T("wins"), _T("WINS Service"), strServiceDesc);
        if (err != ERROR_SUCCESS)
        {
            WinsMessageBox(err);
            hr = HRESULT_FROM_WIN32(err);
        }
    }

    // refresh
    OnRefresh(pNode, NULL, 0, 0, 0);

    return hr;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::UpdateStatistics
        Notification that stats are now available.  Update stats for the 
        server node and give all subnodes a chance to update.
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CWinsServerHandler::UpdateStatistics
(
    ITFSNode * pNode
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned;
    HWND            hStatsWnd;
	BOOL			bChangeIcon = FALSE;

    // Check to see if this node has a stats sheet up.
    hStatsWnd = m_dlgStats.GetSafeHwnd();
    if (hStatsWnd != NULL)
    {
        PostMessage(hStatsWnd, WM_NEW_STATS_AVAILABLE, 0, 0);
    }
    
    return hr;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::DoDBScavenge()	
		Scavenges the database
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::DoDBScavenge(ITFSNode *pNode)
{
	HRESULT hr = hrOK;
	DWORD dwStatus; 

	if (m_dwStatus != ERROR_SUCCESS)
	{
		 dwStatus = ConnectToWinsServer(pNode);
	}

#ifdef WINS_CLIENT_APIS
	dwStatus = ::WinsDoScavenging(m_hBinding);
#else
	dwStatus = ::WinsDoScavenging();
#endif WINS_CLIENT_APIS

	if (dwStatus == ERROR_SUCCESS)
	{
		CString strDisp;
		CString strTemp;
        CThemeContextActivator themeActivator;
		
        strTemp.LoadString(IDS_SCAVENGE_COMMAND);

        AfxFormatString1(strDisp, IDS_QUEUED_MESSAGE, strTemp);
		AfxMessageBox(strDisp, MB_ICONINFORMATION|MB_OK);

		BEGIN_WAIT_CURSOR

		// refresh the stats
		m_wrResults.WinsStat.NoOfPnrs = 0;
		m_wrResults.WinsStat.pRplPnrs = 0;
		m_wrResults.NoOfWorkerThds = 1;

#ifdef WINS_CLIENT_APIS
		dwStatus = ::WinsStatus(m_hBinding, WINSINTF_E_CONFIG, &m_wrResults);
#else
		dwStatus = ::WinsStatus(WINSINTF_E_CONFIG, &m_wrResults);
#endif WINS_CLIENT_APIS

		UpdateStatistics(pNode);

		END_WAIT_CURSOR
	}
	else
    {
		::WinsMessageBox(dwStatus, MB_OK);
    }

	return HRESULT_FROM_WIN32(dwStatus);
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::IsValidNetBIOSName
		Determine if the given netbios is valid, and pre-pend
		a double backslash if not already present (and the address
		is otherwise valid).	
---------------------------------------------------------------------------*/
BOOL
CWinsServerHandler::IsValidNetBIOSName
(
    CString &   strAddress,
    BOOL        fLanmanCompatible,
    BOOL        fWackwack // expand slashes if not present
)
{
    TCHAR szWacks[] = _T("\\\\");

    if (strAddress.IsEmpty())
    {
        return FALSE;
    }

    if (strAddress[0] == _T('\\'))
    {
        if (strAddress.GetLength() < 3)
        {
            return FALSE;
        }

        if (strAddress[1] != _T('\\'))
        {
            // One slash only?  Not valid
            return FALSE;
        }
    }
    else
    {
        if (fWackwack)
        {
            // Add the backslashes
            strAddress = szWacks + strAddress;
        }
    }

    int nMaxAllowedLength = fLanmanCompatible
        ? LM_NAME_MAX_LENGTH
        : NB_NAME_MAX_LENGTH;

    if (fLanmanCompatible)
    {
        strAddress.MakeUpper();
    }

    return strAddress.GetLength() <= nMaxAllowedLength + 2;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnResultRefresh
		Refreshes the data relating to the server
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    if (m_pNameThread)
    {
        m_pNameThread->Abort();
        m_pNameThread = NULL;
    }

    OnRefresh(spNode, pDataObject, 0, arg, lParam);

Error:
    return hr;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnDoConsistencyCheck(ITFSNode *pNode)
		Consisntency Check for WINS
	Author - v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::OnDoConsistencyCheck(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CThemeContextActivator themeActivator;

	HRESULT hr = hrOK;
	
	if(IDYES != AfxMessageBox(IDS_CONSISTENCY_CONFIRM, MB_YESNO))
		return hrFalse;

	WINSINTF_SCV_REQ_T ScvReq;

	ScvReq.Age = 0;				// check all the replicas
	ScvReq.fForce = FALSE;
	ScvReq.Opcode_e = WINSINTF_E_SCV_VERIFY;

#ifdef WINS_CLIENT_APIS
	DWORD dwStatus = ::WinsDoScavengingNew(m_hBinding, &ScvReq);
#else
	DWORD dwStatus = ::WinsDoScavengingNew(&ScvReq);
#endif WINS_CLIENT_APIS

	if(dwStatus == ERROR_SUCCESS)
	{	
		CString strDisp, strJob;
		strJob.Format(IDS_DO_CONSISTENCY_CHECK_STR);

		AfxFormatString1(strDisp,IDS_QUEUED_MESSAGE, strJob);
		
		AfxMessageBox(strDisp, MB_OK);
	}
	else
	{
		::WinsMessageBox(dwStatus, MB_OK);
	}

	return hr;
}

/*---------------------------------------------------------------------------
	CWInsServerHandler::OnDoVersionConsistencyCheck(ITFSNode *pNode)
		Performs the version number consistency check 
	Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::OnDoVersionConsistencyCheck(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    CThemeContextActivator themeActivator;

	HRESULT hr = hrOK;

	if (IDYES != AfxMessageBox(IDS_VERSION_CONSIS_CHECK_WARNING, MB_YESNO))
		return hrOK;
	
	CCheckVersionProgress dlgCheckVersions;

	dlgCheckVersions.m_dwIpAddress = m_dwIPAdd;
	dlgCheckVersions.m_hBinding = GetBinding();
	dlgCheckVersions.DoModal();
	
	return hr;
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::OnSendPushTrigger()
		Sends Push replication trigger
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::OnSendPushTrigger(ITFSNode * pNode)
{
	HRESULT hr = hrOK;
	DWORD   err = ERROR_SUCCESS;

	CPushTrig           dlgPushTrig;
    CGetTriggerPartner	dlgTrigPartner;
    CThemeContextActivator themeActivator;

    if (dlgTrigPartner.DoModal() != IDOK)
        return hr;

	if (dlgPushTrig.DoModal() != IDOK)
		return hr;

    err = ::SendTrigger(GetBinding(), 
                        (LONG) dlgTrigPartner.m_dwServerIp,
                        TRUE, 
                        dlgPushTrig.GetPropagate());

	if (err == ERROR_SUCCESS)
	{
		AfxMessageBox(IDS_REPL_QUEUED, MB_ICONINFORMATION);
	}
    else
    {
        WinsMessageBox(err);
    }

	return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::OnSendPullTrigger()
		Sends Pull replication trigger
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsServerHandler::OnSendPullTrigger(ITFSNode * pNode)
{
	HRESULT hr = hrOK;
	DWORD   err = ERROR_SUCCESS;

	CPullTrig           dlgPullTrig;
    CGetTriggerPartner	dlgTrigPartner;
    CThemeContextActivator themeActivator;

    if (dlgTrigPartner.DoModal() != IDOK)
        return hr;

	if (dlgPullTrig.DoModal() != IDOK)
		return hr;

    err = ::SendTrigger(GetBinding(), 
                        (LONG) dlgTrigPartner.m_dwServerIp,
                        FALSE, 
                        FALSE);

	if (err == ERROR_SUCCESS)
	{
		AfxMessageBox(IDS_REPL_QUEUED, MB_ICONINFORMATION);
	}
	else
	{
		::WinsMessageBox(err);
	}

	return HRESULT_FROM_WIN32(err);
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::GetFolderName(CString& strPath)
		Returns the folder name after displaying the 
		File Dialog
---------------------------------------------------------------------------*/
BOOL
CWinsServerHandler::GetFolderName(CString& strPath, CString& strHelpText)
{
    BOOL  fOk = FALSE;
	TCHAR szBuffer[MAX_PATH];
    TCHAR szExpandedPath[MAX_PATH * 2];

    CString strStartingPath = m_cConfig.m_strBackupPath;
    if (strStartingPath.IsEmpty())
    {
        strStartingPath = _T("%SystemDrive%\\");
    }

    ExpandEnvironmentStrings(strStartingPath, szExpandedPath, sizeof(szExpandedPath) / sizeof(TCHAR));

	LPITEMIDLIST pidlPrograms = NULL; 
	SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlPrograms);

	BROWSEINFO browseInfo;
    browseInfo.hwndOwner = ::FindMMCMainWindow();
	browseInfo.pidlRoot = pidlPrograms;            
	browseInfo.pszDisplayName = szBuffer;  
	
    browseInfo.lpszTitle = strHelpText;
    browseInfo.ulFlags = BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS ;            
    browseInfo.lpfn = BrowseCallbackProc;        

    browseInfo.lParam = (LPARAM) szExpandedPath;
	
	LPITEMIDLIST pidlBrowse = SHBrowseForFolder(&browseInfo);

	fOk = SHGetPathFromIDList(pidlBrowse, szBuffer); 

	CString strBackupPath(szBuffer);
	strPath = strBackupPath;

    LPMALLOC pMalloc = NULL;

    if (pidlPrograms && SUCCEEDED(SHGetMalloc(&pMalloc)))
    {
        if (pMalloc)
            pMalloc->Free(pidlPrograms);
    }

    return fOk;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::SetExtensionName()
		-
	Author: EricDav
---------------------------------------------------------------------------*/
void 
CWinsServerHandler::SetExtensionName()
{
    SetDisplayName(_T("WINS"));
    m_bExtension = TRUE;
}


/*---------------------------------------------------------------------------
	CWinsServerHandler::IsLocalConnection()
		Checks if the local server is being managed
	Author: v-shubk
---------------------------------------------------------------------------*/
BOOL 
CWinsServerHandler::IsLocalConnection()
{
	// get the server netbios name
	CString strServerName = m_strServerAddress;
	
	TCHAR lpBuffer[MAX_COMPUTERNAME_LENGTH + 1]; // address of name buffer  
	
	DWORD nSize   = MAX_COMPUTERNAME_LENGTH + 1;
	::GetComputerName(lpBuffer,&nSize);
	
	CString strCompName(lpBuffer);

	if(strCompName.CompareNoCase(strServerName) == 0)
		return TRUE;
	
	return FALSE;

}

/*---------------------------------------------------------------------------
	CWinsServerHandler:: DeleteWinsServer(CWinsServerObj* pws)
		Calls WinsAPI to delete the server
	Author: v-shubk
 ---------------------------------------------------------------------------*/
DWORD 
CWinsServerHandler:: DeleteWinsServer
(
	DWORD	dwIpAddress
)
{
	DWORD err = ERROR_SUCCESS;

	WINSINTF_ADD_T  WinsAdd;

    WinsAdd.Len  = 4;
    WinsAdd.Type = 0;
    WinsAdd.IPAdd  = dwIpAddress;

#ifdef WINS_CLIENT_APIS
    err =  ::WinsDeleteWins(GetBinding(), &WinsAdd);

#else
	err =  ::WinsDeleteWins(&WinsAdd);

#endif WINS_CLIENT_APIS
	
	return err;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::DisConnectFromWinsServer()  
		Calls WinsUnbind and makes the binding handle invalid
---------------------------------------------------------------------------*/
void 
CWinsServerHandler::DisConnectFromWinsServer()  
{
	if (m_hBinding)
	{
		CString					strIP;
		WINSINTF_BIND_DATA_T    wbdBindData;
		DWORD					dwIP = GetServerIP();

		MakeIPAddress(dwIP, strIP);

		wbdBindData.fTcpIp = 1;
		wbdBindData.pPipeName = NULL;
        wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) strIP;
		
		::WinsUnbind(&wbdBindData, m_hBinding);
		
		m_hBinding = NULL;
	}
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::CheckIfNT351Server()
		Checks if a 351 server is being managed
---------------------------------------------------------------------------*/
BOOL
CWinsServerHandler::CheckIfNT351Server()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	DWORD				err = ERROR_SUCCESS;
	CString				lpstrRoot;
    CString				lpstrVersion;
	CString				strVersion;
    BOOL                f351 = FALSE;

    // don't go to the registry each time -- we have the info in our config object
    // 7/8/98 - EricDav

	/*
    // connect to the registry of the server to find if 
	// it's a 351 server
	lpstrRoot = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
	lpstrVersion = _T("CurrentVersion");

	RegKey rk;

	err = rk.Open(HKEY_LOCAL_MACHINE, lpstrRoot, KEY_READ, m_strServerAddress);
	
	// Get the count of items
	if (!err)
		err = rk.QueryValue(lpstrVersion,strVersion) ;

	if(strVersion.CompareNoCase(_T("3.51")) == 0 )
		return TRUE;

	return FALSE;
    */

    if (m_cConfig.m_dwMajorVersion < 4)
    {
        f351 = TRUE;
    }

    return f351;
}

/*---------------------------------------------------------------------------
	CWinsServerHandler::SetDisplay()
		Sets the node name to either the host name or FQDN
---------------------------------------------------------------------------*/
void
CWinsServerHandler::SetDisplay(ITFSNode * pNode, BOOL fFQDN)
{
    CHAR szHostName[MAX_PATH] = {0};
	CString strIPAdd, strDisplay;
            
    ::MakeIPAddress(m_dwIPAdd, strIPAdd);

    if (fFQDN)
    {
        // check if the server name was resolved and added
        if (m_dwIPAdd != 0)
        {
            // default is ACP.  This should use ACP because winsock uses ACP
            WideToMBCS(m_strServerAddress, szHostName);
            
			HOSTENT * pHostent = ::gethostbyname((CHAR *) szHostName);
			if (pHostent)
			{
                CString strFQDN;

                MBCSToWide(pHostent->h_name, strFQDN);
				
                strFQDN.MakeLower();
				strDisplay.Format(IDS_SERVER_NAME_FORMAT, strFQDN, strIPAdd);

				SetDisplayName(strDisplay);

				if (pNode)
                    pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_DATA);
			}   
			
		}
	}
	// if not FQDN
	else
	{
		if (m_dwIPAdd != 0)
        {
            strDisplay.Format(IDS_SERVER_NAME_FORMAT, m_strServerAddress, strIPAdd);
        }
		else
        {
			strDisplay = m_strServerAddress;
        }

		SetDisplayName(strDisplay);

		if (pNode)
            pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_DATA);
	}

}

void 
CWinsServerHandler::GetErrorInfo(CString & strTitle, CString & strBody, IconIdentifier * pIcon)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    TCHAR szBuffer[MAX_PATH * 2];

    // build the body text
    LoadMessage(m_dwErr, szBuffer, sizeof(szBuffer) / sizeof(TCHAR));
    AfxFormatString1(strBody, IDS_SERVER_MESSAGE_BODY, szBuffer);

    CString strTemp;
    strTemp.LoadString(IDS_SERVER_MESSAGE_BODY_REFRESH);

    strBody += strTemp;

    // get the title
    strTitle.LoadString(IDS_SERVER_MESSAGE_TITLE);

    // and the icon
    if (pIcon)
    {
        *pIcon = Icon_Error;
    }
}

/*---------------------------------------------------------------------------
	Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CWinsServerHandler::OnCreateQuery
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CWinsServerHandler::OnCreateQuery(ITFSNode * pNode)
{
	CWinsServerQueryObj* pQuery = NULL;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        m_pNameThread = new CNameThread();
    
        pQuery = new CWinsServerQueryObj(m_spTFSCompData, m_spNodeMgr);
	    
	    pQuery->m_strServer = GetServerAddress();
        pQuery->m_dwIPAdd = m_dwIPAdd;

        pQuery->m_pNameThread = m_pNameThread;
        pQuery->m_pServerInfoArray = &m_ServerInfoArray;
    }
    COM_PROTECT_CATCH

    return pQuery;
}

/*---------------------------------------------------------------------------
    CWinsServerHandler::OnEventAbort
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CWinsServerQueryObj::OnEventAbort
(
	DWORD dwData,
	DWORD dwType
)
{
	if (dwType == WINS_QDATA_SERVER_INFO)
	{
		Trace0("CWinsServerHandler::OnEventAbort - deleting version");
		delete ULongToPtr(dwData);
	}
}

/*---------------------------------------------------------------------------
	CWinsServerQueryObj::Execute()
		Enumerates everything about a server
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CWinsServerQueryObj::Execute()
{
	HRESULT					hr = hrOK;
	WINSINTF_BIND_DATA_T	wbdBindData;
	CString					strName, strIp;
	DWORD					dwStatus = ERROR_SUCCESS;
	DWORD					dwIp;
	CServerData	*			pServerInfo;

	// need to get the server name and IP address if the server is added 
	// with Do not connect option
	dwStatus = ::VerifyWinsServer(m_strServer, strName, dwIp);
	if (dwStatus != ERROR_SUCCESS)
	{
		Trace1("CWinsServerQueryObj::Execute() - VerifyWinsServer failed! %d\n", dwStatus);

        // Use the existing information we have to try and connect
        if (m_dwIPAdd)
        {
            // we couldn't resolve the name so just use what we have and try to connect
            strName = m_strServer;
            dwIp = m_dwIPAdd;
        }
        else
        {
            // we don't have an IP for this and we can't resolve the name, so error out
		    PostError(dwStatus);
		    return hrFalse;
        }
	}

	pServerInfo = new CServerData;

	::MakeIPAddress(dwIp, strIp);

	pServerInfo->m_strServerName = strName;
	pServerInfo->m_dwServerIp = dwIp;
	pServerInfo->m_hBinding = NULL;

	// get a binding for this server
	wbdBindData.fTcpIp = 1;
	wbdBindData.pPipeName = NULL;
	wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) strIp;

	if ((pServerInfo->m_hBinding = ::WinsBind(&wbdBindData)) == NULL)
	{
		dwStatus = ::GetLastError();

		// send what info we have back to the main thread
		AddToQueue((LPARAM) pServerInfo, WINS_QDATA_SERVER_INFO);

		Trace1("CWinsServerQueryObj::Execute() - WinsBind failed! %d\n", dwStatus);
		PostError(dwStatus);
		return hrFalse;
	}
		
	// load the configuration object
	//pServerInfo->m_config.SetOwner(strName);
	pServerInfo->m_config.SetOwner(strIp);
	dwStatus = pServerInfo->m_config.Load(pServerInfo->m_hBinding);
	if (dwStatus != ERROR_SUCCESS)
	{
		// send what info we have back to the main thread
		AddToQueue((LPARAM) pServerInfo, WINS_QDATA_SERVER_INFO);

		Trace1("CWinsServerQueryObj::Execute() - Load configuration failed! %d\n", dwStatus);
		PostError(dwStatus);
		return hrFalse;
	}

	// send all of the information back to the main thread here
    handle_t hBinding = pServerInfo->m_hBinding;

	AddToQueue((LPARAM) pServerInfo, WINS_QDATA_SERVER_INFO);

	// build the child nodes
	AddNodes(hBinding);

	return hrFalse;
}

/*---------------------------------------------------------------------------
	CWinsServerQueryObj::AddNodes
		Creates the active registrations and replication partners nodes
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CWinsServerQueryObj::AddNodes(handle_t hBinding)
{
	HRESULT				hr = hrOK;
	SPITFSNode			spActReg, spRepPart;
    CServerInfoArray *  pServerInfoArray;
    
	//
	//	active registrations node
	//
	CActiveRegistrationsHandler *pActRegHand = NULL;

	try
	{
		pActRegHand = new CActiveRegistrationsHandler(m_spTFSCompData);
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}
	//
	// Create the actreg container information
	// 
	CreateContainerTFSNode(&spActReg,
						   &GUID_WinsActiveRegNodeType,
						   pActRegHand,
						   pActRegHand,
						   m_spNodeMgr);

	// Tell the handler to initialize any specific data
	pActRegHand->InitializeNode((ITFSNode *) spActReg);

	// load the name type mapping from the registry
	pActRegHand->m_NameTypeMap.SetMachineName(m_strServer);
    pActRegHand->m_NameTypeMap.Load();

    // build the owner mapping
    pActRegHand->m_pServerInfoArray = m_pServerInfoArray;
    pActRegHand->BuildOwnerArray(hBinding);

    // Post this node back to the main thread
	AddToQueue(spActReg);
	pActRegHand->Release();


	//
	//	replication partners node
	//
	CReplicationPartnersHandler *pReplicationHand = NULL;

	try
	{
		pReplicationHand = new CReplicationPartnersHandler (m_spTFSCompData);
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}

	// Create the actreg container information
	CreateContainerTFSNode(&spRepPart,
						   &GUID_WinsReplicationNodeType,
						   pReplicationHand,
						   pReplicationHand,
						   m_spNodeMgr);

	// Tell the handler to initialize any specific data
	pReplicationHand->InitializeNode((ITFSNode *) spRepPart);

    // Post this node back to the main thread
	AddToQueue(spRepPart);
	pReplicationHand->Release();

    // kick off the name query thread
    m_pNameThread->Init(m_pServerInfoArray);
    m_pNameThread->Start();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\srvlatpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	srvlatpp.h
		Brings up the property page for the server node
		
    FILE HISTORY:
        
*/


#if !defined(AFX_SRVLATPP_H__35B59246_47F9_11D1_B9A6_00C04FBF914A__INCLUDED_)
#define AFX_SRVLATPP_H__35B59246_47F9_11D1_B9A6_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _CONFIG_H
#include "config.h"
#endif

#define BURST_QUE_SIZE_LOW      300
#define BURST_QUE_SIZE_MEDIUM   500
#define BURST_QUE_SIZE_HIGH     1000

/////////////////////////////////////////////////////////////////////////////
// CServerPropGeneral dialog

class CServerPropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropGeneral)

// Construction
public:
	CServerPropGeneral();
	~CServerPropGeneral();

// Dialog Data
	//{{AFX_DATA(CServerPropGeneral)
	enum { IDD = IDD_SERVER_PROP_GEN };
	CStatic	m_staticrefresh;
	CStatic	m_staticDesc;
	CEdit	m_editRefreshMn;
	CEdit	m_editRefreshHr;
	CEdit	m_editRefreshSc;
	CSpinButtonCtrl	m_spinRefreshSc;
	CSpinButtonCtrl	m_spinRefreshmn;
	CSpinButtonCtrl	m_spinRefreshHr;
	CEdit	m_editBackupPath;
	CButton	m_check_BackupOnTermination;
	CButton	m_check_EnableAutoRefresh;
	CButton	m_button_Browse;
	BOOL	m_fBackupDB;
	BOOL	m_fEnableAutoRefresh;
	CString	m_strBackupPath;
	int		m_nRefreshHours;
	int		m_nRefreshMinutes;
	int		m_nRefreshSeconds;
	//}}AFX_DATA

	UINT	m_uImage;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropGeneral)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowse();
	afx_msg void OnCheckEnableAutorefresh();
	afx_msg void OnChangeEditBackuppath();
	afx_msg void OnChangeRefresh();
	afx_msg void OnChangeCheckBackupdb();
    //}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CConfiguration *		m_pConfig;
    BOOL                    m_fUpdateRefresh;
    BOOL                    m_fUpdateConfig;

	HRESULT	GetConfig();
	
	HRESULT UpdateServerConfiguration();
	BOOL    UpdateConfig();
	void    SetRefreshData();

	int CalculateRefrInt();

	CString ToString(int nNumber);

	BOOL IsLocalConnection();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CServerPropGeneral::IDD);};

};

/////////////////////////////////////////////////////////////////////////////
// CServerPropDBRecord dialog

class CServerPropDBRecord : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropDBRecord)

// Construction
public:
	CServerPropDBRecord();
	~CServerPropDBRecord();

// Dialog Data
	//{{AFX_DATA(CServerPropDBRecord)
	enum { IDD = IDD_SERVER_PROP_DBRECORD };
	CEdit	m_editExtIntMinute;
	CSpinButtonCtrl	m_spinVerifyMinute;
	CSpinButtonCtrl	m_spinVerifyHour;
	CSpinButtonCtrl	m_spinVerifyDay;
	CSpinButtonCtrl	m_spinRefrIntMinute;
	CSpinButtonCtrl	m_spinRefrIntHour;
	CSpinButtonCtrl	m_spinRefrIntDay;
	CSpinButtonCtrl	m_spinExtTmMinute;
	CSpinButtonCtrl	m_spinExtTmHour;
	CSpinButtonCtrl	m_spinExtTmDay;
	CSpinButtonCtrl	m_spinExtIntMinute;
	CSpinButtonCtrl	m_spinExtIntHour;
	CSpinButtonCtrl	m_spinExtIntDay;
	CEdit	m_editVerifyMinute;
	CEdit	m_editVerifyHour;
	CEdit	m_editVerifyDay;
	CEdit	m_editRefrIntMinute;
	CEdit	m_editRefrIntHour;
	CEdit	m_editRefrIntDay;
	CEdit	m_editExtTmHour;
	CEdit	m_editExtTmMinute;
	CEdit	m_editExtTmDay;
	CEdit	m_editExtIntHour;
	CEdit	m_editExtIntDay;
	int		m_nExtintDay;
	int		m_nExtIntHour;
	int		m_nExtIntMinute;
	int		m_nExtTmDay;
	int		m_nExtTmHour;
	int		m_nExtTmMinute;
	int		m_nRenewDay;
	int		m_nrenewMinute;
	int		m_nRenewMinute;
	int		m_nVerifyDay;
	int		m_nVerifyHour;
	int		m_nVerifyMinute;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropDBRecord)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropDBRecord)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonSetDefault();
	afx_msg void OnChangeEditExtinctIntHour();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private :
	CConfiguration *    m_pConfig;
	HRESULT				GetConfig();
	
	void SetVerifyData();
	void SetExtTimeData();
	void SetExtIntData();

	DWORD CalculateRenewInt();
	DWORD CalculateExtTm();
	DWORD CalculateExtInt();
	DWORD CalculateVerifyInt();

	void SetDefaultRenewInt();
	void SetDefaultExtInt();
	void SetDefaultExtTm();
	void SetDefaultVerifyInt();
    void CalcDaysHoursMinutes(int nValue, int & nDays, int & nHours, int & nMinutes);
	
	HRESULT UpdateServerConfiguration();

	BOOL CheckValues(); 

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CServerPropDBRecord::IDD);};
};


/////////////////////////////////////////////////////////////////////////////
// CServerPropDBVerification dialog

class CServerPropDBVerification : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropDBVerification)

// Construction
public:
	CServerPropDBVerification();
	~CServerPropDBVerification();

// Dialog Data
	//{{AFX_DATA(CServerPropDBVerification)
	enum { IDD = IDD_SERVER_PROP_DBVERIFICATION };
	CEdit	m_editCCSecond;
	CEdit	m_editCCMinute;
	CEdit	m_editCCHour;
	CSpinButtonCtrl	m_spinCCMinute;
	CEdit	m_editCCInterval;
	CEdit	m_editCCMaxChecked;
	CButton	m_radioCheckOwner;
	CButton	m_checkEnableCC;
	CSpinButtonCtrl	m_spinCCSecond;
	CSpinButtonCtrl	m_spinCCHour;
	BOOL	m_fCCPeriodic;
	int		m_nCCCheckRandom;
	int		m_nCCHour;
	int		m_nCCMinute;
	int		m_nCCSecond;
	UINT	m_nCCMaxChecked;
	UINT	m_nCCTimeInterval;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropDBVerification)
	public:
	virtual BOOL OnApply();
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropDBVerification)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckPeriodicCc();
	afx_msg void OnChangeEditCcInterval();
	afx_msg void OnChangeEditCcMaxChecked();
	afx_msg void OnChangeEditCcStartHour();
	afx_msg void OnChangeEditCcStartMinute();
	afx_msg void OnChangeEditCcStartSecond();
	afx_msg void OnRadioCheckOwner();
	afx_msg void OnRadioCheckRandom();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private :
	CConfiguration *    m_pConfig;
	HRESULT				GetConfig();
	
	HRESULT UpdateServerConfiguration();
	
    void    SetCCInfo();
    void    UpdateCCControls();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CServerPropDBVerification::IDD);};
};


/////////////////////////////////////////////////////////////////////////////
// CServerPropAdvanced dialog

class CServerPropAdvanced : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CServerPropAdvanced)

// Construction
public:
	CServerPropAdvanced();
	~CServerPropAdvanced();

// Dialog Data
	//{{AFX_DATA(CServerPropAdvanced)
	enum { IDD = IDD_SERVER_PROP_ADVANCED };
	CButton	m_buttonBrowse;
	CEdit	m_editDbPath;
	CButton	m_checkBurstHandling;
	CButton	m_checkLanNames;
	CEdit	m_editVersionCount;
	CButton	m_checkLogDetailedEvents;
	BOOL	m_fLogEvents;
	CString	m_strStartVersion;
	BOOL	m_fLanNames;
	BOOL	m_fBurstHandling;
	int		m_nQueSelection;
	CString	m_strDbPath;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropAdvanced)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServerPropAdvanced)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckLannames();
	afx_msg void MarkDirty();
	afx_msg void OnCheckBurstHandling();
	afx_msg void OnRadioCustom();
	afx_msg void OnRadioHigh();
	afx_msg void OnRadioLow();
	afx_msg void OnRadioMedium();
	afx_msg void OnChangeEditCustomValue();
	afx_msg void OnButtonBrowseDatabase();
	afx_msg void OnChangeEditDatabasePath();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	
	CConfiguration*			m_pConfig;
	BOOL					m_fRestart;

	// helper functions
	HRESULT GetConfig();
	CString GetVersionInfo(LONG lLowWord, LONG lHighWord);
	
	HRESULT UpdateServerConfiguration();
	void    FillVersionInfo(LONG &lLowWord, LONG &lHighWord);

    void    UpdateBurstHandling();
    void    EnableQueSelection(BOOL bEnable);
    void    EnableCustomEntry();
    void    SetQueSize();
    DWORD   GetQueSize();

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CServerPropAdvanced::IDD);};
};


class CServerProperties : public CPropertyPageHolderBase
{
	
public:
	CServerProperties(ITFSNode *		  pNode,
					  IComponentData *	  pComponentData,
					  ITFSComponentData * pTFSCompData,
					  LPCTSTR			  pszSheetName
					  );
	virtual ~CServerProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

	void SetConfig(CConfiguration * pConfig)
	{
		m_Config = *pConfig;
	}

    CConfiguration * GetConfig()
    {
        return &m_Config;
    }

public:
	CServerPropGeneral			m_pageGeneral;
	CServerPropDBRecord			m_pageDBRecord;
	CServerPropDBVerification	m_pageDBVerification;
	CServerPropAdvanced			m_pageAdvanced;	
	CConfiguration              m_Config;

protected:
	SPITFSComponentData		m_spTFSCompData;
	WINSINTF_RESULTS_T		m_wrResults;
	handle_t				m_hBinding;
	DWORD					m_dwStatus;
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SRVLATPP_H__35B59246_47F9_11D1_B9A6_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\snappp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	snappp.h
		Brings up the snap-in property page		
    FILE HISTORY:
        
*/

#if !defined(AFX_SNAPPP_H__770C838B_17E8_11D1_B94F_00C04FBF914A__INCLUDED_)
#define AFX_SNAPPP_H__770C838B_17E8_11D1_B94F_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CSnapinPropGeneral dialog

class CSnapinPropGeneral : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CSnapinPropGeneral)

// Construction
public:
	CSnapinPropGeneral();
	~CSnapinPropGeneral();

// Dialog Data
	//{{AFX_DATA(CSnapinPropGeneral)
	enum { IDD = IDD_SNAPIN_PP_GENERAL };
	CButton	m_checkValidateServers;
	BOOL	m_fLongName;
	int		m_nOrderByName;
	CButton	m_checkLongName;
	CButton m_buttonSortByName;
	CButton m_buttonSortByIP;
	BOOL	m_fValidateServers;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSnapinPropGeneral)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSnapinPropGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CSnapinPropGeneral::IDD);};

	BOOL m_bDisplayServerOrderChanged;			// to check if the ServerOrder property is changed
	BOOL m_bDisplayFQDNChanged;					// to check if display FQDN is changed

	UINT m_uImage;
};

class CSnapinProperties : public CPropertyPageHolderBase
{
	friend class CSnapinProperties;

public:
	CSnapinProperties(ITFSNode *		  pNode,
					  IComponentData *	  pComponentData,
					  ITFSComponentData * pTFSCompData,
					  LPCTSTR			  pszSheetName);
	
	virtual ~CSnapinProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

public:
	CSnapinPropGeneral		m_pageGeneral;

protected:
	SPITFSComponentData		m_spTFSCompData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SNAPPP_H__770C838B_17E8_11D1_B94F_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\server.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	server.h
		WINS server node information. 
		
    FILE HISTORY:
        
*/

#ifndef _SERVER_H
#define _SERVER_H


#ifndef _WINSHAND_H
#include "winshand.h"

#endif

#ifndef _CONFIG_H
#include "config.h"
#endif

#ifndef _SVRSTATS_H
#include "svrstats.h" 
#endif

#ifndef _TASK_H
#include <task.h>
#endif

#ifndef _WINSMON_H
#include "winsmon.h"
#endif

class CServerStatsFrame;

#define		WINS_QDATA_SERVER_INFO		0x00000001
#define		WINS_SERVER_FLAGS_DEFAULT   FLAG_LANMAN_COMPATIBLE | FLAG_STATUS_BAR | FLAG_AUTO_REFRESH
#define		WINS_SERVER_REFRESH_DEFAULT 600

// this structure contains all of the info the background thread enumerates about
// the server and posts to the main thread
class CServerData
{
public:
	CString			m_strServerName;
	DWORD			m_dwServerIp;
	CConfiguration	m_config;

	handle_t		m_hBinding;
};

/*---------------------------------------------------------------------------
	Class:	CNameCacheEntry
 ---------------------------------------------------------------------------*/
class CNameCacheEntry
{
public:
    DWORD       m_dwIp;
    CString     m_strName;
    CTime       m_timeLastUpdate;
};

typedef CArray<CNameCacheEntry, CNameCacheEntry&> CNameCache;

/*---------------------------------------------------------------------------
	Class:	CNameThread
 ---------------------------------------------------------------------------*/
class CNameThread : public CWinThread
{
public:
    CNameThread();
    ~CNameThread();

public:
    void Init(CServerInfoArray * pServerInfoArray);
    BOOL Start();
    void Abort(BOOL fAutoDelete = TRUE);
    void AbortAndWait();
    BOOL FCheckForAbort();
    BOOL IsRunning();
    void UpdateNameCache();
	BOOL GetNameFromCache(DWORD dwIp, CString & strName);
    
    virtual BOOL InitInstance() { return TRUE; }	// MFC override
    virtual int Run();

private:
    HANDLE              m_hEventHandle;
    CServerInfoArray *  m_pServerInfoArray;
};

/*---------------------------------------------------------------------------
	Class:	CWinsServerHandler
 ---------------------------------------------------------------------------*/
class CWinsServerHandler : public CMTWinsHandler//public CWinsHandler
{
public:
    CWinsServerHandler(ITFSComponentData* pTFSComponentData, 
						LPCWSTR pServerName = NULL, 
						BOOL fConnected = TRUE, 
						DWORD dwIP = 0,
						DWORD dwFlags = WINS_SERVER_FLAGS_DEFAULT,
						DWORD dwRefreshInterval = WINS_SERVER_REFRESH_DEFAULT);
	~CWinsServerHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ 
				if(nCol == 0 || nCol == -1) 
					return GetDisplayName();
				else if(nCol == 1)
					return m_strConnected;
				else
					return NULL;
			}

    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();
			
	// Result handler functionality we override
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

    virtual DWORD   UpdateStatistics(ITFSNode * pNode);
	HRESULT LoadColumns(ITFSComponent * pComponent, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam);

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

public:
	// CMTWinsHandler functionality
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);
    virtual void GetErrorInfo(CString & strTitle, CString & strBody, IconIdentifier * pIcon);
	
	// implementation
	BOOL GetConnected()
	{
		return m_fConnected;
	};

	const CString&  GetServerAddress()
	{
		return m_strServerAddress;
	}

	const DWORD GetServerIP()
	{
		return m_dwIPAdd;
	}

	void SetServerIP(DWORD dwIPAdd)
	{
		m_dwIPAdd = dwIPAdd;
	}

	HRESULT GetActiveRegNode(ITFSNode ** ppNode)
	{
		Assert(ppNode);
		SetI((LPUNKNOWN *) ppNode, m_spActiveReg);
		return hrOK;
	}
	
	CConfiguration& GetConfig()
	{
		return m_cConfig;
	}

	void SetConfig(CConfiguration & configNew)
	{
		m_cConfig = configNew;
	}

	DWORD GetStatus()
	{
		return m_dwStatus;
	}
	
	handle_t GetBinding()
	{
		return m_hBinding;
	}

	DWORD GetFlags()
	{
		return m_dwFlags;
	}

	DWORD GetStatsRefreshInterval()
	{
		return m_dwRefreshInterval;
	}
	BOOL IsLocalConnection();

	virtual HRESULT InitializeNode(ITFSNode * pNode);
	virtual int GetImageIndex(BOOL bOpenImage);
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNode);
	virtual void OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);

    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

	DWORD	ConnectToWinsServer(ITFSNode *pNode);
	
	BOOL IsValidNetBIOSName(CString & strAddress,
							BOOL fLanmanCompatible,
							BOOL fWackwack // expand slashes if not present
							);

	DWORD   GetStatistics(ITFSNode * pNode, PWINSINTF_RESULTS_T * ppStats);
    DWORD   ClearStatistics(ITFSNode *pNode);

	// for the owner dilaog
	DWORD   GetOwnerConfig(PWINSINTF_RESULTS_NEW_T   pResults, CString strIP);
	DWORD   DeleteWinsServer(DWORD	dwIpAddress);

	BOOL	CheckIfNT351Server();

    void    SetExtensionName();	
    void    SetDisplay(ITFSNode * pNode, BOOL fFQDN);

public:
	// holds both the server name and the IP Address
	CString					m_strServerAddress;

	// stores whether the server is connected to or not
	CString					m_strConnected;

	// holds the IP Address of the server
	DWORD					m_dwIPAdd;

	// holds the monitoring IP address, case whrwe the server is not yet connected
	// so IP not known.
	DWORD					m_dwIPMon;
	char					szIPMon[MAX_PATH];

	// to be made persistent, those in the Preferences dialog 
	// of the admin tool
	DWORD					m_dwFlags;
	DWORD					m_dwRefreshInterval;

	// monitoring stuff
	DWORD					m_dwMsgCount;
    char					m_szNameToQry[STR_BUF_SIZE];          // the name to use in the queries
    char					m_nbtFrameBuf[MAX_NBT_PACKET_SIZE];   // buffer to store the NetBT frame

	WINSINTF_RESULTS_T		m_wrResults;
	CServerStatsFrame		m_dlgStats;
	CString					m_strTaskpadTitle;

    // Owner info array
    CServerInfoArray        m_ServerInfoArray;

    // Implementation
private:
	// helper functions
	HRESULT ShowServerStatDialog(ITFSNode* pNode);	
	
	// Task menu for the server
	HRESULT	DoDBBackup(ITFSNode * pNode);
	HRESULT	DoDBCompact(ITFSNode * pNode);
	HRESULT	DoDBRestore(ITFSNode * pNode);
	HRESULT	DoDBScavenge(ITFSNode * pNode);
	HRESULT OnDoConsistencyCheck(ITFSNode * pNode);
	HRESULT OnDoVersionConsistencyCheck(ITFSNode * pNode);
	HRESULT OnSendPushTrigger(ITFSNode * pNode);
	HRESULT OnSendPullTrigger(ITFSNode * pNode);
    HRESULT OnControlService(ITFSNode * pNode, BOOL fStart);
    HRESULT OnPauseResumeService(ITFSNode * pNode, BOOL fPause);
    HRESULT OnRestartService(ITFSNode * pNode);

	// Helpers
	DWORD   BackupDatabase(CString strBackupPath);
	BOOL    GetFolderName(CString & strPath, CString & strHelpText);
	void    DisConnectFromWinsServer();

	// used for compacting the DB
    DWORD RunApp(LPCTSTR input, LPCTSTR startingDirectory, LPSTR * output);
	
private:
	SPITFSNode				m_spActiveReg;
	SPITFSNode				m_spReplicationPartner;
	CConfiguration			m_cConfig;
	handle_t				m_hBinding;
	DWORD					m_dwStatus;
	BOOL					m_fConnected;
    BOOL                    m_bExtension;
    CNameThread *           m_pNameThread;
};

/*---------------------------------------------------------------------------
	Class:	CWinsServerQueryObj
 ---------------------------------------------------------------------------*/
class CWinsServerQueryObj : public CWinsQueryObj
{
public:
	CWinsServerQueryObj(ITFSComponentData * pTFSComponentData,
						ITFSNodeMgr *	    pNodeMgr) 
			: CWinsQueryObj(pTFSComponentData, pNodeMgr) {};
	
	STDMETHODIMP Execute();
	
	virtual void OnEventAbort(DWORD dwData, DWORD dwType);

	void	AddNodes(handle_t handle);

public:
    CNameThread *       m_pNameThread;
    CServerInfoArray *  m_pServerInfoArray;
    DWORD               m_dwIPAdd;
};


#endif _SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\statmap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statmap.h
		WINS static mappings node information. 
		
    FILE HISTORY:
        
*/

#ifndef _STATMAP_H
#define _STATMAP_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

/*---------------------------------------------------------------------------
	Class:	CStaticMappingsHandler
 ---------------------------------------------------------------------------*/
class CStaticMappingsHandler : public CWinsHandler
{
// Interface
public:
	CStaticMappingsHandler(ITFSComponentData *pCompData);


	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
	OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();

	OVERRIDE_NodeHandler_GetString();

	// helper routines
	HRESULT GetGroupName(CString * pstrGroupName);
	HRESULT SetGroupName(LPCTSTR pszGroupName);

public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

    OVERRIDE_BaseHandlerNotify_OnPropertyChange()

// Implementation
private:
};

#endif _STATMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\statndpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statndpp.h
		WINS scope pane status node property pages
		
    FILE HISTORY:
        
*/

#if !defined _STATNDPP_H
#define _STATNDPP_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// StatNdpp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStatusNodePropGen dialog

class CStatusNodePropGen : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CStatusNodePropGen)

// Construction
public:
	CStatusNodePropGen();
	~CStatusNodePropGen();

// Dialog Data
	//{{AFX_DATA(CStatusNodePropGen)
	enum { IDD = IDD_STATUS_NODE_PROPERTIES };
	int		m_nUpdateInterval;
	//}}AFX_DATA

	UINT	m_uImage;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CStatusNodePropGen)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CStatusNodePropGen)
	afx_msg void OnChangeEditUpdate();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CStatusNodePropGen::IDD);}

};

class CStatusNodeProperties : public CPropertyPageHolderBase
{
	
public:
	CStatusNodeProperties(ITFSNode *		  pNode,
					  IComponentData *	  pComponentData,
					  ITFSComponentData * pTFSCompData,
					  LPCTSTR			  pszSheetName
					  );
	virtual ~CStatusNodeProperties();

	ITFSComponentData * GetTFSCompData()
	{
		if (m_spTFSCompData)
			m_spTFSCompData->AddRef();
		return m_spTFSCompData;
	}

public:
	CStatusNodePropGen		m_pageGeneral;
	
protected:
	SPITFSComponentData		m_spTFSCompData;
	
};


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _STATNDPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\statmap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statmap.cpp
		WINS static mappings node information. 
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "statmap.h"

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::CStaticMappingsHandler
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
CStaticMappingsHandler::CStaticMappingsHandler(ITFSComponentData *pCompData) : CWinsHandler(pCompData)
{
}

/*!--------------------------------------------------------------------------
	CStaticMappingsHandler::InitializeNode
		Initializes node specific data
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CStaticMappingsHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString strTemp;
	strTemp.LoadString(IDS_ROOT_NODENAME);

	SetDisplayName(strTemp);

	// Make the node immediately visible
	//pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_SERVER);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_SERVER);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);

	SetColumnStringIDs(&aColumns[WINSSNAP_ROOT][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_ROOT][0]);

	return hrOK;
}

/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CStaticMappingsHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CStaticMappingsHandler::GetString
(
	ITFSNode *	pNode, 
	int			nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();
	else
		return NULL;
}

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::OnAddMenuItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CStaticMappingsHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	CString strMenuItem;

	strMenuItem.LoadString(IDS_ADD_SERVER);

	if (type == CCT_SCOPE)
	{
		// these menu items go in the new menu, 
		// only visible from scope pane

		ASSERT( SUCCEEDED(hr) );
	}

	return hr; 
}

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::OnCommand
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CStaticMappingsHandler::OnCommand
(
	ITFSNode *			pNode, 
	long				nCommandId, 
	DATA_OBJECT_TYPES	type, 
	LPDATAOBJECT		pDataObject, 
	DWORD				dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

	return hr;
}

/*!--------------------------------------------------------------------------
	CStaticMappingsHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CStaticMappingsHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrFalse;
	}
	else
	{
		// we have property pages in the normal case
		hr = hrFalse;
	}
	return hr;
}

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::CreatePropertyPages
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CStaticMappingsHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR				handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT	hr = hrOK;
	HPROPSHEETPAGE hPage;

	Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		//
		// We are loading this snapin for the first time, put up a property
		// page to allow them to name this thing.
		// 
	}
	else
	{
		//
		// Object gets deleted when the page is destroyed
		//
	}

Error:
	return hr;
}

/*---------------------------------------------------------------------------
	CStaticMappingsHandler::OnPropertyChange
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CStaticMappingsHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	return hrOK;
}

/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\statmapp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	statmapp.cpp
		Property Page for Active Registrations Record

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "winssnap.h"
#include "statmapp.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Static Record Types
CString g_strStaticTypeUnique;
CString g_strStaticTypeDomainName;
CString g_strStaticTypeMultihomed;
CString g_strStaticTypeGroup;
CString g_strStaticTypeInternetGroup;
CString g_strStaticTypeUnknown;

/////////////////////////////////////////////////////////////////////////////
static const char rgchHex[16*2+1] = "00112233445566778899aAbBcCdDeEfF";

/*---------------------------------------------------------------------------
	FGetByte()

	Return the byte value of a string.
	Return TRUE pbNum is set to the byte value (only if the string contains
	valid digits)
	Return FALSE if string has unrecognized digits or byte overflow.
	
	eg:
	szNum =	"xFF"	=> return TRUE
	szNum =	"255"	=> return TRUE
	szNum = "256"	=> return FALSE (overflow)
	szNum = "26a"	=> return TRUE (*pbNum = 26, *ppchNext = "a")
	szNum = "ab"	=> return FALSE (unrecognized digits)
 ---------------------------------------------------------------------------*/
BOOL 
FGetByte(IN const char szNum[], OUT BYTE * pbNum, OUT const char ** ppchNext)
{
	ASSERT(szNum);
	ASSERT(pbNum);
	ASSERT(ppchNext);
	
	int nResult;
	char * pchNum = (char *)szNum;
	int iBase = 10;			// Assume a decimal base
	
	if (*pchNum == 'x' || *pchNum == 'X')			// Check if we are using hexadecimal base
	{
		iBase = 16;
		pchNum++;
	}

	char * pchDigit = strchr(rgchHex, *pchNum++);
	
	if (pchDigit == NULL)
		return FALSE;
	
	int iDigit = (int) ((pchDigit - rgchHex) >> 1);
	
	if (iDigit >= iBase)
	{
		// Hexadecimal character in a decimal integer
		return FALSE;
	}
	
	nResult = iDigit;
	pchDigit = strchr(rgchHex, *pchNum);
	iDigit = (int) ((pchDigit - rgchHex) >> 1);

	if (pchDigit == NULL || iDigit >= iBase)
	{
		// Only one character was valid
		*pbNum = (BYTE) nResult;
		*ppchNext = pchNum;
		return TRUE;
	}
	
	pchNum++;
	nResult = (nResult * iBase) + iDigit;
	
	ASSERT(nResult < 256);
	
	if (iBase == 16)
	{
		// Hexadecimal value, stop there
		*pbNum = (BYTE) nResult;
		*ppchNext = pchNum;
		return TRUE;
	}
	
	// Decimal digit, so search for an optional third character
	pchDigit = strchr(rgchHex, *pchNum);
	iDigit = (int) ((pchDigit - rgchHex) >> 1);
	
	if (pchDigit == NULL || iDigit >= iBase)
	{
		*pbNum = (BYTE) nResult;
		*ppchNext = pchNum;
		return TRUE;
	}
	
	nResult = (nResult * iBase) + iDigit;
	
	if (nResult >= 256)
		return FALSE;
	
	pchNum++;
	*pbNum = (BYTE) nResult;
	*ppchNext = pchNum;
	
	return TRUE;
} // FGetByte


/////////////////////////////////////////////////////////////////////////////
// CStaticMappingProp property page

IMPLEMENT_DYNCREATE(CStaticMappingProp, CPropertyPageBase)

CStaticMappingProp::CStaticMappingProp(UINT uIDD) 
	:	CPropertyPageBase(uIDD), 
		m_fStaticPropChanged (TRUE),
		m_uIDD(uIDD)
{
	//{{AFX_DATA_INIT(CStaticMappingProp)
	m_strName = _T("");
	m_strType = _T("");
	m_strScopeName = _T("");
	//}}AFX_DATA_INIT
}


CStaticMappingProp::~CStaticMappingProp()
{
}

void 
CStaticMappingProp::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStaticMappingProp)
	DDX_Control(pDX, IDC_EDIT_SCOPE_NAME, m_editScopeName);
	DDX_Control(pDX, IDC_LIST_IPADD, m_listIPAdd);
	DDX_Control(pDX, IDC_BUTTON_REMOVE, m_buttonRemove);
	DDX_Control(pDX, IDC_BUTTON_ADD, m_buttonAdd);
	DDX_Control(pDX, IDC_EDIT_COMPNAME, m_editName);
	DDX_Control(pDX, IDC_COMBO_STATIC_TYPE, m_comboType);
	DDX_Text(pDX, IDC_EDIT_COMPNAME, m_strName);
	DDX_CBString(pDX, IDC_COMBO_STATIC_TYPE, m_strType);
	DDX_Text(pDX, IDC_EDIT_SCOPE_NAME, m_strScopeName);
	//}}AFX_DATA_MAP

	DDX_Control(pDX, IDC_IPADD, m_editCustomIPAdd);
	//DDX_Control(pDX, IDC_IPADD, m_ipControl);
	DDX_Text(pDX, IDC_IPADD, m_strIPAdd);
}


BEGIN_MESSAGE_MAP(CStaticMappingProp, CPropertyPageBase)
	//{{AFX_MSG_MAP(CStaticMappingProp)
	ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
	ON_BN_CLICKED(IDC_BUTTON_REMOVE, OnButtonRemove)
	ON_CBN_SELCHANGE(IDC_COMBO_STATIC_TYPE, OnSelchangeComboType)
	ON_EN_CHANGE(IDC_EDIT_COMPNAME, OnChangeEditCompname)
	ON_LBN_SELCHANGE(IDC_LIST_IPADD, OnSelChangeListIpAdd)
	//}}AFX_MSG_MAP

	// IP Address control
	ON_EN_CHANGE(IDC_IPADD, OnChangeIpAddress)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CStaticMappingProp message handlers
void CStaticMappingProp::OnOK() 
{
	CPropertyPageBase::OnOK();
}


BOOL 
CStaticMappingProp::OnApply() 
{
	HRESULT hr = hrOK;
    BOOL    bRet = TRUE;

	// if not dirtied return
	if (!IsDirty())
		return TRUE;

	if (((CStaticMappingProperties*)GetHolder())->m_bWizard)
	{
		UpdateData();

		CActiveRegistrationsHandler *pActReg;

		SPITFSNode  spNode;
		spNode = GetHolder()->GetNode();

		pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

		m_strName.TrimLeft();
		m_strName.TrimRight();

        int nMax = (pActReg->IsLanManCompatible()) ? 15 : 16;
		if (m_strName.IsEmpty())
		{
            CString strMessage, strTemp;
            strTemp.Format(_T("%d"), nMax);

            AfxFormatString1(strMessage, IDS_INVALID_NAME, strTemp);
			AfxMessageBox(strMessage);

            m_editName.SetFocus();
			m_editName.SetSel(0, -1);
			
            return FALSE;
		}
		else 
        if (m_strType.IsEmpty())
		{
			AfxMessageBox(IDS_INVALID_TYPE, MB_OK);
			m_comboType.SetFocus();
			return FALSE;
		}

		CString strTemp;

		// check this only for Unique and Normal Group addresses,
		// for the rest, the ipcontrol is balnk and the list box holds the IP a
		// IP addresses for them.

		DWORD dwIp1, dwIp2, dwIp3, dwIp4;
		int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

		LONG lIPAdd = (LONG) MAKEIPADDRESS(dwIp1, dwIp2, dwIp3, dwIp4);

		// it's so bcoz' only in the case of Unique and Normal Group names,
		// IP address is read from the IP control, else from the list box

		if ( (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0) || (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0) )
		{
			if (nAdd != 4)
			{
				AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
				m_editCustomIPAdd.SetFocus();
				return FALSE;
			}

            // check if broadcast address has been entered
			if (m_strIPAdd.CompareNoCase(_T("255.255.255.255")) == 0)
			{
				AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
				m_editCustomIPAdd.SetFocus();
				return FALSE;
			}

            // check to make sure something was entered
            if ( (m_strIPAdd.IsEmpty()) ||
                 (m_strIPAdd.CompareNoCase(_T("0.0.0.0")) == 0) )
            {
			    AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
			    m_editCustomIPAdd.SetFocus();
			    m_editCustomIPAdd.SetSel(0,-1);
			    return FALSE;
            }
		}
        else
        {
            if (m_listIPAdd.GetCount() == 0)
		    {
			    AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
			    m_editCustomIPAdd.SetFocus();
			    m_editCustomIPAdd.SetSel(0,-1);
			    return FALSE;
    		}
        }

		BOOL fInternetGroup = FALSE;

		if (m_strType.CompareNoCase(g_strStaticTypeInternetGroup) == 0)
			fInternetGroup = TRUE;

		// Parse the string
		BOOL fValid = TRUE;
		BOOL fBrackets = FALSE;
		BYTE rgbData[100];
		BYTE bDataT;
		int cbData = 0;
		LPSTR szTemp = (char*) alloca(2*(MAX_PATH+1));

        // just use ACP here because we are just looking at the string
        // we will do the OEM conversion later.
        WideToMBCS(m_strName, szTemp);

		const char * pch = (LPCSTR)szTemp;

		while (*pch)
		{
			if (fBrackets)
			{
				fValid = FALSE;
				goto Done;
			}
		
			if (cbData > 16)
				goto Done;
					
			switch (*pch)
			{
			case '\\':
				pch++;
			
				if (*pch == '\\' || *pch == '[')
				{
					rgbData[cbData++] = *pch++;
					break;	
				}
			
				if (!FGetByte(pch, &bDataT, &pch) || !bDataT)
				{
					fValid = FALSE;
					goto Done;
				}
				
				rgbData[cbData++] = bDataT;
				
				break;

			case '[':
			{
				char szT[4] = { 0 };
				const char * pchT;

				fBrackets = TRUE;
				pch++;
				
				if (*(pch + 1) == 'h' || *(pch + 1) == 'H')
				{
					szT[0] = 'x';
					szT[1] = *pch;
					pch += 2;
				}
				
				else if (*(pch + 2) == 'h' || *(pch + 2) == 'H')
				{
					szT[0] = 'x';
					szT[1] = *pch;
					szT[2] = *(pch + 1);
					pch += 3;
				}
				
				if (szT[0])
				{
					if (!FGetByte(szT, &bDataT, &pchT) || !bDataT || *pchT)
					{
						fValid = FALSE;
						goto Done;
					}
				}
				
				else if (!FGetByte(pch, &bDataT, &pch) || !bDataT)
				{
					fValid = FALSE;
					goto Done;
				}
				
				if (*pch++ != ']')
				{
					fValid = FALSE;
					goto Done;
				}
				
				while (cbData < 15)
					rgbData[cbData++] = ' ';
				
				rgbData[cbData++] = bDataT;
			}
			break;

			default:

	#ifdef FE_SB

				if (::IsDBCSLeadByte(*pch))
					rgbData[cbData++] = *pch++;

	#endif
				
				rgbData[cbData++] = *pch++;
				
			} // switch

		}
		
			
		
	Done:
		// Put a null-terminator at end of string
		rgbData[cbData] = 0;

		if (!cbData || cbData > nMax)
		{
            CString strMessage, strTemp;
            strTemp.Format(_T("%d"), nMax);

            AfxFormatString1(strMessage, IDS_INVALID_NAME, strTemp);
			AfxMessageBox(strMessage);

            m_editName.SetFocus();
			m_editName.SetSel(0,-1);
			
            return FALSE;
		}
		
		if (!fValid)
		{
            CString strMessage, strTemp;
            strTemp.Format(_T("%d"), nMax);

            AfxFormatString1(strMessage, IDS_INVALID_NAME, strTemp);
			AfxMessageBox(strMessage);

            m_editName.SetFocus();
			m_editName.SetSel(0,-1);
			
            return FALSE;
		}
		
		if (fInternetGroup && rgbData[15] == 0x1C)
		{
			AfxMessageBox(IDS_INVALID_INTERNET_GROUP_NAME);
			m_editName.SetFocus();
			m_editName.SetSel(0,-1);
			
            return FALSE;
		}

		if (fInternetGroup)
        {
			while (cbData <= 15)
				rgbData[cbData++] = ' ';
		
        	rgbData[cbData] = 0;
        }

		szTemp = (LPSTR)rgbData;

        // convert our touched up string back to unicode for use later
        MBCSToWide(szTemp, pActReg->m_strStaticMappingName);
        
        //pActReg->m_strStaticMappingName = rgbData;
		pActReg->m_strStaticMappingScope = m_strScopeName;
		pActReg->m_strStaticMappingType = m_strType;
		
        AssignMappingType();
		
        pActReg->m_nStaticMappingType = m_fType;

		// clear the IP adress array maintained in theactreg handler first
		pActReg->m_strArrayStaticMappingIPAddress.RemoveAll();
		pActReg->m_lArrayIPAddress.RemoveAll();

		if ( (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0) || (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0) )
		{
			pActReg->m_strArrayStaticMappingIPAddress.Add(m_strIPAdd);
			pActReg->m_lArrayIPAddress.Add(lIPAdd);
		}
		// copy from the array
		else
		{
			for (int i = 0; i < m_strArrayIPAdd.GetSize(); i++)
			{
				pActReg->m_strArrayStaticMappingIPAddress.Add(m_strArrayIPAdd.GetAt(i));
				pActReg->m_lArrayIPAddress.Add(m_dwArrayIPAdd.GetAt(i));
			}
		}

        // do the thread context switch so we can update the UI as well
	    bRet = CPropertyPageBase::OnApply();

	    if (bRet == FALSE)
	    {
		    // Something bad happened... grab the error code
		    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		    ::WinsMessageBox(GetHolder()->GetError());
	    }
		else
		{
			// set back the defaults for the controls
			m_comboType.SelectString(-1, g_strStaticTypeUnique);
							
			m_editCustomIPAdd.ShowWindow(TRUE);
			m_editCustomIPAdd.SetWindowText(_T(""));
			m_editName.SetWindowText(_T(""));
			m_editScopeName.SetWindowText(_T(""));

			// clear and hide the list box and the Add and Remove buttons
			m_buttonAdd.ShowWindow(FALSE);
			m_buttonRemove.ShowWindow(FALSE);

			int nCount = m_listIPAdd.GetCount();

			for (int i= 0; i < nCount; i++)
			{
				m_listIPAdd.DeleteString(i);
			}

			m_listIPAdd.ShowWindow(FALSE);
			m_listIPAdd.ResetContent();
			m_strArrayIPAdd.RemoveAll();
			m_dwArrayIPAdd.RemoveAll();

			SetRemoveButtonState();

            SetDirty(FALSE);
		}
	}
	// if static mapping properties are modified, we need to do this
	else 
	{
		// validate the data and copy to ActReg node
		UpdateData();

		SPITFSNode  spNode;
		spNode = GetHolder()->GetNode();

		CActiveRegistrationsHandler *pActReg;

		pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

		// clear the array of IP addresses maintained in the act reg handler
		pActReg->m_strArrayStaticMappingIPAddress.RemoveAll();
		pActReg->m_lArrayIPAddress.RemoveAll();


		DWORD dwIp1, dwIp2, dwIp3, dwIp4;
		int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

		if ( (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0)|| (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0))
		{
			if (nAdd != 4)
			{
				AfxMessageBox(IDS_ERR_INVALID_IP, MB_OK);
				// set focus to the IP address control
				m_editCustomIPAdd.SetFocus();
				return hrFalse;
			}
			
		}
		
		LONG lIPAdd = (LONG) MAKEIPADDRESS(dwIp1, dwIp2, dwIp3, dwIp4);

		pActReg->m_strStaticMappingName = m_strName;
		pActReg->m_strStaticMappingType = m_strType;

		AssignMappingType();
		
		pActReg->m_nStaticMappingType = m_fType;

	
		if ( (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0)|| (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0))
		{
			pActReg->m_strArrayStaticMappingIPAddress.Add(m_strIPAdd);
			pActReg->m_lArrayIPAddress.Add(lIPAdd);
		}
		// copy from the array
		else
		{
			for (int i = 0; i < m_strArrayIPAdd.GetSize(); i++)
			{
				pActReg->m_strArrayStaticMappingIPAddress.Add(m_strArrayIPAdd.GetAt(i));
				pActReg->m_lArrayIPAddress.Add(m_dwArrayIPAdd.GetAt(i));
			}
		}

        // do the thread context switch so we can update the UI as well
	    bRet = CPropertyPageBase::OnApply();

	    if (bRet == FALSE)
	    {
		    // Something bad happened... grab the error code
		    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
		    ::WinsMessageBox(GetHolder()->GetError());
	    }
	}

	return bRet;
}

void 
CStaticMappingProp::AssignMappingType()
{
	if (m_strType.CompareNoCase(g_strStaticTypeInternetGroup) == 0)
		m_fType = WINSINTF_E_SPEC_GROUP;
	else 
    if (m_strType.CompareNoCase(g_strStaticTypeUnique) == 0)
		m_fType = WINSINTF_E_UNIQUE;
	else 
    if (m_strType.CompareNoCase(g_strStaticTypeMultihomed) == 0)
		m_fType = WINSINTF_E_MULTIHOMED;
	else 
    if (m_strType.CompareNoCase(g_strStaticTypeGroup) == 0)
		m_fType = WINSINTF_E_NORM_GROUP;
	else 
    if (m_strType.CompareNoCase(g_strStaticTypeDomainName)== 0)
		m_fType = WINSINTF_E_SPEC_GROUP;
}


void 
CStaticMappingProp::OnChangeIpAddress()
{
	SetDirty(TRUE);
	CString strText;
	m_editCustomIPAdd.GetWindowText(strText);

	if (strText.IsEmpty())
	{
		// disable the Add and Remove buttons
        CWnd * pCurFocus = GetFocus();

        if (m_buttonAdd.GetSafeHwnd() == pCurFocus->GetSafeHwnd() ||
            m_buttonRemove.GetSafeHwnd() == pCurFocus->GetSafeHwnd())
        {
            m_editCustomIPAdd.SetFocus();
        }

		m_buttonAdd.EnableWindow(FALSE);
		m_buttonRemove.EnableWindow(FALSE);
	}

	UpdateData();

	DWORD dwIp1, dwIp2, dwIp3, dwIp4;
	int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

	if (nAdd != 4)
	{
        CWnd * pCurFocus = GetFocus();

        if (m_buttonAdd.GetSafeHwnd() == pCurFocus->GetSafeHwnd())
        {
            m_editCustomIPAdd.SetFocus();
        }

        m_buttonAdd.EnableWindow(FALSE);
	}
	else
	{
		m_buttonAdd.EnableWindow(TRUE);
	}

	SetRemoveButtonState();
}


BOOL 
CStaticMappingProp::OnInitDialog() 
{
	// Initialize the IP address controls
	m_ipControl.Create(m_hWnd, IDC_IPADD);
	m_ipControl.SetFieldRange(0, 0, 255);
    
	CPropertyPageBase::OnInitDialog();

    // fill in the type strings
    m_comboType.AddString(g_strStaticTypeUnique);
    m_comboType.AddString(g_strStaticTypeGroup);
    m_comboType.AddString(g_strStaticTypeDomainName);
    m_comboType.AddString(g_strStaticTypeInternetGroup);
    m_comboType.AddString(g_strStaticTypeMultihomed);

    ::SendMessage(::GetDlgItem(m_hWnd, IDC_EDIT_COMPNAME), EM_LIMITTEXT, MAX_PATH, 0);

    if (((CStaticMappingProperties*)GetHolder())->m_bWizard)
	{
        // set control states for the wizard part
        HWND hWndSheet = ((CStaticMappingProperties*)GetHolder())->GetSheetWindow();
        CString strTitle;

        strTitle.LoadString(IDS_CREATE_STATIC_MAPPING);
        ::SetWindowText(hWndSheet, strTitle);

        SetDefaultControlStates();
		m_editScopeName.SetReadOnly(FALSE);

		m_comboType.SelectString(-1, g_strStaticTypeUnique);
	}
	else
	{
        m_editScopeName.SetReadOnly(TRUE);
		m_buttonAdd.ShowWindow(FALSE);
		m_buttonRemove.ShowWindow(FALSE);
		m_listIPAdd.ShowWindow(FALSE);
		
        SetRemoveButtonState();

		// owner only visible in properties mode
		WinsRecord ws = ((CStaticMappingProperties*)GetHolder())->m_wsRecord;

        if (ws.dwOwner != INVALID_OWNER_ID)
        {
		    CString strOwner;
		    MakeIPAddress(ws.dwOwner, strOwner);
            GetDlgItem(IDC_EDIT_OWNER)->SetWindowText(strOwner);
        }
		
        FillControls();
	}

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

    SetDirty(FALSE);

	return TRUE;  
}


BOOL 
CStaticMappingProp::FillControls()
{
	// get the actreg node
	BOOL                            fHasScope = FALSE;
    CActiveRegistrationsHandler *   pActReg;
    SPITFSNode                      spNode;
	
    spNode = GetHolder()->GetNode();
	pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

	WinsRecord ws = ((CStaticMappingProperties*)GetHolder())->m_wsRecord;

	// name and the IP address ypu anyway fill. the reamining depending on
	// whether it's a static or dynamic record

    if (ws.dwNameLen > 16)
    {
        fHasScope = TRUE;
    }

	// build the name string
	CString strName, strScopeName;
    pActReg->CleanNetBIOSName(ws.szRecordName,
                              strName,
						      TRUE,   // Expand
							  TRUE,   // Truncate
							  pActReg->IsLanManCompatible(), 
							  TRUE,   // name is OEM
							  FALSE,  // No double backslash
                              ws.dwNameLen);

	// check if it has a scope name attached to it., looking for a period
    if (fHasScope)
    {
        LPSTR pScope = &ws.szRecordName[17];

        // INTL$ should this be OEMCP, not ACP
        MBCSToWide(pScope, strScopeName, WINS_NAME_CODE_PAGE);

        int nPos = strName.Find(strScopeName);
	    // means that the scope name is attached
	    if ( (nPos != -1) &&
             (!strScopeName.IsEmpty()) )
	    {
            // all we want here is the name
            strName = strName.Left(nPos - 1);
        }
    }
    
    m_strName = strName;
	m_strScopeName = strScopeName;

    // IP address
	CString strIP;

	if (ws.dwState & WINSDB_REC_UNIQUE || ws.dwState & WINSDB_REC_NORM_GROUP)
	{
		for (DWORD i = 0; i < ws.dwNoOfAddrs; i++)
		{
			MakeIPAddress(ws.dwIpAdd[i], strIP);
            m_strArrayIPAdd.Add(strIP);
            m_dwArrayIPAdd.Add(ws.dwIpAdd[i]);
		}
	}
	// in this case the first IP address is that of the owner,
	else
	{
		DWORD dwPos = 1;

		for (DWORD i = 0; i < ws.dwNoOfAddrs/2; ++i)
		{
            ::MakeIPAddress(ws.dwIpAdd[dwPos], strIP);
			m_strArrayIPAdd.Add(strIP);
            m_dwArrayIPAdd.Add(ws.dwIpAdd[dwPos]);
			++dwPos;
			++dwPos;
		}
	}
	
	// text in the controls now
	m_editName.SetWindowText(m_strName);
	m_editScopeName.SetWindowText(m_strScopeName);

	//check if the record is static
	if (ws.dwState & WINSDB_REC_STATIC)
	{
		// active status
		CString strStaticType;
		pActReg->GetStaticTypeString(ws.dwState, strStaticType);

		if (strStaticType.CompareNoCase(g_strStaticTypeDomainName) == 0)
		{
			//could be either Internet Group or Domain Name
			// check for the 15th character , if 1C, then Domain Name 
			// else Internet Group Name

			if ((BYTE)ws.szRecordName[15] == 0x1C)
				strStaticType = g_strStaticTypeDomainName;
			else
				strStaticType = g_strStaticTypeInternetGroup;
		}
		
		FillStaticRecData(strStaticType);

		//m_fStaticPropChanged = TRUE;
		m_strType = strStaticType;
	}
	else
	{
	}
	
	return TRUE;
}


void 
CStaticMappingProp::FillStaticRecData(CString& strType)
{
	// hide the combobox too, show the IPAdd control
	m_editCustomIPAdd.ShowWindow(TRUE);

	// display the combobox
	m_comboType.ShowWindow(TRUE);

	// disable thew type combobox
	m_comboType.EnableWindow(FALSE);

	// get the type of record
	m_comboType.SelectString(-1, strType);

	// make the records read only.
	m_editName.SetReadOnly();

	// depending on the type, hide/show the list control
	// and the add remove buttons.
	if ( (strType.CompareNoCase(g_strStaticTypeUnique) == 0) || strType.CompareNoCase(g_strStaticTypeGroup) == 0)
	{
		m_listIPAdd.ShowWindow(FALSE);
		m_buttonAdd.ShowWindow(FALSE);
		m_buttonRemove.ShowWindow(FALSE);

		m_editCustomIPAdd.ShowWindow(TRUE);
		m_editCustomIPAdd.SetReadOnly(FALSE);
		
		// set it's text to that in the combo box
		CString strIP;
        strIP = m_strArrayIPAdd.GetAt(0);

		m_strOnInitIPAdd = strIP;

		m_ipControl.SetAddress(strIP);
	}
	else
	{
		m_listIPAdd.ShowWindow(TRUE);
		m_buttonAdd.ShowWindow(TRUE);
		m_buttonRemove.ShowWindow(TRUE);

		m_editCustomIPAdd.ShowWindow(TRUE);
		m_editCustomIPAdd.SetReadOnly(FALSE);

		// fill the contents with that from the combo box
		FillList();

		if (m_strArrayIPAdd.GetSize() > 0)
			m_strOnInitIPAdd = m_strArrayIPAdd.GetAt(0);
	}

	SetRemoveButtonState();
}


void 
CStaticMappingProp::FillList()
{
    CString strIP;

	// clear the list box next
	for (int i = 0; i < m_listIPAdd.GetCount(); i++)
		m_listIPAdd.DeleteString(i);

	int nCount = (int) m_strArrayIPAdd.GetSize();

	for (i = 0; i < nCount; i++)
	{
        strIP = m_strArrayIPAdd.GetAt(i);

        m_listIPAdd.AddString(strIP);
        
        if (nCount == 1)
            m_ipControl.SetAddress(strIP);
	}

	m_ipControl.SetAddress(_T(""));
	m_editCustomIPAdd.SetWindowText(_T(""));
	
	SetRemoveButtonState();
}


void 
CStaticMappingProp::FillDynamicRecData(CString& strType, CString& strActive, CString& strExpiration, CString& strVersion)
{
}


void 
CStaticMappingProp::SetDefaultControlStates()
{
	m_comboType.EnableWindow(TRUE);
	m_comboType.ShowWindow(TRUE);

	m_editCustomIPAdd.ShowWindow(TRUE);

	SetRemoveButtonState();
}


void 
CStaticMappingProp::OnButtonAdd() 
{
	UpdateData();

	// add the IPAdd in the IPControl to the list box
	// if valid

	// check if broadcast address is being added
	if (m_strIPAdd.CompareNoCase(_T("255.255.255.255")) == 0)
	{
		AfxMessageBox(IDS_INVALID_IPADDRESS, MB_OK);
		m_editCustomIPAdd.SetFocus();
		return;
	}

	DWORD dwIp1, dwIp2, dwIp3, dwIp4;
	int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

	// check if the address is alreay in the list
	for (int i = 0; i < m_strArrayIPAdd.GetSize() ; i++)
	{
		if (m_strArrayIPAdd[i].CompareNoCase(m_strIPAdd) == 0)
		{
			AfxMessageBox(IDS_ERR_IP_EXISTS, MB_OK);
			m_editCustomIPAdd.SetFocus();
			m_editCustomIPAdd.SetSel(0,-1);
			return;
		}
	}

    if (m_dwArrayIPAdd.GetSize() == WINSINTF_MAX_MEM)
    {
        // cannot add any more addresses
        AfxMessageBox(IDS_ERR_TOOMANY_IP);
        return;
    }

	LONG lIPAdd = (LONG) MAKEIPADDRESS(dwIp1, dwIp2, dwIp3, dwIp4);

    // add to the list 	
	m_listIPAdd.AddString(m_strIPAdd);
	m_strArrayIPAdd.Add(m_strIPAdd);
	m_dwArrayIPAdd.Add(lIPAdd);

	//m_fStaticPropChanged = TRUE; 

	m_editCustomIPAdd.SetWindowText(_T(""));

	SetDirty(TRUE);
}

void 
CStaticMappingProp::OnButtonRemove() 
{
	SPITFSNode  spNode;
	spNode = GetHolder()->GetNode();

	CActiveRegistrationsHandler* pActReg;

	pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

	// remove from the list 	
	int nSel = m_listIPAdd.GetCurSel();
	CString strSel;

	if (nSel != -1)
	{
		m_listIPAdd.GetText(nSel, strSel);
		m_listIPAdd.DeleteString(nSel);
	}

	// set the IP address in the IP Control
	m_ipControl.SetAddress(strSel);

	UpdateData();

	// delete from the CStringArray
	for (int i = 0; i < m_strArrayIPAdd.GetSize(); i++)
	{
		if (strSel == m_strArrayIPAdd.GetAt(i))
		{
			m_strArrayIPAdd.RemoveAt(i);
			m_dwArrayIPAdd.RemoveAt(i);
			break;
		}
	}

	// set the focus to the IP address control
	m_editCustomIPAdd.SetFocus();

	//m_fStaticPropChanged = TRUE; 

	SetDirty(TRUE);
}


void 
CStaticMappingProp::OnSelchangeComboType() 
{
	SetDirty(TRUE);

	if (m_comboType.GetCurSel() == 2 || m_comboType.GetCurSel() == 3 || m_comboType.GetCurSel() == 4)
	{
		// show the list control and the add and the remove buttons
		m_buttonAdd.ShowWindow(TRUE);
		m_buttonRemove.ShowWindow(TRUE);
		m_listIPAdd.ShowWindow(TRUE);
	}
	// hide them
	else
	{
		m_buttonAdd.ShowWindow(FALSE);
		m_buttonRemove.ShowWindow(FALSE);
		m_listIPAdd.ShowWindow(FALSE);
	}
	SetRemoveButtonState();
}

void CStaticMappingProp::OnChangeEditCompname() 
{
	SetDirty(TRUE);
}

void 
CStaticMappingProp::SetRemoveButtonState()
{
	UpdateData();

	if (m_listIPAdd.GetCurSel() == -1)
    {
        CWnd * pCurFocus = GetFocus();

        if (m_buttonRemove.GetSafeHwnd() == pCurFocus->GetSafeHwnd())
        {
            m_editCustomIPAdd.SetFocus();
        }

        m_buttonRemove.EnableWindow(FALSE);
    }
	else
    {
		m_buttonRemove.EnableWindow(TRUE);
    }

	DWORD dwIp1, dwIp2, dwIp3, dwIp4;
	int nAdd = m_ipControl.GetAddress(&dwIp1, &dwIp2, &dwIp3, &dwIp4);

	if (nAdd != 4)
	{
        CWnd * pCurFocus = GetFocus();

        if (m_buttonAdd.GetSafeHwnd() == pCurFocus->GetSafeHwnd())
        {
            m_editCustomIPAdd.SetFocus();
        }

        m_buttonAdd.EnableWindow(FALSE);
	}
	else
	{
		m_buttonAdd.EnableWindow(TRUE);

	}
}

void 
CStaticMappingProp::OnSelChangeListIpAdd()
{
	SetRemoveButtonState();
}

BOOL 
CStaticMappingProp::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT         hr = hrOK;
    SPITFSComponent spComponent;
	SPITFSNode      spNode;
	
    spNode = GetHolder()->GetNode();
    CActiveRegistrationsHandler * pActReg = GETHANDLER(CActiveRegistrationsHandler, spNode);

	if (((CStaticMappingProperties*)GetHolder())->m_bWizard)
	{
		hr = pActReg->AddMapping(spNode);
		if (FAILED(hr))
		{
			GetHolder()->SetError(WIN32_FROM_HRESULT(hr));
		}
		else
		{
			*ChangeMask = RESULT_PANE_CHANGE_ITEM_DATA;
		}
	}
	else
	{
	    ((CStaticMappingProperties *) GetHolder())->GetComponent(&spComponent);

    	DWORD dwErr = pActReg->EditMapping(spNode, spComponent, pActReg->m_nSelectedIndex);
		if (dwErr != ERROR_SUCCESS)
		{
			GetHolder()->SetError(dwErr);
		}
		else
		{
			*ChangeMask = RESULT_PANE_CHANGE_ITEM_DATA;
		}
	}
	
	return FALSE;
}


CStaticMappingProperties::CStaticMappingProperties
(
	ITFSNode *			pNode,
	IComponent *	    pComponent,
	LPCTSTR				pszSheetName,
	WinsRecord *	    pwRecord,
	BOOL				bWizard
) : CPropertyPageHolderBase(pNode, pComponent, pszSheetName), m_bWizard(bWizard)
{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
    m_bTheme = TRUE;

	InitPage(bWizard);

	AddPageToList((CPropertyPageBase*) m_ppageGeneral);

    Init(pwRecord);
}

CStaticMappingProperties::CStaticMappingProperties
(
	ITFSNode *			pNode,
	IComponentData *    pComponentData,
	LPCTSTR				pszSheetName,
	WinsRecord *        pwRecord,
	BOOL				bWizard
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName), m_bWizard(bWizard)
{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
    m_bTheme = TRUE;

	InitPage(bWizard);

	AddPageToList((CPropertyPageBase*) m_ppageGeneral);

    Init(pwRecord);
}

CStaticMappingProperties::~CStaticMappingProperties()
{
	RemovePageFromList((CPropertyPageBase*) m_ppageGeneral, FALSE);

	delete m_ppageGeneral;
	m_ppageGeneral = NULL;
}

void
CStaticMappingProperties::InitPage(BOOL fWizard)
{
	if (fWizard)
	{
		m_ppageGeneral = new CStaticMappingProp(IDD_STATIC_MAPPING_WIZARD);
	}
	else
	{
		m_ppageGeneral = new CStaticMappingProp(IDD_STATIC_MAPPING_PROPERTIES);
	}
}

void
CStaticMappingProperties::Init(WinsRecord * pwRecord)
{
	if (pwRecord)
	{
		strcpy(m_wsRecord.szRecordName , pwRecord->szRecordName);
		m_wsRecord.dwExpiration = pwRecord->dwExpiration;
		m_wsRecord.dwExpiration = pwRecord->dwExpiration;
		m_wsRecord.dwNoOfAddrs = pwRecord->dwNoOfAddrs;

		for (DWORD i = 0; i < pwRecord->dwNoOfAddrs; i++)
		{
			m_wsRecord.dwIpAdd[i] = pwRecord->dwIpAdd[i];
		}

        m_wsRecord.liVersion = pwRecord->liVersion;
		m_wsRecord.dwNameLen = pwRecord->dwNameLen;
		m_wsRecord.dwOwner = pwRecord->dwOwner;
		m_wsRecord.dwState = pwRecord->dwState;
		m_wsRecord.dwType = pwRecord->dwType;
	}
}

HRESULT 
CStaticMappingProperties::SetComponent(ITFSComponent * pComponent)
{
    m_spTFSComponent.Set(pComponent);

    return hrOK;
}

HRESULT 
CStaticMappingProperties::GetComponent(ITFSComponent ** ppComponent)
{
    if (ppComponent)
    {
        *ppComponent = m_spTFSComponent;
        m_spTFSComponent->AddRef();
    }

    return hrOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\statndpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    statndpp.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "winssnap.h"
#include "StatNdpp.h"
#include "status.h"
#include "root.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MILLISEC_PER_MINUTE		(60 * 1000)

/////////////////////////////////////////////////////////////////////////////
// CStatusNodePropGen property page

IMPLEMENT_DYNCREATE(CStatusNodePropGen, CPropertyPageBase)

CStatusNodePropGen::CStatusNodePropGen() : CPropertyPageBase(CStatusNodePropGen::IDD)
{
	//{{AFX_DATA_INIT(CStatusNodePropGen)
	m_nUpdateInterval = 0;
	//}}AFX_DATA_INIT
}


CStatusNodePropGen::~CStatusNodePropGen()
{
}


void CStatusNodePropGen::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPageBase::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStatusNodePropGen)
	DDX_Text(pDX, IDC_EDIT_UPDATE, m_nUpdateInterval);
	DDV_MinMaxInt(pDX, m_nUpdateInterval, 1, 59);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStatusNodePropGen, CPropertyPageBase)
	//{{AFX_MSG_MAP(CStatusNodePropGen)
	ON_EN_CHANGE(IDC_EDIT_UPDATE, OnChangeEditUpdate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStatusNodePropGen message handlers

void CStatusNodePropGen::OnChangeEditUpdate() 
{
	// mark the root node as dirty so that the user is prompted to save the
	// file, refresh interval is part of the .msc file
	SPITFSNode spNode, spParent;
	
	spNode = GetHolder()->GetNode();

	// set the upadte interval from the root node
	spNode->GetParent(&spParent);

	// mark the data as dirty so that we'll ask the user to save.
    spParent->SetData(TFS_DATA_DIRTY, TRUE);

	SetDirty(TRUE);
}

BOOL CStatusNodePropGen::OnInitDialog() 
{
	CPropertyPageBase::OnInitDialog();

	SPITFSNode spNode, spParent;
	
	spNode = GetHolder()->GetNode();

	// set the upadte interval from the root node
	spNode->GetParent(&spParent);

	CWinsRootHandler *pRoot 
		= GETHANDLER(CWinsRootHandler, spParent);

	m_nUpdateInterval = pRoot->GetUpdateInterval()/(MILLISEC_PER_MINUTE);

	UpdateData(FALSE);

	m_uImage = (UINT) spNode->GetData(TFS_DATA_IMAGEINDEX);

    // load the correct icon
    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        if (g_uIconMap[i][1] == m_uImage)
        {
            HICON hIcon = LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
            if (hIcon)
                ((CStatic *) GetDlgItem(IDC_STATIC_ICON))->SetIcon(hIcon);
            break;
        }
    }

	SetDirty(FALSE);

	return TRUE;  
}

BOOL 
CStatusNodePropGen::OnApply() 
{
	UpdateData();

	// update the m_dwInterval for the status node
	SPITFSNode spNode, spParent;
	CWinsRootHandler *pRoot= NULL;
	CWinsStatusHandler	*pStat = NULL;

	spNode = GetHolder()->GetNode();
	spNode->GetParent(&spParent);

	pRoot = GETHANDLER(CWinsRootHandler, spParent);
	pStat = GETHANDLER(CWinsStatusHandler, spNode);

	DWORD dwValue = m_nUpdateInterval * MILLISEC_PER_MINUTE;

	pStat->SetUpdateInterval(dwValue);

	pRoot->SetUpdateInterval(dwValue);

	return CPropertyPageBase::OnApply();   
}


/////////////////////////////////////////////////////////////////////////////
//	CRepNodeProperties Handlers
/////////////////////////////////////////////////////////////////////////////
CStatusNodeProperties::CStatusNodeProperties
(
	ITFSNode *			pNode,
	IComponentData *	pComponentData,
	ITFSComponentData * pTFSCompData,
	LPCTSTR				pszSheetName
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)

{
	m_bAutoDeletePages = FALSE; // we have the pages as embedded members
    m_bTheme = TRUE;

	AddPageToList((CPropertyPageBase*) &m_pageGeneral);
	
	Assert(pTFSCompData != NULL);
	m_spTFSCompData.Set(pTFSCompData);
}


CStatusNodeProperties::~CStatusNodeProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\statmapp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statmapp.h
		Property Page for Active Registrations Record

	FILE HISTORY:
        
*/

#if !defined _STATMAPP_H
#define _STATMAPP_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CStaticMappingProp dialog

#ifndef _IPCTRL_H
#include "ipctrl.h"
#endif

#ifndef _ACTREG_H
#include "actreg.h"
#endif

// Static Record Types
extern CString g_strStaticTypeUnique;
extern CString g_strStaticTypeDomainName;
extern CString g_strStaticTypeMultihomed;
extern CString g_strStaticTypeGroup;
extern CString g_strStaticTypeInternetGroup;
extern CString g_strStaticTypeUnknown;

class CStaticMappingProp : public CPropertyPageBase
{
	DECLARE_DYNCREATE(CStaticMappingProp)

// Construction
public:
	CStaticMappingProp(UINT uIDD = IDD_STATIC_MAPPING_PROPERTIES);
	~CStaticMappingProp();

	virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

// Dialog Data
	//{{AFX_DATA(CStaticMappingProp)
	enum { IDD = IDD_STATIC_MAPPING_PROPERTIES };
	CEdit	m_editScopeName;
	CListBox	m_listIPAdd;
	CButton	m_buttonRemove;
	CButton	m_buttonAdd;
	CComboBox	m_comboIPAdd;
	CEdit	m_editName;
	CComboBox	m_comboType;
	CString	m_strName;
	CString	m_strType;
	CString	m_strScopeName;
	//}}AFX_DATA

	CEdit	m_editCustomIPAdd;
	CString m_strIPAdd;
	LONG	m_lIPAddress;
	CString m_strOnInitIPAdd;

	UINT	m_uImage;
	UINT	m_uIDD;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CStaticMappingProp)
	public:
	virtual void OnOK();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CStaticMappingProp)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonRemove();
	afx_msg void OnSelchangeComboType();
	afx_msg void OnChangeEditCompname();
	afx_msg void OnSelChangeListIpAdd();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// single ip address controls
	afx_msg void OnChangeIpAddress();


private:

	BOOL FillControls();
	
	void AssignMappingType();
	void FillDynamicRecData(CString& strType, CString& strActive, CString& strExpiration, CString& strVersion);
	void FillStaticRecData(CString& strType);
	void SetDefaultControlStates();
	void FillList();
	void SetRemoveButtonState();
	
	int						m_fType;
	IPControl				m_ipControl;
	CStringArray			m_strArrayIPAdd;
	CDWordArray				m_dwArrayIPAdd;

	// set if property changed for static mapping
	BOOL					m_fStaticPropChanged;

	
public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(m_uIDD);}
};

class CStaticMappingProperties:public CPropertyPageHolderBase
{
	
public:
	CStaticMappingProperties(ITFSNode *	        pNode,
							 IComponent *	    pComponent,
							 LPCTSTR			pszSheetName,
							 WinsRecord*		pwRecord = NULL,
							 BOOL				bWizard = FALSE);
	
    CStaticMappingProperties(ITFSNode *	        pNode,
							 IComponentData *   pComponentData,
							 LPCTSTR			pszSheetName,
							 WinsRecord*		pwRecord = NULL,
							 BOOL				bWizard = FALSE);

    virtual ~CStaticMappingProperties();

    void Init(WinsRecord * pwRecord);
    void InitPage(BOOL fWizard);

    HRESULT GetComponent(ITFSComponent ** ppComponent);
    HRESULT SetComponent(ITFSComponent * pComponent);

public:
	CStaticMappingProp * 	m_ppageGeneral;
	WinsRecord				m_wsRecord;
	BOOL					m_bWizard;

    SPITFSComponent         m_spTFSComponent;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined _STATMAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	stdafx.cpp	
		precompiled header file

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\statnode.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	statnode.cpp
		Status leaf node

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "statnode.h"

CServerStatus::CServerStatus(ITFSComponentData *pCompData):
							CWinsHandler(pCompData)
{
	m_bExpanded = FALSE;
	m_nState = loaded;
	dwState = SERVER_ADDED;

	m_uImage = ICON_IDX_SERVER;
    m_timeLast = 0;
}


HRESULT
CServerStatus::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
	
	CString strDisplay;
	
	FormDisplayName(strDisplay);

	SetDisplayName(strDisplay);

	// Make the node immediately visible
	pNode->SetVisibilityState(TFS_VIS_SHOW);
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, WINSSNAP_STATUS_LEAF_NODE);
	pNode->SetData(TFS_DATA_IMAGEINDEX, m_uImage);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, m_uImage);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

	SetColumnStringIDs(&aColumns[WINSSNAP_REPLICATION_PARTNER][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_REPLICATION_PARTNER][0]);
	
	return hrOK;
}

/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CServerStatus::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CServerStatus::GetString
(
	ITFSComponent * pComponent,	
	MMC_COOKIE 	    cookie,
	int				nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();
	switch(nCol)
	{
	    case -1:
	    case 0:
		    return GetDisplayName();
	    
        case 1:
		    return m_strStatus;

        case 2:
            if (m_timeLast == 0)
                m_strLastChecked.Empty();
            else
            {
                FormatDateTime(m_strLastChecked, m_timeLast);
            }
            
            return m_strLastChecked;
            
        default:
		    return NULL;
	}
}


/*---------------------------------------------------------------------------
	Command handlers
 ---------------------------------------------------------------------------*/

void 
CServerStatus:: FormDisplayName(CString &strDisplay)
{
	WCHAR wString[MAX_PATH] = {0};
	int nBytes  = 0;
	
	// form the string for the first column
	nBytes = ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szServerName, -1, wString, 0);
	::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szServerName, -1, wString, nBytes);

	CString strServer(wString);
	m_strServerName = strServer;

	if(dwIPAddress != 0)
	{
		::MakeIPAddress(dwIPAddress, m_strIPAddress);
		strDisplay.Format(IDS_SERVER_NAME_FORMAT, m_strServerName, m_strIPAddress);
	}
	else
	{
		strDisplay = m_strServerName;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\statnode.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	statnode.h
		WINS scope pane status node
		
    FILE HISTORY:
        
*/

#ifndef _STATNODE_H
#define _STATNODE_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

#ifndef _STATUS_H
#include "status.h"
#endif


class CServerStatus : public CWinsHandler
{
	public:
		CServerStatus(ITFSComponentData * pTFSCompData);
		~CServerStatus(){	};

	// Interface
	public:
		// Result handler functionality
//		OVERRIDE_ResultHandler_HasPropertyPages() { return hrOK; }
		OVERRIDE_ResultHandler_GetString();
		
	// Implementation
public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

	// Get/Set Functions
	const CString &GetServerName()
	{
		return m_strServerName;
	}

	void SetRecordName(CString& strName)
	{
		m_strServerName = strName;
	}

	const CString &GetStatus()
	{
		return m_strStatus;
	}

	void SetStatus(CString &strType)
	{
		m_strStatus = strType;
	}

	const CString &GetIPAddress()
	{
		return m_strIPAddress;
	}

	void SetIPAddress(CString& strName)
	{
		m_strIPAddress = strName;
	}

	void FormDisplayName(CString &strDisplay);
	
	char			szServerName[MAX_PATH];
	char			szIPAddress[MAX_PATH];
	DWORD			dwIPAddress;
	DWORD			dwMsgCount;
	DWORD			dwState;							// checks if the server has been deleted from the list
    char			szNameToQry[STR_BUF_SIZE];          // the name to use in the queries
    char			nbtFrameBuf[MAX_NBT_PACKET_SIZE];   // buffer to store the NetBT frame
	CString			m_strStatus;
	CTime           m_timeLast;
	UINT			m_uImage;
    
private:
	CString			m_strServerName;
	CString			m_strIPAddress;
	CString         m_strLastChecked;

	// info from the Wins Record Object
	DWORD			m_dwIPAddress;
};

#endif //SRVNODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\status.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	status.h
		WINS result pane state nodes
		
    FILE HISTORY:
        
*/

#ifndef _STATUS_H
#define _STATUS_H

#ifndef _WINSHAND_H
#include "winshand.h"
#endif

#ifndef _WINSMON_H
#include "winsmon.h"
#endif

#ifndef _STATNODE_H
#include "statnode.h"
#endif

#ifndef _SERVER_H
#include "server.h"
#endif

#include "afxmt.h"

class  CServerStatus;


/*---------------------------------------------------------------------------
	Class:	CWinsStatusHandler
 ---------------------------------------------------------------------------*/
class CWinsStatusHandler : public CMTWinsHandler
{
// Interface
public:
	CWinsStatusHandler(ITFSComponentData *pCompData, DWORD dwUpdateInterval);

	~CWinsStatusHandler();

	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_DestroyHandler();

	STDMETHODIMP_(LPCTSTR) GetString(ITFSNode * pNode, int nCol);

    OVERRIDE_BaseHandlerNotify_OnCreateNodeId2();

public:
	// CWinsHandler overrides
	virtual HRESULT InitializeNode(ITFSNode * pNode);

    OVERRIDE_BaseHandlerNotify_OnPropertyChange();
	OVERRIDE_BaseHandlerNotify_OnExpand();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

    OVERRIDE_ResultHandler_CompareItems();

public:
	DWORD GetUpdateInterval()
	{
		return m_dwUpdateInterval;
	}

	void SetUpdateInterval(DWORD dwValue)
	{
		// set the new interval and wakeup the main probe thread
        // since we are resetting the interval, do a check now and
        // then wait the new interval
        m_dwUpdateInterval = dwValue;
        SetEvent(m_hWaitIntervalMain);
	}

	DWORD WINAPI ExecuteMonitoring();
	DWORD WINAPI ListeningThreadFunc() ;

	HRESULT AddNode(ITFSNode *pNode, CWinsServerHandler *pServer);
	HRESULT DeleteNode(ITFSNode *pNode, CWinsServerHandler *pServer);

    // we don't use query object, but being a MTHandler requires this
    virtual ITFSQueryObject* OnCreateQuery(ITFSNode *pNode) { return NULL; }
	STDMETHOD(OnNotifyHaveData)(LPARAM);

	typedef CArray <CServerStatus *, CServerStatus *> listServers;

	listServers		m_listServers;

// Implementation
private:
	HRESULT CreateListeningSockets( );
	void    StartMonitoring(ITFSNode *pNode);
	int     Probe(CServerStatus *pServer, SOCKET listenNameSvcSock);
	void    CloseSockets();

	void    RemoveServer(int i);
	void    AddServer(CServerStatus* pServer);
	void    BuildServerList(ITFSNode *pNode);
	void    SetIPAddress(int i, LPSTR szIP);
	CServerStatus* GetServer(int i);

	HRESULT CreateNodes(ITFSNode *pNode);
	void    UpdateStatusColumn(ITFSNode *pNode);
	
	int     GetListSize();
	void    UpdateStatus(int nIndex, UINT uStatusId, UINT uImage);
	
	BOOL    IsServerDeleted(CServerStatus *pStat);
	void    MarkAsDeleted(LPSTR szBuffer, BOOL bDelete = TRUE);
	CServerStatus* GetExistingServer(LPSTR szBuffer);

    void    NotifyMainThread();

	BOOL	FCheckForAbort();

private:
	// variables for monitoring
	fd_set					m_listenSockSet;
	SOCKET					listenNameSvcSock;   // 2DO: for the listening thread...
	SOCKET					listenSockCl;	    // socket listening for frames from DHCP srvs
	SOCKET					listenSockSrv;	    // socket listening for frames from DHCP srvs
	
    // thread handles
    HANDLE					m_hMainMonThread;
	HANDLE					m_hListenThread;

    // event handles
    HANDLE					m_hAbortListen;
    HANDLE					m_hAbortMain;
    HANDLE					m_hAnswer;
    HANDLE					m_hWaitIntervalListen;
    HANDLE					m_hWaitIntervalMain;
    HANDLE					m_hPauseListening;
	
    int						m_nServersUpdated;
	DWORD					m_dwUpdateInterval;	// Holds the value in milliSec

	CCriticalSection		m_cs;
    SPITFSNode              m_spNode;
};

// thread proc the background thread initially is called on
DWORD WINAPI MonThreadProc(LPVOID lParam);
DWORD WINAPI MainMonThread(LPVOID lParam);


#endif _STATUS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\svrstats.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ServStat.cpp
		The server statistics dialog
		
    FILE HISTORY:
        
*/

#include <afx.h>
#include "dbgutil.h"
#include "stdafx.h"
#include "winssnap.h"
#include "server.h"
#include "resource.h"
#include "svrstats.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define INTLTIMESTR(time) (((CIntlTime)(time)).CIntlTime::operator const CString())
#define TMST1(x) INTLTIMESTR((m_wrResults).WinsStat.TimeStamps.x)
#define INTLNUMSTR(num) (((CIntlNumber)(num)).CIntlNumber::operator const CString())
#define TCTR(x) INTLNUMSTR((m_wrResults).WinsStat.Counters.x)

#define STATMUTEXNAME       _T("WINSADMNGETSTATISTICS")
#define WM_UPDATE_STATS     WM_USER + 1099

enum 
{
    SERVER_STAT_START_TIME = 0,
	SERVER_STAT_DB_INIT_TIME,
    SERVER_STAT_STAT_CLEAR_TIME,
	SERVER_STAT_BLANK0,
    SERVER_STAT_LAST_PERIODIC_REP,
    SERVER_STAT_LAST_ADMIN_REP,
    SERVER_STAT_LAST_NET_UPDATE_REP,
    SERVER_STAT_LAST_ADDRESS_CHANGE_REP,
	SERVER_STAT_BLANK1,
    SERVER_STAT_TOTAL_QUERIES,
    SERVER_STAT_SUCCESSFUL_QUERRIES,
    SERVER_STAT_FAILED_QUERRIES,
	SERVER_STAT_BLANK2,
    SERVER_STAT_TOTAL_RELEASES,
    SERVER_STAT_SUCCESSFUL_RELEASES,
    SERVER_STAT_FAILED_RELEASES,
	SERVER_STAT_BLANK3,
    SERVER_STAT_UNIQUE_REGISTRATIONS,
    SERVER_STAT_UNIQUE_CONFLICTS,
    SERVER_STAT_UNIQUE_RENEWALS,
	SERVER_STAT_BLANK4,
    SERVER_STAT_GROUP_REGISTRATIONS,
    SERVER_STAT_GROUP_CONFLICTS,
    SERVER_STAT_GROUP_RENEWALS,
	SERVER_STAT_BLANK5,
    SERVER_STAT_TOTAL_REG,
	SERVER_STAT_BLANK6,
    SERVER_STAT_LAST_PERIODIC_SCAV,
    SERVER_STAT_LAST_ADMIN_SCAV,
    SERVER_STAT_LAST_EXTINCTION_SCAV,
    SERVER_STAT_LAST_VERIFICATION_SCAV,
	SERVER_STAT_BLANK7,
    SERVER_STAT_PARTNERS_HEADER,
	SERVER_STAT_MAX
};


/*---------------------------------------------------------------------------
	CServerStatsFrame implementation
 ---------------------------------------------------------------------------*/
const ContainerColumnInfo s_rgServerStatsColumnInfo[] =
{
	{ IDS_SERVER_STATS_START_TIME,					0,		TRUE },
	{ IDS_SERVER_STATS_DB_INIT_TIME,   				0,		TRUE },
	{ IDS_SERVER_STATS_LAST_CLEAR_TIME,   			0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_LAST_PREP,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_AREP,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_NREP,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_ACREP,   		        0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_TOTAL_QUERRIES,   	        0,		TRUE },
	{ IDS_SERVER_STATS_SUCCESSFUL,   			    0,		TRUE },
	{ IDS_SERVER_STATS_FAILED,   				    0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_TOTAL_RELEASES,   	        0,		TRUE },
	{ IDS_SERVER_STATS_SUCCESSFUL,   			    0,		TRUE },
	{ IDS_SERVER_STATS_FAILED,   				    0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_UNIQUE_REGISTRATIONS,   	    0,		TRUE },
	{ IDS_SERVER_STATS_CONFLICTS,   			    0,		TRUE },
	{ IDS_SERVER_STATS_RENEWALS,   				    0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_GROUP_REGISTRATIONS,   	    0,		TRUE },
	{ IDS_SERVER_STATS_CONFLICTS,   			    0,		TRUE },
	{ IDS_SERVER_STATS_RENEWALS,   				    0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_TOTAL_REGISTRATIONS,			0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_LAST_PSCAV,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_ASCAV,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_ESCAV,   		        0,		TRUE },
	{ IDS_SERVER_STATS_LAST_VSCAV,   		        0,		TRUE },
	{ IDS_BLANK,   									0,		TRUE },
	{ IDS_SERVER_STATS_PARTNERS_HEADER,				0,		TRUE },
};

UINT _cdecl
RefreshStatsThread(LPVOID pParam)
{
    DWORD           dw;
	ThreadInfo *    pInfo = (ThreadInfo *)(pParam);
    HANDLE          hmutStatistics = NULL;
    HRESULT         hr = hrOK;

    COM_PROTECT_TRY
    {
        // Open the existing mutex
        while (hmutStatistics == NULL)
        {
            if ((hmutStatistics = ::OpenMutex(SYNCHRONIZE, FALSE, STATMUTEXNAME)) == NULL)
            {
                ::Sleep(2000L);
            }
        }

        // This is where the work gets done
        for (;;)
        {
		    pInfo->dwInterval = pInfo->pDlg->GetRefreshInterval();

            //::Sleep((pInfo->dwInterval)*1000);
            if (::WaitForSingleObject(pInfo->pDlg->m_hAbortEvent, (pInfo->dwInterval) * 1000) == WAIT_OBJECT_0)
            {
                // we're going away, lets get outta here
                break;
            }

            // Wait until we get the go ahead
            dw = ::WaitForSingleObject(hmutStatistics, INFINITE);
            if (dw == WAIT_OBJECT_0)
            {
			    dw = pInfo->pDlg->GetStats();
                if (dw == ERROR_SUCCESS)
                {
                    PostMessage(pInfo->pDlg->GetSafeHwnd(), WM_UPDATE_STATS, 0, 0);
                }

                ::ReleaseMutex(hmutStatistics);
            }
        }

        if (hmutStatistics != NULL)
            CloseHandle(hmutStatistics);

        delete pInfo;
    }
    COM_PROTECT_CATCH

    return 0;
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::CServerStatsFrame()
		Constructor
---------------------------------------------------------------------------*/
CServerStatsFrame::CServerStatsFrame()
	: StatsDialog(STATSDLG_VERTICAL|STATSDLG_CLEAR)
{
    SetColumnInfo(s_rgServerStatsColumnInfo,
				  DimensionOf(s_rgServerStatsColumnInfo));

    m_hmutStatistics = NULL;
    m_hAbortEvent = NULL;
    m_pRefreshThread = NULL;

    ZeroMemory(&m_wrResults, sizeof(m_wrResults));
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::CServerStatsFrame()
		Destructor
---------------------------------------------------------------------------*/
CServerStatsFrame::~CServerStatsFrame()
{
}


BEGIN_MESSAGE_MAP(CServerStatsFrame, StatsDialog)
	//{{AFX_MSG_MAP(CServerStatistics)
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_NEW_STATS_AVAILABLE, OnNewStatsAvailable)
    ON_MESSAGE(WM_UPDATE_STATS, OnUpdateStats)
	ON_BN_CLICKED(IDC_STATSDLG_BTN_CLEAR, OnClear)
	ON_WM_DESTROY()
END_MESSAGE_MAP()

/*---------------------------------------------------------------------------
	CServerStatsFrame::CServerStatsFrame()
		Gets the statistics from the server handler and updates the 
		internal variable m_wrResults
---------------------------------------------------------------------------*/
HRESULT CServerStatsFrame::RefreshData(BOOL fGrabNewData)
{
    if (fGrabNewData)
    {
	    DWORD dwError = 0;

        BEGIN_WAIT_CURSOR;
        dwError = GetStats();
        END_WAIT_CURSOR;
    
        if (dwError != ERROR_SUCCESS)
	    {
		    WinsMessageBox(dwError);
	    }
		else
		{
            UpdateWindow(&m_wrResults);
        }
    }

    return hrOK;
}

DWORD CServerStatsFrame::GetStats()
{
    DWORD                dwError = 0;
	SPITFSNode           spNode;
	PWINSINTF_RESULTS_T  pResults = NULL;
	CWinsServerHandler * pServer;

	pServer = GETHANDLER(CWinsServerHandler, m_spNode);
	
    dwError = pServer->GetStatistics(m_spNode, &pResults);
    if (dwError == ERROR_SUCCESS)
    {
    	m_wrResults = *(pResults);
    }

    return dwError;
}


BOOL CServerStatsFrame::OnInitDialog()
{
	CString	st;
    BOOL bRet;

    AfxFormatString1(st, IDS_SERVER_STATS_TITLE, m_strServerAddress);

    SetWindowText((LPCTSTR) st);
	
    bRet = StatsDialog::OnInitDialog();

	// add the blank column because the replication partner stats need them
	m_listCtrl.InsertColumn(2, _T("            "), LVCFMT_LEFT, 100);

    // Set the default column widths to the width of the widest column
    SetColumnWidths(2 /* Number of Columns */);

    UpdateWindow(&m_wrResults);

    // set the default window size
    RECT rect;
    GetWindowRect(&rect);

	int nWidth = 0;
    for (int i = 0; i < 3; i++)
	{
		nWidth += m_listCtrl.GetColumnWidth(i);	
	}

	SetWindowPos(NULL, rect.left, rect.top, nWidth + 20, SERVER_STATS_DEFAULT_HEIGHT, SWP_SHOWWINDOW);

	if ((m_hmutStatistics = ::CreateMutex(NULL, FALSE, STATMUTEXNAME)) == NULL)
    {
        Trace1("CServerStatsFrame::OnInitDialog() - CreateMutex failed! %lx\n", GetLastError());
        return FALSE;
    }

    if ((m_hAbortEvent = ::CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
    {
        Trace1("CServerStatsFrame::OnInitDialog() - CreateEvent failed! %lx\n", GetLastError());
        return FALSE;
    }

    StartRefresherThread();

    return bRet;
}


void CServerStatsFrame::Sort(UINT nColumnId)
{
    // we don't sort any of our stats
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::OnNewStatsAvailable(UINT wParam, LONG lParam)
		called in response to the message ON_NEW_STATS_AVAILABLE
    Author: EricDav
---------------------------------------------------------------------------*/
afx_msg long 
CServerStatsFrame::OnNewStatsAvailable(UINT wParam, LONG lParam)
{
    DWORD dwErr = GetStats();
    if (dwErr == ERROR_SUCCESS)
    {
        UpdateWindow(&m_wrResults);
    }
    else
    {
        WinsMessageBox(dwErr);
    }

    return 0;
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::OnNewStatsAvailable(UINT wParam, LONG lParam)
		called in response to the message WM_UPDATE_STATS
        The background thread updates the stats, now we need to update
        the UI on the correct thread.
    Author: EricDav
---------------------------------------------------------------------------*/
afx_msg long 
CServerStatsFrame::OnUpdateStats(UINT wParam, LONG lParam)
{
    UpdateWindow(&m_wrResults);

    return 0;
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::UpdateWindow(PWINSINTF_RESULTS_T  pwrResults)
		Updates the contents of the dialog
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::UpdateWindow(PWINSINTF_RESULTS_T  pwrResults)
{

	SPITFSNode    spNode;
    CWinsServerHandler * pServer;

	CString str;

    UINT i;
    int nTotalAddresses = 0, nTotalInUse = 0, nTotalAvailable = 0;
   
	// now fill in the data
    for (i = 0; i < SERVER_STAT_MAX; i++)
	{
        if (!pwrResults)
            str = _T("---");
        else
        {
            switch (i)
		    {
                // server stsrt time
                case SERVER_STAT_START_TIME:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.WinsStartTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.WinsStartTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

				// database initialized time
                case SERVER_STAT_DB_INIT_TIME:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastInitDbTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastInitDbTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
	            	break;
				
				// statistics last cleared time
				case SERVER_STAT_STAT_CLEAR_TIME:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.CounterResetTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.CounterResetTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                	break;

                // some blank lines in between
				case SERVER_STAT_BLANK0:
				case SERVER_STAT_BLANK1:
				case SERVER_STAT_BLANK2:
				case SERVER_STAT_BLANK3:
				case SERVER_STAT_BLANK4:
				case SERVER_STAT_BLANK5:
				case SERVER_STAT_BLANK6:
				case SERVER_STAT_BLANK7:
					str = _T("");
                    break;
                
                case SERVER_STAT_LAST_PERIODIC_REP:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastPRplTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastPRplTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;
                
                case SERVER_STAT_LAST_ADMIN_REP:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastATRplTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastATRplTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_LAST_NET_UPDATE_REP:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastNTRplTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastNTRplTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;
                
                // last address changed time
                case SERVER_STAT_LAST_ADDRESS_CHANGE_REP:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastACTRplTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastACTRplTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
	                break;
                
				// total queries received
                case SERVER_STAT_TOTAL_QUERIES:
	                str = TCTR(NoOfQueries);
                    break;

				// successful queries
                case SERVER_STAT_SUCCESSFUL_QUERRIES:
	                str = TCTR(NoOfSuccQueries);
                    break;

				// Queries that failed
                case SERVER_STAT_FAILED_QUERRIES:
	                str = TCTR(NoOfFailQueries);
                    break;
                
                case SERVER_STAT_TOTAL_RELEASES:
                    str = TCTR(NoOfRel);
                    break;
                
                case SERVER_STAT_SUCCESSFUL_RELEASES:
                    str = TCTR(NoOfSuccRel);
                    break;
                
                case SERVER_STAT_FAILED_RELEASES:
                    str = TCTR(NoOfFailRel);
                    break;

    			// unique registrations
                case SERVER_STAT_UNIQUE_REGISTRATIONS:
                    str = TCTR(NoOfUniqueReg);
                    break;

                case SERVER_STAT_UNIQUE_CONFLICTS:
                    str = TCTR(NoOfUniqueCnf);
                    break;

                case SERVER_STAT_UNIQUE_RENEWALS:
                    str = TCTR(NoOfUniqueRef);
                    break;

				// group registrations
                case SERVER_STAT_GROUP_REGISTRATIONS:
            	    str = TCTR(NoOfGroupReg);
                    break;

                case SERVER_STAT_GROUP_CONFLICTS:
            	    str = TCTR(NoOfGroupCnf);
                    break;

                case SERVER_STAT_GROUP_RENEWALS:
            	    str = TCTR(NoOfGroupRef);
                    break;
				
                // total registrations
				case SERVER_STAT_TOTAL_REG:
	               str = INTLNUMSTR(m_wrResults.WinsStat.Counters.NoOfGroupReg + 
									m_wrResults.WinsStat.Counters.NoOfUniqueReg);
                    break;

                case SERVER_STAT_LAST_PERIODIC_SCAV:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastPScvTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastPScvTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_LAST_ADMIN_SCAV:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastATScvTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastATScvTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_LAST_EXTINCTION_SCAV:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastTombScvTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastTombScvTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_LAST_VERIFICATION_SCAV:
					{
						CTime timeStart(m_wrResults.WinsStat.TimeStamps.LastVerifyScvTime);
						if(timeStart != 0)
							FormatDateTime(str, &m_wrResults.WinsStat.TimeStamps.LastVerifyScvTime);
						else
							str.LoadString(IDS_INVALID_TIME);
					}
                    break;

                case SERVER_STAT_PARTNERS_HEADER:
					{
						str.LoadString(IDS_SERVER_STATS_NO_OF_FAILED);
						m_listCtrl.SetItemText(i, 2, (LPCTSTR) str);

						str.LoadString(IDS_SERVER_STATS_NO_OF_REPLS);
					}
					break;

                default:
                    Assert("Invalid server statistic type!");
                    break;
		    }
        }

		// now the string is set, display in the dlg
		m_listCtrl.SetItemText(i, 1, (LPCTSTR) str);
	}

	UpdatePartnerStats();
}


/*---------------------------------------------------------------------------
	CServerStatsFrame::StartRefresherThread()
		Starts the refresher thread, called as soon as the dilog is 
		brought up
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::StartRefresherThread()
{
	ThreadInfo *info = new ThreadInfo;

	CWinsServerHandler * pServer;
	pServer = GETHANDLER(CWinsServerHandler, m_spNode);
	
	info->dwInterval = pServer->m_dwRefreshInterval;
	info->pDlg = this;

    m_pRefreshThread = ::AfxBeginThread(RefreshStatsThread, info);
	
	if (m_pRefreshThread == NULL)
    {
        Trace0("Failed to create thread\n");
        m_pRefreshThread = NULL;
        return;
    }

    Trace0("Auto refresh thread succesfully started\n");

}


/*---------------------------------------------------------------------------
	CServerStatsFrame::ReInitRefresherThread()
		If the refresher thread was running, re-start it. It is needed
        in order to pick on the fly the new refresh intervals
---------------------------------------------------------------------------*/
void
CServerStatsFrame::ReInitRefresherThread()
{
    // if there is a refresher thread, just restart it
    if (m_pRefreshThread != NULL)
    {
        KillRefresherThread();
        StartRefresherThread();
    }
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::KillRefresherThread()
		Kills the refresh data thread, caled when the dlg is destroyed
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::KillRefresherThread()
{
    //
    // Kill refresher thread if necessary.
    //
    if (m_pRefreshThread == NULL)
    {
        //
        // No thread running
        //
        return;
    }

    //::TerminateThread(m_pRefreshThread->m_hThread, 0);
    //::CloseHandle(m_pRefreshThread->m_hThread);
    ::SetEvent(m_hAbortEvent);
    ::WaitForSingleObject(m_pRefreshThread->m_hThread, 5000);
    
    m_pRefreshThread = NULL;
}


/*---------------------------------------------------------------------------
	CServerStatsFrame::OnDestroy( )
		Message Handler
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::OnDestroy( )
{
	KillRefresherThread();

    if (m_hmutStatistics)
    {
        ::CloseHandle(m_hmutStatistics);
        m_hmutStatistics = NULL;
    }

    if (m_hAbortEvent)
    {
        ::CloseHandle(m_hAbortEvent);
        m_hAbortEvent = NULL;
    }

}


/*---------------------------------------------------------------------------
	CServerStatsFrame::GetRefreshInterval()
	 Returns the refresh interval, stored in the server handler
---------------------------------------------------------------------------*/
DWORD
CServerStatsFrame::GetRefreshInterval()
{
	CWinsServerHandler * pServer;
	pServer = GETHANDLER(CWinsServerHandler, m_spNode);
	
	return pServer->m_dwRefreshInterval;

}


/*---------------------------------------------------------------------------
	CServerStatsFrame::OnClear()
		Calls the wins api to reset counters and updates data, in response to 
		click of the clear button
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::OnClear()
{
    DWORD dwErr = ERROR_SUCCESS;
    CWinsServerHandler * pServer = GETHANDLER(CWinsServerHandler, m_spNode);

	// clear the ststistics
	BEGIN_WAIT_CURSOR
	dwErr = pServer->ClearStatistics(m_spNode);
	END_WAIT_CURSOR

    if (dwErr == ERROR_SUCCESS)
    {
        // refresh the data now
	    RefreshData(TRUE);

	    UpdateWindow(&m_wrResults);
    }
    else
    {
        WinsMessageBox(dwErr);
    }
}

/*---------------------------------------------------------------------------
	CServerStatsFrame::UpdatePartnerStats()
---------------------------------------------------------------------------*/
void 
CServerStatsFrame::UpdatePartnerStats()
{
	UINT i, uCount;
	CString strText;

	// first remove all old partner info
	uCount = m_listCtrl.GetItemCount();
	for (i = 0; i < (uCount - SERVER_STAT_MAX); i++)
	{
		m_listCtrl.DeleteItem(SERVER_STAT_MAX);
	}

	int nPartner = 0;

	// now add all of the partner information in
	for (i = SERVER_STAT_MAX; i < SERVER_STAT_MAX + m_wrResults.WinsStat.NoOfPnrs; i++)
	{
		m_listCtrl.InsertItem(i, _T(""));

		// ip address
		::MakeIPAddress(m_wrResults.WinsStat.pRplPnrs[nPartner].Add.IPAdd, strText);
		m_listCtrl.SetItemText(i, 0, strText);

		// replication count
		strText.Format(_T("%d"), m_wrResults.WinsStat.pRplPnrs[nPartner].NoOfRpls);
		m_listCtrl.SetItemText(i, 1, strText);

		// failed count
		strText.Format(_T("%d"), m_wrResults.WinsStat.pRplPnrs[nPartner].NoOfCommFails);
		m_listCtrl.SetItemText(i, 2, strText);

		nPartner++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\svrstats.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	svrstats.h
		The server statistics dialog
		
    FILE HISTORY:
        
*/

#ifndef _SVRSTATS_H
#define _SVRSTATS_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _STATSDLG_H
#include "statsdlg.h"
#endif

#ifndef _WINSSNAP_H
#include "winssnap.h"
#endif

#ifndef _LISTVIEW_H
#include "listview.h"
#endif

// WINS Service file
extern "C" {
    #include "winsintf.h"
    #include "ipaddr.h"
}

#define SERVER_STATS_DEFAULT_WIDTH      450
#define SERVER_STATS_DEFAULT_HEIGHT     300

class CServerStatsFrame;

// structure used for the back ground thread in refreshing the stats
struct ThreadInfo
{
    DWORD dwInterval;
	CServerStatsFrame*  pDlg;
};


class CServerStatsFrame : public StatsDialog
{
public:
	CServerStatsFrame();
	~CServerStatsFrame();

	// Override the OnInitDialog so that we can set the caption
	virtual BOOL OnInitDialog();

	// Override the RefreshData to provide sample data
	virtual HRESULT RefreshData(BOOL fGrabNewData);

	// Override the Sort to provide the ability to do sorting
	virtual void Sort(UINT nColumnId);

    // custom methods
    afx_msg long OnNewStatsAvailable(UINT wParam, LONG lParam);
    afx_msg long OnUpdateStats(UINT wParam, LONG lParam);
    
    void  UpdateWindow(PWINSINTF_RESULTS_T  pwrResults);
    DWORD GetStats();

    void SetNode(ITFSNode * pNode) { m_spNode.Set(pNode); }
    void SetServer(LPCTSTR pServer) { m_strServerAddress = pServer; }

	// message handlers
	afx_msg void OnDestroy();
	afx_msg	void OnClear();

    DECLARE_MESSAGE_MAP()
    
protected:
    CString         m_strServerAddress;
    SPITFSNode      m_spNode;

	CWinThread *	m_pRefreshThread;
	HANDLE			m_hmutStatistics;

    // helper functions 
	void StartRefresherThread();
	void UpdatePartnerStats();

public:
	WINSINTF_RESULTS_T  m_wrResults;
    HANDLE              m_hAbortEvent;
	
    DWORD	GetRefreshInterval();
    void    ReInitRefresherThread();
	void    KillRefresherThread();

	// Context Help Support
    virtual DWORD * GetHelpMap() { return WinsGetHelpMap(IDD_STATS_NARROW); }
};

#endif _SERVSTAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\verify.c ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    verify.c
        Comment goes here

    FILE HISTORY:

*/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "tchar.h"

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <wtypes.h>

#include <fcntl.h>
#include <ctype.h>

#include <windows.h>
#include <windowsx.h>
#include <tdi.h>

#include <winsock.h>
#include <wsahelp.h>
#include <nameser.h>
//#include <resolve.h>
#include <nb30.h>
#include <nbtioctl.h>

#define WINS_CLIENT_APIS
#include "winsintf.h"
#include "resource.h"
#include "verify.h"


//
// The format of Adapter Status responses
//
typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;


#define WINSTEST_FOUND            0
#define WINSTEST_NOT_FOUND        1
#define WINSTEST_NO_RESPONSE      2

#define WINSTEST_VERIFIED         0
#define WINSTEST_OUT_OF_MEMORY    3
#define WINSTEST_BAD_IP_ADDRESS   4
#define WINSTEST_HOST_NOT_FOUND   5
#define WINSTEST_NOT_VERIFIED     6

#define WINSTEST_INVALID_ARG      7
#define WINSTEST_OPEN_FAILED      8

TCHAR    *messages[] = {
                        L"success",
                        L"name not found",
                        L"no response",
                        L"out of memory",
                        L"bad ip address",
                        L"host not found",
                        L"host address not verified",
                        L"invalid argument",
                        L"failed to open NBT driver"
                     };



#define MAX_NB_NAMES 1000
#define MAX_SERVERS  1000
#define MAX_SIZE     1024

SOCKET  sd;
WSADATA WsaData;

HWND	    g_wndDlg = NULL;
HWND        g_hwndParent = NULL;
HANDLE      g_hThread = NULL;
HINSTANCE   g_hInstance = NULL;

HRESULT foo;

struct  sockaddr_in myad;
struct  sockaddr_in recvad;
int     addrlen;
u_short TranID;
u_long  NonBlocking = 1;

int      NumWinServers = 0;
int      NumNBNames = 0;
u_char * NBNames[MAX_NB_NAMES];
u_long   VerifiedAddress[MAX_NB_NAMES];

//char  lpResults[MAX_SIZE];
//TCHAR  lpResults[MAX_SIZE];
//lpResults = (char*) malloc  (64536);

WINSERVERS WinServers[MAX_SERVERS];

#define NBT_NONCODED_NMSZ   17
#define NBT_NAMESIZE        34

ULONG   NetbtIpAddress;
CHAR    pScope[BUFF_SIZE];

NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );


INT_PTR CALLBACK
dlgProc(
		 HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    int ntest;

	switch (Message)
	{
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    EndDialog(hWnd, IDCANCEL);
                    return TRUE;
            }
            break;

        case WM_INITDIALOG:
            g_wndDlg = hWnd;
            break;

        default:
            return FALSE;
    }

	return TRUE;
}

void ToWCS(LPCSTR szMBCSString, LPWSTR lpWideString)
{
	int nResult;

	// determone the size first
	nResult = MultiByteToWideChar(
						CP_ACP,
						MB_COMPOSITE,
						szMBCSString,
						-1,
						lpWideString,
						0);

	MultiByteToWideChar(
						CP_ACP,
						MB_COMPOSITE,
						szMBCSString,
						-1,
						lpWideString,
						nResult);

    lpWideString[nResult + 1] = '\0';
}

void AddStatusMessageW(LPCWSTR pszMessage)
{
    HWND    hwndEdit;
    MSG     msg;

    hwndEdit = GetDlgItem(g_wndDlg, IDC_EDIT_MESSAGE);

	SetFocus (hwndEdit);
    SendMessage (hwndEdit, EM_SETSEL, -1, -1);
    SendMessage (hwndEdit, EM_REPLACESEL, 0, (LPARAM) ((LPCTSTR) pszMessage));

    // give the window some time to process the message
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
}

void AddStatusMessage(LPCSTR pszMessage)
{
    WCHAR   szBuffer[MAX_SIZE];

    ToWCS(pszMessage, szBuffer);

    AddStatusMessageW(szBuffer);
}

DWORD
GetStatus(
        BOOL            fPrint,
        LPVOID          pResultsA,
        BOOL            fNew,
        BOOL            fShort,
        PUCHAR          IpAddr
        )
{
        DWORD                     Status, i;
        struct in_addr            InAddr;
        PWINSINTF_RESULTS_T       pResults = pResultsA;
        PWINSINTF_RESULTS_NEW_T   pResultsN = pResultsA;
        PWINSINTF_ADD_VERS_MAP_T  pAddVersMaps;
        DWORD                     NoOfOwners;
        handle_t                  BindHdl;
        WINSINTF_BIND_DATA_T      BindData;
        char                      lpResults[MAX_SIZE] = {0};
        TCHAR                     szErrMsg[MAX_SIZE];

		WCHAR  WcharString1[WINSINTF_MAX_NAME_SIZE] = {0};

		int nSize = MultiByteToWideChar(CP_ACP,
							MB_PRECOMPOSED,
							IpAddr,
							-1,
							WcharString1,
							0
							);

		MultiByteToWideChar(CP_ACP,
							MB_PRECOMPOSED,
							IpAddr,
							-1,
							WcharString1,
							nSize
							);

		WcharString1[nSize] = '\0';

		BindData.fTcpIp = TRUE;
        BindData.pServerAdd = (LPSTR) (LPTSTR) WcharString1;

		strcpy(lpResults, "");
		strcat(lpResults, "*****\r\n" );
		strcat(lpResults, "Getting map table from " );
		strcat(lpResults, IpAddr);
		strcat(lpResults, "\r\n");

        AddStatusMessage(lpResults);

        BindHdl = WinsBind(&BindData);
        if (BindHdl == NULL)
        {
    		strcpy(lpResults, "");
            strcat(lpResults, "Unable to bind to " );
            strcat(lpResults, IpAddr);
            strcat(lpResults, "\r\n");

            AddStatusMessage(lpResults);

            return STATUS_SUCCESS;
        }

        if (!fNew)
        {
#ifdef WINS_CLIENT_APIS
            Status = WinsStatus(BindHdl, WINSINTF_E_CONFIG, pResultsA);
#else
            Status = WinsStatus(WINSINTF_E_CONFIG, pResultsA);
#endif  WINS_CLIENT_APIS
        }
        else
        {
            pResultsN->pAddVersMaps = NULL;

#ifdef WINS_CLIENT_APIS
            Status = WinsStatusNew(BindHdl, WINSINTF_E_CONFIG, pResultsN);
#else
            Status = WinsStatusNew(WINSINTF_E_CONFIG, pResultsN);
#endif WINS_CLIENT_APIS
        }

		if (Status == 0)
		{
			//strcpy(lpResults, "");
			//strcat(lpResults, "SUCCESS \r\n");

            //AddStatusMessage(lpResults);
        }
		else
		{
            wsprintfA(lpResults, "Get Wins Status failed! Error: %d\r\n", Status);
            AddStatusMessage(lpResults);
		}

        if (Status == WINSINTF_SUCCESS)
        {
            if (fPrint)
            {
                if (!fNew)
                {
                     pAddVersMaps = pResults->AddVersMaps;
                     NoOfOwners = pResults->NoOfOwners;
                }
                else
                {
                     pAddVersMaps = pResultsN->pAddVersMaps;
                     NoOfOwners = pResultsN->NoOfOwners;
                }

                if (NoOfOwners == 0)
                {
					strcpy(lpResults, "");
                    strcat(lpResults, "The database list of owners is empty.\r\n");

                    AddStatusMessage(lpResults);

         		    Status = WINSINTF_FAILURE;
                }
            }
        }

        WinsUnbind(&BindData, BindHdl);

        return(Status);
}

//------------------------------------------------------------------------
NTSTATUS
GetIpAddress(
    IN HANDLE           fd,
    OUT PULONG          pIpAddress
    )

/*++

Routine Description:

    This function calls into netbt to get the ip address.

Arguments:

   fd - file handle to netbt
   pIpAddress - the ip address returned

Return Value:

   ntstatus

History:
    27-Dec-1995 CDermody    copied from nbtstat.c

--*/

{
    NTSTATUS    status;
    ULONG       BufferSize=100;
    PVOID       pBuffer;

    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = DeviceIoCtrl(fd,
                         pBuffer,
                         BufferSize,
                         IOCTL_NETBT_GET_IP_ADDRS,
                         NULL,
                         0);

    if (NT_SUCCESS(status))
    {
        *pIpAddress = *(ULONG *)pBuffer;
    }
    else
    {
        *pIpAddress = 0;
    }

    LocalFree(pBuffer);

    return(status);
}

//------------------------------------------------------------------------
NTSTATUS
GetInterfaceList
(
    char pDeviceName[][MAX_NAME+1]
)
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string, AnsiString;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    char                pNbtWinsDeviceName[MAX_NAME] = "\\Device\\NetBt_Wins_Export";

    PUCHAR  SubKeyParms = "system\\currentcontrolset\\services\\netbt\\parameters";
    PUCHAR  Scope = "ScopeId";
    CHAR    pScopeBuffer[BUFF_SIZE];
    HKEY    Key;
    LONG    Type;
    ULONG   size;

    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize = 10 * sizeof(NETBT_ADAPTER_INDEX_MAP) + sizeof(ULONG);
    PVOID                   pInput = NULL;
    ULONG                   SizeInput = 0;

    LONG    i, index = 0;

    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
    if (!pInterfaceInfo)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitString(&name_string, pNbtWinsDeviceName);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString(&uc_name_string);

    if (NT_SUCCESS (status))
    {
        do
        {
            status = DeviceIoCtrl(StreamHandle,
                                 pInterfaceInfo,
                                 InterfaceInfoSize,
                                 IOCTL_NETBT_GET_INTERFACE_INFO,
                                 pInput,
                                 SizeInput);

            if (status == STATUS_BUFFER_OVERFLOW)
            {
                LocalFree(pInterfaceInfo);
                pInterfaceInfo = NULL;

                InterfaceInfoSize *= 2;
                if (InterfaceInfoSize != 0xFFFF)
                {
                    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
                }

                if (!pInterfaceInfo)
                {
                    NtClose(StreamHandle);
                    //NlsPerror(COMMON_UNABLE_TO_ALLOCATE_PACKET,0);
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
            else if (!NT_SUCCESS (status))
            {
                LocalFree(pInterfaceInfo);

                NtClose(StreamHandle);
                return(status);
            }

        } while (status == STATUS_BUFFER_OVERFLOW);
        NtClose (StreamHandle);

        for (i = 0; i<pInterfaceInfo->NumAdapters; i++)
        {
            RtlInitString(&name_string, NULL);
            RtlInitUnicodeString(&uc_name_string, pInterfaceInfo->Adapter[i].Name);
            if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&name_string, &uc_name_string, TRUE)))
            {
                size = (name_string.Length > MAX_NAME) ? MAX_NAME : name_string.Length;

                strncpy(pDeviceName[index], name_string.Buffer, size);
                pDeviceName[index][size] = '\0';
                RtlFreeAnsiString (&name_string);

                index++;
            }
        }

        //
        // NULL out the next device string ptr
        //
        if (index < NBT_MAXIMUM_BINDINGS)
        {
            pDeviceName[index][0] = '\0';
        }

        //
        // Read the ScopeId key!
        //
        size = BUFF_SIZE;
        *pScope = '\0';     // By default
        status = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                     SubKeyParms,
                     0,
                     KEY_READ,
                     &Key);

        if (status == ERROR_SUCCESS)
        {
            // now read the Scope key
            status = RegQueryValueExA(Key, Scope, NULL, &Type, pScopeBuffer, &size);
            if (status == ERROR_SUCCESS)
            {
                strcpy(pScope,pScopeBuffer);
            }
            status = RegCloseKey(Key);
        }

        status = STATUS_SUCCESS;
    }

    if (pInterfaceInfo != NULL)
        LocalFree(pInterfaceInfo);

    return status;
}

//------------------------------------------------------------------------
NTSTATUS
OpenNbt(
    IN char path[][MAX_NAME+1],
    OUT PHANDLE pHandle,
    int max_paths
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    LONG                index=0;

    ASSERT ( max_paths <= NBT_MAXIMUM_BINDINGS );

    while ((path[index][0] != '\0') && (index < max_paths))
    {
        RtlInitString(&name_string, path[index]);
        RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status =
        NtCreateFile(
            &StreamHandle,
            SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0);

        RtlFreeUnicodeString(&uc_name_string);

        if (NT_SUCCESS(status))
        {
            *pHandle = StreamHandle;
            return(status);
        }

        ++index;
    }

    return (status);
} // s_open

//------------------------------------------------------------------------
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )

/*++

Routine Description:

    This procedure performs an ioctl(I_STR) on a stream.

Arguments:

    fd        - NT file handle
    iocp      - pointer to a strioctl structure

Return Value:

    0 if successful, non-zero otherwise.

History:
    27-Dec-1995 CDermody    copied from nbtstat.c
--*/

{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;


    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);
}

/****************************************************************************/
/*      CheckRemoteTable                                                    */
/*                                                                          */
/*  This routine does an adapter status query to get the remote name table  */
/*  then checks to see if a netbios name is contained in it.                */
/*                                                                          */
/*  Parameters:                                                             */
/*      RemoteName, the IP address (asci nn.nn.nn.nn format) of a server to */
/*                  query.                                                  */
/*      SearchName, a net bios name.                                        */
/*                                                                          */
/*  Return:                                                                 */
/*      WINSTEST_VERIFIED       The name exists in the remote name table    */
/*      WINSTEST_NOT_VERIFIED   The name does not exist in the remote table */
/*      WINSTEST_BAD_IP_ADDRESS inet_addr could not convert the ip address  */
/*                              character string.                           */
/*      WINSTEST_HOST_NOT_FOUND Could not reach ip address                  */
/*      WINSTEST_OUT_OF_MEMORY  Out of memory                               */
/*  History:                                                                */
/*      27-Dec-1995     CDermody    created following example of nbtstat.c  */
/****************************************************************************/

int
CheckRemoteTable(
    IN HANDLE   fd,
    IN PCHAR    RemoteName,
    IN PCHAR    SearchName
    )

{
    LONG                        Count;
    LONG                        i;
    PVOID                       pBuffer;
    ULONG                       BufferSize=600;
    NTSTATUS                    status;
    tADAPTERSTATUS              *pAdapterStatus;
    NAME_BUFFER                 *pNames;
    CHAR                        MacAddress[20];
    tIPANDNAMEINFO              *pIpAndNameInfo;
    ULONG                       SizeInput;
    ULONG                       IpAddress;
    USHORT                      BytesToCopy;


    pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
    if (!pBuffer)
    {
        return(WINSTEST_OUT_OF_MEMORY);
    }

    status = STATUS_BUFFER_OVERFLOW;
    pIpAndNameInfo = LocalAlloc(LMEM_FIXED,sizeof(tIPANDNAMEINFO));
    if (!pIpAndNameInfo)
    {
        LocalFree(pBuffer);
        return(WINSTEST_OUT_OF_MEMORY);
    }

    RtlZeroMemory((PVOID)pIpAndNameInfo,sizeof(tIPANDNAMEINFO));

    //
    // Convert the remote name which is really a dotted decimal ip address
    // into a ulong
    //
    IpAddress = inet_addr(RemoteName);

    //
    // Don't allow zero for the address since it sends a broadcast and
    // every one responds
    //
    if ((IpAddress == INADDR_NONE) || (IpAddress == 0))
    {
        LocalFree(pBuffer);
        LocalFree(pIpAndNameInfo);

        return(WINSTEST_BAD_IP_ADDRESS);
    }

    pIpAndNameInfo->IpAddress = ntohl(IpAddress);

    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosName[0] = '*';


    pIpAndNameInfo->NetbiosAddress.TAAddressCount = 1;
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressLength
        = sizeof(TDI_ADDRESS_NETBIOS);
    pIpAndNameInfo->NetbiosAddress.Address[0].AddressType
        = TDI_ADDRESS_TYPE_NETBIOS;
    pIpAndNameInfo->NetbiosAddress.Address[0].Address[0].NetbiosNameType
        = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

    SizeInput = sizeof(tIPANDNAMEINFO);

    while (status == STATUS_BUFFER_OVERFLOW)
    {
        status = DeviceIoCtrl(fd,
                             pBuffer,
                             BufferSize,
                             IOCTL_NETBT_ADAPTER_STATUS,
                             pIpAndNameInfo,
                             SizeInput);

        if (status == STATUS_BUFFER_OVERFLOW)
        {
            LocalFree(pBuffer);

            BufferSize *=2;
            pBuffer = LocalAlloc(LMEM_FIXED,BufferSize);
            if (!pBuffer || (BufferSize == 0xFFFF))
            {
                LocalFree(pIpAndNameInfo);

                return(WINSTEST_OUT_OF_MEMORY);
            }
        }
    }

    pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
    if ((pAdapterStatus->AdapterInfo.name_count == 0) ||
        (status != STATUS_SUCCESS))
    {
        LocalFree(pIpAndNameInfo);
        LocalFree(pBuffer);

        return(WINSTEST_HOST_NOT_FOUND);
    }

    pNames = pAdapterStatus->Names;
    Count = pAdapterStatus->AdapterInfo.name_count;

    status = 1;

    while (Count--)
    {
        if (0 == _strnicmp(SearchName, pNames->name, strlen(SearchName)))
        {
            LocalFree(pIpAndNameInfo);
            LocalFree(pBuffer);

            return WINSTEST_VERIFIED; // found
        }

        pNames++;
    }

    LocalFree(pIpAndNameInfo);
    LocalFree(pBuffer);

    return WINSTEST_NOT_VERIFIED;
}


/****************************************************************************/
/*      VerifyRemote                                                        */
/*                                                                          */
/*  This routine checks to see if a netbios name is contained in the remote */
/*  name table at a given IP address.                                       */
/*                                                                          */
/*  Parameters:                                                             */
/*      RemoteName, the IP address (asci nn.nn.nn.nn format) of a server to */
/*                  query.                                                  */
/*      NBName,     a net bios name.                                        */
/*                                                                          */
/*  Return:                                                                 */
/*      WINSTEST_VERIFIED       The name exists in the remote name table    */
/*      WINSTEST_NOT_VERIFIED   The name does not exist in the remote table */
/*      WINSTEST_BAD_IP_ADDRESS inet_addr could not convert the ip address  */
/*                              character string.                           */
/*      WINSTEST_OPEN_FAILED    Could not open NBT driver or could not read */
/*                              the NBT driver info from the registry.      */
/*      WINSTEST_HOST_NOT_FOUND Could not reach ip address                  */
/*      WINSTEST_OUT_OF_MEMORY  Out of memory                               */
/*  History:                                                                */
/*      27-Dec-1995     CDermody    created following example of nbtstat.c  */
/****************************************************************************/

int VerifyRemote(IN PCHAR RemoteName, IN PCHAR NBName)
{
    NTSTATUS    status;
    LONG        interval=-1;
    HANDLE      nbt = 0;
    int         nStatus;
    int         index;
    CHAR        pDeviceName[NBT_MAXIMUM_BINDINGS+1][MAX_NAME+1];

    status = GetInterfaceList(pDeviceName);
    if (!NT_SUCCESS(status))
    {
        return WINSTEST_OPEN_FAILED;
    }

    for (index = 0; index < NBT_MAXIMUM_BINDINGS && pDeviceName[index][0]; index++)
    {
        //
        //  Open the device of the appropriate streams module to start with.
        //
        status = OpenNbt(&pDeviceName[index], &nbt, NBT_MAXIMUM_BINDINGS-index);
        if (!NT_SUCCESS(status))
        {
            //
            // Try the next binding!
            //
            continue;
        }

        GetIpAddress(nbt, &NetbtIpAddress);

        if (RemoteName[0] == '\0')
            return WINSTEST_INVALID_ARG;

        nStatus = CheckRemoteTable(nbt,RemoteName,NBName);
        if (nStatus == WINSTEST_VERIFIED)
            break;
    }

    return nStatus;
}


/*************************************************************/
/*        NBDecode(name,name2)                               */
/*                                                           */
/* This routine decodes a netbios name from level2 to leve1. */
/* name is 16 bytes long, remember that.                     */
/*                                                           */
/*************************************************************/

void
NBDecode(
    unsigned char *name,
    unsigned char *name2
    )
{
  int i;

  for (i = 0; i < NBT_NONCODED_NMSZ - 1; i++)
  {
     name[i] = (name2[2*i+1] - 0x41)*(NBT_NONCODED_NMSZ-1) +
               (name2[2*i+2] - 0x41);
  }

}

/*************************************************************/
/*        NBEncode(name2,name)                               */
/*                                                           */
/* This routine code a netbios name from level1 to level2.   */
/* name2 has to be NBT_NAMESIZE bytes long, remember that.   */
/*************************************************************/

void
NBEncode(
    unsigned char *name2,
    unsigned char *name
    )
{
    int i;

    name2[0] = 0x20;        /* length of first block */

    for (i = 0; i < NBT_NONCODED_NMSZ - 1; i++)
    {
        name2[ 2*i+1 ] =  ((name[ i ] >> 4) & 0x0f) + 0x41;
        name2[ 2*i+2 ] =  (name[ i ]  & 0x0f) + 0x41;
    }

    name2[ NBT_NAMESIZE-1 ] = 0;    /* length of next block */
}

ULONG
AddWins(
    IN  ULONG   IPAddr
    )
{
    INT i;

    for (i = 0; i < MAX_SERVERS; i++)
    {
        if (WinServers[i].Server.s_addr == IPAddr)
        {
            return 0;
        }

        if (WinServers[i].Server.s_addr == 0)
        {
            WinServers[i].Server.s_addr = IPAddr;
			NumWinServers++;
            return i;
        }
    }

    return 0;
}

VOID
PurgeWinsAddr(
    IN  ULONG   IPAddr
    )
{
    INT i;

    for (i = 0; i < MAX_SERVERS; i++)
    {
        if (WinServers[i].Server.s_addr == IPAddr)
        {
            INT j = i + 1;

            while (WinServers[j].Server.s_addr)
            {
                WinServers[j - 1] = WinServers[j];
                j++;
            }

            //
            // Zap the last entry
            //
            WinServers[j - 1].Server.s_addr = 0;

            break;
        }
    }
}

/*******************************************************************/
/*                                                                 */
/* Initialize the WinServers table and set NumWinServers to count  */
/*                                                                 */
/*******************************************************************/

BOOLEAN
InitServers(char *szServer, BOOL fVerifyWithPartners)
{
    FILE *                  sf = NULL;
    int                     i = 0;
    ULONG                   j = 0;
    u_char                  buffer[100] = {0};
    WINSINTF_RESULTS_NEW_T  ResultsN;
    struct in_addr          InAddr;
    char	                szNum[10] = {0};
    char                    lpResults[MAX_SIZE] = {0};

	strcpy(buffer, szServer);

    //WinServers[i].Server.s_addr = inet_addr(buffer);
	InAddr.s_addr = inet_addr(buffer);
    AddWins(InAddr.s_addr);

	if (fVerifyWithPartners)
	{
		if (GetStatus(TRUE, &ResultsN, TRUE, FALSE, inet_ntoa(InAddr)))
		{
			strcpy(lpResults, "");
			strcat(lpResults, "Unable to verify against the WINS server: ");
			strcat(lpResults, inet_ntoa(InAddr));
			strcat(lpResults, "\r\n\r\n");

			AddStatusMessage(lpResults);

			return FALSE;
		}

		//
		// Enter all the WINS server names into the server table
		//
		for (j = 0; j < ResultsN.NoOfOwners; j++)
		{
			//
			// Add addresses; check for duplicates
			//
			struct  in_addr InAddr;
			InAddr.s_addr = htonl(ResultsN.pAddVersMaps[j].Add.IPAdd);
			(VOID)AddWins(htonl(ResultsN.pAddVersMaps[j].Add.IPAdd));
		}

		//NumWinServers = ResultsN.NoOfOwners;

		strcpy(lpResults, "");
		_itoa(NumWinServers, szNum, 10);
		strcat(lpResults, szNum);
		strcat(lpResults, " Wins servers will be Queried:\r\n");

		AddStatusMessage(lpResults);

		for (i = 0; i < NumWinServers; i++)
		{
			struct in_addr  InAddr;

			InAddr.s_addr = WinServers[i].Server.s_addr;

			strcpy(lpResults, "");
			strcat(lpResults, inet_ntoa(InAddr));
			strcat(lpResults,"\r\n");

			AddStatusMessage(lpResults);
		}
	}

    return  TRUE;
}



/*******************************************************************/
/*                                                                 */
/* Send a Name Query to a WINS Server                              */
/*                                                                 */
/* name is the name to query                                       */
/* winsaddr is the ip address of the wins server to query          */
/* TransID is the transaction ID to use for the query              */
/*                                                                 */
/*******************************************************************/

void
_stdcall
SendNameQuery(
    unsigned char *name,
    u_long winsaddr,
    u_short TransID
    )
{
    struct sockaddr_in destad;
    char    lpResults[MAX_SIZE] = {0};
    char    paddedname[NBT_NONCODED_NMSZ];

    struct
    {
        u_short TransactionID;
        u_short Flags;
        u_short QuestionCount;
        u_short AnswerCount;
        u_short NSCount;
        u_short AdditionalRec;
        u_char  QuestionName[NBT_NAMESIZE];
        u_short QuestionType;
        u_short QuestionClass;
    } NameQuery;

    memset(paddedname, 0x20, sizeof(paddedname));
    memcpy(paddedname, name, strlen(name));

    NBEncode(NameQuery.QuestionName, paddedname);

    NameQuery.TransactionID = htons(TransID);
    NameQuery.Flags = htons(0x0100);
    NameQuery.QuestionCount = htons(1);
    NameQuery.AnswerCount = 0;
    NameQuery.NSCount = 0;
    NameQuery.AdditionalRec = 0;
    NameQuery.QuestionType = htons(0x0020);
    NameQuery.QuestionClass = htons(1);

    destad.sin_family = AF_INET;
    destad.sin_port = htons(137);
    destad.sin_addr.s_addr = winsaddr;

    if (sendto(sd, (char *)&NameQuery, sizeof(NameQuery), 0,
                   (struct sockaddr *)&destad, sizeof(destad)) == SOCKET_ERROR)
    {
        wsprintfA(lpResults, "sendto() failed. Error %d. \r\n", WSAGetLastError());

        AddStatusMessage(lpResults);

        // exit(1);
        return;
    }
}

/*******************************************************************/
/*                                                                 */
/* Wait for a Name Response which matches the Transaction ID       */
/*                                                                 */
/* recvaddr is the ip address returned by the wins server          */
/*                                                                 */
/*******************************************************************/

int
_stdcall
GetNameResponse(
    u_long * recvaddr,
	u_short  TransactionID
    )

{
    char lpResults[100] = {0};
    int i;
    int len;
    int rslt;
    u_long AnswerAddr;
    struct sockaddr_in addr;
    NameResponse * pNameResponse = NULL;
    BYTE Buf[NAME_RESPONSE_BUFFER_SIZE] = {0};

    i = 0;
    while (i < 15)
    {
        addrlen = sizeof(addr);
        if ((len=recvfrom(sd, (char *) Buf, sizeof(Buf), 0,
                     (struct sockaddr *)&addr, &addrlen)) < 0)
        {
            rslt = WSAGetLastError();
            if (rslt == WSAEWOULDBLOCK)
            {
                Sleep(100);
                i++;
                continue;
            }
            else
            {
                wsprintfA(lpResults, "recvfrom() failed. Error %d. \r\n", rslt);
                AddStatusMessage(lpResults);

                return WINSTEST_NO_RESPONSE;
            }
        }

        pNameResponse = (NameResponse *) Buf;

        if (TransactionID == htons(pNameResponse->TransactionID))
        {
            if (htons(pNameResponse->AnswerCount) == 0)
            {
                *recvaddr = 0;
                return(WINSTEST_NOT_FOUND);
            }

            AnswerAddr = (pNameResponse->AnswerAddr2 << 16) | pNameResponse->AnswerAddr1;
            *recvaddr = AnswerAddr;

            return(WINSTEST_FOUND);
        }
    }

    *recvaddr = 0;

    return(WINSTEST_NO_RESPONSE);
}

INT
_stdcall
InitNameCheckSocket()
{
	char lpResults[MAX_SIZE];

    /*  Set up a socket to use for querys and responses   */

    WSAStartup( 0x0101, &WsaData ); // make sure winsock is happy - noop for now

    if ((sd = socket( AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
    {
        //wsprintfA(lpResults, "socket() failed.  Error %d. \r\n", WSAGetLastError());
        //AddStatusMessage(lpResults);

		return WSAGetLastError();
    }

    myad.sin_family = AF_INET;
    myad.sin_addr.s_addr = INADDR_ANY;
    myad.sin_port = htons(0);

    if (bind( sd, (struct sockaddr *)&myad, sizeof(myad) ) < 0)
    {
        //wsprintfA(lpResults, "bind() failed. Error %d. \r\n", WSAGetLastError());
        //AddStatusMessage(lpResults);

        closesocket( sd );
		return WSAGetLastError();
    }

    if (ioctlsocket(sd, FIONBIO, &NonBlocking) < 0)
    {
        //wsprintfA(lpResults, "ioctlsocket() failed. Error %d. \r\n", WSAGetLastError());
        //AddStatusMessage(lpResults);
		return WSAGetLastError();
    }

	return 0;
}

INT
_stdcall
CloseNameCheckSocket()
{
	closesocket(sd);

	WSACleanup();

	return 0;
}

DWORD WINAPI ThreadProc(LPVOID pData)
{
    DialogBox(g_hInstance,
	 	      MAKEINTRESOURCE(IDD_VERSION_CONSIS),
			  g_hwndParent,
			  dlgProc);

    return 29;
}

void CreateConsistencyStatusWindow(HINSTANCE hInstance, HWND hWndParent)
{
	// dialog creation
    // create a new window if we don't have one or it possibly went away
    DWORD dwId;
    MSG   msg;

    g_hInstance = hInstance;
    g_hwndParent = hWndParent;

    if (g_wndDlg && !IsWindow(g_wndDlg))
    {
        CloseHandle(g_hThread);
        g_wndDlg = NULL;
    }

    if (!g_wndDlg)
    {
        g_hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &dwId);
        while (g_wndDlg == NULL)
        {
            // give the thread a chance to run
            Sleep(0);

            // since we are all on the same message pump, we need to
            // give the system a chance to handle messages
            while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
	        {
		        TranslateMessage(&msg);
		        DispatchMessage(&msg);
	        }
        }
    }
}

void DestroyConsistencyStatusWindow()
{
    BOOL bResult;

	if (IsWindow(g_wndDlg))
    {
        bResult = PostMessage(g_wndDlg, WM_COMMAND, MAKEWPARAM(0, IDCANCEL), 0);
    }

    if (g_wndDlg)
    {
        WaitForSingleObject(g_hThread, 5000);

        CloseHandle(g_hThread);

        g_hThread = NULL;
        g_wndDlg = NULL;
    }
}

void EnableConsistencyCloseButton(BOOL bEnable)
{
    HWND    hButton;
    HMENU   hSysMenu;
    RECT    rect;

    if (IsWindow(g_wndDlg))
    {
        // enable/disable the button
        hButton = GetDlgItem(g_wndDlg, IDCANCEL);
        EnableWindow(hButton, bEnable);

        // now the system menu
        hSysMenu = GetSystemMenu(GetConsistencyStatusWnd(), FALSE);
        EnableMenuItem(hSysMenu, SC_CLOSE, bEnable ? MF_ENABLED : MF_DISABLED);

        GetWindowRect(GetConsistencyStatusWnd(), &rect);
        InvalidateRect(GetConsistencyStatusWnd(), &rect, TRUE);
    }
}

void ClearConsistencyStatusWindow()
{
    HWND hEdit;

    if (IsWindow(g_wndDlg))
    {
        hEdit = GetDlgItem(g_wndDlg, IDC_EDIT_MESSAGE);
        SetWindowText(hEdit, TEXT(""));
    }
}

HWND GetConsistencyStatusWnd()
{
    return g_wndDlg;
}

// this function should be called once before calling either AddWinsServer
// or CheckRegisteredNames
INT
_stdcall
InitNameConsistency(HINSTANCE hInstance, HWND hWnd)
{
	int status = 0;

    // initialize things
	NumWinServers = 0;
    memset(WinServers, 0, sizeof(WinServers));

    CreateConsistencyStatusWindow(hInstance, hWnd);

    InitNameCheckSocket();

	return status;
}

INT
_stdcall
AddWinsServer(char * szServer, BOOL fVerifyWithPartners)
{
    if (!InitServers(szServer, fVerifyWithPartners))
	{
        return FALSE;
	}

	return TRUE;
}

/*********************************************************************/
/*      M a i n                                                      */
/*                                                                   */
/* 27-Dec-1995  CDermody    Rather that report 'is not responding'   */
/*                          for partial response, use multiple       */
/*                          passes over those that were incomplete   */
/*                          and report 'never responded' only for    */
/*                          those that never did.                    */
/*                          Add mechanism to query the purported     */
/*                          owner of the address to see if the       */
/*                          service really exists there.             */
/*********************************************************************/
/*
_cdecl
main (argc, argv)
    int argc;
    char *argv[];
*/
INT
_stdcall
CheckNameConsistency(char* szName)
{
    int             status = 0;
    int             i;
    int             Pass;
    int             ServerInx, NameInx, Inx;
    struct in_addr  retaddr;
    struct in_addr  tempaddr;
    u_long          temp;
    WINSERVERS *    ServerTemp;
    int             retry;
	FILE *          nf;
    TCHAR           szBuffer[MAX_SIZE] = {0};
    TCHAR           szNum[10];
    char            lpResults[100] = {0};

	// initialize some things
    memset(NBNames, 0, sizeof(NBNames));
    memset(VerifiedAddress, 0, sizeof(VerifiedAddress));

    for (i = 0; i < MAX_SERVERS; i++)
    {
        WinServers[i].LastResponse = -1;
        WinServers[i].fQueried = FALSE;
        WinServers[i].Valid = 0;
        WinServers[i].Failed = 0;
        WinServers[i].Retries = 0;
        WinServers[i].Completed = 0;
    }

	SetCursor(LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT)));

	// call InitNameConsistency, then AddWinsServer to build the list of servers
	// to verify this name against.
	NumNBNames = 1;
	NameInx = 0;

	NBNames[NameInx] = malloc(NBT_NONCODED_NMSZ);
    if (NBNames[NameInx] == NULL)
    {
        strcat(lpResults, "malloc(17) failed.\r\n");

        //DestroyStatusWindow();

        return FALSE;
    }

	strcpy(NBNames[NameInx], szName);

    for (Pass = 1; Pass < 3; Pass++)
    {
		_tcscpy(szBuffer, L"");
		_tcscat(szBuffer, L"\r\n");
        _tcscat(szBuffer, L"Pass ");
		_itot(Pass, szNum, 10);
		_tcscat(szBuffer, szNum);
		_tcscat(szBuffer, L"\r\n");
		_tcscat(szBuffer, L"\r\n");

        AddStatusMessageW(szBuffer);

        /*  We initially have no failed servers   */

        for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
        {
            ServerTemp = &WinServers[ServerInx];
			ServerTemp->Failed = 0;
        }

        for (NameInx = 0; NameInx < NumNBNames; NameInx++)
        {
            for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
            {
                ServerTemp = &WinServers[ServerInx];

                if (ServerTemp->Completed)
                {
                    continue;
                }

                retry = 0;
                TranID++;

RetryLoop:
                strcpy(lpResults, "");
                strcat(lpResults, "Sending NameQuery to the server [");
				strcat(lpResults, inet_ntoa(ServerTemp->Server));
				strcat(lpResults, "] for name " );
				strcat(lpResults, NBNames[NameInx]);

                //AddStatusMessage(lpResults);
                SendNameQuery(NBNames[NameInx],
                              ServerTemp->Server.s_addr,
                              TranID);

                switch (GetNameResponse(&retaddr.s_addr, TranID))
                {
                case WINSTEST_FOUND:     // found
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 1;
                    ServerTemp->LastResponse = NameInx;

                    if (retaddr.s_addr == VerifiedAddress[NameInx])
                    {
                        // this address has already been verified... don't
                        // do the checking again
						strcat(lpResults, "; OK.\r\n");

                        AddStatusMessage(lpResults);
                        break;
                    }

                    status = VerifyRemote(inet_ntoa(ServerTemp->RetAddr),
                                          NBNames[NameInx]);


                    if (WINSTEST_VERIFIED == status)
                    {
						strcat(lpResults, "; OK.\r\n");

                        AddStatusMessage(lpResults);

                        VerifiedAddress[NameInx] = retaddr.s_addr;
                    }
                    else
                    {
						strcat(lpResults, "; could not be verified.\r\n");

                        AddStatusMessage(lpResults);
                    }

                    break;

                case WINSTEST_NOT_FOUND:     // responded -- name not found
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 0;
                    ServerTemp->LastResponse = NameInx;

					strcat(lpResults, "; Name not found!\r\n");

                    AddStatusMessage(lpResults);

                    break;

                case WINSTEST_NO_RESPONSE:     // no response
                    ServerTemp->RetAddr.s_addr = retaddr.s_addr;
                    ServerTemp->Valid = 0;
                    ServerTemp->Retries++;

					strcat(lpResults, "; No response.\r\n");

                    AddStatusMessage(lpResults);

                    retry++;
                    if (retry > 2)
                    {
                        ServerTemp->Failed = 1;
                        continue;
                    }

                    goto RetryLoop;

                }   // switch GetNameResponse
            }   // for ServerInx

            for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
            {
                ServerTemp = &WinServers[ServerInx];
                if (ServerTemp->Completed)
                {
                    continue;
                }

                if (ServerTemp->Valid)
                {
                    temp = ServerTemp->RetAddr.s_addr;
                    break;
                }
            }   // for ServerInx

            for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
            {
                ServerTemp = &WinServers[ServerInx];
                if (ServerTemp->Completed)
                {
                    continue;
                }

                if ( (ServerTemp->Valid) )
                {
                    if ((temp != ServerTemp->RetAddr.s_addr)
                        || (0 != VerifiedAddress[NameInx]
                            && temp != VerifiedAddress[NameInx]) )
                    {
						strcpy(lpResults, "");
                        strcat(lpResults, "Inconsistency found with WINS for NetBIOS name ");
						strcat(lpResults, NBNames[NameInx]);
						strcat(lpResults, "\r\n");

                        AddStatusMessage(lpResults);

                        if (0 != VerifiedAddress[NameInx])
                        {
                            tempaddr.s_addr = VerifiedAddress[NameInx];

							strcpy(lpResults, "");
							strcat(lpResults,"NetBIOS name has verified address (");
							strcat(lpResults,inet_ntoa(tempaddr));
							strcat(lpResults, "). \r\n");

                            AddStatusMessage(lpResults);
                        }

                        for (Inx = 0; Inx < NumWinServers; Inx++)
                        {
                            if (WinServers[Inx].Valid)
                            {
								strcpy(lpResults, "");
                                strcat(lpResults,"    NameQuery(");
								strcat(lpResults,inet_ntoa(WinServers[Inx].Server));
								strcat(lpResults, " \\");
								strcat(lpResults, NBNames[NameInx]);
								strcat(lpResults, ")");

                                strcat(lpResults , " = ");
								strcat(lpResults, inet_ntoa(WinServers[Inx].RetAddr));
								strcat(lpResults, " \r\n");

                                AddStatusMessage(lpResults);
                            }
                        }
                        break;
                    }
                }
            }   // for ServerInx
        }   // for NameInx

        for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
        {
            ServerTemp = &WinServers[ServerInx];
            if (!ServerTemp->Failed)
            {
                ServerTemp->Completed = 1;
            }
        } // for ServerInx
    }   // for Pass

    for (ServerInx = 0; ServerInx < NumWinServers; ServerInx++)
    {
        ServerTemp = &WinServers[ServerInx];
        if ((-1) == ServerTemp->LastResponse)
        {
			strcpy(lpResults, "");
            strcat(lpResults,"WINS Server ");
			strcat(lpResults, inet_ntoa(ServerTemp->Server));
			strcat(lpResults, " never responded! \r\n");

            AddStatusMessage(lpResults);
        }
        else if (0 == ServerTemp->Completed)
        {
			strcpy(lpResults, "");
            strcat(lpResults, "WINS Server ");
			strcat(lpResults, inet_ntoa(ServerTemp->Server));
			strcat(lpResults, " incomplete!\r\n");

            AddStatusMessage(lpResults);
        }
    }   // for ServerInx

    for (NameInx = 0; NameInx < NumNBNames; NameInx++)
    {
        if (0 == VerifiedAddress[NameInx])
        {
			strcpy(lpResults, "");
            strcat(lpResults,"Could not verify address for name (");
			strcat(lpResults, NBNames[NameInx]);
			strcat(lpResults, ").\r\n\r\n");

            AddStatusMessage(lpResults);
        }
    }   // for NameInx
    // exit(0);

	if (NBNames[0])
        free(NBNames[0]);

    return 1;   // just to keep the compiler happy -- why do we have to?
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\status.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	status.cpp
		wins status scope pane node handler. 
		
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "status.h"
#include "server.h"
#include "statnode.h"
#include "dhcp.h"
#include "statndpp.h"

#define WINS_MESSAGE_SIZE       576   
#define ANSWER_TIMEOUT          20000


/*---------------------------------------------------------------------------
	CWinsStatusHandler::CWinsStatusHandler
		Description
 ---------------------------------------------------------------------------*/
CWinsStatusHandler::CWinsStatusHandler
(
    ITFSComponentData * pCompData,
	DWORD               dwUpdateInterval
) : CMTWinsHandler(pCompData),
	m_hListenThread(NULL),
	m_hMainMonThread(NULL),
	m_hPauseListening(NULL),
	m_nServersUpdated(0)
{
	m_bExpanded = FALSE;
	m_nState = loaded;
	m_dwUpdateInterval = dwUpdateInterval;
    
    // from class ThreadHandler
    m_uMsgBase = 0;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::CWinsStatusHandler
		Destructor
 ---------------------------------------------------------------------------*/
CWinsStatusHandler::~CWinsStatusHandler()
{
	m_listServers.RemoveAll();
	
    if (m_uMsgBase)
    {
        ::SendMessage(m_hwndHidden, WM_HIDDENWND_REGISTER, FALSE, m_uMsgBase);
        m_uMsgBase = 0;
    }

    CloseSockets();
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::DestroyHandler
	    Release and pointers we have here
    Author: EricDav
----------------------------------------------------------------------------*/
HRESULT
CWinsStatusHandler::DestroyHandler
(
	ITFSNode * pNode
)
{
    m_spNode.Set(NULL);
    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::OnCreateNodeId2
		Returns a unique string for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CWinsStatusHandler::OnCreateNodeId2(ITFSNode * pNode, CString & strId, DWORD * dwFlags)
{
    const GUID * pGuid = pNode->GetNodeType();

    CString strGuid;

    StringFromGUID2(*pGuid, strGuid.GetBuffer(256), 256);
    strGuid.ReleaseBuffer();

    strId = strGuid;

    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::InitializeNode
		Initializes node specific data
----------------------------------------------------------------------------*/
HRESULT
CWinsStatusHandler::InitializeNode
(
	ITFSNode * pNode
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;
	SPITFSNode spParent;
	
	CString strTemp;
	strTemp.LoadString(IDS_SERVER_STATUS_FOLDER);

	SetDisplayName(strTemp);
	
	// Make the node immediately visible
	pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
	pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_SERVER);
	pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_SERVER);
	pNode->SetData(TFS_DATA_USER, (LPARAM) this);
	pNode->SetData(TFS_DATA_TYPE, WINSSNAP_SERVER_STATUS);
	pNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

	SetColumnStringIDs(&aColumns[WINSSNAP_SERVER_STATUS][0]);
	SetColumnWidths(&aColumnWidths[WINSSNAP_SERVER_STATUS][0]);

  	// the event to signal the Listen thread to abort
	m_hAbortListen = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hAbortListen == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hAbortListen %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

   	// the event to signal the main thread to abort
	m_hAbortMain = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hAbortListen == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hAbortMain %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

    // the event to signal the threads to wakeup
	m_hWaitIntervalListen = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hWaitIntervalListen == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hWaitIntervalListen %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

	m_hWaitIntervalMain = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hWaitIntervalMain == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hWaitIntervalMain %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

	// when sending a probe, the thread waits for this
	m_hAnswer = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hAnswer == NULL)
    {
        Trace1("WinsStatusHandler::InitializeNode - CreateEvent Failed m_hAnswer %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }

	return hr;
}


/*---------------------------------------------------------------------------
	Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
	CWinsStatusHandler::GetString
		Implementation of ITFSNodeHandler::GetString
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CWinsStatusHandler::GetString
(
	ITFSNode *	pNode, 
	int			nCol
)
{
	if (nCol == 0 || nCol == -1)
		return GetDisplayName();

	else
		return NULL;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::OnAddMenuItems
		Description
---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsStatusHandler::OnAddMenuItems
(
	ITFSNode *				pNode,
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	LPDATAOBJECT			lpDataObject, 
	DATA_OBJECT_TYPES		type, 
	DWORD					dwType,
	long *					pInsertionAllowed
)
{ 
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;
	
	return hr; 
}


/*!--------------------------------------------------------------------------
	CWinsStatusHandler::HasPropertyPages
		Implementation of ITFSNodeHandler::HasPropertyPages
	NOTE: the root node handler has to over-ride this function to 
	handle the snapin manager property page (wizard) case!!!
	
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsStatusHandler::HasPropertyPages
(
	ITFSNode *			pNode,
	LPDATAOBJECT		pDataObject, 
	DATA_OBJECT_TYPES   type, 
	DWORD               dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	
	HRESULT hr = hrOK;
	
	if (dwType & TFS_COMPDATA_CREATE)
	{
		// This is the case where we are asked to bring up property
		// pages when the user is adding a new snapin.  These calls
		// are forwarded to the root node to handle.
		hr = hrOK;
	}
	else
	{
		// we have property pages in the normal case
		hr = hrOK;
	}

    return hr;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::CreatePropertyPages
		Description
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsStatusHandler::CreatePropertyPages
(
	ITFSNode *				pNode,
	LPPROPERTYSHEETCALLBACK lpProvider,
	LPDATAOBJECT			pDataObject, 
	LONG_PTR    			handle, 
	DWORD					dwType
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT	hr = hrOK;

	Assert(pNode->GetData(TFS_DATA_COOKIE) != 0);

	// Object gets deleted when the page is destroyed
	SPIComponentData spComponentData;
	m_spNodeMgr->GetComponentData(&spComponentData);

	CStatusNodeProperties * pStatProp = 
								new CStatusNodeProperties(pNode, 
															spComponentData, 
															m_spTFSCompData, 
															NULL);

	Assert(lpProvider != NULL);

	return pStatProp->CreateModelessSheet(lpProvider, handle);
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::OnPropertyChange
		Description
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::OnPropertyChange
(	
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataobject, 
	DWORD			dwType, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	LONG_PTR changeMask = 0;

	CStatusNodeProperties * pProp 
		= reinterpret_cast<CStatusNodeProperties *>(lParam);

	// tell the property page to do whatever now that we are back on the
	// main thread
	pProp->OnPropertyChange(TRUE, &changeMask);

	pProp->AcknowledgeNotify();

	if (changeMask)
		pNode->ChangeNode(changeMask);

	return hrOK;
}

HRESULT 
CWinsStatusHandler::OnExpand
(
	ITFSNode *		pNode, 
	LPDATAOBJECT	pDataObject,
	DWORD			dwType,
	LPARAM			arg, 
	LPARAM			param
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;

	if (m_bExpanded)
		return hr;

    m_spNode.Set(pNode);

	// build the list to hold the list of the servers
	BuildServerList(pNode);

	// Create the result pane data here
	CreateNodes(pNode);

	// start monitoring
	StartMonitoring(pNode);

	m_bExpanded  = TRUE;
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsStatusHandler::OnNotifyHaveData
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsStatusHandler::OnNotifyHaveData
(
	LPARAM			lParam
)
{
    // The background wins monitoring stuff sends us a message to update the 
    // status column information
    UpdateStatusColumn(m_spNode);

    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::OnResultRefresh
		Base handler override
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    // wait up the monitoring thread
    SetEvent(m_hWaitIntervalMain);

    return hrOK;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::CompareItems
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(int)
CWinsStatusHandler::CompareItems
(
	ITFSComponent * pComponent, 
	MMC_COOKIE		cookieA, 
	MMC_COOKIE		cookieB, 
	int				nCol
) 
{ 
	SPITFSNode spNode1, spNode2;

	m_spNodeMgr->FindNode(cookieA, &spNode1);
	m_spNodeMgr->FindNode(cookieB, &spNode2);
	
	int nCompare = 0; 

	CServerStatus * pWins1 = GETHANDLER(CServerStatus, spNode1);
	CServerStatus * pWins2 = GETHANDLER(CServerStatus, spNode2);

	switch (nCol)
	{
		// name
        case 0:
            {
       			nCompare = lstrcmp(pWins1->GetServerName(), pWins2->GetServerName());
            }
            break;

        // status
        case 1:
            {
                CString str1;

                str1 = pWins1->GetStatus();
                nCompare = str1.CompareNoCase(pWins2->GetStatus());
            }
            break;
    }

    return nCompare;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::BuildServerList
		Description
	Author: v-shubk
 ---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::BuildServerList(ITFSNode *pNode)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	// get the root node
	SPITFSNode  spRootNode;

	m_spNodeMgr->GetRootNode(&spRootNode);

	// enumerate thro' all the nodes
	HRESULT hr = hrOK;
	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	BOOL bFound = FALSE;

	// get the enumerator for this node
	spRootNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	while (nNumReturned)
	{
		// iterate to teh next node, if the status handler node is seen
		const GUID*               pGuid;
		
		pGuid = spCurrentNode->GetNodeType();

		if (*pGuid != GUID_WinsServerStatusNodeType)
		{
			// add to the list
			CServerStatus* pServ = NULL;
			
			char	szBuffer[MAX_PATH];
			
			CWinsServerHandler * pServer 
				= GETHANDLER(CWinsServerHandler, spCurrentNode);

            CString strTemp = pServer->GetServerAddress();

            // this should be ACP
            WideToMBCS(strTemp, szBuffer);

			pServ = new CServerStatus(m_spTFSCompData);

			strcpy(pServ->szServerName, szBuffer);
			pServ->dwIPAddress = pServer->GetServerIP();
			pServ->dwMsgCount = 0;
			strcpy(pServ->szIPAddress, "");

			m_listServers.Add(pServ);
		}
        
		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}
}


/*---------------------------------------------------------------------------
		CWinsStatusHandler::CreateListeningSockets( ) 
  Abstract:                                                              
      This function initializes Winsock and opens a socket that listens  
      to bcasts the DHCP srv sends to UDP port 68.                       
  Arguments:                                                             
      pListenSockCl  - reference to the socket we're going to open       
                       (argument passed by reference - clean but hidden) 
                       this socket will listen on the DHCP client port   
                       so that it can pick up bcasts on the local segmnt 
      pListenSockSrv - reference to the socket we're going to open       
                       (argument passed by reference - clean but hidden) 
                       this socket will listen on the DHCP server port   
                       so that it can pick up unicasts to the "relay"    
      listenNameSvcSock - reference to the socket we're going to open    
                       (argument passed by reference - clean but hidden) 
                       this socket will listen on the NBT name svc port  
                       so that it can pick up answers from the WINS srv  
                       We have to do this on the socket layer because on 
                       the NetBIOS layer we wouldn't notice that a name  
                       query has been resolved by bcasting.              
  Return value:                                                          
      none                                                               
--------------------------------------------------------------------------*/
HRESULT
CWinsStatusHandler::CreateListeningSockets( ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    int         nResult = 0;    // status info returned from function calls
    WSADATA     wsaData;        // WinSock startup details buffer
	DWORD	    optionValue;	// helper var for setsockopt()
    SOCKADDR_IN	sockAddr;		// struct holding source socket info

	// the event to signal listening thread to pause
	m_hPauseListening = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	if (m_hPauseListening == NULL)
    {
        Trace1("WinsStatusHandler::CreateListeningSockets - CreateEvent Failed m_hPauseListening %d\n", ::GetLastError());
        return HRESULT_FROM_WIN32(::GetLastError());
    }
	
    //  create socket to listen to the WINS servers on the client port (same subnet)
    listenSockCl = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( listenSockCl  == INVALID_SOCKET ) 
	{
        Trace1("\nError %d creating socket to listen to WINS traffic.\n", 
														WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    optionValue = TRUE;
    if ( setsockopt(listenSockCl, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
											WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	optionValue = TRUE;
    if ( setsockopt(listenSockCl, SOL_SOCKET, SO_BROADCAST, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
										WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = 0;			// use any local address
    sockAddr.sin_port = htons( DHCP_CLIENT_PORT );
    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(listenSockCl, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) 
	{
        Trace1("\nError %d binding the listening socket.\n", 
											WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }


    //  create socket to listen to the WINS servers on the server port (remote subnet, fake relay)
    listenSockSrv = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( listenSockSrv  == INVALID_SOCKET ) 
	{
        Trace1("\nError %d creating socket to listen to DHCP traffic.\n", 
													WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    optionValue = TRUE;
    if ( setsockopt(listenSockSrv, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
												WSAGetLastError() );
		return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	optionValue = TRUE;
    if ( setsockopt(listenSockSrv, SOL_SOCKET, SO_BROADCAST, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
											WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = 0;			// use any local address
    sockAddr.sin_port = htons( DHCP_SERVR_PORT );
    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(listenSockSrv, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) 
	{
        Trace1("\nError %d binding the listening socket.\n", 
													WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	
    //  create socket to listen to name svc responses from the WINS server
    listenNameSvcSock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( listenNameSvcSock  == INVALID_SOCKET ) 
	{
        Trace1("\nError %d creating socket to listen to WINS traffic.\n", WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    optionValue = TRUE;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
													WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	optionValue = FALSE;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_BROADCAST, (const char *)&optionValue, sizeof(optionValue)) ) 
	{
        Trace1("\nError %d setting SO_REUSEADDR option.\n", 
												WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = INADDR_ANY;
    sockAddr.sin_port = 0;
    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(listenNameSvcSock, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) 
	{
        Trace1("\nError %d binding the listening socket.\n", 
											WSAGetLastError() );
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

	return hrOK;

} 


/*---------------------------------------------------------------------------
		CWinsStatusHandler::ListeningThreadFunc( ) 
  Abstract:                                                              
      A blocking recvfrom() is sitting in an infinite loop. Whenever we  
      receive anything on our listening socket we do a quick sanity chk  
      on the packet and then increment a counter.                        
      The processing is kept minimal to spare the CPU cycles.            
  Arguments:                                                             
      pListenSock - pointer to the socket set we've opened to listen for 
                    xmits from the server                                
  Return value:                                                          
      none                                                               
---------------------------------------------------------------------------*/
DWORD WINAPI 
CWinsStatusHandler::ListeningThreadFunc( ) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    SOCKADDR_IN   senderSockAddr;
	int			  nSockAddrSize = sizeof( senderSockAddr );
	int		      nBytesRcvd = 0;
    int           nSocksReady;
	char		  MsgBuf[WINS_MESSAGE_SIZE];
    int           nSockNdx;
    LPBYTE        MagicCookie;
    SOCKET        listenSock;
    fd_set        localSockSet;         // to take care of reinit for select()
	char		  szOutput[MAX_PATH];
    
    while ( TRUE ) 
	{
		// check if the thread needs to be aborted
		if (WaitForSingleObject(m_hPauseListening, 0) == WAIT_OBJECT_0)
        {
    		Trace0("CWinsStatusHandler::ListenThreadFun - going to sleep\n");

            // wait until we are woken up or the next time interval expires
		    WaitForSingleObject(m_hWaitIntervalListen, INFINITE);
    		Trace0("CWinsStatusHandler::ListenThreadFun - waking up\n");
        }

        if (WaitForSingleObject(m_hAbortListen, 0) == WAIT_OBJECT_0)
        {
            // we are going away.. break out man
    		Trace0("CWinsStatusHandler::ListenThreadFun - abort detected, bye bye\n");
            break;
        }

        // reinit the select set in every loop
        localSockSet = m_listenSockSet;

		timeval tm;
		tm.tv_sec = 5;

		// number of sockets ready
        nSocksReady = select( 0, &localSockSet, NULL, NULL, &tm );
		if ( nSocksReady == SOCKET_ERROR ) 
		{ 
            Trace1("select() failed with error %d.\n", WSAGetLastError() );
        }

	    for ( nSockNdx = 0; nSockNdx < nSocksReady; nSockNdx++ ) 
		{
            listenSock = localSockSet.fd_array[nSockNdx];

            nBytesRcvd = recvfrom( listenSock, MsgBuf, sizeof(MsgBuf), 0, (LPSOCKADDR )&senderSockAddr, &nSockAddrSize );
		    if ( nBytesRcvd == SOCKET_ERROR ) 
			{ 
                Trace1( "recvfrom() failed with error %d.\n", WSAGetLastError() );
            }

			strcpy(szOutput, (LPSTR)inet_ntoa(senderSockAddr.sin_addr));
			CString strOutput(szOutput);

            Trace2("ListeningThreadFunc(): processing frame from %s port %d \n", strOutput, ntohs(senderSockAddr.sin_port));
            
			//  process incoming WINS
            if ( (listenSock == listenNameSvcSock) && 
                 (senderSockAddr.sin_port == NBT_NAME_SERVICE_PORT) 
               ) 
            {
				strcpy(szOutput, (LPSTR)inet_ntoa(senderSockAddr.sin_addr));
				CString str(szOutput);

                Trace1("ListeningThreadFunc(): processing WINS frame from %s \n", str);
                 
               	int nCount = GetListSize();
				for ( int i=0; i < nCount ; i++) 
				{
					CServerStatus *pWinsSrvEntry = GetServer(i);

					// check if the server has been deleted in the scope pane
					if (IsServerDeleted(pWinsSrvEntry))
						continue;

					// get the iP address for the server
					DWORD dwIPAdd = pWinsSrvEntry->dwIPAddress;
					CString strIP;
					::MakeIPAddress(dwIPAdd, strIP);

                    char szBuffer[MAX_PATH] = {0};

					// convert to mbcs
                    // NOTE: this should be ACP because its being handed to a winsock call
                    WideToMBCS(strIP, szBuffer);
					
					// check if the server has been deleted in the scope pane
					if (IsServerDeleted(pWinsSrvEntry))
						continue;

					if (dwIPAdd == 0)
						strcpy(szBuffer, pWinsSrvEntry->szIPAddress);
					
					DWORD dwSrvIPAdd = inet_addr( szBuffer );

					if ( senderSockAddr.sin_addr.s_addr == dwSrvIPAdd ) 
					{
						// check if the server has been deleted in the scope pane
						if (IsServerDeleted(pWinsSrvEntry))
							continue;

						pWinsSrvEntry->dwMsgCount++;

                        struct in_addr addrStruct;
                        addrStruct.s_addr = dwSrvIPAdd;

						strcpy(szOutput, inet_ntoa(addrStruct));
						CString str(szOutput);
                        Trace1("ListeningThreadFunc(): WINS msg received from %s \n", str );

                        // notify the thread we got something
                        SetEvent(m_hAnswer);
                    }
					
                }
            }
            
        } /* END OF for() processing indicated sockets from select() */

    } /* END OF while( TRUE ) */

    return TRUE;
} 


/*---------------------------------------------------------------------------
  int CWinsHandler::Probe()  
      Assembles and sends a name query to the WINS server.               
  Arguments:                                                             
      none                                                               
  Return value:                                                          
      TRUE if a response has been received from the server               
      FALSE otherwise  
    Author: v-shubk
---------------------------------------------------------------------------*/
int 
CWinsStatusHandler::Probe( 
						CServerStatus	*pServer,
						SOCKET listenNameSvcSock 
					   )
{
    NM_FRAME_HDR       *pNbtHeader = (NM_FRAME_HDR *)pServer->nbtFrameBuf;
    NM_QUESTION_SECT   *pNbtQuestion = (NM_QUESTION_SECT *)( pServer->nbtFrameBuf + sizeof(NM_FRAME_HDR) );
    char               *pDest, *pName;
    struct sockaddr_in  destSockAddr;   // struct holding dest socket info
    int		            nBytesSent = 0;
//	char				m_szNameToQry[MAX_PATH] = "Rhino1";


    /* RFC 1002 section 4.2.12

                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         NAME_TRN_ID           |0|  0x0  |0|0|1|0|0 0|B|  0x0  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          0x0001               |           0x0000              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          0x0000               |           0x0000              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                         QUESTION_NAME                         /
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           NB (0x0020)         |        IN (0x0001)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   */
    
    pNbtHeader->xid            = NM_QRY_XID;
	pNbtHeader->flags          = NBT_NM_OPC_QUERY | 
                                 NBT_NM_OPC_REQUEST | 
                                 NBT_NM_FLG_RECURS_DESRD;
	pNbtHeader->question_cnt   = 0x0100;
	pNbtHeader->answer_cnt     = 0;
	pNbtHeader->name_serv_cnt  = 0;
	pNbtHeader->additional_cnt = 0;

    // pDest is filling nbtQuestion->q_name 
    pNbtQuestion->q_type       = NBT_NM_QTYP_NB;
    pNbtQuestion->q_class      = NBT_NM_QCLASS_IN;

    //
    //  translate the name
    //
    pDest = (char *)&(pNbtQuestion->q_name);
    pName = pServer->szServerName;
    // the first byte of the name is the length field = 2*16
    *pDest++ = NBT_NAME_SIZE;

    // step through name converting ascii to half ascii, for 32 times
    
	for ( int i = 0; i < (NBT_NAME_SIZE / 2) ; i++ ) {
        *pDest++ = (*pName >> 4) + 'A';
        *pDest++ = (*pName++ & 0x0F) + 'A';
    }
    *pDest++ = '\0';
    *pDest = '\0';

	// check if the server has been deleted in the scope pane
	if (IsServerDeleted(pServer))
		return FALSE;

	CString strIP;
	DWORD dwIPAdd = pServer->dwIPAddress;

	// even then 0 means, invalid server
	if (dwIPAdd == 0 && strcmp(pServer->szIPAddress, "") == 0)
		return FALSE;

	::MakeIPAddress(dwIPAdd, strIP);
    char szBuffer[MAX_PATH] = {0};

    // convert to mbcs
	// NOTE: this should be ACP because it is being used in a winsock call
    WideToMBCS(strIP, szBuffer);

	// if the name is not yet resolved
	if (dwIPAdd == 0)
	{
		strcpy(szBuffer, pServer->szIPAddress);
	}
	
	DWORD dwSrvIPAdd = inet_addr( szBuffer );

    //
    // send the name query frame
    // 
    destSockAddr.sin_family = PF_INET;
    destSockAddr.sin_port = NBT_NAME_SERVICE_PORT;
    destSockAddr.sin_addr.s_addr = dwSrvIPAdd;
    for (int k = 0; k < 8 ; k++ ) { destSockAddr.sin_zero[k] = 0; }

    struct in_addr addrStruct; 
    addrStruct.s_addr = dwSrvIPAdd;
    Trace1( "CWinsSrv::Probe(): sending probe Name Query to %s \n", strIP);
    
    nBytesSent = sendto( listenNameSvcSock,
                         (PCHAR )pServer->nbtFrameBuf, 
                         sizeof(NM_FRAME_HDR) + sizeof(NM_QUESTION_SECT),
                         0,
                         (struct sockaddr *)&destSockAddr,
                         sizeof( struct sockaddr )
                       );

    if ( nBytesSent == SOCKET_ERROR ) 
	{
        Trace1("CWinsSrv::Probe(): Error %d in sendto().\n", WSAGetLastError() );
    }

    //
    //  the other thread should see the incoming frame and increment dwMsgCount
    //
    WaitForSingleObject(m_hAnswer, ANSWER_TIMEOUT);

    if ( pServer->dwMsgCount == 0 ) 
		return FALSE; 
    
	return TRUE;
} /* END OF Probe() */


/*---------------------------------------------------------------------------
	CWinsStatusHandler::ExecuteMonitoring()
		Starts monitoring thread for the servers
    Author: v-shubk
----------------------------------------------------------------------------*/
DWORD WINAPI 
CWinsStatusHandler::ExecuteMonitoring()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HANDLE          hListeningThread;
	CServerStatus	*pWinsSrvEntry = NULL;
	
    //  create listening thread
    FD_ZERO( &m_listenSockSet );
	FD_SET( listenSockCl,      &m_listenSockSet );
    FD_SET( listenSockSrv,     &m_listenSockSet );
    FD_SET( listenNameSvcSock, &m_listenSockSet );
	
	m_hListenThread = CreateThread( NULL,					// handle can't be inherited
									 0,						// default stack size
									 MonThreadProc,			// thread function
									 this,					// argument to the thread function
									 0,						// start thread immediately
									 NULL
		                           );

	if (m_hListenThread == NULL ) 
	{
		Trace0("CWinsStatusHandler::ExecuteMonitoring() - Listening thread failed to start\n");
		return hrOK;
    }
	
    //  main checking loop
    while ( TRUE ) 
	{
		//  scanning the list of WINS servers
		POSITION pos;
		int nCount = GetListSize();
		m_nServersUpdated = 0;
      
        for (int i = 0; i < nCount; i++)
		{
			pWinsSrvEntry = GetServer(i);

			if (IsServerDeleted(pWinsSrvEntry))
				continue;

			UpdateStatus(i, IDS_ROOTNODE_STATUS_WORKING, ICON_IDX_SERVER_BUSY);
            NotifyMainThread();

            DWORD dwIPAdd = pWinsSrvEntry->dwIPAddress;

			// if the server is not connected, try to get the host IP address
			if (dwIPAdd == 0)
			{
				// get the server name and convert to MBCS. Get the IP for this server and try
				// to check the status
				char* dest_ip=NULL;
				char hostname[MAX_PATH] ;
				struct sockaddr_in dest;
				unsigned addr =0;

				if (IsServerDeleted(pWinsSrvEntry))
					continue;

				strcpy(hostname,pWinsSrvEntry->szServerName); 

				HOSTENT *hp = gethostbyname(hostname);
						
				if ((!hp)  && (addr == INADDR_NONE) ) 
				{ 
					CString str(hostname);
					Trace1("Unable to resolve %s \n",str);
					SetIPAddress(i, NULL);
				}    
				else if (!hp)
				{ 
					addr = inet_addr(hostname); 
					SetIPAddress(i, hostname);
				}   
				else
				{

					if (hp != NULL)   
						memcpy(&(dest.sin_addr),hp->h_addr, hp->h_length); 
					else   
						dest.sin_addr.s_addr = addr;    

					if (hp)   
						dest.sin_family = hp->h_addrtype;   
					else 
						dest.sin_family = AF_INET;  

					dest_ip = inet_ntoa(dest.sin_addr); 
					SetIPAddress(i, dest_ip);
				}
			}

			CString strIP;

			if (IsServerDeleted(pWinsSrvEntry))
				continue;

			::MakeIPAddress(pWinsSrvEntry->dwIPAddress, strIP);
         
            //  TRY to probe max 3 times
            if (pWinsSrvEntry->dwMsgCount == 0)
			{
				UINT uStatus = 0;
				UINT uImage;

				if (IsServerDeleted(pWinsSrvEntry))
					continue;

                BOOL fResponding = FALSE;

                if (pWinsSrvEntry->dwIPAddress != 0)
                {

                    for (int j = 0; j < 3; j++)
                    {
                        fResponding = Probe(pWinsSrvEntry, listenNameSvcSock);
                        if (fResponding)
                            break;

				        if (FCheckForAbort())
				        {
					        // we are going away.. break out man
    				        Trace0("CWinsStatusHandler::ExecuteMonitoring() - abort detected, bye bye \n");
					        break;
				        }
                    }
                }

				// check to see if we need to clear out 
				if (FCheckForAbort())
				{
					// we are going away.. break out man
    				Trace0("CWinsStatusHandler::ExecuteMonitoring() - abort detected, bye bye \n");
					break;
				}

                if (!fResponding)
				{
					Trace1("Status is DOWN for the server %s \n", strIP);
					uStatus = IDS_ROOTNODE_STATUS_DOWN;
					uImage = ICON_IDX_SERVER_LOST_CONNECTION;
				}
				else
				{
					Trace1("Status is UP for the server %s \n", strIP);
					uStatus = IDS_ROOTNODE_STATUS_UP;
					uImage = ICON_IDX_SERVER_CONNECTED;
				}

				if (IsServerDeleted(pWinsSrvEntry))
					continue;

				UpdateStatus(i, uStatus, uImage);
				m_nServersUpdated++;

                // update the last checked time
                pWinsSrvEntry->m_timeLast = CTime::GetCurrentTime();

                NotifyMainThread();
			}
            else
			{
				Trace2( "%d WINS msg from server %s - zeroing counter\n", 
                        pWinsSrvEntry->dwMsgCount, strIP);

				if (IsServerDeleted(pWinsSrvEntry))
					continue;

                pWinsSrvEntry->dwMsgCount = 0;
                
			}

            pWinsSrvEntry->dwMsgCount = 0;

		}
		
        // tell the listening thread to go to sleep
        SetEvent(m_hPauseListening);
		m_nServersUpdated = 0;
			
        // wait for the next interval or if we are triggered
   	    Trace1("CWinsStatusHandler::ExecuteMonitoring() - going to sleep for %d \n", m_dwUpdateInterval);
        WaitForSingleObject(m_hWaitIntervalMain, m_dwUpdateInterval);
   	    Trace0("CWinsStatusHandler::ExecuteMonitoring() - waking up\n");

        // wake up the listening thread
        SetEvent(m_hWaitIntervalListen);

        if (FCheckForAbort())
        {
            // we are going away.. break out man
    	    Trace0("CWinsStatusHandler::ExecuteMonitoring() - abort detected, bye bye \n");
            break;
        }
    } 

    return TRUE;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::CloseSockets
		Closes all the socket connections that were opened
	Author: v-shubk
---------------------------------------------------------------------------*/
BOOL
CWinsStatusHandler::FCheckForAbort()
{
	BOOL fAbort = FALSE;

    if (WaitForSingleObject(m_hAbortMain, 0) == WAIT_OBJECT_0)
    {
        // we are going away.. break out man
        fAbort = TRUE;
    }

	return fAbort;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::CloseSockets
		Closes all the socket connections that were opened
	Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::CloseSockets()
{
	//	final clean up
    if (closesocket(listenSockCl) == SOCKET_ERROR) 
	{
	    Trace1("closesocket(listenSockCl) failed with error %d.\n", WSAGetLastError());
    }
    
    if (closesocket(listenSockSrv) == SOCKET_ERROR) 
	{
	    Trace1("closesocket(listenSockSrv) failed with error %d.\n", WSAGetLastError());
    }

	if (closesocket(listenNameSvcSock) == SOCKET_ERROR)
	{
		Trace1("closesocket(listenNameSvcSock) failed with error %d \n", WSAGetLastError());
	}

    // we're going away...
    Trace0("CWinsStatusHandler::CloseSockets() - Setting abort event.\n");
    SetEvent(m_hAbortListen);
    SetEvent(m_hAbortMain);

    // wake everybody up
    Trace0("CWinsStatusHandler::CloseSockets() - waking up threads.\n");
    SetEvent(m_hWaitIntervalListen);
    SetEvent(m_hWaitIntervalMain);
    SetEvent(m_hAnswer);

    // terminate the threads
	if (m_hListenThread)
	{
        if (WaitForSingleObject(m_hListenThread, 5000) != WAIT_OBJECT_0)
        {
            Trace0("CWinsStatusHandler::CloseSockets() - ListenThread failed to cleanup!\n");
        }

        ::CloseHandle(m_hListenThread);
		m_hListenThread = NULL;
	}

	if (m_hMainMonThread)
	{
        if (WaitForSingleObject(m_hMainMonThread, 5000) != WAIT_OBJECT_0)
        {
            Trace0("CWinsStatusHandler::CloseSockets() - MainMonThread failed to cleanup!\n");
        }

		::CloseHandle(m_hMainMonThread);
		m_hMainMonThread = NULL;   
	}

    // clean up our events
	if (m_hPauseListening)
	{
		::CloseHandle(m_hPauseListening);
		m_hPauseListening = NULL;
	}

	if (m_hAbortListen)
	{
		::CloseHandle(m_hAbortListen);
		m_hAbortListen = NULL;
	}
	
	if (m_hAbortMain)
	{
		::CloseHandle(m_hAbortMain);
		m_hAbortMain = NULL;
	}

    if (m_hWaitIntervalListen)
	{
		::CloseHandle(m_hWaitIntervalListen);
		m_hWaitIntervalListen = NULL;
	}

    if (m_hWaitIntervalMain)
	{
		::CloseHandle(m_hWaitIntervalMain);
		m_hWaitIntervalMain = NULL;
	}

    if (m_hAnswer)
	{
		::CloseHandle(m_hAnswer);
		m_hAnswer = NULL;
	}
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::CreateNodes(ITFSNode *pNode)
		Displays the result pane nodes for the servers
    Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::CreateNodes(ITFSNode *pNode)
{
	HRESULT hr = hrOK;
	POSITION pos = NULL;

	int nCount = (int)m_listServers.GetSize();

	for(int i = 0; i < nCount; i++)
	{
		SPITFSNode spStatLeaf;

		CServerStatus *pWinsSrvEntry = m_listServers.GetAt(i);
		
		CreateLeafTFSNode(&spStatLeaf,
						  &GUID_WinsServerStatusLeafNodeType,
						  pWinsSrvEntry, 
						  pWinsSrvEntry,
						  m_spNodeMgr);

		// Tell the handler to initialize any specific data
		pWinsSrvEntry->InitializeNode((ITFSNode *) spStatLeaf);

		// Add the node as a child to the Active Leases container
		pNode->AddChild(spStatLeaf);
		
		pWinsSrvEntry->Release();
	}
	return hr;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::UpdateStatusColumn(ITFSNode *pNode)
		Updates the status column of the servers in the result pane
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::UpdateStatusColumn(ITFSNode *pNode)
{
	HRESULT hr = hrOK;

	// enumerate thro' all the nodes
	SPITFSNodeEnum spNodeEnum;
	SPITFSNode spCurrentNode;
	ULONG nNumReturned = 0;
	BOOL bFound = FALSE;

	// get the enumerator for this node
	pNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	
	while (nNumReturned)
	{
		CServerStatus * pStat = GETHANDLER(CServerStatus, spCurrentNode);

		spCurrentNode->SetData(TFS_DATA_IMAGEINDEX, pStat->m_uImage);
		spCurrentNode->SetData(TFS_DATA_OPENIMAGEINDEX, pStat->m_uImage);

		// fillup the status column
		spCurrentNode->ChangeNode(RESULT_PANE_CHANGE_ITEM);

		// get the next Server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::AddNode(ITFSNode *pNode, CWinsServerHandler *pServer)
		Adds a node to the result pane, used when a new server is added to 
		tree that has to be reflected for the status node
    Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::AddNode(ITFSNode *pNode, CWinsServerHandler *pServer)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;
	CServerStatus* pServ = NULL;
    char	szBuffer[MAX_PATH] = {0};
	SPITFSNode spStatLeaf;

    // if we haven't been expanded, don't add now.  Will get done
    // when we are expanded.
    if (!m_bExpanded)
        return hr;

	// add to the list
    // NOTE: this should be ACP because it's being used through winsock
    CString strTemp = pServer->GetServerAddress();
    WideToMBCS(strTemp, szBuffer);

	// check if the server already exists, if so, just change the 
	// state stored to SERVER_ADDED and change the variables
	// appropriately
	if ((pServ = GetExistingServer(szBuffer)) == NULL)
	{
		pServ = new CServerStatus(m_spTFSCompData);
		strcpy(pServ->szServerName, szBuffer);
		AddServer(pServ);
	}
	else
	{
		// just add the related data to the CServerStatus and add the node
		// to the UI
		strcpy(pServ->szServerName, szBuffer);
		// set the flag to SERVER_ADDED
		MarkAsDeleted(szBuffer, FALSE);
	}

	pServ->dwIPAddress = pServer->GetServerIP();
	pServ->dwMsgCount = 0;
	strcpy(pServ->szIPAddress, "");

	// create the new node here
	CreateLeafTFSNode(&spStatLeaf,
					  &GUID_WinsServerStatusLeafNodeType,
					  pServ, 
					  pServ,
					  m_spNodeMgr);

	// Tell the handler to initialize any specific data
	pServ->InitializeNode((ITFSNode *) spStatLeaf);

	// Add the node as a child to the Active Leases container
	pNode->AddChild(spStatLeaf);
	
	pServ->Release();

	spStatLeaf->ChangeNode(RESULT_PANE_CHANGE_ITEM_DATA);
	pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM);

	return hr;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::DeleteNode(ITFSNode *pNode, 
								CWinsServerHandler *pServer)
		Removes the particular server from tehresult pane
    Author: v-shubk
---------------------------------------------------------------------------*/
HRESULT 
CWinsStatusHandler::DeleteNode(ITFSNode *pNode, CWinsServerHandler *pServer)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = hrOK;
	CServerStatus* pServ = NULL;
	char	szBuffer[MAX_PATH];
	SPITFSNode spStatLeaf;

	// loop thro' the status nodes and set the flag to deleted so that this 
	// server is not seen in the result pane

	SPITFSNodeEnum			spNodeEnum;
	SPITFSNode				spCurrentNode;
	ULONG					nNumReturned = 0;

	// get the enumerator
	pNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

	while (nNumReturned)
	{
		char szBuffer[MAX_PATH];

		// iterate thro' all the nodes and get the one that matches the 
		// current server
		CServerStatus * pStat = GETHANDLER(CServerStatus, spCurrentNode);

		// convert to ANSI
        CString strTemp = pServer->GetServerAddress();
        WideToMBCS(strTemp, szBuffer);

		// if found
		if (_stricmp(szBuffer, pStat->szServerName) == 0)
		{
			// mark as deleted and break
			MarkAsDeleted(szBuffer, TRUE);
				
			// remove this node
			spCurrentNode->SetVisibilityState(TFS_VIS_HIDE);
				
			spCurrentNode->ChangeNode(RESULT_PANE_DELETE_ITEM);

			// do the cleanup and break
			//spCurrentNode.Release();

			//break;
		}

		// get the next server in the list
		spCurrentNode.Release();
		spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
	}

	return hr;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::StartMonitoring
		Spawns off the monitoring thread
	Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::StartMonitoring(ITFSNode *pNode)
{
	HRESULT hr = hrOK;

	// create the sockets, they need to be closed at the end
	hr = CreateListeningSockets();

	if (hr != hrOK)
	{
		Trace0("CWinsStatusHandler::StartMonitoring, Initializing the sockets failed\n");
		// no point continuing
		return;
	}

	m_hMainMonThread = CreateThread(NULL,
									0,
									MainMonThread,
									this,
									0,
									NULL
									);

	if (m_hMainMonThread == NULL)
	{
		Trace0("CWinsStatusHandler:: Main Monitoring thread failed to start\n");
		return;
	}

}


/*---------------------------------------------------------------------------
    CWinsStatusHandler::GetServer(int i)
		Returns the Server given the index
    Author: v-shubk
---------------------------------------------------------------------------*/
CServerStatus*
CWinsStatusHandler::GetServer(int i)
{
	CSingleLock sl(&m_cs);
	sl.Lock();

	return m_listServers.GetAt(i);
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::AddServer(CServerStatus* pServer)
		Adds a server to the array maintained
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::AddServer(CServerStatus* pServer)
{
	CSingleLock		sl(&m_cs);
	sl.Lock();

	m_listServers.Add(pServer);
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::RemoveServer(int i)
		Removes a server from the array
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::RemoveServer(int i)
{
	CSingleLock		sl(&m_cs);
	sl.Lock();

	m_listServers.RemoveAt(i);
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::UpdateStatus(UINT nID, int i)
		Upadtes the status string for the server
    Author: v-shubk
---------------------------------------------------------------------------*/
void
CWinsStatusHandler::UpdateStatus(int nIndex, UINT uStatusId, UINT uImage)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CSingleLock		sl(&m_cs);
	sl.Lock();

	CServerStatus *pStat = m_listServers.GetAt(nIndex);

	pStat->m_strStatus.LoadString(uStatusId);
	pStat->m_uImage = uImage;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::GetListSize()
		Retruns the number of elements in the array
    Author: v-shubk
---------------------------------------------------------------------------*/
int 
CWinsStatusHandler::GetListSize()
{
	CSingleLock		sl(&m_cs);
	sl.Lock();

	return (int)m_listServers.GetSize();
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::SetIPAddress(int i, LPSTR szIP)
		Sets the iP Address of the server, this is the case when the server
		is added with Do not connect option, but we still need to update the 
		status
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::SetIPAddress(int i, LPSTR szIP)
{
	CSingleLock		sl(&m_cs);
	sl.Lock();

	CServerStatus *pStat = m_listServers.GetAt(i);

	strcpy(pStat->szIPAddress, szIP);

}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::MarkAsDeleted(LPSTR szBuffer, BOOL bDelete)
		Marks the flag to DELETED if bDelete is TRUE, else to ADDED
		All the servers with the flag DELETED set are not processed
		and are not shown in the UI.
    Author: v-shubk
---------------------------------------------------------------------------*/
void 
CWinsStatusHandler::MarkAsDeleted(LPSTR szBuffer, BOOL bDelete)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CSingleLock		sl(&m_cs);
	sl.Lock();

	int				nCount = 0;
	CServerStatus	*pStat = NULL;

	// get the list of the servers maintained
	nCount = (int)m_listServers.GetSize();

	for(int i = 0; i < nCount; i++)
	{
		pStat = m_listServers.GetAt(i);

		if (_stricmp(szBuffer, pStat->szServerName) == 0)
		{
			// set the deleted flag
			if (bDelete)
				pStat->dwState = SERVER_DELETED;
			else
				pStat->dwState = SERVER_ADDED;
			break;
		}
	}

	return;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::GetExistingServer(LPSTR szBuffer)	
		Gets the pointer to the existing server in the array
		This function is useful when the server is deletd and again added back 
		to the scope tree.
    Author: v-shubk
----------------------------------------------------------------------------*/
CServerStatus *
CWinsStatusHandler::GetExistingServer(LPSTR szBuffer)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	CSingleLock		sl(&m_cs);
	sl.Lock();

	int					nCount = 0;
	CServerStatus		*pStat = NULL;

	for(int i = 0; i < nCount; i++)
	{
		pStat = m_listServers.GetAt(i);

		if (_strcmpi(pStat->szServerName, szBuffer) == 0)
			return pStat;
	}

	return NULL;
}


/*---------------------------------------------------------------------------
	CWinsStatusHandler::IsServerDeleted(CServerStatus *pStat)
		Checks if a server has been deleted, such servers
		sre not considered for monitoring
    Author: v-shubk
---------------------------------------------------------------------------*/
BOOL 
CWinsStatusHandler::IsServerDeleted(CServerStatus *pStat)
{
	return (pStat->dwState == SERVER_DELETED) ? TRUE : FALSE;
}

/*---------------------------------------------------------------------------
	CWinsStatusHandler::NotifyMainThread()
        Description
    Author: EricDav
---------------------------------------------------------------------------*/
void
CWinsStatusHandler::NotifyMainThread()
{
    if (!m_uMsgBase)
    {
	    m_uMsgBase = (INT) ::SendMessage(m_spTFSCompData->GetHiddenWnd(), WM_HIDDENWND_REGISTER, TRUE, 0);
    }

    ::PostMessage(m_spTFSCompData->GetHiddenWnd(), 
                  m_uMsgBase + WM_HIDDENWND_INDEX_HAVEDATA,
				 (WPARAM)(ITFSThreadHandler *)this, 
                 NULL);
}


// listening thread for the main monitoring thread
DWORD WINAPI 
MonThreadProc(LPVOID pParam)
{
    DWORD dwReturn;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        CWinsStatusHandler * pWinsStatus = (CWinsStatusHandler *) pParam;
	    
        Trace0("MonThreadProc - Thread started.\n");

        dwReturn = pWinsStatus->ListeningThreadFunc();

        Trace0("MonThreadProc - Thread ending.\n");
    }
    COM_PROTECT_CATCH

    return dwReturn;
}


// main monitoring thread
DWORD WINAPI MainMonThread(LPVOID pParam)
{
    DWORD dwReturn;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
        CWinsStatusHandler * pWinsStatus = (CWinsStatusHandler *) pParam;
	    
        Trace0("MainMonThread - Thread started.\n");

        dwReturn = pWinsStatus->ExecuteMonitoring();

        Trace0("MainMonThread - Thread ending.\n");
    }
    COM_PROTECT_CATCH

    return dwReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\verify.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	verify.h	
		WINS defines from ntdef.h 
		
    FILE HISTORY:
        
*/

#ifndef _VERIFY_H
#define _VERIFY_H

#ifdef __cplusplus
extern "C"
{
#endif
	
typedef struct
{
    BOOLEAN         fQueried;
    struct in_addr  Server;
    struct in_addr  RetAddr;
    int             Valid;
    int             Failed;
    int             Retries;
    int             LastResponse;
    int             Completed;
} WINSERVERS;

#define MAX_SERVERS		1000

#define NBT_NONCODED_NMSZ   17
#define NBT_NAMESIZE        34

#define WINSTEST_FOUND            0
#define WINSTEST_NOT_FOUND        1
#define WINSTEST_NO_RESPONSE      2

#define WINSTEST_VERIFIED         0
#define WINSTEST_OUT_OF_MEMORY    3
#define WINSTEST_BAD_IP_ADDRESS   4
#define WINSTEST_HOST_NOT_FOUND   5
#define WINSTEST_NOT_VERIFIED     6
#define WINSTEST_INVALID_ARG      7
#define WINSTEST_OPEN_FAILED      8

#define BUFF_SIZE                 1024

typedef struct _NameResponse
{
    u_short TransactionID;
    u_short Flags;
    u_short QuestionCount;
    u_short AnswerCount;
    u_short NSCount;
    u_short AdditionalRec;
    u_char  AnswerName[NBT_NAMESIZE];
    u_short AnswerType;
    u_short AnswerClass;
    u_short AnswerTTL1;
    u_short AnswerTTL2;
    u_short AnswerLength;
    u_short AnswerFlags;
    u_short AnswerAddr1;
    u_short AnswerAddr2;
} NameResponse;

#define NAME_RESPONSE_BUFFER_SIZE sizeof(NameResponse) * 10

extern int VerifyRemote(IN PCHAR RemoteName, IN PCHAR NBName);
extern INT _stdcall CheckNameConsistency(char * szName);
extern INT _stdcall InitNameConsistency(HINSTANCE hInstance, HWND hWnd);
extern INT _stdcall AddWinsServer(char * szServer, BOOL fVerifyWithPartners);
extern INT _stdcall InitNameCheckSocket();
extern INT _stdcall CloseNameCheckSocket();
extern void _stdcall SendNameQuery(unsigned char *name, u_long winsaddr, u_short TransID);
extern int _stdcall GetNameResponse(u_long *recvaddr, u_short TransactionID);

extern void CreateConsistencyStatusWindow(HINSTANCE hInstance, HWND hWndParent);
extern void DestroyConsistencyStatusWindow();
extern void ClearConsistencyStatusWindow();
extern void EnableConsistencyCloseButton(BOOL bEnable);
extern void AddStatusMessageW(LPCWSTR pszMessage);
extern HWND GetConsistencyStatusWnd();

#ifdef __cplusplus
}
#endif

#endif _VERIFY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

	FILE HISTORY:
        
*/

// so that the winscnst.h file compiles
#define FUTURES(x)
#define MCAST       1

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <afxcview.h>
#include <afxext.h>
#include <afxmt.h>
#include <shfusion.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//#pragma comment(lib, "mmc")
#include <mmc.h>


extern "C"
{
	#include "winsock.h"     // WinSock definitions
	#include "lmerr.h"       // Network error codes 
}

// WINS Service file
#define WINS_CLIENT_APIS

extern "C" 
{
    #include "winsintf.h"   // WINS RPC interfaces
    #include "rnraddrs.h"   // needed by winscnst.h
    #include "winscnst.h"   // WINS constants and default values
    #include "ipaddr.h"     // ip address stuff
}


#include "resource.h"

// Global defines for WINS snapin
#include "winssnap.h"

// macros for memory exception handling
#define CATCH_MEM_EXCEPTION             \
	TRY

#define END_MEM_EXCEPTION(err)          \
	CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

// Files from ..\tfscore
#include <dbgutil.h>
#include <std.h>
#include <errutil.h>
#include <register.h>
#include <htmlhelp.h>

// Files from ..\common
#include <ccdata.h>
#include <about.h>
#include <dataobj.h>
#include <proppage.h>
#include <ipaddr.hpp>
#include <objplus.h>
#include <intltime.h>
#include <intlnum.h>

// project specific
#include "winscomp.h"
#include "WinsSup.h"
#include "helparr.h"
#include "ipnamepr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\vrfysrv.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 -99             **/
/**********************************************************************/

/*
    vrfysrv.cpp
        Comment goes here

    FILE HISTORY:

*/

#include "stdafx.h"
#include "winssnap.h"
#include "VrfySrv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVerifyWins dialog


CVerifyWins::CVerifyWins(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CVerifyWins::IDD, pParent), m_fCancelPressed(FALSE)
{
	//{{AFX_DATA_INIT(CVerifyWins)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

//	Create(CVerifyWins::IDD, pParent);
}


void CVerifyWins::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVerifyWins)
	DDX_Control(pDX, IDCANCEL, m_buttonCancel);
	DDX_Control(pDX, IDC_STATIC_SERVERNAME, m_staticServerName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVerifyWins, CBaseDialog)
	//{{AFX_MSG_MAP(CVerifyWins)
	ON_WM_SETCURSOR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVerifyWins message handlers

void CVerifyWins::OnCancel() 
{
	// TODO: Add extra cleanup here
	m_fCancelPressed = TRUE;
	//CBaseDialog::OnCancel();
}

//
// Dismiss the dialog
//
void 
CVerifyWins::Dismiss()
{
    DestroyWindow();
}

void 
CVerifyWins::PostNcDestroy()
{
//    delete this;
}

void 
CVerifyWins::SetServerName(CString strName)
{
	m_staticServerName.SetWindowText(strName);
}

BOOL CVerifyWins::OnInitDialog() 
{
	CBaseDialog::OnInitDialog();
	
	//m_buttonCancel.ShowWindow(FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CVerifyWins::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	// TODO: Add your message handler code here and/or call default
	SetCursor(LoadCursor(NULL, IDC_ARROW));
	
	return CBaseDialog::OnSetCursor(pWnd, nHitTest, message);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\vrfysrv.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	vrfysrv.h
		verify wins dialog
		
    FILE HISTORY:
        
*/

#if !defined(AFX_VERIFYSRV_H__6DB886C1_8E0F_11D1_BA0B_00C04FBF914A__INCLUDED_)
#define AFX_VERIFYSRV_H__6DB886C1_8E0F_11D1_BA0B_00C04FBF914A__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CVerifyWins dialog

#ifndef _DIALOG_H
#include "dialog.h"
#endif

class CVerifyWins : public CBaseDialog
{
// Construction
public:
	CVerifyWins(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CVerifyWins)
	enum { IDD = IDD_VERIFY_WINS };
	CButton	m_buttonCancel;
	CStatic	m_staticServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVerifyWins)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CVerifyWins)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	BOOL m_fCancelPressed;

public:
	BOOL IsCancelPressed()
	{
		return m_fCancelPressed;
	}

	void Dismiss();

	virtual void PostNcDestroy();

	void SetServerName(CString strName);

public:
	virtual DWORD * GetHelpMap() { return WinsGetHelpMap(CVerifyWins::IDD);};

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VERIFYSRV_H__6DB886C1_8E0F_11D1_BA0B_00C04FBF914A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winscomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winscomp.cpp
		This file contains the derived implementations from CComponent
		and CComponentData for the WINS admin snapin.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "winscomp.h"
#include "root.h"
#include "server.h"
#include "vrfysrv.h"
#include "status.h"

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define HI HIDDEN
#define EN ENABLED

LARGE_INTEGER gliWinssnapVersion;

UINT aColumns[WINSSNAP_NODETYPE_MAX][MAX_COLUMNS] =
{
	{IDS_ROOT_NAME,             IDS_STATUS,              0,                       0,                    0,                   0,                0,                     0,0}, // WINSSNAP_ROOT
	{IDS_WINSSERVER_NAME,       IDS_DESCRIPTION,         0,                       0,                    0,                   0,                0,                     0,0}, // WINSSNAP_SERVER
	{IDS_ACTIVEREG_RECORD_NAME, IDS_ACTIVEREG_TYPE,      IDS_ACTIVEREG_IPADDRESS, IDS_ACTIVEREG_ACTIVE, IDS_ACTIVEREG_STATIC,IDS_ACTREG_OWNER, IDS_ACTIVEREG_VERSION, IDS_ACTIVEREG_EXPIRATION,0}, // WINSSNAP_ACTIVE_REGISTRATIONS
	{IDS_REPLICATION_SERVERNAME,IDS_ACTIVEREG_IPADDRESS, IDS_ACTIVEREG_TYPE,      0,                    0,                   0,                0,					  0,0}, // WINSSNAP_REPLICATION_PARTNERS
	{IDS_ROOT_NODENAME,         IDS_ROOT_NODE_STATUS,    IDS_LAST_UPDATE,         0,                    0,                   0,                0,                     0,0}, // STATUS
	{0,0,0,0,0,0,0,0,0}
};

//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//
// StatusRemove
int aColumnWidths[WINSSNAP_NODETYPE_MAX][MAX_COLUMNS] =
{	
	{250,       150,       50,        AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_ROOT
	{250,       250,       AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_SERVER
	{150,       120,       100,       75,        50,        100,       100,       150,       AUTO_WIDTH}, // WINSSNAP_ACTIVE_REGISTRATIONS
	{100,       100,       100,       150,       AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_REPLICATION_PARTNERS
	{250,       100,       200,       AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_SERVER_STATUS
	{AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // WINSSNAP_SERVER_STATUS

};

// icon defines
UINT g_uIconMap[ICON_IDX_MAX + 1][2] = 
{
    {IDI_ICON01,	    ICON_IDX_ACTREG_FOLDER_CLOSED},
    {IDI_ICON02,		ICON_IDX_ACTREG_FOLDER_CLOSED_BUSY},
    {IDI_ICON03,		ICON_IDX_ACTREG_FOLDER_OPEN},
    {IDI_ICON04,		ICON_IDX_ACTREG_FOLDER_OPEN_BUSY},
    {IDI_ICON05,		ICON_IDX_CLIENT},
    {IDI_ICON06,		ICON_IDX_CLIENT_GROUP},
    {IDI_ICON07,		ICON_IDX_PARTNER},
    {IDI_ICON08,		ICON_IDX_REP_PARTNERS_FOLDER_CLOSED},
    {IDI_ICON09,		ICON_IDX_REP_PARTNERS_FOLDER_CLOSED_BUSY},
    {IDI_ICON10,		ICON_IDX_REP_PARTNERS_FOLDER_CLOSED_LOST_CONNECTION},
    {IDI_ICON11,		ICON_IDX_REP_PARTNERS_FOLDER_OPEN},
    {IDI_ICON12,		ICON_IDX_REP_PARTNERS_FOLDER_OPEN_BUSY},
    {IDI_ICON13,		ICON_IDX_REP_PARTNERS_FOLDER_OPEN_LOST_CONNECTION},
    {IDI_ICON14,		ICON_IDX_SERVER},
    {IDI_ICON15,		ICON_IDX_SERVER_BUSY},
    {IDI_ICON16,		ICON_IDX_SERVER_CONNECTED},
    {IDI_ICON17,		ICON_IDX_SERVER_LOST_CONNECTION},
    {IDI_ICON18,        ICON_IDX_SERVER_NO_ACCESS},
	{IDI_WINS_SNAPIN,	ICON_IDX_WINS_PRODUCT}, 
    {0, 0}
};

// help mapper for dialogs and property pages
struct ContextHelpMap
{
    UINT            uID;
    const DWORD *   pdwMap;
};

ContextHelpMap g_uContextHelp[WINSSNAP_NUM_HELP_MAPS] =
{
    {IDD_ACTREG_FIND_RECORD,				g_aHelpIDs_IDD_ACTREG_FIND_RECORD},
    {IDD_CHECK_REG_NAMES,                   g_aHelpIDs_IDD_CHECK_REG_NAMES},
    {IDD_DELTOMB_RECORD,                    g_aHelpIDs_IDD_DELTOMB_RECORD},
    {IDD_DYN_PROPERTIES,					g_aHelpIDs_IDD_DYN_PROPERTIES},
    {IDD_FILTER_SELECT,				        g_aHelpIDs_IDD_FILTER_SELECT},
    {IDD_GETIPADDRESS,                      g_aHelpIDs_IDD_GETIPADDRESS},
    {IDD_GETNETBIOSNAME,                    g_aHelpIDs_IDD_GETNETBIOSNAME},
    {IDD_IPADDRESS,                         g_aHelpIDs_IDD_IPADDRESS},
    {IDD_NAME_TYPE,                         g_aHelpIDs_IDD_NAME_TYPE},
    {IDD_OWNER_DELETE,						g_aHelpIDs_IDD_OWNER_DELETE},
    {IDD_OWNER_FILTER,						g_aHelpIDs_IDD_OWNER_FILTER},
    {IDD_FILTER_IPADDR,                     g_aHelpIDs_IDD_FILTER_IPADDR},
    {IDD_PULL_TRIGGER,						NULL},
    {IDD_REP_NODE_ADVANCED,					g_aHelpIDs_IDD_REP_NODE_ADVANCED},
    {IDD_REP_NODE_PUSH,                     g_aHelpIDs_IDD_REP_NODE_PUSH},
    {IDD_REP_NODE_PULL,                     g_aHelpIDs_IDD_REP_NODE_PULL},
    {IDD_REP_NODE_GENERAL,                  g_aHelpIDs_IDD_REP_NODE_GENERAL},
    {IDD_REP_PROP_ADVANCED,					g_aHelpIDs_IDD_REP_PROP_ADVANCED},
    {IDD_REP_PROP_GENERAL,					g_aHelpIDs_IDD_REP_PROP_GENERAL},
    {IDD_SEND_PUSH_TRIGGER,					g_aHelpIDs_IDD_SEND_PUSH_TRIGGER},
    {IDD_SERVER_PROP_ADVANCED,				g_aHelpIDs_IDD_SERVER_PROP_ADVANCED},
    {IDD_SERVER_PROP_DBRECORD,				g_aHelpIDs_IDD_SERVER_PROP_DBRECORD},
    {IDD_SERVER_PROP_DBVERIFICATION,		g_aHelpIDs_IDD_SERVER_PROP_DBVERIFICATION},
    {IDD_SERVER_PROP_GEN,					g_aHelpIDs_IDD_SERVER_PROP_GEN},
    {IDD_SNAPIN_PP_GENERAL,					g_aHelpIDs_IDD_SNAPIN_PP_GENERAL},
    {IDD_STATIC_MAPPING_PROPERTIES,         g_aHelpIDs_IDD_STATIC_MAPPING_PROPERTIES},
    {IDD_STATIC_MAPPING_WIZARD,             g_aHelpIDs_IDD_STATIC_MAPPING_WIZARD},
	{IDD_STATS_NARROW,						NULL},
    {IDD_STATUS_NODE_PROPERTIES,            g_aHelpIDs_IDD_STATUS_NODE_PROPERTIES},
    {IDD_VERIFY_WINS,		                NULL},
    {IDD_VERSION_CONSIS,                    g_aHelpIDs_IDD_VERSION_CONSIS},
};

CWinsContextHelpMap     g_winsContextHelpMap;

DWORD * WinsGetHelpMap(UINT uID) 
{
    DWORD * pdwMap = NULL;
    g_winsContextHelpMap.Lookup(uID, pdwMap);
    return pdwMap;
}



CString aMenuButtonText[3][2];

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

/////////////////////////////////////////////////////////////////////////////
// CWinsComponent implementation

/*---------------------------------------------------------------------------
	Class CWinsComponent implementation
 ---------------------------------------------------------------------------*/
CWinsComponent::CWinsComponent()
{
}

CWinsComponent::~CWinsComponent()
{
}

STDMETHODIMP CWinsComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_spImageList != NULL);
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1]);
        }
    }

	return S_OK;
}

/*!--------------------------------------------------------------------------
	CWinsComponent::QueryDataObject
		Implementation of IComponent::QueryDataObject.  We need this for
        virtual listbox support.  MMC calls us back normally with the cookie
        we handed it...  In the case of the VLB, it hands us the index of 
        the item.  So, we need to do some extra checking...
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponent::QueryDataObject
(
	MMC_COOKIE              cookie, 
	DATA_OBJECT_TYPES       type,
    LPDATAOBJECT*           ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    SPITFSNode          spSelectedNode;
    SPITFSNode          spRootNode;
    SPITFSResultHandler spResultHandler;
    long                lViewOptions = 0;
    LPOLESTR            pViewType = NULL;
    CDataObject *       pDataObject;

    COM_PROTECT_TRY
    {
        // check to see what kind of result view type the selected node has
        CORg (GetSelectedNode(&spSelectedNode));
        CORg (spSelectedNode->GetResultHandler(&spResultHandler));
   
    	CORg (spResultHandler->OnGetResultViewType(this, spSelectedNode->GetData(TFS_DATA_COOKIE), &pViewType, &lViewOptions));

        if ( (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ||
             (cookie == MMC_MULTI_SELECT_COOKIE) )
        {
            if (cookie == MMC_MULTI_SELECT_COOKIE)
            {
                // this is a special case for multiple select.  We need to build a list
                // of GUIDs and the code to do this is in the handler...
                spResultHandler->OnCreateDataObject(this, cookie, type, ppDataObject);
            }
            else
            {
                // this node has a virtual listbox for the result pane.  Gerenate
                // a special data object using the selected node as the cookie
                Assert(m_spComponentData != NULL);
                CORg (m_spComponentData->QueryDataObject(reinterpret_cast<LONG_PTR>((ITFSNode *) spSelectedNode), type, ppDataObject));
            }

            pDataObject = reinterpret_cast<CDataObject *>(*ppDataObject);
            pDataObject->SetVirtualIndex((int) cookie);
        }
        else
        if (cookie == MMC_WINDOW_COOKIE)
        {
            // this cookie needs the text for the static root node, so build the DO with
            // the root node cookie
            m_spNodeMgr->GetRootNode(&spRootNode);
            CORg (m_spComponentData->QueryDataObject((MMC_COOKIE) spRootNode->GetData(TFS_DATA_COOKIE), type, ppDataObject));
        }
        else
        {
            // just forward this to the component data
            Assert(m_spComponentData != NULL);
            CORg (m_spComponentData->QueryDataObject(cookie, type, ppDataObject));
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsComponent::OnSnapinHelp
		-
	Author: v-shubk
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponent::OnSnapinHelp
(
	LPDATAOBJECT	pDataObject,
	LPARAM			arg, 
	LPARAM			param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = hrOK;

	HtmlHelpA(NULL, "WinsSnap.chm", HH_DISPLAY_TOPIC, 0);

	return hr;
}


/*!--------------------------------------------------------------------------
	CWinsComponent::CompareObjects
		Implementation of IComponent::CompareObjects
		MMC calls this to compare two objects
        We override this for the virtual listbox case.  With a virtual listbox,
        the cookies are the same, but the index in the internal structs 
        indicate which item the dataobject refers to.  So, we need to look
        at the indicies instead of just the cookies.
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponent::CompareObjects
(
	LPDATAOBJECT lpDataObjectA, 
	LPDATAOBJECT lpDataObjectB
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
		return E_POINTER;

    // Make sure both data object are mine
    SPINTERNAL spA;
    SPINTERNAL spB;
    HRESULT hr = S_FALSE;

	COM_PROTECT_TRY
	{
		spA = ExtractInternalFormat(lpDataObjectA);
		spB = ExtractInternalFormat(lpDataObjectB);

		if (spA != NULL && spB != NULL)
        {
            if (spA->HasVirtualIndex() && spB->HasVirtualIndex())
            {
                hr = (spA->GetVirtualIndex() == spB->GetVirtualIndex()) ? S_OK : S_FALSE;
            }
            else
            {
                hr = (spA->m_cookie == spB->m_cookie) ? S_OK : S_FALSE;
            }
        }
	}
	COM_PROTECT_CATCH

    return hr;
}



/*---------------------------------------------------------------------------
	Class CWinsComponentData implementation
 ---------------------------------------------------------------------------*/

CWinsComponentData::CWinsComponentData()
{
	// initialize our global help map
    for (int i = 0; i < WINSSNAP_NUM_HELP_MAPS; i++)
    {
        g_winsContextHelpMap.SetAt(g_uContextHelp[i].uID, (LPDWORD) g_uContextHelp[i].pdwMap);
    }
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::OnInitialize
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CWinsComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

	return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::OnDestroy
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CWinsComponentData::OnDestroy()
{
	m_spNodeMgr.Release();
	return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::OnInitializeNodeMgr
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponentData::OnInitializeNodeMgr
(
	ITFSComponentData *	pTFSCompData, 
	ITFSNodeMgr *		pNodeMgr
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	// For now create a new node handler for each new node,
	// this is rather bogus as it can get expensive.  We can
	// consider creating only a single node handler for each
	// node type.
	CWinsRootHandler *	pHandler = NULL;
	SPITFSNodeHandler	spHandler;
	SPITFSNode			spNode;
	HRESULT				hr = hrOK;

	try
	{
		pHandler = new CWinsRootHandler(pTFSCompData);

		// Do this so that it will get released correctly
		spHandler = pHandler;
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}
	CORg( hr );
	
	// Create the root node for this sick puppy
	CORg( CreateContainerTFSNode(&spNode,
								 &GUID_WinsGenericNodeType,
								 pHandler,
								 pHandler,		 /* result handler */
								 pNodeMgr) );

	// Need to initialize the data for the root node
	pHandler->InitializeNode(spNode);
	
	CORg( pNodeMgr->SetRootNode(spNode) );
	m_spRootNode.Set(spNode);
	
    pTFSCompData->SetHTMLHelpFileName(_T("winssnap.chm"));

Error:	
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::OnCreateComponent
		-
	Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponentData::OnCreateComponent
(
	LPCOMPONENT *ppComponent
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppComponent != NULL);
	
	HRESULT			  hr = hrOK;
	CWinsComponent *  pComp = NULL;

	try
	{
		pComp = new CWinsComponent;
	}
	catch(...)
	{
		hr = E_OUTOFMEMORY;
	}

	if (FHrSucceeded(hr))
	{
		pComp->Construct(m_spNodeMgr,
						static_cast<IComponentData *>(this),
						m_spTFSComponentData);
		*ppComponent = static_cast<IComponent *>(pComp);
	}
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsComponentData::GetCoClassID
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) 
CWinsComponentData::GetCoClassID()
{
	return &CLSID_WinsSnapin;
}

/*!--------------------------------------------------------------------------
	CSfmComponentData::OnCreateDataObject
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsComponentData::OnCreateDataObject
(
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	
	pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}


///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP 
CWinsComponentData::GetClassID
(
	CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_WinsSnapin;

    return hrOK;
}

STDMETHODIMP 
CWinsComponentData::IsDirty()
{
	return m_spRootNode->GetData(TFS_DATA_DIRTY) ? hrOK : hrFalse;
}

STDMETHODIMP 
CWinsComponentData::Load
(
	IStream *pStm
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

	LARGE_INTEGER   liSavedVersion;
	CString         str;
    
	ASSERT(pStm);

    CDWordArray			dwArrayIp;
	CDWordArray			dwArrayFlags;
	CDWordArray			dwArrayRefreshInterval;
	CDWordArray			dwArrayColumnInfo;
	DWORD				dwUpdateInterval;
    DWORD               dwSnapinFlags;
    CStringArray		strArrayName;
	ULONG				nNumReturned = 0;
    DWORD				dwFileVersion;
	CWinsRootHandler *	pRootHandler;
    SPITFSNodeEnum		spNodeEnum;
    SPITFSNode			spCurrentNode;
	HCURSOR				hOldCursor;
	HCURSOR				hNewCursor;
	int					i;

    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_READ);    
    
    // read the version of the file format
    CORg(xferStream.XferDWORD(WINSSTRM_TAG_VERSION, &dwFileVersion));

    // Read the version # of the admin tool
    CORg(xferStream.XferLARGEINTEGER(WINSSTRM_TAG_VERSIONADMIN, &liSavedVersion));
	if (liSavedVersion.QuadPart < gliWinssnapVersion.QuadPart)
	{
		// File is an older version.  Warn the user and then don't
		// load anything else
		Assert(FALSE);
	}

	// Read the root node name
    CORg(xferStream.XferCString(WINSSTRM_TAB_SNAPIN_NAME, &str));
	Assert(m_spRootNode);
	pRootHandler = GETHANDLER(CWinsRootHandler, m_spRootNode);
	pRootHandler->SetDisplayName(str);

	// read the root node info
	CORg(xferStream.XferDWORD(WINSSTRM_TAG_SNAPIN_FLAGS, &dwSnapinFlags));
	pRootHandler->m_dwFlags = dwSnapinFlags;

    pRootHandler->m_fValidate = (dwSnapinFlags & FLAG_VALIDATE_CACHE) ? TRUE : FALSE;
    
	// read from the stream
	CORg(xferStream.XferDWORD(WINSSTRM_TAG_UPDATE_INTERVAL, &dwUpdateInterval));

	pRootHandler->SetUpdateInterval(dwUpdateInterval);
    
    // now read all of the server information
    CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_IP, &dwArrayIp));
	CORg(xferStream.XferCStringArray(WINSSTRM_TAG_SERVER_NAME, &strArrayName));
	CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_FLAGS, &dwArrayFlags));
	CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_REFRESHINTERVAL, &dwArrayRefreshInterval));
	
	hOldCursor = NULL;

	hNewCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW));
	if (hNewCursor)
		hOldCursor = SetCursor(hNewCursor);

	// now create the servers based on the information
    for (i = 0; i < dwArrayIp.GetSize(); i++)
	{
		//
		// now create the server object
		//
		pRootHandler->AddServer((LPCWSTR) strArrayName[i], 
                                FALSE, 
								dwArrayIp[i],
								FALSE, 
								dwArrayFlags[i],
								dwArrayRefreshInterval[i]
								);
	}

	pRootHandler->DismissVerifyDialog();

	// load the column information
	for (i = 0; i < NUM_SCOPE_ITEMS; i++)
	{
		CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

		for (int j = 0; j < MAX_COLUMNS; j++)
		{
			aColumnWidths[i][j] = dwArrayColumnInfo[j];
		}

	}

	if (hOldCursor)
		SetCursor(hOldCursor);

Error:
	return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP 
CWinsComponentData::Save
(
	IStream *pStm, 
	BOOL	 fClearDirty
)
{
	HRESULT hr = hrOK;

    CDWordArray			dwArrayIp;
    CStringArray		strArrayName;
	CDWordArray			dwArrayFlags;
	CDWordArray			dwArrayRefreshInterval;
	CDWordArray			dwArrayColumnInfo;
	DWORD				dwUpdateInterval;
    DWORD               dwSnapinFlags;
    DWORD				dwFileVersion = WINSSNAP_FILE_VERSION;
	CString				str;
	CWinsRootHandler *	pRootHandler;
    int					nNumServers = 0, nVisibleCount = 0;
	SPITFSNodeEnum		spNodeEnum;
    SPITFSNode			spCurrentNode;
    ULONG				nNumReturned = 0;
    int					nCount = 0;
	const GUID *		pGuid;
	CWinsServerHandler *pServer;
	int					i;

	ASSERT(pStm);

	// set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_WRITE);    

	// Write the version # of the file format
    CORg(xferStream.XferDWORD(WINSSTRM_TAG_VERSION, &dwFileVersion));

	// Write the version # of the admin tool
    CORg(xferStream.XferLARGEINTEGER(WINSSTRM_TAG_VERSIONADMIN, &gliWinssnapVersion));

	// write the root node name
    Assert(m_spRootNode);
	pRootHandler = GETHANDLER(CWinsRootHandler, m_spRootNode);
	str = pRootHandler->GetDisplayName();

	CORg(xferStream.XferCString(WINSSTRM_TAB_SNAPIN_NAME, &str));

	//
	// Build our array of servers
	//
	hr = m_spRootNode->GetChildCount(&nVisibleCount, &nNumServers);

	dwArrayColumnInfo.SetSize(MAX_COLUMNS);

	// save the root node info
	dwSnapinFlags = pRootHandler->m_dwFlags;

    CORg(xferStream.XferDWORD(WINSSTRM_TAG_SNAPIN_FLAGS, &dwSnapinFlags));
	
	dwUpdateInterval = pRootHandler->GetUpdateInterval();
	CORg(xferStream.XferDWORD(WINSSTRM_TAG_UPDATE_INTERVAL, &dwUpdateInterval));
	
	//
	// loop and save off all the server's attributes
	//
    m_spRootNode->GetEnum(&spNodeEnum);

	spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
	{
		pGuid = spCurrentNode->GetNodeType();

		if (*pGuid == GUID_WinsServerStatusNodeType)
		{
			// go to the next node
			spCurrentNode.Release();
			spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
			//nCount++;
		
            continue;
		}

		pServer = GETHANDLER(CWinsServerHandler, spCurrentNode);

        // put the information in our array
		strArrayName.Add(pServer->GetServerAddress());
		dwArrayIp.Add(pServer->GetServerIP());
		dwArrayFlags.Add(pServer->m_dwFlags);
		dwArrayRefreshInterval.Add(pServer->m_dwRefreshInterval);

        // go to the next node
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        nCount++;
	}

	// now write out all of the server information
    CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_IP, &dwArrayIp));
    CORg(xferStream.XferCStringArray(WINSSTRM_TAG_SERVER_NAME, &strArrayName));
	CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_FLAGS, &dwArrayFlags));
	CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_SERVER_REFRESHINTERVAL, &dwArrayRefreshInterval));
		
	// save the column information
	for (i = 0; i < NUM_SCOPE_ITEMS; i++)
	{
		for (int j = 0; j < MAX_COLUMNS; j++)
		{
			dwArrayColumnInfo[j] = aColumnWidths[i][j];
		}

		CORg(xferStream.XferDWORDArray(WINSSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));
	}
    
	if (fClearDirty)
	{
		m_spRootNode->SetData(TFS_DATA_DIRTY, FALSE);
	}

Error:
    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP 
CWinsComponentData::GetSizeMax
(
	ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10000);

    return S_OK;
}

STDMETHODIMP 
CWinsComponentData::InitNew()
{
	return hrOK;
}

HRESULT 
CWinsComponentData::FinalConstruct()
{
	HRESULT				hr = hrOK;
	
	hr = CComponentData::FinalConstruct();
	
	if (FHrSucceeded(hr))
	{
		m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
	}
	return hr;
}

void 
CWinsComponentData::FinalRelease()
{
	CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winscomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	winscomp.h
		This file contains the derived prototypes from CComponent
		and CComponentData for the WINS admin snapin.

    FILE HISTORY:
        
*/

#ifndef _WINSCOMP_H
#define _WINSCOMP_H

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H
#include "compont.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#define COLORREF_PINK	0x00FF00FF
#define WINSSNAP_FILE_VERSION    0x00000001
#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

#define STRING_LENGTH_MAX		 256

enum WINSSTRM_TAG
{
	WINSSTRM_TAG_VERSION					=	XFER_TAG(1, XFER_DWORD),
	WINSSTRM_TAG_VERSIONADMIN				=	XFER_TAG(2, XFER_LARGEINTEGER),
    WINSSTRM_TAB_SNAPIN_NAME				=   XFER_TAG(3, XFER_STRING),
    WINSSTRM_TAG_SERVER_IP					=	XFER_TAG(4, XFER_DWORD_ARRAY),
	WINSSTRM_TAG_SERVER_NAME				=	XFER_TAG(5, XFER_STRING_ARRAY),
	WINSSTRM_TAG_SERVER_CONNECTED			=	XFER_TAG(6, XFER_STRING_ARRAY),
	WINSSTRM_TAG_SERVER_FLAGS				=	XFER_TAG(10, XFER_DWORD_ARRAY),
	WINSSTRM_TAG_SERVER_REFRESHINTERVAL		=	XFER_TAG(11, XFER_DWORD_ARRAY),
	WINSSTRM_TAG_COLUMN_INFO				=	XFER_TAG(12, XFER_DWORD_ARRAY),
	WINSSTRM_TAG_SNAPIN_FLAGS	            =	XFER_TAG(13, XFER_DWORD),
	WINSSTRM_TAG_UPDATE_INTERVAL			=	XFER_TAG(14, XFER_DWORD)
};

typedef enum _ICON_INDICIES
{
	ICON_IDX_ACTREG_FOLDER_CLOSED,
	ICON_IDX_ACTREG_FOLDER_CLOSED_BUSY,
	ICON_IDX_ACTREG_FOLDER_OPEN,
	ICON_IDX_ACTREG_FOLDER_OPEN_BUSY,
	ICON_IDX_CLIENT,
	ICON_IDX_CLIENT_GROUP,
	ICON_IDX_PARTNER,
	ICON_IDX_REP_PARTNERS_FOLDER_CLOSED,
	ICON_IDX_REP_PARTNERS_FOLDER_CLOSED_BUSY,
	ICON_IDX_REP_PARTNERS_FOLDER_CLOSED_LOST_CONNECTION,
	ICON_IDX_REP_PARTNERS_FOLDER_OPEN,
	ICON_IDX_REP_PARTNERS_FOLDER_OPEN_BUSY,
	ICON_IDX_REP_PARTNERS_FOLDER_OPEN_LOST_CONNECTION,
	ICON_IDX_SERVER,
	ICON_IDX_SERVER_BUSY,
	ICON_IDX_SERVER_CONNECTED,
	ICON_IDX_SERVER_LOST_CONNECTION,
    ICON_IDX_SERVER_NO_ACCESS,
	ICON_IDX_WINS_PRODUCT,
	ICON_IDX_MAX
} ICON_INDICIES, * LPICON_INDICIES;

// icon image map
extern UINT g_uIconMap[ICON_IDX_MAX + 1][2];

/////////////////////////////////////////////////////////////////////////////
// CWinsComponentData

class CWinsComponentData :
	public CComponentData,
	public CComObjectRoot
{
public:
	
BEGIN_COM_MAP(CWinsComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
			
	// These are the interfaces that we MUST implement

	// We will implement our common behavior here, with the derived
	// classes implementing the specific behavior.
	DeclareIPersistStreamInitMembers(IMPL)
	DeclareITFSCompDataCallbackMembers(IMPL)

	CWinsComponentData();

	HRESULT FinalConstruct();
	void FinalRelease();
	
protected:
	SPITFSNodeMgr	m_spNodeMgr;
	SPITFSNode		m_spRootNode;

// Notify handler declarations
private:
};

/////////////////////////////////////////////////////////////////////////////
// CWinsComponent
class CWinsComponent : 
	public TFSComponent
{
public:
	CWinsComponent();
	~CWinsComponent();

	//DeclareITFSCompCallbackMembers(IMPL)
	STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie);
	STDMETHOD(QueryDataObject) (MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject);

    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

    // snap-in help
	STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);

//Attributes
private:
};

/*---------------------------------------------------------------------------
	This is how the WINS snapin implements its extension functionality.
	It actually exposes two interfaces that are CoCreate-able.  One is the 
	primary interface, the other the extension interface.
	
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CWinsComponentDataPrimary : public CWinsComponentData,
	public CComCoClass<CWinsComponentDataPrimary, &CLSID_WinsSnapin>
{
public:
	DECLARE_REGISTRY(CWinsComponentDataPrimary, 
					 _T("WinsSnapin.WinsSnapin.1"), 
					 _T("WinsSnapin.WinsSnapin"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

	STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_WinsSnapin; }
};


class CWinsComponentDataExtension : public CWinsComponentData,
    public CComCoClass<CWinsComponentDataExtension, &CLSID_WinsSnapinExtension>
{
public:
	DECLARE_REGISTRY(CWinsComponentDataExtension, 
					 _T("WinsSnapinExtension.WinsSnapinExtension.1"), 
					 _T("WinsSnapinExtension.WinsSnapinExtension"), 
					 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_WinsSnapinExtension; }
};


/*---------------------------------------------------------------------------
	This is the derived class for handling the IAbout interface from MMC
	Author: EricDav
 ---------------------------------------------------------------------------*/
class CWinsAbout : 
	public CAbout,
    public CComCoClass<CWinsAbout, &CLSID_WinsSnapinAbout>
{
public:
DECLARE_REGISTRY(CWinsAbout, _T("WinsSnapin.About.1"), 
							 _T("WinsSnapin.About"), 
							 IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CWinsAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
	COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CWinsAbout)

// these must be overridden to provide values to the base class
protected:
	virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
	virtual UINT GetAboutProviderId()	 { return IDS_ABOUT_PROVIDER; }
	virtual UINT GetAboutVersionId()	 { return IDS_ABOUT_VERSION; }
	virtual UINT GetAboutIconId()		 { return IDI_WINS_SNAPIN; }

	virtual UINT GetSmallRootId()		 { return IDB_ROOT_SMALL; }
	virtual UINT GetSmallOpenRootId()	 { return IDB_ROOT_SMALL; }
	virtual UINT GetLargeRootId()		 { return IDB_ROOT_LARGE; }
	virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 

};

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
	{ SHActivateContext (&m_ulActivationCookie); }
	
    ~CThemeContextActivator()
	{ SHDeactivateContext (m_ulActivationCookie); }
	
private:
    ULONG_PTR m_ulActivationCookie;
};    

#endif _WINSCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winsdb.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winsdb.cpp
		Wins database enumerator

	FILE HISTORY:
    Oct 13  1997    EricDav     Modified        

*/

#include "stdafx.h"
#include "wins.h"
#include "search.h"
#include "winsdb.h"
#include "tfschar.h"

IMPLEMENT_ADDREF_RELEASE(CWinsDatabase);

IMPLEMENT_SIMPLE_QUERYINTERFACE(CWinsDatabase, IWinsDatabase)

DEBUG_DECLARE_INSTANCE_COUNTER(CWinsDatabase)

CWinsDatabase::CWinsDatabase()
    : m_cRef(1), m_fFiltered(FALSE), m_fInitialized(FALSE), m_bShutdown(FALSE), m_hrLastError(hrOK)
{
	DEBUG_INCREMENT_INSTANCE_COUNTER(CWinsDatabase);

	SetCurrentState(WINSDB_NORMAL);

    m_hBinding = NULL;
	m_hThread = NULL;
	m_hStart = NULL;
	m_hAbort = NULL;
    m_dwOwner = (DWORD)-1;
    m_strPrefix = NULL;
    m_dwRecsCount = 0;
    m_bEnableCache = FALSE;
}

CWinsDatabase::~CWinsDatabase()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CWinsDatabase);
    
    m_bShutdown = TRUE;

    if (m_strPrefix != NULL)
        delete m_strPrefix;
    
    SetEvent(m_hAbort);
    SetEvent(m_hStart);
    
    if (WaitForSingleObject(m_hThread, 30000) != WAIT_OBJECT_0)
    {
        Trace0("WinsDatabase destructor thread never died!\n");       

        // TerminateThread
    }

    CloseHandle(m_hAbort);
    CloseHandle(m_hStart);
    CloseHandle(m_hThread);
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Init
		Implementation of IWinsDatabase::Init
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Init()
{
	HRESULT         hr = hrOK;
    WINSDB_STATE    uCurrentState;

    m_dwRecsCount = 0;

    COM_PROTECT_TRY
	{
        CORg (GetCurrentState(&uCurrentState));
        if (uCurrentState != WINSDB_NORMAL)
        {
            Trace1("WinsDatabase::Init - called when database busy - state %d\n", uCurrentState);       
            return E_FAIL;
        }

		CORg (m_cMemMan.Initialize());
        CORg (m_IndexMgr.Initialize());

        m_hrLastError = hrOK;

        CORg (SetCurrentState(WINSDB_LOADING));

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Start
		Implementation of IWinsDatabase::Start
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Start()
{
    // signal the thread to start loading
    SetEvent(m_hStart);

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Initialize
		Implementation of IWinsDatabase::Initialize
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Initialize(LPCOLESTR	pszName, LPCOLESTR pszIP)
{
	HRESULT hr = hrOK;
	DWORD dwError; 
	DWORD dwThreadId;

	COM_PROTECT_TRY
	{
		m_strName = pszName;
		m_strIp   = pszIP;

		CORg (m_cMemMan.Initialize());
        CORg (m_IndexMgr.Initialize());

        m_hStart = ::CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_hStart == NULL)
        {
            dwError = ::GetLastError();
            Trace1("WinsDatabase::Initialize - CreateEvent Failed m_hStart %d\n", dwError);
          
            return HRESULT_FROM_WIN32(dwError);
        }

        m_hAbort = ::CreateEvent(NULL, FALSE, FALSE, NULL);
		if (m_hAbort == NULL)
        {
            dwError = ::GetLastError();
            Trace1("WinsDatabase::Initialize - CreateEvent Failed m_hAbort %d\n", dwError);
          
            return HRESULT_FROM_WIN32(dwError);
        }

        m_hThread = ::CreateThread(NULL, 0, ThreadProc, this, 0, &dwThreadId);
		if (m_hThread == NULL)
        {
            dwError = ::GetLastError();
            Trace1("WinsDatabase::Init - CreateThread Failed %d\n", dwError);
          
            return HRESULT_FROM_WIN32(dwError);
        }

        m_fInitialized = TRUE;
	
        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH
	
	return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetName
		Implementation of IWinsDatabase::GetName
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetName(LPOLESTR pszName, UINT cchMax)
{
	HRESULT hr = hrOK;
	LPCTSTR pBuf;

	COM_PROTECT_TRY
	{
        if (cchMax < (UINT) (m_strName.GetLength() / sizeof(TCHAR)))
            return E_FAIL;

        StrnCpy(pszName, (LPCTSTR) m_strName, cchMax);
    }
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetIP
		Implementation of IWinsDatabase::GetIP
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetIP(LPOLESTR pszIP, UINT cchMax)
{
	HRESULT hr = hrOK;
	LPCTSTR pBuf;

    COM_PROTECT_TRY
	{
        if (cchMax < (UINT) (m_strIp.GetLength() / sizeof(TCHAR)))
            return E_FAIL;

        StrnCpy(pszIP, (LPCTSTR) m_strIp, cchMax);

    }
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Stop
		Implementation of IWinsDatabase::Stop
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Stop()
{
	HRESULT         hr = hrOK;
	WINSDB_STATE    uState;

    COM_PROTECT_TRY
	{
		CORg (GetCurrentState(&uState));

        if (uState != WINSDB_LOADING)
            return hr;

		SetEvent(m_hAbort);

        CORg (SetCurrentState(WINSDB_NORMAL));

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Clear
		Clears the wins DB of all records
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::Clear()
{
	HRESULT         hr = hrOK;
	WINSDB_STATE    uState;

    COM_PROTECT_TRY
	{
		CORg (GetCurrentState(&uState));

        if (uState == WINSDB_SORTING ||
            uState == WINSDB_FILTERING)
            return E_FAIL;

        if (uState == WINSDB_LOADING)
        {
    		SetEvent(m_hAbort);
            CORg (SetCurrentState(WINSDB_NORMAL));
        }

   		CORg (m_cMemMan.Initialize());
        CORg (m_IndexMgr.Initialize());
        m_dwOwner = (DWORD)-1;
        if (m_strPrefix != NULL)
            delete m_strPrefix;
        m_strPrefix = NULL;

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

    return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetLastError
		Returns the last error for async calls
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetLastError(HRESULT * pLastError)
{
	HRESULT         hr = hrOK;
	WINSDB_STATE    uState;

    COM_PROTECT_TRY
	{
        if (pLastError)
            *pLastError = m_hrLastError;

	}
	COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Sort
		Implementation of IWinsDatabase::Sort
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT	
CWinsDatabase::Sort(WINSDB_SORT_TYPE SortType, DWORD dwSortOptions)
{
	HRESULT         hr = hrOK;
	WINSDB_STATE    uState;

	COM_PROTECT_TRY
	{
		CORg (GetCurrentState(&uState));

        if (uState != WINSDB_NORMAL)
			return E_FAIL;

		CORg (SetCurrentState(WINSDB_SORTING));

        m_IndexMgr.Sort(SortType, dwSortOptions);

        CORg (SetCurrentState(WINSDB_NORMAL));

		COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetHRow
		Implementation of IWinsDatabase::GetHRow
        returns the HRow in the current sorted index
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetHRow(UINT		uIndex,
					   LPHROW   hRow)
{
	Assert(uIndex >= 0);

	HRESULT hr = hrOK;
    WINSDB_STATE uState;
    int          nCurrentCount;

	COM_PROTECT_TRY
	{
        CORg (GetCurrentCount(&nCurrentCount));

        if (uIndex > (UINT) nCurrentCount)
            return E_FAIL;

    	CORg (GetCurrentState(&uState));
        if (uState == WINSDB_SORTING || uState == WINSDB_FILTERING)
            return E_FAIL;

        m_IndexMgr.GetHRow(uIndex, hRow);

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

	return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetRows
		Implementation of IWinsDatabase::GetRows
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT	CWinsDatabase::GetRows(	ULONG	uNumberOfRows,
							    ULONG	uStartPos,
								HROW*	pHRow,
								int*	nNumberOfRowsReturned)
{
    int             nCurrentCount;
    WINSDB_STATE    uState;
	HRESULT         hr = hrOK;
    int             nReturnedRows = 0;
    int             i;
    HROW            hrowCur;

    Assert (uStartPos >= 0);

    COM_PROTECT_TRY
	{
    	CORg (GetCurrentState(&uState));
		if (uState == WINSDB_SORTING || uState == WINSDB_FILTERING)
			return E_FAIL;

        CORg (GetCurrentCount(&nCurrentCount));
        Assert ((int) uStartPos <= nCurrentCount);
        if (uStartPos > (UINT) nCurrentCount)
            return E_FAIL;

		for (i = (int) uStartPos; i < (int) (uStartPos + uNumberOfRows); i++)
		{
			if( i > nCurrentCount )
			{
				break;
			}

            CORg (m_IndexMgr.GetHRow(i, &hrowCur));

			// if the row is marked deleted, don't add it to the array
            // REVIEW: directly accessing memory here.. we may want to change this
            // to go through the memory manager
            if ( ((LPWINSDBRECORD) hrowCur)->szRecordName[17] & WINSDB_INTERNAL_DELETED )
			{
				continue;
			}

            // fill in the data
            pHRow[i-uStartPos] = hrowCur;
            nReturnedRows++;
		}

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

    if (nNumberOfRowsReturned)
        *nNumberOfRowsReturned = nReturnedRows;

    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetData
		Implementation of IWinsDatabase::GetData
        returns the HRow in the current sorted index
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT CWinsDatabase::GetData(HROW         hRow,
							   LPWINSRECORD pRecordData)
{
	HRESULT hr = E_FAIL;

	COM_PROTECT_TRY
	{
        CORg (m_cMemMan.GetData(hRow, pRecordData));

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

	return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::FindRow
		Implementation of IWinsDatabase::FindRow
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::FindRow(LPCOLESTR	pszName,
			   	       HROW		    hrowStart,
					   HROW *		phRow) 
{
	HRESULT     hr = E_FAIL;
	WinsRecord  ws;
    int         nIndex, nPos, nCurrentCount;
    HROW        hrowCur;
    HROW        hrowFound = NULL;
    char        szName[MAX_PATH];

    CString strTemp(pszName);

    // this should be OEM 
    WideToMBCS(strTemp, szName, WINS_NAME_CODE_PAGE);

	COM_PROTECT_TRY
	{
        CORg (m_IndexMgr.GetIndex(hrowStart, &nIndex));
		
		/////
		CORg(GetHRow(nIndex, &hrowCur));
		CORg (m_IndexMgr.GetIndex(hrowCur, &nIndex));

        CORg (GetCurrentCount(&nCurrentCount));

		if(nIndex != -1)
		{

			CORg(GetHRow(nIndex, &hrowCur));

			for (nPos = nIndex + 1; nPos < nCurrentCount; nPos++)
			{
				CORg(GetHRow(nPos, &hrowCur));
            
				CORg(GetData(hrowCur, &ws));
				if(!_strnicmp(ws.szRecordName, szName, strlen(szName) ))
				{
					hrowFound = hrowCur;
					hr = hrOK;
					break;
				}
			}
		}

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

    if (phRow)
        *phRow = hrowFound;

    return hr;
}
        
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetTotalCount
		Implementation of IWinsDatabase::GetTotalCount
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT	
CWinsDatabase::GetTotalCount(int * nTotalCount)
{
	HRESULT hr = hrOK;
	COM_PROTECT_TRY
	{
		*nTotalCount = m_IndexMgr.GetTotalCount();
	}
	COM_PROTECT_CATCH
	return hr;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::GetCurrentCount
		Implementation of IWinsDatabase::GetCurrentCount
        returns the HRow in the current sorted index
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetCurrentCount(int * nCurrentCount)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		if (m_DBState == WINSDB_SORTING)
			*nCurrentCount = 0;
		else
			*nCurrentCount = m_IndexMgr.GetCurrentCount();
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetCurrentScanned(int * nCurrentScanned)
		Implementation of IWinsDatabase::GetCurrentScanned
        returns the total number of records that were read from the server
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetCurrentScanned(int * nCurrentCount)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
        *nCurrentCount = m_dwRecsCount;
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::AddRecord
		Implementation of IWinsDatabase::AddRecord
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CWinsDatabase::AddRecord(const LPWINSRECORD pRecordData)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		// critical sections taken care by the memory manager
		HROW hrow = NULL;
    
        CORg (m_cMemMan.AddData(*pRecordData, &hrow));
        CORg (m_IndexMgr.AddHRow(hrow));

        COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH

	return hrOK;
}
	
/*!--------------------------------------------------------------------------
	CWinsDatabase::DeleteRecord
		Implementation of IWinsDatabase::DeleteRecord
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::DeleteRecord(HROW hrowRecord)
{
	HRESULT hr = hrOK;
    WINSDB_STATE uState;
    
	COM_PROTECT_TRY
	{
		CORg (GetCurrentState(&uState));

        if (uState != WINSDB_NORMAL)
			return E_FAIL;

		// make sure the hrow is a valid one
		if (!m_cMemMan.IsValidHRow(hrowRecord))
			return E_FAIL;

		// Tell the memmgr to delete this record
        CORg (m_cMemMan.Delete(hrowRecord));

        // now tell the index manager to remove this hrow
        CORg (m_IndexMgr.RemoveHRow(hrowRecord));

        COM_PROTECT_ERROR_LABEL;
    }
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetCurrentState
		Implementation of IWinsDatabase::GetCurrentState
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetCurrentState(WINSDB_STATE * pState)
{
	CSingleLock cl(&m_csState);
    cl.Lock();

    *pState = m_DBState;
	
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::SetCurrentState
		Helper function to set the current state, protected
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::SetCurrentState(WINSDB_STATE winsdbState)
{
	CSingleLock cl(&m_csState);
    cl.Lock();

    m_DBState = winsdbState;
	
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::FilterRecords
		Implementation of IWinsDatabase::FilterRecords
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::FilterRecords
(
    WINSDB_FILTER_TYPE  FilterType,
	DWORD			    dwParam1,
	DWORD			    dwParam2)
{
	HRESULT hr = E_NOTIMPL;
	WINSDB_STATE uState ;

	COM_PROTECT_TRY
	{
		// fail if the state is other then WINSDB_NORMAL
		CORg (GetCurrentState(&uState));

        if (uState == WINSDB_SORTING || uState == WINSDB_FILTERING)
			return E_FAIL;

		// if in the loading state the readrecords function takes care
		if(uState != WINSDB_LOADING)
			CORg (SetCurrentState(WINSDB_FILTERING));

        // do the filtering here, rebuild the filtered name Index
		m_IndexMgr.Filter(FilterType, dwParam1, dwParam2);

		if(uState != WINSDB_LOADING)
			CORg (SetCurrentState(WINSDB_NORMAL));

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH
	
    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::AddFilter
        Adds the filters specified to the list
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::AddFilter(WINSDB_FILTER_TYPE FilterType, DWORD dwParam1, DWORD dwParam2, LPCOLESTR strParam3)
{
	HRESULT hr = hrOK;
	
	COM_PROTECT_TRY
	{
		// for filter by type, dwParam1 is the type, dwParam2 is show/not show
		m_IndexMgr.AddFilter(FilterType, dwParam1, dwParam2, strParam3);
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::ClearFilter
        CLears all the filters
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/

HRESULT 
CWinsDatabase::ClearFilter(WINSDB_FILTER_TYPE FilterType)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		//CFilteredIndexName *pFilterName = (CFilteredIndexName *)m_IndexMgr.GetFilteredNameIndex();
		//pFilterName->ClearFilter();
		m_IndexMgr.ClearFilter(FilterType);
	}
	COM_PROTECT_CATCH

	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::SetActiveView
		Implementation of IWinsDatabase::SetActiveView
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/

HRESULT 
CWinsDatabase::SetActiveView(WINSDB_VIEW_TYPE ViewType)
{
	HRESULT hr = hrOK;

	COM_PROTECT_TRY
	{
		m_IndexMgr.SetActiveView(ViewType);
	}
	COM_PROTECT_CATCH

	return hr;

}

/*!--------------------------------------------------------------------------
	CWinsDatabase::Execute()
        The background thread calls into this to execute
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
DWORD
CWinsDatabase::Execute()
{
    DWORD dwStatus = 0;

    // wait for the other thread to signal us to start doing something

    while (::WaitForSingleObject(m_hStart, INFINITE) == WAIT_OBJECT_0)
    {
        if (m_bShutdown)
            break;

        Trace0("WinsDatabase::Execute - start event signaled\n");

		WINSINTF_BIND_DATA_T wbdBindData;
		handle_t		hBinding = NULL;

        do
        {
            // enumerate leases here
            SetCurrentState(WINSDB_LOADING);

	        // now that the server name and ip are valid, call
	        // WINSBind function directly.
	        
            WINSINTF_ADD_T  waWinsAddress;

	        DWORD			dwStatus;
	        CString strNetBIOSName;

		    // call WinsBind function with the IP address
		    wbdBindData.fTcpIp = 1;
		    wbdBindData.pPipeName = NULL;
		    
		    // convert wbdBindData.pServerAdd to wide char again as one of the internal 
		    // functions expects a wide char string, this is done in WinsABind which is bypassed for 
		    // unicode compatible apps

            wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) m_strIp;

		    if ((hBinding = ::WinsBind(&wbdBindData)) == NULL)
		    {
			    dwStatus = ::GetLastError();
                Trace1("WinsDatabase::Execute - WinsBind failed %lx\n", dwStatus);
			    break;
		    }

#ifdef WINS_CLIENT_APIS
		    dwStatus = ::WinsGetNameAndAdd(
							hBinding,
			                &waWinsAddress,
			                (BYTE *)strNetBIOSName.GetBuffer(128));

#else
			dwStatus = ::WinsGetNameAndAdd(
							&waWinsAddress,
			                (BYTE *)strNetBIOSName.GetBuffer(128));

#endif WINS_CLIENT_APIS

            strNetBIOSName.ReleaseBuffer();

            if (dwStatus == ERROR_SUCCESS)
            {
				if(m_dwOwner == (DWORD)-1)
					dwStatus = ReadRecords(hBinding);
				else
					dwStatus = ReadRecordsByOwner(hBinding);

                break;
            }
            else
            {
                Trace1("WinsDatabase::Execute - WinsGetNameAndAdd failed %lx\n", dwStatus);
                break;
            }
        
        } while (FALSE);

        SetCurrentState(WINSDB_NORMAL);


		if(hBinding)
		{
			// call winsunbind here, the handle is invalid after this and that's fine
			WinsUnbind(&wbdBindData, hBinding);
			hBinding = NULL;
		}
        Trace0("WinsDatabase::Execute - all done, going to sleep now...\n");

    } // while !Start

    Trace0("WinsDatabase::Execute - exiting\n");
    return dwStatus;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::ReadRecords
        Reads records from the WINS server
    Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
DWORD 
CWinsDatabase::ReadRecords(handle_t hBinding)
{
	DWORD dwStatus = ERROR_SUCCESS;
	DWORD err = ERROR_SUCCESS;
	
    CWinsResults winsResults;
    err = winsResults.Update(hBinding);

	WINSINTF_RECS_T Recs;
	Recs.pRow = NULL;
	
	DWORD   NoOfRecsDesired = 500;
	DWORD   TypeOfRecs = 4;
	BOOL    fReadAllRecords ;

    PWINSINTF_RECORD_ACTION_T pRow;
    enum {ST_SCAN_1B_NAME, ST_SCAN_NORM_NAME} State;
	LPBYTE  pLastName;
	UINT    nLastNameLen, nLastBuffLen;

    pLastName       = NULL;
    nLastNameLen    = 0;
    nLastBuffLen    = 0;

#ifdef DEBUG
    CTime timeStart, timeFinish;
    timeStart = CTime::GetCurrentTime();
#endif

    m_dwRecsCount = 0;

    // initialize the state machine. If we have a name prefix filter we
    // start in ST_INIT_1B since we look first for the 1B names. These are
    // particular in a sense their type byte - i.e. 0x1B - has been swapped
    // with the first byte from the name. Consequently we need to do the same
    // to allow WINS to look first for these names. Once we get over the 1B zone
    // of our names, we restore the first byte and initiate another cycle for
    // the rest of the name.
    if (m_strPrefix != NULL)
    {
        nLastNameLen = nLastBuffLen = strlen(m_strPrefix) + 1;
        pLastName = (LPBYTE) new CHAR[nLastBuffLen];
        strcpy((LPSTR)pLastName, m_strPrefix);
        pLastName[0] = 0x1B;
        State = ST_SCAN_1B_NAME;
    }
    else
    {
        State = ST_SCAN_NORM_NAME;
    }

    do
	{

#ifdef WINS_CLIENT_APIS
        err = ::WinsGetDbRecsByName(
                    hBinding,
                    NULL,
                    WINSINTF_BEGINNING,
                    pLastName,
			        nLastNameLen,
                    NoOfRecsDesired, 
                    TypeOfRecs,
                    &Recs);

#else
		err = ::WinsGetDbRecsByName(
                    NULL,
                    WINSINTF_BEGINNING,
                    pFromName,
					LastNameLen,
                    NoOfRecsDesired,
                    TypeOfRecs,
                    &Recs);

#endif WINS_CLIENT_APIS 


        // check to see if we need to abort
        if (WaitForSingleObject(m_hAbort, 0) == WAIT_OBJECT_0)
        {
    		Trace0("CWinsDatabase::ReadRecords - abort detected\n");
            dwStatus = ERROR_OPERATION_ABORTED;
            break;
        }

        if (err == ERROR_REC_NON_EXISTENT)
		{
			//
			// Not a problem, there simply
			// are no records in the database
			//
            Trace0("WinsDatabase::ReadRecords - no records in the Datbase\n");
			fReadAllRecords = TRUE;
			err = ERROR_SUCCESS;
			break;
		}

		if (err == ERROR_SUCCESS)
		{
			fReadAllRecords  = Recs.NoOfRecs < NoOfRecsDesired;
            if (fReadAllRecords)
                Trace0("WinsDatabase::ReadRecords - Recs.NoOfRecs < NoOfRecsDesired, will exit\n");

            TRY
			{
				DWORD i;
				pRow = Recs.pRow;

				for (i = 0; i < Recs.NoOfRecs; ++i, ++pRow)
				{
					PWINSINTF_RECORD_ACTION_T pRow1 = Recs.pRow;
                    WinsRecord wRecord;
                    HROW hrow = NULL;

                    WinsIntfToWinsRecord(pRow, wRecord);
					if (pRow->OwnerId < (UINT) winsResults.AddVersMaps.GetSize())
                    {
						wRecord.dwOwner = winsResults.AddVersMaps[pRow->OwnerId].Add.IPAdd;
                    }
                    else
                    {
                        // having a record owned by a server which is not in the version map
                        // we got just earlier from WINS is not something that usually happens.
                        // It might happen only if the new owner was added right in between.
                        // Unlikely since this is a very small window - but if this happens
                        // just skip the record. From our point of view this owner doesn't exist
                        // hence the record doesn't belong to the view. It will show up with the
                        // first refresh.
                        continue;
                    }

					m_dwRecsCount++;

                    if (!m_bEnableCache && !m_IndexMgr.AcceptWinsRecord(&wRecord))
                        continue;

                    // add the data to our memory store and
                    // to the sorted index
                    m_cMemMan.AddData(wRecord, &hrow);
                    // if m_bEnableCache is 0 the the filter was checked
                    m_IndexMgr.AddHRow(hrow, TRUE, !m_bEnableCache);

                    //Trace1("%d records added to DB\n", m_dwRecsCount);
				}


                // if we reached the end of the DB there is no need to do
                // anything from below. Is just pLastName that needs to be
                // freed up - this is done outside the loop, before exiting
                // the call.
                if (!fReadAllRecords)
                {
                    BOOL fRangeOver = FALSE;

                    // get to the last record that was retrieved.
                    --pRow;

                    // check if the last name retrieved from the server is still
                    // mathing the pattern prefix (if any) or the range has been 
                    // passed over (fRangeOver)

                    if (m_strPrefix != NULL)
                    {
                        for (UINT i = 0; i < pRow->NameLen && m_strPrefix[i] != 0; i++)
                        {
                            if (m_strPrefix[i] != pRow->pName[i])
                            {
                                fRangeOver = TRUE;
                                break;
                            }
                        }
                    }

                    // here fRangeOver is either TRUE if the name doesn't match the pattern
                    // prefix or FALSE if the range is not passed yet. This latter thing means
                    // either the name is included in the prefix or the prefix isn't included in the name
                    // !!! We might want to invalidate the "name included in the prefix" case.
                    if (fRangeOver)
                    {
                        switch(State)
                        {
                        case ST_SCAN_1B_NAME:
                            // in this state pLastName is definitely not NULL and even more, 
                            // it once copied m_strPrefix. Since pLastName can only grow, it is
                            // certain it is large enough to cotain m_strPrefix one more time.
                            strcpy((LPSTR)pLastName, m_strPrefix);
					        nLastNameLen = strlen((LPCSTR)pLastName);
                            State = ST_SCAN_NORM_NAME;
                            break;
                        case ST_SCAN_NORM_NAME:
                            // we were scanning normal names and we passed
                            // over the range of names we are looking for
                            // so just get out of the loop.
                            fReadAllRecords = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        // enlarge the pLastName if needed
                        if (nLastBuffLen < pRow->NameLen+2)
                        {
                            if (pLastName != NULL)
                                delete pLastName;
                            nLastBuffLen = pRow->NameLen+2;
                            pLastName = (LPBYTE)new CHAR[nLastBuffLen];
                        }
                        // copy in pLastName the name of the last record
					    strcpy((LPSTR)pLastName, (LPCSTR)(pRow->pName));

                        if (pRow->NameLen >= 16 && pLastName[15] == 0x1B)
					    {
						    CHAR ch = pLastName[15];
						    pLastName[15] = pLastName[0];
						    pLastName[0] = ch;
					    }

                        strcat((LPSTR)pLastName, "\x01");
					    nLastNameLen = strlen((LPCSTR)pLastName);
                    }
                }
			}
			CATCH_ALL(e)
			{
				err = ::GetLastError();
                Trace1("WinsDatabase::ReadRecords - Exception! %d \n", err);
                m_hrLastError = HRESULT_FROM_WIN32(err);
			}
			END_CATCH_ALL
		}		
		else
		{
            Trace1("WinsDatabase::ReadRecords - GetRecsByName failed! %d \n", err);
            m_hrLastError = HRESULT_FROM_WIN32(err);
			break;
		}
		
		if (Recs.pRow != NULL)
        {
            ::WinsFreeMem(Recs.pRow);
        }

    } while(!fReadAllRecords );

    if (pLastName != NULL)
        delete pLastName;

#ifdef DEBUG
    timeFinish = CTime::GetCurrentTime();
    CTimeSpan timeDelta = timeFinish - timeStart;
	CString strTempTime = timeDelta.Format(_T("%H:%M:%S"));
    Trace2("WINS DB - ReadRecords: %d records read, total time %s\n", m_dwRecsCount, strTempTime);
#endif

    return dwStatus;
}

/*!--------------------------------------------------------------------------
	ThreadProc
        -
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
DWORD WINAPI 
ThreadProc(LPVOID pParam)
{
    DWORD dwReturn;
    HRESULT hr = hrOK;

    COM_PROTECT_TRY
    {
	    CWinsDatabase *pWinsDB = (CWinsDatabase *) pParam;
	    
        Trace0("WinsDatabase Background Thread started.\n");

        dwReturn = pWinsDB->Execute();
    }
    COM_PROTECT_CATCH

    return dwReturn;
}


/*!--------------------------------------------------------------------------
	WinsIntfToWinsRecord
		Converts a wins record from the server into the WinsRecord struct
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
void
WinsIntfToWinsRecord(PWINSINTF_RECORD_ACTION_T  pRecord, WinsRecord & wRecord)
{
    ZeroMemory(&wRecord, sizeof(WinsRecord));

    //::strcpy(wRecord.szRecordName, (LPCSTR)pRecord->pName);
    ::memcpy(wRecord.szRecordName, (LPCSTR)pRecord->pName, pRecord->NameLen);

    wRecord.dwExpiration = (ULONG) pRecord->TimeStamp;
	wRecord.liVersion = pRecord->VersNo;
	wRecord.dwOwner = pRecord->OwnerId;
	wRecord.dwNameLen = WINSINTF_NAME_LEN_M(pRecord->NameLen);
    wRecord.dwType |= (BYTE) wRecord.szRecordName[15];

    // translate the state and types to our own definitions
    switch (pRecord->State_e)
    {
        case WINSINTF_E_TOMBSTONE:
		    wRecord.dwState |= WINSDB_REC_TOMBSTONE;
            break;

        case WINSINTF_E_DELETED:
            //Trace0("WinsIntfToWinsRecord - deleted record.\n");
		    wRecord.dwState |= WINSDB_REC_DELETED;
            break;

        case WINSINTF_E_RELEASED:
            //Trace0("WinsIntfToWinsRecord - released record.\n");
		    wRecord.dwState |= WINSDB_REC_RELEASED;
            break;

        default:  // WINSINTF_E_ACTIVE:
		    wRecord.dwState |= WINSDB_REC_ACTIVE;
            break;
    }

    switch (pRecord->TypOfRec_e)
    {
        case WINSINTF_E_NORM_GROUP:
		    wRecord.dwState |= WINSDB_REC_NORM_GROUP;
            break;

        case WINSINTF_E_SPEC_GROUP:
		    wRecord.dwState |= WINSDB_REC_SPEC_GROUP;
            break;

        case WINSINTF_E_MULTIHOMED:
		    wRecord.dwState |= WINSDB_REC_MULTIHOMED;
            break;

        default:  // WINSINTF_E_UNIQUE:
		    wRecord.dwState |= WINSDB_REC_UNIQUE;
            break;
    }

    // now do the type -- move the value into the high word
    DWORD dwTemp = (pRecord->TypOfRec_e << 16);
    wRecord.dwType |= dwTemp;

    // now set the static flag
    if (pRecord->fStatic)
		wRecord.dwState |= WINSDB_REC_STATIC;

    // store all of the IP addrs
    wRecord.dwNoOfAddrs = pRecord->NoOfAdds;
    if (pRecord->NoOfAdds > 1)
    {
        Assert(pRecord->NoOfAdds <= WINSDB_MAX_NO_IPADDRS);
        
        //if (wRecord.dwNoOfAddrs > 4)
        //    Trace1("WinsIntfToWinsRecord - record with multiple (>4) IP addrs: %d\n", wRecord.dwNoOfAddrs);

        wRecord.dwState |= WINSDB_REC_MULT_ADDRS;

        for (UINT i = 0; i < pRecord->NoOfAdds; i++)
            wRecord.dwIpAdd[i] = pRecord->pAdd[i].IPAdd;
    }
    else
    {   
        if (pRecord->NoOfAdds == 0)
        {
            //Trace2("WinsIntfToWinsRecord - record with NoOfAdds == 0; IP: %lx State: %lx \n", pRecord->Add.IPAdd, wRecord.dwState);
        }

        if (pRecord->Add.IPAdd == 0)
        {
            Trace1("WinsIntfToWinsRecord - record with 0 IP Address! State: %lx \n", wRecord.dwState);
        }

        wRecord.dwIpAdd[0] = pRecord->Add.IPAdd;
    }
}

/*!--------------------------------------------------------------------------
	CreateWinsDatabase
		-
	Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
HRESULT
CreateWinsDatabase(CString&  strName, CString&  strIP, IWinsDatabase **ppWinsDB)
{
	AFX_MANAGE_STATE(AfxGetModuleState());
	
	CWinsDatabase *	pWinsDB = NULL;
	HRESULT		hr = hrOK;

	SPIWinsDatabase	spWinsDB;

	COM_PROTECT_TRY
	{
		pWinsDB = new CWinsDatabase();
		Assert(pWinsDB);
		
		spWinsDB = pWinsDB;
		CORg(pWinsDB->Initialize(strName, strIP));
		
		*ppWinsDB = spWinsDB.Transfer();

		COM_PROTECT_ERROR_LABEL;
	}
	COM_PROTECT_CATCH
	
	return hr;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::SetApiInfo
		Implementation of SetApiInfo of IWinsDatabase
	Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::SetApiInfo(DWORD dwOwner, LPCOLESTR strPrefix, BOOL bCache)
{
    // first cleanup the old prefix
    if (m_strPrefix != NULL)
    {
        delete m_strPrefix;
        m_strPrefix = NULL;
    }

    if (strPrefix != NULL)
    {
        UINT    nPxLen = 0;
        LPSTR   pPrefix;

        nPxLen = (_tcslen(strPrefix)+1)*sizeof(TCHAR);
        m_strPrefix = new char[nPxLen];
        if (m_strPrefix != NULL)
        {
#ifdef _UNICODE
            if (WideCharToMultiByte(CP_OEMCP,
                                    0,
                                    strPrefix,
                                    -1,
                                    m_strPrefix,
                                    nPxLen,
                                    NULL,
                                    NULL) == 0)
            {
                delete m_strPrefix;
                m_strPrefix = NULL;
            }
#else
            CharToOem(strPrefix, m_strPrefix);
#endif
            m_strPrefix = _strupr(m_strPrefix);

            for (pPrefix = m_strPrefix;
                 *pPrefix != '\0' && *pPrefix != '*' && *pPrefix != '?';
                 pPrefix++);
            *pPrefix = '\0';
        }
    }

    m_dwOwner = dwOwner;

    m_bEnableCache = bCache;

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::GetCachingFlag
		Implementation of GetCachingFlag of IWinsDatabase
	Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::GetCachingFlag(LPBOOL pbCache)
{
    *pbCache = m_bEnableCache;
    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::ReloadSuggested
		Implementation of ReloadSuggested of IWinsDatabase
	Author: FlorinT
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsDatabase::ReloadSuggested(DWORD dwOwner, LPCOLESTR strPrefix, LPBOOL pbReload)
{
    // check whether we filtered on a particular owner.
    if (m_dwOwner != 0xFFFFFFFF)
    {
        // we did filter on owner previously, suggest RELOAD if we now
        // don't want to filter on any owner (dwOwner == 0xffffffff)
        // or the owner we want to filter is different from the original one
        *pbReload = (m_dwOwner != dwOwner);
    }
    else
    {
        // we didn't filter on any owner previously so we either loaded
        // all the records (if no name prefix was specified) or loaded
        // all the records matching the given prefix
        if (m_strPrefix != NULL)
        {
            // we did have a previous prefix to match so we need to see
            // if the new prefix is not by any chance more specific than
            // the original one. In which case there is no need to reload
            LPSTR   pPrefix;
            UINT    nPxLen;
            UINT    i;

            if (strPrefix == NULL)
            {
                // if now we're not filtering by name, since we did previously
                // we definitely need to reload the database
                *pbReload = TRUE;
                return hrOK;
            }

            nPxLen = (_tcslen(strPrefix)+1)*sizeof(TCHAR);
            pPrefix = new char[nPxLen];
            if (pPrefix != NULL)
            {
#ifdef _UNICODE
                if (WideCharToMultiByte(CP_OEMCP,
                                        0,
                                        strPrefix,
                                        -1,
                                        pPrefix,
                                        nPxLen,
                                        NULL,
                                        NULL) == 0)
                {
                    delete pPrefix;
                    *pbReload = TRUE;
                    return hrOK;
                }
#else
                CharToOem(strPrefix, pPrefix);
#endif
                pPrefix = _strupr(pPrefix);

                for (i = 0;
                     pPrefix[i] != '\0' && pPrefix[i] != '*' && pPrefix[i] != '?';
                     i++);
                pPrefix[i] = '\0';

                // we don't suggest database reloading only if the current prefix
                // is a prefix for the new one to be applied. This way, whatever 
                // was retrieved previously already contains the names having the
                // new prefix.
                *pbReload = (strncmp(m_strPrefix, pPrefix, strlen(m_strPrefix)) != 0);

                delete pPrefix;
            }
            else
            {
                // couldn't allocate memory -> serious enough to ask a full reload
                *pbReload = TRUE;
            }
        }
        else
        {
            // well, there was no prefix specified last time the db was loaded so
            // we should have the whole database in hand. No need to reload.
            *pbReload = FALSE;
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
	CWinsDatabase::ReadRecordsByOwner
        Reads records from the WINS server for a particular owner
    Author: EricDav, v-shubk
 ---------------------------------------------------------------------------*/
#define MAX_DESIRED_RECORDS     400
#define LARGE_GAP_DETECT_COUNT  32
DWORD 
CWinsDatabase::ReadRecordsByOwner(handle_t hBinding)
{
    DWORD           err;
    CWinsResults    winsResults;
    WINSINTF_RECS_T Recs;
    DWORD           dwIP;
    LARGE_INTEGER   MinVersNo, MaxVersNo;
    LARGE_INTEGER   LowestVersNo;
    DWORD           dwDesired;
    DWORD           dwLargeGapCount;
    WINSINTF_ADD_T  OwnerAdd;
    DWORD           i;

    err = winsResults.Update(hBinding);
    if (err != ERROR_SUCCESS)
    {
        m_hrLastError = HRESULT_FROM_WIN32(err);
        return err;
    }

    MinVersNo.QuadPart= 0;
    for (i = 0; i < (int)winsResults.NoOfOwners; i++)
    {
        if (m_dwOwner == winsResults.AddVersMaps[i].Add.IPAdd)
        {
            MaxVersNo = winsResults.AddVersMaps[i].VersNo;
            break;
        }
    }

    // if we couldn't find the owner (highly unlikely) get out
    // with error INVALID_PARAMETER.
    if (i == winsResults.NoOfOwners)
    {
        err = ERROR_INVALID_PARAMETER;
        m_hrLastError = HRESULT_FROM_WIN32(err);
        return err;
    }

    m_dwRecsCount = 0;

    OwnerAdd.Type = 0;
    OwnerAdd.Len = 4;
    OwnerAdd.IPAdd = m_dwOwner;

    // This is what the server does to retrieve the records:
    // 1. sets an ascending index on owner & version number.
    // 2. goes to the first record owned by the given owner,
    //    having a version number larger or equal to MinVersNo.
    // 3. stop if the record's vers num is higher than the range specified
    // 4. stop if more than 1000 recs have been already received
    // 5. add the new record to the set to return and go to 3.
    //
    dwDesired       = MAX_DESIRED_RECORDS;
    dwLargeGapCount = LARGE_GAP_DETECT_COUNT;
    LowestVersNo.QuadPart = 0;
    if (MaxVersNo.QuadPart > dwDesired)
        MinVersNo.QuadPart = MaxVersNo.QuadPart-dwDesired;
    else
        MinVersNo.QuadPart = 0;
    Recs.pRow = NULL;
    while(MaxVersNo.QuadPart >= MinVersNo.QuadPart)
    {
        // clear up the previous array - if any
        if (Recs.pRow != NULL)
        {
            ::WinsFreeMem(Recs.pRow);
            Recs.pRow = NULL;
        }

        // go to WINS to get the data for the given Owner
#ifdef WINS_CLIENT_APIS
		err = ::WinsGetDbRecs(hBinding, &OwnerAdd, MinVersNo,
			MaxVersNo, &Recs);
#else
		err = ::WinsGetDbRecs(&OwnerAdd, MinVersNo,
			MaxVersNo, &Recs);
#endif WINS_CLIENT_APIS

        // if abort was requested, break out with "ABORTED"
		if (WaitForSingleObject(m_hAbort, 0) == WAIT_OBJECT_0)
		{
			err = ERROR_OPERATION_ABORTED;
			break;
		}

        // if there is any kind of error break out
        if (err != ERROR_SUCCESS)
        {
            if (err == ERROR_REC_NON_EXISTENT)
            {
                // I'm not sure this happens after all. The server side (WINS) has
                // not code path returning such an error code.
                err = ERROR_SUCCESS;
            }
            else
            {
                // if this happens, just get out with the error, and save the
                // meaning of the error
			    m_hrLastError = HRESULT_FROM_WIN32(err);
            }
            break;
        }

        // if got less than 1/4 of the size of the range, expand the range
        // to double of what it was + 1. (+1 is important to avoid the effect
        // of dramatic drop down because of DWORD roll-over
        if (Recs.NoOfRecs <= (dwDesired >> 2))
        {
            dwDesired <<= 1;
            dwDesired |= 1;
        }
        // else if got more than 3/4 of the size of the range, split the range in 2
        // but not less than MAX_DESIRED_RECORDS
        else if (Recs.NoOfRecs >= (dwDesired - (dwDesired >> 2)))
        {
            dwDesired = max (MAX_DESIRED_RECORDS, dwDesired >> 1);
        }

		TRY
		{
			DWORD                       j;
            PWINSINTF_RECORD_ACTION_T   pRow;

			for (j = 0, pRow = Recs.pRow; j < Recs.NoOfRecs; j++, ++pRow)
			{
				WinsRecord wRecord;
				HROW hrow = NULL;

				pRow->OwnerId = m_dwOwner;
				WinsIntfToWinsRecord(pRow, wRecord);

				m_dwRecsCount++;
                
                if (!m_bEnableCache && !m_IndexMgr.AcceptWinsRecord(&wRecord))
                    continue;

				// add the data to our memory store and
				// to the sorted index
				m_cMemMan.AddData(wRecord, &hrow);
				m_IndexMgr.AddHRow(hrow, FALSE, !m_bEnableCache);
			}

            // now setup the new range to search..
            //
            // if this is not the gap boundary detection cycle, the next MaxVersNo
            // needs to go right below the current MinVersNo. Otherwise, MaxVersNo
            // needs to remain untouched!
            if (dwLargeGapCount != 0)
                MaxVersNo.QuadPart = MinVersNo.QuadPart - 1;

            // if no records were found..
            if (Recs.NoOfRecs == 0)
            {
                // ..and we were already in the gap boundary detection cycle..
                if (dwLargeGapCount == 0)
                    // ..just break the loop - there are simply no more records
                    // for this owner in the database
                    break;

                // ..otherwise just decrease the gap boundary detection counter.
                // If it reaches 0, then next cycle we will attempt to see if
                // there is any record closer to the lowest edge of the range by
                // expanding for one time only the whole space.
                dwLargeGapCount--;
            }
            else
            {
                // if we just exited the gap boundary detection cycle by finding some
                // records, set the LowestVersNo to one more than the largest VersNo 
                // we found during this cycle.
                if (dwLargeGapCount == 0)
                {
                    pRow--;
                    LowestVersNo.QuadPart = pRow->VersNo.QuadPart+1;
                }

                // if there were any records found, just reset the gap boundary detection counter.
                dwLargeGapCount = LARGE_GAP_DETECT_COUNT;
            }

            // if the dwLargeGapCount counter is zero, it means the next cycle is a gap boundary detection one
            // which means the range should be set for the whole unexplored space.
            if (dwLargeGapCount != 0 && MaxVersNo.QuadPart > LowestVersNo.QuadPart + dwDesired)
                MinVersNo.QuadPart = MaxVersNo.QuadPart - dwDesired;
            else
                MinVersNo.QuadPart = LowestVersNo.QuadPart;
		}
		CATCH_ALL(e)
		{
			err = ::GetLastError();
			m_hrLastError = HRESULT_FROM_WIN32(err);
		}
		END_CATCH_ALL
		
	}

	if (Recs.pRow != NULL)
		::WinsFreeMem(Recs.pRow);

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winsdb.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	winsdb.h
		Wins database enumerator

	FILE HISTORY:
    Oct 13  1997    EricDav     Modified        

*/

#ifndef _WINDDB_H
#define _WINSDB_H

#include "wins.h"

#ifndef _MEMMNGR_H
#include "memmngr.h"
#endif

#ifndef _HARRAY_H
#include "harray.h"
#endif

class CWinsDatabase : public IWinsDatabase
{
public:
    CWinsDatabase();
    ~CWinsDatabase();

 	DeclareIUnknownMembers(IMPL)
	DeclareIWinsDatabaseMembers(IMPL)

    // helper to set the current state
    HRESULT SetCurrentState(WINSDB_STATE winsdbState);

    // for background threading
    DWORD Execute();
    DWORD ReadRecords(handle_t hBinding);
	DWORD ReadRecordsByOwner(handle_t hBinding);

    // ??
    int GetIndex(HROW hrow);
	HROW GetHRow(WinsRecord wRecord, BYTE bLast, BOOL fAllRecords);

protected:
	// Holds all of the sorted and filtered indicies
    CIndexMgr               m_IndexMgr;
    // handles memory allocation
    CMemoryManager			m_cMemMan;
    // total number of records scanned
    DWORD                   m_dwRecsCount;


    LONG					m_cRef;
	BOOL					m_fFiltered;
    BOOL                    m_fInitialized;
    BOOL                    m_bShutdown;

    CString					m_strName;
	CString					m_strIp;
    
	HANDLE					m_hThread;
	HANDLE					m_hStart;
	HANDLE					m_hAbort;

    HRESULT                 m_hrLastError;

	WINSDB_STATE			m_DBState;

    handle_t				m_hBinding;

    CCriticalSection        m_csState;

//    CDWordArray             m_dwaOwnerFilter;
    BOOL                    m_bEnableCache;
    DWORD                   m_dwOwner;
    LPSTR                   m_strPrefix;
};

typedef ComSmartPointer<IWinsDatabase, &IID_IWinsDatabase> SPIWinsDatabase;

// thread proc the background thread initially is called on
DWORD WINAPI ThreadProc(LPVOID lParam);

// converts records from the server to WinsRecords
void WinsIntfToWinsRecord(PWINSINTF_RECORD_ACTION_T pRecord, WinsRecord & wRecord);

// helper to create and initialize the WinsDatabase
extern HRESULT CreateWinsDatabase(CString&  strName, CString&  strIP, IWinsDatabase **ppWinsDB);

#endif // _WINSDB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winshand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	Winshand.cpp
		WINS specifc handler base classes

    FILE HISTORY:
        
*/



#include "stdafx.h"
#include "winshand.h"
#include "snaputil.h"


MMC_CONSOLE_VERB g_ConsoleVerbs[] =
{
	MMC_VERB_OPEN,
    MMC_VERB_COPY,
	MMC_VERB_PASTE,
	MMC_VERB_DELETE,
	MMC_VERB_PROPERTIES,
	MMC_VERB_RENAME,
	MMC_VERB_REFRESH,
	MMC_VERB_PRINT
};

#define HI HIDDEN
#define EN ENABLED

// StatusRemove
MMC_BUTTON_STATE g_ConsoleVerbStates[WINSSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, EN, HI, HI, HI},   // WINSSNAP_ROOT
	{HI, HI, HI, EN, EN, HI, EN, HI},   // WINSSNAP_SERVER
	{HI, HI, HI, HI, HI, HI, EN, HI},   // WINSSNAP_ACTIVEREG
	{HI, HI, HI, HI, EN, HI, EN, HI},   // WINSSNAP_REPLICATION_PARTNERS	
	{HI, HI, HI, HI, EN, HI, EN, HI},	// WINSSNAP_SERVER_STATUS
	{HI, HI, HI, EN, EN, HI, HI, HI},   // WINSSNAP_REGISTRATION	
    {HI, HI, HI, EN, EN, HI, HI, HI},	// WINSSNAP_REPLICATION_PARTNER
	{HI, HI, HI, HI, HI, HI, HI, HI}	// WINSSNAP_STATUS_LEAF_NODE
};

//Status Remove
MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[WINSSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, HI, HI, HI, HI},   // WINSSNAP_ROOT
	{HI, HI, HI, HI, HI, HI, HI, HI},   // WINSSNAP_SERVER
	{HI, HI, HI, HI, HI, HI, EN, HI},   // WINSSNAP_ACTIVEREG
	{HI, HI, HI, EN, HI, HI, HI, HI},   // WINSSNAP_REPLICATION_PARTNERS	
	{HI, HI, HI, HI, HI, HI, HI, HI},   // WINSSNAP_SERVER_STATUS	
	{HI, HI, HI, EN, HI, HI, HI, HI},   // WINSSNAP_REGISTRATION	
    {HI, HI, HI, EN, HI, HI, HI, HI},	// WINSSNAP_REPLICATION_PARTNER
	{HI, HI, HI, HI, HI, HI, HI, HI}	// WINSSNAP_STATUS_LEAF_NODE
};

// Help ID array for help on scope items
DWORD g_dwMMCHelp[WINSSNAP_NODETYPE_MAX] =
{
	WINSSNAP_HELP_ROOT,                 // WINSSNAP_ROOT
	WINSSNAP_HELP_SERVER,               // WINSSNAP_SERVER
	WINSSNAP_HELP_ACT_REG_NODE,         // WINSSNAP_ACTIVEREG
	WINSSNAP_HELP_REP_PART_NODE,        // WINSSNAP_REPLICATION_PARTNERS
	WINSSNAP_HELP_ACTREG_ENTRY,         // WINSSNAP_SCOPE
	WINSSNAP_HELP_REP_PART_ENTRY        // WINSSNAP_REPLICATION_PARTNER
};


/*---------------------------------------------------------------------------
	Class:	CMTWinsHandler
 ---------------------------------------------------------------------------*/

//
// Called by the result handler when a command comes in that isn't handled 
// by the result handler.  If appropriate it passes it to the scope pane hander.
//
HRESULT
CMTWinsHandler::HandleScopeCommand
(
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the handler to take care of this
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnCommand(spNode, nCommandID, dwType, pDataObject, (ULONG) spNode->GetData(TFS_DATA_TYPE));
    }
        
Error:
    return hr;
}

//
// Called by the result handler to add the scope pane menu items to the menu
// where appropriate.  Puts scope pane menu items in when action menu is clicked
// and the message view has focus as well as when a right click happens in the white 
// space of the result pane.
//
HRESULT
CMTWinsHandler::HandleScopeMenus
(
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the normal handler to put up the menu items
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnAddMenuItems(spNode, pContextMenuCallback, pDataObject, CCT_SCOPE, (ULONG) spNode->GetData(TFS_DATA_TYPE), pInsertionAllowed);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
	CMTWinsHandler::OnChangeState
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
void CMTWinsHandler::OnChangeState
(
	ITFSNode * pNode
)
{
	// Increment the state to the next position

	switch (m_nState)
	{
		case notLoaded:
		case loaded:
		case unableToLoad:
			{
				m_nState = loading;
				m_dwErr = 0;
			}
			break;

		case loading:
			{
				m_nState = (m_dwErr != 0) ? unableToLoad : loaded;
                
                if (m_dwErr)
                {
                    CString strTitle, strBody;
                    IconIdentifier icon;

                    GetErrorInfo(strTitle, strBody, &icon);
                    ShowMessage(pNode, strTitle, strBody, icon);
                }
                else
                {
                    ClearMessage(pNode);
                }

                m_fSilent = FALSE;
			}
			break;
	
		default:
			ASSERT(FALSE);
	}

    // check to make sure we are still the visible node in the UI
    if (m_bSelected)
    {
        UpdateStandardVerbs(pNode, pNode->GetData(TFS_DATA_TYPE));
    }

	// Now check and see if there is a new image for this state for this handler
	int nImage, nOpenImage;

	nImage = GetImageIndex(FALSE);
	nOpenImage = GetImageIndex(TRUE);

	if (nImage >= 0)
		pNode->SetData(TFS_DATA_IMAGEINDEX, nImage);

	if (nOpenImage >= 0)
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
	
	VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON)));
}


 /*!--------------------------------------------------------------------------
	CMTWinsHandler::UpdateStandardVerbs
		Tells the IComponent to update the verbs for this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTWinsHandler::UpdateStandardVerbs
(
    ITFSNode * pNode,
    LONG_PTR   dwNodeType
)
{
    HRESULT				hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject;

    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

    CORg ( spConsole->UpdateAllViews(pDataObject, 
                                     dwNodeType, 
                                     RESULT_PANE_UPDATE_VERBS) ); 

    pDataObject->Release();
	
Error:
    return;
}

/*---------------------------------------------------------------------------
	CMTWinsHandler::OnResultDelete
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CMTWinsHandler::OnResultDelete received\n");

	// translate this call to the parent and let it handle deletion 
	// of result pane items
	SPITFSNode spNode, spParent;
	SPITFSResultHandler spParentRH;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));
	CORg (spNode->GetParent(&spParent));

	if (spParent == NULL)
		return hr;

	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
	return hr;
}


 /*!--------------------------------------------------------------------------
	CMTWinsHandler::UpdateConsoleVerbs
		Updates the standard verbs depending upon the state of the node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTWinsHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];	
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
        
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
        
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::EnableVerbs
		Enables the toolbar buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CMTWinsHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
									   
        }
    }
	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}

 /*!--------------------------------------------------------------------------
	CMTWinsHandler::ExpandNode
		Expands/compresses this node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CMTWinsHandler::ExpandNode
(
    ITFSNode *  pNode,
    BOOL        fExpand
)
{
    SPIComponentData	spCompData;
    SPIDataObject       spDataObject;
    LPDATAOBJECT        pDataObject;
    SPIConsole          spConsole;
    HRESULT             hr = hrOK;

    // don't expand the node if we are handling the EXPAND_SYNC message,
    // this screws up the insertion of item, getting duplicates.
    if (!m_fExpandSync)
    {
        m_spNodeMgr->GetComponentData(&spCompData);

	    CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
	    CORg ( spConsole->UpdateAllViews(pDataObject, TRUE, RESULT_PANE_EXPAND) ); 
    }

Error:
    return;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnExpandSync
		Handles the MMCN_EXPANDSYNC notifcation 
        We need to do syncronous enumeration.  We'll fire off the background 
        thread like before, but we'll wait for it to exit before we return.
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::OnExpandSync
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    HRESULT hr = hrOK;
    MSG msg;

    m_fExpandSync = TRUE;

    hr = OnExpand(pNode, pDataObject, CCT_SCOPE, arg, lParam);

    // wait for the background thread to exit
    if (m_hThread != NULL)
        WaitForSingleObject(m_hThread, INFINITE);
    
    // The background thread posts messages to a hidden window to 
    // pass data back to the main thread. The messages won't go through since we are
    // blocking the main thread.  The data goes on a queue in the query object
    // which the handler has a pointer to so we can just fake the notification.
    if (m_spQuery.p)
        OnNotifyHaveData((LPARAM) m_spQuery.p);

    // Tell MMC we handled this message
    MMC_EXPANDSYNC_STRUCT * pES = reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(lParam);
    if (pES)
        pES->bHandled = TRUE;

    m_fExpandSync = FALSE;

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    HRESULT         hr = hrOK;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    SPINTERNAL      spInternal;
    BOOL            bMultiSelect = FALSE;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

	m_bSelected = bSelect;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnCreateDataObject
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTWinsHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	    pObject = NULL;
	SPIDataObject	    spDataObject;
    long                lViewOptions;
    LPOLESTR            pViewType;
    BOOL                bVirtual;

    pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
    	OnGetResultViewType(pComponent, cookie, &pViewType, &lViewOptions);
        bVirtual = (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ? TRUE : FALSE;
        
        CreateMultiSelectData(pComponent, pObject, bVirtual);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::CreateMultiSelectData
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CMTWinsHandler::CreateMultiSelectData
(
    ITFSComponent * pComponent, 
    CDataObject *   pObject,
    BOOL            bVirtual
)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList        listSelectedNodes;
    CVirtualIndexArray  arraySelectedIndicies;
    CGUIDArray          rgGuids;
    UINT                cb;
    GUID*               pGuid;
    const GUID *        pcGuid;
    int                 i;

    COM_PROTECT_TRY
    {
        if (bVirtual)
        {
            // build a list of the selected indicies in the virtual listbox
            CORg (BuildVirtualSelectedItemList(pComponent, &arraySelectedIndicies));

            // now call and get the GUIDs for each one
            for (i = 0; i < arraySelectedIndicies.GetSize(); i++)
            {
                pcGuid = GetVirtualGuid(arraySelectedIndicies[i]);
                if (pcGuid)
                    rgGuids.AddUnique(*pcGuid);
            }
        }
        else
        {
            CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

            // collect all of the unique guids
            while (listSelectedNodes.GetCount() > 0)
	        {
		        SPITFSNode   spCurNode;

		        spCurNode = listSelectedNodes.RemoveHead();

                pcGuid = spCurNode->GetNodeType();
			
                rgGuids.AddUnique(*pcGuid);
            }
        }

        // now put the information in the data object
        cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
        
        if (cb > 0)
        {
            pObject->SetMultiSelDobj();
    
            pGuid = new GUID[(size_t)rgGuids.GetSize()];
            CopyMemory(pGuid, rgGuids.GetData(), cb);
            pObject->SetMultiSelData((BYTE*)pGuid, cb);
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnResultUpdateView
		Implementation of ITFSResultHandler::OnResultUpdateView
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT CMTWinsHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LPARAM        hint
)
{
	HRESULT hr = hrOK;

    if (hint == RESULT_PANE_UPDATE_VERBS)
    {
	    SPIConsoleVerb  spConsoleVerb;
        SPITFSNode      spNode;

        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

        UpdateConsoleVerbs(spConsoleVerb, data);
    }
    else
    {
        return CBaseResultHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
		szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTWinsHandler::SaveColumns
		-
 ---------------------------------------------------------------------------*/
HRESULT 
CMTWinsHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth)) &&
            (aColumnWidths[dwNodeType][nCol] != nColWidth))
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}



/*---------------------------------------------------------------------------
	Class:	CWinsHandler
 ---------------------------------------------------------------------------*/

//
// Called by the result handler when a command comes in that isn't handled 
// by the result handler.  If appropriate it passes it to the scope pane hander.
//
HRESULT
CWinsHandler::HandleScopeCommand
(
	MMC_COOKIE  	cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the handler to take care of this
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnCommand(spNode, nCommandID, dwType, pDataObject, (ULONG) spNode->GetData(TFS_DATA_TYPE));
    }
        
Error:
    return hr;
}

//
// Called by the result handler to add the scope pane menu items to the menu
// where appropriate.  Puts scope pane menu items in when action menu is clicked
// and the message view has focus as well as when a right click happens in the white 
// space of the result pane.
//
HRESULT
CWinsHandler::HandleScopeMenus
(
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    DATA_OBJECT_TYPES   dwType = CCT_RESULT;

    if (IS_SPECIAL_DATAOBJECT(pDataObject))
    {
        dwType = CCT_SCOPE;
    }
    else
    {
        if (pDataObject)
        {
			SPINTERNAL		    spInternal;

            spInternal = ::ExtractInternalFormat(pDataObject);
			if (spInternal)
				dwType = spInternal->m_type;
        }
    }

    if (dwType == CCT_SCOPE)
    {
        // call the normal handler to put up the menu items
	    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

        hr = OnAddMenuItems(spNode, pContextMenuCallback, pDataObject, CCT_SCOPE, (ULONG) spNode->GetData(TFS_DATA_TYPE), pInsertionAllowed);
    }

Error:
    return hr;
}


/*---------------------------------------------------------------------------
	CWinsHandler::Command
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsHandler::Command
(
    ITFSComponent * pComponent, 
	MMC_COOKIE		cookie, 
	int				nCommandID,
	LPDATAOBJECT	pDataObject
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	HRESULT hr = S_OK;

    // this may have come from the scope pane handler, so pass it up
    hr = HandleScopeCommand(cookie, nCommandID, pDataObject);

    return hr;
}


/*!--------------------------------------------------------------------------
	CWinsHandler::AddMenuItems
		Over-ride this to add our view menu item
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
	MMC_COOKIE				cookie,
	LPDATAOBJECT			pDataObject, 
	LPCONTEXTMENUCALLBACK	pContextMenuCallback, 
	long *					pInsertionAllowed
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	HRESULT hr = S_OK;

    // figure out if we need to pass this to the scope pane menu handler
    hr = HandleScopeMenus(cookie, pDataObject, pContextMenuCallback, pInsertionAllowed);
    
    return hr;
}



/*---------------------------------------------------------------------------
	CWinsHandler::OnResultDelete
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE		cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CWinsHandler::OnResultDelete received\n");

	// translate this call to the parent and let it handle deletion 
	// of result pane items
	SPITFSNode spNode, spParent;
	SPITFSResultHandler spParentRH;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));
	CORg (spNode->GetParent(&spParent));

	if (spParent == NULL)
		return hr;

	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
	return hr;
}

 /*!--------------------------------------------------------------------------
	CWinsHandler::UpdateConsoleVerbs
		Updates the standard verbs depending upon the state of the node
	Author: EricDav
 ---------------------------------------------------------------------------*/
void
CWinsHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];	
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        /*
		ButtonState = g_ConsoleVerbStates[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
		*/

		ButtonState = g_ConsoleVerbStates[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
        
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
				for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;

            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
	CWinsHandler::EnableVerbs
		Enables the toolbar buttons
	Author: EricDav
 ---------------------------------------------------------------------------*/
void 
CWinsHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
									   
        }
    }

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}

/*!--------------------------------------------------------------------------
	CWinsHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    HRESULT         hr = hrOK;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    SPINTERNAL      spInternal;
    BOOL            bMultiSelect;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
		bMultiSelect = FALSE;
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsHandler::OnCreateDataObject
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWinsHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	    pObject = NULL;
	SPIDataObject	    spDataObject;
    long                lViewOptions;
    LPOLESTR            pViewType;
    BOOL                bVirtual;

    pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
    	OnGetResultViewType(pComponent, cookie, &pViewType, &lViewOptions);
        bVirtual = (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ? TRUE : FALSE;
        
        CreateMultiSelectData(pComponent, pObject, bVirtual);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

 /*!--------------------------------------------------------------------------
	CWinsHandler::CreateMultiSelectData
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
HRESULT
CWinsHandler::CreateMultiSelectData
(
    ITFSComponent * pComponent, 
    CDataObject *   pObject,
    BOOL            bVirtual
)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList        listSelectedNodes;
        CVirtualIndexArray  arraySelectedIndicies;
    CGUIDArray          rgGuids;
    UINT                cb;
    GUID*               pGuid;
    const GUID *        pcGuid;
    int                 i;

    COM_PROTECT_TRY
    {
        if (bVirtual)
        {
            // build a list of the selected indicies in the virtual listbox
            CORg (BuildVirtualSelectedItemList(pComponent, &arraySelectedIndicies));

            // now call and get the GUIDs for each one
            for (i = 0; i < arraySelectedIndicies.GetSize(); i++)
            {
                pcGuid = GetVirtualGuid(arraySelectedIndicies[i]);
                if (pcGuid)
                    rgGuids.AddUnique(*pcGuid);
            }
        }
        else
        {
            CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

            // collect all of the unique guids
            while (listSelectedNodes.GetCount() > 0)
	        {
		        SPITFSNode   spCurNode;

		        spCurNode = listSelectedNodes.RemoveHead();
                pcGuid = spCurNode->GetNodeType();
        
                rgGuids.AddUnique(*pcGuid);
            }
        }

        // now put the information in the data object
        cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
        
        if (cb > 0)
        {
            pObject->SetMultiSelDobj();
    
            pGuid = new GUID[(size_t)rgGuids.GetSize()];
            CopyMemory(pGuid, rgGuids.GetData(), cb);
            pObject->SetMultiSelData((BYTE*)pGuid, cb);
        }
        
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}


/*!--------------------------------------------------------------------------
	CWinsHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: v-shubk
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
		szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CWinsHandler::SaveColumns
		-
 ---------------------------------------------------------------------------*/
HRESULT 
CWinsHandler::SaveColumns
(   
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth)) &&
            (aColumnWidths[dwNodeType][nCol] != nColWidth))
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winshand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winshand.h
		Header file for wins specific base handler classes and query obj

    FILE HISTORY:
        
*/

#ifndef _WINSHAND_H
#define _WINSHAND_H

#ifndef _HANDLERS_H
#include <handlers.h>
#endif

#ifndef _QUERYOBJ_H
#include <queryobj.h>
#endif

extern MMC_CONSOLE_VERB g_ConsoleVerbs[8];
extern MMC_BUTTON_STATE g_ConsoleVerbStates[WINSSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)];
extern MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[WINSSNAP_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)];

/*---------------------------------------------------------------------------
	Class:	CHandlerEx
 ---------------------------------------------------------------------------*/
class CHandlerEx
{
// Interface
public:
	virtual HRESULT InitializeNode(ITFSNode * pNode) = 0;
	LPCTSTR GetDisplayName() { return m_strDisplayName; }
	void    SetDisplayName(LPCTSTR pName) { m_strDisplayName = pName; }

private:
	CString m_strDisplayName;
};

/*---------------------------------------------------------------------------
	Class:	CWinsHandler
 ---------------------------------------------------------------------------*/
class CWinsHandler : 
		public CHandler,
		public CHandlerEx
{
public:

	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad
	} nodeStateType;

	CWinsHandler(ITFSComponentData *pCompData) 
        : CHandler(pCompData),
          m_verbDefault(MMC_VERB_OPEN)
	{
	};

	~CWinsHandler() {};

	// base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    // by default we don't allow nodes to be renamed
    OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    HRESULT HandleScopeCommand(MMC_COOKIE cookie, int nCommandID, LPDATAOBJECT pDataObject);
    HRESULT HandleScopeMenus(MMC_COOKIE	cookie,	LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long * pInsertionAllowed);

	void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);

    virtual const GUID * GetVirtualGuid(int nIndex) { return NULL; }

protected:
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject, BOOL bVirtual);
    void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

	virtual DWORD UpdateStatistics(ITFSNode * pNode) { return 0; }

	// This is the default verb, by default it is set to MMC_VERB_OPEN
	MMC_CONSOLE_VERB	m_verbDefault;
};

/*---------------------------------------------------------------------------
	Class:	CMTWinsHandler
 ---------------------------------------------------------------------------*/
class CMTWinsHandler : 
		public CMTHandler,
		public CHandlerEx
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad
	} nodeStateType;

	CMTWinsHandler(ITFSComponentData *pCompData) 
        : CMTHandler(pCompData),
          m_verbDefault(MMC_VERB_OPEN),
          m_fSilent(FALSE),
          m_fExpandSync(FALSE)
	{ 
        m_nState = notLoaded; 
    }
	~CMTWinsHandler() {};

	// base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// by default we don't allow nodes to be renamed
	OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }
    OVERRIDE_BaseHandlerNotify_OnExpandSync();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
	OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
	OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    HRESULT HandleScopeCommand(MMC_COOKIE cookie, int nCommandID, LPDATAOBJECT pDataObject);
    HRESULT HandleScopeMenus(MMC_COOKIE	cookie,	LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pContextMenuCallback, long * pInsertionAllowed);
	
    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);
    
    virtual const GUID * GetVirtualGuid(int nIndex) { return NULL; }

	void	ExpandNode(ITFSNode * pNode, BOOL fExpand);

    // any node with taskpads should override this to identify itself
    virtual int   GetTaskpadIndex() { return 0; }

protected:
    virtual void GetErrorInfo(CString & strTitle, CString & strBody, IconIdentifier * pIcon) { };
	virtual void OnChangeState(ITFSNode* pNode);
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNewNode)
	{
		if (pNewNode->IsContainer())
		{
			// assume all the child containers are derived from this class
			//((CWinsMTContainer*)pNode)->SetServer(GetServer());
		}
		pParentNode->AddChild(pNewNode);
	}

    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject, BOOL bVirtual);
    void    UpdateStandardVerbs(ITFSNode * pToolbar, LONG_PTR dwNodeType);
    void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

	// This is the default verb, by default it is set to MMC_VERB_OPEN
	MMC_CONSOLE_VERB	m_verbDefault;

	BOOL		m_bSelected;
    BOOL        m_fSilent;
    BOOL        m_fExpandSync;
};

/*---------------------------------------------------------------------------
	Class:	CWinsQueryObj : general purpose base class
 ---------------------------------------------------------------------------*/
class CWinsQueryObj : public CNodeQueryObject
{
public:
	CWinsQueryObj
	(
		ITFSComponentData *	pTFSCompData, 
		ITFSNodeMgr *		pNodeMgr
	) 
	{
		m_spTFSCompData.Set(pTFSCompData); 
	    m_spNodeMgr.Set(pNodeMgr);
	}

	CQueueDataListBase & GetQueue() { return m_dataQueue; }

public:
	CString				 m_strServer;
	SPITFSComponentData  m_spTFSCompData;
	SPITFSNodeMgr		 m_spNodeMgr;
};

#endif _WINSHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winsmon.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	winsmon.h
		wins monitoring defines
		
    FILE HISTORY:
        
*/


#ifndef _WINSMON_H
#define _WINSMON_H

// wins monitoring stuff
#define		 STR_BUF_SIZE	255      

//
//  WINS related constants
//
#define NM_QRY_XID 0x6DFC

const u_short NBT_NAME_SERVICE_PORT  = htons(137);    // UDP
const int     NBT_NAME_SIZE          = 32;
const int     MAX_NBT_PACKET_SIZE    = 1500;

const WORD NBT_NM_OPC_REQUEST      = 0x0000;
const WORD NBT_NM_OPC_RESPONSE     = 0x0080;

const WORD NBT_NM_OPC_QUERY        = 0x0000;
const WORD NBT_NM_OPC_REGISTRATION = 0x0028;
const WORD NBT_NM_OPC_RELEASE      = 0x0030;
const WORD NBT_NM_OPC_WACK         = 0x0038;
const WORD NBT_NM_OPC_REFRESH      = 0x0040;

//
//  Name Service Flags
//
const WORD NBT_NM_FLG_BCAST        = 0x1000;
const WORD NBT_NM_FLG_RECURS_AVAIL = 0x8000;   
const WORD NBT_NM_FLG_RECURS_DESRD = 0x0001;
const WORD NBT_NM_FLG_TRUNCATED    = 0x0002;
const WORD NBT_NM_FLG_AUTHORITATIV = 0x0004;

//
//  Name Service question types
//
const WORD NBT_NM_QTYP_NB          = 0x2000;
const WORD NBT_NM_QTYP_NBSTAT      = 0x2100;

const WORD NBT_NM_QCLASS_IN        = 0x0100;


typedef struct {
	WORD  xid;
	WORD  flags;
	WORD  question_cnt;
	WORD  answer_cnt;
	WORD  name_serv_cnt;
	WORD  additional_cnt;
} NM_FRAME_HDR;


typedef struct {
	BYTE q_name[NBT_NAME_SIZE+2];
	WORD q_type;
	WORD q_class;
} NM_QUESTION_SECT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\addserv.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    edituser.h
        Edit user dialog implementation file

	FILE HISTORY:

*/

#include "stdafx.h"
#include "AddServ.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddServ dialog


CAddServ::CAddServ(CWnd* pParent /*=NULL*/)
	: CBaseDialog(CAddServ::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddServ)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CAddServ::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddServ)
	DDX_Control(pDX, IDC_ADD_EDIT_NAME, m_editComputerName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddServ, CBaseDialog)
	//{{AFX_MSG_MAP(CAddServ)
	ON_BN_CLICKED(IDC_BTN_BROWSE, OnButtonBrowse)
	ON_BN_CLICKED(IDC_ADD_LOCAL, OnRadioBtnClicked)
	ON_BN_CLICKED(IDC_ADD_OTHER, OnRadioBtnClicked)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddServ message handlers

BOOL CAddServ::OnInitDialog()
{
	CBaseDialog::OnInitDialog();

	CheckDlgButton(IDC_ADD_OTHER, BST_CHECKED);

	m_editComputerName.SetFocus();
	
	OnRadioBtnClicked();

	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CAddServ::OnButtonBrowse()
{
    CGetComputer getComputer;

	if (!getComputer.GetComputer(GetSafeHwnd()))
        return;

	CString strTemp = getComputer.m_strComputerName;

	m_editComputerName.SetWindowText(strTemp);
}


void CAddServ::OnRadioBtnClicked()
{
	BOOL fEnable = IsDlgButtonChecked(IDC_ADD_OTHER);

	m_editComputerName.EnableWindow(fEnable);
	GetDlgItem(IDC_BTN_BROWSE)->EnableWindow(fEnable);
}

void CAddServ::OnOK()
{
	DWORD dwLength;

	if (IsDlgButtonChecked(IDC_ADD_OTHER))
	{
		dwLength = m_editComputerName.GetWindowTextLength() + 1;
		if (dwLength <= 1)
		{
			AfxMessageBox(IDS_ERR_EMPTY_NAME);
			return;
		}

		m_editComputerName.GetWindowText(m_stComputerName.GetBuffer(dwLength), dwLength);
	}
	else
	{
		dwLength = MAX_COMPUTERNAME_LENGTH + 1;
        GetComputerName(m_stComputerName.GetBuffer(dwLength), &dwLength);
	}

	m_stComputerName.ReleaseBuffer();

	CBaseDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winssup.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winsup.cpp
		Global functions

	FILE HISTORY:


*/

#include "stdafx.h"
#include "winssup.h"
#include "tregkey.h"
#include "resource.h"
#include "wins.h"
#include <clusapi.h>
#include "..\tfscore\cluster.h"

const TCHAR g_szPipeName[] = _T("\\pipe\\WinsPipe");
const TCHAR g_szDefaultHelpTopic[] = _T("\\help\\winsconcepts.chm::/sag_WINStopnode.htm");

/*---------------------------------------------------------------------------
	SendTrigger()
		Sends a pull or push replication trigger to a given wins server
---------------------------------------------------------------------------*/
DWORD
SendTrigger
(
	handle_t hWins,
    LONG     ipTarget,
    BOOL     fPush,
    BOOL     fPropagate
)
{
    DWORD           dwStatus;
    WINSINTF_ADD_T  WinsAdd;
    
    WinsAdd.Len  = 4;
    WinsAdd.Type = 0;
    WinsAdd.IPAdd  = ipTarget;

	WINSINTF_TRIG_TYPE_E	TrigType;

    TrigType = fPush ? (fPropagate ? WINSINTF_E_PUSH_PROP : WINSINTF_E_PUSH) : WINSINTF_E_PULL;

#ifdef WINS_CLIENT_APIS
    dwStatus = ::WinsTrigger(hWins,
		                     &WinsAdd, 
                             TrigType);
#else
	dwStatus = ::WinsTrigger(&WinsAdd, 
		                     TrigType);
#endif WINS_CLIENT_APIS
    
    return dwStatus;
}


/*---------------------------------------------------------------------------
	ControlWINSService(LPCTSTR pszName, BOOL bStop)
		Stops ot starts the WINS service on the local machine
---------------------------------------------------------------------------*/
DWORD ControlWINSService(LPCTSTR pszName, BOOL bStop)
{
    DWORD           dwState = bStop ? SERVICE_STOPPED : SERVICE_RUNNING;
    DWORD           dwPending = bStop ? SERVICE_STOP_PENDING : SERVICE_START_PENDING;
    DWORD           err = ERROR_SUCCESS;
	int             i;
    SERVICE_STATUS  ss;
    DWORD           dwControl;
    BOOL            fSuccess;
	SC_HANDLE       hService = NULL;
    SC_HANDLE       hScManager = NULL;

	// oepmnt he service control manager
    hScManager = ::OpenSCManager(pszName, NULL, SC_MANAGER_ALL_ACCESS);
    if (hScManager == NULL)
    {
        err = ::GetLastError();
        Trace1("ControlWINSService - OpenScManager failed! %d\n", err);
        goto Error;
    }

	// get the handle to the WINS service
    hService = OpenService(hScManager, _T("WINS"), SERVICE_ALL_ACCESS);
    if (hService == NULL)
    {
        err = ::GetLastError();
        Trace1("ControlWINSService - OpenService failed! %d\n", err);
        goto Error;
    }

	// if stop requested
	if (bStop)
	{
		dwControl = SERVICE_CONTROL_STOP;
		fSuccess = ::ControlService(hService, dwControl, &ss);
	    if (!fSuccess)
	    {
	        err = ::GetLastError();
            Trace1("ControlWINSService - ControlService failed! %d\n", err);
            goto Error;
	    }
    }
	// otherwise start the service
	else
	{
		fSuccess = ::StartService(hService, 0, NULL);
	    if (!fSuccess)
	    {
	        err = ::GetLastError();
            Trace1("ControlWINSService - StartService failed! %d\n", err);
            goto Error;
	    }
	}

#define LOOP_TIME   5000
#define NUM_LOOPS   600

    // wait for the service to start/stop.  
    for (i = 0; i < NUM_LOOPS; i++)
    {
        ::QueryServiceStatus(hService, &ss);

        // check to see if we are done
        if (ss.dwCurrentState == dwState)
        {
            int time = LOOP_TIME * i;
            Trace1("ControlWINSService - service stopped/started in approx %d ms!\n", time);
            break;
        }
        
        // now see if something bad happened
        if (ss.dwCurrentState != dwPending)
        {
            int time = LOOP_TIME * i;
            Trace1("ControlWINSService - service stop/start failed in approx %d ms!\n", time);
            break;
        }

        Sleep(LOOP_TIME);
    }

    if (i == NUM_LOOPS)
        Trace0("ControlWINSService - service did NOT stop/start in wait period!\n");

    if (ss.dwCurrentState != dwState)
        err = ERROR_SERVICE_REQUEST_TIMEOUT;

Error:
    // close the respective handles
	if (hService)
        ::CloseServiceHandle(hService);

    if (hScManager)
        ::CloseServiceHandle(hScManager);

	return err;
}





/*---------------------------------------------------------------------------
	GetNameIP(	const CString &strDisplay, 
				CString &strName, 
				CString &strIP)
		Returns the Server name and the IP Address string with the 
		group name
 ---------------------------------------------------------------------------*/
void 
GetNameIP
(
  const CString &strDisplay, 
  CString &strName, 
  CString &strIP
)
{
	CString strTemp = strDisplay;

	// find '['
	int nPos = strDisplay.Find(_T("["));

	// left of the positioncontains the name and right of it has the IP address

	// 1 to take care of the space before '['
	strName = strDisplay.Left(nPos-1);

	strIP = strDisplay.Right(strDisplay.GetLength() - nPos);

	// take out '[' and ']' in strIP

	int npos1 = strIP.Find(_T("["));
	int npos2 = strIP.Find(_T("]"));

	strIP = strIP.Mid(npos1+1, npos2-npos1-1);

	return;
}


/*---------------------------------------------------------------------------
	WideToMBCS()
		converts WCS to MBCS string

        NOTE: the caller of this function must make sure that szOut is big
              enough to hold any possible string in strIn.
 ---------------------------------------------------------------------------*/
DWORD 
WideToMBCS(CString & strIn, LPSTR szOut, UINT uCodePage, DWORD dwFlags, BOOL * pfDefaultUsed)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fDefaultCharUsed = FALSE;

    int nNumBytes = ::WideCharToMultiByte(uCodePage,
					                        dwFlags,
					                        strIn, 
					                        -1,
					                        szOut,
                                            0,
					                        NULL,
					                        &fDefaultCharUsed);
 
    dwErr = ::WideCharToMultiByte(uCodePage,
                                 dwFlags,
                                 strIn,
                                 -1,
                                 szOut,
                                 nNumBytes,
                                 NULL,
                                 &fDefaultCharUsed);

    szOut[nNumBytes] = '\0';

    if (pfDefaultUsed)
       *pfDefaultUsed = fDefaultCharUsed;

    return dwErr;
}

/*---------------------------------------------------------------------------
	MBCSToWide ()
		converts MBCS to Wide string
 ---------------------------------------------------------------------------*/
DWORD 
MBCSToWide(LPSTR szIn, CString & strOut, UINT uCodePage, DWORD dwFlags)
{
    DWORD dwErr = ERROR_SUCCESS;

    LPTSTR pBuf = strOut.GetBuffer(MAX_PATH * 2);
    ZeroMemory(pBuf, MAX_PATH * 2);

    
    dwErr = ::MultiByteToWideChar(uCodePage, 
                                  dwFlags, 
                                  szIn, 
                                  -1, 
                                  pBuf, 
                                  MAX_PATH * 2);

    strOut.ReleaseBuffer();

    return dwErr;
}

LONG 
GetSystemMessageA
(
    UINT	nId,
    CHAR *	chBuffer,
    int		cbBuffSize 
)
{
    CHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  WINS server error messages.
    //

    if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibrary( _T("netmsg.dll") );
    }
    else
	if( nId >= 0x40000000L )
    {
        hdll = LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessageA( flags,
                      (LPVOID) hdll,
                      nId,
                      0,
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? ERROR_SUCCESS : ::GetLastError() ;
}

LONG 
GetSystemMessage 
(
    UINT	nId,
    TCHAR *	chBuffer,
    int		cbBuffSize 
)
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  WINS server error messages.
    //

    if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibrary( _T("netmsg.dll") );
    }
    else
	if( nId >= 0x40000000L )
    {
        hdll = LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessage( flags,
                      (LPVOID) hdll,
                      nId,
                      0,
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? ERROR_SUCCESS : ::GetLastError() ;
}


/*!--------------------------------------------------------------------------
	LoadMessage
		Loads the error message from the correct DLL.
	Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
LoadMessage 
(
    UINT	nIdPrompt,
    TCHAR *	chMsg,
    int		nMsgSize
)
{
    BOOL bOk;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_WINS_DOWN;
    }

    //
    //  If it's a socket error or our error, the text is in our resource fork.
    //  Otherwise, use FormatMessage() and the appropriate DLL.
    //
    if (    (nIdPrompt >= IDS_ERR_BASE && nIdPrompt < IDS_MSG_LAST)  )
    {
        //
        //  It's in our resource fork
        //
        bOk = ::LoadString( AfxGetInstanceHandle(), nIdPrompt, chMsg, nMsgSize / sizeof(TCHAR) ) != 0 ;
    }
    else
    {
        //
        //  It's in the system somewhere.
        //
        bOk = GetSystemMessage( nIdPrompt, chMsg, nMsgSize ) == 0 ;
    }

    if (bOk && nIdPrompt == ERROR_ACCESS_DENIED)
    {
        // tack on our extra help to explain different acess levels 
        CString strAccessDeniedHelp;

        strAccessDeniedHelp.LoadString(IDS_ACCESS_DENIED_HELP);

        lstrcat(chMsg, _T("\n\n"));
        lstrcat(chMsg, strAccessDeniedHelp);
    }

    //
    //  If the error message did not compute, replace it.
    //
    if ( ! bOk ) 
    {
        TCHAR chBuff [STRING_LENGTH_MAX] ;
        static const TCHAR * pszReplacement = _T("System Error: %ld");
        const TCHAR * pszMsg = pszReplacement ;

        //
        //  Try to load the generic (translatable) error message text
        //
        if ( ::LoadString( AfxGetInstanceHandle(), IDS_ERR_MESSAGE_GENERIC, 
            chBuff, STRING_LENGTH_MAX ) != 0 ) 
        {
            pszMsg = chBuff ;
        }
        ::wsprintf( chMsg, pszMsg, nIdPrompt ) ;
    }

    return bOk;
}


/*!--------------------------------------------------------------------------
	WinsMessageBox
		Puts up a message box with the corresponding error text.
	Author: EricDav
 ---------------------------------------------------------------------------*/
int WinsMessageBox(UINT nIdPrompt, 
 				   UINT nType , 
				   const TCHAR * pszSuffixString,
				   UINT nHelpContext)
{
	TCHAR chMesg [4000] ;
    BOOL bOk ;
    CThemeContextActivator themeActivator;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszSuffixString ) 
    {
        ::lstrcat( chMesg, _T("  ") ) ;
        ::lstrcat( chMesg, pszSuffixString ) ; 
    }

    return ::AfxMessageBox( chMesg, nType, nHelpContext ) ;
}

/*!--------------------------------------------------------------------------
	WinsMessageBoxEx
		Puts up a message box with the corresponding error text.
	Author: EricDav
 ---------------------------------------------------------------------------*/
int 
WinsMessageBoxEx
(
    UINT        nIdPrompt,
    LPCTSTR     pszPrefixMessage,
    UINT        nType,
    UINT        nHelpContext
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR       chMesg[4000];
    CString     strMessage;
    BOOL        bOk;
    CThemeContextActivator themeActivator;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(TCHAR));
    if ( pszPrefixMessage ) 
    {
        strMessage = pszPrefixMessage;
        strMessage += _T("\n");
        strMessage += _T("\n");
        strMessage += chMesg;
    }
    else
    {
        strMessage = chMesg;
    }

    return AfxMessageBox(strMessage, nType, nHelpContext);
}


// class NameTypeMapping handlers

/*!--------------------------------------------------------------------------
	MapDWORDToCString
		Generic mapping of a DWORD to a CString. 
		dwNameType is the 16th byte of the name.
		dwWinsType is Unique, multihomed, group, etc...
	Author: KennT
 ---------------------------------------------------------------------------*/
void MapDWORDToCString(DWORD dwNameType, DWORD dwWinsType, const CStringMapArray * pMap, CString & strName)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CStringMapEntry mapEntry;

	for (int i = 0; i < pMap->GetSize(); i++)
	{
        mapEntry = pMap->GetAt(i);

		// break out if this is the correct type and the wins type
		// matches or is a don't care
		if ( (mapEntry.dwNameType == dwNameType) &&
			 ( (mapEntry.dwWinsType == -1) ||
			   (mapEntry.dwWinsType == dwWinsType) ) )
		{
            break;
		}

        mapEntry.dwNameType = 0xFFFFFFFF;
	}
	
    if (mapEntry.dwNameType == 0xFFFFFFFF)
    {
        MapDWORDToCString(NAME_TYPE_OTHER, dwWinsType, pMap, strName);
    }
    else
    {
        if (mapEntry.st.IsEmpty())
		    Verify(pMap->GetAt(i).st.LoadString(mapEntry.ulStringId));

        strName = pMap->GetAt(i).st;
    }
}

// this structure allows us to map name types to strings.  The secondary
// check is based on the wins defined record type.  In order for this to work
// correctly, place any names that need to be defined with the wins type before
// the entry with the wins type set to -1.
static const UINT s_NameTypeMappingDefault[NUM_DEFAULT_NAME_TYPES][3] =
{
	{ NAME_TYPE_WORKSTATION,		WINSINTF_E_NORM_GROUP,	IDS_NAMETYPE_MAP_WORKGROUP },
	{ NAME_TYPE_WORKSTATION,		-1,						IDS_NAMETYPE_MAP_WORKSTATION },
	{ NAME_TYPE_DC,					-1,						IDS_NAMETYPE_MAP_DC },
	{ NAME_TYPE_FILE_SERVER,		WINSINTF_E_SPEC_GROUP,	IDS_NAMETYPE_MAP_SPECIAL_INTERNET_GROUP },
	{ NAME_TYPE_FILE_SERVER,		-1,						IDS_NAMETYPE_MAP_FILE_SERVER },
	{ NAME_TYPE_DMB	,				-1,						IDS_NAMETYPE_MAP_DMB },
	{ NAME_TYPE_OTHER,				-1,						IDS_NAMETYPE_MAP_OTHER },
	{ NAME_TYPE_NETDDE,				-1,						IDS_NAMETYPE_MAP_NETDDE },
	{ NAME_TYPE_MESSENGER,			-1,						IDS_NAMETYPE_MAP_MESSENGER },
	{ NAME_TYPE_RAS_SERVER,			-1,						IDS_NAMETYPE_MAP_RAS_SERVER },
	{ NAME_TYPE_NORM_GRP_NAME,		-1,						IDS_NAMETYPE_MAP_NORMAL_GROUP_NAME },
	{ NAME_TYPE_WORK_NW_MON_AGENT,	-1,						IDS_NAMETYPE_MAP_NW_MON_AGENT },
	{ NAME_TYPE_WORK_NW_MON_NAME,	-1,						IDS_NAMETYPE_MAP_NMN},
};

const NameTypeMapping::REGKEYNAME NameTypeMapping::c_szNameTypeMapKey = _T("SYSTEM\\CurrentControlSet\\Services\\wins\\NameTypeMap");
const NameTypeMapping::REGKEYNAME NameTypeMapping::c_szDefault= _T("(Default)");

NameTypeMapping ::NameTypeMapping()
{
}

NameTypeMapping ::~NameTypeMapping()
{
	Unload();
}

void
NameTypeMapping ::SetMachineName(LPCTSTR pszMachineName)
{
    m_strMachineName = pszMachineName;
}

HRESULT NameTypeMapping::Load()
{
	HRESULT		hr = hrOK;
	RegKey		regkey;
	RegKey		regkeyMachine;
	HKEY		hkeyMachine = HKEY_LOCAL_MACHINE;
	RegKey::CREGKEY_KEY_INFO	regkeyInfo;
	RegKeyIterator	regkeyIter;
	UINT		i;
	WORD		langID;
	RegKey		regkeyProto;
	DWORD		dwErr;
    CStringMapEntry mapEntry;

	::ZeroMemory(&regkeyInfo, sizeof(regkeyInfo));
	
	// Look for the registry key
	if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkey.Open(hkeyMachine, c_szNameTypeMapKey, KEY_READ, m_strMachineName) ;
		hr = HRESULT_FROM_WIN32( dwErr );
    }

    // Get the count of items
	if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkey.QueryKeyInfo(&regkeyInfo) ;
		hr = HRESULT_FROM_WIN32( dwErr );
    }
	
	// Alloc the array for the count of items + default items
	Unload();

	// Read in the registry data and add it to the internal array

    //
	// enumerate the keys
	//
	if (FHrSucceeded(hr))
		hr = regkeyIter.Init(&regkey);
		
	if (FHrSucceeded(hr))
	{
		HRESULT	hrIter;
		DWORD	dwProtoId;
		CString	stKey;
		CString	stLang;
		
		// Now that we have this key, look for the language id
		langID = GetUserDefaultLangID();
		stLang.Format(_T("%04x"), (DWORD)langID);
							
		for (hrIter = regkeyIter.Next(&stKey, NULL); hrIter == hrOK; hrIter = regkeyIter.Next(&stKey, NULL))
		{
			CString	st;
			
			// Given the name of the key, that is a hex value (the protocol id)
			// Convert that into a DWORD
			dwProtoId = _tcstoul((LPCTSTR) stKey, NULL, 16);

			// Open this key
			regkeyProto.Close();
			dwErr = regkeyProto.Open(regkey, stKey);
			if (!FHrSucceeded(HRESULT_FROM_WIN32(dwErr)))
				continue;

			// Ok, get the name value
			dwErr = regkeyProto.QueryValue(stLang, st);
			if (!FHrSucceeded(HRESULT_FROM_WIN32(dwErr)))
			{
				// Look for the key with the name of default
				dwErr = regkeyProto.QueryValue(c_szDefault, st);
			}

			if (FHrSucceeded(HRESULT_FROM_WIN32(dwErr)))
			{
				// Ok, add this value to the list
				mapEntry.dwNameType = dwProtoId;
				mapEntry.st = st;
				mapEntry.ulStringId = 0;

                Add(mapEntry);
			}
		}
	}

	// Read in the default item data and add it to the array
	for (i = 0; i < DimensionOf(s_NameTypeMappingDefault); i++)
	{
        mapEntry.dwNameType = s_NameTypeMappingDefault[i][0];
        mapEntry.dwWinsType = s_NameTypeMappingDefault[i][1];
		mapEntry.st.LoadString(s_NameTypeMappingDefault[i][2]);
		mapEntry.ulStringId = 0;

        Add(mapEntry);
	}
	
	return hrOK;
}

void NameTypeMapping::Unload()
{
    RemoveAll();   
}

void NameTypeMapping::TypeToCString(DWORD dwProtocolId, DWORD dwRecordType, CString & strName)
{
	MapDWORDToCString(dwProtocolId, dwRecordType, this, strName);
}

// add in the new id/name
HRESULT NameTypeMapping::AddEntry(DWORD dwProtocolId, LPCTSTR pstrName)
{
    HRESULT     hr = hrOK;
	RegKey		regkey;
    RegKey      regkeyID;
    HKEY		hkeyMachine = HKEY_LOCAL_MACHINE;
	WORD		langID;
    CStringMapEntry mapEntry;
    CString     stID, stLang, stNew;

	// Look for the registry key
	if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkey.Create(hkeyMachine, c_szNameTypeMapKey, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strMachineName) ;
		hr = HRESULT_FROM_WIN32( dwErr );
    }

	// build our new ID string
	stID.Format(_T("%04x"), (DWORD) dwProtocolId);

	// Now that we have this key, look for the language id
	langID = GetUserDefaultLangID();
	stLang.Format(_T("%04x"), (DWORD)langID);

    stNew = c_szNameTypeMapKey + _T("\\") + stID;

    // create the ID key
	if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkeyID.Create(hkeyMachine, stNew, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,NULL, m_strMachineName) ;
		hr = HRESULT_FROM_WIN32( dwErr );
    }

	// set the name value
    if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkeyID.SetValue(stLang, pstrName) ;
        hr = HRESULT_FROM_WIN32( dwErr );
    }

	if (FHrSucceeded(hr))
    {
        // add to internal list
		mapEntry.dwNameType = dwProtocolId;
		mapEntry.st = pstrName;
		mapEntry.ulStringId = 0;

        Add(mapEntry);
    }

    return hr;
}

// modify the given ID's string name
HRESULT NameTypeMapping::ModifyEntry(DWORD dwProtocolId, LPCTSTR pstrName)
{
    HRESULT     hr = hrOK;
	RegKey		regkey;
    RegKey      regkeyID;
    HKEY		hkeyMachine = HKEY_LOCAL_MACHINE;
	int 		i;
	WORD		langID;
    CString     stID, stLang, stNew;

	// Look for the registry key
	if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkey.Open(hkeyMachine, c_szNameTypeMapKey, KEY_READ, m_strMachineName) ;
		hr = HRESULT_FROM_WIN32( dwErr );
    }

	// build our new ID string
	stID.Format(_T("%04x"), (DWORD) dwProtocolId);

    stNew = c_szNameTypeMapKey + _T("\\") + stID;

    // open the correct ID key
	if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkeyID.Open(hkeyMachine, stNew, KEY_ALL_ACCESS, m_strMachineName) ;
		hr = HRESULT_FROM_WIN32( dwErr );
    }

	// Now that we have this key, look for the language id
	langID = GetUserDefaultLangID();
	stLang.Format(_T("%04x"), (DWORD)langID);

    // set the new value
    if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkeyID.SetValue(stLang, pstrName) ;
        hr = HRESULT_FROM_WIN32( dwErr );
    }

	if (FHrSucceeded(hr))
    {
        // modify the internal list
		for (i = 0; i < GetSize(); i++)
        {
            if (GetAt(i).dwNameType == dwProtocolId)
            {
                m_pData[i].st = pstrName;
                break;
            }
        }
    }

    return hr;
}

// remove the given ID's string name
HRESULT NameTypeMapping::RemoveEntry(DWORD dwProtocolId)
{
    HRESULT     hr = hrOK;
	RegKey		regkey;
    HKEY		hkeyMachine = HKEY_LOCAL_MACHINE;
	int 		i;
    CString     stID;

	// Look for the registry key
	if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkey.Open(hkeyMachine, c_szNameTypeMapKey, KEY_READ, m_strMachineName) ;
		hr = HRESULT_FROM_WIN32( dwErr );
    }

	// build our new ID string
	stID.Format(_T("%04x"), (DWORD) dwProtocolId);

    // set the new value
    if (FHrSucceeded(hr))
    {
        DWORD dwErr = regkey.RecurseDeleteKey(stID) ;
        hr = HRESULT_FROM_WIN32( dwErr );
    }

	if (FHrSucceeded(hr))
    {
        // modify the internal list
		for (i = 0; i < GetSize(); i++)
        {
            if (GetAt(i).dwNameType == dwProtocolId)
            {
                RemoveAt(i);
                break;
            }
        }
    }

    return hr;
}


BOOL        
NameTypeMapping::EntryExists(DWORD dwProtocolId)
{
    BOOL fExists = FALSE;

    for (int i = 0; i < GetSize(); i++)
    {
        if (GetAt(i).dwNameType == dwProtocolId)
        {
            fExists = TRUE;
            break;
        }
    }

    return fExists;
}

/*---------------------------------------------------------------------------
		CleanString(CString& str)
		Strip leading and trailing spaces from the string.
---------------------------------------------------------------------------*/
CString&
CleanString(
    CString& str
    )
{
    if (str.IsEmpty())
    {
        return str ;
    }
    int n = 0;
    while ((n < str.GetLength()) && (str[n] == ' '))
    {
        ++n;
    }

    if (n)
    {
        str = str.Mid(n);
    }
    n = str.GetLength();
    while (n && (str[--n] == ' '))
    {
        str.ReleaseBuffer(n);
    }

    return str;
}

/*---------------------------------------------------------------------------
	IsValidNetBIOSName
		Determine if the given netbios is valid, and pre-pend
		a double backslash if not already present (and the address
		is otherwise valid).	
---------------------------------------------------------------------------*/
BOOL
IsValidNetBIOSName(
    CString & strAddress,
    BOOL fLanmanCompatible,
    BOOL fWackwack // expand slashes if not present
    )
{
    TCHAR szWacks[] = _T("\\\\");

    if (strAddress.IsEmpty())
    {
        return FALSE;
    }

    if (strAddress[0] == _T('\\'))
    {
        if (strAddress.GetLength() < 3)
        {
            return FALSE;
        }

        if (strAddress[1] != _T('\\'))
        {
            // One slash only?  Not valid
            return FALSE;
        }
    }
    else
    {
        if (fWackwack)
        {
            // Add the backslashes
            strAddress = szWacks + strAddress;
        }
    }

    int nMaxAllowedLength = fLanmanCompatible
        ? LM_NAME_MAX_LENGTH
        : NB_NAME_MAX_LENGTH;

    if (fLanmanCompatible)
    {
        strAddress.MakeUpper();
    }

    return strAddress.GetLength() <= nMaxAllowedLength + 2;
}

/*---------------------------------------------------------------------------
	IsValidDomain
 
       Determine if the given domain name address is valid, and clean
       it up, if necessary
---------------------------------------------------------------------------*/
BOOL
IsValidDomain(CString & strDomain)
{
/*    int nLen;

    if ((nLen = strDomain.GetLength()) != 0)
    {
        if (nLen < DOMAINNAME_LENGTH)  // 255
        {
            int i;
            int istr = 0;
            TCHAR ch;
            BOOL fLet_Dig = FALSE;
            BOOL fDot = FALSE;
            int cHostname = 0;

            for (i = 0; i < nLen; i++)
            {
                // check each character
                ch = strDomain[i];

                BOOL fAlNum = iswalpha(ch) || iswdigit(ch);

                if (((i == 0) && !fAlNum) ||
                        // first letter must be a digit or a letter
                    (fDot && !fAlNum) ||
                        // first letter after dot must be a digit or a letter
                    ((i == (nLen - 1)) && !fAlNum) ||
                        // last letter must be a letter or a digit
                    (!fAlNum && ( ch != _T('-') && ( ch != _T('.') && ( ch != _T('_'))))) ||
                        // must be letter, digit, - or "."
                    (( ch == _T('.')) && ( !fLet_Dig )))
                        // must be letter or digit before '.'
                {
                    return FALSE;
                }
                fLet_Dig = fAlNum;
                fDot = (ch == _T('.'));
                cHostname++;
                if ( cHostname > HOSTNAME_LENGTH )
                {
                    return FALSE;
                }
                if ( fDot )
                {
                    cHostname = 0;
                }
            }
        }
    } 
*/
    return TRUE;
}

/*---------------------------------------------------------------------------
	IsValidIpAddress
 
		Determine if the given IP address is valid, and clean
		it up, if necessary
 ---------------------------------------------------------------------------*/
BOOL
IsValidIpAddress(CString & strAddress)
{
    if (strAddress.IsEmpty())
    {
        return FALSE;
    }

    CIpAddress ia(strAddress);
    BOOL fValid = ia.IsValid();
    if (fValid)
    {
        // Fill out the IP address string for clarity
        strAddress = ia;
        return TRUE;
    }

    return FALSE;
}


/*---------------------------------------------------------------------------
	IsValidAddress
		Determine if the given address is a valid NetBIOS or
		TCP/IP address, judging by the name only.  Note that
		validation may clean up the given string
		NetBIOS names not beginning with "\\" will have those characters
		pre-pended, and otherwise valid IP Addresses are filled out to
		4 octets.
        Leading and trailing spaces are removed from the string.
  --------------------------------------------------------------------------*/
BOOL
IsValidAddress(
				CString& strAddress,
				BOOL * fIpAddress,
				BOOL fLanmanCompatible,
				BOOL fWackwack          // expand netbios slashes
			  )
{
    int i;

    // Remove leading and trailing spaces
    CleanString(strAddress);

    if (strAddress.IsEmpty()) {
        *fIpAddress = FALSE;
        return FALSE;
    }
    
	if (strAddress[0] == _T('\\')) {
        *fIpAddress = FALSE;
        return IsValidNetBIOSName(strAddress, fLanmanCompatible, fWackwack);
    }

    if (IsValidIpAddress(strAddress)) 
	{
        *fIpAddress = TRUE;
        return TRUE;
    } 
	else 
	{
        *fIpAddress = FALSE;
    }
    if (IsValidDomain (strAddress)) {
        return TRUE;
    }

    // last chance, maybe its a NetBIOS name w/o wackwack
    return IsValidNetBIOSName(strAddress, fLanmanCompatible, fWackwack);
}

/*---------------------------------------------------------------------------
	VerifyWinsServer(CString& strServer,CString& strIP)
		Called if the server is not coonected yet, gets the name and 
		IP address od the server
	Author:v-shubk
---------------------------------------------------------------------------*/
/*
DWORD 
VerifyWinsServer(CString &strAddress, CString &strServerName, DWORD & dwIP)
{
	CString strNameIP = strAddress;
	BOOL fIp;
	DWORD err = ERROR_SUCCESS;

	if (IsValidAddress(strNameIP, &fIp, TRUE, TRUE))
	{
		CWinsServerObj ws(NULL,"", TRUE, TRUE);

		if (fIp) 
        {
    		// IP address specified
		    ws = CWinsServerObj(CIpAddress(strNameIP), "", TRUE, TRUE);
        }
        else 
		{
    		// machine name specified
			ws = CWinsServerObj(CIpAddress(), strNameIP, TRUE, TRUE);
        }

		WINSINTF_BIND_DATA_T    wbdBindData;
		handle_t                hBinding = NULL;
		WINSINTF_ADD_T          waWinsAddress;
        char                    szNetBIOSName[256] = {0};

		do
		{
			// First attempt to bind to the new address
			wbdBindData.fTcpIp = ws.GetNetBIOSName().IsEmpty();
			CString strTempAddress;

			if (wbdBindData.fTcpIp)
			{
				strTempAddress = ((CString)ws.GetIpAddress());
			}
			else
			{
				//strTempAddress = _T("\\\\") + ws.GetNetBIOSName();

                CString tmp;

                tmp = ws.GetNetBIOSName();

                if  ( (tmp[0] == _T('\\')) && (tmp[1] == _T('\\')) )
                    strTempAddress = ws.GetNetBIOSName();
                else
                    strTempAddress = _T("\\\\") + ws.GetNetBIOSName(); 
			}

            wbdBindData.pPipeName = wbdBindData.fTcpIp ? NULL : (LPSTR) g_szPipeName;
			wbdBindData.pServerAdd = (LPSTR) (LPCTSTR) strTempAddress;

			if ((hBinding = ::WinsBind(&wbdBindData)) == NULL)
			{
				err = ::GetLastError();
				break;
			}

#ifdef WINS_CLIENT_APIS
			err = ::WinsGetNameAndAdd(hBinding, 
				                      &waWinsAddress,
				                      (LPBYTE) szNetBIOSName);
#else
			err = ::WinsGetNameAndAdd(&waWinsAddress,
				                      (LPBYTE) szNetBIOSName);
#endif WINS_CLIENT_APIS

		}
		while (FALSE);

		if (err == ERROR_SUCCESS)
		{
			// Always use the IP address used for connection
            // if we went over tcpip (not the address returned
            // by the WINS service.
            if (wbdBindData.fTcpIp)
            {
                CIpNamePair ip(ws.GetIpAddress(), szNetBIOSName);
                ws = ip;
			}
            else
            {
                CIpNamePair ip(waWinsAddress.IPAdd, szNetBIOSName);
                ws = ip;
			}

            // convert the dbcs netbios name to wide char
            WCHAR szTempIP[20] = {0};

			int nNumBytes = MultiByteToWideChar(CP_ACP, 
												0, 
												szNetBIOSName,
												-1,
												szTempIP, 
												20); 
            // now fill in the name for return
            strServerName = szTempIP;

            // fill in the IP
            dwIP = (LONG) ws.QueryIpAddress();
        }

		if (hBinding)
		{
			// call winsunbind here, No more WINS apis called atfer this
			WinsUnbind(&wbdBindData, hBinding);
			hBinding = NULL;
		}
	}
	
    return err;
}
*/

/*---------------------------------------------------------------------------
	VerifyWinsServer(CString& strServer,CString& strIP)
		Called if the server is not coonected yet, gets the name and 
		IP address od the server
	Author: ericdav
---------------------------------------------------------------------------*/
DWORD 
VerifyWinsServer(CString &strAddress, CString &strServerName, DWORD & dwIP)
{
	CString strNameIP = strAddress;
	BOOL fIp;
	DWORD err = ERROR_SUCCESS;

	if (IsValidAddress(strNameIP, &fIp, TRUE, TRUE))
	{
		CWinsServerObj ws(NULL, "", TRUE, TRUE);

		if (fIp) 
        {
            BOOL bIsCluster = ::FIsComputerInRunningCluster(strNameIP);

    		// IP address specified
		    ws = CWinsServerObj(CIpAddress(strNameIP), "", TRUE, TRUE);

            // if the ip address given to us is a cluster address..
            if (bIsCluster)
            {
                err = GetClusterInfo(
                        strNameIP,
                        strServerName,
                        &dwIP);
                if (err == ERROR_SUCCESS)
                {
                    DWORD dwCheckIP;

                    err = GetHostAddress(strServerName, &dwCheckIP);
                    if (dwCheckIP != dwIP)
                    {
                        bIsCluster = FALSE;
                    }
                }
            }

            // this is not a cluster address
            if (!bIsCluster)
            {
                err = GetHostName((LONG) ws.GetIpAddress(), strServerName);
                if (err == ERROR_SUCCESS)
                {
                    if (strServerName.IsEmpty())
                    {
                        err = DNS_ERROR_NAME_DOES_NOT_EXIST;
                    }
                    else
                    {
                        // just want the host name
                        int nDot = strServerName.Find('.');
                        if (nDot != -1)
                        {
                            strServerName = strServerName.Left(nDot);
                        }
                    }

                    dwIP = (LONG) ws.GetIpAddress();
                }
            }
        }
        else 
		{
    		// machine name specified
			ws = CWinsServerObj(CIpAddress(), strNameIP, TRUE, TRUE);

            err = GetHostAddress(strNameIP, &dwIP);
            if (err == ERROR_SUCCESS)
            {
                // just want the host name
                int nDot = strNameIP.Find('.');
                if (nDot != -1)
                {
                    strServerName = strNameIP.Left(nDot);
                }
                else
                {
                    strServerName = strNameIP;
                }
            }
        }
    }

    return err;
}

void MakeIPAddress(DWORD dwIP, CString & strIP)
{
	CString strTemp;
	
    DWORD   dwFirst = GETIP_FIRST(dwIP);
	DWORD   dwSecond = GETIP_SECOND(dwIP);
	DWORD   dwThird = GETIP_THIRD(dwIP);
	DWORD   dwLast = GETIP_FOURTH(dwIP);

    strIP.Empty();

	// wrap it into CString object
    TCHAR szStr[20] = {0};

	_itot(dwFirst, szStr, 10);
    strTemp = szStr;
    strTemp += _T(".");

	_itot(dwSecond, szStr, 10);
	strTemp += szStr;
    strTemp += _T(".");

	_itot(dwThird, szStr, 10);
	strTemp += szStr;
    strTemp += _T(".");

	_itot(dwLast, szStr, 10);
	strTemp += szStr;
    
    strIP = strTemp;
}

DWORD
GetHostName
(
    DWORD       dwIpAddr,
    CString &   strHostName
)
{
    CString strName;

    //
    //  Call the Winsock API to get host name information.
    //
    strHostName.Empty();

    u_long ulAddrInNetOrder = ::htonl( (u_long) dwIpAddr ) ;

    HOSTENT * pHostInfo = ::gethostbyaddr( (CHAR *) & ulAddrInNetOrder,
										   sizeof ulAddrInNetOrder,
										   PF_INET ) ;
    if ( pHostInfo == NULL )
    {
        return ::WSAGetLastError();
	}

    // copy the name
    MBCSToWide(pHostInfo->h_name, strName);

    strName.MakeUpper();

    int nDot = strName.Find(_T("."));

    if (nDot != -1)
        strHostName = strName.Left(nDot);
    else
        strHostName = strName;

    return NOERROR;
}

/*---------------------------------------------------------------------------
	GetHostAddress
		Description
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD 
GetHostAddress 
(
    LPCTSTR		pszHostName,
    DWORD  *	pdwIp
)
{
    DWORD err = ERROR_SUCCESS;
    CHAR szString [ 2 * (MAX_PATH + 1)] = {0}; // large enough for a MAX_PATH MBCS encoding

    CString strTemp(pszHostName);
    WideToMBCS(strTemp, szString);

    HOSTENT * pHostent = ::gethostbyname( szString ) ;

    if ( pHostent )
    {
        *pdwIp = ::ntohl( *((u_long *) pHostent->h_addr_list[0]) ) ;
    }
    else
    {
        err = ::WSAGetLastError() ;
	}

    return err ;
}

//
// This function makes the appropriate call to either WinsStatus or WinsStatusNew
//
CWinsResults::CWinsResults()
{
    NoOfOwners = 0;
    AddVersMaps.RemoveAll();
    MyMaxVersNo.QuadPart = 0;
    RefreshInterval = 0;
    TombstoneInterval = 0;
    TombstoneTimeout = 0;
    VerifyInterval = 0;
    WinsPriorityClass = 0;
    NoOfWorkerThds = 0;
    memset(&WinsStat, 0, sizeof(WinsStat));
}

CWinsResults::CWinsResults(WINSINTF_RESULTS_T * pwrResults)
{
    Set(pwrResults);
}

CWinsResults::CWinsResults(WINSINTF_RESULTS_NEW_T * pwrResults)
{
    Set(pwrResults);
}

DWORD
CWinsResults::Update(handle_t hBinding)
{
    DWORD err;

    //
    // First try the new API which does not
    // not have the 25 partner limitation.  If
    // this fails with RPC_S_PROCNUM_OUT_OF_RANGE,
    // we know the server is a down-level server,
    // and we need to call the old method.
    //
    err = GetNewConfig(hBinding);

	if (err == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        //
        // Try old API
        //
        err = GetConfig(hBinding);
    }

    return err;
}
    
DWORD 
CWinsResults::GetNewConfig(handle_t hBinding)
{
    WINSINTF_RESULTS_NEW_T wrResults;

	wrResults.WinsStat.NoOfPnrs = 0;
    wrResults.WinsStat.pRplPnrs = NULL;
    wrResults.NoOfWorkerThds = 1;
    wrResults.pAddVersMaps = NULL;

#ifdef WINS_CLIENT_APIS
    DWORD dwStatus = ::WinsStatusNew(hBinding, WINSINTF_E_CONFIG_ALL_MAPS, &wrResults);
#else
    DWORD dwStatus = ::WinsStatusNew(WINSINTF_E_CONFIG_ALL_MAPS, &wrResults);
#endif WINS_CLIENT_APIS

    if (dwStatus == ERROR_SUCCESS)
    {
        Set(&wrResults);
    }
    else
    {
        Clear();
    }

	return dwStatus;
}

DWORD 
CWinsResults::GetConfig(handle_t hBinding)
{
    WINSINTF_RESULTS_T wrResults;

	wrResults.WinsStat.NoOfPnrs = 0;
    wrResults.WinsStat.pRplPnrs = NULL;
    wrResults.NoOfWorkerThds = 1;

#ifdef WINS_CLIENT_APIS
    DWORD dwStatus = ::WinsStatus(hBinding, WINSINTF_E_CONFIG_ALL_MAPS, &wrResults);
#else
	DWORD dwStatus = ::WinsStatus(WINSINTF_E_CONFIG_ALL_MAPS, &wrResults);
#endif WINS_CLIENT_APIS

    if (dwStatus == ERROR_SUCCESS)
    {
        Set(&wrResults);
    }
    else
    {
        Clear();
    }

	return dwStatus;
}

void 
CWinsResults::Clear()
{
    AddVersMaps.RemoveAll();

    NoOfOwners = 0;
    MyMaxVersNo.QuadPart = 0;
    RefreshInterval = 0;
    TombstoneInterval = 0;
    TombstoneTimeout = 0;
    VerifyInterval = 0;
    WinsPriorityClass = 0;
    NoOfWorkerThds = 0;
    memset(&WinsStat, 0, sizeof(WinsStat));
}

void
CWinsResults::Set(WINSINTF_RESULTS_NEW_T * pwrResults)
{
    if (pwrResults)
    {
        NoOfOwners = pwrResults->NoOfOwners;
    
        AddVersMaps.RemoveAll();
    
        for (UINT i = 0; i < NoOfOwners; i++)
        {
            AddVersMaps.Add(pwrResults->pAddVersMaps[i]);
        }

        MyMaxVersNo.QuadPart = pwrResults->MyMaxVersNo.QuadPart;
    
        RefreshInterval = pwrResults->RefreshInterval;
        TombstoneInterval = pwrResults->TombstoneInterval;
        TombstoneTimeout = pwrResults->TombstoneTimeout;
        VerifyInterval = pwrResults->VerifyInterval;
        WinsPriorityClass = pwrResults->WinsPriorityClass;
        NoOfWorkerThds = pwrResults->NoOfWorkerThds;
        WinsStat = pwrResults->WinsStat;
    }
}

void
CWinsResults::Set(WINSINTF_RESULTS_T * pwrResults)
{
    if (pwrResults == NULL)
    {
        Clear();
    }
    else
    {
        NoOfOwners = pwrResults->NoOfOwners;
    
        AddVersMaps.RemoveAll();

        for (UINT i = 0; i < NoOfOwners; i++)
        {
            AddVersMaps.Add(pwrResults->AddVersMaps[i]);
        }

        MyMaxVersNo.QuadPart = pwrResults->MyMaxVersNo.QuadPart;
    
        RefreshInterval = pwrResults->RefreshInterval;
        TombstoneInterval = pwrResults->TombstoneInterval;
        TombstoneTimeout = pwrResults->TombstoneTimeout;
        VerifyInterval = pwrResults->VerifyInterval;
        WinsPriorityClass = pwrResults->WinsPriorityClass;
        NoOfWorkerThds = pwrResults->NoOfWorkerThds;
        WinsStat = pwrResults->WinsStat;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winssnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winssnap.cpp
		WINS snapin entry points/registration functions
		
		Note: Proxy/Stub Information
			To build a separate proxy/stub DLL, 
			run nmake -f Snapinps.mak in the project directory.

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include "initguid.h"
#include "winscomp.h"
#include "winssnap.h"
#include "ncglobal.h"   // network console global defines
#include "cmptrmgr.h"   // computer management snapin node types
#include "locale.h"     // for setlocale

#include <lmerr.h> // for NERR stuff

#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_WinsSnapin, CWinsComponentDataPrimary)
	OBJECT_ENTRY(CLSID_WinsSnapinExtension, CWinsComponentDataExtension)
	OBJECT_ENTRY(CLSID_WinsSnapinAbout, CWinsAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CWinsSnapinApp theApp;

BOOL CWinsSnapinApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);

    SHFusionInitializeFromModuleID (m_hInstance, 2);

    //
    //  Initialize the CWndIpAddress control window class IPADDRESS
    //
    CWndIpAddress::CreateWindowClass( m_hInstance ) ;

    // set the default locale to the system locale
    setlocale(LC_ALL, "");

	//
    //  Initialize use of the WinSock routines
    //
    WSADATA wsaData ;
    
    if ( ::WSAStartup( MAKEWORD( 1, 1 ), & wsaData ) != 0 )
    {
        m_bWinsockInited = TRUE;
		Trace0("InitInstance: Winsock initialized!\n");
    }
	else
	{
		m_bWinsockInited = FALSE;
	}

	::IPAddrInit(m_hInstance);

	return CWinApp::InitInstance();
}

int CWinsSnapinApp::ExitInstance()
{
	SHFusionUninitialize();

    _Module.Term();

	DEBUG_VERIFY_INSTANCE_COUNTS;

	//
    // Terminate use of the WinSock routines.
    //
    if ( m_bWinsockInited )
    {
        WSACleanup() ;
    }

	return CWinApp::ExitInstance();
}

/***
 *
 *  CWinsadmnApp::GetSystemMessage
 *
 *  Purpose:
 *
 *      Given a message ID, determine where the message resides,
 *      and load it into the buffer.
 *
 *  Arguments:
 *
 *      UINT    nId         Message ID number
 *      char *  chBuffer    Character buffer to load into.
 *      int     cbBuffSize  Size of buffer in characters
 *
 *  Returns:
 *
 *      API error return code, or ERROR_SUCCESS
 *
 */
DWORD
CWinsSnapinApp::GetSystemMessage(
    UINT nId,
    TCHAR * chBuffer,
    int cbBuffSize
    )
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
                | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges.
    //
    if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = ::LoadLibrary( _T("netmsg.dll") );
    }
    else if( nId >= 0x40000000L )
    {
        hdll = ::LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    DWORD dwResult = ::FormatMessage( flags,
                                      (LPVOID) hdll,
                                      nId,
                                      0,
                                      chBuffer,
                                      cbBuffSize,
                                      NULL );

    if( hdll != NULL )
    {
        LONG err = ::GetLastError();
        ::FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? ERROR_SUCCESS : ::GetLastError();
}

/***
 *
 *  CWinsadmnApp::MessageBox
 *
 *  Purpose:
 *
 *      Replacement for AfxMessageBox().  This function will call up the
 *      appropriate message from wherever before displaying it
 *
 *  Arguments:
 *
 *      UINT    nIdPrompt    Message ID
 *      UINT    nType        AfxMessageBox type (YESNO, OKCANCEL, etc)
 *      UINT    nHelpContext Help context ID for AfxMessageBox();
 *
 *  Notes:
 *
 *      If an error occurs, a standard message (hard-coded in english) will
 *      be shown that gives the error number.
 *
 */
int
CWinsSnapinApp::MessageBox (
    UINT nIdPrompt,
    UINT nType,
    UINT nHelpContext
    )
{
    CThemeContextActivator themeActivator;
    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_WINS_DOWN;
    }

    //
    //  If it's our error, the text is in our resource segment.
    //  Otherwise, use FormatMessage() and the appropriate DLL>
    //
    if ((nIdPrompt >= IDS_ERR_INVALID_IP) && (nIdPrompt <= IDS_MSG_LAST))
    {
         return ::AfxMessageBox(nIdPrompt, nType, nHelpContext);
    }

    TCHAR szMesg [1024] ;
    int nResult;

    if ((nResult = GetSystemMessage(nIdPrompt, szMesg, sizeof(szMesg)/sizeof(TCHAR)))
            == ERROR_SUCCESS)
    {
        return ::AfxMessageBox(szMesg, nType, nHelpContext);
    }

    Trace1("Message number %d not found",  nIdPrompt);
    ASSERT(0 && "Error Message ID not handled");
    
    //
    //  Do something for the retail version
    //
    ::wsprintf ( szMesg, _T("Error: %lu"), nIdPrompt);
    ::AfxMessageBox(szMesg, nType, nHelpContext);

    return nResult;
}

int
CWinsSnapinApp::MessageBox (
    LPCTSTR pPrefixText,
    UINT nIdPrompt,
    UINT nType,
    UINT nHelpContext
    )
{
    CThemeContextActivator themeActivator;

    CString strText = pPrefixText;
    CString strAppend;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
    if (nIdPrompt == EPT_S_NOT_REGISTERED ||
        nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
    {
        nIdPrompt = IDS_ERR_WINS_DOWN;
    }

    //
    //  If it's our error, the text is in our resource segment.
    //  Otherwise, use FormatMessage() and the appropriate DLL>
    //
    if ((nIdPrompt >= IDS_ERR_BASE) && (nIdPrompt <= IDS_MSG_LAST))
    {
        strAppend.LoadString(nIdPrompt);
        strText += strAppend;
        
        return ::AfxMessageBox(strText, nType, nHelpContext);
    }

    TCHAR szMesg [1024] ;
    int nResult;

    if ((nResult = GetSystemMessage(nIdPrompt, szMesg, sizeof(szMesg)/sizeof(TCHAR)))
            == ERROR_SUCCESS)
    {
        strText += szMesg;
        return ::AfxMessageBox(strText, nType, nHelpContext);
    }

    Trace1("Message number %d not found",  nIdPrompt);
    ASSERT(0 && "Error Message ID not handled");
    
    //
    //  Do something for the retail version
    //
    ::wsprintf ( szMesg, _T("Error: %lu"), nIdPrompt);
    strText += szMesg;
    ::AfxMessageBox(strText, nType, nHelpContext);

    return nResult;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
	// registers object, typelib and all interfaces in typelib
	//
	HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

    CString strDesc, strExtDesc, strRootDesc, strVersion;

    strDesc.LoadString(IDS_SNAPIN_DESC);
    strExtDesc.LoadString(IDS_SNAPIN_EXTENSION_DESC);
    strRootDesc.LoadString(IDS_ROOT_DESC);
    strVersion.LoadString(IDS_ABOUT_VERSION);
    
    //
	// register the snapin into the console snapin list
	//
	hr = RegisterSnapinGUID(&CLSID_WinsSnapin, 
						&GUID_WinsRootNodeType, 
						&CLSID_WinsSnapinAbout,
						strDesc, 
						strVersion, 
						TRUE);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

	hr = RegisterSnapinGUID(&CLSID_WinsSnapinExtension, 
						    NULL, 
						    &CLSID_WinsSnapinAbout,
						    strExtDesc, 
						    strVersion, 
						    FALSE);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

    //
	// register the snapin nodes into the console node list
	//
	hr = RegisterNodeTypeGUID(&CLSID_WinsSnapin,
							  &GUID_WinsRootNodeType, 
							  strRootDesc);
	ASSERT(SUCCEEDED(hr));

#ifdef  __NETWORK_CONSOLE__

	hr = RegisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                         &CLSID_WinsSnapinExtension,
    							         strExtDesc,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &CLSID_WinsSnapinExtension);   // the value doesn't matter,
                                                                        // just needs to be non-null
	ASSERT(SUCCEEDED(hr));
#endif

	hr = RegisterAsRequiredExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                         &CLSID_WinsSnapinExtension,
    							         strExtDesc,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS);   // NULL : not dynamic
	ASSERT(SUCCEEDED(hr));
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hr  = _Module.UnregisterServer();
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;
	
	// un register the snapin 
	//
	hr = UnregisterSnapinGUID(&CLSID_WinsSnapin);
	ASSERT(SUCCEEDED(hr));
	
	if (FAILED(hr))
		return hr;

	hr = UnregisterSnapinGUID(&CLSID_WinsSnapinExtension);
    if (FAILED(hr))
		return hr;

    // unregister the snapin nodes 
	//
	hr = UnregisterNodeTypeGUID(&GUID_WinsRootNodeType);
	ASSERT(SUCCEEDED(hr));

    if (FAILED(hr))
		return hr;
	
#ifdef  __NETWORK_CONSOLE__

	hr = UnregisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                           &CLSID_WinsSnapinExtension,
                                           EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                           &CLSID_WinsSnapinExtension);  
	ASSERT(SUCCEEDED(hr));

#endif
    // computer management snapin extension
	hr = UnregisterAsRequiredExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                           &CLSID_WinsSnapinExtension,
                                           EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                           &CLSID_WinsSnapinExtension);  
	ASSERT(SUCCEEDED(hr));

    if (FAILED(hr))
		return hr;

    return hr;
}

#ifdef _DEBUG
void DbgVerifyInstanceCounts()
{
    DEBUG_VERIFY_INSTANCE_COUNT(CHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CMTHandler);
}



#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winssnap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winssnap.h
		global defines
		
    FILE HISTORY:
        
*/

#ifndef _WINSSNAP_H
#define _WINSSNAP_H

// message that gets posted to statistics windows to update their stats
#define WM_NEW_STATS_AVAILABLE  WM_USER + 100

// macro to get the handler for a node. This is a WINS snapin specific 
// implementation
#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

extern const GUID       GUID_WinsServerNodeType;			// Server NodeType GUID
// {90901AF6-7A31-11d0-97E0-00C04FC3357A}
extern const CLSID		CLSID_WinsSnapin ;

// {524CCE97-A886-11d0-AB86-00C04FC3357A}
extern const CLSID		CLSID_WinsSnapinExtension ;

// {1CE57F61-A88A-11d0-AB86-00C04FC3357A}
extern const GUID		CLSID_WinsSnapinAbout;

// {1AE7F339-AA00-11d0-AB88-00C04FC3357A}
extern const GUID		GUID_WinsRootNodeType ;

// {D5A5218E-BD09-11d0-AB96-00C04FC3357A}
extern const GUID		GUID_WinsGenericNodeType ;

extern const GUID		GUID_WinsReplicationNodeType;
// {E220FD88-1FE6-11d1-B967-00C04FBF914A}
extern const GUID		GUID_WinsActiveRegNodeType ;

// {FEC2D41A-2DF7-11d1-B97B-00C04FBF914A}
extern const GUID		GUID_WinsActiveRegistrationLeafNodeType;

// {6A112BB1-4577-11d1-B99F-00C04FBF914A}
extern const GUID		GUID_WinsReplicationPartnerLeafNodeType;

// {CC6473A7-A49C-11d1-BA4D-00C04FBF914A}
extern const GUID		GUID_WinsServerStatusNodeType;

extern const GUID		GUID_WinsServerStatusLeafNodeType;

// {DA1BDD17-8E54-11d1-93DB-00C04FC3357A}
extern const GUID       GUID_NetConsRootNodeType;

extern	const IID		IID_IWinsDatabase;// = {0x7B0C8BBF,0x3117,0x11d1,{0xB9,0x81,0x00,0xC0,0x4F,0xBF,0x91,0x4A}};

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// Sample folder types
enum NODETYPES
{
// scope pane items
    WINSSNAP_ROOT,
    WINSSNAP_SERVER,
	WINSSNAP_ACTIVE_REGISTRATIONS,
    WINSSNAP_REPLICATION_PARTNERS,

	//StatusRemove
	WINSSNAP_SERVER_STATUS,

	
// result pane items
    WINSSNAP_REGISTRATION,
	WINSSNAP_REPLICATION_PARTNER,
	WINSSNAP_STATUS_LEAF_NODE,
    WINSSNAP_NODETYPE_MAX
};

#define GETIP_FIRST(x)             ((x>>24) & 0xff)
#define GETIP_SECOND(x)            ((x>>16) & 0xff)
#define GETIP_THIRD(x)             ((x>> 8) & 0xff)
#define GETIP_FOURTH(x)            ((x)     & 0xff)

#define INTLTIMESTR(time) (((CIntlTime)(time)).CIntlTime::operator const CString())
#define TMST(x) INTLTIMESTR(x)


// wait cursor stuff around functions.  If you need a wait cursor for 
// and entire fucntion, just use CWaitCursor.  To wrap a wait cursor
// around an rpc call, use these macros.
#define BEGIN_WAIT_CURSOR   {  CWaitCursor waitCursor;
#define RESTORE_WAIT_CURSOR    waitCursor.Restore();
#define END_WAIT_CURSOR     }


// Defines for help from the help menu and F1 help for scope pane items
#define WINSSNAP_HELP_BASE							0xA0000000
#define WINSSNAP_HELP_SNAPIN						WINSSNAP_HELP_BASE + 1
#define WINSSNAP_HELP_ROOT							WINSSNAP_HELP_BASE + 2
#define WINSSNAP_HELP_SERVER						WINSSNAP_HELP_BASE + 3
#define WINSSNAP_HELP_ACT_REG_NODE				    WINSSNAP_HELP_BASE + 4
#define WINSSNAP_HELP_REP_PART_NODE				    WINSSNAP_HELP_BASE + 5
#define WINSSNAP_HELP_ACTREG_ENTRY					WINSSNAP_HELP_BASE + 6
#define WINSSNAP_HELP_REP_PART_ENTRY				WINSSNAP_HELP_BASE + 7


class CWinsSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
    int     MessageBox (UINT nIdPrompt, UINT nType = MB_OK, UINT nHelpContext = -1);
    int     MessageBox (LPCTSTR pPrefixText, UINT nIdPrompt, UINT nType = MB_OK, UINT nHelpContext = -1);
    DWORD   GetSystemMessage(UINT nId, TCHAR * chBuffer, int cbBuffSize);

public:
	BOOL m_bWinsockInited;
};

extern CWinsSnapinApp theApp;

// help stuff here
typedef CMap<UINT, UINT, DWORD *, DWORD *> CWinsContextHelpMap;
extern CWinsContextHelpMap g_winsContextHelpMap;

#define WINSSNAP_NUM_HELP_MAPS  33

extern DWORD * WinsGetHelpMap(UINT uID);


#endif //_WINSSNAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wins\winssup.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	winsup.cpp
		Global functions and variables

	FILE HISTORY:


*/


#ifndef _WINSSUP_H
#define _WINSSUP_H

// some global defines we need
#define WINS_NAME_CODE_PAGE     CP_OEMCP 
#define INVALID_OWNER_ID        0xFFFFFFFF


// Constants used in samples
const int NUM_FOLDERS = 6;
const int MAX_COLUMNS = 9;
const int NUM_SCOPE_ITEMS = 4;

extern const TCHAR g_szPipeName[];
extern const TCHAR g_szDefaultHelpTopic[];

extern const CLSID      CLSID_WinsSnapin;               // In-Proc server GUID
extern const CLSID      CLSID_WinsSnapinExtension;      // In-Proc server GUID
extern const CLSID      CLSID_WinsSnapinAbout;          // In-Proc server GUID
extern const GUID       GUID_WinsRootNodeType;          // Main NodeType GUID on numeric format
extern const GUID       GUID_WinsGenericNodeType;          // Generic-non extendible NodeType GUID

// defines used in the display of owner info
enum _COLUMNS
{
    COLUMN_IP,
    COLUMN_NAME,
    COLUMN_VERSION,
    COLUMN_MAX
};

// #defines for time intervals
#define SEC_PER_DAY		(24	*60	* 60)
#define SEC_PER_HOUR	(60 * 60)
#define SEC_PER_MINUTE	60

// for verifying the WINS servers
#define NB_NAME_MAX_LENGTH      16          // Max length for NetBIOS names
#define LM_NAME_MAX_LENGTH      15          // Maximum length for Lanman-compatible 
											// NetBIOS Name.

#define DOMAINNAME_LENGTH       255
#define HOSTNAME_LENGTH         16

// for monitoring
#define SERVER_DELETED		    0x00000001
#define SERVER_ADDED		    0x00000002

// deleted owner gets this vers no
#define OWNER_DELETED           0x7FFFFFFFFFFFFFFF

// flags that get stored in the .msc file
enum _SERVERFLAGS
{
    FLAG_LANMAN_COMPATIBLE = 0x00000001,
    FLAG_VALIDATE_CACHE    = 0x00000002,
    FLAG_STATUS_BAR        = 0x00000004,
    FLAG_AUTO_REFRESH      = 0x00000008,
    FLAG_EXTENSION         = 0x00000010,    // we are an extension
    FLAG_SHOW_FQDN         = 0x00000020,
    FLAG_SERVER_ORDER_IP   = 0x00000040,
    FLAG_SHOW_TASKPADS     = 0x00000080,
};

#define WIN32_FROM_HRESULT(hr)		(0x0000FFFF & (hr))

extern UINT aColumns[WINSSNAP_NODETYPE_MAX][MAX_COLUMNS];
extern int aColumnWidths[WINSSNAP_NODETYPE_MAX][MAX_COLUMNS];

// Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

DWORD   SendTrigger(handle_t hWins, LONG ipTarget, BOOL fPush, BOOL fPropagate);

//often used functions
DWORD   ControlWINSService(LPCTSTR pszName, BOOL bStop = TRUE);
void    GetNameIP(const CString &strDisplay, CString &strName, CString &strIP);
void    MakeIPAddress(DWORD dwIPAdd, CString &strIP);
DWORD   GetHostName(DWORD dwIpAddr, CString & strHostName);
DWORD   GetHostAddress(LPCTSTR pszHostName, DWORD * pdwIp);

DWORD   WideToMBCS(CString & strIn, LPSTR szOut, UINT uCodePage = CP_ACP, DWORD dwFlags = 0, BOOL * pfDefaultUsed = NULL);
DWORD   MBCSToWide(LPSTR szOut, CString & strIn, UINT uCodePage = CP_ACP, DWORD dwFlags = 0);

// formatted messagebox for the snap-in
BOOL LoadMessage(UINT nIdPrompt, TCHAR * chMsg, int nMsgSize);
LONG GetSystemMessageA(UINT	nId, CHAR *	chBuffer, int cbBuffSize);
LONG GetSystemMessage (UINT	nId, TCHAR * chBuffer, int cbBuffSize);
int WinsMessageBox(UINT nIdPrompt, 
 				   UINT nType = MB_OK, 
				   const TCHAR * pszSuffixString = NULL,
				   UINT nHelpContext = -1);

int WinsMessageBoxEx(UINT    nIdPrompt, 
 				     LPCTSTR pszPrefixMessage,
                     UINT    nType = MB_OK, 
  				     UINT    nHelpContext = -1);

// for the validation of server names
BOOL IsValidNetBIOSName(CString & strAddress,BOOL fLanmanCompatible,BOOL fWackwack);
DWORD VerifyWinsServer(CString& strAddress, CString &strServerName, DWORD &dwIP);
BOOL IsValidAddress(CString& strAddress,BOOL * fIpAddress,BOOL fLanmanCompatible,BOOL fWackwack );

typedef enum _NAME_TYPE_MAPPING_
{
	NAME_TYPE_WORKSTATION           = 0x00000000,
	NAME_TYPE_MESSENGER             = 0x00000003,
	NAME_TYPE_RAS_SERVER            = 0x00000006,
	NAME_TYPE_DMB                   = 0x0000001B,
	NAME_TYPE_DC                    = 0x0000001C,		
	NAME_TYPE_NORM_GRP_NAME         = 0x0000001E,
	NAME_TYPE_NETDDE                = 0x0000001F, 
	NAME_TYPE_FILE_SERVER           = 0x00000020,	
	NAME_TYPE_WORK_NW_MON_AGENT     = 0x000000BE,
	NAME_TYPE_WORK_NW_MON_NAME      = 0x000000BF,
	NAME_TYPE_OTHER		            = 0x0000FFFF,
} NAME_TYPE_MAPPING;

#define NUM_DEFAULT_NAME_TYPES      13

extern const UINT s_NameTypeMappingDefault[NUM_DEFAULT_NAME_TYPES][3];

/*---------------------------------------------------------------------------
	Protocol name formatting functions/classes

	This is provided separately from the usual function mechanism.  The
	reason is that we will read in additional data from the registry of
	the router.  This allows users to add their own protocols.
 ---------------------------------------------------------------------------*/

 
 /*---------------------------------------------------------------------------
	Class:	CStringMapEntry
 ---------------------------------------------------------------------------*/
class CStringMapEntry
{
public:
    CStringMapEntry() 
	{
		dwNameType = 0;
		dwWinsType = -1;
		ulStringId = 0;
	}

    CStringMapEntry(CStringMapEntry & stringMapEntry)
    {
        *this = stringMapEntry;
    }

    CStringMapEntry & operator = (const CStringMapEntry & stringMapEntry)
    {
        if (this != &stringMapEntry)
        {
			dwNameType = stringMapEntry.dwNameType;
			dwWinsType = stringMapEntry.dwWinsType;
			st = stringMapEntry.st;
			ulStringId = stringMapEntry.ulStringId;
		}
        
        return *this;
    }

public:    
	DWORD		dwNameType;			// 16th byte of name, -1 is a sentinel value
	DWORD		dwWinsType;		// type of record--Unique, group, etc; -1 for don't care
	CString	    st;
	ULONG		ulStringId;
};

typedef CArray<CStringMapEntry, CStringMapEntry&> CStringMapArray;

void MapDWORDToCString(DWORD dwNameType, DWORD dwWinsType, const CStringMapEntry *pMap, CString & strName);

/*---------------------------------------------------------------------------
	Class:	NameTypeMapping
 ---------------------------------------------------------------------------*/
class NameTypeMapping : public CStringMapArray
{
public:
	NameTypeMapping();
	~NameTypeMapping();
	
	HRESULT		Load();
	void		Unload();
    HRESULT     AddEntry(DWORD dwProtocolId, LPCTSTR pszName);
    HRESULT     ModifyEntry(DWORD dwProtocolId, LPCTSTR pszName);
    HRESULT     RemoveEntry(DWORD dwProtocolId);
    BOOL        EntryExists(DWORD dwProtocolId);

    void        SetMachineName(LPCTSTR pszMachineName);

	void        TypeToCString(DWORD dwNameType, DWORD dwWinsType, CString & strName);

private:
	typedef CString REGKEYNAME;

    CString     m_strMachineName;
public:
	static const REGKEYNAME c_szNameTypeMapKey;
	static const REGKEYNAME c_szDefault;
};

/*---------------------------------------------------------------------------
	Class:	CServerInfo
 ---------------------------------------------------------------------------*/
class CServerInfo 
{
public:
    CServerInfo() {};
    CServerInfo(DWORD dwIp, CString & strName, LARGE_INTEGER liVersion)
        : m_dwIp(dwIp),
          m_strName(strName)
    {
        m_liVersion.QuadPart = liVersion.QuadPart;
    }

    CServerInfo(CServerInfo & ServerInfo)
    {
        *this = ServerInfo;
    }

    CServerInfo & operator = (const CServerInfo & ServerInfo)
    {
        if (this != &ServerInfo)
        {
            m_dwIp = ServerInfo.m_dwIp;
            m_strName = ServerInfo.m_strName;
            m_liVersion.QuadPart = ServerInfo.m_liVersion.QuadPart;
        }
        
        return *this;
    }

public:
    DWORD           m_dwIp;
    CString         m_strName;
    LARGE_INTEGER   m_liVersion;
};

typedef CArray<CServerInfo, CServerInfo&> CServerInfoArrayBase;

/*---------------------------------------------------------------------------
	Class:	CWinsThread
 ---------------------------------------------------------------------------*/
class CServerInfoArray : public CServerInfoArrayBase
{
public:
    const CServerInfo GetAt(int nIndex)
    {
        CSingleLock sl(&m_lock);

        sl.Lock();

        return CServerInfoArrayBase::GetAt(nIndex);
    }

    CServerInfo & ElementAt(int nIndex)
    {
        CSingleLock sl(&m_lock);

        sl.Lock();

        return CServerInfoArrayBase::ElementAt(nIndex);
    }

    void SetAt(int nIndex, CServerInfo & serverInfo)
    {
        CSingleLock sl(&m_lock);

        sl.Lock();

        CServerInfoArrayBase::SetAt(nIndex, serverInfo);
    }
public:
    CSemaphore  m_lock;
};


typedef CArray<WINSINTF_ADD_VERS_MAP_T, WINSINTF_ADD_VERS_MAP_T> CAddVersMap;

/*---------------------------------------------------------------------------
	Class:	CWinsResults
	    Abstraction of the WINS_RESULTS and WINS_RESULTS_NEW structs
 ---------------------------------------------------------------------------*/
class CWinsResults
{
public:
    CWinsResults();
    CWinsResults(WINSINTF_RESULTS_T * pwrResults);
    CWinsResults(WINSINTF_RESULTS_NEW_T * pwrResults);

    CWinsResults(CServerInfo & ServerInfo)
    {
        *this = ServerInfo;
    }

    CWinsResults & operator = (const CWinsResults & CWinsResults)
    {
        if (this != &CWinsResults)
        {
            NoOfOwners = CWinsResults.NoOfOwners;
            AddVersMaps.Copy(CWinsResults.AddVersMaps);
            MyMaxVersNo.QuadPart = CWinsResults.MyMaxVersNo.QuadPart;
            RefreshInterval = CWinsResults.RefreshInterval;
            TombstoneInterval = CWinsResults.TombstoneInterval;
            TombstoneTimeout = CWinsResults.TombstoneTimeout;
            VerifyInterval = CWinsResults.VerifyInterval;
            WinsPriorityClass = CWinsResults.WinsPriorityClass;
            NoOfWorkerThds = CWinsResults.NoOfWorkerThds;
            WinsStat = CWinsResults.WinsStat;
        }
        
        return *this;
    }

    DWORD   Update(handle_t binding);
    void    Set(WINSINTF_RESULTS_T * pwrResults);
    void    Set(WINSINTF_RESULTS_NEW_T * pwrResults);
    void    Clear();

protected:
    DWORD   GetConfig(handle_t binding);
    DWORD   GetNewConfig(handle_t binding);

public:
	DWORD			NoOfOwners;
    CAddVersMap     AddVersMaps;
	LARGE_INTEGER	MyMaxVersNo;
	DWORD			RefreshInterval;
	DWORD			TombstoneInterval;
	DWORD			TombstoneTimeout;
	DWORD			VerifyInterval;
	DWORD			WinsPriorityClass;
	DWORD			NoOfWorkerThds;
	WINSINTF_STAT_T	WinsStat;
};

/*---------------------------------------------------------------------------
	Class:	CWinsName
 ---------------------------------------------------------------------------*/
class CWinsName
{
public:
	CWinsName()
	{
		dwType = 0;
	}

    CWinsName(CWinsName & winsName)
    {
        *this = winsName;
    }

    CWinsName & operator = (const CWinsName & winsName)
    {
        if (this != &winsName)
        {
			strName = winsName.strName;
			dwType = winsName.dwType;
		}
        
        return *this;
    }

	BOOL operator == (const CWinsName & winsName)
	{
		if ( (strName.Compare(winsName.strName) == 0) &&
			 (dwType == winsName.dwType) )
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

public:
	CString	strName;
	DWORD	dwType;
};

typedef CArray<CWinsName, CWinsName&> CWinsNameArray;

/*---------------------------------------------------------------------------
	Class:	CTypeFilterInfo
 ---------------------------------------------------------------------------*/
class CTypeFilterInfo
{
public:
	CTypeFilterInfo()
	{
		dwType = 0;
		fShow = TRUE;
	}

    CTypeFilterInfo(CTypeFilterInfo & typeFilterInfo)
    {
        *this = typeFilterInfo;
    }

    CTypeFilterInfo & operator = (const CTypeFilterInfo & typeFilterInfo)
    {
        if (this != &typeFilterInfo)
        {
			dwType = typeFilterInfo.dwType;
			fShow = typeFilterInfo.fShow;
		}
        
        return *this;
    }

	BOOL operator == (const CTypeFilterInfo & typeFilterInfo)
	{
		if ( (fShow == typeFilterInfo.fShow) &&
			 (dwType == typeFilterInfo.dwType) )
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}

public:
	DWORD	dwType;
	BOOL	fShow;
};

typedef CArray<CTypeFilterInfo, CTypeFilterInfo&> CTypeFilterInfoArray;

#endif //#define _WINSSUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipctrl.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    ipcontrol.h
//
// History:
//  ??/??/??    Tony Romano         Created.
//  05/16/96    Abolade Gbadegesin  Revised.
//============================================================================

#ifndef __IPCTRL_H
#define __IPCTRL_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//----------------------------------------------------------------------------
// Class:       IPControl
//
// Controls an IP-address edit-control.
//----------------------------------------------------------------------------

class IPControl {
    
    public:

        IPControl( );
        ~IPControl( );
    
        BOOL
        Create(
            HWND        hParent,
            UINT        nID );

        operator
        HWND( ) { ASSERT(m_hIPaddr); return m_hIPaddr; }
    
        BOOL
        IsBlank( );

        VOID
        SetFocusField(
            DWORD       dwField );

        VOID
        SetFieldRange(
            DWORD       dwField,
            DWORD       dwMin,
            DWORD       dwMax );

        VOID
        ClearAddress( );
    
        VOID
        SetAddress(
            DWORD       ardwAddress[4] );

        VOID
        SetAddress(
            DWORD       a1,
            DWORD       a2,
            DWORD       a3,
            DWORD       a4 );

        VOID
        SetAddress(
            LPCTSTR     lpszString );
    
        INT 
        GetAddress(
            DWORD       ardwAddress[4] );

        INT 
        GetAddress(
            DWORD*      a1,
            DWORD*      a2,
            DWORD*      a3,
            DWORD*      a4 );

        INT
        GetAddress(
            CString&    address );
    
        LRESULT
        SendMessage(
            UINT        uMsg,
            WPARAM      wParam,
            LPARAM      lParam );
    
    protected:

        HWND            m_hIPaddr;
};



//----------------------------------------------------------------------------
// Macro:   MAKEADDR
//
// Given an a, b, c, and d, constructs a network-order DWORD corresponding
// to the IP-address a.b.c.d
//----------------------------------------------------------------------------

#define MAKEADDR(a, b, c, d) \
    (((a) & 0xff) | (((b) & 0xff) << 8) | (((c) & 0xff) << 16) | (((d) & 0xff) << 24))


//----------------------------------------------------------------------------
// Macros:      INET_NTOA
//              INET_ADDR
//
// Generic-text macros for IP-address conversion.
//----------------------------------------------------------------------------

/*
#ifndef UNICODE
#define INET_NTOA(a)    inet_ntoa(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addr
#else
#define INET_NTOA(a)    inet_ntoaw(*(struct in_addr *)&(a))
#define INET_ADDR       inet_addrw
#endif
*/

//----------------------------------------------------------------------------
// Macro:       INET_CMP
//
// Comparison macro for IP addresses.
//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument
//----------------------------------------------------------------------------

inline int INET_CMP(DWORD a, DWORD b)
{
	DWORD	t;
	
	return ((t = ((a & 0x000000ff) - (b & 0x000000ff))) ? t :  
	((t = ((a & 0x0000ff00) - (b & 0x0000ff00))) ? t :   
	((t = ((a & 0x00ff0000) - (b & 0x00ff0000))) ? t :  
	((t = (((a>>8) & 0x00ff0000) - ((b>>8) & 0x00ff0000)))))));
}




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\addserv.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    EditUser.h   
        Edit Users dialog header file

	FILE HISTORY:
        
*/

#if !defined(AFX_ADDSERV_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_ADDSERV_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAddServ dialog

class CAddServ : public CBaseDialog
{
// Construction
public:
	CAddServ(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddServ)
	enum { IDD = IDD_ADD_COMPUTER };
	CEdit m_editComputerName;
	//}}AFX_DATA

    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDD_ADD_COMPUTER[0]; }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddServ)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddServ)
	virtual BOOL OnInitDialog();
	afx_msg void OnButtonBrowse();
	afx_msg void OnRadioBtnClicked();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	
public:
	CString m_stComputerName;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDSERV_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\apinfo.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

#include "stdafx.h"
#include "DynamLnk.h"
#include "apinfo.h"
#include "spdutil.h"

#include "security.h"
#include "lm.h"
#include "service.h"

#define AVG_PREFERRED_ENUM_COUNT       40
#define MAX_NUM_RECORDS	10  // was 10

#define DEFAULT_SECURITY_PKG    _T("negotiate")
#define NT_SUCCESS(Status)      ((NTSTATUS)(Status) >= 0)
#define STATUS_SUCCESS          ((NTSTATUS)0x00000000L)

// internal functions
BOOL    IsUserAdmin(LPCTSTR pszMachine, PSID    AccountSid);
DWORD   ValidateDomainAccount(IN CString Machine, IN CString UserName, IN CString Domain, OUT PSID * AccountSid);
NTSTATUS ValidatePassword(IN LPCWSTR UserName, IN LPCWSTR Domain, IN LPCWSTR Password);
DWORD   GetCurrentUser(CString & strAccount);

DEBUG_DECLARE_INSTANCE_COUNTER(CApDbInfo);

CApDbInfo::CApDbInfo() :
	  m_cRef(1)
{
        m_Init=0;
        m_Active=0;
        m_session_init = false;
	DEBUG_INCREMENT_INSTANCE_COUNTER(CSpdInfo);
}

CApDbInfo::~CApDbInfo()
{
	DEBUG_DECREMENT_INSTANCE_COUNTER(CApInfo());
	CSingleLock cLock(&m_csData);
	
	cLock.Lock();

	//Convert the data to our internal data structure
	//FreeItemsAndEmptyArray(m_arrayFWFilters);
	FreeItemsAndEmptyArray(m_arrayApData);

	cLock.Unlock();

}

// Although this object is not a COM Interface, we want to be able to
// take advantage of recounting, so we have basic addref/release/QI support
IMPLEMENT_ADDREF_RELEASE(CApDbInfo)

IMPLEMENT_SIMPLE_QUERYINTERFACE(CApDbInfo, IApDbInfo)

void CApDbInfo::FreeItemsAndEmptyArray(CApInfoArray& array)
{
    for (int i = 0; i < array.GetSize(); i++)
    {
        delete array.GetAt(i);
    }
    array.RemoveAll();
}

HRESULT CApDbInfo::SetComputerName(LPTSTR pszName)
{
	m_stMachineName = pszName;
	return S_OK;
}

HRESULT CApDbInfo::GetComputerName(CString * pstName)
{
	Assert(pstName);

	if (NULL == pstName)
		return E_INVALIDARG;

	
	*pstName = m_stMachineName;

	return S_OK;
	
}

HRESULT CApDbInfo::GetSession(PHANDLE phsession)
{
	Assert(phsession);

	if (NULL == phsession)
		return E_INVALIDARG;

	*phsession = m_session;
	
	return S_OK;
	
}

HRESULT CApDbInfo::SetSession(HANDLE hsession)
{
	m_session = hsession;
	m_session_init = true;
	return S_OK;
}


HRESULT 
CApDbInfo::EnumApData()
{
    HRESULT                 hr                  = hrOK;
    DWORD                   dwErr               = ERROR_SUCCESS;
    DWORD                   dwCurrentIndexType  = 0;
    DWORD                   dwCurrentSortOption = 0;
    DWORD                   dwNumRequest        = 0; 
    DWORD                   dwOffset            = 0;    
    DWORD                   flagIn              = 0;
    DWORD                   flagOut             = 0;
    DWORD                   i                   = 0;
    DWORD                   j                   = 0;
    DWORD                   oldSize             = 0;
    CSingleLock             cLock(&m_csData);
    CApInfoArray            arrayTemp;
    CString	            debugString; 
    INTFS_KEY_TABLE         ApTable;
    PINTF_KEY_ENTRY         pKeyEntry           = NULL;
    INTF_ENTRY              ApEntry;
    PWZC_802_11_CONFIG_LIST pConfigList         = NULL;
    PWZC_WLAN_CONFIG	    pLanConfig          = NULL;
    CApInfo                 *pApInfo            = NULL;
    
    FreeItemsAndEmptyArray(arrayTemp);
    memset(&ApTable, 0, sizeof(INTFS_KEY_TABLE));
	
    dwErr = ::WZCEnumInterfaces(NULL /*(LPTSTR)(LPCTSTR)m_stMachineName*/,
                                &ApTable);

    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Error;
    }

    cLock.Lock();

    flagIn = (DWORD)(-1);  // Set to get all fields

    //
    // for each GUID (NIC) returned by EnumInterfaces, call QueryInterface and
    // add that interface's data to the array.
    //

    for (i = 0; i < ApTable.dwNumIntfs; i++) 
    {
        flagOut = 0;
        pKeyEntry = ApTable.pIntfs + i;
        memset (&ApEntry, 0, sizeof(INTF_ENTRY));
        ApEntry.wszGuid = pKeyEntry->wszGuid;

        dwErr = ::WZCQueryInterface(NULL /*(LPTSTR)(LPCTSTR)m_stMachineName*/,
                                    flagIn,
                                    &ApEntry,
                                    &flagOut);
        
        //
        // Did we get the BSSID list?
        //

        if ( (dwErr == ERROR_SUCCESS) && 
             (flagOut & INTF_BSSIDLIST) )
        {
            pConfigList = (PWZC_802_11_CONFIG_LIST)(ApEntry.rdBSSIDList.pData);

            //
            // increase size of array by the number of visible AP's in this 
            // interface.
            //

            oldSize = (DWORD)arrayTemp.GetSize();
            arrayTemp.SetSize(oldSize + pConfigList->NumberOfItems);

            //
            // iterate through each visible ap
            // index starts at .Index instead of 0 for some reason...
            //

            for (j = pConfigList->Index; 
                 j < pConfigList->NumberOfItems + pConfigList->Index; 
                 j++) 
            {
                pLanConfig = &(pConfigList->Config[j]);

                //
                // Default Constructor zeros the ApInfo object.
                //

                pApInfo = new CApInfo();
                if (NULL == pApInfo)
                {
                    hr = E_OUTOFMEMORY;
                    goto Error;
                }                

                //
                // Set the data
                //

                dwErr = pApInfo->SetApInfo(&ApEntry, pLanConfig);
                if (dwErr != ERROR_SUCCESS)
                    AfxMessageBox(_T("Error setting ApInfo"), MB_OK);

                //
                // put new item in current 0-based index plus the previous
                // size of array.
                //

                arrayTemp[j -pConfigList->Index + oldSize] = pApInfo;
            }
        }

        WZCDeleteIntfObj(&ApEntry);
    }

    //
    // Only free top level array of table, as individual keys will be 
    // deleted by the query mechanism.
    //

    RpcFree(ApTable.pIntfs);
    
    FreeItemsAndEmptyArray(m_arrayApData);
    m_arrayApData.Copy(arrayTemp);

    //
    //remember the original IndexType and Sort options
    //

    dwCurrentIndexType = IDS_COL_APDATA_GUID;
    dwCurrentSortOption = SORT_ASCENDING;
    
    m_IndexMgrLogData.Reset();
    for (i = 0; i < (DWORD)m_arrayApData.GetSize(); i++)
    {
        m_IndexMgrLogData.AddItem(m_arrayApData.GetAt(i));
    }
    SortApData(dwCurrentIndexType, dwCurrentSortOption);
    
 Error:
    //
    // This particular error is because we don't have any MM policies. 
    // Ignore it
    //

    if (HRESULT_FROM_WIN32(ERROR_NO_DATA) == hr)
        hr = hrOK;
    
    return hr;
}


DWORD CApDbInfo::GetApCount()
{
	CSingleLock cLock(&m_csData);
	cLock.Lock();
	
	return (DWORD)m_arrayApData.GetSize();
}



HRESULT 
CApDbInfo::GetApInfo(
    int     iIndex,
    CApInfo *pApDb
    )
/*++

Routine Description:

    Returns the ApInfo at a virtual index

Arguments:

    [in] iIndex - virtual index
    [out] pApDb - Returned value. space must be allocated by caller

Returns:

    HR_OK on success
    
--*/
{
    HRESULT hr = hrOK;
    CApInfo *pApInfo = NULL;

    m_csData.Lock();

    if (iIndex < m_arrayApData.GetSize())
    {
        pApInfo = (CApInfo*) m_IndexMgrLogData.GetItemData(iIndex);
        Assert(pApInfo);
        *pApDb = *pApInfo;
    }
    else
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
   
    m_csData.Unlock();

    return hr;
}


HRESULT
CApDbInfo::SortApData(
    DWORD dwIndexType,
    DWORD dwSortOptions
    )
{
    return m_IndexMgrLogData.SortApData(dwIndexType, dwSortOptions);
}


STDMETHODIMP
CApDbInfo::Destroy()
{
    //$REVIEW this routine get called when doing auto-refresh
    //We don't need to clean up anything at this time.
    //Each array (Filter, SA, policy...) will get cleaned up when calling the
    //corresponding enum function.
    
    HANDLE hsession;
    
    GetSession(&hsession);
    
    if (m_session_init == true) 
    {
        ::CloseWZCDbLogSession(hsession);
    }    

    return S_OK;
}


DWORD
CApDbInfo::GetInitInfo()
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    return m_Init;
}

void
CApDbInfo::SetInitInfo(DWORD dwInitInfo)
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    m_Init=dwInitInfo;
}

DWORD
CApDbInfo::GetActiveInfo()
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    return m_Active;
}

void
CApDbInfo::SetActiveInfo(DWORD dwActiveInfo)
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    m_Active=dwActiveInfo;
}


/*!--------------------------------------------------------------------------
    CreateApInfo
        Helper to create the ApDbInfo object.
 ---------------------------------------------------------------------------*/
HRESULT 
CreateApDbInfo(IApDbInfo ** ppApDbInfo)
{
    AFX_MANAGE_STATE(AfxGetModuleState());
    
    SPIApDbInfo     spApDbInfo;
    IApDbInfo *     pApDbInfo = NULL;
    HRESULT         hr = hrOK;

    COM_PROTECT_TRY
    {
        pApDbInfo = new CApDbInfo;

        // Do this so that it will get freed on error
        spApDbInfo = pApDbInfo;
	
    
        *ppApDbInfo = spApDbInfo.Transfer();

    }
    COM_PROTECT_CATCH

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\apinfo.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	apinfo.h

    FILE HISTORY:
        
*/

#ifndef _APINFO_H
#define _APINFO_H

#ifndef _HARRAY_H
#include "harray.h"
#endif

#include "spdutil.h"

#define PROTOCOL_ID_OFFSET  9

interface IApInfo;

template <class T>
void
FreeItemsAndEmptyArray (
    T& array);

DWORD   IsAdmin(LPCTSTR szMachineName, LPCTSTR szAccount, LPCTSTR szPassword, BOOL * pfIsAdmin);

/* _ApInfo: Private structure used inside of CApInfo. 
 */
typedef struct _ApInfo
{
    WZC_WLAN_CONFIG wlanConfig;
    LPWSTR          wszGuid;
    BOOL            bAssociated;
} APINFO, *PAPINFO;

class CApInfo
{
public:
    CApInfo() 
    {
        memset(&m_ApInfo, 0, sizeof(APINFO));
    }

    CApInfo(PINTF_ENTRY nicEntry, PWZC_WLAN_CONFIG apEntry)
    {
        DWORD dwErr = ERROR_SUCCESS;

        dwErr = SetWlanConfig(apEntry);
        dwErr = SetWszGuid(nicEntry->wszGuid);

        //TODO: Throw exceptions on error
    }	

    DWORD SetApInfo(PINTF_ENTRY nicEntry, PWZC_WLAN_CONFIG apEntry)
    {
        DWORD dwErr = ERROR_SUCCESS;

        dwErr = SetWlanConfig(apEntry);
        if (dwErr != ERROR_SUCCESS)
            goto done;

        dwErr = SetWszGuid(nicEntry->wszGuid);
        if (dwErr != ERROR_SUCCESS)
            goto done;
        
        dwErr = SetAssociated(nicEntry);
        
    done:
        return dwErr;
    }	

    const CApInfo& operator=(const CApInfo& ApInfoSrc)
    {
        DWORD dwErr = ERROR_SUCCESS;

        dwErr = SetWlanConfig(&(ApInfoSrc.m_ApInfo.wlanConfig));
        if (dwErr != ERROR_SUCCESS)
            goto done;

        dwErr = SetWszGuid(ApInfoSrc.m_ApInfo.wszGuid);
        if (dwErr != ERROR_SUCCESS)
            goto done;

        m_ApInfo.bAssociated = ApInfoSrc.m_ApInfo.bAssociated;

    done:
        return *this;
    }

    ~CApInfo()
    {
        if (NULL != m_ApInfo.wlanConfig.rdUserData.pData)
        {
            delete [] m_ApInfo.wlanConfig.rdUserData.pData;
            m_ApInfo.wlanConfig.rdUserData.pData = NULL;
        }
        
        if (NULL != m_ApInfo.wszGuid)
        {
            delete [] m_ApInfo.wszGuid;
            m_ApInfo.wszGuid = NULL;
        }
    }
    
private:
    DWORD SetAssociated(const INTF_ENTRY *pIntfEntry)
    {
        int i = 0;
        DWORD dwErr = ERROR_SUCCESS;
        const NDIS_802_11_MAC_ADDRESS *pAssocMac = NULL;
        const NDIS_802_11_MAC_ADDRESS *pCurrMac = NULL;

        m_ApInfo.bAssociated = FALSE;

        if (NULL == pIntfEntry)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto done;
        }
        
        pAssocMac = (const NDIS_802_11_MAC_ADDRESS*)pIntfEntry->rdBSSID.pData;
        pCurrMac = &(m_ApInfo.wlanConfig.MacAddress);

        if (0 == memcmp(pAssocMac, pCurrMac, sizeof(NDIS_802_11_MAC_ADDRESS)) )
            m_ApInfo.bAssociated = TRUE;

    done:
        return dwErr;
    }

    DWORD SetWlanConfig(const WZC_WLAN_CONFIG *pwlanCfgSrc)
    {
        DWORD dwErr = ERROR_SUCCESS;
        DWORD dwLen = 0;
        PWZC_WLAN_CONFIG pwlanCfgDest = &(m_ApInfo.wlanConfig);
        
        ASSERT(pwlanCfgSrc != NULL);
        
        //copy upto the pointer in rdUserData
        memcpy(pwlanCfgDest, pwlanCfgSrc, 
               sizeof(WZC_WLAN_CONFIG) - sizeof(LPBYTE));

        if (pwlanCfgDest->rdUserData.pData != NULL)
            AfxMessageBox(_T("Non null UserData"), MB_OK);

        dwLen = pwlanCfgSrc->rdUserData.dwDataLen;
        if (dwLen > 0)
        {
            pwlanCfgDest->rdUserData.pData = new BYTE[dwLen];
            if (pwlanCfgDest->rdUserData.pData != 0)
                memcpy(pwlanCfgDest->rdUserData.pData, 
                       pwlanCfgSrc->rdUserData.pData,
                       pwlanCfgSrc->rdUserData.dwDataLen);
            else
                dwErr = ERROR_OUTOFMEMORY;
        }

        return dwErr;
    }

    DWORD SetWszGuid(LPWSTR wszGuidSrc)
    {
        DWORD dwErr = ERROR_SUCCESS;
        DWORD dwLen = 0;

        ASSERT(wszGuidSrc != NULL);

        if (wszGuidSrc != NULL)
        {
            dwLen = wcslen(wszGuidSrc) + 1;
            m_ApInfo.wszGuid = new wchar_t[dwLen];
            if (0 == m_ApInfo.wszGuid)
                dwErr = ERROR_OUTOFMEMORY;
            else
                memcpy(m_ApInfo.wszGuid, wszGuidSrc, dwLen * sizeof(wchar_t));
        }
        return dwErr;
    }

public:
    APINFO m_ApInfo;
};

typedef CArray<CApInfo *, CApInfo *> CApInfoArray;

#define MAX_STR_LEN 80

#define DeclareIApDbInfoMembers(IPURE) \
	STDMETHOD(Destroy) (THIS) IPURE; \
	STDMETHOD(SetComputerName) (THIS_ LPTSTR pszName) IPURE; \
	STDMETHOD(GetComputerName) (THIS_ CString * pstName) IPURE; \
	STDMETHOD(GetSession) (THIS_ PHANDLE phsession) IPURE; \
	STDMETHOD(SetSession) (THIS_ HANDLE hsession) IPURE;  \
	STDMETHOD(EnumApData) (THIS) IPURE; \
	STDMETHOD(GetApInfo) (THIS_ int iIndex, CApInfo * pApInfo) IPURE; \
	STDMETHOD_(DWORD, GetApCount) (THIS) IPURE; \
	STDMETHOD(SortApData) (THIS_ DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
	STDMETHOD_(DWORD, GetInitInfo) (THIS) IPURE; \
	STDMETHOD_(void, SetInitInfo) (THIS_ DWORD dwInitInfo) IPURE; \
	STDMETHOD_(DWORD, GetActiveInfo) (THIS) IPURE; \
	STDMETHOD_(void, SetActiveInfo) (THIS_ DWORD dwActiveInfo) IPURE;

#undef INTERFACE
#define INTERFACE IApDbInfo
DECLARE_INTERFACE_(IApDbInfo, IUnknown)
{
public:
	DeclareIUnknownMembers(PURE);
	DeclareIApDbInfoMembers(PURE);
};

typedef ComSmartPointer <IApDbInfo, &IID_IApDbInfo> SPIApDbInfo;

class CApDbInfo : public IApDbInfo
{
public:
    CApDbInfo();
    ~CApDbInfo();
    
    DeclareIUnknownMembers(IMPL);
    DeclareIApDbInfoMembers(IMPL);

private:
    CApInfoArray            m_arrayApData;	     //For Ap Data
    CIndexMgrLogData        m_IndexMgrLogData;
    CCriticalSection        m_csData;
    CString                 m_stMachineName;
    LONG                    m_cRef;
    DWORD                   m_Init;
    DWORD                   m_Active;   
    HANDLE                  m_session;
    bool                    m_session_init;

private:
    void FreeItemsAndEmptyArray(CApInfoArray& array);
};

HRESULT CreateApDbInfo(IApDbInfo **ppApDbInfo);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\harray.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	harray.h
		Index mgr for IPSecmon

	FILE HISTORY:
    Nov 29  1999    Ning Sun     Created        

*/

#ifndef _HARRAY_H__
#define _HARRAY_H__


#include "afxmt.h"


extern const DWORD INDEX_TYPE_DEFAULT;

typedef enum _SORT_OPTIONS
{
	SORT_DESCENDING	= 0x00,
	SORT_ASCENDING	= 0x01

} SORT_OPTIONS;



typedef CArray<void *, void *> CIndexArray;
typedef int (__cdecl *PCOMPARE_FUNCTION)(const void *elem1, const void *elem2);

class CColumnIndex : public CIndexArray
{
public:
	CColumnIndex(DWORD dwIndexType, PCOMPARE_FUNCTION pfnCompare);

public:
	HRESULT Sort();
	VOID SetSortOption(DWORD dwSortOption) { m_dwSortOption = dwSortOption; }
	DWORD GetSortOption() { return m_dwSortOption; }
	DWORD GetType() { return m_dwIndexType; }
	void* GetIndexedItem(int nIndex);

protected:
	DWORD m_dwIndexType;
	DWORD m_dwSortOption;
	PCOMPARE_FUNCTION m_pfnCompare;
};

typedef CList<CColumnIndex*, CColumnIndex*> CIndexArrayList;

class CIndexManager
{
public:
	CIndexManager();
	virtual ~CIndexManager();

protected:
	CColumnIndex m_DefaultIndex;
	CIndexArrayList m_listIndicies;
	POSITION m_posCurrentIndex;

public:
	void Reset();

	int AddItem(void * pItem);
	int GetItemCount() { return (int)m_DefaultIndex.GetSize(); }

	void * GetItemData(int nIndex);

	virtual HRESULT Sort(
				DWORD SortType, 
				DWORD dwSortOption
				) { return hrOK; }
	
	DWORD GetCurrentIndexType();
	DWORD GetCurrentSortOption();
};

class CIndexMgrLogData : public CIndexManager
{
public:
	CIndexMgrLogData() : CIndexManager() {}

public:
    HRESULT SortLogData(
				DWORD SortType, 
				DWORD dwSortOption
				);


    HRESULT SortApData(
				DWORD SortType, 
				DWORD dwSortOption
				);
};

class CIndexMgrFWFilter : public CIndexManager
{
public:
	CIndexMgrFWFilter() : CIndexManager() {}

public:
    HRESULT SortFWFilters(
				DWORD SortType, 
				DWORD dwSortOption
				);
    HRESULT	ReverseFWFilters(
    			);
};


#endif //_HARRAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipctrl.cpp ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1996 - 1999 
//
// File:    ipctrl.cpp
//
// History:
//              Tony Romano             Created.
//  06/17/96    Abolade Gbadegesin      Revised.
//
// Implements the C++ class encapsulating the IP-address custom control.
//============================================================================

#include "stdafx.h"
extern "C" {
#include "ipaddr.h"
};

#include "ipctrl.h"




IPControl::IPControl( ) { m_hIPaddr = 0; }

IPControl::~IPControl( ) { }



BOOL
IPControl::Create(
    HWND        hParent,
    UINT        nID
    ) {

    ASSERT(IsWindow(hParent));

    if (hParent)    
        m_hIPaddr   = GetDlgItem(hParent, nID);

    return m_hIPaddr != NULL;   
}



LRESULT
IPControl::SendMessage(
    UINT        uMsg,
    WPARAM      wParam,
    LPARAM      lParam
    ) {

    ASSERT(IsWindow(m_hIPaddr));

    return ::SendMessage(m_hIPaddr, uMsg, wParam, lParam);
}



BOOL
IPControl::IsBlank(
    ) {

    return (BOOL)SendMessage(IP_ISBLANK, 0, 0);
}



VOID
IPControl::SetAddress(
    DWORD       ardwAddress[4]
    ) {

    SendMessage(
        IP_SETADDRESS, 0,
        MAKEIPADDRESS(
            ardwAddress[0], ardwAddress[1], ardwAddress[2], ardwAddress[3]
            )
        );
}



VOID
IPControl::SetAddress(
    DWORD       a1,
    DWORD       a2,
    DWORD       a3,
    DWORD       a4
    ) {

    SendMessage(IP_SETADDRESS, 0, MAKEIPADDRESS(a1,a2,a3,a4));
}



VOID
IPControl::SetAddress(
    LPCTSTR     lpszString
    ) {

    if (!lpszString) { ClearAddress(); }

    SendMessage(WM_SETTEXT, 0, (LPARAM)lpszString);
}


INT
IPControl::GetAddress(
    DWORD       *a1,
    DWORD       *a2,
    DWORD       *a3,
    DWORD       *a4
    ) {

    INT_PTR nSet;
    DWORD dwAddress;

    ASSERT(a1 && a2 && a3 && a4);

    if ((nSet = SendMessage(IP_GETADDRESS,0,(LPARAM)&dwAddress)) == 0) {

        *a1 = 0;
        *a2 = 0;
        *a3 = 0;
        *a4 = 0;
    }
    else {

        *a1 = FIRST_IPADDRESS( dwAddress );
        *a2 = SECOND_IPADDRESS( dwAddress );
        *a3 = THIRD_IPADDRESS( dwAddress );
        *a4 = FOURTH_IPADDRESS( dwAddress );
    }

    return (INT)nSet;
}


INT
IPControl::GetAddress(
    DWORD       ardwAddress[4]
    ) {

    INT_PTR nSet;
    DWORD dwAddress;

    if ((nSet = SendMessage(IP_GETADDRESS, 0, (LPARAM)&dwAddress )) == 0) {

        ardwAddress[0] = 0;
        ardwAddress[1] = 0;
        ardwAddress[2] = 0;
        ardwAddress[3] = 0;
    }
    else {

        ardwAddress[0] = FIRST_IPADDRESS( dwAddress );
        ardwAddress[1] = SECOND_IPADDRESS( dwAddress );
        ardwAddress[2] = THIRD_IPADDRESS( dwAddress );
        ardwAddress[3] = FOURTH_IPADDRESS( dwAddress );
    }

    return (INT)nSet;
}


INT
IPControl::GetAddress(
    CString&    address
    ) {

    INT_PTR c, nSet;
    DWORD dwAddress;

    nSet = SendMessage(IP_GETADDRESS, 0, (LPARAM)&dwAddress);

    address.ReleaseBuffer((int)(c = SendMessage(WM_GETTEXT, 256, (LPARAM)address.GetBuffer(256))));

    return (INT)nSet;
}


VOID
IPControl::SetFocusField(
    DWORD       dwField
    ) {

    SendMessage(IP_SETFOCUS, dwField, 0);
}


VOID
IPControl::ClearAddress(
    ) {

    SendMessage(IP_CLEARADDRESS, 0, 0);
}


VOID
IPControl::SetFieldRange(
    DWORD       dwField,
    DWORD       dwMin,
    DWORD       dwMax
    ) {

    SendMessage(IP_SETRANGE, dwField, MAKERANGE(dwMin,dwMax));
}

#if 0
WCHAR *
inet_ntoaw(
    struct in_addr  dwAddress
    ) {

    static WCHAR szAddress[16];

    mbstowcs(szAddress, inet_ntoa(*(struct in_addr *)&dwAddress), 16);

    return szAddress;
}


DWORD
inet_addrw(
    LPCWSTR     szAddressW
    ) {

    CHAR szAddressA[16];

    wcstombs(szAddressA, szAddressW, 16);

    return inet_addr(szAddressA);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\guids.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	guids.cpp
		IPSecMon snapin GUID definitions

	FILE HISTORY:
        
*/
#include "stdafx.h"


// MMC required node types

// {23DC5869-BD9F-46fd-AADD-1F869BA64FC3}
static const CLSID CLSID_IpsmSnapin = 
{ 0x23dc5869, 0xbd9f, 0x46fd, { 0xaa, 0xdd, 0x1f, 0x86, 0x9b, 0xa6, 0x4f, 0xc3 } };

// {A22B9703-F7C8-47bc-B705-18FEB5143ADB}
static const CLSID CLSID_IpsmSnapinExtension = 
{ 0xa22b9703, 0xf7c8, 0x47bc, { 0xb7, 0x5, 0x18, 0xfe, 0xb5, 0x14, 0x3a, 0xdb } };

// {F866248B-C56C-4638-BEB1-B9B90092C147}
static const GUID CLSID_IpsmSnapinAbout = 
{ 0xf866248b, 0xc56c, 0x4638, { 0xbe, 0xb1, 0xb9, 0xb9, 0x0, 0x92, 0xc1, 0x47 } };

//
// Scope pane node types
//

// {83F470CD-2FBA-42aa-980D-23F9BA576041}
static const GUID GUID_IpsmRootNodeType = 
{ 0x83f470cd, 0x2fba, 0x42aa, { 0x98, 0xd, 0x23, 0xf9, 0xba, 0x57, 0x60, 0x41 } };

// {22B98FB0-6BAB-42ec-93D3-6EB27F8E6EC9}
static const GUID GUID_IpsmServerNodeType = 
{ 0x22b98fb0, 0x6bab, 0x42ec, { 0x93, 0xd3, 0x6e, 0xb2, 0x7f, 0x8e, 0x6e, 0xc9 } };

// {980204D3-2AC0-4110-B6C9-10C432AC4116}
static const GUID GUID_IpsmFilterNodeType = 
{ 0x980204d3, 0x2ac0, 0x4110, { 0xb6, 0xc9, 0x10, 0xc4, 0x32, 0xac, 0x41, 0x16 } };


//
// result pane item GUIDs
//

// {42EB09D7-8ED3-441f-8FD8-B104E21D4BF8}
static const GUID GUID_IpsmSpecificFilterNodeType = 
{ 0x42eb09d7, 0x8ed3, 0x441f, { 0x8f, 0xd8, 0xb1, 0x4, 0xe2, 0x1d, 0x4b, 0xf8 } };

// {8E497957-E7CD-4bd9-A6EB-85E8DB4AA65F}
static const GUID GUID_IpsmMmPolicyNodeType = 
{ 0x8e497957, 0xe7cd, 0x4bd9, { 0xa6, 0xeb, 0x85, 0xe8, 0xdb, 0x4a, 0xa6, 0x5f } };

// {ADA99501-263F-4e5b-A556-CEA27861F3F4}
static const GUID GUID_QmNodeType = 
{ 0xada99501, 0x263f, 0x4e5b, { 0xa5, 0x56, 0xce, 0xa2, 0x78, 0x61, 0xf3, 0xf4 } };

// {63D386C2-5FDD-4575-B2AB-55697210D250}
static const GUID GUID_MmNodeType = 
{ 0x63d386c2, 0x5fdd, 0x4575, { 0xb2, 0xab, 0x55, 0x69, 0x72, 0x10, 0xd2, 0x50 } };


//
//  GUID for our fake ISpdInfo object
//

// {03429834-CB9C-469e-BD62-C1D098FDAF9D}
static const GUID IID_ISpdInfo = 
{ 0x3429834, 0xcb9c, 0x469e, { 0xbd, 0x62, 0xc1, 0xd0, 0x98, 0xfd, 0xaf, 0x9d } };

// {95E66368-CCA7-4b1d-B14D-6015F2539884}
static const GUID GUID_IpsmQmSANodeType = 
{ 0x95e66368, 0xcca7, 0x4b1d, { 0xb1, 0x4d, 0x60, 0x15, 0xf2, 0x53, 0x98, 0x84 } };

// {79180C18-FAF5-4f2a-BBD2-F7D4447A542E}
static const GUID GUID_IpsmQmPolicyNodeType = 
{ 0x79180c18, 0xfaf5, 0x4f2a, { 0xbb, 0xd2, 0xf7, 0xd4, 0x44, 0x7a, 0x54, 0x2e } };

// {5DC46910-D162-48f1-A8D9-0D86D262FCBD}
static const GUID GUID_IpsmMmFilterNodeType = 
{ 0x5dc46910, 0xd162, 0x48f1, { 0xa8, 0xd9, 0xd, 0x86, 0xd2, 0x62, 0xfc, 0xbd } };

// {EBB65C82-D249-4671-871B-1273AAB18989}
static const GUID GUID_IpsmMmSpFilterNodeType = 
{ 0xebb65c82, 0xd249, 0x4671, { 0x87, 0x1b, 0x12, 0x73, 0xaa, 0xb1, 0x89, 0x89 } };

// {1A0A65A3-E658-40c2-BF67-8849C220D3A2}
static const GUID GUID_IpsmMmSANodeType = 
{ 0x1a0a65a3, 0xe658, 0x40c2, { 0xbf, 0x67, 0x88, 0x49, 0xc2, 0x20, 0xd3, 0xa2 } };

//
//	GUID for IApDbInfo
//

// {68E67664-8528-4c2c-94AE-23D60B561FF3}
static const GUID IID_IApDbInfo = 
{ 0x68e67664, 0x8528, 0x4c2c, { 0x94, 0xae, 0x23, 0xd6, 0xb, 0x56, 0x1f, 0xf3 } };


//
// Guid for Fw Node Types
//

// {75D2956F-F197-494c-8152-C5B723246FE4}
static const GUID GUID_FilterNodeType = 
{ 0x75d2956f, 0xf197, 0x494c, { 0x81, 0x52, 0xc5, 0xb7, 0x23, 0x24, 0x6f, 0xe4 } };

// {87A70360-7380-409e-A358-92D0CB776080}
static const GUID GUID_LogNodeType= 
{ 0x87a70360, 0x7380, 0x409e, { 0xa3, 0x58, 0x92, 0xd0, 0xcb, 0x77, 0x60, 0x80 } };


// {798CEC60-63B4-4a89-86B3-9A02B99781EE}
static const GUID GUID_IpfmLogDataNodeType = 
{ 0x798cec60, 0x63b4, 0x4a89, { 0x86, 0xb3, 0x9a, 0x2, 0xb9, 0x97, 0x81, 0xee } };

// {43875DF0-14CF-4fd2-92C9-DBCC5050E5FD}
static const GUID GUID_IpfmFilterDataNodeType = 
{ 0x43875df0, 0x14cf, 0x4fd2, { 0x92, 0xc9, 0xdb, 0xcc, 0x50, 0x50, 0xe5, 0xfd } };

//
// Guid for wireless monitor
//

// {7F1EF63F-4FBC-4fa1-81EF-9E986CB3EACE}
static const GUID GUID_IpfmWirelessNodeType = 
{ 0x7f1ef63f, 0x4fbc, 0x4fa1, { 0x81, 0xef, 0x9e, 0x98, 0x6c, 0xb3, 0xea, 0xce } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\harray.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	hArray.cpp	
		Index manager for IPSecMon

	FILE HISTORY:
    Nov 29  1999    Ning Sun     Created

*/

#include "stdafx.h"
#include "spddb.h"
#include "harray.h"
#include "mbstring.h"
#include "spdutil.h"

extern const DWORD INDEX_TYPE_DEFAULT = 0;

int __cdecl CompareLogDataMsg(const void *pvElem1, const void *pvElem2);
int __cdecl CompareLogDataTime(const void *pvElem1, const void *pvElem2);
int __cdecl CompareLogDataCat(const void *pvElem1, const void *pvElem2);
int __cdecl CompareLogDataComp(const void *pvElem1, const void *pvElem2);
int __cdecl CompareLogDataLMAC(const void *pvElem1, const void *pvElem2);
int __cdecl CompareLogDataRMAC(const void *pvElem1, const void *pvElem2);
int __cdecl CompareLogDataSSID(const void *pvElem1, const void *pvElem2);

typedef int (__cdecl *PFNCompareProc)(const void *, const void *);

//This structure saves the pair of sort type and sort function
struct SortTypeAndCompareProcPair
{
	DWORD			dwType;
	PFNCompareProc	pCompareProc;
};

/* LogData sort types and sort functions
 * NULL means do nothing during sort
 */
SortTypeAndCompareProcPair TypeProcLogData[] = 
{ {IDS_COL_LOGDATA_MSG,             CompareLogDataMsg},
  {IDS_COL_LOGDATA_TIME,            CompareLogDataTime},
  {IDS_COL_LOGDATA_CAT,             CompareLogDataCat},
  {IDS_COL_LOGDATA_COMP_ID,         CompareLogDataComp},
  {IDS_COL_LOGDATA_SSID,            CompareLogDataSSID},
  {IDS_COL_LOGDATA_LOCAL_MAC_ADDR,  CompareLogDataLMAC},
  {IDS_COL_LOGDATA_REMOTE_MAC_ADDR, CompareLogDataRMAC},
  {INDEX_TYPE_DEFAULT,              NULL} };

//	{IDS_COL_APDATA_SSID, IDS_COL_APDATA_INF_MODE, IDS_COL_APDATA_MAC, IDS_COL_APDATA_GUID, IDS_COL_APDATA_PRIVACY, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // Access Point Data

SortTypeAndCompareProcPair TypeProcApData[] =
{
	{IDS_COL_APDATA_SSID, NULL /*CompareLogDataMsg*/},
	{IDS_COL_APDATA_INF_MODE, NULL /*CompareLogDataTime*/},
	{IDS_COL_APDATA_MAC, NULL},
	{IDS_COL_APDATA_GUID, NULL},
	{IDS_COL_APDATA_PRIVACY, NULL},
	{INDEX_TYPE_DEFAULT, NULL}		//NULL means do nothing during sort
};

CColumnIndex::CColumnIndex(DWORD dwIndexType, PCOMPARE_FUNCTION pfnCompare)
 :	CIndexArray(),
	m_dwIndexType(dwIndexType),
	m_pfnCompare(pfnCompare),
	m_dwSortOption(SORT_ASCENDING)
{
}

HRESULT CColumnIndex::Sort()
{
    if (NULL != m_pfnCompare)
        qsort(GetData(), (size_t)GetSize(), sizeof(void *), m_pfnCompare);
    
    return S_OK;
}

void* CColumnIndex::GetIndexedItem(int nIndex)
{
    return ((m_dwSortOption & SORT_ASCENDING)) ? GetAt(GetSize() - nIndex -1) 
        : GetAt(nIndex);
}


CIndexManager::CIndexManager()
    :  m_DefaultIndex(INDEX_TYPE_DEFAULT, NULL), /* Dont sort by default */
    m_posCurrentIndex(NULL)
{
}

CIndexManager::~CIndexManager()
{
    Reset();
}


void
CIndexManager::Reset()
{
    while (m_listIndicies.GetCount() > 0)
    {
        delete m_listIndicies.RemoveHead();
    }
    
    m_posCurrentIndex = NULL;
    
    m_DefaultIndex.RemoveAll();
}

int
CIndexManager::AddItem(void *pItem)
{
    return (int)m_DefaultIndex.Add(pItem);
}


void * CIndexManager::GetItemData(int nIndex)
{
    CColumnIndex * pIndex = NULL;
    
    if (NULL == m_posCurrentIndex)
    {
        //use the default index
        pIndex = &m_DefaultIndex;
    }
    else
    {
        pIndex = m_listIndicies.GetAt(m_posCurrentIndex);
    }
    
    Assert(pIndex);
    
    if (nIndex < pIndex->GetSize() && nIndex >= 0)
    {
        return pIndex->GetIndexedItem(nIndex);
    }
    else
    {
        Panic0("We dont have that index!");
        return NULL;
    }    
}

DWORD CIndexManager::GetCurrentIndexType()
{
    DWORD dwIndexType;
    
    if (m_posCurrentIndex)
    {
        CColumnIndex * pIndex = m_listIndicies.GetAt(m_posCurrentIndex);
        dwIndexType = pIndex->GetType();
    }
    else
    {
        dwIndexType = m_DefaultIndex.GetType();
    }
    
    return dwIndexType;
}

DWORD CIndexManager::GetCurrentSortOption()
{
    DWORD dwSortOption;
    
    if (m_posCurrentIndex)
    {
        CColumnIndex * pIndex = m_listIndicies.GetAt(m_posCurrentIndex);
        dwSortOption = pIndex->GetSortOption();
    }
    else
    {
        dwSortOption = m_DefaultIndex.GetSortOption();
    }
    
    return dwSortOption;
}

HRESULT
CIndexMgrLogData::SortLogData(DWORD dwSortType, 
                              DWORD dwSortOptions)
{
    HRESULT hr = hrOK;
    
    POSITION posLast;
    POSITION pos;
    DWORD    dwIndexType;
    
    pos = m_listIndicies.GetHeadPosition();
    while (pos)
    {
        posLast = pos;
        CColumnIndex * pIndex = m_listIndicies.GetNext(pos);
        
        dwIndexType = pIndex->GetType();
        
        // the index for this type already exists, just sort accordingly
        if (dwIndexType == dwSortType)
        {
            pIndex->SetSortOption(dwSortOptions);
            
            m_posCurrentIndex = posLast;
            
            return hrOK;
        }
    }
    
    // if not, create one
    CColumnIndex * pNewIndex = NULL;
    for (int i = 0; i < DimensionOf(TypeProcLogData); i++)
    {
        if (TypeProcLogData[i].dwType == dwSortType)
        {
            pNewIndex = new CColumnIndex(dwSortType, 
                                         TypeProcLogData[i].pCompareProc);
            break;
        }
    }
    Assert(pNewIndex);
    if (NULL == pNewIndex)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    // copy the array from the original index
    pNewIndex->Copy(m_DefaultIndex);
	
    pNewIndex->SetSortOption(dwSortOptions);
    pNewIndex->Sort();

    m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);

    return hr;
}


HRESULT
CIndexMgrLogData::SortApData(DWORD dwSortType, 
                             DWORD dwSortOptions)
{
    HRESULT hr = hrOK;
    
    POSITION posLast;
    POSITION pos;
    DWORD    dwIndexType;
    
    pos = m_listIndicies.GetHeadPosition();
    while (pos)
    {
        posLast = pos;
        CColumnIndex * pIndex = m_listIndicies.GetNext(pos);
        
        dwIndexType = pIndex->GetType();
        
        // the index for this type already exists, just sort accordingly
        if (dwIndexType == dwSortType)
        {
            pIndex->SetSortOption(dwSortOptions);
            
            m_posCurrentIndex = posLast;
            
            return hrOK;
        }
    }
    
    // if not, create one
    CColumnIndex * pNewIndex = NULL;
    for (int i = 0; i < DimensionOf(TypeProcApData); i++)
    {
        if (TypeProcApData[i].dwType == dwSortType)
        {
            pNewIndex = new CColumnIndex(dwSortType, TypeProcApData[i].pCompareProc);
            break;
        }
    }
    Assert(pNewIndex);
    if (NULL == pNewIndex)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    
    // copy the array from the original index
    pNewIndex->Copy(m_DefaultIndex);
    
    
    pNewIndex->SetSortOption(dwSortOptions);
    pNewIndex->Sort();
    
    m_posCurrentIndex = m_listIndicies.AddTail(pNewIndex);
    
    return hr;
}

/* CmpWStr
 * Compares two WStrs
 * Returns 
 * < 0 if wstr1 < wstr2
 *   0 if wstr1 == wstr2
 * > 0 if wstr1 > wstr2
 */
int CmpWStr(const wchar_t *pwstr1, const wchar_t *pwstr2)
{
    int nRetVal = 0;
 
    if (pwstr1 == pwstr2)
        nRetVal = 0;
    else if (NULL == pwstr1) 
        nRetVal = -1;
    else if (NULL == pwstr2)
        nRetVal = 1;
    else
        nRetVal =  _wcsicmp(pwstr1, pwstr2);

    return nRetVal;
}

/* CmpDWord
 * Compares two DWORDs
 * Returns 
 * < 0 if dw1 < dw2 
 *   0 if dw1 == dw2 
 * > 0 if dw1 > dw2 
 */
int CmpDWord(const DWORD dw1, const DWORD dw2)
{
    int nRetVal = 0;

    nRetVal = dw1 - dw2;

    return nRetVal;
}

/* CmpFileTime
 * Compares two FILETIMEs.
 * Returns 
 * -1 if ft1 < ft2
 *  0 if ft1 == ft2
 *  1 if ft1 > ft2
 */
int CmpFileTime(const FILETIME *pft1, const FILETIME *pft2)
{
    int nRetVal = 0;
    const ULONGLONG ullft1 = *(const UNALIGNED ULONGLONG UNALIGNED*) pft1;
    const ULONGLONG ullft2 = *(const UNALIGNED ULONGLONG UNALIGNED*) pft2;
    LONGLONG llDiff = 0;

    llDiff = ullft1 - ullft2;
    
    if (llDiff < 0)
        nRetVal = -1;
    else if (llDiff > 0)
        nRetVal = 1;

    return nRetVal;
}

/* CompareLogDataTime
 * Compares CLogDataInfo on the basis of its timestamp with another
 */
int __cdecl CompareLogDataTime(const void *pvElem1, const void *pvElem2)
{
    int nRetVal = 0;
    UNALIGNED PWZC_DB_RECORD pwzcDbRecord1 = 
        &((*(CLogDataInfo**)pvElem1)->m_wzcDbRecord);
    UNALIGNED PWZC_DB_RECORD pwzcDbRecord2 = 
        &((*(CLogDataInfo**)pvElem2)->m_wzcDbRecord);

    nRetVal=CmpFileTime((const FILETIME*) 
                        &(pwzcDbRecord1->timestamp),
                        (const FILETIME*)
                        &(pwzcDbRecord2->timestamp));
    return nRetVal;
}

/* CompareLogDataMsg
 * Compares CLogDataInfo on the basis of its message with another
 */
int __cdecl CompareLogDataMsg(const void *pvElem1, const void *pvElem2)
{
    int nRetVal = 0;
    PWZC_DB_RECORD pwzcDbRecord1 = 
        &((*(CLogDataInfo**)pvElem1)->m_wzcDbRecord);
    PWZC_DB_RECORD pwzcDbRecord2 = 
        &((*(CLogDataInfo**)pvElem2)->m_wzcDbRecord);
    
    nRetVal = CmpWStr( (LPWSTR) pwzcDbRecord1->message.pData, 
                       (LPWSTR) pwzcDbRecord2->message.pData);
    return nRetVal;
}

/* CompareLogDataLMAC
 * Compares CLogDataInfo on the basis of its local MAC address with another
 */
int __cdecl CompareLogDataLMAC(const void *pvElem1, const void *pvElem2)
{
    int nRetVal = 0;
    PWZC_DB_RECORD pwzcDbRecord1 = 
        &((*(CLogDataInfo**)pvElem1)->m_wzcDbRecord);
    PWZC_DB_RECORD pwzcDbRecord2 = 
        &((*(CLogDataInfo**)pvElem2)->m_wzcDbRecord);
    
    nRetVal = CmpWStr( (LPWSTR) pwzcDbRecord1->localmac.pData, 
                       (LPWSTR) pwzcDbRecord2->localmac.pData);
    return nRetVal;
}

/* CompareLogDataRMAC
 * Compares CLogDataInfo on the basis of its remote MAC address with another
 */
int __cdecl CompareLogDataRMAC(const void *pvElem1, const void *pvElem2)
{
    int nRetVal = 0;
    PWZC_DB_RECORD pwzcDbRecord1=&((*(CLogDataInfo**)pvElem1)->m_wzcDbRecord);
    PWZC_DB_RECORD pwzcDbRecord2=&((*(CLogDataInfo**)pvElem2)->m_wzcDbRecord);
    
    nRetVal = CmpWStr( (LPWSTR) pwzcDbRecord1->remotemac.pData, 
                       (LPWSTR) pwzcDbRecord2->remotemac.pData);
    return nRetVal;
}

/* CompareLogDataSSID
 * Compares CLogDataInfo on the basis of its SSID with another
 */
int __cdecl CompareLogDataSSID(const void *pvElem1, const void *pvElem2)
{
    int nRetVal = 0;
    PWZC_DB_RECORD pwzcDbRecord1=&((*(CLogDataInfo**)pvElem1)->m_wzcDbRecord);
    PWZC_DB_RECORD pwzcDbRecord2=&((*(CLogDataInfo**)pvElem2)->m_wzcDbRecord);
    
    nRetVal = CmpWStr( (LPWSTR) pwzcDbRecord1->ssid.pData, 
                       (LPWSTR) pwzcDbRecord2->ssid.pData);
    return nRetVal;
}

/* CompareLogDataCat
 * Compares two CLogDataInfo on the basis of its category with another
 */
int __cdecl CompareLogDataCat(const void *pvElem1, const void *pvElem2)
{
    int nRetVal = 0;
    PWZC_DB_RECORD pwzcDbRecord1=&((*(CLogDataInfo**)pvElem1)->m_wzcDbRecord);
    PWZC_DB_RECORD pwzcDbRecord2=&((*(CLogDataInfo**)pvElem2)->m_wzcDbRecord);

    nRetVal = CmpDWord(pwzcDbRecord1->category, pwzcDbRecord2->category);

    return nRetVal;    
}

/* CompareLogDataComp
 * Compares two CLogDataInfo on the basis of its component with another
 */
int __cdecl CompareLogDataComp(const void *pvElem1, const void *pvElem2)
{
    int nRetVal = 0;
    PWZC_DB_RECORD pwzcDbRecord1=&((*(CLogDataInfo**)pvElem1)->m_wzcDbRecord);
    PWZC_DB_RECORD pwzcDbRecord2=&((*(CLogDataInfo**)pvElem2)->m_wzcDbRecord);

    nRetVal = CmpDWord(pwzcDbRecord1->componentid, pwzcDbRecord2->componentid);

    return nRetVal;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipsmcomp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    ipsmcomp.cpp
        This file contains the derived implementations from CComponent
        and CComponentData for the wlanmon snapin.

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "root.h"
#include "server.h"

#include <atlimpl.cpp>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DWORD gdwIpsmSnapVersion;

UINT aColumns[IPSECMON_NODETYPE_MAX][MAX_COLUMNS] =
{
    {IDS_ROOT_NAME, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {IDS_SERVER_NAME, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0},	//IPFWMON_FILTER
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0},	//IPFWMON_LOG
    // Wireless Log
    {IDS_COL_LOGDATA_COMP_ID, IDS_COL_LOGDATA_CAT, IDS_COL_LOGDATA_TIME, 
     IDS_COL_LOGDATA_LOCAL_MAC_ADDR, IDS_COL_LOGDATA_REMOTE_MAC_ADDR, 
     IDS_COL_LOGDATA_SSID, IDS_COL_LOGDATA_MSG, 0, 0, 0, 0, 0, 0, 0}, 
    // Access Point Data
    {IDS_COL_APDATA_SSID, IDS_COL_APDATA_INF_MODE, IDS_COL_APDATA_MAC, 
     IDS_COL_APDATA_PRIVACY, IDS_COL_APDATA_RSSI, IDS_COL_APDATA_CHANNEL, 
     IDS_COL_APDATA_RATE, IDS_COL_APDATA_GUID, 0, 0, 0, 0, 0},
    {0,0,0,0,0,0,0,0,0,0,0,0,0,0}
};

//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//

int aColumnWidths[IPSECMON_NODETYPE_MAX][MAX_COLUMNS] =
{   
    {200, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH}, // IPSMSNAP_ROOT
    {200, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH}, // IPSMSNAP_SERVER
    {AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH}, // IPSECMON_LOG
    {AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH}, // IPSECMON_MAIN_MODE
    // Wireless Log
    {90, 90, 150, 125, 125, 80, 350, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH}, 
    // Access Point
    {150, 150, 150, 150, AUTO_WIDTH, AUTO_WIDTH, 150, 250, 
     AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH}, 
    {AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, AUTO_WIDTH, 
     AUTO_WIDTH, AUTO_WIDTH}
};

#define HI HIDDEN
#define EN ENABLED

MMC_CONSOLE_VERB g_ConsoleVerbs[] =
{
    MMC_VERB_OPEN,
    MMC_VERB_COPY,
    MMC_VERB_PASTE,
    MMC_VERB_DELETE,
    MMC_VERB_PROPERTIES,
    MMC_VERB_RENAME,
    MMC_VERB_REFRESH,
    MMC_VERB_PRINT
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStates[IPSECMON_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, HI, HI, HI, HI}, // IPSMSNAP_ROOT
    {HI, HI, HI, HI, HI, HI, HI, HI}, // IPSMSNAP_SERVER
    {HI, HI, HI, HI, HI, HI, EN, HI}, // IPSECMON_FILTER
    {HI, HI, HI, HI, HI, HI, HI, HI}, // IPSECMON_LOG,
    {HI, HI, HI, EN, HI, HI, EN, HI}, // IPFWMON_LOGDATA
    {HI, HI, HI, HI, HI, HI, EN, HI}, // WLANMON_APDATA
    {HI, HI, HI, HI, HI, HI, EN, HI}, // WLANMON_APDATA_ITEM
    {HI, HI, HI, HI, EN, HI, EN, HI}  // IPFWMON_LOGDATA_ITEM
};

// default states for the console verbs
MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[IPSECMON_NODETYPE_MAX][ARRAYLEN(g_ConsoleVerbs)] =
{
    {HI, HI, HI, HI, HI, HI, HI, HI}, // IPSMSNAP_ROOT
    {HI, HI, HI, HI, HI, HI, HI, HI}, // IPSMSNAP_SERVER
    {HI, HI, HI, HI, HI, HI, EN, HI}, // IPSECMON_FILTER
    {HI, HI, HI, HI, HI, HI, HI, HI}, // IPSECMON_LOG,
    {HI, HI, HI, EN, HI, HI, EN, HI}, // IPFWMON_LOGDATA
    {HI, HI, HI, HI, HI, HI, EN, HI}, // WLANMON_APDATA
    {HI, HI, HI, HI, HI, HI, EN, HI}, // WLANMON_APDATA_ITEM
    {HI, HI, HI, HI, EN, HI, EN, HI}  // IPFWMON_LOGDATA_ITEM
};

//TODO
// Help ID array for help on scope items
DWORD g_dwMMCHelp[IPSECMON_NODETYPE_MAX] =
{
    IPSMSNAP_HELP_ROOT,                // IPSMSNAP_ROOT
    IPSMSNAP_HELP_SERVER,              // IPSMSNAP_SERVER
    IPSMSNAP_HELP_PROVIDER,            // IPSECMON_QM_SA
	IPSMSNAP_HELP_ROOT,				   // IPSECMON_FILTAER
    IPSMSNAP_HELP_DEVICE,              // IPSECMON_QM_SA_ITEM
};

// icon defines
UINT g_uIconMap[ICON_IDX_MAX + 1][2] = 
{
    {IDI_ICON01,          ICON_IDX_SERVER},
    {IDI_ICON02,          ICON_IDX_SERVER_BUSY},
    {IDI_ICON03,          ICON_IDX_SERVER_CONNECTED},
    {IDI_ICON04,          ICON_IDX_SERVER_LOST_CONNECTION},
    {IDI_ICON05,          ICON_IDX_MACHINE},
    {IDI_ICON06,          ICON_IDX_FOLDER_CLOSED},
    {IDI_ICON07,          ICON_IDX_FOLDER_OPEN},
    {IDI_WLANMON_SNAPIN,  ICON_IDX_PRODUCT},
    {IDI_IPSM_FILTER,     ICON_IDX_FILTER},
    {IDI_IPSM_POLICY,     ICON_IDX_POLICY},
    {IDI_LOG_ERROR,       ICON_IDX_LOGDATA_ERROR},
    {IDI_LOG_WARNING,     ICON_IDX_LOGDATA_WARNING},
    {IDI_LOG_INFO,        ICON_IDX_LOGDATA_INFORMATION},
    {IDI_LOG_UNKNOWN,     ICON_IDX_LOGDATA_UNKNOWN},
    {IDI_AP_ADHOC,        ICON_IDX_AP_ADHOC},
    {IDI_AP_INFRA,        ICON_IDX_AP_INFRA},
    {IDI_AP_ASSOC_ADHOC,  ICON_IDX_AP_ASSOC_ADHOC},
    {IDI_AP_ASSOC_INFRA,  ICON_IDX_AP_ASSOC_INFRA},
    {0, 0}
};

/*!--------------------------------------------------------------------------
    GetSystemMessage
        Use FormatMessage() to get a system error message
    Author: EricDav
 ---------------------------------------------------------------------------*/
LONG 
GetSystemMessage 
(
    UINT    nId,
    TCHAR * chBuffer,
    int     cbBuffSize 
)
{
    TCHAR * pszText = NULL ;
    HINSTANCE hdll = NULL ;

    DWORD flags = FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    //  Interpret the error.  Need to special case
    //  the lmerr & ntstatus ranges, as well as
    //  dhcp server error messages.
    //

	if( nId >= NERR_BASE && nId <= MAX_NERR )
    {
        hdll = LoadLibrary( _T("netmsg.dll") );
    }
    else if( nId >= 0x40000000L )
    {
        hdll = LoadLibrary( _T("ntdll.dll") );
    }

    if( hdll == NULL )
    {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    //  Let FormatMessage do the dirty work.
    //
    DWORD dwResult = ::FormatMessage( flags,
                      (LPVOID) hdll,
                      nId,
                      0,
                      chBuffer,
                      cbBuffSize,
                      NULL ) ;

    if( hdll != NULL )
    {
        LONG err = GetLastError();
        FreeLibrary( hdll );
        if ( dwResult == 0 )
        {
            ::SetLastError( err );
        }
    }

    return dwResult ? 0 : ::GetLastError() ;
}

/*!--------------------------------------------------------------------------
    LoadMessage
        Loads the error message from the correct DLL.
    Author: EricDav
 ---------------------------------------------------------------------------*/
BOOL
LoadMessage 
(
    UINT    nIdPrompt,
    TCHAR * chMsg,
    int     nMsgSize
)
{
    BOOL bOk;

    //
    // Substitute a friendly message for "RPC server not
    // available" and "No more endpoints available from
    // the endpoint mapper".
    //
	if (nIdPrompt == RPC_S_UNKNOWN_IF)
	{
		nIdPrompt = IDS_ERR_SPD_DOWN;
	}
	else if (nIdPrompt == RPC_S_SERVER_UNAVAILABLE)
	{
		nIdPrompt = IDS_ERR_SPD_UNAVAILABLE;
	}
    

    //
    //  If it's a socket error or our error, the text is in our resource fork.
    //  Otherwise, use FormatMessage() and the appropriate DLL.
    //
    if (nIdPrompt >= IDS_ERR_BASE && nIdPrompt < IDS_MESG_MAX)
    {
        //
        //  It's in our resource fork
        //
        bOk = ::LoadString( AfxGetInstanceHandle(), nIdPrompt, chMsg, nMsgSize ) != 0 ;
    }
    else
    {
        //
        //  It's in the system somewhere.
        //
        bOk = GetSystemMessage( nIdPrompt, chMsg, nMsgSize ) == 0 ;
    }

    //
    //  If the error message did not compute, replace it.
    //
    if ( ! bOk ) 
    {
        TCHAR chBuff [STRING_LENGTH_MAX] ;
        static const TCHAR * pszReplacement = _T("System Error: %ld");
        const TCHAR * pszMsg = pszReplacement ;

        //
        //  Try to load the generic (translatable) error message text
        //
        if ( ::LoadString( AfxGetInstanceHandle(), IDS_ERR_MESSAGE_GENERIC, 
            chBuff, DimensionOf(chBuff) ) != 0 ) 
        {
            pszMsg = chBuff ;
        }
        ::wsprintf( chMsg, pszMsg, nIdPrompt ) ;
    }

    return bOk;
}

/*!--------------------------------------------------------------------------
    IpsmMessageBox
        Puts up a message box with the corresponding error text.
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
IpsmMessageBox 
(
    UINT            nIdPrompt,
    UINT            nType,
    const TCHAR *   pszSuffixString,
    UINT            nHelpContext 
)
{
    TCHAR chMesg [4000] = {0};
    BOOL bOk ;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(chMesg[0]));
    if ( pszSuffixString ) 
    {
        ::lstrcat( chMesg, _T("  ") ) ;
        ::lstrcat( chMesg, pszSuffixString ) ; 
    }

    return ::AfxMessageBox( chMesg, nType, nHelpContext ) ;
}

/*!--------------------------------------------------------------------------
    IpsmMessageBoxEx
        Puts up a message box with the corresponding error text.
    Author: EricDav
 ---------------------------------------------------------------------------*/
int 
IpsmMessageBoxEx
(
    UINT        nIdPrompt,
    LPCTSTR     pszPrefixMessage,
    UINT        nType,
    UINT        nHelpContext
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR       chMesg[4000] = {0};
    CString     strMessage;
    BOOL        bOk;

    bOk = LoadMessage(nIdPrompt, chMesg, sizeof(chMesg)/sizeof(chMesg[0]));
    if ( pszPrefixMessage ) 
    {
        strMessage = pszPrefixMessage;
        strMessage += _T("\n");
        strMessage += _T("\n");
        strMessage += chMesg;
    }
    else
    {
        strMessage = chMesg;
    }

    return AfxMessageBox(strMessage, nType, nHelpContext);
}

/*---------------------------------------------------------------------------
    Class CIpsmComponent implementation
 ---------------------------------------------------------------------------*/
CIpsmComponent::CIpsmComponent()
{
    m_pbmpToolbar = NULL;
}

CIpsmComponent::~CIpsmComponent()
{
    if (m_pbmpToolbar)
    {
        delete m_pbmpToolbar;
        m_pbmpToolbar = NULL;
    }
}

STDMETHODIMP CIpsmComponent::InitializeBitmaps(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(m_spImageList != NULL);
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(m_spImageList->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CIpsmComponent::QueryDataObject
        Implementation of IComponent::QueryDataObject.  We need this for
        virtual listbox support.  MMC calls us back normally with the cookie
        we handed it...  In the case of the VLB, it hands us the index of 
        the item.  So, we need to do some extra checking...
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponent::QueryDataObject
(
    MMC_COOKIE              cookie, 
    DATA_OBJECT_TYPES       type,
    LPDATAOBJECT*           ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    SPITFSNode          spSelectedNode;
    SPITFSResultHandler spResultHandler;
    long                lViewOptions;
    LPOLESTR            pViewType;
    CDataObject *       pDataObject;

    COM_PROTECT_TRY
    {
        // check to see what kind of result view type the selected node has
        CORg (GetSelectedNode(&spSelectedNode));
        CORg (spSelectedNode->GetResultHandler(&spResultHandler));
   
        CORg (spResultHandler->OnGetResultViewType(this, spSelectedNode->GetData(TFS_DATA_COOKIE), &pViewType, &lViewOptions));

        if ( (lViewOptions & MMC_VIEW_OPTIONS_OWNERDATALIST) ||
             (cookie == MMC_MULTI_SELECT_COOKIE) )
        {
            if (cookie == MMC_MULTI_SELECT_COOKIE)
            {
                // this is a special case for multiple select.  We need to build a list
                // of GUIDs and the code to do this is in the handler...
                spResultHandler->OnCreateDataObject(this, cookie, type, ppDataObject);
            }
            else
            {
                // this node has a virtual listbox for the result pane.  Gerenate
                // a special data object using the selected node as the cookie
                Assert(m_spComponentData != NULL);
                CORg (m_spComponentData->QueryDataObject(reinterpret_cast<MMC_COOKIE>((ITFSNode *) spSelectedNode), type, ppDataObject));
            }

            pDataObject = reinterpret_cast<CDataObject *>(*ppDataObject);
            pDataObject->SetVirtualIndex((int) cookie);
        }
        else
        {
            // just forward this to the component data
            Assert(m_spComponentData != NULL);
            CORg (m_spComponentData->QueryDataObject(cookie, type, ppDataObject));
        }

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CIpsmComponent::CompareObjects
		Implementation of IComponent::CompareObjects
		MMC calls this to compare two objects
        We override this for the virtual listbox case.  With a virtual listbox,
        the cookies are the same, but the index in the internal structs 
        indicate which item the dataobject refers to.  So, we need to look
        at the indicies instead of just the cookies.
	Author: 
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponent::CompareObjects
(
	LPDATAOBJECT lpDataObjectA, 
	LPDATAOBJECT lpDataObjectB
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
		return E_POINTER;

    // Make sure both data object are mine
    SPINTERNAL spA;
    SPINTERNAL spB;
    HRESULT hr = S_FALSE;

	COM_PROTECT_TRY
	{
		spA = ExtractInternalFormat(lpDataObjectA);
		spB = ExtractInternalFormat(lpDataObjectB);

		if (spA != NULL && spB != NULL)
        {
			if (spA->m_cookie != spB->m_cookie)
			{
				hr = S_FALSE;
			}
			else
			{
				if (spA->HasVirtualIndex() && spB->HasVirtualIndex())
				{
					hr = (spA->GetVirtualIndex() == spB->GetVirtualIndex()) ? S_OK : S_FALSE;
				}
				else
				{
					hr = S_OK;
				}
			}
        }
	}
	COM_PROTECT_CATCH

    return hr;
}


/*!--------------------------------------------------------------------------
    CIpsmComponentData::SetControlbar
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmComponent::SetControlbar
(
    LPCONTROLBAR    pControlbar
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    if (pControlbar)
    {
    }

    // store the control bar away for future use
    m_spControlbar.Set(pControlbar);

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::ControlbarNotify
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponent::ControlbarNotify
(
    MMC_NOTIFY_TYPE event, 
    LPARAM          arg, 
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnSnapinHelp
        -
    Author: EricDav
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponent::OnSnapinHelp
(
    LPDATAOBJECT    pDataObject,
    LPARAM          arg, 
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = hrOK;

    //help info here
    HtmlHelpA(NULL, "infrared.chm", HH_DISPLAY_TOPIC, 0);

    return hr;
}

/*---------------------------------------------------------------------------
    Class CIpsmComponentData implementation
 ---------------------------------------------------------------------------*/
CIpsmComponentData::CIpsmComponentData()
{
    gdwIpsmSnapVersion = IPSMSNAP_VERSION;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnInitialize
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIpsmComponentData::OnInitialize(LPIMAGELIST pScopeImage)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HICON   hIcon;

    for (int i = 0; i < ICON_IDX_MAX; i++)
    {
        hIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(g_uIconMap[i][0]));
        if (hIcon)
        {
            // call mmc
            VERIFY(SUCCEEDED(pScopeImage->ImageListSetIcon(reinterpret_cast<LONG_PTR*>(hIcon), g_uIconMap[i][1])));
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnDestroy
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP CIpsmComponentData::OnDestroy()
{
    m_spNodeMgr.Release();
    return hrOK;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnInitializeNodeMgr
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponentData::OnInitializeNodeMgr
(
    ITFSComponentData * pTFSCompData, 
    ITFSNodeMgr *       pNodeMgr
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // For now create a new node handler for each new node,
    // this is rather bogus as it can get expensive.  We can
    // consider creating only a single node handler for each
    // node type.
    CIpsmRootHandler *  pHandler = NULL;
    SPITFSNodeHandler   spHandler;
    SPITFSNode          spNode;
    HRESULT             hr = hrOK;

    try
    {
        pHandler = new CIpsmRootHandler(pTFSCompData);

        // Do this so that it will get released correctly
        spHandler = pHandler;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }
    CORg( hr );
    
    // Create the root node for this sick puppy
    CORg( CreateContainerTFSNode(&spNode,
                                 &GUID_IpsmRootNodeType,
                                 pHandler,
                                 pHandler,       /* result handler */
                                 pNodeMgr) );

    // Need to initialize the data for the root node
    pHandler->InitializeNode(spNode);   

    CORg( pNodeMgr->SetRootNode(spNode) );
    m_spRootNode.Set(spNode);

    //Add help
    pTFSCompData->SetHTMLHelpFileName(_T("IRsnap.chm"));
Error:  
    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnCreateComponent
        -
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponentData::OnCreateComponent
(
    LPCOMPONENT *ppComponent
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    ASSERT(ppComponent != NULL);
    
    HRESULT           hr = hrOK;
    CIpsmComponent *  pComp = NULL;

    try
    {
        pComp = new CIpsmComponent;
        pComp->Construct(m_spNodeMgr,
                         static_cast<IComponentData *>(this),
                         m_spTFSComponentData);
        *ppComponent = static_cast<IComponent *>(pComp);        
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::GetCoClassID
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(const CLSID *) 
CIpsmComponentData::GetCoClassID()
{
    return &CLSID_IpsmSnapin;
}

/*!--------------------------------------------------------------------------
    CIpsmComponentData::OnCreateDataObject
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmComponentData::OnCreateDataObject
(
    MMC_COOKIE          cookie, 
    DATA_OBJECT_TYPES   type, 
    IDataObject **      ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

    CDataObject *   pObject = NULL;
    SPIDataObject   spDataObject;
    
    pObject = new CDataObject;
    spDataObject = pObject; // do this so that it gets released correctly
                        
    Assert(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*GetCoClassID());

    pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
                                    reinterpret_cast<void**>(ppDataObject));
}

///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
STDMETHODIMP 
CIpsmComponentData::GetClassID
(
    CLSID *pClassID
)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_IpsmSnapin;

    return hrOK;
}

STDMETHODIMP 
CIpsmComponentData::IsDirty()
{
    HRESULT hr = hrFalse;

    if (m_spRootNode->GetData(TFS_DATA_DIRTY))
    {
        hr = hrOK;
    }
    
    return hr;
}

STDMETHODIMP 
CIpsmComponentData::Load
(
    IStream *pStm
)
{
    HRESULT     hr = hrOK;
    DWORD       dwSavedVersion;
    CString     str;
    int         i, j;
    
    ASSERT(pStm);

    CStringArray strArrayName;
    CDWordArray dwArrayRefreshInterval;
    CDWordArray dwArrayOptions;
    CDWordArray dwArrayColumnInfo;

    ASSERT(pStm);
    
    CIpsmRootHandler * pRootHandler = GETHANDLER(CIpsmRootHandler, m_spRootNode);

    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_READ);    
    
    // read the version of the file format
    DWORD dwFileVersion;
    CORg(xferStream.XferDWORD(IPSMSTRM_TAG_VERSION, &dwFileVersion));
    if (dwFileVersion < IPSMSNAP_FILE_VERSION)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        AfxMessageBox(IDS_ERR_OLD_CONSOLE_FILE);
        return hr;
    }

    // Read the version # of the admin tool
    CORg(xferStream.XferDWORD(IPSMSTRM_TAG_VERSIONADMIN, &dwSavedVersion));
    if (dwSavedVersion < gdwIpsmSnapVersion)
    {
        // File is an older version.  Warn the user and then don't
        // load anything else
        Assert(FALSE);
    }

    // now read all of the server information
    CORg(xferStream.XferCStringArray(IPSMSTRM_TAG_SERVER_NAME, &strArrayName));
    CORg(xferStream.XferDWORDArray(IPSMSTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval));
    CORg(xferStream.XferDWORDArray(IPSMSTRM_TAG_SERVER_OPTIONS, &dwArrayOptions));

    // now load the column information
    for (i = 0; i < NUM_SCOPE_ITEMS; i++)
    {
        CORg(xferStream.XferDWORDArray(IPSMSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo));

        for (j = 0; j < MAX_COLUMNS; j++)
        {
            aColumnWidths[i][j] = dwArrayColumnInfo[j];
        }

    }

    // now create the servers based on the information
    for (i = 0; i < strArrayName.GetSize(); i++)
    {
        //
        // now create the server object
        //
        pRootHandler->AddServer(NULL, 
                                strArrayName[i],
                                FALSE, 
                                dwArrayOptions[i], 
                                dwArrayRefreshInterval[i],
                                FALSE,
                                0,
                                0);
    }

Error:
    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}


STDMETHODIMP 
CIpsmComponentData::Save
(
    IStream *pStm, 
    BOOL     fClearDirty
)
{
    HRESULT hr = hrOK;
    CStringArray strArrayName;
    CDWordArray dwArrayRefreshInterval;
    CDWordArray dwArrayOptions;
    CDWordArray dwArrayColumnInfo;

    ASSERT(pStm);
    
    // set the mode for this stream
    XferStream xferStream(pStm, XferStream::MODE_WRITE);    
    CString str;

    // Write the version # of the file format
    DWORD dwFileVersion = IPSMSNAP_FILE_VERSION;
    xferStream.XferDWORD(IPSMSTRM_TAG_VERSION, &dwFileVersion);
    
    // Write the version # of the admin tool
    xferStream.XferDWORD(IPSMSTRM_TAG_VERSIONADMIN, &gdwIpsmSnapVersion);

    //
    // Build our array of servers
    //
    int nNumServers = 0, nVisibleCount = 0;
    hr = m_spRootNode->GetChildCount(&nVisibleCount, &nNumServers);

    strArrayName.SetSize(nNumServers);
    dwArrayRefreshInterval.SetSize(nNumServers);
    dwArrayOptions.SetSize(nNumServers);
    dwArrayColumnInfo.SetSize(MAX_COLUMNS);
    

    //
    // loop and save off all the server's attributes
    //
    SPITFSNodeEnum spNodeEnum;
    SPITFSNode spCurrentNode;
    ULONG nNumReturned = 0;
    int nCount = 0;

    m_spRootNode->GetEnum(&spNodeEnum);

    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
    {
        CIpsmServer * pServer = GETHANDLER(CIpsmServer, spCurrentNode);

        // query the server for it's options:
        // auto refresh
        dwArrayRefreshInterval[nCount] = pServer->GetAutoRefreshInterval();
        dwArrayOptions[nCount] = pServer->GetOptions();

        // put the information in our array
        strArrayName[nCount] = pServer->GetName();

        // go to the next node
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);

        nCount++;
    }

    // now write out all of the server information
    xferStream.XferCStringArray(IPSMSTRM_TAG_SERVER_NAME, &strArrayName);
    xferStream.XferDWORDArray(IPSMSTRM_TAG_SERVER_REFRESH_INTERVAL, &dwArrayRefreshInterval);
    xferStream.XferDWORDArray(IPSMSTRM_TAG_SERVER_OPTIONS, &dwArrayOptions);

    // now save the column information
    for (int i = 0; i < NUM_SCOPE_ITEMS; i++)
    {
        for (int j = 0; j < MAX_COLUMNS; j++)
        {
            dwArrayColumnInfo[j] = aColumnWidths[i][j];
        }

        xferStream.XferDWORDArray(IPSMSTRM_TAG_COLUMN_INFO, &dwArrayColumnInfo);
    }


    if (fClearDirty)
    {
        m_spRootNode->SetData(TFS_DATA_DIRTY, FALSE);
    }

    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}


STDMETHODIMP 
CIpsmComponentData::GetSizeMax
(
    ULARGE_INTEGER *pcbSize
)
{
    ASSERT(pcbSize);

    // Set the size of the string to be saved
    ULISet32(*pcbSize, 10000);

    return S_OK;
}

STDMETHODIMP 
CIpsmComponentData::InitNew()
{
    return hrOK;
}

HRESULT 
CIpsmComponentData::FinalConstruct()
{
    HRESULT             hr = hrOK;
    
    hr = CComponentData::FinalConstruct();
    
    if (FHrSucceeded(hr))
    {
        m_spTFSComponentData->GetNodeMgr(&m_spNodeMgr);
    }
    return hr;
}

void 
CIpsmComponentData::FinalRelease()
{
    CComponentData::FinalRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipsmcomp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    ipsmcomp.h
        This file contains the derived prototypes from CComponent
        and CComponentData for the IPSECMON snapin.

    FILE HISTORY:
        
*/

#ifndef _IPSMCOMP_H
#define _IPSMCOMP_H

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

#ifndef _COMPONT_H_
#include "compont.h"
#endif

#ifndef _XSTREAM_H
#include "xstream.h"
#endif

#define COLORREF_PINK   0x00FF00FF

//  Use FormatMessage() to get a system error message
LONG GetSystemMessage ( UINT nId, TCHAR * chBuffer, int cbBuffSize ) ;

BOOL LoadMessage (UINT nIdPrompt, TCHAR * chMsg, int nMsgSize);

//  Surrogate AfxMessageBox replacement for error message filtering.
int IpsmMessageBox(UINT nIdPrompt, 
                   UINT nType = MB_OK, 
                   const TCHAR * pszSuffixString = NULL,
                   UINT nHelpContext = -1);

int IpsmMessageBoxEx(UINT    nIdPrompt, 
                     LPCTSTR pszPrefixMessage,
                     UINT    nType = MB_OK, 
                     UINT    nHelpContext = -1);

enum IPSMSTRM_TAG
{
    IPSMSTRM_TAG_VERSION =                  XFER_TAG(1, XFER_DWORD),
    IPSMSTRM_TAG_VERSIONADMIN =             XFER_TAG(2, XFER_DWORD),
    IPSMSTRM_TAG_SERVER_NAME =              XFER_TAG(3, XFER_STRING_ARRAY),
    IPSMSTRM_TAG_SERVER_REFRESH_INTERVAL =  XFER_TAG(4, XFER_DWORD_ARRAY),
    IPSMSTRM_TAG_COLUMN_INFO =              XFER_TAG(5, XFER_DWORD_ARRAY),
    IPSMSTRM_TAG_SERVER_OPTIONS =           XFER_TAG(6, XFER_DWORD_ARRAY),
    IPSMSTRM_TAG_SERVER_LINE_SIZE =         XFER_TAG(7, XFER_DWORD_ARRAY),
    IPSMSTRM_TAG_SERVER_PHONE_SIZE =        XFER_TAG(8, XFER_DWORD_ARRAY)
};

/////////////////////////////////////////////////////////////////////////////
// CIpsmComponentData

class CIpsmComponentData :
    public CComponentData,
    public CComObjectRoot
{
public:
    
BEGIN_COM_MAP(CIpsmComponentData)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISnapinHelp)
END_COM_MAP()
            
    // These are the interfaces that we MUST implement

    // We will implement our common behavior here, with the derived
    // classes implementing the specific behavior.
    DeclareIPersistStreamInitMembers(IMPL)
    DeclareITFSCompDataCallbackMembers(IMPL)

    CIpsmComponentData();

    HRESULT FinalConstruct();
    void FinalRelease();
    
protected:
    SPITFSNodeMgr   m_spNodeMgr;
    SPITFSNode      m_spRootNode;

// Notify handler declarations
private:
};

/////////////////////////////////////////////////////////////////////////////
// CIpsmComponent
class CIpsmComponent : 
    public TFSComponent
{
public:
    CIpsmComponent();
    ~CIpsmComponent();

    STDMETHOD(InitializeBitmaps)(MMC_COOKIE cookie);
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param); 
    STDMETHOD(QueryDataObject)(MMC_COOKIE           cookie, 
                               DATA_OBJECT_TYPES    type,
                               LPDATAOBJECT*        ppDataObject);
	STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);
    STDMETHOD(OnSnapinHelp)(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param);

//Attributes
private:
    SPIToolbar          m_spToolbar;    // Toolbar
    CBitmap*            m_pbmpToolbar;  // Imagelist for toolbar
};

/*---------------------------------------------------------------------------
    This is how the DHCP snapin implements its extension functionality.
    It actually exposes two interfaces that are CoCreate-able.  One is the 
    primary interface, the other the extension interface.
    
    Author: EricDav
 ---------------------------------------------------------------------------*/
class CIpsmComponentDataPrimary : public CIpsmComponentData,
    public CComCoClass<CIpsmComponentDataPrimary, &CLSID_IpsmSnapin>
{
public:
    DECLARE_REGISTRY(CIpsmComponentDataPrimary, 
                     _T("TelephonySnapin.TelephonySnapin.1"), 
                     _T("TelephonySnapin.TelephonySnapin"), 
                     IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_IpsmSnapin; }
};


class CIpsmComponentDataExtension : public CIpsmComponentData,
    public CComCoClass<CIpsmComponentDataExtension, &CLSID_IpsmSnapinExtension>
{
public:
    DECLARE_REGISTRY(CIpsmComponentDataExtension, 
                     _T("TelephonySnapinExtension.TelephonySnapinExtension.1"), 
                     _T("TelephonySnapinExtension.TelephonySnapinExtension"), 
                     IDS_SNAPIN_DESC, THREADFLAGS_BOTH)
    STDMETHODIMP_(const CLSID *)GetCoClassID() { return &CLSID_IpsmSnapinExtension; }
};


/*---------------------------------------------------------------------------
    This is the derived class for handling the IAbout interface from MMC
    Author: EricDav
 ---------------------------------------------------------------------------*/
class CIpsmAbout : 
    public CAbout,
    public CComCoClass<CIpsmAbout, &CLSID_IpsmSnapinAbout>
{
public:
DECLARE_REGISTRY(CIpsmAbout, _T("IpsecMonSnapin.About.1"), 
                             _T("IpsecMonSnapin.About"), 
                             IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CIpsmAbout)
    COM_INTERFACE_ENTRY(ISnapinAbout) // Must have one static entry
    COM_INTERFACE_ENTRY_CHAIN(CAbout) // chain to the base class
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CIpsmAbout)

// these must be overridden to provide values to the base class
protected:
    virtual UINT GetAboutDescriptionId() { return IDS_ABOUT_DESCRIPTION; }
    virtual UINT GetAboutProviderId()    { return IDS_ABOUT_PROVIDER; }
    virtual UINT GetAboutVersionId()     { return IDS_ABOUT_VERSION; }
    virtual UINT GetAboutIconId()        { return IDI_WLANMON_SNAPIN; }

    virtual UINT GetSmallRootId()        { return IDB_ROOT_SMALL; }
    virtual UINT GetSmallOpenRootId()    { return IDB_ROOT_SMALL; }
    virtual UINT GetLargeRootId()        { return IDB_ROOT_LARGE; }
    virtual COLORREF GetLargeColorMask() { return (COLORREF) COLORREF_PINK; } 

};
    

#endif _IPSMCOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipsmhand.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	ipsmhand.cpp
		IPSecMon specifc handler base classes

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "ipsmhand.h"
#include "snaputil.h"  // For CGUIDArray
#include "extract.h"   // For ExtractInternalFormat

//Tthe help file
const TCHAR g_szDefaultHelpTopic[] = _T("\\help\\infrared.chm::/sag_IrDAtopnode.htm");


/*---------------------------------------------------------------------------
	CMTIpsmHandler::OnChangeState
		Description
	Author: NSun
 ---------------------------------------------------------------------------*/
void CMTIpsmHandler::OnChangeState
(
	ITFSNode * pNode
)
{
	// Increment the state to the next position
	switch (m_nState)
	{
		case notLoaded:
		case loaded:
		case unableToLoad:
			{
				m_nState = loading;
				m_dwErr = 0;
			}
			break;

		case loading:
			{
				m_nState = (m_dwErr != 0) ? unableToLoad : loaded;
                if (m_dwErr)
                {
                    CString strPrefix;
                    GetErrorPrefix(pNode, &strPrefix);
                    if (!strPrefix.IsEmpty())
                        ::IpsmMessageBoxEx(m_dwErr, strPrefix);
                }
			}
			break;
	
		default:
			ASSERT(FALSE);
	}

    // check to make sure we are still the visible node in the UI
    if (m_bSelected)
    {
        UpdateStandardVerbs(pNode, pNode->GetData(TFS_DATA_TYPE));
    }

    // Now check and see if there is a new image for this state for this handler
	int nImage, nOpenImage;

	nImage = GetImageIndex(FALSE);
	nOpenImage = GetImageIndex(TRUE);

	if (nImage >= 0)
		pNode->SetData(TFS_DATA_IMAGEINDEX, nImage);

	if (nOpenImage >= 0)
		pNode->SetData(TFS_DATA_OPENIMAGEINDEX, nOpenImage);
	
	VERIFY(SUCCEEDED(pNode->ChangeNode(SCOPE_PANE_CHANGE_ITEM_ICON)));
}

 /*!--------------------------------------------------------------------------
	CMTIpsmHandler::UpdateStandardVerbs
		Tells the IComponent to update the verbs for this node
	Author: NSun
 ---------------------------------------------------------------------------*/
void
CMTIpsmHandler::UpdateStandardVerbs
(
    ITFSNode *  pNode,
    LONG_PTR    dwNodeType
)
{
    HRESULT				hr = hrOK;
    SPIComponentData	spCompData;
	SPIConsole			spConsole;
    IDataObject*		pDataObject;

    m_spNodeMgr->GetComponentData(&spCompData);

    CORg ( spCompData->QueryDataObject(NULL, CCT_RESULT, &pDataObject) );

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );

    CORg ( spConsole->UpdateAllViews(pDataObject, 
                                     reinterpret_cast<MMC_COOKIE>(pNode), 
                                     RESULT_PANE_UPDATE_VERBS) ); 

    pDataObject->Release();
	
Error:
    return;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnCreateDataObject
		-
	Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CMTIpsmHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE			cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	    pObject = NULL;
	SPIDataObject	    spDataObject;

    pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CMTIpsmHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
	    {
		    SPITFSNode   spCurNode;
            const GUID * pGuid;

		    spCurNode = listSelectedNodes.RemoveHead();
            pGuid = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pGuid);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT)rgGuids.GetSize() * sizeof(GUID);
        
        pGuid = new GUID[(size_t)rgGuids.GetSize()];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::SaveColumns
		-
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMTIpsmHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if ( (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth))) && 
             (aColumnWidths[dwNodeType][nCol] != nColWidth) )
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }

        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CMTIpsmHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM			arg, 
	LPARAM			lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    SPINTERNAL		spInternal;
    BOOL            bMultiSelect = FALSE;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

    m_bSelected = bSelect;

   	Trace1("CMTIpsmHandler::OnResultSelect select = %d\n", bSelect);
 
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    
    spInternal = ::ExtractInternalFormat(pDataObject);
    
    if (spInternal && 
        spInternal->m_cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CORg (pComponent->GetSelectedNode(&spNode));
        bMultiSelect = TRUE;
    }
    else
    {
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    }

    UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE), bMultiSelect);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultUpdateView
		Implementation of ITFSResultHandler::OnResultUpdateView
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CMTIpsmHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT   pDataObject, 
    LPARAM         data, 
    LPARAM         hint
)
{
	HRESULT hr = hrOK;

    if (hint == RESULT_PANE_UPDATE_VERBS)
    {
	    SPIConsoleVerb  spConsoleVerb;
        SPITFSNode      spNode;

        CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

        spNode.Set(reinterpret_cast<ITFSNode *>(data));

        UpdateConsoleVerbs(spConsoleVerb, spNode->GetData(TFS_DATA_TYPE));
    }
    else
    {
        return CBaseResultHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CMTIpsmHandler::OnResultContextHelp(ITFSComponent * pComponent, 
                                            LPDATAOBJECT    pDataObject, 
                                            MMC_COOKIE      cookie, 
                                            LPARAM          arg, 
                                            LPARAM          lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;
    UINT            nLen = 0;
    LPCTSTR         pszHelpFile = NULL;
    CString         szHelpFilePath;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface(IID_IDisplayHelp, 
                                   (LPVOID*) &spDisplayHelp);
    ASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
    {
        pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (NULL == pszHelpFile)
            goto Error;
        
        nLen = ::GetWindowsDirectory(szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        if (0 == nLen)
        {
            hr = E_FAIL;
            goto Error;
        }
        
        szHelpFilePath.ReleaseBuffer();
        szHelpFilePath += g_szDefaultHelpTopic;
        
        hr = spDisplayHelp->ShowTopic(T2OLE((LPTSTR)(LPCTSTR) szHelpFilePath));
        ASSERT (SUCCEEDED(hr));
    }
    
 Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
	CMTIpsmHandler::UpdateStandardVerbs
		Updates the standard verbs depending upon the state of the node
	Author: NSun
 ---------------------------------------------------------------------------*/
void
CMTIpsmHandler::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];	
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::EnableVerbs
		Enables the verb buttons
	Author: NSun
 ---------------------------------------------------------------------------*/
void 
CMTIpsmHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultRefresh
		Call into the MTHandler to do a refresh
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CMTIpsmHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    OnRefresh(spNode, pDataObject, 0, arg, lParam);

Error:
    return hr;
}

 /*!--------------------------------------------------------------------------
	CMTIpsmHandler::ExpandNode
		Expands/compresses this node
	Author: NSun
 ---------------------------------------------------------------------------*/
void
CMTIpsmHandler::ExpandNode
(
    ITFSNode *  pNode,
    BOOL        fExpand
)
{
    SPIComponentData	spCompData;
    SPIDataObject       spDataObject;
    LPDATAOBJECT        pDataObject;
    SPIConsole          spConsole;
    HRESULT             hr = hrOK;

    m_spNodeMgr->GetComponentData(&spCompData);

	CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_SCOPE, &pDataObject) );
    spDataObject = pDataObject;

    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
	CORg ( spConsole->UpdateAllViews(pDataObject, TRUE, RESULT_PANE_EXPAND) ); 

Error:
    return;
}


/*---------------------------------------------------------------------------
	Class:	CIpsmHandler
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
	CIpsmHandler::SaveColumns
		-
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmHandler::SaveColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    LONG_PTR            dwNodeType;
    int                 nCol = 0;
    int                 nColWidth = 0;
    SPITFSNode          spNode, spRootNode;
    SPIHeaderCtrl       spHeaderCtrl;
    BOOL                bDirty = FALSE;

    CORg (m_spNodeMgr->FindNode(cookie, &spNode));
    CORg (pComponent->GetHeaderCtrl(&spHeaderCtrl));
    
    dwNodeType = spNode->GetData(TFS_DATA_TYPE);

    while (aColumns[dwNodeType][nCol] != 0)
    {
        if ( (SUCCEEDED(spHeaderCtrl->GetColumnWidth(nCol, &nColWidth))) && 
             (aColumnWidths[dwNodeType][nCol] != nColWidth) )
        {
            aColumnWidths[dwNodeType][nCol] = nColWidth;
            bDirty = TRUE;
        }
         
        nCol++;
    }

    if (bDirty)
    {
        CORg (m_spNodeMgr->GetRootNode(&spRootNode));
		spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CIpsmHandler::OnCreateDataObject
		-
	Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmHandler::OnCreateDataObject
(
    ITFSComponent *     pComponent,
	MMC_COOKIE      	cookie, 
	DATA_OBJECT_TYPES	type, 
	IDataObject **		ppDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    Assert(ppDataObject != NULL);

	CDataObject *	pObject = NULL;
	SPIDataObject	spDataObject;
	
	pObject = new CDataObject;
	spDataObject = pObject;	// do this so that it gets released correctly
						
    Assert(pObject != NULL);

    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        CreateMultiSelectData(pComponent, pObject);
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(*(m_spTFSComponentData->GetCoClassID()));

	pObject->SetTFSComponentData(m_spTFSComponentData);

    return  pObject->QueryInterface(IID_IDataObject, 
									reinterpret_cast<void**>(ppDataObject));
}

HRESULT
CIpsmHandler::CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject)
{
    HRESULT hr = hrOK;

    // build the list of selected nodes
	CTFSNodeList listSelectedNodes;
    CGUIDArray   rgGuids;
    UINT         cb;
    GUID*        pGuid;

    COM_PROTECT_TRY
    {
        CORg (BuildSelectedItemList(pComponent, &listSelectedNodes));

        // collect all of the unique guids
        while (listSelectedNodes.GetCount() > 0)
	    {
		    SPITFSNode   spCurNode;
            const GUID * pGuid;

		    spCurNode = listSelectedNodes.RemoveHead();
            pGuid = spCurNode->GetNodeType();
        
            rgGuids.AddUnique(*pGuid);
        }

        // now put the information in the data object
        pObject->SetMultiSelDobj();
        cb = (UINT)rgGuids.GetSize() * sizeof(GUID);
        
        pGuid = new GUID[(size_t)rgGuids.GetSize()];
        CopyMemory(pGuid, rgGuids.GetData(), cb);
        
        pObject->SetMultiSelData((BYTE*)pGuid, cb);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

 /*---------------------------------------------------------------------------
	CIpsmHandler::OnResultDelete
		Description
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmHandler::OnResultDelete
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject,
	MMC_COOKIE  	cookie, 
	LPARAM			arg, 
	LPARAM			lParam
)
{
	HRESULT hr = hrOK;

	Trace0("CIpsmHandler::OnResultDelete received\n");

	// translate this call to the parent and let it handle deletion 
	// of result pane items
	SPITFSNode spNode, spParent;
	SPITFSResultHandler spParentRH;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));
	CORg (spNode->GetParent(&spParent));

	if (spParent == NULL)
		return hr;

	CORg (spParent->GetResultHandler(&spParentRH));

	CORg (spParentRH->Notify(pComponent, spParent->GetData(TFS_DATA_COOKIE), pDataObject, MMCN_DELETE, arg, lParam));

Error:
	return hr;
}

/*!--------------------------------------------------------------------------
	CMTIpsmHandler::OnResultRefresh
		Call into the MTHandler to do a refresh
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmHandler::OnResultRefresh
(
    ITFSComponent *     pComponent,
    LPDATAOBJECT        pDataObject,
    MMC_COOKIE          cookie,
    LPARAM              arg,
    LPARAM              lParam
)
{
	HRESULT     hr = hrOK;
    SPITFSNode  spNode;

	CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    OnRefresh(spNode, pDataObject, 0, arg, lParam);

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CIpsmHandler::OnResultContextHelp
		Implementation of ITFSResultHandler::OnResultContextHelp
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmHandler::OnResultContextHelp
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT         hr = hrOK;
    SPIDisplayHelp  spDisplayHelp;
    SPIConsole      spConsole;

    pComponent->GetConsole(&spConsole);

    hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
	ASSERT (SUCCEEDED (hr));
	if ( SUCCEEDED (hr) )
	{
        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
        if (pszHelpFile == NULL)
            goto Error;

        CString szHelpFilePath;
	    UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
	    if (nLen == 0)
        {
		    hr = E_FAIL;
            goto Error;
        }

	    szHelpFilePath.ReleaseBuffer();
        szHelpFilePath += g_szDefaultHelpTopic;

		hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
		ASSERT (SUCCEEDED (hr));
    }

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
	CIpsmHandler::OnResultSelect
		Handles the MMCN_SELECT notifcation 
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmHandler::OnResultSelect
(
	ITFSComponent * pComponent, 
	LPDATAOBJECT	pDataObject, 
    MMC_COOKIE      cookie,
	LPARAM	    	arg, 
	LPARAM		    lParam
)
{
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    HRESULT         hr = hrOK;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

   	Trace1("CIpsmHandler::OnResultSelect select = %d\n", bSelect);
    //m_bSelected = bSelect;

    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));
    CORg (m_spNodeMgr->FindNode(cookie, &spNode));

    for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[spNode->GetData(TFS_DATA_TYPE)], bStates);

Error:
    return hr;
}


/*!--------------------------------------------------------------------------
	CMTIpsmHandler::EnableVerbs
		Enables the verb buttons
	Author: NSun
 ---------------------------------------------------------------------------*/
void 
CIpsmHandler::EnableVerbs
(
    IConsoleVerb *      pConsoleVerb,
    MMC_BUTTON_STATE    ButtonState[],
    BOOL                bState[]
)
{
    if (pConsoleVerb == NULL)
    {
        Assert(FALSE);
        return;
    }

    for (int i=0; i < ARRAYLEN(g_ConsoleVerbs); ++i)
    {
        if (ButtonState[i] == ENABLED)
        {
            // unhide this button before enabling
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       FALSE);
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       ButtonState[i], 
                                       bState[i]);
        }
        else
        {
            // hide this button
            pConsoleVerb->SetVerbState(g_ConsoleVerbs[i], 
                                       HIDDEN, 
                                       TRUE);
        }
    }

	pConsoleVerb->SetDefaultVerb(m_verbDefault);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipsmhelp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    ipsmhelp.h  
        help IDs for context sensitive help

    FILE HISTORY:
    
*/

// IPSMSNAP Identifiers 
// Dialogs (IDD_*) 
 
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ipsmsnap.rc
//

//IP Security Statistics dialog-Refresh button
#define IDH_STATS_REFRESH               8

//Server properties dialog
#define IDH_CHECK_ENABLE_STATS          360
#define IDH_EDIT_MINUTES                361
#define IDH_SPIN_MINUTES                364
#define IDH_STATIC_MINUTES              365
#define IDH_EDIT_SECONDS                362
#define IDH_SPIN_SECONDS                366

#define IDH_BUTTON_ADD_ADMIN            354
#define IDH_BUTTON_REMOVE_ADMIN         355
#define IDH_LIST_USERS                  356
#define IDH_EDIT_NAME                   357
#define IDH_EDIT_PASSWORD               358

#define IDH_CHECK_ENABLE_SERVER         367
#define IDH_LIST_ADMINS                 368
#define IDH_BUTTON_CHOOSE_USER          371
#define IDH_STATIC_ADMINS               372
#define IDH_STATIC_ACCOUNT              373
#define IDH_STATIC_USERNAME             374
#define IDH_STATIC_PASSWORD             375
#define IDH_STATIC_NOTE                 376
#define IDH_STATIC_LISTBOX              377

#define IDH_LIST_DRIVERS                380
#define IDH_BUTTON_EDIT_DRIVER          381
#define IDH_LIST_NEW_DRIVERS            382
#define IDH_BUTTON_ADD_DRIVER           384
#define IDH_BUTTON_REMOVE_DRIVER        386
#define IDH_BUTTON_ADD_USER             387
#define IDH_BUTTON_REMOVE_USER          388
#define IDH_BUTTON_ADD_NEW_DRIVER       389
#define IDH_STATIC_ACCOUNT_INFO         390
#define IDH_EDIT_INFO                   393
#define IDH_LIST_SPECIFIC               394
#define IDH_FLTR_SRC_ADDR               396
#define IDH_STATIC_SRC_MASK             397
#define IDH_STATIC_DEST_MASK            398

#define IDH_MM_POL_GEN_LIST             399
#define IDH_MM_POL_GEN_PROP             400
#define IDH_FLTR_SRC_MASK               401
#define IDH_LIST_MM_POL_AUTH            470
#define IDH_FLTR_IN_FLAG                402
#define IDH_MM_AUTH_DETAIL              403
#define IDH_FLTR_SRC_PORT               404
#define IDH_SRCH_SRC_ANY                405
#define IDH_SRCH_SRC_SPEC               406
#define IDH_FLTR_PROTOCOL               407
#define IDH_SRCH_SRC_EDIT               408
#define IDH_FLTR_IF_TYPE                409
#define IDH_SRCH_DEST_ANY               410
#define IDH_FLTR_MIRROR                 411
#define IDH_SRCH_DEST_SPEC              412
#define IDH_FLTR_POLICY                 413
#define IDH_SRCH_DEST_EDIT              414
#define IDH_FLTR_OUT_FLAG               415
#define IDH_SRCH_PROTO                  416
#define IDH_FLTR_DEST_ADDR              417
#define IDH_SRCH_SRC_PORT               418
#define IDH_FLTR_DEST_MASK              419
#define IDH_SRCH_DEST_PORT              420
#define IDH_FLTR_DEST_PORT              421
#define IDH_SRCH_LIST                   422
#define IDH_QM_POL_GEN_LIST             423
#define IDH_SRCH_PROTO2                 424
#define IDH_MM_STATIC_SRC_MASK          425
#define IDH_MM_FLTR_SRC_ADDR            426
#define IDH_SRCH_INBOUND                427
#define IDH_MM_FLTR_SRC_MASK            428
#define IDH_SRCH_OUTBOUND               429
#define IDH_MM_FLTR_IF_TYPE             430
#define IDH_SEARCH                      431
#define IDH_MM_FLTR_MIRROR              432
#define IDH_SRCH_SRC_IP                 433
#define IDH_MM_FLTR_POLICY              434
#define IDH_SRCH_DEST_IP                435
#define IDH_MM_STATIC_DEST_MASK         436
#define IDH_SRCH_RADIO_BEST             437
#define IDH_MM_FLTR_DEST_ADDR           438
#define IDH_SRCH_RADIO_ALL              439
#define IDH_MM_FLTR_DEST_MASK           440
#define IDH_MM_SRCH_RADIO_BEST          441
#define IDH_MM_LIST_SPECIFIC            442
#define IDH_MM_SRCH_RADIO_ALL           443
#define IDH_MM_SRCH_SRC_ANY             445
#define IDH_MM_SRCH_SRC_SPEC            448
#define IDH_ADD_LOCAL                   449
#define IDH_STATS_QM_LIST               450
#define IDH_MM_SRCH_SRC_IP              451
#define IDH_ADD_OTHER                   452
#define IDH_MM_SRCH_DEST_ANY            453
#define IDH_ADD_EDIT_NAME               454
#define IDH_MM_SRCH_DEST_SPEC           455
#define IDH_BTN_BROWSE                  456
#define IDH_MM_SRCH_DEST_IP             457
#define IDH_MM_SRCH_INBOUND             459
#define IDH_STATS_MM_LIST               460
#define IDH_MM_SRCH_OUTBOUND            461
#define IDH_MM_SEARCH                   462
#define IDH_MM_SRCH_LIST                463

#define IDH_MMSA_IKE_POL                481
#define IDH_MMSA_LIST_QM                482
#define IDH_MMSA_AUTH                   483
#define IDH_MMSA_CONF                   484
#define IDH_MMSA_INTEG                  485
#define IDH_MMSA_KEYLIFE                486
#define IDH_MMSA_DH_GRP                 487
#define IDH_QMSA_PFS_ENABLE             488
#define IDH_MMSA_ME                     490
#define IDH_MMSA_PEER                   491

#define IDH_QMSA_AUTH                   492
#define IDH_QMSA_ESP_CONF               493

#define IDH_QMSA_KEYLIFE                494

#define IDH_QMSA_PFS_GRP                495
#define IDH_QMSA_PROT                   496
#define IDH_QMSA_NEGPOL                 498
#define IDH_QMSA_ME_TNL                 499
#define IDH_QMSA_PEER_TNL               500

#define IDH_QMSA_SRC_PORT               501
#define IDH_QMSA_DEST_PORT              502
#define IDH_QMSA_DEST                   503
#define IDH_QMSA_SRC                    504
#define IDH_QMSA_ESP_INTEG              505

#define IDH_STATIC_MMSA_OFFER			506
#define IDH_STATIC_QMSA_OFFER			507

#define IDH_CHECK_ENABLE_DNS            510

//Log property sheet context sensitive help IDs
#define IDH_LOGDATAPP_SOURCE            60000001
#define IDH_LOGDATAPP_TYPE              60000002
#define IDH_LOGDATAPP_TIMESTAMP         60000003
#define IDH_LOGDATAPP_SSID              60000004
#define IDH_LOGDATAPP_LMAC              60000005
#define IDH_LOGDATAPP_RMAC              60000006
#define IDH_LOGDATAPP_DESCRIPTION       60000007
#define IDH_LOGDATAPP_DETAILS           60000008
#define IDH_LOGDATAPP_UP                60000009
#define IDH_LOGDATAPP_DOWN              60000010
#define IDH_LOGDATAPP_COPY              60000011

const DWORD g_aHelpIDs_IDP_FILTER_GENERAL[]=
{
	IDC_STATIC_FLTR_SRC, -1,
	IDC_STATIC_FLTR_DEST, -1,
		
	IDC_STATIC_FLTR_SRC_PORT, IDH_FLTR_SRC_PORT,
	IDC_FLTR_SRC_PORT, IDH_FLTR_SRC_PORT,

	IDC_STATIC_FLTR_SRC_ADDR, IDH_FLTR_SRC_ADDR,
	IDC_FLTR_SRC_ADDR, IDH_FLTR_SRC_ADDR,
	IDC_FLTR_SRC_ADDR_EDIT, IDH_FLTR_SRC_ADDR,

	IDC_STATIC_SRC_MASK, IDH_STATIC_SRC_MASK,
	IDC_FLTR_SRC_MASK, IDH_FLTR_SRC_MASK,

	IDC_STATIC_FLTR_DEST_PORT, IDH_FLTR_DEST_PORT,
	IDC_FLTR_DEST_PORT, IDH_FLTR_DEST_PORT,

	IDC_STATIC_FLTR_DEST_ADDR, IDH_FLTR_DEST_ADDR,
	IDC_FLTR_DEST_ADDR, IDH_FLTR_DEST_ADDR,
	IDC_FLTR_DEST_ADDR_EDIT, IDH_FLTR_DEST_ADDR,

	IDC_STATIC_DEST_MASK, IDH_STATIC_DEST_MASK,
	IDC_FLTR_DEST_MASK, IDH_FLTR_DEST_MASK,

	IDC_STATIC_FLTR_PROTOCOL, IDH_FLTR_PROTOCOL,
	IDC_FLTR_PROTOCOL, IDH_FLTR_PROTOCOL,

	IDC_STATIC_FLTR_IN_FLAG, IDH_FLTR_IN_FLAG,
	IDC_FLTR_IN_FLAG, IDH_FLTR_IN_FLAG,

	IDC_STATIC_FLTR_OUT_FLAG, IDH_FLTR_OUT_FLAG,
	IDC_FLTR_OUT_FLAG, IDH_FLTR_OUT_FLAG,

	IDC_STATIC_FLTR_IF_TYPE, IDH_FLTR_IF_TYPE,
	IDC_FLTR_IF_TYPE, IDH_FLTR_IF_TYPE,

	IDC_STATIC_FLTR_MIRROR, IDH_FLTR_MIRROR,
	IDC_FLTR_MIRROR, IDH_FLTR_MIRROR,

	IDC_STATIC_FLTR_POLICY, IDH_FLTR_POLICY,
	IDC_FLTR_POLICY, IDH_FLTR_POLICY,
	
	IDC_LIST_SPECIFIC, IDH_LIST_SPECIFIC,
	0, 0
};

const DWORD g_aHelpIDs_IDP_MM_FILTER_GENERAL[]=
{
	IDC_STATIC_MM_FLTR_SRC, -1,
	IDC_STATIC_MM_FLTR_DEST, -1,
	
	IDC_STATIC_MM_FLTR_SRC_ADDR, IDH_MM_FLTR_SRC_ADDR,
	IDC_MM_FLTR_SRC_ADDR, IDH_MM_FLTR_SRC_ADDR,
	IDC_MM_FLTR_SRC_ADDR_EDIT, IDH_MM_FLTR_SRC_ADDR,

	IDC_MM_STATIC_SRC_MASK, IDH_MM_STATIC_SRC_MASK,
	IDC_MM_FLTR_SRC_MASK, IDH_MM_FLTR_SRC_MASK,

	IDC_STATIC_MM_FLTR_DEST_ADDR, IDH_MM_FLTR_DEST_ADDR,
	IDC_MM_FLTR_DEST_ADDR, IDH_MM_FLTR_DEST_ADDR,
	IDC_MM_FLTR_DEST_ADDR_EDIT, IDH_MM_FLTR_DEST_ADDR,

	IDC_MM_STATIC_DEST_MASK, IDH_MM_STATIC_DEST_MASK,
	IDC_MM_FLTR_DEST_MASK, IDH_MM_FLTR_DEST_MASK,

	IDC_STATIC_MM_FLTR_IF_TYPE, IDH_MM_FLTR_IF_TYPE,
	IDC_MM_FLTR_IF_TYPE, IDH_MM_FLTR_IF_TYPE,

	IDC_STATIC_MM_FLTR_MIRROR, IDH_MM_FLTR_MIRROR,
	IDC_MM_FLTR_MIRROR, IDH_MM_FLTR_MIRROR,

	IDC_STATIC_MM_FLTR_POLICY, IDH_MM_FLTR_POLICY,
	IDC_MM_FLTR_POLICY, IDH_MM_FLTR_POLICY,
	
	IDC_MM_LIST_SPECIFIC, IDH_MM_LIST_SPECIFIC,
	0, 0
};

const DWORD g_aHelpIDs_IDP_MM_POLICY_GENERAL[]=
{
	IDC_MM_POL_GEN_LIST, IDH_MM_POL_GEN_LIST,
	IDC_MM_POL_GEN_PROP, IDH_MM_POL_GEN_PROP,
	0, 0
};

const DWORD g_aHelpIDs_IDP_MM_SA_GENERAL[]=
{
	IDC_STATIC_MMSA_ME, IDH_MMSA_ME,
	IDC_MMSA_ME, IDH_MMSA_ME,

	IDC_STATIC_MMSA_PEER, IDH_MMSA_PEER,
	IDC_MMSA_PEER, IDH_MMSA_PEER,

	IDC_STATIC_MMSA_AUTH, IDH_MMSA_AUTH,
	IDC_MMSA_AUTH, IDH_MMSA_AUTH,

	IDC_STATIC_MMSA_IKE_POL, IDH_MMSA_IKE_POL,
	IDC_MMSA_IKE_POL, IDH_MMSA_IKE_POL,

	IDC_STATIC_MMSA_OFFER, IDH_STATIC_MMSA_OFFER,

	IDC_STATIC_MMSA_CONF, IDH_MMSA_CONF,
	IDC_MMSA_CONF, IDH_MMSA_CONF,

	IDC_STATIC_MMSA_INTEG, IDH_MMSA_INTEG,
	IDC_MMSA_INTEG, IDH_MMSA_INTEG,

	IDC_STATIC_MMSA_DH_GRP, IDH_MMSA_DH_GRP,
	IDC_MMSA_DH_GRP, IDH_MMSA_DH_GRP,

	IDC_STATIC_MMSA_KEYLIFE, IDH_MMSA_KEYLIFE,
	IDC_MMSA_KEYLIFE, IDH_MMSA_KEYLIFE,

	IDC_MMSA_LIST_QM, IDH_MMSA_LIST_QM,
	0, 0
};

const DWORD g_aHelpIDs_IDP_QM_SA_GENERAL[]=
{
	IDC_STATIC_QMSA_SRC, IDH_QMSA_SRC,
	IDC_QMSA_SRC, IDH_QMSA_SRC,

	IDC_STATIC_QMSA_DEST, IDH_QMSA_DEST,
	IDC_QMSA_DEST, IDH_QMSA_DEST,

	IDC_STATIC_QMSA_SRC_PORT, IDH_QMSA_SRC_PORT,
	IDC_QMSA_SRC_PORT, IDH_QMSA_SRC_PORT,

	IDC_STATIC_QMSA_DEST_PORT, IDH_QMSA_DEST_PORT,
	IDC_QMSA_DEST_PORT, IDH_QMSA_DEST_PORT,

	IDC_STATIC_QMSA_PROT, IDH_QMSA_PROT,
	IDC_QMSA_PROT, IDH_QMSA_PROT,

	IDC_STATIC_QMSA_OFFER, IDH_STATIC_QMSA_OFFER,

	IDC_STATIC_QMSA_AUTH, IDH_QMSA_AUTH,
	IDC_QMSA_AUTH, IDH_QMSA_AUTH,

	IDC_STATIC_QMSA_ESP_CONF, IDH_QMSA_ESP_CONF,
	IDC_QMSA_ESP_CONF, IDH_QMSA_ESP_CONF,

	IDC_STATIC_QMSA_ESP_INTEG, IDH_QMSA_ESP_INTEG, 
	IDC_QMSA_ESP_INTEG, IDH_QMSA_ESP_INTEG, 

	IDC_STATIC_QMSA_KEYLIFE, IDH_QMSA_KEYLIFE,
	IDC_QMSA_KEYLIFE, IDH_QMSA_KEYLIFE,

	IDC_STATIC_QMSA_PFS_ENABLE, IDH_QMSA_PFS_ENABLE,
	IDC_QMSA_PFS_ENABLE, IDH_QMSA_PFS_ENABLE,

	IDC_STATIC_QMSA_PFS_GRP, IDH_QMSA_PFS_GRP,
	IDC_QMSA_PFS_GRP, IDH_QMSA_PFS_GRP,

	IDC_STATIC_QMSA_NEGPOL, IDH_QMSA_NEGPOL,  
	IDC_QMSA_NEGPOL, IDH_QMSA_NEGPOL,  

	IDC_STATIC_QMSA_ME_TNL, IDH_QMSA_ME_TNL,   
	IDC_QMSA_ME_TNL, IDH_QMSA_ME_TNL,   

	IDC_STATIC_QMSA_PEER_TNL, IDH_QMSA_PEER_TNL,
	IDC_QMSA_PEER_TNL, IDH_QMSA_PEER_TNL,

	0, 0
};

const DWORD g_aHelpIDs_IDP_QM_POLICY_GENERAL[]=
{
	IDC_QM_POL_GEN_LIST, IDH_QM_POL_GEN_LIST,
	0, 0
};

const DWORD g_aHelpIDs_IDP_SERVER_REFRESH[]=
{
	IDC_CHECK_ENABLE_STATS, IDH_CHECK_ENABLE_STATS,

	IDC_STATIC_INTERVAL, -1,
	IDC_EDIT_MINUTES, IDH_EDIT_MINUTES,
	IDC_SPIN_MINUTES, IDH_SPIN_MINUTES,
	IDC_STATIC_MINUTES, -1,
	

	IDC_EDIT_SECONDS, IDH_EDIT_SECONDS,
	IDC_SPIN_SECONDS, IDH_SPIN_SECONDS,
	IDC_STATIC_SECONDS, -1,
	IDC_CHECK_ENABLE_DNS, IDH_CHECK_ENABLE_DNS,
	
	0, 0
};

const DWORD g_aHelpIDs_IDP_MM_AUTH[]=
{
	IDC_LIST_MM_POL_AUTH, IDH_LIST_MM_POL_AUTH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_SRCH_FLTRS[]=
{
	IDC_SRCH_SRC_ANY, IDH_SRCH_SRC_ANY,
	IDC_SRCH_SRC_SPEC, IDH_SRCH_SRC_SPEC,
	IDC_SRCH_SRC_IP, IDH_SRCH_SRC_IP,
	IDC_SRCH_DEST_ANY, IDH_SRCH_DEST_ANY,
	IDC_SRCH_DEST_SPEC, IDH_SRCH_DEST_SPEC,
	IDC_SRCH_DEST_IP, IDH_SRCH_DEST_IP,
	IDC_SRCH_PROTO, IDH_SRCH_PROTO,
//	IDC_SRCH_PROTO_NUMBER, IDH_SRCH_PROTO_NUMBER,
//	IDC_SRCH_PROTO_SPIN, IDH_SRCH_PROTO_SPIN,
	IDC_SRCH_SRC_PORT, IDH_SRCH_SRC_PORT,
	IDC_SRCH_DEST_PORT, IDH_SRCH_DEST_PORT,
	IDC_SRCH_INBOUND, IDH_SRCH_INBOUND,
	IDC_SRCH_OUTBOUND, IDH_SRCH_OUTBOUND,
	IDC_SEARCH, IDH_SEARCH,
	IDC_SRCH_LIST, IDH_SRCH_LIST,
	IDC_SRCH_RADIO_BEST, IDH_SRCH_RADIO_BEST,
	IDC_SRCH_RADIO_ALL, IDH_SRCH_RADIO_ALL,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MM_SRCH_FLTRS[]=
{
	IDC_MM_SRCH_SRC_ANY, IDH_MM_SRCH_SRC_ANY,
	IDC_MM_SRCH_SRC_SPEC, IDH_MM_SRCH_SRC_SPEC,
	IDC_MM_SRCH_SRC_IP, IDH_MM_SRCH_SRC_IP,
	IDC_MM_SRCH_DEST_ANY, IDH_MM_SRCH_DEST_ANY,
	IDC_MM_SRCH_DEST_SPEC, IDH_MM_SRCH_DEST_SPEC,
	IDC_MM_SRCH_DEST_IP, IDH_MM_SRCH_DEST_IP,
	IDC_MM_SRCH_INBOUND, IDH_MM_SRCH_INBOUND,
	IDC_MM_SRCH_OUTBOUND, IDH_MM_SRCH_OUTBOUND,
	IDC_MM_SEARCH, IDH_MM_SEARCH,
	IDC_MM_SRCH_LIST, IDH_MM_SRCH_LIST,
	IDC_MM_SRCH_RADIO_BEST, IDH_MM_SRCH_RADIO_BEST,
	IDC_MM_SRCH_RADIO_ALL, IDH_MM_SRCH_RADIO_ALL,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ADD_COMPUTER[]=
{
	IDC_ADD_LOCAL, IDH_ADD_LOCAL,
	IDC_ADD_OTHER, IDH_ADD_OTHER,
	IDC_ADD_EDIT_NAME, IDH_ADD_EDIT_NAME,
	IDC_BTN_BROWSE, IDH_BTN_BROWSE,
	0, 0
};

const DWORD g_aHelpIDs_IDD_IPSM_STATS[]=
{
	IDC_STATS_MM_LIST, IDH_STATS_MM_LIST,
	IDC_STATS_QM_LIST, IDH_STATS_QM_LIST,
	IDC_STATS_REFRESH, IDH_STATS_REFRESH,
	0, 0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_LOGDATA[] =
{
    IDC_LOGDATAPP_SOURCE,         IDH_LOGDATAPP_SOURCE,
    IDC_LOGDATA_EDIT1,            IDH_LOGDATAPP_SOURCE,
    IDC_LOGDATAPP_TYPE,           IDH_LOGDATAPP_TYPE,
    IDC_LOGDATA_EDIT2,            IDH_LOGDATAPP_TYPE,    
    IDC_LOGDATAPP_TIME,           IDH_LOGDATAPP_TIMESTAMP,
    IDC_LOGDATA_EDIT3,            IDH_LOGDATAPP_TIMESTAMP,    
    IDC_LOGDATAPP_SSID,           IDH_LOGDATAPP_SSID,
    IDC_LOGDATA_EDIT7,            IDH_LOGDATAPP_SSID,    
    IDC_LOGDATAPP_LMAC,           IDH_LOGDATAPP_LMAC,
    IDC_LOGDATA_EDIT5,            IDH_LOGDATAPP_LMAC,    
    IDC_LOGDATAPP_RMAC,           IDH_LOGDATAPP_RMAC,
    IDC_LOGDATA_EDIT6,            IDH_LOGDATAPP_RMAC,    
    IDC_LOGDATAPP_DESC,           IDH_LOGDATAPP_DESCRIPTION,
    IDC_LOGDATA_EDIT4,            IDH_LOGDATAPP_DESCRIPTION,    
    IDC_LOGDATAPP_DETAILS,        IDH_LOGDATAPP_DETAILS,
    IDC_LOGDATA_EDIT8,            IDH_LOGDATAPP_DETAILS,    
    IDC_BTN_MOVE_UP,              IDH_LOGDATAPP_UP,
    IDC_BTN_MOVE_DOWN,            IDH_LOGDATAPP_DOWN,
    IDC_BTN_COPY,                 IDH_LOGDATAPP_COPY,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipsmhand.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2000 **/
/**********************************************************************/

/*
	IPSMhand.h
		Header file for IPSecMon specific base handler classes and query obj

    FILE HISTORY:
        
*/

#ifndef _IPSMHAND_H
#define _IPSMHAND_H

#ifndef _HANDLERS_H
#include <handlers.h>
#endif

#ifndef _QUERYOBJ_H
#include <queryobj.h>
#endif

extern const TCHAR g_szDefaultHelpTopic[];

/*---------------------------------------------------------------------------
	Class:	CHandlerEx
 ---------------------------------------------------------------------------*/
class CHandlerEx
{
// Interface
public:
    virtual HRESULT InitializeNode(ITFSNode * pNode) = 0;
	LPCTSTR GetDisplayName() { return m_strDisplayName; }
	void    SetDisplayName(LPCTSTR pName) { m_strDisplayName = pName; }

private:
	CString m_strDisplayName;
};

/*---------------------------------------------------------------------------
	Class:	CIpsmHandler
 ---------------------------------------------------------------------------*/
class CIpsmHandler : 
        public CHandler,
		public CHandlerEx
{
public:
	CIpsmHandler(ITFSComponentData *pCompData) : 
		CHandler(pCompData),
		m_verbDefault(MMC_VERB_OPEN) {};
	~CIpsmHandler() {};

    // base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
    OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }

    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultDelete();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();
	OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);
	
	MMC_CONSOLE_VERB	m_verbDefault;

protected:
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);

public:
};

/*---------------------------------------------------------------------------
	Class:	CMTIpsmHandler
 ---------------------------------------------------------------------------*/
class CMTIpsmHandler : 
		public CMTHandler,
		public CHandlerEx
{
public:
	// enumeration for node states, to handle icon changes
	typedef enum
	{
		notLoaded = 0, // initial state, valid only if server never contacted
		loading,
		loaded,
		unableToLoad
	} nodeStateType;

	CMTIpsmHandler(ITFSComponentData *pCompData) : 
		CMTHandler(pCompData),
		m_verbDefault(MMC_VERB_OPEN) 
		{ m_nState = notLoaded; m_bSelected = FALSE; }
	~CMTIpsmHandler() {};

    // base handler virtual function over-rides
	virtual HRESULT SaveColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

    // by default we don't allow nodes to be renamed
	OVERRIDE_BaseHandlerNotify_OnRename() { return hrFalse; }

    // base result handler overrides
    OVERRIDE_BaseResultHandlerNotify_OnResultRefresh();
	OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
	OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultContextHelp();

    // Multi-select functionalty
    OVERRIDE_ResultHandler_OnCreateDataObject();

    void EnableVerbs(IConsoleVerb *     pConsoleVerb,
                     MMC_BUTTON_STATE   ButtonState[],
                     BOOL               bEnable[]);

protected:
	virtual void OnChangeState(ITFSNode* pNode);
    virtual void GetErrorPrefix(ITFSNode * pNode, CString * pstrPrefix) { };
	virtual void OnHaveData(ITFSNode * pParentNode, ITFSNode * pNewNode)
	{
		if (pNewNode->IsContainer())
		{
			// assume all the child containers are derived from this class
			//((CIpsmMTContainer*)pNode)->SetServer(GetServer());
		}
		pParentNode->AddChild(pNewNode);
	}

    virtual void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

    void    UpdateStandardVerbs(ITFSNode * pToolbar, LONG_PTR dwNodeType);
    HRESULT CreateMultiSelectData(ITFSComponent * pComponent, CDataObject * pObject);
    void    ExpandNode(ITFSNode * pNode, BOOL fExpand);

	MMC_CONSOLE_VERB	m_verbDefault;
protected:
    BOOL        m_bSelected;
};

/*---------------------------------------------------------------------------
	Class:	CIpsmQueryObj : general purpose base class
 ---------------------------------------------------------------------------*/
class CIpsmQueryObj : public CNodeQueryObject
{
public:
	CIpsmQueryObj
	(
		ITFSComponentData *	pTFSCompData, 
		ITFSNodeMgr *		pNodeMgr
	) : m_dwErr(0)
	{
		m_spTFSCompData.Set(pTFSCompData); 
	    m_spNodeMgr.Set(pNodeMgr);
	}

	CQueueDataListBase & GetQueue() { return m_dataQueue; }

public:
	CString				 m_strServer;
	SPITFSComponentData  m_spTFSCompData;
	SPITFSNodeMgr		 m_spNodeMgr;
	DWORD				 m_dwErr;
};

#endif _IPSMHAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipsmsnap.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2000 **/
/**********************************************************************/

/*
    ipsmsnap.cpp
        IPWirelessMon snapin entry points/registration functions
        
        Note: Proxy/Stub Information
            To build a separate proxy/stub DLL, 
            run nmake -f Snapinps.mak in the project directory.

    FILE HISTORY:
       Based on IPSecMon snapin (files copied, then modified) 
*/

#include "stdafx.h"
#include "initguid.h"
#include "ncglobal.h"  // network console global defines
#include "cmptrmgr.h"   // computer menagement snapin stuff
#include "spdutil.h"

#ifdef _DEBUG
void DbgVerifyInstanceCounts();
#define DEBUG_VERIFY_INSTANCE_COUNTS DbgVerifyInstanceCounts()
#else
#define DEBUG_VERIFY_INSTANCE_COUNTS
#endif

const TCHAR c_szHelpFile[] = _T("wireless.hlp");

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_IpsmSnapin, CIpsmComponentDataPrimary)
    OBJECT_ENTRY(CLSID_IpsmSnapinExtension, CIpsmComponentDataExtension)
    OBJECT_ENTRY(CLSID_IpsmSnapinAbout, CIpsmAbout)
END_OBJECT_MAP()

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// CIpsmSnapinApp
//
BEGIN_MESSAGE_MAP(CIpsmSnapinApp, CWinApp)
    //{{AFX_MSG_MAP(CIpsmSnapinApp)
    //ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    //ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    //ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    //ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
    // Global help commands
    ON_COMMAND(ID_HELP_INDEX, CWinApp::OnHelpFinder)
    ON_COMMAND(ID_HELP_USING, CWinApp::OnHelpUsing)
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CWinApp::OnHelpIndex)
END_MESSAGE_MAP()

CIpsmSnapinApp theApp;

BOOL CIpsmSnapinApp::InitInstance()
{
    _Module.Init(ObjectMap, m_hInstance);


    //
    //  Initialize the CWndIpAddress control window class IPADDRESS
    //
    CWndIpAddress::CreateWindowClass( m_hInstance ) ;
    
    //
    //  Initialize use of the WinSock routines
    //
    WSADATA wsaData ;
    
    if ( ::WSAStartup( MAKEWORD( 1, 1 ), & wsaData ) != 0 )
    {
        m_bWinsockInited = TRUE;
        Trace0("InitInstance: Winsock initialized!\n");
    }
    else
    {
        m_bWinsockInited = FALSE;
    }

    if (m_pszHelpFilePath)
        free((void*)m_pszHelpFilePath);

    m_pszHelpFilePath=_tcsdup(c_szHelpFile);
    
    return CWinApp::InitInstance();
}

int CIpsmSnapinApp::ExitInstance()
{
    _Module.Term();

    DEBUG_VERIFY_INSTANCE_COUNTS;

    //
    // Terminate use of the WinSock routines.
    //
    if ( m_bWinsockInited )
    {
        WSACleanup() ;
    }

    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    TCHAR   szModuleFileName[MAX_PATH * 2 + 1] = {0};

    BOOL fGotModuleName = TRUE;

    fGotModuleName = (0 != ::GetModuleFileName(
                                 _Module.GetModuleInstance(),
                                 szModuleFileName,
                                 DimensionOf(szModuleFileName) - 1));
    szModuleFileName[MAX_PATH * 2] = 0;
    
    //
    // registers object, typelib and all interfaces in typelib
    //
    HRESULT hr = _Module.RegisterServer(/* bRegTypeLib */ FALSE);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    CString stName;
    CString stNameStringIndirect;

    stName.LoadString(IDS_SNAPIN_NAME);
    stNameStringIndirect.Format(
                             L"@%s,-%-d", szModuleFileName,
                             IDS_SNAPIN_DESC);
    //
    // register the snapin into the console snapin list
    //
    hr = RegisterSnapinGUID(&CLSID_IpsmSnapin, 
                        &GUID_IpsmRootNodeType, 
                        &CLSID_IpsmSnapinAbout,
                        (LPCTSTR) stName, 
                        _T("1.0"), 
                        TRUE,
                        fGotModuleName ? (LPCTSTR)stNameStringIndirect : NULL);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    CString stExtensionName;
    CString stExtensionNameIndirect;
    stExtensionName.LoadString(IDS_SNAPIN_EXTENSION);
    stExtensionNameIndirect.Format(L"@%s,-%-d", szModuleFileName, IDS_SNAPIN_EXTENSION);

    hr = RegisterSnapinGUID(&CLSID_IpsmSnapinExtension, 
                            NULL, 
                            &CLSID_IpsmSnapinAbout,
                            (LPCTSTR) stExtensionName, 
                            _T("1.0"), 
                            FALSE,
                            fGotModuleName ? (LPCTSTR)stExtensionNameIndirect : NULL);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    //
    // register the snapin nodes into the console node list
    //
    hr = RegisterNodeTypeGUID(&CLSID_IpsmSnapin, 
                              &GUID_IpsmRootNodeType, 
                              _T("Root of Manager"));
    ASSERT(SUCCEEDED(hr));

#ifdef  __NETWORK_CONSOLE__
    hr = RegisterAsRequiredExtensionGUID(&GUID_NetConsRootNodeType, 
                                         &CLSID_IpsmSnapinExtension,
                                         (LPCTSTR) stExtensionName,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &GUID_NetConsRootNodeType);   // doesn't matter what this is, just 
                                                                       // needs to be non-null guid

    ASSERT(SUCCEEDED(hr));
#endif

    hr = RegisterAsRequiredExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                         &CLSID_IpsmSnapinExtension,
                                         (LPCTSTR) stExtensionName,
                                         EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE,
                                         &NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS);  // NULL makes it not dynamic
    ASSERT(SUCCEEDED(hr));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr  = _Module.UnregisterServer();
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;
    
    // un register the snapin 
    //
    hr = UnregisterSnapinGUID(&CLSID_IpsmSnapin);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    hr = UnregisterSnapinGUID(&CLSID_IpsmSnapinExtension);
    ASSERT(SUCCEEDED(hr));
    
    if (FAILED(hr))
        return hr;

    // unregister the snapin nodes 
    //
    hr = UnregisterNodeTypeGUID(&GUID_IpsmRootNodeType);
    ASSERT(SUCCEEDED(hr));

#ifdef  __NETWORK_CONSOLE__
    
    hr = UnregisterAsExtensionGUID(&GUID_NetConsRootNodeType, 
                                   &CLSID_IpsmSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
    ASSERT(SUCCEEDED(hr));
#endif

    hr = UnregisterAsExtensionGUID(&NODETYPE_COMPUTERMANAGEMENT_SERVERAPPS, 
                                   &CLSID_IpsmSnapinExtension,
                                   EXTENSION_TYPE_TASK | EXTENSION_TYPE_NAMESPACE);
    ASSERT(SUCCEEDED(hr));

    return hr;
}

#ifdef _DEBUG
void DbgVerifyInstanceCounts()
{
    DEBUG_VERIFY_INSTANCE_COUNT(CHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CMTHandler);
    DEBUG_VERIFY_INSTANCE_COUNT(CSpdInfo);
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\ipsmsnap.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 2000 **/
/**********************************************************************/

/*
	global.h
		Global defines for the IPSecMon snapin


	FILE HISTORY:
        
*/

const TCHAR PA_SERVICE_NAME[] = _T("PolicyAgent");

// Defines for help from the help menu and F1 help for scope pane items
#define IPSMSNAP_HELP_BASE				    0xA0000000
#define IPSMSNAP_HELP_SNAPIN			    IPSMSNAP_HELP_BASE + 1
#define IPSMSNAP_HELP_ROOT				    IPSMSNAP_HELP_BASE + 2
#define IPSMSNAP_HELP_SERVER 			    IPSMSNAP_HELP_BASE + 3
#define IPSMSNAP_HELP_PROVIDER 		        IPSMSNAP_HELP_BASE + 4
#define IPSMSNAP_HELP_DEVICE  			    IPSMSNAP_HELP_BASE + 5

// wait cursor stuff around functions.  If you need a wait cursor for 
// and entire fucntion, just use CWaitCursor.  To wrap a wait cursor
// around an rpc call, use these macros.
#define BEGIN_WAIT_CURSOR   {  CWaitCursor waitCursor;
#define RESTORE_WAIT_CURSOR    waitCursor.Restore();
#define END_WAIT_CURSOR     }

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// macro to get the handler for a node. This is a IPSecMon snapin specific 
// implementation
#define GETHANDLER(classname, node) (reinterpret_cast<classname *>(node->GetData(TFS_DATA_USER)))

// HRESULT Mapping
#define WIN32_FROM_HRESULT(hr)         (0x0000FFFF & (hr))

// Version Suff
#define IPSMSNAP_VERSION         0x00010000

extern DWORD gdwIpsmSnapVersion;

#define IPSMSNAP_FILE_VERSION	 0x00000001

// constants for time conversion
#define MILLISEC_PER_SECOND			1000
#define MILLISEC_PER_MINUTE			(60 * MILLISEC_PER_SECOND)
#define MILLISEC_PER_HOUR			(60 * MILLISEC_PER_MINUTE)

#define IPSECMON_REFRESH_INTERVAL_DEFAULT	(45 * MILLISEC_PER_SECOND) // 45 seconds

// macros for memory exception handling
#define CATCH_MEM_EXCEPTION             \
	TRY

#define END_MEM_EXCEPTION(err)          \
	CATCH_ALL(e) {                      \
       err = ERROR_NOT_ENOUGH_MEMORY ;  \
    } END_CATCH_ALL

// some global defines we need
#define STRING_LENGTH_MAX		 256

// Note - These are offsets into my image list
typedef enum _ICON_INDICIES
{
	ICON_IDX_SERVER,
	ICON_IDX_SERVER_BUSY,
	ICON_IDX_SERVER_CONNECTED,
	ICON_IDX_SERVER_LOST_CONNECTION,
	ICON_IDX_MACHINE,
	ICON_IDX_FOLDER_OPEN,
	ICON_IDX_FOLDER_CLOSED,
	ICON_IDX_PRODUCT,
	ICON_IDX_FILTER,
	ICON_IDX_POLICY,
	ICON_IDX_LOGDATA_ERROR,
	ICON_IDX_LOGDATA_WARNING,
	ICON_IDX_LOGDATA_INFORMATION,
	ICON_IDX_LOGDATA_UNKNOWN,
        ICON_IDX_AP_ADHOC,
        ICON_IDX_AP_INFRA,
        ICON_IDX_AP_ASSOC_ADHOC,
        ICON_IDX_AP_ASSOC_INFRA,
	ICON_IDX_MAX
} ICON_INDICIES, * LPICON_INDICIES;

// Sample folder types
enum NODETYPES
{
    // scope pane items
    IPSMSNAP_ROOT,
    IPSMSNAP_SERVER,
    IPFWMON_FILTER,
    IPFWMON_LOG,
    IPFWMON_LOGDATA,
    WLANMON_APDATA,
    
    // result pane items
    WLANMON_APDATA_ITEM,
    IPFWMON_LOGDATA_ITEM,
    IPSECMON_NODETYPE_MAX
};

//  GUIDs are defined in guids.cpp
extern const CLSID      CLSID_IpsmSnapin;				// In-Proc server GUID
extern const CLSID      CLSID_IpsmSnapinExtension;		// In-Proc server GUID
extern const CLSID      CLSID_IpsmSnapinAbout;			// In-Proc server GUID
extern const GUID       GUID_IpsmRootNodeType;			// Root NodeType GUID 
extern const GUID       GUID_IpsmServerNodeType;		// Server NodeType GUID
extern const GUID       GUID_IpsmFilterNodeType;		// Filters NodeType GUID
extern const GUID       GUID_IpsmSpecificFilterNodeType;		// Specific Filters NodeType GUID
extern const GUID       GUID_QmNodeType;			// Quick Mode NodeType GUID
extern const GUID       GUID_MmNodeType;			// Main Mode NodeType GUID

extern const GUID       GUID_IpsmMmPolicyNodeType;		// Main Mode Policy GUID 
extern const GUID       GUID_IpsmQmPolicyNodeType;		// Quick Mode Policy GUID
extern const GUID       GUID_IpsmMmFilterNodeType;		// Main Mode Filter GUID  
extern const GUID       GUID_IpsmMmSANodeType;			// Main Mode SA GUID
extern const GUID       GUID_IpsmMmSpFilterNodeType;	// Main Mode Specific Filter GUID  

extern const GUID       IID_ISpdInfo;
extern const GUID       IID_IApDbInfo;
extern const GUID       GUID_IpsmQmSANodeType;

extern const GUID 	   GUID_FilterNodeType;
extern const GUID 	   GUID_LogNodeType;
extern const GUID 	   GUID_IpfmLogDataNodeType;
extern const GUID 	   GUID_IpfmFilterDataNodeType;
extern const GUID	   GUID_IpfmWirelessNodeType;

const int MAX_COLUMNS = 14;
const int NUM_SCOPE_ITEMS = 3;
const int NUM_CONSOLE_VERBS = 8;

// arrays used to hold all of the result pane column information
extern UINT aColumns[IPSECMON_NODETYPE_MAX][MAX_COLUMNS];
extern int aColumnWidths[IPSECMON_NODETYPE_MAX][MAX_COLUMNS];


// arrays for console verbs
extern MMC_CONSOLE_VERB g_ConsoleVerbs[NUM_CONSOLE_VERBS];
extern MMC_BUTTON_STATE g_ConsoleVerbStates[IPSECMON_NODETYPE_MAX][NUM_CONSOLE_VERBS];
extern MMC_BUTTON_STATE g_ConsoleVerbStatesMultiSel[IPSECMON_NODETYPE_MAX][NUM_CONSOLE_VERBS];

// array for help
extern DWORD g_dwMMCHelp[IPSECMON_NODETYPE_MAX];

// Clipboard format that has the Type and Cookie
extern const wchar_t*   SNAPIN_INTERNAL;

// CIpsmSnapinApp definition
class CIpsmSnapinApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();

    DECLARE_MESSAGE_MAP()

public:
	BOOL m_bWinsockInited;
};

extern CIpsmSnapinApp theApp;

#define IPSECMON_UPDATE_STATUS ( 0x10000000 )
#define IPFWMON_UPDATE_STATUS  ( 0x10000000 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\logdatanode.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _LOGDATA_NODE_H
#define _LOGDATA_NODE_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif

/*
  This value indicates the size in bytes of each summary at the maximum. It 
  must mirror the value in layer2svc\monitor\inc\database.h
*/
#define MAX_SUMMARY_MESSAGE_SIZE 80

/*---------------------------------------------------------------------------
	Class:	CFilterHandler
 ---------------------------------------------------------------------------*/
class CLogDataHandler : public CIpsmHandler
{
public:
    CLogDataHandler(ITFSComponentData* pTFSComponentData);
    virtual ~CLogDataHandler();

    // Interface
public:
    // base handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString()
        { return (nCol == 0) ? GetDisplayName() : NULL; }
    
    // Base handler notifications we handle
    OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    
    
    // Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();
    OVERRIDE_BaseResultHandlerNotify_OnResultColumnClick();

    OVERRIDE_ResultHandler_OnGetResultViewType();
    OVERRIDE_ResultHandler_GetVirtualString(); 
    OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_HasPropertyPages();
    OVERRIDE_ResultHandler_CreatePropertyPages();
    OVERRIDE_ResultHandler_SortItems();

    STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);
    /*
    STDMETHODIMP SortItems(int     nColumn, 
                           DWORD   dwSortOptions,    
                           LPARAM  lUserParam);
    */
    // base handler overrides
    virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);
    
    // CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);
    
    
    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
    { 
        return &GUID_IpfmLogDataNodeType; 
    }

public:
    // CMTIpsmHandler functionality
    virtual HRESULT  InitializeNode(ITFSNode * pNode);
    virtual int      GetImageIndex(BOOL bOpenImage);
    ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);
    
public:
    // implementation specific	
    HRESULT InitData(ISpdInfo * pSpdInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
    // Implementation
private:
    // Command handlers
    HRESULT OnDelete(ITFSNode * pNode);
    //HRESULT UpdateViewType(ITFSNode * pNode, FILTER_TYPE NewFltrType);

    HRESULT GetSelectedItem(int *pnIndex, CLogDataInfo *pLogData, 
                            IResultData *pResultData);
    HRESULT GetSelectedItemState(UINT *puiState, IResultData *pResultData);
    HRESULT MaintainSelection();

private:
    SPISpdInfo          m_spSpdInfo;
    int                 m_nSelIndex;          //Virtual index of selected item
    CLogDataInfo        m_SelLogData;         //The selected item
    ITFSComponent       *m_pComponent;
};


#endif _LOGDATA_NODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\logdatanode.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    provider.cpp
        Filter node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "LogDataNode.h"
#include "logdatapp.h"
#include "SpdUtil.h"

#define ELLIPSIS _T("...")

/*---------------------------------------------------------------------------
    Class CLogDataHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CLogDataHandler::CLogDataHandler(ITFSComponentData * pComponentData) 
    : CIpsmHandler(pComponentData),
      m_pComponent(NULL)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CLogDataHandler::~CLogDataHandler()
{
}

/*!--------------------------------------------------------------------------
    CLogDataHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CLogDataHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


    CString strTemp;  
	strTemp.LoadString(IDS_LOG_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPFWMON_LOGDATA);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[IPFWMON_LOGDATA][0]);
    SetColumnWidths(&aColumnWidths[IPFWMON_LOGDATA][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CLogDataHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CLogDataHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CLogDataHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    HRESULT     hr = hrOK;
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (type == CCT_SCOPE && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP))
    {
        CString         strBuffer;
        WZC_CONTEXT     wzcContext = {0};
        DWORD           dwMenu;

        strBuffer.Empty();
        m_spSpdInfo->GetComputerName(&strBuffer);

        WZCQueryContext(
            //strBuffer.IsEmpty()? NULL : (LPWSTR)(LPCWSTR)strBuffer,
            NULL,
            WZC_CONTEXT_CTL_LOG,
            &wzcContext,
            NULL);

        dwMenu = (wzcContext.dwFlags & WZC_CTXT_LOGGING_ON) ? IDS_MENU_DISABLE_LOGGING : IDS_MENU_ENABLE_LOGGING,

        strBuffer.LoadString(dwMenu);

        hr = LoadAndAddMenuItem(
                pContextMenuCallback, 
                strBuffer, 
                dwMenu,
                CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                0);
        Assert(hrOK == hr);

        strBuffer.LoadString(IDS_MENU_FLUSH_LOGS);
        hr = LoadAndAddMenuItem(pContextMenuCallback,
                                strBuffer,
                                IDS_MENU_FLUSH_LOGS,
                                CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                0);
        Assert(hrOK == hr);
        
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CLogDataHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    /* virtual listbox notifications come to the handler of the node that 
     * is selected. check to see if this notification is for a virtual 
     * listbox item or this SA node itself.
     */
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

 /*!--------------------------------------------------------------------------
    CLogDataHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CLogDataHandler::OnRefresh(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
    )
{
    HRESULT            hr            = S_OK;
    DWORD              dwNew         = 0;
    DWORD              dwTotal       = 0;
    int                i             = 0; 
    SPIConsole         spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

    //
    // Get new records if any
    //

    CORg(m_spSpdInfo->EnumLogData(&dwNew, &dwTotal));
    i = m_spSpdInfo->GetLogDataCount();
    
    //
    // Now notify the virtual listbox
    //

    CORg(m_spNodeMgr->GetConsole(&spConsole) );
    CORg(MaintainSelection());
    CORg(spConsole->UpdateAllViews(
                        pDataObject, 
                        i, 
                        RESULT_PANE_SET_VIRTUAL_LB_SIZE));

 Error:
    return hr;
}


/*---------------------------------------------------------------------------
    CLogDataHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    HRESULT     hr                   = S_OK;
    int         i                    = 0;
    CString     strBuffer;
    WZC_CONTEXT wzcContext           = {0};
    HANDLE      hSessionContainer    = NULL;
    SPIConsole  spConsole;
    DWORD       dwNew                = 0;
    DWORD       dwTotal              = 0;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    //
    // Handle the scope context menu commands here
    //
    
    switch (nCommandId)
    {
    case IDS_MENU_ENABLE_LOGGING:
    case IDS_MENU_DISABLE_LOGGING:

        strBuffer.Empty();
        m_spSpdInfo->GetComputerName(&strBuffer);

        //
        // Disabling logging will not flush client side logs or reset the
        // session. User may query these records if desired.
        //
        
        if (IDS_MENU_ENABLE_LOGGING == nCommandId)
        {
            wzcContext.dwFlags = WZC_CTXT_LOGGING_ON;

            //
            // Enumerate from the beginning, flush all the old logs
            //
            
            m_spSpdInfo->StartFromFirstRecord(TRUE);
            CORg(m_spSpdInfo->FlushLogs());
            CORg(m_spSpdInfo->EnumLogData(&dwNew, &dwTotal));
            
            //
            // Now notify the virtual listbox
            //

            CORg(m_spNodeMgr->GetConsole(&spConsole) );
            CORg(MaintainSelection());
            CORg(spConsole->UpdateAllViews(
                                pDataObject, 
                                dwTotal, 
                                RESULT_PANE_SET_VIRTUAL_LB_SIZE));
            
        }
        else
            wzcContext.dwFlags = 0;

        WZCSetContext(
            //strBuffer.IsEmpty()? NULL : (LPWSTR)(LPCWSTR)strBuffer,
            NULL,
            WZC_CONTEXT_CTL_LOG,
            &wzcContext,
            NULL);

        break;

    case IDS_MENU_FLUSH_LOGS:
        m_spSpdInfo->GetSession(&hSessionContainer);
        FlushWZCDbLog(hSessionContainer);
        CORg(m_spSpdInfo->FlushLogs());
        i = 0;
        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(
                              pDataObject,
                              i, 
                              RESULT_PANE_SET_VIRTUAL_LB_SIZE));
        break;
            
    default:
        break;
    }

COM_PROTECT_ERROR_LABEL;
    return hr;        
}

/*!--------------------------------------------------------------------------
    CLogDataHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));



    HRESULT hr = S_OK;
  /*
    SPITFSNode spNode;

    m_spResultNodeMgr->FindNode(cookie, &spNode);

   

	FILTER_TYPE NewFltrType = m_FltrType;

	// handle result context menu and view menus here
	switch (nCommandID)
    {
        case IDS_VIEW_ALL_FLTR:
			NewFltrType = FILTER_TYPE_ANY;
            break;

        case IDS_VIEW_TRANSPORT_FLTR:
			NewFltrType = FILTER_TYPE_TRANSPORT;
            break;

		case IDS_VIEW_TUNNEL_FLTR:
			NewFltrType = FILTER_TYPE_TUNNEL;
			break;

        default:
            break;
    }

	//Update the views if a different view is selected.
	if (NewFltrType != m_FltrType)
	{
		UpdateViewType(spNode, NewFltrType);
	}
	*/
    return hr;
}

/*!--------------------------------------------------------------------------
    CLogDataHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CLogDataHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD       dwError;
    DWORD       dwDynDnsFlags;

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    //CServerProperties * pServerProp = new CServerProperties(pNode, spComponentData, m_spTFSCompData, NULL);

    //
    // Object gets deleted when the page is destroyed
    //
    Assert(lpSA != NULL);

    //return pServerProp->CreateModelessSheet(lpSA, handle);
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CLogDataHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CLogDataHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CLogDataHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CLogDataHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CLogDataHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CLogDataHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);
    SPIResultData   spResultData;

    /* virtual listbox notifications come to the handler of the node that 
     * is selected. check to see if this notification is for a virtual 
     * listbox item or the active registrations node itself.
     */
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

    m_verbDefault = MMC_VERB_OPEN;
    if (!fSelect)
	{
        return hr;
	}

    if (m_spSpdInfo)
    {
        DWORD dwInitInfo;

        dwInitInfo=m_spSpdInfo->GetInitInfo();
        if (!(dwInitInfo & MON_LOG_DATA)) 
        {
            CORg(m_spSpdInfo->EnumLogData(NULL, NULL));            
            m_spSpdInfo->SetInitInfo(dwInitInfo | MON_LOG_DATA);
        }
        m_spSpdInfo->SetActiveInfo(MON_LOG_DATA);


        // Get the current count
        i = m_spSpdInfo->GetLogDataCount();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, 
                                         RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {        
        //we have a selected result item
        m_pComponent = pComponent;
        CORg(pComponent->GetResultData(&spResultData));
        CORg(GetSelectedItem(&m_nSelIndex, &m_SelLogData, spResultData));

        //TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = IPFWMON_LOGDATA_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
		
        //enable the "properties" and "refresh" menu
        bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
        bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
        m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);

        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);

        //hide "delete" and "properties" context menu 
        bStates[MMC_VERB_PROPERTIES & 0x000F] = FALSE;
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
        bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*
 * CLogDataHandler::OnResultColumnClick
 * Description: Handles the MMCN_COLUMN_CLICK notification
 * Parameters: 
 * Returns: S_OK - lets mmc know we handle notification
 *          other error - indicates a failure to mmc
 */
HRESULT CLogDataHandler::OnResultColumnClick(ITFSComponent *pComponent,
                                             LPARAM        nColumn,
                                             BOOL          bAscending)
{
    DWORD dwColID = 0;
    HRESULT hr = S_OK;

    Assert(nColumn < DimensionOf[IPFWMON_LOGDATA]);
    
    dwColID = aColumns[IPFWMON_LOGDATA][nColumn];
    hr = m_spSpdInfo->SetSortOptions(dwColID, bAscending);

    return hr;
}


/*!--------------------------------------------------------------------------
    CLogDataHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CLogDataHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CLogDataHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::HasPropertyPages(
    ITFSComponent *pComponent,
    MMC_COOKIE     cookie,
    LPDATAOBJECT   pDataObject
    )
{
    HRESULT            hr            = S_OK;
    int                nCount        = 0;
    int                nIndex        = 0;
    CLogDataProperties *pLogDataProp = NULL;
    CLogDataGenProp    *pGenProp     = NULL;
    CDataObject        *pDataObj     = NULL;
    SPINTERNAL         spInternal;

    nCount = HasPropSheetsOpen();

    ASSERT(nCount <= 1);

    if (nCount == 1)
    {
        //
        // Get the open page general and the page holder.
        //

        hr = GetOpenPropSheet(
                 0,
                 (CPropertyPageHolderBase **)&pLogDataProp);
        ASSERT(SUCCEEDED(hr));

        pGenProp = &pLogDataProp->m_pageGeneral;

        //
        // Get the virtual index from the new data object and the data object
        // which is used by the page holder.
        //

        spInternal = ExtractInternalFormat(pDataObject);

        ASSERT(spInternal->HasVirtualIndex());
        nIndex = spInternal->GetVirtualIndex();

        pDataObj = reinterpret_cast<CDataObject*>(pLogDataProp->m_pDataObject);

        //
        // Change the selection and shift the focus :).
        //

        hr = pGenProp->MoveSelection(
                           pLogDataProp, 
                           pDataObj, 
                           nIndex);

        ASSERT(SUCCEEDED(hr));

        pGenProp->SetFocus();

        //
        // Dont let MMC create another property sheet.
        //

        hr = S_FALSE;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CLogDataHandler::CreatePropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
    Modified: vbhanu
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::CreatePropertyPages(ITFSComponent               *pComponent, 
				     MMC_COOKIE                  cookie,
				     LPPROPERTYSHEETCALLBACK     lpProvider, 
				     LPDATAOBJECT 		 pDataObject, 
				     LONG_PTR 			 handle)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  HRESULT	hr = hrOK;
  SPINTERNAL  spInternal;
  SPITFSNode  spNode;
  int		nIndex;
  SPIComponentData spComponentData;
  CLogDataInfo LogDataInfo;
  CLogDataProperties * pLogDataProp;
    
  Assert(m_spNodeMgr);
	
  CORg( m_spNodeMgr->FindNode(cookie, &spNode) );
  CORg( m_spNodeMgr->GetComponentData(&spComponentData) );

  spInternal = ExtractInternalFormat(pDataObject);

  //
  // virtual listbox notifications come to the handler of the node that is 
  // selected.
  //

  // assert that this notification is for a virtual listbox item 
  Assert(spInternal);
  if (!spInternal->HasVirtualIndex())
    return hr;

  nIndex = spInternal->GetVirtualIndex();

  // Get the complete record
  CORg(m_spSpdInfo->GetSpecificLog(nIndex, &LogDataInfo));
  
  pLogDataProp = new CLogDataProperties(
                         spNode,
                         spComponentData,
                         m_spTFSCompData,
                         &LogDataInfo,
                         m_spSpdInfo,
                         NULL, 
                         pDataObject,
                         m_spNodeMgr,
                         pComponent);

  hr = pLogDataProp->CreateModelessSheet(lpProvider, handle);
      
  COM_PROTECT_ERROR_LABEL;
  return hr;
}


/*---------------------------------------------------------------------------
    CLogDataHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CLogDataHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CLogDataHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CLogDataHandler::GetVirtualImage
(
    int     nIndex
)
{
    HRESULT hr;
    int nImgIndex = ICON_IDX_LOGDATA_UNKNOWN;
    CLogDataInfo LogData;
    PWZC_DB_RECORD pwzcDbRecord = NULL;

    CORg(m_spSpdInfo->GetLogDataInfo(nIndex, &LogData));
    pwzcDbRecord = &LogData.m_wzcDbRecord;

    switch (pwzcDbRecord->category)
    {
    case DBLOG_CATEG_INFO:
        nImgIndex = ICON_IDX_LOGDATA_INFORMATION;
        break;

    case DBLOG_CATEG_WARN:
        nImgIndex = ICON_IDX_LOGDATA_WARNING;
        break;

    case DBLOG_CATEG_ERR:
        nImgIndex = ICON_IDX_LOGDATA_ERROR;
        break;

    case DBLOG_CATEG_PACKET:
        nImgIndex = ICON_IDX_LOGDATA_INFORMATION;
        break;

    default:
        nImgIndex = ICON_IDX_LOGDATA_UNKNOWN;
        break;
    }

COM_PROTECT_ERROR_LABEL;

    return nImgIndex;
}

/*---------------------------------------------------------------------------
    CLogDataHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR 
CLogDataHandler::GetVirtualString(int     nIndex,
                                  int     nCol)
{
    HRESULT hr = S_OK;
    static CString strTemp;
    LPTSTR  lptstrTemp = NULL;
    
    CLogDataInfo logData;
    PWZC_DB_RECORD pwzcDbRecord = NULL;
    
    strTemp.Empty();
    
    if (nCol >= DimensionOf(aColumns[IPFWMON_LOGDATA]))
        return NULL;
    
    CORg(m_spSpdInfo->GetLogDataInfo(nIndex, &logData));

    pwzcDbRecord = &logData.m_wzcDbRecord;
    switch (aColumns[IPFWMON_LOGDATA][nCol])
    {
    case IDS_COL_LOGDATA_MSG:
        if (pwzcDbRecord->message.pData != NULL)
        {
            strTemp = (LPWSTR) (pwzcDbRecord->message.pData);
            if (pwzcDbRecord->message.dwDataLen > MAX_SUMMARY_MESSAGE_SIZE)
                strTemp += ELLIPSIS;
        }
        break;
        
    case IDS_COL_LOGDATA_TIME:
        FileTimeToString(pwzcDbRecord->timestamp, &strTemp);
        break;
        
    case IDS_COL_LOGDATA_CAT:
        CategoryToString(pwzcDbRecord->category, strTemp);
        break;
        
    case IDS_COL_LOGDATA_COMP_ID:
        ComponentIDToString(pwzcDbRecord->componentid, strTemp);
        break;
        
    case IDS_COL_LOGDATA_LOCAL_MAC_ADDR:
        if (pwzcDbRecord->localmac.pData != NULL)
            strTemp = (LPWSTR)pwzcDbRecord->localmac.pData;
        break;
        
    case IDS_COL_LOGDATA_REMOTE_MAC_ADDR:
        if (pwzcDbRecord->remotemac.pData != NULL)
            strTemp = (LPWSTR)pwzcDbRecord->remotemac.pData;
        break;
        
    case IDS_COL_LOGDATA_SSID:
        if (pwzcDbRecord->ssid.pData != NULL)
        {
            lptstrTemp = strTemp.GetBuffer(pwzcDbRecord->ssid.dwDataLen);
            CopyAndStripNULL(lptstrTemp, 
                             (LPTSTR)pwzcDbRecord->ssid.pData, 
                             pwzcDbRecord->ssid.dwDataLen);
            strTemp.ReleaseBuffer();
        }
        break;
        
    default:
        Panic0("CLogDataHandler::GetVirtualString - Unknown column!\n");
        break;
    }
    
    COM_PROTECT_ERROR_LABEL;
    return strTemp;
}

/*---------------------------------------------------------------------------
    CLogDataHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CLogDataHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*
 * CLogDataHandler::SortItems
 * Description: Sorting of the virtual listbox items
 * Parameters:
 * Returns:
 */
HRESULT CLogDataHandler::SortItems(int nColumn, DWORD dwSortOptions, 
                                   LPARAM lUserParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = S_OK;
    BEGIN_WAIT_CURSOR
	
    hr = m_spSpdInfo->SortLogData();
	
    END_WAIT_CURSOR

    return hr;
}

/*!--------------------------------------------------------------------------
    CLogDataHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CLogDataHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPFWMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CLogDataHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CLogDataHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CLogDataHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CLogDataHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}

/*---------------------------------------------------------------------------
    CLogDataHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CLogDataHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;

    Trace0("CLogDataHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, 
                                          CCT_RESULT, 
                                          &pDataObject) );
    spDataObject = pDataObject;

    i = m_spSpdInfo->GetLogDataCount();

    CORg(MaintainSelection());
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPFWMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CLogDataHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CLogDataHandler::InitData
(
    ISpdInfo *     pSpdInfo
)
{

    m_spSpdInfo.Set(pSpdInfo);

    return hrOK;
}

/*
  CLogDataHandler::GetSelectedItem
  
  Description:
  Returns the underlying LogData for a selected item
  
  Parameters:
  [out] pLogData - Holds a copy of the item. Caller must allocate space for
                   the base holder. Inner items are allocated by CLogDataInfo
  [in]  pResultData - Used to call GetNextItem

  Returns:
  S_OK on success
*/

HRESULT CLogDataHandler::GetSelectedItem(int *pnIndex, CLogDataInfo *pLogData,
                                         IResultData *pResultData)
{
    HRESULT hr = S_OK;
    RESULTDATAITEM rdi;

    if ( (NULL == pLogData) || (NULL == pnIndex) || (NULL == pResultData) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Error;
    }

    memset(&rdi, 0, sizeof(RESULTDATAITEM));

    rdi.mask = RDI_STATE | RDI_INDEX;
    //search from the beginning
    rdi.nIndex = -1;
    //for a selected item
    rdi.nState = LVIS_SELECTED;

    //start the search
    CORg(pResultData->GetNextItem(&rdi));

    //copy out the item
    *pnIndex = rdi.nIndex;
    CORg(m_spSpdInfo->GetLogDataInfo(rdi.nIndex, pLogData));

    COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*
  CLogDataHandler::GetSelectedItemState
  
  Description:
  Gets the item ID and lparam of the item that was selected
  
  Parameters:
  [out] puiState - Holds the state of the item. Caller must allocate space.
  [in]  pResultData - Used to call GetItem

  Returns:
  S_OK on success
*/

HRESULT CLogDataHandler::GetSelectedItemState(UINT *puiState, 
                                              IResultData *pResultData)
{
    HRESULT hr = S_OK;
    RESULTDATAITEM rdi;

    if ( (NULL == puiState) || (NULL == pResultData) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Error;
    }

    memset(&rdi, 0, sizeof(RESULTDATAITEM));

    rdi.mask = RDI_STATE | RDI_INDEX;
    //search from the beginning
    rdi.nIndex = -1;
    //for a selected item
    rdi.nState = LVIS_SELECTED;

    //start the search
    CORg(pResultData->GetNextItem(&rdi));

    //copy out the state
    *puiState = (UINT) rdi.nState;

    COM_PROTECT_ERROR_LABEL;
    return hr;
}

/* 
   CLogDataHandler::MaintainSelection
   Maintains the selection at the current selected item once new items
   have been added to the virtual list.

   Returns:
   S_OK on success
*/
HRESULT CLogDataHandler::MaintainSelection()
{
    UINT               uiState      = 0;
    HRESULT            hr           = S_OK;
    int                nCount       = 0;
    CLogDataProperties *pLogDataProp = NULL;
    CLogDataGenProp    *pGenProp     = NULL;
    CDataObject        *pDataObj     = NULL;
    SPIResultData      spResultData;

    //If we dont have our component yet, ie no selection was made
    if (NULL == m_pComponent)
        goto Error;

    //Ensure item at current selected index is not selected
    CORg(m_pComponent->GetResultData(&spResultData));
    CORg(GetSelectedItemState(&uiState, spResultData));
    CORg(spResultData->ModifyItemState(m_nSelIndex, 0, 0, 
                                       LVIS_SELECTED | LVIS_FOCUSED)); 

    //Find the new index of the current item and set it to the old state
    CORg(m_spSpdInfo->FindIndex(&m_nSelIndex, &m_SelLogData));
    if (m_nSelIndex < 0)
        CORg(m_spSpdInfo->GetLastIndex(&m_nSelIndex));
    CORg(spResultData->ModifyItemState(m_nSelIndex, 0, uiState, 0)); 

    //
    // Update any open property pages to the new index
    //

    nCount = HasPropSheetsOpen();

    ASSERT(nCount <= 1);

    if (nCount == 1)
    {
        //
        // Get the open page general and the page holder.
        //

        hr = GetOpenPropSheet(
                 0,
                 (CPropertyPageHolderBase **)&pLogDataProp);
        ASSERT(SUCCEEDED(hr));

        pGenProp = &pLogDataProp->m_pageGeneral;

        //
        // Change the selected index for the property page
        //

        pDataObj = reinterpret_cast<CDataObject*>(pLogDataProp->m_pDataObject);
        pDataObj->SetVirtualIndex(m_nSelIndex);
    }

    COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*
HRESULT 
CLogDataHandler::UpdateViewType(ITFSNode * pNode, FILTER_TYPE NewFltrType)
{
	// clear the listbox then set the size

    HRESULT             hr = hrOK;
    SPIComponentData    spCompData;
    SPIConsole          spConsole;
    IDataObject*        pDataObject;
    SPIDataObject       spDataObject;
    LONG_PTR            command;               
    int i;

    COM_PROTECT_TRY
    {
		m_FltrType = NewFltrType;

		//tell the spddb to update its index manager for QM filter
		m_spSpdInfo->ChangeLogDataViewType(m_FltrType);

        i = m_spSpdInfo->GetLogDataCountOfCurrentViewType();

		m_spNodeMgr->GetComponentData(&spCompData);

        CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    
		//update the result pane virtual list
        CORg ( spConsole->UpdateAllViews(spDataObject, i, RESULT_PANE_CLEAR_VIRTUAL_LB) ); 

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\logdatapp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    logdatapp.cpp
        Log data properties implementation file

    FILE HISTORY:
        oct/11/2001 - vbhanu modified
*/

#include "stdafx.h"
#include "logdatapp.h"
#include "logdatanode.h"
#include "spdutil.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CLogDataProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CLogDataProperties::CLogDataProperties(
    ITFSNode            *pNode,
    IComponentData      *pComponentData,
    ITFSComponentData   *pTFSCompData,
    CLogDataInfo        *pLogDataInfo,
    ISpdInfo            *pSpdInfo,
    LPCTSTR             pszSheetName,
    LPDATAOBJECT        pDataObject,
    ITFSNodeMgr         *pNodeMgr,
    ITFSComponent       *pComponent)
  : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

    AddPageToList((CPropertyPageBase*) &m_pageGeneral);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

    m_LogDataInfo = *pLogDataInfo;

    m_bTheme = TRUE;

    m_pDataObject = pDataObject;
    m_pNodeMgr = pNodeMgr;

    m_pComponent = pComponent;
    m_pageGeneral.SetLogDataProperties(this);
}

CLogDataProperties::~CLogDataProperties()
{
    RemovePageFromList((CPropertyPageBase*) &m_pageGeneral, FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CLogDataGenProp property page

IMPLEMENT_DYNCREATE(CLogDataGenProp, CPropertyPageBase)

CLogDataGenProp::CLogDataGenProp() 
    : CPropertyPageBase(CLogDataGenProp::IDD)
{
    //{{AFX_DATA_INIT(CLogDataGenProp)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_hgCopy = NULL;
}

CLogDataGenProp::~CLogDataGenProp()
{
    if (m_hgCopy != NULL)
        GlobalFree(m_hgCopy);
}

void 
CLogDataGenProp::DoDataExchange(
    CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLogDataGenProp)
    //DDX_Control(pDX, IDC_LIST_SPECIFIC, m_listSpecificFilters);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLogDataGenProp, CPropertyPageBase)
    //{{AFX_MSG_MAP(CLogDataGenProp)
    ON_BN_CLICKED(IDC_BTN_MOVE_UP, OnButtonUp)
    ON_BN_CLICKED(IDC_BTN_MOVE_DOWN, OnButtonDown)
    ON_BN_CLICKED(IDC_BTN_COPY, OnButtonCopy)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogDataGenProp message handlers

BOOL 
CLogDataGenProp::OnInitDialog() 
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  CPropertyPageBase::OnInitDialog();

  PopulateLogInfo();
  
  SetDirty(FALSE);

  return TRUE;  // return TRUE unless you set the focus to a control
                // EXCEPTION: OCX Property Pages should return FALSE
}


HRESULT 
CLogDataGenProp::SetLogDataProperties(
    CLogDataProperties *pLogDataProp)
/*++
    CLogDataGenProp::SetLogDataProperties - Sets member var to parent
    
    Arguments:
    pLogDataProp - A pointer to the parent class
    
    Returns: 
    S_OK on success
--*/
{
    HRESULT hr = S_OK;

    if (NULL == pLogDataProp)
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    else
        m_pLogDataProp = pLogDataProp;

    return hr;
}


HRESULT 
CLogDataGenProp::GetSelectedItemState(
    int *pnSelIndex, 
    PUINT puiState, 
    IResultData *pResultData)
/*++ 
   CLogDataGenProp::GetSelectedItemState - Gets the list item state for the
   selected item
   
   Arguments:
   [out] puiState - holds the state of the item
   [out] nIndex - Returns the index to the selected item
   [in]  pResultData - Pointer to result data to use for the search

   Returns:
   S_OK on success
--*/
{
    HRESULT hr = S_OK;
    RESULTDATAITEM rdi;

    if ( (NULL == puiState) || (NULL == pResultData) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Error;
    }

    memset(&rdi, 0, sizeof(RESULTDATAITEM));

    rdi.mask = RDI_STATE | RDI_INDEX;
    //search from the beginning
    rdi.nIndex = -1;
    //for a selected item
    rdi.nState = LVIS_SELECTED;

    //start the search
    CORg(pResultData->GetNextItem(&rdi));

    //copy out the state
    *puiState = (UINT) rdi.nState;
    *pnSelIndex = rdi.nIndex;

    COM_PROTECT_ERROR_LABEL;
    return hr;
}


#if 0

HRESULT 
CLogDataGenProp::MoveSelection(
    int nIndexTo
    )
/*++

Routine Description:

    CLogDataGenProp::UpdateSelection:
    Moves the selection to the specified index
    
Arguments:

    nIndexTo - A valid virtual index to move to
    
Returns:

    S_OK on success

--*/
{
    int nIndexFrom = 0;
    UINT uiState = 0;
    HRESULT hr = S_OK;
    SPIResultData spResultData;

    CORg(m_pLogDataProp->m_pComponent->GetResultData(&spResultData));
    CORg(GetSelectedItemState(&nIndexFrom, &uiState, spResultData));
    CORg(spResultData->ModifyItemState(nIndexFrom, 0, 0, 
                                       LVIS_SELECTED | LVIS_FOCUSED));
    CORg(spResultData->ModifyItemState(nIndexTo, 0, uiState, 0));

    COM_PROTECT_ERROR_LABEL;
    return hr;
}

void 
CLogDataGenProp::OnButtonUp()
{
    int nIndex = 0;
    HRESULT hr = hrOK;
    CLogDataInfo *pLogDataInfo = NULL;
    CLogDataProperties *pLogDataProp = (CLogDataProperties *)GetHolder();
    CDataObject *pDataObject = NULL;
    SPIConsole spConsole;
    int nCount = 0;
    
    pDataObject = reinterpret_cast<CDataObject *>(pLogDataProp->m_pDataObject);
    nIndex = pDataObject->GetVirtualIndex();
    nIndex--;

    pLogDataProp->GetLogDataInfo(&pLogDataInfo);
    ASSERT(pLogDataInfo != NULL);

    //
    // Free up the space occupied by the previous log entry
    //

    pLogDataInfo->Deallocate();

    CORg(pLogDataProp->m_spSpdInfo->GetSpecificLog(
            nIndex, 
            pLogDataInfo));

    //
    // Refresh the contents
    //

    ShowSpecificInfo(pLogDataInfo);
    pDataObject->SetVirtualIndex(nIndex);
    MoveSelection(nIndex);
    
    //
    // Force the listbox to update its status
    //

    pLogDataProp->m_pNodeMgr->GetConsole(&spConsole);
    nCount = pLogDataProp->m_spSpdInfo->GetLogDataCount();
    spConsole->UpdateAllViews(pDataObject, nCount, IPFWMON_UPDATE_STATUS);

    COM_PROTECT_ERROR_LABEL;
    if (FAILED(hr))
    {
        switch(hr)
        {
        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            //
            // Get the old log back
            //
        
            nIndex++;
            hr = pLogDataProp->m_spSpdInfo->GetSpecificLog(
                nIndex, 
                pLogDataInfo);
            ASSERT(SUCCEEDED(hr));
        
            //
            // Display a warning
            //
        
            AfxMessageBox(IDS_LOGDATA_WARN_BOF, MB_OK | MB_ICONEXCLAMATION, 0);
            break;

        default:
            //
            // Unexpected error
            //

            ASSERT(FALSE);
            break;
        }
    }
}


void 
CLogDataGenProp::OnButtonDown()
{
    int nIndex = 0;
    HRESULT hr = hrOK;
    CLogDataInfo *pLogDataInfo = NULL;
    CLogDataProperties *pLogDataProp = (CLogDataProperties *)GetHolder();
    CDataObject *pDataObject = NULL;
    SPIConsole spConsole;
    int nCount = 0;

    pDataObject = reinterpret_cast<CDataObject *>(pLogDataProp->m_pDataObject);
    nIndex = pDataObject->GetVirtualIndex();
    nIndex++;

    pLogDataProp->GetLogDataInfo(&pLogDataInfo);    
    ASSERT(pLogDataInfo != NULL);

    //
    // Free up the space occupied by the previous log entry
    //

    pLogDataInfo->Deallocate();

    CORg(pLogDataProp->m_spSpdInfo->GetSpecificLog(
            nIndex, 
            pLogDataInfo));
    //
    // Refresh the contents
    //

    ShowSpecificInfo(pLogDataInfo);
    pDataObject->SetVirtualIndex(nIndex);
    MoveSelection(nIndex);

    //
    // Force the listbox to update its status
    //

    pLogDataProp->m_pNodeMgr->GetConsole(&spConsole);
    nCount = pLogDataProp->m_spSpdInfo->GetLogDataCount();
    spConsole->UpdateAllViews(pDataObject, nCount, IPFWMON_UPDATE_STATUS);

    COM_PROTECT_ERROR_LABEL;
    if (FAILED(hr))
    {
        switch(hr)
        {
        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            //
            // Get the old log back
            //
        
            nIndex--;
            hr = pLogDataProp->m_spSpdInfo->GetSpecificLog(
                nIndex, 
                pLogDataInfo);
            ASSERT(SUCCEEDED(hr));
        
            //
            // Display a warning
            //
            AfxMessageBox(IDS_LOGDATA_WARN_EOF, MB_OK | MB_ICONEXCLAMATION, 0);
            break;
    
        default:
            //
            // Unexpected error
            //
            ASSERT(FALSE);
            break;
        }
    }
}

#endif //0


HRESULT
CLogDataGenProp::MoveSelection(
    CLogDataProperties *pLogDataProp,
    CDataObject        *pDataObj,
    int                nIndexTo                              
    )
/*++

Routine Description:

    CLogDataGenProp::MoveSelection:
    Moves the selection to the specified index
    
Arguments:

    nIndexTo - A valid virtual index to move to
    
Returns:

    S_OK on success
    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if the index could not be located

--*/
{
    HRESULT            hr            = S_OK;
    HRESULT            hrErr         = S_OK;
    int                nIndexFrom    = 0;
    int                nCount        = 0;
    UINT               uiState       = 0;
    CLogDataInfo       *pLogDataInfo = NULL;
    SPIConsole         spConsole;
    SPIResultData      spResultData;

    //
    // Blow the old record away
    //
    pLogDataProp->GetLogDataInfo(&pLogDataInfo);
    
    ASSERT(pLogDataInfo != NULL);

    pLogDataInfo->Deallocate();

    //
    // Attempt to get the new record at nIndexTo
    //
    
    CORg(pLogDataProp->m_spSpdInfo->GetSpecificLog(
             nIndexTo, 
             pLogDataInfo));

    //
    // Refresh the contents and the selection
    //

    ShowSpecificInfo(pLogDataInfo);
    pDataObj->SetVirtualIndex(nIndexTo);

    CORg(m_pLogDataProp->m_pComponent->GetResultData(&spResultData));
    CORg(GetSelectedItemState(&nIndexFrom, &uiState, spResultData));
    CORg(spResultData->ModifyItemState(nIndexFrom, 0, 0, 
                                       LVIS_SELECTED | LVIS_FOCUSED));
    CORg(spResultData->ModifyItemState(nIndexTo, 0, uiState, 0));
    
    //
    // Force the listbox to update its status
    //

    pLogDataProp->m_pNodeMgr->GetConsole(&spConsole);
    nCount = pLogDataProp->m_spSpdInfo->GetLogDataCount();
    spConsole->UpdateAllViews(
                   pDataObj, 
                   nCount, 
                   IPFWMON_UPDATE_STATUS);

    COM_PROTECT_ERROR_LABEL;
    if (FAILED(hr))
    {
        switch(hr)
        {
        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            //
            // Get the old log back, we have not yet updated the display or
            // the virtual index.
            //
        
            hrErr = pLogDataProp->m_spSpdInfo->GetSpecificLog(
                                                   nIndexFrom, 
                                                   pLogDataInfo);
            ASSERT(SUCCEEDED(hrErr));
            break;

        default:
            //
            // Should never happen.
            //
            
            ASSERT(FALSE);
            break;
        }
    }

    return hr;
}


void 
CLogDataGenProp::OnButtonUp()
/*++

Routine Description:

    CLogDataGenProp::OnButtonUp:
    Moves the selection up by a single record
    
Arguments:

    None.
    
Returns:

    Nothing.

--*/
{
    HRESULT            hr            = S_OK;
    int                nIndex        = 0;
    CLogDataProperties *pLogDataProp = NULL;
    CDataObject        *pDataObj     = NULL;

    //
    // Get the parent class, data object and the new index
    //

    pLogDataProp = (CLogDataProperties *)GetHolder();
    pDataObj = reinterpret_cast<CDataObject *>(pLogDataProp->m_pDataObject);
    
    nIndex = pDataObj->GetVirtualIndex();
    nIndex--;

    //
    // Try moving the selection up
    //

    CORg(MoveSelection(
             pLogDataProp, 
             pDataObj,
             nIndex));

    COM_PROTECT_ERROR_LABEL;
    if (FAILED(hr))
    {
        switch(hr)
        {
        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            //
            // Display a warning, indicating BOF as this is the only possible
            // reason for this error.
            //
        
            AfxMessageBox(
                IDS_LOGDATA_WARN_BOF, 
                MB_OK | MB_ICONEXCLAMATION, 
                0);
            break;

        default:
            //
            // Unexpected error
            //

            ASSERT(FALSE);
            break;
        }            
    }
}


void 
CLogDataGenProp::OnButtonDown()
/*++

Routine Description:

    CLogDataGenProp::OnButtonDown:
    Moves the selection down by a single record
    
Arguments:

    None.
    
Returns:

    Nothing.

--*/
{
    HRESULT            hr            = S_OK;
    int                nIndex        = 0;
    CLogDataProperties *pLogDataProp = NULL;
    CDataObject        *pDataObj     = NULL;

    //
    // Get the parent class, data object and the new index
    //

    pLogDataProp = (CLogDataProperties *)GetHolder();
    pDataObj = reinterpret_cast<CDataObject *>(pLogDataProp->m_pDataObject);
    
    nIndex = pDataObj->GetVirtualIndex();
    nIndex++;

    //
    // Try moving the selection down
    //

    CORg(MoveSelection(
             pLogDataProp, 
             pDataObj,
             nIndex));

    COM_PROTECT_ERROR_LABEL;
    if (FAILED(hr))
    {
        switch(hr)
        {
        case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
            //
            // Display a warning, indicating BOF as this is the only possible
            // reason for this error.
            //
        
            AfxMessageBox(
                IDS_LOGDATA_WARN_EOF, 
                MB_OK | MB_ICONEXCLAMATION, 
                0);
            break;

        default:
            //
            // Unexpected error
            //

            ASSERT(FALSE);
            break;
        }            
    }
}


#if 0
void 
CLogDataGenProp::OnSelectionJump(
    int nIndex
    )
/*++

Routine Description:

    CLogDataGenProp::OnSelectionJump:
    Changes the selection to a specific index
    
Arguments:

    nIndex - The index to jump to
    
Returns:

    Nothing.

--*/
{
    HRESULT            hr            = S_OK;
    CLogDataProperties *pLogDataProp = NULL;
    CDataObject        *pDataObj     = NULL;

    //
    // Get the parent class, data object and the new index
    //

    pLogDataProp = (CLogDataProperties *)GetHolder();
    pDataObj = reinterpret_cast<CDataObject *>(pLogDataProp->m_pDataObject);

    //
    // Try moving the selection
    //

    CORg(MoveSelection(
             pLogDataProp, 
             pDataObj,
             nIndex));

    COM_PROTECT_ERROR_LABEL;
    ASSERT(SUCCEDED(hr));
}
#endif //0


#define PRECOMPUTED_STATIC_SIZE 200
void 
CLogDataGenProp::OnButtonCopy()
{
    DWORD dwErr = ERROR_SUCCESS;
    int nNumBytes = 0;
    BOOL bClipOpened = FALSE;
    BOOL bErr = FALSE;
    LPTSTR lptstrCopy = NULL;
    DWORD dwSize = PRECOMPUTED_STATIC_SIZE * sizeof(TCHAR);
    CString csTemp;
    CLogDataInfo *pLogDataInfo = NULL;
    CLogDataProperties *pLogDataProp = (CLogDataProperties *)GetHolder();
    HANDLE hData = NULL;
    
    Assert(pLogDataProp);
    pLogDataProp->GetLogDataInfo(&pLogDataInfo);

    dwSize += pLogDataInfo->m_wzcDbRecord.message.dwDataLen +
              pLogDataInfo->m_wzcDbRecord.ssid.dwDataLen +
              pLogDataInfo->m_wzcDbRecord.context.dwDataLen;
    
    //open the clipboard
    bClipOpened = ::OpenClipboard(NULL);
    if (FALSE == bClipOpened)
        goto exit;

    bErr = EmptyClipboard();
    if (FALSE == bErr)
    {
        dwErr = GetLastError();
        goto exit;
    }
    
    //copy
    if (m_hgCopy != NULL)
        GlobalFree(m_hgCopy);
    
    m_hgCopy = GlobalAlloc(GMEM_MOVEABLE, dwSize);
    if (NULL == m_hgCopy)
        goto exit;

    lptstrCopy = (LPTSTR) GlobalLock(m_hgCopy);

    ComponentIDToString(pLogDataInfo->m_wzcDbRecord.componentid, csTemp);
    nNumBytes = _stprintf(lptstrCopy, _T("Source: %s\r\n"), (LPCTSTR)csTemp);
    lptstrCopy += nNumBytes;
    
    CategoryToString(pLogDataInfo->m_wzcDbRecord.category, csTemp);
    nNumBytes = _stprintf(lptstrCopy, _T("Type: %s\r\n"),(LPCTSTR)csTemp);
    lptstrCopy += nNumBytes;

    FileTimeToString(pLogDataInfo->m_wzcDbRecord.timestamp, &csTemp);
    nNumBytes = _stprintf(lptstrCopy, _T("Timestamp: %s\r\n"),(LPCTSTR)csTemp);
    lptstrCopy += nNumBytes;
    
    nNumBytes = _stprintf(lptstrCopy, _T("Description: %s\r\n"),
                        (LPCTSTR) pLogDataInfo->m_wzcDbRecord.message.pData);
    lptstrCopy += nNumBytes;
   
    nNumBytes = _stprintf(lptstrCopy, _T("Local MAC: %s\r\n"),
                          (LPCTSTR)pLogDataInfo->m_wzcDbRecord.localmac.pData);
    lptstrCopy += nNumBytes;
    
    nNumBytes = _stprintf(lptstrCopy, _T("Remote MAC: %s\r\n"),
                        (LPCTSTR)pLogDataInfo->m_wzcDbRecord.remotemac.pData);
    lptstrCopy += nNumBytes;

    nNumBytes = _stprintf(lptstrCopy, _T("SSID: "));
    lptstrCopy += nNumBytes;
    
    CopyAndStripNULL(lptstrCopy, 
                     (LPTSTR)pLogDataInfo->m_wzcDbRecord.ssid.pData, 
                     pLogDataInfo->m_wzcDbRecord.ssid.dwDataLen);
    lptstrCopy += pLogDataInfo->m_wzcDbRecord.ssid.dwDataLen/sizeof(TCHAR) - 1;
    nNumBytes = _stprintf(lptstrCopy, _T("\r\n"));
    lptstrCopy += nNumBytes;
    
    nNumBytes = _stprintf(lptstrCopy, _T("Details: %s\r\n"), 
                          (LPWSTR) pLogDataInfo->m_wzcDbRecord.context.pData);

    GlobalUnlock(m_hgCopy);

    hData = SetClipboardData(CF_UNICODETEXT, m_hgCopy);
    if (NULL == hData)
        dwErr = GetLastError();        
exit:    
    //close clipboard
    if (TRUE == bClipOpened)
        CloseClipboard();
}

void 
CLogDataGenProp::ShowSpecificInfo(
    CLogDataInfo *pLogDataInfo)
{
    LPTSTR lptstrTemp = NULL;
    CString csTemp;

    ComponentIDToString(pLogDataInfo->m_wzcDbRecord.componentid, csTemp);
    GetDlgItem(IDC_LOGDATA_EDIT1)->SetWindowText(csTemp);

    CategoryToString(pLogDataInfo->m_wzcDbRecord.category, csTemp);
    GetDlgItem(IDC_LOGDATA_EDIT2)->SetWindowText(csTemp);

    FileTimeToString(pLogDataInfo->m_wzcDbRecord.timestamp, &csTemp);
    GetDlgItem(IDC_LOGDATA_EDIT3)->SetWindowText(csTemp);

    if (NULL != pLogDataInfo->m_wzcDbRecord.message.pData)
        csTemp = (LPWSTR) pLogDataInfo->m_wzcDbRecord.message.pData;
    else
        csTemp = _T("");
    GetDlgItem(IDC_LOGDATA_EDIT4)->SetWindowText(csTemp);

    if (NULL != pLogDataInfo->m_wzcDbRecord.localmac.pData)
        csTemp = (LPWSTR) pLogDataInfo->m_wzcDbRecord.localmac.pData;
    else
        csTemp = _T("");
    GetDlgItem(IDC_LOGDATA_EDIT5)->SetWindowText(csTemp);
        
    if (NULL != pLogDataInfo->m_wzcDbRecord.remotemac.pData)
        csTemp = (LPWSTR) pLogDataInfo->m_wzcDbRecord.remotemac.pData;
    else
        csTemp = _T("");
    GetDlgItem(IDC_LOGDATA_EDIT6)->SetWindowText(csTemp);
        
    if (NULL != pLogDataInfo->m_wzcDbRecord.ssid.pData)
    {
        lptstrTemp = csTemp.GetBuffer(pLogDataInfo->
                                     m_wzcDbRecord.ssid.dwDataLen);
        CopyAndStripNULL(lptstrTemp, 
                         (LPTSTR)pLogDataInfo->m_wzcDbRecord.ssid.pData, 
                         pLogDataInfo->m_wzcDbRecord.ssid.dwDataLen);
        csTemp.ReleaseBuffer();
    }
    else
        csTemp = _T("");
    GetDlgItem(IDC_LOGDATA_EDIT7)->SetWindowText(csTemp);

    if (NULL != pLogDataInfo->m_wzcDbRecord.context.pData)
        csTemp = (LPWSTR) pLogDataInfo->m_wzcDbRecord.context.pData;
    else
        csTemp = _T("");
    GetDlgItem(IDC_LOGDATA_EDIT8)->SetWindowText(csTemp);
}


void 
CLogDataGenProp::SetButtonIcon(
    HWND hwndBtn, 
    ULONG ulIconID)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HICON hIcon = NULL;
    HICON hIconPrev = NULL;

    hIcon = (HICON) LoadImage(AfxGetInstanceHandle(), 
                              MAKEINTRESOURCE(ulIconID), IMAGE_ICON,
                              16, 16, LR_DEFAULTCOLOR);
    if (hIcon != NULL)
    {
        hIconPrev = (HICON) ::SendMessage(hwndBtn, BM_SETIMAGE, 
                                          (WPARAM) IMAGE_ICON,
                                          (LPARAM) hIcon);
        if (hIconPrev != NULL)
            DestroyIcon(hIconPrev);
    }
}


void 
CLogDataGenProp::PopulateLogInfo()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd *pWnd = NULL;
    CLogDataInfo *pLogDataInfo = NULL;
    CLogDataProperties *pLogDataProp = (CLogDataProperties *)GetHolder();

    Assert(pLogDataProp);
    pLogDataProp->GetLogDataInfo(&pLogDataInfo);

    //set fancy buttons
    pWnd = GetDlgItem(IDC_BTN_MOVE_UP);
    SetButtonIcon(pWnd->m_hWnd, IDI_LOG_UP_ARROW);

    pWnd = GetDlgItem(IDC_BTN_MOVE_DOWN);
    SetButtonIcon(pWnd->m_hWnd, IDI_LOG_DOWN_ARROW);

    pWnd = GetDlgItem(IDC_BTN_COPY);
    SetButtonIcon(pWnd->m_hWnd, IDI_LOG_COPY);

    ShowSpecificInfo(pLogDataInfo);
}


BOOL 
CLogDataGenProp::OnApply() 
{
  if (!IsDirty())
    return TRUE;
  
  UpdateData();
  
  //TODO
  //Do nothing at this time
  
  //CPropertyPageBase::OnApply();
  
  return TRUE;
}

BOOL 
CLogDataGenProp::OnPropertyChange(
    BOOL bScope, 
    LONG_PTR *ChangeMask)
{
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\mdlsdlg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    SrchFltr.h   
        Search Filter dialog header file

	FILE HISTORY:
        
*/

#if !defined(AFX_MODELESSDLG_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_MODELESSDLG_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_

#include "spddb.h"
#include "ipctrl.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CModelessDlg dialog

class CModelessDlg : public CBaseDialog
{
// Construction
public:
	CModelessDlg();   // standard constructor
	virtual ~CModelessDlg();

	HANDLE GetSignalEvent() { return m_hEventThreadKilled; }

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchFilters)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	virtual void OnOK();
	virtual void OnCancel();

	// Generated message map functions
	//{{AFX_MSG(CModelessDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// This is used by the thread and the handler (the thread signals
   // the handler that it has cleaned up after itself).
   HANDLE   m_hEventThreadKilled;

};

void CreateModelessDlg(CModelessDlg * pDlg,
					   HWND hWndParent,
                       UINT  nIDD);

void WaitForModelessDlgClose(CModelessDlg *pWndStats);

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_MODELESSDLG_H__77C7FD5C_6CE5_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\mdlsdlg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    MdlsDlg.cpp
		The class to handle modelss dialog in the snapin

	FILE HISTORY:

*/

#include "stdafx.h"
#include "modeless.h"
#include "MdlsDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CModelessDlg dialog


CModelessDlg::CModelessDlg()
	: CBaseDialog()
{
	//{{AFX_DATA_INIT(CModelessDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_hEventThreadKilled = ::CreateEvent(NULL, FALSE, FALSE, NULL);
	Assert(m_hEventThreadKilled);
}

CModelessDlg::~CModelessDlg()
{
	if (m_hEventThreadKilled)
		::CloseHandle(m_hEventThreadKilled);
	m_hEventThreadKilled = 0;
}

void CModelessDlg::DoDataExchange(CDataExchange* pDX)
{
	CBaseDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CModelessDlg)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CModelessDlg, CBaseDialog)
	//{{AFX_MSG_MAP(CModelessDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CModelessDlg message handlers

void CModelessDlg::OnOK()
{
	DestroyWindow();

	// Explicitly kill this thread.
	AfxPostQuitMessage(0);
}


void CModelessDlg::OnCancel()
{
	DestroyWindow();

	// Explicitly kill this thread.
	AfxPostQuitMessage(0);
}


void CreateModelessDlg(CModelessDlg * pDlg,
					   HWND hWndParent,
                       UINT  nIDD)
{                         
   ModelessThread *  pMT;

   // If the dialog is still up, don't create a new one
   if (pDlg->GetSafeHwnd())
   {
      ::SetActiveWindow(pDlg->GetSafeHwnd());
      return;
   }

   pMT = new ModelessThread(hWndParent,
                      nIDD,
                      pDlg->GetSignalEvent(),
                      pDlg);
   pMT->CreateThread();
}

void WaitForModelessDlgClose(CModelessDlg *pDlg)
{
   if (pDlg->GetSafeHwnd())
   {
      // Post a cancel to that window
      // Do an explicit post so that it executes on the other thread
      pDlg->PostMessage(WM_COMMAND, IDCANCEL, 0);

      // Now we need to wait for the event to be signalled so that
      // its memory can be cleaned up
      WaitForSingleObject(pDlg->GetSignalEvent(), INFINITE);
   }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\logdatapp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    logdatapp.h
        log data properties header file

    FILE HISTORY:
        oct/11/2001 - vbhanu modified
*/

#if !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358A__INCLUDED_)
#define AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3358A__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

//forward declare friend class
class CLogDataProperties;

/////////////////////////////////////////////////////////////////////////////
// CLogDataGenProp dialog

class CLogDataGenProp : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CLogDataGenProp)

      // Construction
public:
    CLogDataGenProp();
    ~CLogDataGenProp();

    HRESULT
    MoveSelection(
        CLogDataProperties *pLogDataProp,
        CDataObject        *pDataObj,
        int                nIndexTo                              
        );

// Dialog Data
    //{{AFX_DATA(CLogDataGenProp)
    enum { IDD = IDD_PROPPAGE_LOGDATA};
    //CListCtrl	m_listSpecificFilters;
    //}}AFX_DATA

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);
    HRESULT SetLogDataProperties(CLogDataProperties *pLogDataProp);

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CLogDataGenProp)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HGLOBAL m_hgCopy;
    CLogDataProperties *m_pLogDataProp;

protected:
    // Generated message map functions
    //{{AFX_MSG(CLogDataGenProp)
    virtual BOOL OnInitDialog();
    virtual void OnButtonCopy();
    virtual void OnButtonUp();
    virtual void OnButtonDown();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()       
    void 
    ShowSpecificInfo(
        CLogDataInfo *pLogDataInfo
        );

    void 
    SetButtonIcon(
        HWND hwndBtn, 
        ULONG ulIconID);

    void 
    PopulateLogInfo();

    // Context Help Support
    LPDWORD GetHelpMap() 
    { 
        return (LPDWORD) &g_aHelpIDs_IDD_PROPPAGE_LOGDATA[0]; 
    }

    //HRESULT MoveSelection(int nIndexTo);
    HRESULT 
    GetSelectedItemState(
        int *pnSelIndex, 
        PUINT puiState, 
        IResultData *pResultData
        );
};

/*
 *    CLogDataProperties Class
 */
 
class CLogDataProperties: public CPropertyPageHolderBase
{
  friend class CLogDataGenProp;

 public:
  CLogDataProperties(ITFSNode               *pNode, 
                     IComponentData         *pComponentData,
                     ITFSComponentData      *pTFSComponentData, 
                     CLogDataInfo           *pLogDataInfo, 
                     ISpdInfo               *pSpdInfo,
                     LPCTSTR                pszSheetName,
                     LPDATAOBJECT           pDataObject,
                     ITFSNodeMgr            *pNodeMgr,
                     ITFSComponent          *pComponent);

  virtual ~CLogDataProperties();

  ITFSComponentData*
  GetTFSCompData()
  {
      if (m_spTFSCompData)
	m_spTFSCompData->AddRef();

      return m_spTFSCompData;
  }

  HRESULT 
  GetLogDataInfo(
      CLogDataInfo **ppLogDataInfo
      )
  {
      Assert(ppLogDataInfo);
      *ppLogDataInfo = &m_LogDataInfo;
      return hrOK;
  }

  HRESULT 
  GetSpdInfo(
      ISpdInfo **ppSpdInfo
      )
  {
      Assert(ppSpdInfo);
      *ppSpdInfo = NULL;
      SetI((LPUNKNOWN *)ppSpdInfo, m_spSpdInfo);

      return hrOK;
  }

 public:
  CLogDataGenProp     m_pageGeneral;
  LPDATAOBJECT        m_pDataObject;

 protected:
  SPITFSComponentData m_spTFSCompData;
  CLogDataInfo        m_LogDataInfo;
  SPISpdInfo          m_spSpdInfo;
  ITFSNodeMgr         *m_pNodeMgr;
  ITFSComponent       *m_pComponent;
};

#endif // !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ipsmsnap.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_LOGDATA_WARN_BOF            2
#define IDS_SIZE                        3
#define IDS_TYPE                        4
#define IDS_ROOT_NODENAME               5
#define IDS_ROOT_NAME                   6
#define IDS_SERVER_NAME                 7
#define IDC_STATS_REFRESH               8
#define IDS_LOGDATA_WARN_EOF            8
#define IDS_COL_FLTR_NAME               9
#define IDS_FILTER_NODE                 10
#define IDS_COL_FLTR_SRC_TNL            11
#define IDS_COL_FLTR_DEST_TNL           12
#define IDS_QM_SA_NODE                  13
#define IDS_IPSECMON                    14
#define IDS_COL_FLTR_SRC                15
#define IDS_COL_FLTR_DEST               16
#define IDS_QUICK_MODE_NODENAME         17
#define IDS_SPECIFIC_FILTER_NODE        18
#define IDS_COL_FLTR_SRC_PORT           19
#define IDS_COL_FLTR_DEST_PORT          20
#define IDS_COL_FLTR_PROT               21
#define IDS_COL_FLTR_DIR                22
#define IDS_MAIN_MODE_NODENAME          23
#define IDS_COL_MM_POL_NAME             24
#define IDS_COL_MM_POL_OFFER            25
#define IDS_MM_POL_NODE                 26
#define IDS_COL_QM_POL_NAME             27
#define IDS_COL_QM_POL_OFFER            28
#define IDS_QM_POL_NODE                 29
#define IDS_SNAPIN_NAME                 30
#define IDS_SNAPIN_EXTENSION            31
#define IDS_MM_FILTER_NODE              32
#define IDS_MM_SP_FILTER_NODE           33
#define IDS_COL_FLTR_WEIGHT             34
#define IDS_MM_OFFER_PROP               35
#define IDS_COL_FLTR_FLAG               36
#define IDS_COL_MM_AUTH_METHOD          38
#define IDS_MM_AUTH_NODE                39
#define IDS_COL_MM_AUTH_GUID            40
#define IDS_STATS_TITLE                 41
#define IDS_STATS_NAME                  42
#define IDS_STATS_DATA                  43
#define IDS_COL_QM_POLICY               44
#define IDS_COL_MM_FLTR_POL             45
#define IDS_COL_MM_FLTR_AUTH            46
#define IDS_MM_SA_NODE                  47
#define IDS_COL_MM_SA_ME                48
#define IDS_COL_MM_SA_PEER              49
#define IDS_COL_MM_SA_AUTH              50
#define IDS_COL_MM_SA_ENCRYPITON        51
#define IDS_COL_MM_SA_INTEGRITY         52
#define IDS_COL_MM_SA_DH                53
#define IDS_COL_IF_TYPE                 54
#define IDS_COL_FLTR_OUT_FLAG           55
#define IDS_COL_FLTR_IN_FLAG            56
#define IDS_LOG_NODENAME                57
#define IDS_LOG_NODE                    58
#define IDS_COL_LOGDATA_MSG             59
#define IDS_COL_LOGDATA_TIME            60
#define IDS_COL_LOGDATA_CAT             61
#define IDS_COL_LOGDATA_COMP_ID         63
#define IDS_COL_FLTR_ACTN               64
#define IDS_COL_FLTR_NUM_FLDS           65
#define IDS_COL_FLTR_FLD1               66
#define IDS_COL_FLTR_FLD2               67
#define IDS_COL_FLTR_FLD3               68
#define IDS_COL_FLTR_FLD4               69
#define IDS_COL_FLTR_FLD5               70
#define IDS_COL_FLTR_FLD6               71
#define IDS_COL_FLTR_FLD7               72
#define IDS_COL_FLTR_FLD8               73
#define IDS_COL_FLTR_FLD9               74
#define IDS_COL_IF                      75
#define IDS_WIRELESS_NODE               76
#define IDS_COL_APDATA_SSID             77
#define IDS_COL_APDATA_INF_MODE         78
#define IDS_COL_APDATA_MAC              79
#define IDS_COL_APDATA_GUID             80
#define IDS_COL_APDATA_PRIVACY          81
#define IDS_COL_LOGDATA_LOCAL_MAC_ADDR  82
#define IDS_COL_LOGDATA_REMOTE_MAC_ADDR 83
#define IDS_COL_LOGDATA_SSID            84
#define IDS_COL_APDATA_RSSI             85
#define IDS_COL_APDATA_CHANNEL          86
#define IDS_COL_APDATA_RATE             87
#define IDS_ABOUT_DESCRIPTION           100
#define IDS_ABOUT_PROVIDER              101
#define IDS_ABOUT_VERSION               102
#define IDD_PROPPAGE_LOGDATA            107
#define IDP_SERVER_REFRESH              140
#define IDB_16x16                       202
#define IDB_32x32                       203
#define IDB_ROOT_SMALL                  216
#define IDB_ROOT_LARGE                  217
#define IDP_FILTER_GENERAL              235
#define IDP_MM_POLICY_GENERAL           236
#define IDP_QM_POLICY_GENERAL           237
#define IDP_MM_FILTER_GENERAL           238
#define IDP_MM_AUTH                     239
#define IDD_SRCH_FLTRS                  240
#define IDD_MM_SRCH_FLTRS               241
#define IDD_ADD_COMPUTER                242
#define IDD_IPSM_STATS                  243
#define IDP_MM_SA_GENERAL               244
#define IDP_QM_SA_GENERAL               245
#define IDI_LOG_WARNING                 248
#define IDI_LOG_ERROR                   249
#define IDI_LOG_INFO                    250
#define IDI_LOG_UNKNOWN                 251
#define IDI_LOG_DOWN_ARROW              252
#define IDI_LOG_UP_ARROW                254
#define IDI_LOG_COPY                    268
#define IDI_AP_ADHOC                    270
#define IDI_AP_INFRA                    271
#define IDI_WLANMON_SNAPIN              272
#define IDI_AP_ASSOC_ADHOC              273
#define IDI_AP_ASSOC_INFRA              274
#define IDI_ICON06                      283
#define IDI_ICON07                      284
#define IDI_ICON05                      296
#define IDI_ICON01                      305
#define IDI_ICON02                      306
#define IDI_ICON03                      307
#define IDI_ICON04                      308
#define IDI_IPSM_FILTER                 309
#define IDI_IPSM_POLICY                 310
#define IDC_BUTTON_ADD_ADMIN            354
#define IDC_BUTTON_REMOVE_ADMIN         355
#define IDC_LIST_USERS                  356
#define IDC_EDIT_NAME                   357
#define IDC_EDIT_PASSWORD               358
#define IDC_CHECK_ENABLE_STATS          360
#define IDC_EDIT_MINUTES                361
#define IDC_EDIT_SECONDS                362
#define IDC_SPIN_MINUTES                364
#define IDC_STATIC_MINUTES              365
#define IDC_SPIN_SECONDS                366
#define IDC_CHECK_ENABLE_SERVER         367
#define IDC_LIST_ADMINS                 368
#define IDC_BUTTON_CHOOSE_USER          371
#define IDC_STATIC_ADMINS               372
#define IDC_STATIC_ACCOUNT              373
#define IDC_STATIC_USERNAME             374
#define IDC_STATIC_PASSWORD             375
#define IDC_STATIC_NOTE                 376
#define IDC_STATIC_LISTBOX              377
#define IDI_TELEPHONY                   378
#define IDC_LIST_DRIVERS                380
#define IDC_BUTTON_EDIT_DRIVER          381
#define IDC_LIST_NEW_DRIVERS            382
#define IDC_BUTTON_ADD_DRIVER           384
#define IDC_BUTTON_REMOVE_DRIVER        386
#define IDC_BUTTON_ADD_USER             387
#define IDC_BUTTON_REMOVE_USER          388
#define IDC_BUTTON_ADD_NEW_DRIVER       389
#define IDC_STATIC_ACCOUNT_INFO         390
#define IDC_EDIT_INFO                   393
#define IDC_LIST_SPECIFIC               394
#define IDC_FLTR_SRC_ADDR_EDIT          395
#define IDC_FLTR_SRC_ADDR               396
#define IDC_STATIC_SRC_MASK             397
#define IDC_STATIC_DEST_MASK            398
#define IDC_MM_POL_GEN_LIST             399
#define IDC_MM_POL_GEN_PROP             400
#define IDC_FLTR_SRC_MASK               401
#define IDC_LIST_MM_POL_AUTH            401
#define IDC_FLTR_IN_FLAG                402
#define IDC_CHECK_ENABLE_DNS            403
#define IDC_FLTR_SRC_PORT               404
#define IDC_SRCH_SRC_ANY                405
#define IDC_SRCH_SRC_SPEC               406
#define IDC_FLTR_PROTOCOL               407
#define IDC_SRCH_SRC_EDIT               408
#define IDC_FLTR_IF_TYPE                409
#define IDC_SRCH_DEST_ANY               410
#define IDC_FLTR_MIRROR                 411
#define IDC_SRCH_DEST_SPEC              412
#define IDC_FLTR_POLICY                 413
#define IDC_SRCH_DEST_EDIT              414
#define IDC_FLTR_OUT_FLAG               415
#define IDC_SRCH_PROTO                  416
#define IDC_FLTR_DEST_ADDR              417
#define IDC_SRCH_SRC_PORT               418
#define IDC_FLTR_DEST_MASK              419
#define IDC_SRCH_DEST_PORT              420
#define IDC_FLTR_DEST_PORT              421
#define IDC_SRCH_LIST                   422
#define IDC_QM_POL_GEN_LIST             423
#define IDC_SRCH_PROTO2                 424
#define IDC_MM_STATIC_SRC_MASK          425
#define IDC_MM_FLTR_SRC_ADDR            426
#define IDC_SRCH_INBOUND                427
#define IDC_MM_FLTR_SRC_MASK            428
#define IDC_SRCH_OUTBOUND               429
#define IDC_MM_FLTR_IF_TYPE             430
#define IDC_SEARCH                      431
#define IDC_MM_FLTR_MIRROR              432
#define IDC_SRCH_SRC_IP                 433
#define IDC_MM_FLTR_POLICY              434
#define IDC_SRCH_DEST_IP                435
#define IDC_MM_STATIC_DEST_MASK         436
#define IDC_SRCH_RADIO_BEST             437
#define IDC_MM_FLTR_DEST_ADDR           438
#define IDC_SRCH_RADIO_ALL              439
#define IDC_MM_FLTR_DEST_MASK           440
#define IDC_MM_SRCH_RADIO_BEST          441
#define IDC_MM_LIST_SPECIFIC            442
#define IDC_MM_SRCH_RADIO_ALL           443
#define IDC_MM_SRCH_SRC_ANY             445
#define IDC_MM_SRCH_SRC_SPEC            448
#define IDC_ADD_LOCAL                   449
#define IDC_STATS_QM_LIST               450
#define IDC_MM_SRCH_SRC_IP              451
#define IDC_ADD_OTHER                   452
#define IDC_MM_SRCH_DEST_ANY            453
#define IDC_ADD_EDIT_NAME               454
#define IDC_MM_SRCH_DEST_SPEC           455
#define IDC_BTN_BROWSE                  456
#define IDC_MM_SRCH_DEST_IP             457
#define IDC_MM_SRCH_INBOUND             459
#define IDC_STATS_MM_LIST               460
#define IDC_MM_SRCH_OUTBOUND            461
#define IDC_MM_SEARCH                   462
#define IDC_MM_SRCH_LIST                463
#define IDS_COL_QM_SA_POL               464
#define IDS_COL_QM_SA_AUTH              465
#define IDS_COL_QM_SA_CONF              467
#define IDS_COL_QM_SA_INTEGRITY         468
#define IDS_COL_QM_SA_SRC               469
#define IDS_COL_QM_SA_DEST              470
#define IDS_COL_QM_SA_PROT              471
#define IDS_COL_QM_SA_SRC_PORT          472
#define IDS_COL_QM_SA_DES_PORT          473
#define IDS_COL_QM_SA_MY_TNL            474
#define IDS_COL_QM_SA_PEER_TNL          475
#define IDC_MM_FLTR_DEST_ADDR_EDIT      476
#define IDC_MM_FLTR_SRC_ADDR_EDIT       477
#define IDC_MMSA_IKE_POL                481
#define IDC_MMSA_LIST_QM                482
#define IDC_MMSA_AUTH                   483
#define IDC_MMSA_CONF                   484
#define IDC_MMSA_INTEG                  485
#define IDC_MMSA_KEYLIFE                486
#define IDC_MMSA_DH_GRP                 487
#define IDC_QMSA_PFS_ENABLE             488
#define IDC_FLTR_DEST_ADDR_EDIT         489
#define IDC_MMSA_ME                     490
#define IDC_MMSA_PEER                   492
#define IDC_QMSA_AUTH                   492
#define IDC_QMSA_ESP_CONF               493
#define IDC_QMSA_KEYLIFE                494
#define IDC_QMSA_PFS_GRP                495
#define IDC_QMSA_PROT                   496
#define IDC_QMSA_NEGPOL                 498
#define IDC_QMSA_ME_TNL                 499
#define IDC_QMSA_PEER_TNL               500
#define IDC_QMSA_SRC_PORT               501
#define IDC_QMSA_DEST_PORT              502
#define IDC_QMSA_DEST                   503
#define IDC_QMSA_SRC                    504
#define IDC_QMSA_ESP_INTEG              505
#define IDC_SRCH_PROTO_NUMBER           510
#define IDC_SRCH_PROTO_SPIN             512
#define IDC_STATIC_FLTR_SRC             513
#define IDC_STATIC_FLTR_SRC_PORT        514
#define IDC_STATIC_FLTR_SRC_ADDR        515
#define IDC_STATIC_FLTR_DEST_PORT       516
#define IDC_STATIC_FLTR_DEST_ADDR       517
#define IDC_STATIC_FLTR_IN_FLAG         518
#define IDC_STATIC_FLTR_OUT_FLAG        519
#define IDC_STATIC_FLTR_MIRROR          520
#define IDC_STATIC_FLTR_POLICY          521
#define IDC_STATIC_FLTR_PROTOCOL        522
#define IDC_STATIC_FLTR_IF_TYPE         523
#define IDC_STATIC_FLTR_DEST            524
#define IDC_STATIC_MM_FLTR_SRC_ADDR     525
#define IDC_STATIC_MM_FLTR_DEST_ADDR    526
#define IDC_STATIC_MM_FLTR_IF_TYPE      527
#define IDC_STATIC_MM_FLTR_MIRROR       528
#define IDC_STATIC_MM_FLTR_POLICY       529
#define IDC_STATIC_MM_FLTR_SRC          530
#define IDC_STATIC_MM_FLTR_DEST         531
#define IDC_STATIC_MMSA_ME              532
#define IDC_STATIC_MMSA_PEER            533
#define IDC_STATIC_MMSA_AUTH            534
#define IDC_STATIC_MMSA_IKE_POL         535
#define IDC_STATIC_MMSA_CONF            536
#define IDC_STATIC_MMSA_INTEG           537
#define IDC_STATIC_MMSA_DH_GRP          538
#define IDC_STATIC_MMSA_KEYLIFE         539
#define IDC_STATIC_QMSA_SRC             540
#define IDC_STATIC_QMSA_DEST            541
#define IDC_STATIC_QMSA_SRC_PORT        542
#define IDC_STATIC_QMSA_DEST_PORT       543
#define IDC_STATIC_QMSA_PROT            544
#define IDC_STATIC_QMSA_AUTH            545
#define IDC_STATIC_QMSA_ESP_INTEG       546
#define IDC_STATIC_QMSA_KEYLIFE         547
#define IDC_STATIC_QMSA_PFS_ENABLE      548
#define IDC_STATIC_QMSA_PFS_GRP         549
#define IDC_STATIC_QMSA_NEGPOL          550
#define IDC_STATIC_QMSA_ME_TNL          551
#define IDC_STATIC_QMSA_PEER_TNL        552
#define IDC_STATIC_QMSA_ESP_CONF        553
#define IDC_STATIC_INTERVAL             554
#define IDC_STATIC_SECONDS              555
#define IDC_STATIC_MMSA_OFFER           556
#define IDC_STATIC_QMSA_OFFER           557
#define IDC_SRCH_SRC_ANYPORT            558
#define IDC_SRCH_SRC_SPPORT             559
#define IDC_SRCH_DEST_ANYPORT           560
#define IDC_SRCH_DEST_SPPORT            561
#define IDC_LOGDATA_EDIT1               563
#define IDC_BTN_COPY                    567
#define IDC_BTN_MOVE_UP                 568
#define IDC_LOGDATA_EDIT2               569
#define IDC_LOGDATA_EDIT3               570
#define IDC_LOGDATA_EDIT4               571
#define IDC_LOGDATA_EDIT5               572
#define IDC_LOGDATA_EDIT6               573
#define IDC_LOGDATA_EDIT7               574
#define IDC_LOGDATA_EDIT8               575
#define IDC_BTN_MOVE_DOWN               576
#define IDC_LOGDATAPP_SOURCE            577
#define IDC_LOGDATAPP_TIME              578
#define IDC_LOGDATAPP_LMAC              579
#define IDC_LOGDATAPP_DESC              580
#define IDC_LOGDATAPP_DETAILS           581
#define IDC_LOGDATAPP_TYPE              582
#define IDC_LOGDATAPP_SSID              583
#define IDC_LOGDATAPP_RMAC              584
#define IDS_ADD_MACHINE                 1000
#define IDS_MENU_RECONNECT              1001
#define IDS_MENU_STATISTICS             1004
#define IDS_VIEW_TASKPAD                1005
#define IDS_MENU_ENABLE_LOGGING         1006
#define IDS_MENU_DISABLE_LOGGING        1007
#define IDS_MENU_FLUSH_LOGS             1008
#define IDS_FILTER_PP_COL_DIRECTION     1009
#define IDS_FILTER_PP_COL_SRC           1010
#define IDS_FILTER_PP_COL_DEST          1011
#define IDS_FILTER_PP_COL_FLAG          1012
#define IDS_FILTER_PP_COL_WEIGHT        1013
#define IDS_MM_POL_GEN_ENCRYPTION       1014
#define IDS_MM_POL_GEN_AUTH             1015
#define IDS_MM_POL_GEN_DH               1016
#define IDS_MM_POL_GEN_QMLMT            1017
#define IDS_MM_POL_GEN_IKEAUTH          1018
#define IDS_DOI_AH_NONE                 1019
#define IDS_DOI_AH_MD5                  1020
#define IDS_DOI_AH_SHA                  1021
#define IDS_DOI_ESP_NONE                1022
#define IDS_DOI_ESP_DES                 1023
#define IDS_DOI_ESP_3_DES               1024
#define IDS_IKE_PRESHARED_KEY           1025
#define IDS_IKE_DSS_SIGNATURE           1026
#define IDS_IKE_RSA_SIGNATURE           1027
#define IDS_IKE_RSA_ENCRYPTION          1028
#define IDS_IKE_SSPI                    1029
#define IDS_HMAC_AH_MD5                 1030
#define IDS_HMAC_AH_SHA                 1031
#define IDS_QM_POL_GEN_AUTH             1032
#define IDS_QM_POL_GEN_ESP_CONF         1033
#define IDS_QM_POL_GEN_ESP_INTEG        1034
#define IDS_QM_POL_GEN_KEY_LIFE         1035
#define IDS_QM_POL_GEN_PFS              1036
#define IDS_QM_POL_GEN_PFS_GP           1037
#define IDS_DHGROUP_LOW                 1038
#define IDS_DHGROUP_MEDIUM              1039
#define IDS_DHGROUP_HIGH                1040
#define IDS_MM_POL_GEN_KEY_LIFE         1041
#define IDS_FLTR_SEARCH                 1042
#define IDS_MM_AUTH_METHOD              1043
#define IDS_MM_AUTH_DETAIL              1044
#define IDS_ADDR_ME                     1045
#define IDS_ADDR_ANY                    1046
#define IDS_MM_FLTR_SEARCH              1047
#define IDS_FILTER_PP_COL_POLICY        1048
#define IDS_FLTER_PP_COL_IKE_POL        1049
#define IDS_PASS_THROUGH                1500
#define IDS_BLOCKING                    1501
#define IDS_NEG_SEC                     1502
#define IDS_PROTOCOL_ANY                1503
#define IDS_PROTOCOL_ICMP               1504
#define IDS_PROTOCOL_GGP                1505
#define IDS_PROTOCOL_TCP                1506
#define IDS_PROTOCOL_EGP                1507
#define IDS_PROTOCOL_PUP                1508
#define IDS_PROTOCOL_UDP                1509
#define IDS_PROTOCOL_HMP                1510
#define IDS_PROTOCOL_XNS_IDP            1511
#define IDS_PROTOCOL_RDP                1512
#define IDS_PROTOCOL_RVD                1513
#define IDS_IF_TYPE_ALL                 1514
#define IDS_IF_TYPE_LAN                 1515
#define IDS_IF_TYPE_RAS                 1516
#define IDS_UNKNOWN                     1517
#define IDS_YES                         1518
#define IDS_NO                          1519
#define IDS_FLTR_DIR_IN                 1520
#define IDS_FLTR_DIR_OUT                1521
#define IDS_KEY_LIFE_TIME               1522
#define IDS_ALGO_NONE                   1523
#define IDS_AUTH_PROP                   1524
#define IDS_FLTER_PP_COL_MM_AUTH        1525
#define IDS_STATS_QM_ACTIVE_SA          1526
#define IDS_STATS_QM_PENDING_KEY_OPS    1527
#define IDS_STATS_QM_KEY_ADDITION       1528
#define IDS_STATS_QM_KEY_DEL            1529
#define IDS_STATS_QM_REKEYS             1530
#define IDS_STATS_QM_ACTIVE_TNL         1531
#define IDS_STATS_QM_BAD_SPI            1532
#define IDS_STATS_QM_PKT_NOT_DECRYPT    1533
#define IDS_STATS_QM_PKT_NOT_AUTH       1534
#define IDS_STATS_QM_PKT_REPLAY         1535
#define IDS_STATS_QM_OFFLOAD_SA         1536
#define IDS_STATS_QM_ESP_BYTE_SENT      1537
#define IDS_STATS_QM_ESP_BYTE_RCV       1538
#define IDS_STATS_QM_AUTH_BYTE_SENT     1539
#define IDS_STATS_QM_ATTH_BYTE_RCV      1540
#define IDS_STATS_QM_TNL_BYTE_SENT      1541
#define IDS_STATS_QM_TNL_BYTE_RCV       1542
#define IDS_STATS_QM_OFFLOAD_BYTE_SENT  1543
#define IDS_STATS_QM_OFFLOAD_BYTE_RCV   1544
#define IDS_NOT_AVAILABLE               1545
#define IDS_PORT_ANY                    1546
#define IDS_STATS_MM_ACTIVE_ACQUIRE     1547
#define IDS_STATS_MM_ACTIVE_RCV         1548
#define IDS_STATS_QM_XPORT_BYTE_SENT    1549
#define IDS_STATS_MM_ACQUIRE_FAIL       1550
#define IDS_STATS_MM_RCV_FAIL           1551
#define IDS_STATS_MM_SEND_FAIL          1552
#define IDS_STATS_MM_ACQUIRE_HEAP_SIZE  1553
#define IDS_STATS_MM_RCV_HEAP_SIZE      1554
#define IDS_STATS_MM_NEG_FAIL           1556
#define IDS_STATS_MM_INVALID_COOKIE     1557
#define IDS_STATS_MM_TOTAL_ACQUIRE      1558
#define IDS_STATS_MM_TOTAL_GETSPI       1559
#define IDS_STATS_MM_TOTAL_KEY_ADD      1560
#define IDS_STATS_MM_TOTAL_KEY_UPDATE   1561
#define IDS_STATS_MM_GET_SPI_FAIL       1562
#define IDS_STATS_MM_KEY_ADD_FAIL       1563
#define IDS_STATS_MM_KEY_UPDATE_FAIL    1564
#define IDS_STATS_MM_ISADB_LIST_SIZE    1565
#define IDS_STATS_MM_CONN_LIST_SIZE     1566
#define IDS_STATS_MM_OAKLEY_MM          1567
#define IDS_STATS_MM_OAKLEY_QM          1568
#define IDS_STATS_QM_XPORT_BYTE_RCV     1569
#define IDS_OTHER_PROTO                 1570
#define IDS_STATS_MM_DEAD_ASSOCIATIONS  1571
#define IDS_STATS_MM_INACTIVE_ASSOCIATIONS 1572
#define IDS_STATS_MM_SOFT_ASSOCIATIONS  1573
#define IDS_STATS_QM_KEY_DELETION       1574
#define IDS_VIEW_ALL_FLTR               1575
#define IDS_VIEW_TRANSPORT_FLTR         1576
#define IDS_VIEW_TUNNEL_FLTR            1577
#define IDS_OTHER                       1578
#define IDS_STATS_MM_INVALID_PACKETS    1579
#define IDS_PROTOCOL_IGMP               1580
#define IDS_WARN_SERVER_DELETE          2000
#define IDS_ROOT_TASK_TITLE             3000
#define IDS_ROOT_TASK_GETTING_STARTED   3002
#define IDS_ROOT_TASK_GETTING_STARTED_HELP 3003
#define IDS_ROOT_TASK_ADD_SERVER        3006
#define IDS_ROOT_TASK_ADD_SERVER_HELP   3007
#define IDS_ERR_MESSAGE_GENERIC         5001
#define IDS_ERR_INVALID_INTEGER         5002
#define IDS_ERR_AUTO_REFRESH_ZERO       5003
#define IDS_ERR_SERVER_IN_LIST          5004
#define IDS_ERR_OLD_CONSOLE_FILE        5005
#define IDS_NO_STATUS                   5006
#define IDS_ERR_SERVER_NODE             5007
#define IDS_ERR_INVALID_PROTOCOLID      5008
#define IDS_ERR_INVALID_SRC_PORT        5009
#define IDS_ERR_INVALID_DEST_PORT       5010
#define IDS_LOCAL_SYSTEM_ACCOUNT        5011
#define IDS_ERR_USER_NOT_ADMIN          5012
#define IDS_ADMIN_ALREADY_IN_LIST       5013
#define IDS_USER_ALREADY_AUTHORIZED     5014
#define IDS_ACCOUNT_CHANGE_START        5015
#define IDS_ERR_NO_DIRECTION            5016
#define IDS_LSAERR_READ_FAILED          5017
#define IDS_LSAERR_WRITE_FAILED         5018
#define IDS_LSAERR_WRITE_SUCCEEDED      5019
#define IDS_ERR_EMPTY_NAME              5020
#define IDS_LOGDATA_SOURCE_WZCSVC       5021
#define IDS_LOGDATA_SOURCE_EAPOL        5022
#define IDS_LOGDATA_SOURCE_UNKNOWN      5023
#define IDS_LOGDATA_TYPE_INFORMATION    5024
#define IDS_LOGDATA_TYPE_WARNING        5025
#define IDS_LOGDATA_TYPE_ERROR          5026
#define IDS_LOGDATA_TYPE_UNKNOWN        5027
#define IDS_APDATA_PRIVACY_UNKNOWN      5028
#define IDS_APDATA_PRIVACY_ENABLED      5029
#define IDS_APDATA_PRIVACY_DISABLED     5030
#define IDS_APDATA_INFRA_PEER           5031
#define IDS_APDATA_INFRA_INFRA          5032
#define IDS_APDATA_INFRA_UNKNOWN        5033
#define IDS_LOGDATA_TYPE_PACKET         5034
#define IDS_ERR_BASE                    63000
#define IDS_ERR_SPD_DOWN                63001
#define IDS_ERR_SPD_UNAVAILABLE         63002
#define IDS_MESG_MAX                    65000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        275
#define _APS_NEXT_COMMAND_VALUE         32807
#define _APS_NEXT_CONTROL_VALUE         585
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\root.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    root.cpp
        
    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "root.h"
#include "server.h"
#include "tregkey.h"
#include "service.h"
#include "ncglobal.h"  // network console global defines
#include "addserv.h"

unsigned int g_cfMachineName = RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");

LPOLESTR g_RootTaskOverBitmaps[ROOT_TASK_MAX] = 
{
    L"/wlcmroll.bmp",
    L"/srvrroll.bmp",
};

LPOLESTR g_RootTaskOffBitmaps[ROOT_TASK_MAX] = 
{
    L"/wlcm.bmp",
    L"/srvr.bmp",
};

UINT g_RootTaskText[ROOT_TASK_MAX] = 
{
    IDS_ROOT_TASK_GETTING_STARTED,
    IDS_ROOT_TASK_ADD_SERVER,
};

UINT g_RootTaskHelp[ROOT_TASK_MAX] = 
{
    IDS_ROOT_TASK_GETTING_STARTED_HELP,
    IDS_ROOT_TASK_ADD_SERVER_HELP,
};

HRESULT
CRootTasks::Init(BOOL bExtension, BOOL bThisMachine, BOOL bNetServices)
{
    HRESULT     hr = hrOK;
    MMC_TASK    mmcTask;
    int         nPos = 0;
    int         nFinish = ROOT_TASK_MAX;

    m_arrayMouseOverBitmaps.SetSize(ROOT_TASK_MAX);
    m_arrayMouseOffBitmaps.SetSize(ROOT_TASK_MAX);
    m_arrayTaskText.SetSize(ROOT_TASK_MAX);
    m_arrayTaskHelp.SetSize(ROOT_TASK_MAX);

    // setup path for reuse
    OLECHAR szBuffer[MAX_PATH*2];    // that should be enough
    lstrcpy (szBuffer, L"res://");
    ::GetModuleFileName(_Module.GetModuleInstance(), szBuffer + lstrlen(szBuffer), MAX_PATH);
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

	if (bExtension)
		nPos = ROOT_TASK_MAX;
	/*
    if (bExtension && bThisMachine)
    {
        nPos = ROOT_TASK_MAX - 2;
        nFinish = ROOT_TASK_MAX - 1;
    }
    else
    if (bExtension && bNetServices)
    {
        nPos = ROOT_TASK_MAX - 1;
        nFinish = ROOT_TASK_MAX;
    }
	*/

    for (nPos; nPos < nFinish; nPos++)
    {
        m_arrayMouseOverBitmaps[nPos] = szBuffer;
        m_arrayMouseOffBitmaps[nPos] = szBuffer;
        m_arrayMouseOverBitmaps[nPos] += g_RootTaskOverBitmaps[nPos];
        m_arrayMouseOffBitmaps[nPos] += g_RootTaskOffBitmaps[nPos];

        m_arrayTaskText[nPos].LoadString(g_RootTaskText[nPos]);
        m_arrayTaskHelp[nPos].LoadString(g_RootTaskHelp[nPos]);

        AddTask((LPTSTR) (LPCTSTR) m_arrayMouseOverBitmaps[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayMouseOffBitmaps[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayTaskText[nPos], 
                (LPTSTR) (LPCTSTR) m_arrayTaskHelp[nPos], 
                MMC_ACTION_ID, 
                nPos);
    }
    
    return hr;
}



/*---------------------------------------------------------------------------
    CIpsmRootHandler::CIpsmRootHandler
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CIpsmRootHandler::CIpsmRootHandler(ITFSComponentData *pCompData) : CIpsmHandler(pCompData)
{
    //m_bTaskPadView = FUseTaskpadsByDefault(NULL);
    m_bTaskPadView = FALSE;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmRootHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    CString strTemp;
    strTemp.LoadString(IDS_ROOT_NODENAME);

    SetDisplayName(strTemp);

    // Make the node immediately visible
    //pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, 0);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_PRODUCT);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_PRODUCT);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, IPSMSNAP_ROOT);

    SetColumnStringIDs(&aColumns[IPSMSNAP_ROOT][0]);
    SetColumnWidths(&aColumnWidths[IPSMSNAP_ROOT][0]);

    m_strTaskpadTitle.LoadString(IDS_ROOT_TASK_TITLE);

    return hrOK;
}

/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::GetString
        Implementation of ITFSNodeHandler::GetString
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP_(LPCTSTR) 
CIpsmRootHandler::GetString
(
    ITFSNode *  pNode, 
    int         nCol
)
{
    if (nCol == 0 || nCol == -1)
        return GetDisplayName();
    else
        return NULL;
}


/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    hr = CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param);

    if (dwType & TFS_COMPDATA_EXTENSION)
    {
        // we are extending somebody.  Get the computer name and check that machine
        hr = CheckMachine(pNode, pDataObject);
    }
    else
    {
        int iVisibleCount = 0;
        int iTotalCount = 0;

        pNode->GetChildCount(&iVisibleCount, &iTotalCount);

        if (0 == iTotalCount)
        {
            // check to see if we need to add the local machine to the list
            hr = CheckMachine(pNode, NULL);
        }
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnAddMenuItems
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    CString strMenuItem;

    if (type == CCT_SCOPE)
    {
        // these menu items go in the new menu, 
        // only visible from scope pane
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
#if 0
            /* TODO: Re-enable when iterface needs to be remoteable */
            strMenuItem.LoadString(IDS_ADD_MACHINE);
            hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                     strMenuItem, 
                                     IDS_ADD_MACHINE,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP, 
                                     0 );
#endif //0
            ASSERT( SUCCEEDED(hr) );
        }
    }

    return hr; 
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnCommand
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    switch (nCommandId)
    {
        case IDS_ADD_MACHINE:
            OnAddMachine(pNode);
            break;

        default:
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::AddMenuItems
        Over-ride this to add our view menu item
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;
    CString strMenuItem;
/*
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        strMenuItem.LoadString(IDS_VIEW_TASKPAD);
        hr = LoadAndAddMenuItem( pContextMenuCallback, 
                                 strMenuItem, 
                                 IDS_VIEW_TASKPAD,
                                 CCM_INSERTIONPOINTID_PRIMARY_VIEW, 
                                 (m_bTaskPadView) ? MF_CHECKED : 0 );
    }
*/
    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::Command
        Handles commands for the current view
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = S_OK;

    switch (nCommandID)
    {
        case MMCC_STANDARD_VIEW_SELECT:
            m_bTaskPadView = FALSE;
            break;

        case IDS_VIEW_TASKPAD:
            {
                // if we are not viewing the taskpad presently, re-select the node
                // so that the taskpad is visible
                SPIConsole   spConsole;
                SPITFSNode   spNode;

                m_bTaskPadView = !m_bTaskPadView;

                m_spResultNodeMgr->FindNode(cookie, &spNode);
                m_spTFSCompData->GetConsole(&spConsole);
                spConsole->SelectScopeItem(spNode->GetData(TFS_DATA_SCOPEID));
            }
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    HRESULT hr = hrOK;
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        // This is the case where we are asked to bring up property
        // pages when the user is adding a new snapin.  These calls
        // are forwarded to the root node to handle.
        hr = hrFalse;
    }
    else
    {
        // we have property pages in the normal case
        hr = hrFalse;
    }
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpProvider,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = hrOK;
    HPROPSHEETPAGE hPage;

    Assert(pNode->GetData(TFS_DATA_COOKIE) == 0);
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        //
        // We are loading this snapin for the first time, put up a property
        // page to allow them to name this thing.
        // 
    }
    else
    {
        //
        // Object gets deleted when the page is destroyed
        //
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::TaskPadNotify
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::TaskPadNotify
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    VARIANT *       arg,
    VARIANT *       param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (arg->vt == VT_I4)
    {
        switch (arg->lVal)
        {
            case ROOT_TASK_GETTING_STARTED:
                {
                    SPIDisplayHelp spDisplayHelp;
                    SPIConsole spConsole;

                    pComponent->GetConsole(&spConsole);

                    HRESULT hr = spConsole->QueryInterface (IID_IDisplayHelp, (LPVOID*) &spDisplayHelp);
                    ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        LPCTSTR pszHelpFile = m_spTFSCompData->GetHTMLHelpFileName();
                        if (pszHelpFile == NULL)
                            break;

                        CString szHelpFilePath;
                        UINT nLen = ::GetWindowsDirectory (szHelpFilePath.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
                        if (nLen == 0)
                            return E_FAIL;

                        szHelpFilePath.ReleaseBuffer();
                        szHelpFilePath += g_szDefaultHelpTopic;

                        hr = spDisplayHelp->ShowTopic (T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
                        ASSERT (SUCCEEDED (hr));
                    }
                }
                break;
            
            case ROOT_TASK_ADD_SERVER:
                {
                    SPITFSNode spNode;

                    m_spResultNodeMgr->FindNode(cookie, &spNode);
                    OnAddMachine(spNode);
                }
                break;

            default:
                Panic1("CIpsmRootHandler::TaskPadNotify - Unrecognized command! %d", arg->lVal);
                break;
        }
    }

    return hrOK;
}

/*!--------------------------------------------------------------------------
    CBaseResultHandler::EnumTasks
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::EnumTasks
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPDATAOBJECT    pDataObject,
    LPOLESTR        pszTaskGroup,
    IEnumTASK **    ppEnumTask
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    CRootTasks *    pTasks = NULL;
    SPIEnumTask     spEnumTasks;
    SPINTERNAL      spInternal = ExtractInternalFormat(pDataObject);
    BOOL            bExtension = FALSE;
    BOOL            bAddThisMachineTasks = FALSE;
    BOOL            bAddNetServicesTasks = FALSE;
    const CLSID *   pNodeClsid = &CLSID_IpsmSnapin;
    CString         strMachineGroup = NETCONS_ROOT_THIS_MACHINE;
    CString         strNetServicesGroup = NETCONS_ROOT_NET_SERVICES;
        
    if ((spInternal == NULL) || (*pNodeClsid != spInternal->m_clsid))
        bExtension = TRUE;

    if (bExtension && 
        strMachineGroup.CompareNoCase(pszTaskGroup) == 0)
    {
        // There are multiple taskpad groups in the network console
        // we need to make sure we are extending the correct one.
        bAddThisMachineTasks = TRUE;
    }

    if (bExtension && 
        strNetServicesGroup.CompareNoCase(pszTaskGroup) == 0)
    {
        // There are multiple taskpad groups in the network console
        // we need to make sure we are extending the correct one.
        bAddNetServicesTasks = TRUE;
    }

    COM_PROTECT_TRY
    {
        pTasks = new CRootTasks();
        spEnumTasks = pTasks;

        if (!(bExtension && !bAddThisMachineTasks && !bAddNetServicesTasks))
            CORg (pTasks->Init(bExtension, bAddThisMachineTasks, bAddNetServicesTasks));

        CORg (pTasks->QueryInterface (IID_IEnumTASK, (void **)ppEnumTask));
    
        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::TaskPadGetTitle
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmRootHandler::TaskPadGetTitle
(
    ITFSComponent * pComponent,
    MMC_COOKIE      cookie,
    LPOLESTR        pszGroup,
    LPOLESTR *      ppszTitle
)
{
    HRESULT hr = S_OK;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (ppszTitle == NULL)
    {        
        hr = E_OUTOFMEMORY;
        goto error;
    }
    
    *ppszTitle = (LPOLESTR) CoTaskMemAlloc (sizeof(OLECHAR)*
                                            (lstrlen(m_strTaskpadTitle)+1));
    if (*ppszTitle == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    
    lstrcpy (*ppszTitle, m_strTaskpadTitle);

 error:
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    // if we aren't displaying the taskpad, use the default stuff...
    if (!m_bTaskPadView)
        return CIpsmHandler::OnGetResultViewType(pComponent, cookie, ppViewType, pViewOptions);

	//TODO Should we keep that?
    //
    // In this code we are defaulting to a taskpad view for this node all the time.
    // It is the snapins responsibility to put up a view menu selection that has a
    // selection for the taskpad. Do that in AddMenuItems.
    //
    //
    // We will use the default DHTML provided by MMC. It actually resides as a
    // resource inside MMC.EXE. We just get the path to it and use that.
    // The one piece of magic here is the text following the '#'. That is the special
    // way we have of identifying they taskpad we are talking about. Here we say we are
    // wanting to show a taskpad that we refer to as "CMTP1". We will actually see this
    // string pass back to us later. If someone is extending our taskpad, they also need
    // to know what this secret string is.
    //
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    OLECHAR szBuffer[MAX_PATH*2]; // a little extra

    lstrcpy (szBuffer, L"res://");
    OLECHAR * temp = szBuffer + lstrlen(szBuffer);

	//TODO need to hook up the ipsecmon help file
    // get "res://"-type string for custom taskpad
    // the string after the # gets handed back to us in future calls...
    // should be unique for each node
    ::GetModuleFileName (NULL, temp, MAX_PATH);
    lstrcat (szBuffer, L"/default.htm#TAPIROOT");

    // alloc and copy bitmap resource string
    *ppViewType = (LPOLESTR)CoTaskMemAlloc (sizeof(OLECHAR)*(lstrlen(szBuffer)+1));

    if (!*ppViewType)
        return E_OUTOFMEMORY;   // or S_FALSE ???

    lstrcpy (*ppViewType, szBuffer);

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CIpsmRootHandler::OnResultSelect
        For nodes with task pads, we override the select message to set 
        the selected node.  Nodes with taskpads do not get the MMCN_SHOW
        message which is where we normall set the selected node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CIpsmRootHandler::OnResultSelect(ITFSComponent *pComponent, LPDATAOBJECT pDataObject, MMC_COOKIE cookie, LPARAM arg, LPARAM lParam)
{
    HRESULT hr = hrOK;

    CORg(DoTaskpadResultSelect(pComponent, pDataObject, cookie, arg, lParam, m_bTaskPadView));

    CORg(CIpsmHandler::OnResultSelect(pComponent, pDataObject, cookie, arg, lParam));

Error:
    return hr;
}


/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsmRootHandler::OnAddMachine
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmRootHandler::OnAddMachine
(
    ITFSNode *  pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    HRESULT hr = hrOK;
    
    /*
    GETCOMPUTERSELECTIONINFO    info;
    PDSSELECTIONLIST    pSelList = NULL;

    LPCTSTR attrs[] = {_T("dNSHostName")};

    ZeroMemory(&info, sizeof(GETCOMPUTERSELECTIONINFO));
    info.cbSize = sizeof(GETCOMPUTERSELECTIONINFO);
    info.hwndParent = FindMMCMainWindow();
    info.flObjectPicker = 0; // not allow multiple selection
    info.flDsObjectPicker = DSOP_SCOPE_DIRECTORY | 
                            DSOP_SCOPE_DOMAIN_TREE | 
                            DSOP_SCOPE_EXTERNAL_TRUSTED_DOMAINS;
    info.flStartingScope = DSOP_SCOPE_DIRECTORY;
    info.ppDsSelList = &pSelList;
    info.cRequestedAttributes = 1;
    info.aptzRequestedAttributes = attrs;

    hr = GetComputerSelection(&info);
    if(hr != S_OK)  // assume the API will display error message, if there is
        return hr;

    CString strTemp = pSelList->aDsSelection[0].pwzName;
    if (strTemp.Left(2) == _T("\\\\"))
        strTemp = pSelList->aDsSelection[0].pwzName[2];
    */
	
	CAddServ	dlgAddServ(CWnd::FromHandle(FindMMCMainWindow()));
	if (IDOK != dlgAddServ.DoModal())
	{
		return hr;
	}
	
	CString strTemp = dlgAddServ.m_stComputerName;

    // if the machine is already in the list, don't bother.
    if (IsServerInList(pNode, strTemp))
    {
        AfxMessageBox(IDS_ERR_SERVER_IN_LIST);
    }
    else
    {
        AddServer(_T(""), strTemp, TRUE, IPSMSNAP_OPTIONS_REFRESH, IPSECMON_REFRESH_INTERVAL_DEFAULT);
    }

    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::AddServer
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmRootHandler::AddServer
(
    LPCWSTR          pServerIp,
    LPCTSTR          pServerName,
    BOOL             bNewServer,
    DWORD            dwServerOptions,
    DWORD            dwRefreshInterval,
    BOOL             bExtension,
    DWORD            dwLineBuffSize,
    DWORD            dwPhoneBuffSize
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    CIpsmServer *       pServer = NULL;
    SPITFSNodeHandler   spHandler;
    SPITFSNode          spNode, spRootNode;

    // Create a handler for the node
    try
    {
        pServer = new CIpsmServer(m_spTFSCompData);
        //pServer->SetName(pServerName);
        
        // Do this so that it will get released correctly
        spHandler = pServer;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }
    CORg( hr );
    
    //
    // Create the server container information
    // 
    CreateContainerTFSNode(&spNode,
                           &GUID_IpsmServerNodeType,
                           pServer,
                           pServer,
                           m_spNodeMgr);

    // Tell the handler to initialize any specific data
    pServer->SetName(pServerName);

    pServer->InitializeNode((ITFSNode *) spNode);

    if (dwServerOptions & IPSMSNAP_OPTIONS_EXTENSION)
    {
        pServer->SetExtensionName();
    }

    // Mask out the auto refresh option because we set it next
    pServer->SetOptions(dwServerOptions & ~IPSMSNAP_OPTIONS_REFRESH);

    // if we got a valid refresh interval, then set it.
    pServer->SetAutoRefresh(spNode, dwServerOptions & IPSMSNAP_OPTIONS_REFRESH, dwRefreshInterval);

    pServer->SetDnsResolve(spNode, dwServerOptions & IPSMSNAP_OPTIONS_DNS);

    AddServerSortedName(spNode, bNewServer);

    if (bNewServer)
    {
        // need to get our node descriptor
        CORg(m_spNodeMgr->GetRootNode(&spRootNode));
        spRootNode->SetData(TFS_DATA_DIRTY, TRUE);
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::IsServerInList
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
BOOL
CIpsmRootHandler::IsServerInList
(
    ITFSNode *      pRootNode,
    LPCTSTR         pszMachineName
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;
    DWORD           dwIpAddressCurrent;
    BOOL            bFound = FALSE;
    CString         strNewName = pszMachineName;

    // get the enumerator for this node
    pRootNode->GetEnum(&spNodeEnum);

    spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        CIpsmServer * pServer = GETHANDLER(CIpsmServer, spCurrentNode);
        if (strNewName.CompareNoCase(pServer->GetName()) == 0)
        {
            bFound = TRUE;
            break;
        }

        // get the next Server in the list
        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    return bFound;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::AddServerSortedIp
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::AddServerSortedIp
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
    ULONG           nNumReturned = 0;
    DWORD           dwIpAddressCurrent = 0;
    DWORD           dwIpAddressTarget;

    CIpsmServer *   pServer;

    // get our target address
    pServer = GETHANDLER(CIpsmServer, pNewNode);
    //pServer->GetIpAddress(&dwIpAddressTarget);

    // need to get our node descriptor
    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
    CORg(spRootNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CIpsmServer, spCurrentNode);
        //pServer->GetIpAddress(&dwIpAddressCurrent);

        //if (dwIpAddressCurrent > dwIpAddressTarget)
        //{
            // Found where we need to put it, break out
            break;
        //}

        // get the next Server in the list
        spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::AddServerSortedName
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::AddServerSortedName
(
    ITFSNode *      pNewNode,
    BOOL            bNewServer
)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    SPITFSNode      spPrevNode;
    SPITFSNode      spRootNode;
    ULONG           nNumReturned = 0;
    CString         strTarget, strCurrent;

    CIpsmServer *   pServer;

    // get our target address
    pServer = GETHANDLER(CIpsmServer, pNewNode);
    strTarget = pServer->GetName();

    // need to get our node descriptor
    CORg(m_spNodeMgr->GetRootNode(&spRootNode));

    // get the enumerator for this node
    CORg(spRootNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CIpsmServer, spCurrentNode);
        strCurrent = pServer->GetName();

        if (strTarget.Compare(strCurrent) < 0)
        {
            // Found where we need to put it, break out
            break;
        }

        // get the next Server in the list
        spPrevNode.Set(spCurrentNode);

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

    // Add the node in based on the PrevNode pointer
    if (spPrevNode)
    {
        if (bNewServer)
        {
            if (spPrevNode->GetData(TFS_DATA_SCOPEID) != NULL)
            {
                pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_PREVIOUS);
                pNewNode->SetData(TFS_DATA_RELATIVE_SCOPEID, spPrevNode->GetData(TFS_DATA_SCOPEID));
            }
        }
        
        CORg(spRootNode->InsertChild(spPrevNode, pNewNode));
    }
    else
    {   
        // add to the head
        if (m_bExpanded)
        {
            pNewNode->SetData(TFS_DATA_RELATIVE_FLAGS, SDI_FIRST);
        }
        CORg(spRootNode->AddChild(pNewNode));
    }

Error:
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmRootHandler::CheckMachine
        adds the machine to the list of servers.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmRootHandler::CheckMachine
(
    ITFSNode *      pRootNode,
    LPDATAOBJECT    pDataObject
)
{
    HRESULT hr = hrOK;

    // Get the local machine name and check to see if the service
    // is installed.
    CString strMachineName;
    LPTSTR  pBuf;
    DWORD   dwLength = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL    bExtension = (pDataObject != NULL);

    if (!bExtension)
    {
        pBuf = strMachineName.GetBuffer(dwLength);
        GetComputerName(pBuf, &dwLength);
        strMachineName.ReleaseBuffer();
    }
    else
    {
        strMachineName = Extract<TCHAR>(pDataObject, (CLIPFORMAT) g_cfMachineName, COMPUTERNAME_LEN_MAX);
    }

    if (strMachineName.IsEmpty())
    {
        DWORD   dwSize = MAX_COMPUTERNAME_LENGTH + 1;
        LPTSTR  pBuf = strMachineName.GetBuffer(dwSize);
    
        ::GetComputerName(pBuf, &dwSize);
    
        strMachineName.ReleaseBuffer();
    }

    // if the machine is already in the list, don't bother.
    if (IsServerInList(pRootNode, strMachineName))
        return hr;

    if (bExtension)
        RemoveOldEntries(pRootNode, strMachineName);

    // we always add the local machine or whatever machine we are pointed at even if 
    // we are an extension

    // OK.  add it to the list.
    DWORD dwFlags = 0;

    if (bExtension)
        dwFlags |= IPSMSNAP_OPTIONS_EXTENSION;

    dwFlags |= IPSMSNAP_OPTIONS_REFRESH;

    AddServer(_T(""), strMachineName, TRUE, dwFlags, IPSECMON_REFRESH_INTERVAL_DEFAULT, bExtension);
    return hr;
}

// when running as an extension, it is possible that we were saved as "local machine"
// which means that if the saved console file was moved to another machine we need to remove 
// the old entry that was saved
HRESULT 
CIpsmRootHandler::RemoveOldEntries(ITFSNode * pNode, LPCTSTR pszAddr)
{
    HRESULT         hr = hrOK;
    SPITFSNodeEnum  spNodeEnum;
    SPITFSNode      spCurrentNode;
    ULONG           nNumReturned = 0;
    CIpsmServer *   pServer;
    CString         strCurAddr;

    // get the enumerator for this node
    CORg(pNode->GetEnum(&spNodeEnum));

    CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
    while (nNumReturned)
    {
        // walk the list of servers and see if it already exists
        pServer = GETHANDLER(CIpsmServer, spCurrentNode);

        strCurAddr = pServer->GetName();

        if (strCurAddr.CompareNoCase(pszAddr) != 0)
        {
            CORg (pNode->RemoveChild(spCurrentNode));
        }

        spCurrentNode.Release();
        spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
    }

Error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\root.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    root.h
        IPSecMon root node information (the root node is not displayed
        in the MMC framework but contains information such as 
        all of the servers in this snapin).
        
    FILE HISTORY:
        
*/

#ifndef _ROOT_H
#define _ROOT_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _TASK_H
#include <task.h>
#endif

#define COMPUTERNAME_LEN_MAX            255

typedef enum _ROOT_TASKS
{
    ROOT_TASK_GETTING_STARTED,
    ROOT_TASK_ADD_SERVER,
    ROOT_TASK_MAX
} ROOT_TASKS;

class CRootTasks : public CTaskList
{
public:
    HRESULT Init(BOOL bExtension, BOOL bThisMachine, BOOL bNetServices);

private:
    CStringArray    m_arrayMouseOverBitmaps;
    CStringArray    m_arrayMouseOffBitmaps;
    CStringArray    m_arrayTaskText;
    CStringArray    m_arrayTaskHelp; 
};

/*---------------------------------------------------------------------------
    Class:  CIpsmRootHandler
 ---------------------------------------------------------------------------*/
class CIpsmRootHandler : public CIpsmHandler
{
// Interface
public:
    CIpsmRootHandler(ITFSComponentData *pCompData);

    // Node handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString();

    // base handler functionality we override
    OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();

    // Result handler functionality
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();

    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
    OVERRIDE_ResultHandler_OnGetResultViewType();
    OVERRIDE_ResultHandler_TaskPadNotify();
    OVERRIDE_ResultHandler_EnumTasks();
    OVERRIDE_ResultHandler_TaskPadGetTitle();

public:
    // helper routines
    HRESULT AddServer(LPCWSTR pServerIp, 
                      LPCTSTR pServerName, 
                      BOOL bNewServer, 
                      DWORD dwServerOptions = 0x00000000, 
                      DWORD dwRefreshInterval = 0xffffffff, 
                      BOOL bExtension = FALSE,  
                      DWORD dwLineBuffSize = 0,
                      DWORD dwPhoneBuffSize = 0
                      );

    BOOL    IsServerInList(ITFSNode * pRootNode, LPCTSTR pszNewName);
    HRESULT AddServerSortedIp(ITFSNode * pNewNode, BOOL bNewServer);
    HRESULT AddServerSortedName(ITFSNode * pNewNode, BOOL bNewServer);

public:
    // CIpsmHandler overrides
    virtual HRESULT InitializeNode(ITFSNode * pNode);

// Implementation
private:
    // Command handlers
    HRESULT OnAddMachine(ITFSNode * pNode);
    HRESULT OnImportOldList(ITFSNode * pNode);
    BOOL    OldServerListExists();

    // helpers
    HRESULT CheckMachine(ITFSNode * pRootNode, LPDATAOBJECT pDataObject);
    HRESULT RemoveOldEntries(ITFSNode * pRootNode, LPCTSTR pszAddr);

protected:
    CString m_strTaskpadTitle;
    BOOL    m_bTaskPadView;
};

#endif _ROOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\server.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    server.cpp
        IPSecMon machine node handler

    FILE HISTORY:
        
*/


#include "stdafx.h"
#include "spddb.h"
#include "apinfo.h"
#include "server.h"     // Server definition
#include "servpp.h"
#include "logdatanode.h"
#include "wirelessnode.h"
#include "objplus.h"
#include "ipaddres.h"



CTimerMgr g_TimerMgr;
CHashTable g_HashTable;

extern ULONG RevertDwordBytes(DWORD dw);

/////////////////////////////////////////////////////////////////////
// 
// CTimerArray implementation
//
/////////////////////////////////////////////////////////////////////
CTimerMgr::CTimerMgr()
{

}

CTimerMgr::~CTimerMgr()
{
    CTimerDesc * pTimerDesc;

    for (int i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer != 0)
            FreeTimer(i);

        delete pTimerDesc;
    }

}

int
CTimerMgr::AllocateTimer
(
    ITFSNode *      pNode,
    CIpsmServer *   pServer,
    UINT            uTimerValue,
    TIMERPROC       TimerProc
)
{
    int        i           = 0;
    CTimerDesc *pTimerDesc = NULL;
    
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    // look for an empty slot
    for (i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer == 0)
            break;
    }

    // did we find one?  if not allocate one
    if (i < 0)
    {
        try
        {
            pTimerDesc = new CTimerDesc;
            Add(pTimerDesc);
        }
        catch(...)
        {
            //
            // Free up memory allocated for the timer
            //
            if (pTimerDesc != NULL)
            {                
                delete pTimerDesc;
                pTimerDesc = NULL;
            }
            
            return -1;
        }
        i = (int)GetUpperBound();
    }
    
    pTimerDesc->uTimer = SetTimer(NULL, (UINT) i, uTimerValue, TimerProc);
    if (pTimerDesc->uTimer == 0)
        return -1;
    
    pTimerDesc->spNode.Set(pNode);
    pTimerDesc->pServer = pServer;
    pTimerDesc->timerProc = TimerProc;    
 
    return i;
}

void 
CTimerMgr::FreeTimer
(
    UINT_PTR uEventId
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    CTimerDesc * pTimerDesc;

    Assert(uEventId <= (UINT) GetUpperBound());
    if (uEventId > (UINT) GetUpperBound())
        return;

    pTimerDesc = GetAt((int) uEventId);
    ::KillTimer(NULL, pTimerDesc->uTimer);

    pTimerDesc->spNode.Release();
    pTimerDesc->pServer = NULL;
    pTimerDesc->uTimer = 0;
}

CTimerDesc *
CTimerMgr::GetTimerDesc
(
    UINT_PTR uEventId
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // the caller of this function should lock the timer mgr
    // while accessing this pointer
    CTimerDesc * pTimerDesc;

    for (int i = (int)GetUpperBound(); i >= 0; --i)
    {
        pTimerDesc = GetAt(i);
        if (pTimerDesc->uTimer == (UINT) uEventId)
            return pTimerDesc;
    }

    return NULL;
}

void
CTimerMgr::ChangeInterval
(
    UINT_PTR    uEventId,
    UINT        uNewInterval
)
{
    CSingleLock slTimerMgr(&m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    Assert(uEventId <= (UINT) GetUpperBound());
    if (uEventId > (UINT) GetUpperBound())
        return;

    CTimerDesc   tempTimerDesc;
    CTimerDesc * pTimerDesc;

    pTimerDesc = GetAt((int) uEventId);

    // kill the old timer
    ::KillTimer(NULL, pTimerDesc->uTimer);

    // set a new one with the new interval
    pTimerDesc->uTimer = ::SetTimer(
                               NULL,
                               (UINT) uEventId,
                               uNewInterval,
                               pTimerDesc->timerProc);

}

VOID CALLBACK 
StatisticsTimerProc
( 
    HWND        hwnd, 
    UINT        uMsg, 
    UINT_PTR    idEvent, 
    DWORD       dwTime 
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CSingleLock slTimerMgr(&g_TimerMgr.m_csTimerMgr);

    // get a lock on the timer mgr for the scope of this
    // function.
    slTimerMgr.Lock();

    // on the timer, get the timer descriptor for this event
    // Call into the appropriate handler to update the stats.
    CTimerDesc * pTimerDesc;

    pTimerDesc = g_TimerMgr.GetTimerDesc(idEvent);

    if (pTimerDesc != NULL)
    {
        pTimerDesc->pServer->m_bStatsOnly = TRUE;
        pTimerDesc->pServer->OnRefreshStats(
                                 pTimerDesc->spNode,
                                 NULL,
                                 NULL,
                                 0,
                                 0);
        pTimerDesc->pServer->m_bStatsOnly = FALSE;
    }
}

/*---------------------------------------------------------------------------
    Class CIpsmServer implementation
 ---------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CIpsmServer::CIpsmServer
(
    ITFSComponentData * pComponentData
) : CMTIpsmHandler(pComponentData),
    m_bStatsOnly(FALSE),
    m_StatsTimerId(-1),
    m_dwOptions(0)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
}

CIpsmServer::~CIpsmServer()
{
	/*
    if (m_StatsDlg.GetSafeHwnd())
    {
        WaitForModelessDlgClose(&m_StatsDlg);
    }
    */
}

/*!--------------------------------------------------------------------------
    CIpsmServer::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    
    HRESULT hr = hrOK;
    CString strTemp;

    HANDLE hsession;

    COM_PROTECT_TRY
    {
        CORg (CreateSpdInfo(&m_spSpdInfo));
        CORg (CreateApDbInfo(&m_spApDbInfo));

        m_spSpdInfo->SetComputerName((LPTSTR)(LPCTSTR)m_strServerAddress);
        m_spApDbInfo->SetComputerName((LPTSTR)(LPCTSTR)m_strServerAddress);

	//AfxMessageBox(m_strServerAddress, MB_YESNO);  //ERASEME//

#if 0
        no need to open a session here as we tried to open a session
        when constructing the database.

        hr = OpenWZCDbLogSession(
                                 NULL/*(LPTSTR)(LPCTSTR)m_strServerAddress*/, 
                                 0,
                                 &hsession);
        if (hr == 0) 
        {
            m_spSpdInfo->SetSession(hsession);
        }
#endif //0
        
        BuildDisplayName(&strTemp);

        SetDisplayName(strTemp);

       

        // Make the node immediately visible
        pNode->SetVisibilityState(TFS_VIS_SHOW);
        pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
        pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_SERVER);
        pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_SERVER);
        pNode->SetData(TFS_DATA_USER, (LPARAM) this);
        pNode->SetData(TFS_DATA_TYPE, IPSMSNAP_SERVER);

        SetColumnStringIDs(&aColumns[IPSMSNAP_SERVER][0]);
        SetColumnWidths(&aColumnWidths[IPSMSNAP_SERVER][0]);

       // m_StatsDlg.SetData(m_spSpdInfo);

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}


/*---------------------------------------------------------------------------
    CIpsmServer::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CIpsmServer::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;
    switch (m_nState)
    {
        case notLoaded:
            nIndex = ICON_IDX_SERVER;
            break;

        case loading:
            nIndex = ICON_IDX_SERVER_BUSY;
            break;

        case loaded:
            nIndex = ICON_IDX_SERVER_CONNECTED;
            break;

        case unableToLoad:
            nIndex = ICON_IDX_SERVER_LOST_CONNECTION;
            break;
        default:
            ASSERT(FALSE);
    }

    return nIndex;
}

/*---------------------------------------------------------------------------
    CIpsmServer::OnHaveData
        When the background thread enumerates nodes to be added to the UI,
        we get called back here.  We override this to force expansion of the 
        node so that things show up correctly.
    Author: NSun
 ---------------------------------------------------------------------------*/
void 
CIpsmServer::OnHaveData
(
    ITFSNode * pParentNode, 
    ITFSNode * pNewNode
)
{
    CMTIpsmHandler::OnHaveData(pParentNode, pNewNode);
    ExpandNode(pParentNode, TRUE);
}

/*---------------------------------------------------------------------------
    CIpsmServer::OnHaveData
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
void 
CIpsmServer::OnHaveData
(
    ITFSNode * pParentNode, 
    LPARAM      Data,
    LPARAM      Type
)
{
    HRESULT hr = hrOK;
    HWND    hStatsDlg = NULL;
    
    // This is how we get non-node data back from the background thread.
    switch (Type)
    {
    case IPSECMON_QDATA_REFRESH_STATS:
        {
            // tell all of the child nodes to clear their status caches
            // if any of the nodes is the selected node, then they should
            // repaint the window
            SPITFSNodeEnum      spNodeEnum;
            SPITFSNode          spCurrentNode;
            ULONG               nNumReturned;
            
            CORg(pParentNode->GetEnum(&spNodeEnum));
            
            CORg(spNodeEnum->Next(1, &spCurrentNode, &nNumReturned));
            while (nNumReturned)
            {
                LONG_PTR dwDataType = spCurrentNode->GetData(TFS_DATA_TYPE);
                switch (dwDataType)
                {
                case IPFWMON_LOGDATA:
                    {
                        CLogDataHandler * pLogDataHandler = 
                            GETHANDLER(CLogDataHandler, spCurrentNode);
                        pLogDataHandler->UpdateStatus(spCurrentNode);
                    }
                    break;	
                    
                case WLANMON_APDATA:
                    {
                        CWirelessHandler * pWirelessHandler = 
                            GETHANDLER(CWirelessHandler, spCurrentNode);
                        pWirelessHandler->UpdateStatus(spCurrentNode);
                    }
                    break;
                    
                default:
                    break;
                }
                spCurrentNode.Release();
                spNodeEnum->Next(1, &spCurrentNode, &nNumReturned);
            }
        }
        break;

    case IPSECMON_QDATA_FAILED:
        pParentNode->DeleteAllChildren(TRUE);
        
        // in OnChangeState, the sate will be changed to unableToLoad
        // and the error will be posted
        m_nState = loading;  
        OnChangeState(pParentNode);
        
        //Also close the statistics window
        //hStatsDlg = m_StatsDlg.GetSafeHwnd();
        if (hStatsDlg)
        {
            PostMessage(hStatsDlg, WM_CLOSE, 0, 0);
        }
        break;
    }
    
    COM_PROTECT_ERROR_LABEL;
}

/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsmServer::OnAddMenuItems
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmServer::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG    fFlags = 0;
    HRESULT hr = S_OK;
    CString strMenuItem;

    //TODO handle menu items here
    if (m_nState != loaded)
    {
        fFlags |= MF_GRAYED;
    }

    if (type == CCT_SCOPE)
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
            strMenuItem.LoadString(IDS_MENU_RECONNECT);
            hr = LoadAndAddMenuItem( pContextMenuCallback,
                                     strMenuItem,
                                     IDS_MENU_RECONNECT,
                                     CCM_INSERTIONPOINTID_PRIMARY_TOP,
                                     0
                                     );
            ASSERT( SUCCEEDED(hr) );
        }

    }

    return hr; 
}

/*---------------------------------------------------------------------------
    CIpsmServer::OnCommand
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmServer::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;

    switch (nCommandId)
    {
         case IDS_MENU_RECONNECT:
            OnRefresh(pNode, pDataObject, 0, 0, 0);
            break;
            
        default:
            break;
    }

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmServer::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmServer::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    HRESULT hr = S_FALSE;
#if 0    
    //TODO: remove #if and #endif to re-enable property pages when ready
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT hr = hrOK;
    
    if (dwType & TFS_COMPDATA_CREATE)
    {
        // This is the case where we are asked to bring up property
        // pages when the user is adding a new snapin.  These calls
        // are forwarded to the root node to handle.  Only for the root node
        hr = hrOK;
        Assert(FALSE); // should never get here
    }
    else
    {
        // we have property pages in the normal case, but don't put the
        // menu up if we are not loaded yet
        if ( (m_nState == loaded) ||
             (m_nState == unableToLoad) )
        {
            hr = hrOK;
        }
        else
        {
            hr = hrFalse;
        }
    }
#endif //0
    return hr;
}

/*---------------------------------------------------------------------------
    CIpsmServer::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CIpsmServer::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpProvider,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    HRESULT hr = S_FALSE;

    return hr;
#if 0
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    CMachineProperties * pMachineProp = new CMachineProperties(
                                                pNode,
                                                spComponentData,
                                                m_spTFSCompData,
                                                m_spSpdInfo, 
                                                NULL, 
                                                loaded == m_nState
                                                );
    

    pMachineProp->m_strMachineName = m_strServerAddress;

    // fill in the auto refresh info
    pMachineProp->m_pageRefresh.m_dwRefreshInterval = GetAutoRefreshInterval();
    pMachineProp->m_pageRefresh.m_bAutoRefresh = GetOptions() & IPSMSNAP_OPTIONS_REFRESH ? TRUE : FALSE;
    
    return pMachineProp->CreateModelessSheet(lpProvider, handle);
#endif //0

}

/*---------------------------------------------------------------------------
    CIpsmServer::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmServer::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    CMachineProperties * pMachineProp = reinterpret_cast<CMachineProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    pMachineProp->OnPropertyChange(TRUE, &changeMask);

    //Let the main thread know that we are done
    pMachineProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;

}

/*!--------------------------------------------------------------------------
    CIpsmServer::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CIpsmServer::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return OnDelete(pNode);
}

/*!--------------------------------------------------------------------------
    CIpsmServer::OnNotifyExiting
        We override this for the server node because we don't want the 
        icon to change when the thread goes away.  Normal behavior is that
        the node's icon changes to a wait cursor when the background thread
        is running.  If we are only doing stats collection, then we 
        don't want the icon to change.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::OnNotifyExiting
(
    LPARAM          lParam
)
{
    CIpsmServerQueryObj * pQuery = (CIpsmServerQueryObj *) lParam;
    
    if (!pQuery->m_bStatsOnly)
        OnChangeState(m_spNode);

    ReleaseThreadHandler();

    Unlock();

    return hrOK;
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 /*!--------------------------------------------------------------------------
    CIpsmServer::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
    HRESULT hr = S_OK;
    m_spSpdInfo->Destroy();
    m_spApDbInfo->Destroy();

    hr = CMTHandler::OnRefresh(pNode, pDataObject, dwType, arg, param);
    /*
    HWND hStatsDlg = m_StatsDlg.GetSafeHwnd();
    if (hStatsDlg)
    {
        PostMessage(hStatsDlg, WM_UPDATE_STATS, 0, 0);
    }
    */

    return hr;
}

/*!--------------------------------------------------------------------------
    CIpsmServer::OnRefreshStats
        Default implementation for the Stats refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::OnRefreshStats
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT             hr = hrOK;
    SPITFSNode          spNode;
    SPITFSNodeHandler   spHandler;
    ITFSQueryObject *   pQuery = NULL;
    
    if (m_bExpanded == FALSE)
    {
        // we cannot get statistics if the node hasn't been expanded yet
        return hr;
    }

    // only do stats refresh if the server was loaded correctly.
    if (m_nState != loaded)
        return hr;

    BOOL bLocked = IsLocked();
    if (bLocked)
    {
        // cannot refresh stats if this node is locked
        return hr; 
    }

    Lock();

    //OnChangeState(pNode);

    pQuery = OnCreateQuery(pNode);
    Assert(pQuery);

    // notify the UI to change icon, if needed
    //Verify(SUCCEEDED(pComponentData->ChangeNode(this, SCOPE_PANE_CHANGE_ITEM_ICON)));

    Verify(StartBackgroundThread(pNode, m_spTFSCompData->GetHiddenWnd(), pQuery));
    
    pQuery->Release();

    return hrOK;
}


 /*---------------------------------------------------------------------------
    CIpsmServer::OnDelete()
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::OnDelete(ITFSNode * pNode)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT hr = S_OK;

    CString strMessage;
    AfxFormatString1(strMessage, IDS_WARN_SERVER_DELETE, m_strServerAddress);

    if (AfxMessageBox(strMessage, MB_YESNO) == IDYES)
    {
        // remove this node from the list, there's nothing we need to tell
        // the server, it's just our local list of servers
        SPITFSNode spParent;

        pNode->GetParent(&spParent);
        spParent->RemoveChild(pNode);
    }

    return hr;
}

 
/*---------------------------------------------------------------------------
    Server manipulation functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsmServer::BuildDisplayName
        Builds the string that goes in the UI for this server
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::BuildDisplayName
(
    CString * pstrDisplayName
)
{
    if (pstrDisplayName)
    {
        *pstrDisplayName = GetName();
    }

    return hrOK;
}

/*---------------------------------------------------------------------------
    CIpsmServer::SetAutoRefresh
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::SetAutoRefresh
(
    ITFSNode *  pNode,
    BOOL        bOn,
    DWORD       dwRefreshInterval
)
{
    BOOL bCurrentAutoRefresh = IsAutoRefreshEnabled();

    if (bCurrentAutoRefresh &&
        !bOn)
    {
        // turning off the timer
        g_TimerMgr.FreeTimer(m_StatsTimerId);
    }
    else
    if (!bCurrentAutoRefresh &&
        bOn)
    {
        // gotta turn on the timer
        m_StatsTimerId = g_TimerMgr.AllocateTimer(pNode, this, dwRefreshInterval, StatisticsTimerProc);
    }
    else
    if (bOn && 
        m_dwRefreshInterval != dwRefreshInterval)
    {
        // time to change the timer
        g_TimerMgr.ChangeInterval(m_StatsTimerId, dwRefreshInterval);
    }

    if (bOn)
        m_dwOptions |= IPSMSNAP_OPTIONS_REFRESH;
    else
        m_dwOptions &= ~IPSMSNAP_OPTIONS_REFRESH;

    m_dwRefreshInterval = dwRefreshInterval;

    return hrOK;
}


/*---------------------------------------------------------------------------
    CIpsmServer::SetDnsResolve
        Description
    Author: Briansw
 ---------------------------------------------------------------------------*/
HRESULT
CIpsmServer::SetDnsResolve
(
    ITFSNode *  pNode,
    BOOL        bEnable
)
{

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (bEnable)
        m_dwOptions |= IPSMSNAP_OPTIONS_DNS;
    else
        m_dwOptions &= ~IPSMSNAP_OPTIONS_DNS;

    g_HashTable.SetDnsResolve(bEnable);


    return hrOK;

}


/*---------------------------------------------------------------------------
    CIpsmServer::SetAutoRefresh
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
void
CIpsmServer::SetExtensionName()
{
    CString strName;
    strName.LoadString(IDS_IPSECMON);
    SetDisplayName(strName);
}

 /*!--------------------------------------------------------------------------
    CIpsmServer::UpdateStandardVerbs
        Updates the standard verbs depending upon the state of the node
    Author: NSun
 ---------------------------------------------------------------------------*/
void
CIpsmServer::UpdateConsoleVerbs
(
    IConsoleVerb * pConsoleVerb,
    LONG_PTR       dwNodeType,
    BOOL           bMultiSelect
)
{
    BOOL                bStates[ARRAYLEN(g_ConsoleVerbs)];  
    MMC_BUTTON_STATE *  ButtonState;
    int                 i;
    
    if (bMultiSelect)
    {
        ButtonState = g_ConsoleVerbStatesMultiSel[dwNodeType];
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
    }
    else
    {
        ButtonState = g_ConsoleVerbStates[dwNodeType];
        switch (m_nState)
        {
            case loaded:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
                break;
    
            case notLoaded:
            case loading:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                break;

            case unableToLoad:
                for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
                bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
                bStates[MMC_VERB_DELETE & 0x000F] = TRUE;
                bStates[MMC_VERB_PROPERTIES & 0x000F] = TRUE;
                break;
        }
    }

    EnableVerbs(pConsoleVerb, ButtonState, bStates);
}

/*---------------------------------------------------------------------------
    Background thread functionality
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CIpsmServer::OnCreateQuery
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
ITFSQueryObject* 
CIpsmServer::OnCreateQuery(ITFSNode * pNode)
{
    CIpsmServerQueryObj* pQuery = 
        new CIpsmServerQueryObj(m_spTFSCompData, m_spNodeMgr);
    
    pQuery->m_strServer = GetName();
    pQuery->m_spSpdInfo.Set(m_spSpdInfo);
    pQuery->m_spApDbInfo.Set(m_spApDbInfo);
    pQuery->m_bStatsOnly = m_bStatsOnly;
    
    return pQuery;
}

/*---------------------------------------------------------------------------
    CIpsmServerQueryObj::Execute()
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP
CIpsmServerQueryObj::Execute()
{
    HRESULT   hr = S_OK;
    DWORD dwActive=m_spSpdInfo->GetActiveInfo();
    DWORD dwInit=m_spSpdInfo->GetInitInfo();
//  DWORD dwApActive=m_spApDbInfo->GetActiveInfo();
//  DWORD dwApInit=m_spApDbInfo->GetInitInfo();
    DWORD dwNew = 0;
    DWORD dwTotal = 0;
    int i;
    
    //Query the data from SPD

    //switch(dwActive) {
   
    /*case MON_FILTER:
            CORg(m_spSpdInfo->EnumFWFilters());
            break;
   */
    //case MON_LOG_DATA:
        CORg(m_spSpdInfo->EnumLogData(&dwNew, &dwTotal));
        CORg(m_spApDbInfo->EnumApData());
    //    break; 
    //default:
        // Initial load.  Ping server to see if its up
        //CORg(m_spSpdInfo->LoadStatistics());
    //    break;
    //}

    if (m_bStatsOnly)
    {
        // we post this message esentially to get back on the main thread 
        // so that we can update the UI
        AddToQueue(NULL, IPSECMON_QDATA_REFRESH_STATS);
        return hrFalse;
    }

    {
        //Add the access point node
        SPITFSNode spWirelessNode;
        CWirelessHandler *pWirelessHandler = new 
            CWirelessHandler(m_spTFSCompData);
        CreateContainerTFSNode(	&spWirelessNode,
                                &GUID_IpfmWirelessNodeType,
                                pWirelessHandler,
                                pWirelessHandler,
                                m_spNodeMgr);
        pWirelessHandler->InitApData(m_spApDbInfo);
        pWirelessHandler->InitializeNode(spWirelessNode);
        AddToQueue(spWirelessNode);
        pWirelessHandler->Release();
        //pNode->AddChild(spWirelessNode);


        // add the wireless log node
        SPITFSNode spLogDataNode;
        CLogDataHandler * pLogDataHandler = new 
            CLogDataHandler(m_spTFSCompData);
        CreateContainerTFSNode(&spLogDataNode,
                               &GUID_IpfmLogDataNodeType,
                               pLogDataHandler,
                               pLogDataHandler,
                               m_spNodeMgr);
        pLogDataHandler->InitData(m_spSpdInfo);
        pLogDataHandler->InitializeNode(spLogDataNode);
        AddToQueue(spLogDataNode);
        pLogDataHandler->Release();
        //pNode->AddChild(spLogDataNode);
    }		
    
COM_PROTECT_ERROR_LABEL;

    if (FAILED(hr))
    {
        PostError(WIN32_FROM_HRESULT(hr));
        if (m_bStatsOnly)
        {
            //If we are doing auto-refresh, tell the main thread 
            //that the query failed
            AddToQueue(NULL, IPSECMON_QDATA_FAILED);
        }
    }

    return hrFalse;
}



CHashTable::CHashTable()
{
    DWORD i;
    
    m_bDnsResolveActive=FALSE;
    m_bThreadRunning=FALSE;
    for (i=0; i < TOTAL_TABLE_SIZE; i++) {
        InitializeListHead(&HashTable[i]);
    }

}

DWORD
CHashTable::AddPendingObject(in_addr IpAddr)
{
    HashEntry *newEntry=new HashEntry;

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    if (newEntry == NULL) {
        return ERROR_OUTOFMEMORY;
    }
    newEntry->IpAddr=IpAddr;

    InsertHeadList(&HashTable[PENDING_INDEX],&newEntry->Linkage);

    return ERROR_SUCCESS;
}

DWORD
CHashTable::AddObject(HashEntry *pHE)
{

    DWORD Key=HashData(pHE->IpAddr);
    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();
    
    InsertHeadList(&HashTable[Key],&pHE->Linkage);

    return ERROR_SUCCESS;
}


DWORD
CHashTable::GetObject(HashEntry **ppHashEntry,in_addr IpAddr)
{
    DWORD Key=HashData(IpAddr);
    HashEntry *pHE;
    PLIST_ENTRY pEntry;
    DWORD dwErr;
    
    pHE=NULL;

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    if (!m_bDnsResolveActive) {
        return ERROR_NOT_READY;
    }

    // Start resolver thread
    if (!m_bThreadRunning) {
        AfxBeginThread((AFX_THREADPROC)HashResolverCallback,
                       NULL);
        m_bThreadRunning=TRUE;
    }

    for (   pEntry = HashTable[Key].Flink;
            pEntry != &HashTable[Key];
            pEntry = pEntry->Flink) {
        
       pHE = CONTAINING_RECORD(pEntry,
                              HashEntry,
                              Linkage);
       if (memcmp(&pHE->IpAddr,&IpAddr,sizeof(in_addr)) == 0) {
           *ppHashEntry = pHE;
           return ERROR_SUCCESS;
       }
    }
    dwErr=AddPendingObject(IpAddr);

    return ERROR_INVALID_PARAMETER;
}


DWORD
CHashTable::FlushTable()
{
    DWORD i;
    PLIST_ENTRY pEntry,pNextEntry;
    HashEntry *pHE;

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    for (i=0; i < TOTAL_TABLE_SIZE; i++) {
        pEntry = HashTable[i].Flink;
        
        while ( pEntry != &HashTable[i]) {
            
            pHE = CONTAINING_RECORD(pEntry,
                                    HashEntry,
                                    Linkage);
            
            pNextEntry=pEntry->Flink;
            delete pHE;
            pEntry=pNextEntry;
        }
        InitializeListHead(&HashTable[i]);
    }
    return ERROR_SUCCESS;

}


CHashTable::~CHashTable()
{
    DWORD i;
    PLIST_ENTRY pEntry,pNextEntry;
    HashEntry *pHE;

    m_bDnsResolveActive=FALSE;
    while(m_bThreadRunning) {
        Sleep(10);
    }

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    for (i=0; i < TOTAL_TABLE_SIZE; i++) {
        pEntry = HashTable[i].Flink;
        
        while ( pEntry != &HashTable[i]) {
            
            pHE = CONTAINING_RECORD(pEntry,
                                    HashEntry,
                                    Linkage);
            
            pNextEntry=pEntry->Flink;
            delete pHE;
            pEntry=pNextEntry;
        }

    }

}

HRESULT
CHashTable::SetDnsResolve(BOOL bEnable) 
{

    CSingleLock slHashLock(&m_csHashLock);
    slHashLock.Lock();

    if (m_bDnsResolveActive != bEnable) {
        m_bDnsResolveActive = bEnable;
        FlushTable();
    }

    return hrOK;
}

DWORD
CHashTable::HashData(in_addr IpAddr)
{
    int i;
    int j=0;

    for (i = 0; i < (sizeof(struct in_addr)); i++)
        j ^= (unsigned char)(*((char *)&IpAddr + i));

    return j % HASH_TABLE_SIZE;
}


DWORD
CHashTable::DnsResolve()
{

    PLIST_ENTRY pEntry;
    HashEntry *pHE;
    HOSTENT *pHost;
    BOOL bWorkAvail;

    while(m_bDnsResolveActive) {

        pHE=NULL;
        bWorkAvail=FALSE;

        CSingleLock slHashLock(&m_csHashLock);
        slHashLock.Lock();
        if (!IsListEmpty(&HashTable[PENDING_INDEX])) {
            pEntry=RemoveHeadList(&HashTable[PENDING_INDEX]);
            pHE = CONTAINING_RECORD(pEntry,
                                    HashEntry,
                                    Linkage);
            bWorkAvail=TRUE;
        }
        slHashLock.Unlock();

        // Make sure name resolution is outside of lock for perf
        if (bWorkAvail) {
            pHost=gethostbyaddr((char*)&pHE->IpAddr,sizeof(in_addr),AF_INET);
            if (pHost) {
                //Resolution succeeded
                pHE->HostName = pHost->h_name;
                g_HashTable.AddObject(pHE);
            } else {
                // Resolution attempted, failed, cache failure for perf
                ULONG ul = RevertDwordBytes(*(DWORD*)&pHE->IpAddr);
                CIpAddress TmpIpAddr = ul;
                pHE->HostName = (CString)TmpIpAddr;
                g_HashTable.AddObject(pHE);
            }
        } else {
            Sleep(300);
        }
    }
    
    m_bThreadRunning=FALSE;
    return ERROR_SUCCESS;
}



UINT HashResolverCallback(LPVOID pParam)
{

    g_HashTable.DnsResolve();
    return ERROR_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\stdafx.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1997 **/
/**********************************************************************/

/*
	stdafx.cpp	
		precompiled header file

	FILE HISTORY:
        
*/

#include "stdafx.h"
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\servpp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties header file

    FILE HISTORY:
        
*/

#if !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
#define AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define AUTO_REFRESH_MINUTES_MAX       180
#define AUTO_REFRESH_SECONDS_MAX       59

BOOL    IsLocalSystemAccount(LPCTSTR pszAccount);

/////////////////////////////////////////////////////////////////////////////
// CMachinePropRefresh dialog

class CMachinePropRefresh : public CPropertyPageBase
{
    DECLARE_DYNCREATE(CMachinePropRefresh)

// Construction
public:
    CMachinePropRefresh();
    ~CMachinePropRefresh();

// Dialog Data
    //{{AFX_DATA(CMachinePropRefresh)
    enum { IDD = IDP_SERVER_REFRESH };
    CEdit   m_editSeconds;
    CEdit   m_editMinutes;
    CSpinButtonCtrl m_spinSeconds;
    CSpinButtonCtrl m_spinMinutes;
    CButton m_checkEnableStats;
    //}}AFX_DATA

    void UpdateButtons();
    void ValidateMinutes();
    void ValidateSeconds();

    virtual BOOL OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask);

    // Context Help Support
    virtual DWORD * GetHelpMap() { return (DWORD *) &g_aHelpIDs_IDP_SERVER_REFRESH[0]; }

    BOOL        m_bAutoRefresh;
    DWORD       m_dwRefreshInterval;

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CMachinePropRefresh)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CMachinePropRefresh)
    virtual BOOL OnInitDialog();
    afx_msg void OnCheckEnableStats();
    afx_msg void OnChangeEditMinutes();
    afx_msg void OnChangeEditSeconds();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
//}}AFX

class CMachineProperties : public CPropertyPageHolderBase
{
    friend class CMachinePropRefresh;

public:
    CMachineProperties(ITFSNode *          pNode,
                      IComponentData *    pComponentData,
                      ITFSComponentData * pTFSCompData,
                      ISpdInfo *         pSpdInfo,
                      LPCTSTR             pszSheetName,
                      BOOL                fSpdInfoLoaded);
    virtual ~CMachineProperties();

    ITFSComponentData * GetTFSCompData()
    {
        if (m_spTFSCompData)
            m_spTFSCompData->AddRef();
        return m_spTFSCompData;
    }

    HRESULT GetSpdInfo(ISpdInfo ** ppSpdInfo) 
    {   
        Assert(ppSpdInfo);
        *ppSpdInfo = NULL;
        SetI((LPUNKNOWN *) ppSpdInfo, m_spSpdInfo);
        return hrOK;
    }


public:
    CMachinePropRefresh      m_pageRefresh;

    CString                 m_strMachineName;

protected:
    SPITFSComponentData     m_spTFSCompData;
    SPISpdInfo             m_spSpdInfo;
    
    BOOL                    m_fSpdInfoLoaded;
};


#endif // !defined(AFX_SERVPP_H__037BF46A_6E87_11D1_93B6_00C04FC3357A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\spddb.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	spddb.h

    FILE HISTORY:
        
*/

#ifndef _SPDDB_H
#define _SPDDB_H

#ifndef _HARRAY_H
#include "harray.h"
#endif

#include "spdutil.h"

#define PROTOCOL_ID_OFFSET  9

interface ISpdInfo;

template <class T>
void
FreeItemsAndEmptyArray (
    T& array);

DWORD
IsAdmin(
    LPCTSTR szMachineName,
    LPCTSTR szAccount,
    LPCTSTR szPassword,
    BOOL * pfIsAdmin
    );

typedef enum _IPFWMON_INFO_TYPE 
{
    MON_FILTER=0x1,
    MON_LOG_DATA=0x2,
    MON_FWSTATS=0x100,
    MON_FWINIT=0x400
} IPFWMON_INFO_TYPE;

DWORD DeallocateDbRecord(PWZC_DB_RECORD const pwzcRec);

class CLogDataInfo
{
public:
    WZC_DB_RECORD       m_wzcDbRecord;

public:
    CLogDataInfo()
    {
        memset(&m_wzcDbRecord, 0, sizeof(WZC_DB_RECORD));
    }

    DWORD ConvertToDbRecord(PWZC_DB_RECORD pwzcRecord)
    {
        DWORD dwErr = ERROR_SUCCESS;

        dwErr = AllocateAndCopy(pwzcRecord, &m_wzcDbRecord);

        return dwErr;
    }

    CLogDataInfo& operator=(const WZC_DB_RECORD &wzcDbRecord)
    {
        const WZC_DB_RECORD *pwzcDbRecord = &wzcDbRecord;

        AllocateAndCopy(&m_wzcDbRecord, pwzcDbRecord);
        
        return *this;
    }

    CLogDataInfo& operator=(const CLogDataInfo &cLogData)
    {
        const WZC_DB_RECORD *pwzcDbRecord = &cLogData.m_wzcDbRecord;

        AllocateAndCopy(&m_wzcDbRecord, pwzcDbRecord);

        return *this;
    }

    BOOL operator==(const CLogDataInfo &LogDataRHS)
    {
        BOOL bEqual = FALSE;
        const WZC_DB_RECORD *pwzcDbLHS = &m_wzcDbRecord;
        const WZC_DB_RECORD *pwzcDbRHS = &LogDataRHS.m_wzcDbRecord;

        //TODO: Complete and check all the fields inside
        if ( (pwzcDbLHS->recordid == pwzcDbRHS->recordid) &&
             (pwzcDbLHS->componentid == pwzcDbRHS->componentid) &&
             (pwzcDbLHS->category == pwzcDbRHS->category) &&
             (pwzcDbLHS->timestamp == pwzcDbRHS->timestamp) &&
             (pwzcDbLHS->message.dwDataLen == pwzcDbRHS->message.dwDataLen) &&
             (pwzcDbLHS->localmac.dwDataLen == pwzcDbRHS->localmac.dwDataLen)&&
             (pwzcDbLHS->remotemac.dwDataLen==pwzcDbRHS->remotemac.dwDataLen)&&
             (pwzcDbLHS->ssid.dwDataLen == pwzcDbRHS->ssid.dwDataLen) &&
             (pwzcDbLHS->context.dwDataLen == pwzcDbRHS->context.dwDataLen) )
            bEqual = TRUE;

        return bEqual;
    }

    BOOL operator!=(const CLogDataInfo &LogDataRHS)
    {
        BOOL bNotEqual = FALSE;
        const WZC_DB_RECORD *pwzcDbLHS = &m_wzcDbRecord;
        const WZC_DB_RECORD *pwzcDbRHS = &LogDataRHS.m_wzcDbRecord;

        //TODO: complete and check all fields inside 
        if ( (pwzcDbLHS->recordid != pwzcDbRHS->recordid) ||
             (pwzcDbLHS->componentid != pwzcDbRHS->componentid) ||
             (pwzcDbLHS->category != pwzcDbRHS->category) ||
             (pwzcDbLHS->timestamp != pwzcDbRHS->timestamp) ||
             (pwzcDbLHS->message.dwDataLen != pwzcDbRHS->message.dwDataLen) ||
             (pwzcDbLHS->localmac.dwDataLen != pwzcDbRHS->localmac.dwDataLen)||
             (pwzcDbLHS->remotemac.dwDataLen!=pwzcDbRHS->remotemac.dwDataLen)||
             (pwzcDbLHS->ssid.dwDataLen != pwzcDbRHS->ssid.dwDataLen) ||
             (pwzcDbLHS->context.dwDataLen != pwzcDbRHS->context.dwDataLen) )
            bNotEqual = TRUE;

        return bNotEqual;
    }

    void Deallocate()
    {
        DeallocateDbRecord(&m_wzcDbRecord);
    }

    ~CLogDataInfo()
    {
        DeallocateDbRecord(&m_wzcDbRecord);
    }

 private:
    DWORD AllocateAndCopy(WZC_DB_RECORD *pwzcDest, 
                          const WZC_DB_RECORD *pwzcSrc)
    {
        DWORD dwErr = ERROR_SUCCESS;
        
        pwzcDest->recordid = pwzcSrc->recordid;
        pwzcDest->componentid = pwzcSrc->componentid;
        pwzcDest->category = pwzcSrc->category;
        pwzcDest->timestamp = pwzcSrc->timestamp;
        pwzcDest->message.dwDataLen = pwzcSrc->message.dwDataLen;
        pwzcDest->localmac.dwDataLen = pwzcSrc->localmac.dwDataLen;
        pwzcDest->remotemac.dwDataLen = pwzcSrc->remotemac.dwDataLen;
        pwzcDest->ssid.dwDataLen = pwzcSrc->ssid.dwDataLen;
        pwzcDest->context.dwDataLen = pwzcSrc->context.dwDataLen;
        
        try
	{
            if (pwzcSrc->message.dwDataLen > 0)
            {
                pwzcDest->message.pData = new 
                    BYTE[pwzcSrc->message.dwDataLen];
                memcpy(pwzcDest->message.pData, 
                       pwzcSrc->message.pData,
                       pwzcSrc->message.dwDataLen);
            }
            else
                pwzcDest->message.pData = NULL;
            
            if (pwzcSrc->localmac.dwDataLen > 0)
            {
                pwzcDest->localmac.pData = new
                    BYTE[pwzcSrc->localmac.dwDataLen];
                memcpy(pwzcDest->localmac.pData, 
                       pwzcSrc->localmac.pData,
                       pwzcSrc->localmac.dwDataLen);
            }
            else
                pwzcDest->localmac.pData = NULL;
            
            if (pwzcSrc->remotemac.dwDataLen > 0)
            {
                pwzcDest->remotemac.pData = new
                    BYTE[pwzcSrc->remotemac.dwDataLen];
                
                memcpy(pwzcDest->remotemac.pData, 
                       pwzcSrc->remotemac.pData,
                       pwzcSrc->remotemac.dwDataLen);
            }
            else
                pwzcDest->remotemac.pData = NULL;
            
            if (pwzcSrc->ssid.dwDataLen > 0)
            {
                pwzcDest->ssid.pData = new
                    BYTE[pwzcSrc->ssid.dwDataLen];
                memcpy(pwzcDest->ssid.pData, pwzcSrc->ssid.pData,
                       pwzcSrc->ssid.dwDataLen);
            }
            else
                pwzcDest->ssid.pData = NULL;
            
            if (pwzcSrc->context.dwDataLen > 0)
            {
                pwzcDest->context.pData = new
                    BYTE[pwzcSrc->context.dwDataLen];
                memcpy(pwzcDest->context.pData, 
                       pwzcSrc->context.pData,
                       pwzcSrc->context.dwDataLen);
            }
            else
                pwzcDest->context.pData = NULL;
        }
        catch(...)
	{
            Panic0("Memory allocation failure AllocateAndCopy");
            dwErr = ERROR_OUTOFMEMORY;
        }      
        return dwErr;
    }
};

typedef CArray<CLogDataInfo *, CLogDataInfo *> CLogDataInfoArray;

#define MAX_STR_LEN 80

#define DeclareISpdInfoMembers(IPURE) \
	STDMETHOD(Destroy) (THIS) IPURE; \
	STDMETHOD(SetComputerName) (THIS_ LPTSTR pszName) IPURE; \
	STDMETHOD(GetComputerName) (THIS_ CString * pstName) IPURE; \
	STDMETHOD(GetSession) (THIS_ PHANDLE phsession) IPURE; \
	STDMETHOD(SetSession) (THIS_ HANDLE hsession) IPURE; \
        STDMETHOD(ResetSession) (THIS) IPURE; \
	STDMETHOD(EnumLogData) (THIS_ PDWORD pdwNew, PDWORD pdwTotal) IPURE; \
        STDMETHOD(FlushLogs) (THIS) IPURE; \
	STDMETHOD(GetLogDataInfo) (THIS_ int iIndex, CLogDataInfo * pLogDataInfo) IPURE; \
        STDMETHOD(SetSortOptions) (THIS_ DWORD dwColID, BOOL bAscending) IPURE; \
	STDMETHOD_(DWORD, GetLogDataCount) (THIS) IPURE; \
	STDMETHOD(SortLogData) (THIS_ DWORD dwIndexType, DWORD dwSortOptions) IPURE; \
        STDMETHOD(SortLogData) (THIS) IPURE; \
        STDMETHOD(GetLastIndex) (THIS_ int *pnIndex) IPURE; \
        STDMETHOD(GetSpecificLog) (THIS_ int nIndex, CLogDataInfo *pLogDataInfo) IPURE; \
        STDMETHOD(FindIndex) (THIS_ int *pnIndex, CLogDataInfo *pLogDataInfo) IPURE; \
	STDMETHOD_(DWORD, GetInitInfo) (THIS) IPURE; \
	STDMETHOD_(void, SetInitInfo) (THIS_ DWORD dwInitInfo) IPURE; \
	STDMETHOD_(DWORD, GetActiveInfo) (THIS) IPURE; \
	STDMETHOD_(void, SetActiveInfo) (THIS_ DWORD dwActiveInfo) IPURE; \
        STDMETHOD_(void, StartFromFirstRecord) (THIS_ BOOL bFromFirst) IPURE; \

#undef INTERFACE
#define INTERFACE ISpdInfo
DECLARE_INTERFACE_(ISpdInfo, IUnknown)
{
public:
	DeclareIUnknownMembers(PURE)
	DeclareISpdInfoMembers(PURE)

};

typedef ComSmartPointer<ISpdInfo, &IID_ISpdInfo> SPISpdInfo;

class CSpdInfo : public ISpdInfo
{
public:
    CSpdInfo();
    ~CSpdInfo();
    
    DeclareIUnknownMembers(IMPL);
    DeclareISpdInfoMembers(IMPL);
    
private:
    CLogDataInfoArray	m_arrayLogData;	 //For Log Data
    CIndexMgrLogData	m_IndexMgrLogData;
    CCriticalSection    m_csData;
    CString		m_stMachineName;
    LONG                m_cRef;
    DWORD               m_Init;
    DWORD               m_Active;
    HANDLE              m_session;
    bool                m_session_init;
    BOOL                m_bFromFirst;
    BOOL                m_bEliminateDuplicates;
    //Remember the users last choice for sorting
    DWORD               m_dwSortIndex;
    DWORD               m_dwSortOption;
    /* Configureable parameter representing the number of records that
     * may be stored in the database and hence indicates the number of
     * records that are cached in the monitor.
     */
    int m_nNumRecords;
    
private:
    DWORD
    EliminateDuplicates(
        CLogDataInfoArray *pArray
        );
    
    HRESULT
    InternalEnumLogData(
        CLogDataInfoArray *pArray,
        DWORD             dwPreferredNum,
        BOOL              pbFromFirst
        );
    
    HRESULT
    InternalGetSpecificLog(
        CLogDataInfo *pLogDataInfo
        );
    
    void
    FreeItemsAndEmptyArray(
        CLogDataInfoArray& array
        );
};

HRESULT
CreateSpdInfo(
    ISpdInfo **ppSpdInfo
    );

#endif // _SPDDB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\server.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
    server.h

    FILE HISTORY:
        
*/

#ifndef _SERVER_H
#define _SERVER_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _SPDDB_H
#include "spddb.h"
#endif

#ifndef _APINFO_H
#include "apinfo.h"
#endif

//#include "stats.h"

// options for the server outside of the API
#define IPSMSNAP_OPTIONS_REFRESH            0x00000001
#define IPSMSNAP_OPTIONS_EXTENSION          0x00000002
#define IPSMSNAP_OPTIONS_DNS                0x00000004

// custom data types for query object
#define IPSECMON_QDATA_REFRESH_STATS            0x00000001
#define IPSECMON_QDATA_FAILED					0x00000002

class CIpsmServer;

class CTimerDesc
{
public:
    SPITFSNode      spNode;
    CIpsmServer *   pServer;
    UINT_PTR        uTimer;
    TIMERPROC       timerProc;
};

typedef CArray<CTimerDesc *, CTimerDesc *> CTimerArrayBase;

class CTimerMgr : CTimerArrayBase
{
public:
    CTimerMgr();
    ~CTimerMgr();

public:
    int                 AllocateTimer(ITFSNode * pNode, CIpsmServer * pServer, UINT uTimerValue, TIMERPROC TimerProc);
    void                FreeTimer(UINT_PTR uEventId);
    void                ChangeInterval(UINT_PTR uEventId, UINT uNewInterval);
    CTimerDesc *        GetTimerDesc(UINT_PTR uEventId);
    CCriticalSection    m_csTimerMgr;
};

/*---------------------------------------------------------------------------
    Class:  CIpsmServer
 ---------------------------------------------------------------------------*/
class CIpsmServer : public CMTIpsmHandler
{
public:
    CIpsmServer(ITFSComponentData* pTFSComponentData);
    ~CIpsmServer();

// Interface
public:
    // base handler functionality we override
    OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
    OVERRIDE_NodeHandler_OnAddMenuItems();
    OVERRIDE_NodeHandler_OnCommand();
    OVERRIDE_NodeHandler_GetString()
            { return (nCol == 0) ? GetDisplayName() : NULL; }

    // Choose which messages we want to handle
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

    // Result handler functionality we override

    // CMTHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);

public:
    // CMTIpsmHandler functionality
    virtual HRESULT  InitializeNode(ITFSNode * pNode);
    virtual int      GetImageIndex(BOOL bOpenImage);
    ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);
    virtual void     OnHaveData(ITFSNode * pParentNode, ITFSNode * pNode);
	virtual void     OnHaveData(ITFSNode * pParentNode, LPARAM Data, LPARAM Type);

    STDMETHOD(OnNotifyExiting)(LPARAM);

    virtual void     GetErrorPrefix(ITFSNode * pNode, CString * pstrMessage)
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState());
        AfxFormatString1(*pstrMessage, IDS_ERR_SERVER_NODE, GetDisplayName());
    }
    
    virtual void    UpdateConsoleVerbs(IConsoleVerb * pConsoleVerb, LONG_PTR dwNodeType, BOOL bMultiSelect = FALSE);

public:
    // implementation specific  
    HRESULT BuildDisplayName(CString * pstrDisplayName);

    void    SetName(LPCTSTR pName) { m_strServerAddress = pName; }
    LPCTSTR GetName() { return m_strServerAddress; }

    HRESULT OnRefreshStats(ITFSNode *   pNode,
                           LPDATAOBJECT pDataObject,
                           DWORD        dwType,
                           LPARAM       arg,
                           LPARAM       param);


    void    SetOptions(DWORD dwOptions) { m_dwOptions = dwOptions; }
    DWORD   GetOptions() { return m_dwOptions; }

    HRESULT SetAutoRefresh(ITFSNode *  pNode, BOOL bOn, DWORD dwRefreshInterval);
    HRESULT SetDnsResolve(ITFSNode *  pNode, BOOL bEnable);
    BOOL    IsAutoRefreshEnabled() { return m_dwOptions & IPSMSNAP_OPTIONS_REFRESH; }
    DWORD   GetAutoRefreshInterval() { return m_dwRefreshInterval; }
    
    void    SetExtensionName();

// Implementation
private:
    // Command handlers
    HRESULT OnDelete(ITFSNode * pNode);

public:
    BOOL                m_bStatsOnly;

private:
	SPISpdInfo			m_spSpdInfo;
	SPIApDbInfo			m_spApDbInfo;
	//CIpsecStats			m_StatsDlg;

    CString             m_strServerAddress;
    
    DWORD               m_dwOptions;
    DWORD               m_dwRefreshInterval;
    
    int                 m_StatsTimerId;
};



/*---------------------------------------------------------------------------
    Class:  CIpsmServerQueryObj
 ---------------------------------------------------------------------------*/
class CIpsmServerQueryObj : public CIpsmQueryObj
{
public:
    CIpsmServerQueryObj(ITFSComponentData * pTFSComponentData,
                        ITFSNodeMgr *       pNodeMgr) 
            : CIpsmQueryObj(pTFSComponentData, pNodeMgr) {};
    
    STDMETHODIMP Execute();
    
public:
	SPISpdInfo			m_spSpdInfo;
	SPIApDbInfo			m_spApDbInfo;
    BOOL                m_bStatsOnly;
};

class HashEntry {
public:
    LIST_ENTRY Linkage;
    in_addr IpAddr;
    CString HostName;
}; 

#define HASH_TABLE_SIZE 128
#define TOTAL_TABLE_SIZE 129  //hash entries 0-127, Pending list is 128
#define PENDING_INDEX 128

//Callback for background resolver thread
UINT HashResolverCallback(LPVOID pParam);

class CHashTable {
public:
    CHashTable();
    ~CHashTable();
    DWORD AddPendingObject(in_addr IpAddr);
    DWORD AddObject(HashEntry *pHE);
    DWORD GetObject(HashEntry **ppHashEntry,in_addr IpAddr);
    HRESULT SetDnsResolve(BOOL bEnable);
    DWORD FlushTable();
    DWORD DnsResolve();

public:
    CCriticalSection m_csHashLock;
    BOOL m_bDnsResolveActive;
    BOOL m_bThreadRunning;

private:
    DWORD HashData(in_addr IPAddr);
    LIST_ENTRY HashTable[TOTAL_TABLE_SIZE];
};

#endif _SERVER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\servpp.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    Servpp.h   
        Server properties implementation file

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "Servpp.h"
#include "server.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


BOOL IsLocalSystemAccount(LPCTSTR pszAccount)
{
    BOOL fLocal = FALSE;
    CString strLocalSystemAccount;

    if (pszAccount != NULL)
    {
        strLocalSystemAccount.LoadString(IDS_LOCAL_SYSTEM_ACCOUNT);

        if (strLocalSystemAccount.CompareNoCase(pszAccount) == 0)
            fLocal = TRUE;
    }

    return fLocal;
}

/////////////////////////////////////////////////////////////////////////////
//
// CMachineProperties holder
//
/////////////////////////////////////////////////////////////////////////////
CMachineProperties::CMachineProperties
(
    ITFSNode *          pNode,
    IComponentData *    pComponentData,
    ITFSComponentData * pTFSCompData,
    ISpdInfo *          pSpdInfo,
    LPCTSTR             pszSheetName,
    BOOL                fSpdInfoLoaded
) : CPropertyPageHolderBase(pNode, pComponentData, pszSheetName),
    m_fSpdInfoLoaded(fSpdInfoLoaded)
{
    //ASSERT(pFolderNode == GetContainerNode());

    m_bAutoDeletePages = FALSE; // we have the pages as embedded members

	AddPageToList((CPropertyPageBase*) &m_pageRefresh);

    Assert(pTFSCompData != NULL);
    m_spTFSCompData.Set(pTFSCompData);
    
    m_spSpdInfo.Set(pSpdInfo);

}

CMachineProperties::~CMachineProperties()
{
	RemovePageFromList((CPropertyPageBase*) &m_pageRefresh, FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// CMachinePropRefresh property page

IMPLEMENT_DYNCREATE(CMachinePropRefresh, CPropertyPageBase)

CMachinePropRefresh::CMachinePropRefresh() : CPropertyPageBase(CMachinePropRefresh::IDD)
{
    //{{AFX_DATA_INIT(CMachinePropRefresh)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CMachinePropRefresh::~CMachinePropRefresh()
{
}

void CMachinePropRefresh::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPageBase::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMachinePropRefresh)
    DDX_Control(pDX, IDC_EDIT_SECONDS, m_editSeconds);
    DDX_Control(pDX, IDC_EDIT_MINUTES, m_editMinutes);
    DDX_Control(pDX, IDC_SPIN_SECONDS, m_spinSeconds);
    DDX_Control(pDX, IDC_SPIN_MINUTES, m_spinMinutes);
    DDX_Control(pDX, IDC_CHECK_ENABLE_STATS, m_checkEnableStats);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMachinePropRefresh, CPropertyPageBase)
    //{{AFX_MSG_MAP(CMachinePropRefresh)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_STATS, OnCheckEnableStats)
    ON_EN_CHANGE(IDC_EDIT_MINUTES, OnChangeEditMinutes)
    ON_EN_CHANGE(IDC_EDIT_SECONDS, OnChangeEditSeconds)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMachinePropRefresh message handlers

BOOL CMachinePropRefresh::OnInitDialog() 
{
    CPropertyPageBase::OnInitDialog();
    
    m_spinMinutes.SetRange(0, AUTO_REFRESH_MINUTES_MAX);
    m_spinSeconds.SetRange(0, AUTO_REFRESH_SECONDS_MAX);

    m_checkEnableStats.SetCheck(m_bAutoRefresh);

    // update the refresh interval
    int nMinutes, nSeconds;
    DWORD dwRefreshInterval = m_dwRefreshInterval;

    nMinutes = dwRefreshInterval / MILLISEC_PER_MINUTE;
    dwRefreshInterval -= nMinutes * MILLISEC_PER_MINUTE;

    nSeconds = dwRefreshInterval / MILLISEC_PER_SECOND;
    dwRefreshInterval -= nSeconds * MILLISEC_PER_SECOND;

    m_spinMinutes.SetPos(nMinutes);
    m_spinSeconds.SetPos(nSeconds);

    m_editMinutes.LimitText(2);
    m_editSeconds.LimitText(2);

    // set the button states
    UpdateButtons();

    SetDirty(FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CMachinePropRefresh::UpdateButtons()
{
    int nCheck = m_checkEnableStats.GetCheck();

    GetDlgItem(IDC_EDIT_MINUTES)->EnableWindow(nCheck != 0);
    GetDlgItem(IDC_EDIT_SECONDS)->EnableWindow(nCheck != 0);

    GetDlgItem(IDC_SPIN_MINUTES)->EnableWindow(nCheck != 0);
    GetDlgItem(IDC_SPIN_SECONDS)->EnableWindow(nCheck != 0);
}

void CMachinePropRefresh::OnCheckEnableStats() 
{
    SetDirty(TRUE);
    
    UpdateButtons();    
}

void CMachinePropRefresh::OnChangeEditMinutes() 
{
    ValidateMinutes();
    SetDirty(TRUE);
}

void CMachinePropRefresh::OnChangeEditSeconds() 
{
    ValidateSeconds();
    SetDirty(TRUE);
}

void CMachinePropRefresh::ValidateMinutes() 
{
    CString strValue;
    int nValue;

    if (m_editMinutes.GetSafeHwnd() != NULL)
    {
        m_editMinutes.GetWindowText(strValue);
        if (!strValue.IsEmpty())
        {
            nValue = _ttoi(strValue);

            if ((nValue >= 0) &&
                (nValue <= AUTO_REFRESH_MINUTES_MAX))
            {
                // everything is good
                return;
            }

            if (nValue > AUTO_REFRESH_MINUTES_MAX)
                nValue = AUTO_REFRESH_MINUTES_MAX;
            else
            if (nValue < 0)
                nValue = 0;

            // set the new value and beep
            CString strText;
            LPTSTR pBuf = strText.GetBuffer(5);
            
            _itot(nValue, pBuf, 10);
            strText.ReleaseBuffer();

            MessageBeep(MB_ICONEXCLAMATION);

            m_editMinutes.SetWindowText(strText);
            
            m_editMinutes.SetSel(0, -1);
            m_editMinutes.SetFocus();
        }
    }
}

void CMachinePropRefresh::ValidateSeconds() 
{
    CString strValue;
    int nValue;

    if (m_editSeconds.GetSafeHwnd() != NULL)
    {
        m_editSeconds.GetWindowText(strValue);
        if (!strValue.IsEmpty())
        {
            nValue = _ttoi(strValue);

            if ((nValue >= 0) &&
                (nValue <= AUTO_REFRESH_SECONDS_MAX))
            {
                // everything is good
                return;
            }
            
            if (nValue > AUTO_REFRESH_SECONDS_MAX)
                nValue = AUTO_REFRESH_SECONDS_MAX;
            else
            if (nValue < 0)
                nValue = 0;

            CString strText;
            LPTSTR pBuf = strText.GetBuffer(5);
            
            _itot(nValue, pBuf, 10);
            strText.ReleaseBuffer();

            MessageBeep(MB_ICONEXCLAMATION);

            m_editSeconds.SetWindowText(strText);
            
            m_editSeconds.SetSel(0, -1);
            m_editSeconds.SetFocus();
        }
    }
}

BOOL CMachinePropRefresh::OnApply() 
{
    if (!IsDirty())
        return TRUE;

    UpdateData();

    m_bAutoRefresh = (m_checkEnableStats.GetCheck() == 1) ? TRUE : FALSE;

    int nMinutes = m_spinMinutes.GetPos();
    int nSeconds = m_spinSeconds.GetPos();

    
	//use minutes as seconds.
    m_dwRefreshInterval = nMinutes * MILLISEC_PER_MINUTE;
	m_dwRefreshInterval += nSeconds * MILLISEC_PER_SECOND;

    if (m_bAutoRefresh && m_dwRefreshInterval == 0)
    {
        CString strMessage;
        
        AfxMessageBox(IDS_ERR_AUTO_REFRESH_ZERO);
        m_editMinutes.SetSel(0, -1);
        m_editMinutes.SetFocus();

        return FALSE;
    }
    
    BOOL bRet = CPropertyPageBase::OnApply();

    if (bRet == FALSE)
    {
        // Something bad happened... grab the error code
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        ::IpsmMessageBox(GetHolder()->GetError());
    }

    return bRet;
}

BOOL CMachinePropRefresh::OnPropertyChange(BOOL bScope, LONG_PTR *ChangeMask)
{
    SPITFSNode      spNode;
    CIpsmServer *   pServer;
    DWORD           dwError;

    // do stuff here.
    BEGIN_WAIT_CURSOR;

    spNode = GetHolder()->GetNode();
    pServer = GETHANDLER(CIpsmServer, spNode);

    pServer->SetAutoRefresh(spNode, m_bAutoRefresh, m_dwRefreshInterval);

    SPITFSNodeMgr   spNodeMgr;
    SPITFSNode spRootNode;

    spNode->GetNodeMgr(&spNodeMgr);
    spNodeMgr->GetRootNode(&spRootNode);
    spRootNode->SetData(TFS_DATA_DIRTY, TRUE);

    END_WAIT_CURSOR;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\spddb.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    spddb.h

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "DynamLnk.h"
#include "spddb.h"
#include "spdutil.h"

#include "security.h"
#include "lm.h"
#include "service.h"

#define AVG_PREFERRED_ENUM_COUNT       40
#define MAX_NUM_RECORDS	10  // was 10

#define DEFAULT_SECURITY_PKG    _T("negotiate")
#define NT_SUCCESS(Status)      ((NTSTATUS)(Status) >= 0)
#define STATUS_SUCCESS          ((NTSTATUS)0x00000000L)

//
// The database holds 5K records and wraps around. So we dont cache more than
// 5K records.
//

#define WZCDB_DEFAULT_NUM_RECS  5000
// internal functions
BOOL    IsUserAdmin(LPCTSTR pszMachine, PSID    AccountSid);
BOOL    LookupAliasFromRid(LPWSTR TargetComputer, DWORD Rid, LPWSTR Name, PDWORD cchName);
DWORD   ValidateDomainAccount(IN CString Machine, IN CString UserName, IN CString Domain, OUT PSID * AccountSid);
NTSTATUS ValidatePassword(IN LPCWSTR UserName, IN LPCWSTR Domain, IN LPCWSTR Password);
DWORD   GetCurrentUser(CString & strAccount);

DWORD GetCurrentUser(CString & strAccount)
{
    LPBYTE pBuf;

    NET_API_STATUS status = NetWkstaUserGetInfo(NULL, 1, &pBuf);
    if (status == NERR_Success)
    {
        strAccount.Empty();

        WKSTA_USER_INFO_1 * pwkstaUserInfo = (WKSTA_USER_INFO_1 *) pBuf;
 
        strAccount = pwkstaUserInfo->wkui1_logon_domain;
        strAccount += _T("\\");
        strAccount += pwkstaUserInfo->wkui1_username;

        NetApiBufferFree(pBuf);
    }

    return (DWORD) status;
}

/*!--------------------------------------------------------------------------
    IsAdmin
        Connect to the remote machine as administrator with user-supplied
        credentials to see if the user has admin priviledges

        Returns
            TRUE - the user has admin rights
            FALSE - if user doesn't
    Author: EricDav, KennT
 ---------------------------------------------------------------------------*/
DWORD IsAdmin(LPCTSTR szMachineName, LPCTSTR szAccount, LPCTSTR szPassword, BOOL * pIsAdmin)
{
    CString         stAccount;
    CString         stDomain;
    CString         stUser;
    CString         stMachineName;
    DWORD           dwStatus;
    BOOL            fIsAdmin = FALSE;

    // get the current user info
    if (szAccount == NULL)
    {
        GetCurrentUser(stAccount);
    }
    else
    {
        stAccount = szAccount;
    }
    
    // separate the user and domain
    int nPos = stAccount.Find(_T("\\"));
    stDomain = stAccount.Left(nPos);
    stUser = stAccount.Right(stAccount.GetLength() - nPos - 1);

    // build the machine string
    stMachineName = szMachineName;
    if ( stMachineName.Left(2) != TEXT( "\\\\" ) )
    {
        stMachineName = TEXT( "\\\\" ) + stMachineName;
    }

    // validate the domain account and get the sid 
    PSID connectSid;

    dwStatus = ValidateDomainAccount( stMachineName, stUser, stDomain, &connectSid );
    if ( dwStatus != ERROR_SUCCESS  ) 
    {
        goto Error;
    }

    // if a password was supplied, is it correct?
    if (szPassword)
    {
        dwStatus = ValidatePassword( stUser, stDomain, szPassword );

        if ( dwStatus != SEC_E_OK ) 
        {
            switch ( dwStatus ) 
            {
                case SEC_E_LOGON_DENIED:
                    dwStatus = ERROR_INVALID_PASSWORD;
                    break;

                case SEC_E_INVALID_HANDLE:
                    dwStatus = ERROR_INTERNAL_ERROR;
                    break;

                default:
                    dwStatus = ERROR_INTERNAL_ERROR;
                    break;
            } // end of switch

            goto Error;

        } // Did ValidatePassword succeed?
    }

    // now check the machine to see if this account has admin access
    fIsAdmin = IsUserAdmin( stMachineName, connectSid );

Error:
    if (pIsAdmin)
        *pIsAdmin = fIsAdmin;

    return dwStatus;
}


BOOL
IsUserAdmin(LPCTSTR pszMachine,
            PSID    AccountSid)

/*++

Routine Description:

    Determine if the specified account is a member of the local admin's group

Arguments:

    AccountSid - pointer to service account Sid

Return Value:

    True if member

--*/

{
    NET_API_STATUS status;
    DWORD count;
    WCHAR adminGroupName[UNLEN+1];
    DWORD cchName = UNLEN;
    PLOCALGROUP_MEMBERS_INFO_0 grpMemberInfo;
    PLOCALGROUP_MEMBERS_INFO_0 pInfo;
    DWORD entriesRead;
    DWORD totalEntries;
    DWORD_PTR resumeHandle = NULL;
    DWORD bufferSize = 128;
    BOOL foundEntry = FALSE;

    // get the name of the admin's group

    if (!LookupAliasFromRid(NULL,
                            DOMAIN_ALIAS_RID_ADMINS,
                            adminGroupName,
                            &cchName)) {
        return(FALSE);
    }

    // get the Sids of the members of the admin's group

    do 
    {
        status = NetLocalGroupGetMembers(pszMachine,
                                         adminGroupName,
                                         0,             // level 0 - just the Sid
                                         (LPBYTE *)&grpMemberInfo,
                                         bufferSize,
                                         &entriesRead,
                                         &totalEntries,
                                         &resumeHandle);

        bufferSize *= 2;
        if ( status == ERROR_MORE_DATA ) 
        {
            // we got some of the data but I want it all; free this buffer and
            // reset the context handle for the API

            NetApiBufferFree( grpMemberInfo );
            resumeHandle = NULL;
        }
    } while ( status == NERR_BufTooSmall || status == ERROR_MORE_DATA );

    if ( status == NERR_Success ) 
    {
        // loop through the members of the admin group, comparing the supplied
        // Sid to that of the group members' Sids

        for ( count = 0, pInfo = grpMemberInfo; count < totalEntries; ++count, ++pInfo ) 
        {
            if ( EqualSid( AccountSid, pInfo->lgrmi0_sid )) 
            {
                foundEntry = TRUE;
                break;
            }
        }

        NetApiBufferFree( grpMemberInfo );
    }

    return foundEntry;
}

//
//
//

BOOL
LookupAliasFromRid(
    LPWSTR TargetComputer,
    DWORD Rid,
    LPWSTR Name,
    PDWORD cchName
    )
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_NAME_USE snu;
    PSID pSid;
    WCHAR DomainName[DNLEN+1];
    DWORD cchDomainName = DNLEN;
    BOOL bSuccess = FALSE;

    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //

    if(AllocateAndInitializeSid(&sia,
                                2,
                                SECURITY_BUILTIN_DOMAIN_RID,
                                Rid,
                                0, 0, 0, 0, 0, 0,
                                &pSid)) {

        bSuccess = LookupAccountSidW(TargetComputer,
                                     pSid,
                                     Name,
                                     cchName,
                                     DomainName,
                                     &cchDomainName,
                                     &snu);

        FreeSid(pSid);
    }

    return bSuccess;
} // LookupAliasFromRid

DWORD
ValidateDomainAccount(
    IN CString Machine,
    IN CString UserName,
    IN CString Domain,
    OUT PSID * AccountSid
    )

/*++

Routine Description:

    For the given credentials, look up the account SID for the specified
    domain. As a side effect, the Sid is stored in theData->m_Sid.

Arguments:

    pointers to strings that describe the user name, domain name, and password

    AccountSid - address of pointer that receives the SID for this user

Return Value:

    TRUE if everything validated ok.

--*/

{
    DWORD dwStatus = ERROR_SUCCESS;
    DWORD dwSidSize = 128;
    DWORD dwDomainNameSize = 128;
    LPWSTR pwszDomainName;
    SID_NAME_USE SidType;
    CString domainAccount;
    PSID accountSid;

    domainAccount = Domain + _T("\\") + UserName;

    do {
        // Attempt to allocate a buffer for the SID. Note that apparently in the
        // absence of any error theData->m_Sid is freed only when theData goes
        // out of scope.

        accountSid = LocalAlloc( LMEM_FIXED, dwSidSize );
        pwszDomainName = (LPWSTR) LocalAlloc( LMEM_FIXED, dwDomainNameSize * sizeof(WCHAR) );

        // Was space allocated for the SID and domain name successfully?

        if ( accountSid == NULL || pwszDomainName == NULL ) {
            if ( accountSid != NULL ) {
                LocalFree( accountSid );
            }

            if ( pwszDomainName != NULL ) {
                LocalFree( pwszDomainName );
            }

            //FATALERR( IDS_ERR_NOT_ENOUGH_MEMORY, GetLastError() );    // no return
            break;
        }

        // Attempt to Retrieve the SID and domain name. If LookupAccountName failes
        // because of insufficient buffer size(s) dwSidSize and dwDomainNameSize
        // will be set correctly for the next attempt.

        if ( !LookupAccountName( Machine,
                                 domainAccount,
                                 accountSid,
                                 &dwSidSize,
                                 pwszDomainName,
                                 &dwDomainNameSize,
                                 &SidType ))
        {
            // free the Sid buffer and find out why we failed
            LocalFree( accountSid );

            dwStatus = GetLastError();
        }

        // domain name isn't needed at any time
        LocalFree( pwszDomainName );
        pwszDomainName = NULL;

    } while ( dwStatus == ERROR_INSUFFICIENT_BUFFER );

    if ( dwStatus == ERROR_SUCCESS ) {
        *AccountSid = accountSid;
    }

    return dwStatus;
} // ValidateDomainAccount

NTSTATUS
ValidatePassword(
    IN LPCWSTR UserName,
    IN LPCWSTR Domain,
    IN LPCWSTR Password
    )
/*++

Routine Description:

    Uses SSPI to validate the specified password

Arguments:

    UserName - Supplies the user name

    Domain - Supplies the user's domain

    Password - Supplies the password

Return Value:

    TRUE if the password is valid.

    FALSE otherwise.

--*/

{
    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle ClientCredHandle;
    CredHandle ServerCredHandle;
    BOOL ClientCredAllocated = FALSE;
    BOOL ServerCredAllocated = FALSE;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;

    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;

    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecBufferDesc *pChallengeDesc      = NULL;
    CtxtHandle *  pClientContextHandle = NULL;
    CtxtHandle *  pServerContextHandle = NULL;

    AuthIdentity.User = (LPWSTR)UserName;
    AuthIdentity.UserLength = lstrlenW(UserName);
    AuthIdentity.Domain = (LPWSTR)Domain;
    AuthIdentity.DomainLength = lstrlenW(Domain);
    AuthIdentity.Password = (LPWSTR)Password;
    AuthIdentity.PasswordLength = lstrlenW(Password);
    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;

    //
    // Get info about the security packages.
    //

    SecStatus = QuerySecurityPackageInfo( DEFAULT_SECURITY_PKG, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }

    //
    // Acquire a credential handle for the server side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,
                    DEFAULT_SECURITY_PKG,
                    SECPKG_CRED_INBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ServerCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ServerCredAllocated = TRUE;

    //
    // Acquire a credential handle for the client side
    //

    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    DEFAULT_SECURITY_PKG,
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    &AuthIdentity,
                    NULL,
                    NULL,
                    &ClientCredHandle,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) {
        goto error_exit;
    }
    ClientCredAllocated = TRUE;

    NegotiateBuffer.pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken ); // [CHKCHK] check or allocate this earlier //
    if ( NegotiateBuffer.pvBuffer == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto error_exit;
    }

    ChallengeBuffer.pvBuffer = LocalAlloc( 0, PackageInfo->cbMaxToken ); // [CHKCHK]
    if ( ChallengeBuffer.pvBuffer == NULL ) {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto error_exit;
    }

    do {

        //
        // Get the NegotiateMessage (ClientSide)
        //

        NegotiateDesc.ulVersion = 0;
        NegotiateDesc.cBuffers = 1;
        NegotiateDesc.pBuffers = &NegotiateBuffer;

        NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
        NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;

        ClientFlags = 0; // ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT; // [CHKCHK] 0

        InitStatus = InitializeSecurityContext(
                         &ClientCredHandle,
                         pClientContextHandle, // (NULL on the first pass, partially formed ctx on the next)
                         NULL,                 // [CHKCHK] szTargetName
                         ClientFlags,
                         0,                    // Reserved 1
                         SECURITY_NATIVE_DREP,
                         pChallengeDesc,       // (NULL on the first pass)
                         0,                    // Reserved 2
                         &ClientContextHandle,
                         &NegotiateDesc,
                         &ContextAttributes,
                         &Lifetime );

        // BUGBUG - the following call to NT_SUCCESS should be replaced with something.

        if ( !NT_SUCCESS(InitStatus) ) {
            SecStatus = InitStatus;
            goto error_exit;
        }

        // ValidateBuffer( &NegotiateDesc ) // [CHKCHK]

        pClientContextHandle = &ClientContextHandle;

        //
        // Get the ChallengeMessage (ServerSide)
        //

        NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
        ChallengeDesc.ulVersion = 0;
        ChallengeDesc.cBuffers = 1;
        ChallengeDesc.pBuffers = &ChallengeBuffer;

        ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
        ChallengeBuffer.BufferType = SECBUFFER_TOKEN;

        ServerFlags = ASC_REQ_ALLOW_NON_USER_LOGONS; // ASC_REQ_EXTENDED_ERROR; [CHKCHK]

        AcceptStatus = AcceptSecurityContext(
                        &ServerCredHandle,
                        pServerContextHandle,   // (NULL on the first pass)
                        &NegotiateDesc,
                        ServerFlags,
                        SECURITY_NATIVE_DREP,
                        &ServerContextHandle,
                        &ChallengeDesc,
                        &ContextAttributes,
                        &Lifetime );


        // BUGBUG - the following call to NT_SUCCESS should be replaced with something.

        if ( !NT_SUCCESS(AcceptStatus) ) {
            SecStatus = AcceptStatus;
            goto error_exit;
        }

        // ValidateBuffer( &NegotiateDesc ) // [CHKCHK]

        pChallengeDesc = &ChallengeDesc;
        pServerContextHandle = &ServerContextHandle;


    } while ( AcceptStatus == SEC_I_CONTINUE_NEEDED ); // || InitStatus == SEC_I_CONTINUE_NEEDED );

error_exit:
    if (ServerCredAllocated) {
        FreeCredentialsHandle( &ServerCredHandle );
    }
    if (ClientCredAllocated) {
        FreeCredentialsHandle( &ClientCredHandle );
    }

    //
    // Final Cleanup
    //

    if ( NegotiateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( NegotiateBuffer.pvBuffer );
    }

    if ( ChallengeBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( ChallengeBuffer.pvBuffer );
    }

    if ( AuthenticateBuffer.pvBuffer != NULL ) {
        (VOID) LocalFree( AuthenticateBuffer.pvBuffer );
    }
    return(SecStatus);
} // ValidatePassword


DEBUG_DECLARE_INSTANCE_COUNTER(CSpdInfo);

CSpdInfo::CSpdInfo() 
    : m_cRef(1),
      m_Init(0),
      m_Active(0),
      m_session_init(false),
      m_dwSortIndex(IDS_COL_LOGDATA_TIME),
      m_dwSortOption(SORT_ASCENDING),
      m_nNumRecords(WZCDB_DEFAULT_NUM_RECS),
      m_bEliminateDuplicates(FALSE)

{
    HRESULT hr = S_OK;
    HANDLE hSession = NULL;

    /* 
       Either we opened a session successfully or we found out that logging
       is disabled. If logging is disabled then we check every time EnumLogData
       is called to see if we can access the database.
    */

    DEBUG_INCREMENT_INSTANCE_COUNTER(CSpdInfo);
}


CSpdInfo::~CSpdInfo()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSpdInfo);
    CSingleLock cLock(&m_csData);
    
    cLock.Lock();
    
    //Convert the data to our internal data structure
    //FreeItemsAndEmptyArray(m_arrayFWFilters);
    FreeItemsAndEmptyArray(m_arrayLogData);
    
    cLock.Unlock();   
}


// Although this object is not a COM Interface, we want to be able to
// take advantage of recounting, so we have basic addref/release/QI support
IMPLEMENT_ADDREF_RELEASE(CSpdInfo)

IMPLEMENT_SIMPLE_QUERYINTERFACE(CSpdInfo, ISpdInfo)

    
void
CSpdInfo::FreeItemsAndEmptyArray(
    CLogDataInfoArray& array
    )
{
    for (int i = 0; i < array.GetSize(); i++)
    {
        delete array.GetAt(i);
    }
    array.RemoveAll();
}


HRESULT
CSpdInfo::SetComputerName(
    LPTSTR pszName
    )
{
    m_stMachineName = pszName;
    return S_OK;
}


HRESULT
CSpdInfo::GetComputerName(
    CString * pstName
    )
{
    Assert(pstName);
    
    if (NULL == pstName)
        return E_INVALIDARG;
    
    
    *pstName = m_stMachineName;
    
    return S_OK;   
}


HRESULT
CSpdInfo::GetSession(
    PHANDLE phsession
    )
{
    Assert(session);
    
    if (NULL == phsession)
        return E_INVALIDARG;
    
    *phsession = m_session;
    
    return S_OK;   
}


HRESULT
CSpdInfo::SetSession(
    HANDLE hsession
    )
{
    m_csData.Lock();
    
    m_session = hsession;
    m_session_init = true;
    m_bFromFirst = TRUE;

    m_csData.Unlock();
    return S_OK;
}


HRESULT
CSpdInfo::ResetSession()
/*++
    CSpdInfo::ResetSession:
    Used to reset the session when the logging is turned off so that we dont 
    use a bad session.

    Arguments:
    None

    Returns:
    Always returns S_OK
--*/    
{
    if (m_session != NULL)
        CloseWZCDbLogSession(m_session);

    m_session = NULL;
    m_session_init = false;

    return S_OK;
}


DWORD
CSpdInfo::EliminateDuplicates(
    CLogDataInfoArray *pArray
    )
/*++
    CSpdInfo::EliminateDuplicates: Removes duplicate records from the given
    array. 

    If the database moves past the end of the table, it cannot move
    to get new records on the next refresh cyle, hence it always remains
    on the last record. So if our cache size is the same as the database
    size, then we must delete the first record as the new enumeration
    would have resulted in a duplicate record.

    We also know that in only the first element is a duplicate

    Arguments:
    [in/out] pArray - Pointer to array containing elements. On exit contains
    all non duplicate elements

    Returns:
    ERROR_SUCCESS on success
--*/    
{
    int i = 0;
    int j = 0;
    int nSize = 0;
    DWORD dwErr = ERROR_SUCCESS;
    CLogDataInfo *pLog = NULL;

    if (NULL == pArray)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto done;
    }

    nSize = (int) pArray->GetSize();

    if (0 == nSize) 
        goto done;

    //Merely delete the first element

    pLog = pArray->GetAt(0);
    delete pLog;
    pArray->RemoveAt(0);

 done:
    return dwErr;
}


void
CSpdInfo::StartFromFirstRecord(
    BOOL bFromFirst)
/*++
  
Routine Description:

    CSpdInfo::StartFromFirstRecord:
    Sets the read location to start from the first or from the end of the
    table
    
Arguments:

    IN bFromFirst - TRUE if the read should be done from the beginning of the
                    database, FALSE otherwise
                    
Returns:

    Nothing.
    
--*/
{
    m_csData.Lock();
    
    m_bFromFirst = bFromFirst;

    m_csData.Unlock();
}


HRESULT
CSpdInfo::InternalEnumLogData(
    CLogDataInfoArray  *pArray,
    DWORD              dwPreferredNum,
    BOOL               bFromFirst
    )
/*++

Routine Description:

    CSpdInfo::InternalEnumLogData - Enumerates data from the service and adds
                                    to pArray.
                                    
Arguments:
    [out] pArray - New values are appended if any
    [in]  dwPreferredNum - Holds the number of records requested

Returns:

    HRESULT_FROM_WIN32() of the following codes
    ERROR_SUCCESS on success
    ERROR_NO_MORE_ITEMS on no more items
    ERROR_SERVICE_DISABLED otherwise
    
--*/    
{
    HRESULT             hr            = hrOK;
    DWORD               dwErr         = ERROR_SUCCESS;
    HANDLE              hsession      = NULL;
    DWORD               dwCrtNum      = 0;
    PWZC_DB_RECORD      pDbRecord     = NULL;
    PWZC_DB_RECORD      pWZCRecords   = NULL;
    DWORD               dwNumRecords  = 0;
    CLogDataInfo        *pLogDataInfo = NULL;        
    int                 i             = 0;
    
    ASSERT(pArray);

    FreeItemsAndEmptyArray(*pArray);
    GetSession(&hsession);

    while (ERROR_SUCCESS == dwErr)
    {
        dwCrtNum = (DWORD)pArray->GetSize();
        
        dwErr = EnumWZCDbLogRecords(hsession, 
                                    NULL, 
                                    &bFromFirst, 
                                    dwPreferredNum,
                                    &pWZCRecords, 
                                    &dwNumRecords, 
                                    NULL);

        bFromFirst = FALSE;
        pArray->SetSize(dwCrtNum + dwNumRecords);

        for (i = 0, pDbRecord = pWZCRecords;
             i < (int)dwNumRecords;
             i++, pDbRecord++)
        {
            pLogDataInfo = new CLogDataInfo;
            if (NULL == pLogDataInfo)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }
            *pLogDataInfo = *pDbRecord;
            (*pArray)[dwCrtNum + i] = pLogDataInfo;

            RpcFree(pDbRecord->message.pData);
            RpcFree(pDbRecord->context.pData);
            RpcFree(pDbRecord->ssid.pData);
            RpcFree(pDbRecord->remotemac.pData);
            RpcFree(pDbRecord->localmac.pData);
        }

        RpcFree(pWZCRecords);        
    } 
    
    switch (dwErr)
    {
    case ERROR_SUCCESS:
    case ERROR_NO_MORE_ITEMS:
        hr = HRESULT_FROM_WIN32(ERROR_SUCCESS);
        break;

    default:
        hr = HRESULT_FROM_WIN32(dwErr);
        break;
    }
    
    COM_PROTECT_ERROR_LABEL;
    return hr;
}


HRESULT 
CSpdInfo::EnumLogData(
    PDWORD pdwNew, 
    PDWORD pdwTotal)
/*++

Routine Description:

    CSpdInfo::EnumLogData:
    Enumerates logs differentially

Arguments:

Returns:

--*/
{
    int                 i                     = 0;
    int                 nStoreSize            = 0;
    int                 nTempStoreSize        = 0;
    int                 nNumToDel             = 0;
    HRESULT             hr                    = hrOK;
    DWORD               dwErr                 = ERROR_SUCCESS;
    DWORD               dwCurrentIndexType    = 0;
    DWORD               dwCurrentSortOption   = 0;
    DWORD               dwNumRequest          = MAX_NUM_RECORDS; 
    DWORD               dwOffset              = 0;
    DWORD               dwStoreSize           = 0;
    HANDLE              hSession              = NULL;
    CLogDataInfo        *pLogInfo             = NULL;
    CLogDataInfoArray   arrayTemp;
    BOOL                bFromFirst            = FALSE;
    
    if (false == m_session_init) 
    {
        dwErr = OpenWZCDbLogSession(
                    NULL/*(LPTSTR)(LPCTSTR)m_stMachineName*/,
                    0,
                    &hSession);

        if (dwErr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            goto Error;
        }

        SetSession(hSession);
    }

    ASSERT(m_session_init == true);

    //
    // If our session was created successfully, we should go ahead and pick up
    // data from the database. If not we should return. 
    //

    dwStoreSize = GetLogDataCount();

    if (dwStoreSize == 0)
        bFromFirst = TRUE;
        
    CORg(InternalEnumLogData(&arrayTemp, dwNumRequest, bFromFirst));

    m_csData.Lock();
   
    nTempStoreSize = (int) arrayTemp.GetSize();

    if (pdwNew != NULL)
        *pdwNew = nTempStoreSize;

    //
    // Add new items to our cache. If we have read records our earlier, remove
    // the first element from the new array, as the database would return the
    // last record once again.
    //

    if (nTempStoreSize > 0)
    {        
        if (bFromFirst == FALSE)
            EliminateDuplicates(&arrayTemp);
        
        m_arrayLogData.Append(arrayTemp);
    }

    //
    // Delete the old items if we are at the window
    //

    nStoreSize = (int) m_arrayLogData.GetSize();

    if (nStoreSize >= m_nNumRecords) 
    {
        nNumToDel = nStoreSize - m_nNumRecords;

        //
        // The oldest elements are at zero
        //

        for (i=0; i < nNumToDel; i++)
            delete m_arrayLogData.GetAt(i);
        m_arrayLogData.RemoveAt(0, nNumToDel);

        ASSERT(m_nNumRecords == m_arrayLogData.GetSize());
        nStoreSize = m_nNumRecords;
    }

    if (pdwTotal != NULL)
        *pdwTotal = nStoreSize;

    m_IndexMgrLogData.Reset();
    for (i = 0; i < nStoreSize; i++)
    {
        pLogInfo = m_arrayLogData.GetAt(i);
        m_IndexMgrLogData.AddItem(pLogInfo);
    }

    //
    // Re-sort based on the IndexType and Sort options    
    //

    SortLogData(m_dwSortIndex, m_dwSortOption);

    m_csData.Unlock();

    COM_PROTECT_ERROR_LABEL;
    if (FAILED(hr))
    {
        switch (hr)
        {
        case HRESULT_FROM_WIN32(ERROR_REMOTE_SESSION_LIMIT_EXCEEDED):
            //
            // Pop up a message...
            //

            AfxMessageBox(
                IDS_ERR_SPD_UNAVAILABLE, 
                MB_OK | MB_ICONEXCLAMATION, 
                0);
        case HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED):
            //
            // Reset the session if initialised
            //

            if (m_session_init == true)
                ResetSession();

            //
            // Flush the logs
            //
            FlushLogs();
            hr = S_OK;
            break;

        default:
            //
            // Unexpected error, this should never happen.
            //
            
            ASSERT(FALSE);
            hr = S_FALSE;
            break;
        }        
    }

    return hr;
}



HRESULT
CSpdInfo::FlushLogs()
/*++
    CSpdInfo::FlushLogs - Flushes logs in the data base and resets the index
    manager
--*/    
{
    HRESULT hr = S_OK;
    
    FreeItemsAndEmptyArray(m_arrayLogData);
    m_IndexMgrLogData.Reset();

    return hr;
}

DWORD
CSpdInfo::GetLogDataCount()
{
    DWORD       dwSize = 0;
    CSingleLock cLock(&m_csData);

    cLock.Lock();

    dwSize = (DWORD) m_arrayLogData.GetSize();

    cLock.Unlock();
    return dwSize;    
}


HRESULT
CSpdInfo::InternalGetSpecificLog(
    CLogDataInfo *pLogDataInfo
    )
/*++
    CSpdInfo::InternalGetSpecificLog: Internal function to retrieve all fields
    of requested record

    Arguments:
    [in/out] pLogDataInfo - On entry has the partial record, 
    On exit has the complete record if successful

    Returns:
    S_OK on Success
--*/    
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwNumRecords = 0;
    WZC_DB_RECORD wzcTemplate;
    PWZC_DB_RECORD pwzcRecordList = NULL;
    
    if (false == m_session_init)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
        goto Error;
    }

    memset(&wzcTemplate, 0, sizeof(WZC_DB_RECORD));

    //Fill up template
    dwErr = pLogDataInfo->ConvertToDbRecord(&wzcTemplate);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto Error;
    }

    dwErr = GetSpecificLogRecord(m_session, 
                                 &wzcTemplate, 
                                 &pwzcRecordList,
                                 &dwNumRecords,
                                 NULL);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto FreeOnError;
    }

    if (dwNumRecords != 1)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto FreeOnError;
    }

    //Fill up return value
    *pLogDataInfo = pwzcRecordList[0];

 FreeOnError:
    DeallocateDbRecord(&wzcTemplate);

    COM_PROTECT_ERROR_LABEL;
    return hr;
}


HRESULT
CSpdInfo::GetSpecificLog(
    int iIndex,
    CLogDataInfo *pLogData
    )
/*++
    CSpdInfo::GetSpecificLog: Gets a specific log from the database with all
    information
  
    Arguments:
    [in] iIndex - Index to the record to obtain
    [out] pLogData - Storage for the specific record, contains the complete 
    record on success

    Returns:
    S_OK on success
--*/    
{
    HRESULT hr = S_OK;
    int nSize = 0; 
    CLogDataInfo *pLogDataInfo = NULL;

    m_csData.Lock();

    nSize = (DWORD)m_arrayLogData.GetSize();
    if ((iIndex < 0) || (iIndex >= nSize))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Error;
    }

    pLogDataInfo = (CLogDataInfo*)m_IndexMgrLogData.GetItemData(iIndex);
    
    if (NULL == pLogDataInfo)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Error;
    }

    //Get the complete record
    *pLogData = *pLogDataInfo;
    CORg(InternalGetSpecificLog(pLogData));

    COM_PROTECT_ERROR_LABEL;
    m_csData.Unlock();

    return hr;
}

HRESULT
CSpdInfo::GetLogDataInfo(
    int iIndex,
    CLogDataInfo * pLogData
    )
{
    HRESULT hr = S_OK;
    int nSize = 0; 
    CLogDataInfo *pLogDataInfo = NULL;

    m_csData.Lock();

    nSize = (DWORD)m_arrayLogData.GetSize();
    if ((iIndex < 0) || (iIndex >= nSize))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        goto Error;
    }

    pLogDataInfo = (CLogDataInfo*)m_IndexMgrLogData.GetItemData(iIndex);
    
    if (NULL == pLogDataInfo)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);        
        goto Error;
    }

    //Get the partial record
    *pLogData = *pLogDataInfo;

    COM_PROTECT_ERROR_LABEL;
    m_csData.Unlock();

    return hr;
}


HRESULT
CSpdInfo::SortLogData(
    DWORD dwIndexType,
    DWORD dwSortOptions
    )
{
    return m_IndexMgrLogData.SortLogData(dwIndexType, dwSortOptions);
}


HRESULT CSpdInfo::SortLogData()
/*++
    CSpdInfo::SortLogData
    Description: For use externally, locks and sorts with last set sort
    options
    
    Parameters:
    
    Returns:
--*/    
{
    HRESULT hr = S_OK;

    m_csData.Lock();

    hr = SortLogData(m_dwSortIndex, m_dwSortOption);

    m_csData.Unlock();

    return hr;
}


HRESULT
CSpdInfo::SetSortOptions(
    DWORD dwColID,
    BOOL bAscending
    )
/*++
    CSpdInfo::SetSortOptions
    Sets the sort options to be used whenever data is enumerated
    
--*/    
{
    HRESULT hr = S_OK;
    DWORD dwSortOption = SORT_ASCENDING;

    if( (IDS_COL_LOGDATA_TIME != dwColID) &&
        (IDS_COL_LOGDATA_COMP_ID != dwColID) &&
        (IDS_COL_LOGDATA_CAT != dwColID) &&
        (IDS_COL_LOGDATA_LOCAL_MAC_ADDR != dwColID) &&
        (IDS_COL_LOGDATA_REMOTE_MAC_ADDR != dwColID) &&
        (IDS_COL_LOGDATA_SSID != dwColID) &&
        (IDS_COL_LOGDATA_MSG != dwColID) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto done;
    }

    if (FALSE == bAscending)
        dwSortOption = SORT_DESCENDING;

    //lock csData so that EnumLogRecords sorts correctly on the next sort
    m_csData.Lock();
  
    m_dwSortIndex = dwColID;
    m_dwSortOption = dwSortOption;
    
    m_csData.Unlock();

 done:
    return hr;
}


HRESULT
CSpdInfo::FindIndex(
    int *pnIndex,
    CLogDataInfo *pLogDataInfo
    )
/*++
    CSpdInfo::FindIndex
    Finds the virtual index of the item corresponding to the input LogDataInfo

    Parameters:
    [out]  pnIndex - A pointer to place the result index
    [in]   pLogDataInfo - A pointer to the LogDataInfo to be found
    
    Returns:
    S_OK on success 
    *pnIndex will contain a valid index if found, else will have -1
  
--*/    
{
    int nSize = 0;
    int i = 0;
    HRESULT hr = S_OK;
    BOOL bFound = FALSE;
    CLogDataInfo *pLogDataLHS = NULL;

    if ( (NULL == pnIndex) || (NULL == pLogDataInfo) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Error;
    }

    *pnIndex = -1;

    m_csData.Lock();

    nSize = (int) m_arrayLogData.GetSize();
    while ( (i < nSize) && (FALSE == bFound) )
    {
        pLogDataLHS = (CLogDataInfo*) m_IndexMgrLogData.GetItemData(i);
        if (*pLogDataLHS == *pLogDataInfo)
        {
            *pnIndex = i;
            bFound = TRUE;
        }
        else
            i++;
    }
    
    m_csData.Unlock();

    COM_PROTECT_ERROR_LABEL;
    return hr;
}


HRESULT
CSpdInfo::GetLastIndex(
    int *pnIndex
    )
/*++
    CSpdInfo::GetLastIndex
    Returns the virtual index for the last item in the list

    Returns:
    S_OK on success
--*/    
{
    int nLastIndex = 0;
    HRESULT hr = S_OK;

    if (NULL == pnIndex)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Error;
    }

    m_csData.Lock();

    nLastIndex = (int) m_arrayLogData.GetSize();
    nLastIndex--;
    *pnIndex = nLastIndex;

    m_csData.Unlock();

    COM_PROTECT_ERROR_LABEL;
    return hr;
}


STDMETHODIMP
CSpdInfo::Destroy()
{
    //$REVIEW this routine get called when doing auto-refresh
    //We don't need to clean up anything at this time.
    //Each array (Filter, SA, policy...) will get cleaned up when calling the
    //corresponding enum function.
    
    HANDLE hSession;
    
    GetSession(&hSession);
    
    if (m_session_init == true) 
    {
        CloseWZCDbLogSession(hSession);
        m_session_init = false;
        m_bFromFirst = TRUE;
    }
    
    return S_OK;
}



DWORD
CSpdInfo::GetInitInfo()
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    return m_Init;
}


void
CSpdInfo::SetInitInfo(
    DWORD dwInitInfo
    )
{
    CSingleLock cLock(&m_csData);
    
    cLock.Lock();
        
    m_Init=dwInitInfo;
}

DWORD
CSpdInfo::GetActiveInfo()
{
    CSingleLock cLock(&m_csData);
    
    cLock.Lock();
        
    return m_Active;
}


void
CSpdInfo::SetActiveInfo(
    DWORD dwActiveInfo
    )
{
    CSingleLock cLock(&m_csData);
    cLock.Lock();
        
    m_Active=dwActiveInfo;
}


/*!--------------------------------------------------------------------------
    CreateSpdInfo
        Helper to create the SpdInfo object.
 ---------------------------------------------------------------------------*/
HRESULT 
CreateSpdInfo(
    ISpdInfo ** ppSpdInfo
    )
{
    AFX_MANAGE_STATE(AfxGetModuleState());
    
    SPISpdInfo     spSpdInfo;
    ISpdInfo *     pSpdInfo = NULL;
    HRESULT         hr = hrOK;

    COM_PROTECT_TRY
    {
        pSpdInfo = new CSpdInfo;

        // Do this so that it will get freed on error
        spSpdInfo = pSpdInfo;
	
    
        *ppSpdInfo = spSpdInfo.Transfer();

    }
    COM_PROTECT_CATCH

    return hr;
}


DWORD
DeallocateDbRecord(
    PWZC_DB_RECORD const pwzcRec
    )
/*++
    DeallocateDbRecord - Frees up the internal memory used in a WZC_DB_RECORD
    structure. To be used only when space has been allocated by sources other 
    than RPC. Does not deallocate outer level

    Arguments:
    [in/out]pwzcRec - Holds the record to free. Internal mem alone is freed and
    contents freed are annulled.

    Returns:
    ERROR_SUCCESS on success
--*/    
{
    DWORD dwErr = ERROR_SUCCESS;

    if (NULL != pwzcRec->message.pData)
    {
        delete [] pwzcRec->message.pData;
        pwzcRec->message.pData = NULL;
    }
    
    if (NULL != pwzcRec->localmac.pData)
    {
        delete [] pwzcRec->localmac.pData;
        pwzcRec->localmac.pData = NULL;
    }
    
    if (NULL != pwzcRec->remotemac.pData)
    {
        delete [] pwzcRec->remotemac.pData;
        pwzcRec->remotemac.pData = NULL;
    }
    
    if (NULL != pwzcRec->ssid.pData)
    {
        delete [] pwzcRec->ssid.pData;
        pwzcRec->ssid.pData = NULL;
    }
    
    if (NULL != pwzcRec->context.pData)
    {
        delete [] pwzcRec->context.pData;
        pwzcRec->ssid.pData = NULL;
    }
    
    return dwErr;
}


//
//  FUNCTIONS: MIDL_user_allocate and MIDL_user_free
//
//  PURPOSE: Used by stubs to allocate and free memory
//           in standard RPC calls. Not used when
//           [enable_allocate] is specified in the .acf.
//
//
//  PARAMETERS:
//    See documentations.
//
//  RETURN VALUE:
//    Exceptions on error.  This is not required,
//    you can use -error allocation on the midl.exe
//    command line instead.
//
//
void * __RPC_USER MIDL_user_allocate(size_t size)
{
    return(HeapAlloc(GetProcessHeap(), HEAP_GENERATE_EXCEPTIONS, size));
}

void __RPC_USER MIDL_user_free( void *pointer)
{
    HeapFree(GetProcessHeap(), 0, pointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\spdutil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    spdutil.cpp

    FILE HISTORY:
        
*/
#include "stdafx.h"

#include "spdutil.h"
#include "objplus.h"
#include "ipaddres.h"
#include "spddb.h"
#include "server.h"

extern CHashTable g_HashTable;

const DWORD IPSM_PROTOCOL_TCP = 6;
const DWORD IPSM_PROTOCOL_UDP = 17;

const TCHAR c_szSingleAddressMask[] = _T("255.255.255.255");

const CHAR c_EqualMatchType[] = "=";
const CHAR c_RangeMatchType[] = "IN";

const ProtocolStringMap c_ProtocolStringMap[] = 
{ 
    {0, IDS_PROTOCOL_ANY},
    {1, IDS_PROTOCOL_ICMP},
    {2, IDS_PROTOCOL_IGMP},
    {3, IDS_PROTOCOL_GGP},
    {6, IDS_PROTOCOL_TCP},    
    {8, IDS_PROTOCOL_EGP},    
    {12, IDS_PROTOCOL_PUP},     
    {17, IDS_PROTOCOL_UDP},    
    {20, IDS_PROTOCOL_HMP},    
    {22, IDS_PROTOCOL_XNS_IDP},
    {27, IDS_PROTOCOL_RDP}, 
    {66, IDS_PROTOCOL_RVD}    
};

const int c_nProtocols = DimensionOf(c_ProtocolStringMap);

// The frequency table into which the channel is the index
const ULONG g_ulFreqTable[] = {2412000, 2417000, 2422000, 2427000, 2432000, 
                               2437000, 2442000, 2447000, 2452000, 2457000, 
                               2462000, 2467000, 2472000, 2484000};
                                 
ULONG RevertDwordBytes(DWORD dw)
{
    ULONG ulRet;
    ulRet = dw >> 24;
    ulRet += (dw & 0xFF0000) >> 8;
    ulRet += (dw & 0x00FF00) << 8;
    ulRet += (dw & 0x0000FF) << 24;

    return ulRet;
}

void ProtocolToString
(
    BYTE protocol, 
    CString * pst
)
{
    BOOL fFound = FALSE;
    for (int i = 0; i < DimensionOf(c_ProtocolStringMap); i++)
    {
        if (c_ProtocolStringMap[i].dwProtocol == protocol)
        {
            pst->LoadString(c_ProtocolStringMap[i].nStringID);
            fFound = TRUE;
        }
    }

    if (!fFound)
    {
        pst->Format(IDS_OTHER_PROTO, protocol);
    }
}




void BoolToString
(
        BOOL bl,
        CString * pst
)
{
    if (bl)
        pst->LoadString (IDS_YES);
    else
        pst->LoadString (IDS_NO);
}

void IpToString(ULONG ulIp, CString *pst)
{
    ULONG ul;
    CIpAddress ipAddr;
    ul = RevertDwordBytes(ulIp);
    ipAddr = ul;
    *pst = (CString) ipAddr;
}

void NumToString(DWORD number, CString * pst)
{
    pst->Format(_T("%d"), number);
    return;
}

void FileTimeToString(FILETIME logDataTime, CString *pst)
{      
    SYSTEMTIME	timeFields;
    FileTimeToSystemTime ( (PFILETIME)&logDataTime, &timeFields);
    pst->Format (_T("%2d/%2d/%4d  %02d:%02d:%02d:%03d"),
                 timeFields.wMonth,
                 timeFields.wDay,
                 timeFields.wYear,
                 timeFields.wHour,
                 timeFields.wMinute,
                 timeFields.wSecond,
                 timeFields.wMilliseconds
                 );				 
    return;
}

VOID SSIDToString(NDIS_802_11_SSID Ssid, CString &SsidStr)
{
	LPTSTR pStr = SsidStr.GetBuffer(Ssid.SsidLength + 1);

	MultiByteToWideChar(	CP_ACP, 
							MB_PRECOMPOSED,
							(LPCSTR)Ssid.Ssid,
							(int)Ssid.SsidLength,
							pStr,
							(int)Ssid.SsidLength);
	pStr[Ssid.SsidLength] = _T('\0');
	SsidStr.ReleaseBuffer();
}

VOID GuidToString (LPWSTR guid, CString &guidStr) 
{
	guidStr = guid;
}

VOID MacToString (NDIS_802_11_MAC_ADDRESS macAddress, CString &macAddrStr)
{
	LPTSTR pStr = macAddrStr.GetBuffer(18);
	
	UINT i;

	for (i = 0; i < 6; i++)
	{
		wsprintf(pStr, _T("%02X-"), macAddress[i]);
		pStr += 3;
	}
	*(pStr-1) = _T('\0');
}

DWORD CategoryToString(DWORD dwCategory, CString &csCategory)
{
    BOOL bLoaded = FALSE;
    DWORD dwErr = ERROR_SUCCESS;

    switch (dwCategory)
    {
    case DBLOG_CATEG_INFO:
        bLoaded = csCategory.LoadString(IDS_LOGDATA_TYPE_INFORMATION);
        Assert(TRUE == bLoaded);
        break;
		
    case DBLOG_CATEG_WARN:
        bLoaded = csCategory.LoadString(IDS_LOGDATA_TYPE_WARNING);
        Assert(TRUE == bLoaded);
        break;
        
    case DBLOG_CATEG_ERR:
        bLoaded = csCategory.LoadString(IDS_LOGDATA_TYPE_ERROR);
        Assert(TRUE == bLoaded);
        break;
        
	case DBLOG_CATEG_PACKET:
	    bLoaded = csCategory.LoadString(IDS_LOGDATA_TYPE_PACKET);
		Assert(TRUE == bLoaded);
		break;
		
    default:
        bLoaded = csCategory.LoadString(IDS_LOGDATA_TYPE_UNKNOWN);
        Assert(TRUE == bLoaded);
        dwErr = ERROR_BAD_FORMAT;
        break;
    }
    
    return dwErr;
}

DWORD PrivacyToString(ULONG ulPrivacy, CString *pcs)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL bLoaded = FALSE;

    switch(ulPrivacy)
    {
    case 0:
        bLoaded = pcs->LoadString(IDS_APDATA_PRIVACY_DISABLED);
        Assert(TRUE == bLoaded);
        break;

    case 1:
        bLoaded = pcs->LoadString(IDS_APDATA_PRIVACY_ENABLED);
        Assert(TRUE == bLoaded);
        break;

    default:
        bLoaded = pcs->LoadString(IDS_APDATA_PRIVACY_UNKNOWN);
        Assert(TRUE == bLoaded);
        dwErr = ERROR_BAD_FORMAT;
        break;
    }

    return dwErr;
}

DWORD InfraToString(NDIS_802_11_NETWORK_INFRASTRUCTURE InfraMode, CString *pcs)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL bLoaded = FALSE;

    switch(InfraMode)
    {
    case Ndis802_11IBSS:
        bLoaded = pcs->LoadString(IDS_APDATA_INFRA_PEER);
        Assert(TRUE == bLoaded);
        break;

    case Ndis802_11Infrastructure:
        bLoaded = pcs->LoadString(IDS_APDATA_INFRA_INFRA);
        Assert(TRUE == bLoaded);
        break;

    default:
        bLoaded = pcs->LoadString(IDS_APDATA_INFRA_UNKNOWN);
        Assert(TRUE == bLoaded);
        dwErr = ERROR_BAD_FORMAT;
        break;
    }

    return dwErr;
}

DWORD RateToString(NDIS_802_11_RATES Rates, CString *pcs)
{
    int i = 0;
    UCHAR ucMask = 0x7F;
    float fMul = 0.5;
    float fVal = 0.0;
    DWORD dwErr = ERROR_SUCCESS;
    CString csTemp;

    if (0 == Rates[i])
        goto done;

    fVal = fMul * (float)(Rates[i] & ucMask);
    csTemp.Format(_T("%.2f"), fVal);
    (*pcs) += csTemp;
    i++;
    
    while (Rates[i] != 0)
    {
        (*pcs) += _T(", ");
        fVal = fMul * (float)(Rates[i] & ucMask);
        csTemp.Format(_T("%.2f"), fVal);
        (*pcs) += csTemp;
        i++;
    }

 done:
    return dwErr;
}

DWORD ChannelToString(NDIS_802_11_CONFIGURATION *pConfig, CString *pcs)
{
    DWORD dwErr = ERROR_SUCCESS;
    int nChannel = 0;

    while ( (nChannel < ARRAYLEN(g_ulFreqTable)) && 
            (g_ulFreqTable[nChannel] != pConfig->DSConfig) )
        nChannel++;

    //channels number from 1 instead of 0
    nChannel++;

    if (nChannel <= ARRAYLEN(g_ulFreqTable))
        pcs->Format(_T("%lu [%d]"), pConfig->DSConfig, nChannel);
    else
        pcs->Format(_T("%ls [?]"), pConfig->DSConfig);

    return dwErr;
}

DWORD ComponentIDToString(DWORD dwCompID, CString &csComponent)
{
    BOOL bLoaded = FALSE;
    DWORD dwErr = ERROR_SUCCESS;

    switch (dwCompID)
    {
        case DBLOG_COMPID_WZCSVC:
            bLoaded = csComponent.LoadString(IDS_LOGDATA_SOURCE_WZCSVC);
            Assert(TRUE == bLoaded);
            break;
            
        case DBLOG_COMPID_EAPOL:
            bLoaded = csComponent.LoadString(IDS_LOGDATA_SOURCE_EAPOL);
            Assert(TRUE == bLoaded);
            break;

        default:
            bLoaded = csComponent.LoadString(IDS_LOGDATA_SOURCE_UNKNOWN);
            Assert(TRUE == bLoaded);
            dwErr = ERROR_BAD_FORMAT;
            break;
    }

    return dwErr;
}

DWORD CopyAndStripNULL(LPTSTR lptstrDest, LPTSTR lptstrSrc, DWORD dwLen)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (0 == dwLen)
    {
        lptstrDest[dwLen]=_T('\0');    
        goto exit;
    }
    
    //Length sent is length of string in bytes + two for NULL terminator
    dwLen /= sizeof(TCHAR);
    dwLen--;
    lptstrDest[dwLen]=_T('\0');
    while (0 != dwLen--)
    {
        if (_T('\0') != lptstrSrc[dwLen])
            lptstrDest[dwLen] = lptstrSrc[dwLen];
        else
            lptstrDest[dwLen] = _T(' ');

    }

exit:
    return dwErr;
}

BOOL operator==(const FILETIME& ftLHS, const FILETIME& ftRHS)
{
    BOOL bEqual = FALSE;
    const ULONGLONG ullLHS = *(const UNALIGNED ULONGLONG * UNALIGNED) &ftLHS;
    const ULONGLONG ullRHS = *(const UNALIGNED ULONGLONG * UNALIGNED) &ftRHS;
    LONGLONG llDiff = 0;

    llDiff = ullRHS - ullLHS;

    if (0 == llDiff)
        bEqual = TRUE;

    return bEqual;
}

BOOL operator!=(const FILETIME& ftLHS, const FILETIME& ftRHS)
{
    BOOL bNotEqual = FALSE;
    const ULONGLONG ullLHS = *(const UNALIGNED ULONGLONG * UNALIGNED) &ftLHS;
    const ULONGLONG ullRHS = *(const UNALIGNED ULONGLONG * UNALIGNED) &ftRHS;
    LONGLONG llDiff = 0;

    llDiff = ullRHS - ullLHS;

    if (0 != llDiff)
        bNotEqual = TRUE;

    return bNotEqual;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\spdutil.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    spdutil.h

    FILE HISTORY:
        
*/

#ifndef _HEADER_SPDUTILS_H
#define _HEADER_SPDUTILS_H



struct ProtocolStringMap
{
	DWORD dwProtocol;
	UINT nStringID;
};

extern const DWORD IPSM_PROTOCOL_TCP;
extern const DWORD IPSM_PROTOCOL_UDP;

extern const ProtocolStringMap c_ProtocolStringMap[];
extern const int c_nProtocols;

extern const TCHAR c_szSingleAddressMask[];

void IpToString(
	ULONG ulIp, 
	CString *pst
	);

void BoolToString(
	BOOL bl, 
	CString * pst
	);

void ProtocolToString(
	BYTE protocol, 
	CString * pst
	);
/*
void DirectionToString
(
	DWORD dwDir,
	CString * pst
);
*/

void NumToString
(
    DWORD number, 
    CString * pst
);

void FileTimeToString
(
    FILETIME logDataTime, 
    CString * pst
);

VOID SSIDToString(NDIS_802_11_SSID Ssid, CString &SsidStr);

VOID GuidToString (LPWSTR guid, CString &guidStr) ;

VOID MacToString (NDIS_802_11_MAC_ADDRESS macAddress, CString &macAddrStr);

DWORD CategoryToString(DWORD dwCategory, CString &csCategory);

DWORD ComponentIDToString(DWORD dwCompID, CString &csComponent);

DWORD CopyAndStripNULL(LPTSTR lptstrDest, LPTSTR lptstrSrc, DWORD dwLen);

DWORD RateToString(NDIS_802_11_RATES Rates, CString *pcs);

DWORD PrivacyToString(ULONG ulPrivacy, CString *pcs);

DWORD ChannelToString(NDIS_802_11_CONFIGURATION *pConfig, CString *pcs);

DWORD InfraToString(NDIS_802_11_NETWORK_INFRASTRUCTURE InfraMode, 
                    CString *pcs);

//Some global operators
BOOL operator==(const FILETIME& ftLHS, const FILETIME& ftRHS);
BOOL operator!=(const FILETIME& ftLHS, const FILETIME& ftRHS);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\loopback\debug.h ===
#ifndef _DEBUG_
#define _DEBUG_

#if DBG
  #define DEBUG DBG
#endif
//
// Debug Levels used with DBGPRINT

#define DBG_LEVEL_INFO  0
#define DBG_LEVEL_WARN  1
#define DBG_LEVEL_ERR   2
#define DBG_LEVEL_FATAL 3

// Component Types

#define DBG_COMP_INIT     0x00000001
#define DBG_COMP_DPC      0x00000002
#define DBG_COMP_REGISTRY 0x00000004
#define DBG_COMP_MEMORY   0x00000008
#define DBG_COMP_SEND     0x00000010
#define DBG_COMP_REQUEST  0x00000020
#define DBG_COMP_MISC     0x00000040
#define DBG_COMP_ALL      0xffffffff

extern LONG LoopDebugLevel;
extern LONG LoopDebugComponent;

#ifdef DEBUG

    #define DBGPRINT(Component, Level, Fmt) \
        if ((LoopDebugComponent & Component) && (Level >= LoopDebugLevel)) { \
            DbgPrint("    *** Loop - "); \
            DbgPrint Fmt; \
        }

    #define DBGBREAK(Level) \
        if (Level >= LoopDebugLevel) { \
            DbgBreakPoint(); \
        }

#else
    #define DBGPRINT(Component, Level, Fmt)
    #define DBGBREAK(Level)
#endif

#endif // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\lib\nthlpr.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	ndisapi.c

Abstract:

	Since we cannot include windows.h and ntos.h in the same C file. Sigh !!!

Author:

	JameelH

Environment:

	Kernel mode, FSD

Revision History:

	Aug 1997	 JameelH 	Initial version

--*/

#include <ntosp.h>

extern
VOID
XSetLastError(
	IN	ULONG		Error
	);

VOID
InitUnicodeString(
	IN	PUNICODE_STRING		DestinationString,
	IN	PCWSTR				SourceString
    )
{
	RtlInitUnicodeString(DestinationString, SourceString);
}

NTSTATUS
AppendUnicodeStringToString(
	IN	PUNICODE_STRING		Destination,
	IN	PUNICODE_STRING		Source
    )
{
	return (RtlAppendUnicodeStringToString(Destination, Source));
}

HANDLE
OpenDevice(
	IN	PUNICODE_STRING		DeviceName
	)
{
	OBJECT_ATTRIBUTES	ObjAttr;
	NTSTATUS			Status;
	IO_STATUS_BLOCK		IoStsBlk;
	HANDLE				Handle = NULL;

	InitializeObjectAttributes(&ObjAttr,
							   DeviceName,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);

	Status = NtOpenFile(&Handle,
						FILE_GENERIC_READ | FILE_GENERIC_WRITE,
						&ObjAttr,
						&IoStsBlk,
						FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
						FILE_SYNCHRONOUS_IO_NONALERT);
	if (Status != STATUS_SUCCESS)
	{
		XSetLastError(RtlNtStatusToDosError(Status));
	}
	return(Handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\wirelessnode.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
    WirelessNode.cpp
        Wireless ApInfo node handler

    FILE HISTORY:
        
*/

#include "stdafx.h"
#include "server.h"
#include "WirelessNode.h"

#include "SpdUtil.h"

/*---------------------------------------------------------------------------
    Class CWirelessHandler implementation
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    Constructor and destructor
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
CWirelessHandler::CWirelessHandler
(
    ITFSComponentData * pComponentData
) : CIpsmHandler(pComponentData)

{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
}


CWirelessHandler::~CWirelessHandler()
{
}

/*!--------------------------------------------------------------------------
    CWirelessHandler::InitializeNode
        Initializes node specific data
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CWirelessHandler::InitializeNode
(
    ITFSNode * pNode
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));


    CString strTemp;  
	strTemp.LoadString(IDS_WIRELESS_NODE);
    SetDisplayName(strTemp);

    // Make the node immediately visible
    pNode->SetVisibilityState(TFS_VIS_SHOW);
    pNode->SetData(TFS_DATA_COOKIE, (LPARAM) pNode);
    pNode->SetData(TFS_DATA_IMAGEINDEX, ICON_IDX_FOLDER_CLOSED);
    pNode->SetData(TFS_DATA_OPENIMAGEINDEX, ICON_IDX_FOLDER_OPEN);
    pNode->SetData(TFS_DATA_USER, (LPARAM) this);
    pNode->SetData(TFS_DATA_TYPE, WLANMON_APDATA);
    pNode->SetData(TFS_DATA_SCOPE_LEAF_NODE, TRUE);

    SetColumnStringIDs(&aColumns[WLANMON_APDATA][0]);
    SetColumnWidths(&aColumnWidths[WLANMON_APDATA][0]);

    return hrOK;
}


/*---------------------------------------------------------------------------
    CWirelessHandler::GetImageIndex
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
int 
CWirelessHandler::GetImageIndex(BOOL bOpenImage) 
{
    int nIndex = -1;

    return nIndex;
}


/*---------------------------------------------------------------------------
    Overridden base handler functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CWirelessHandler::OnAddMenuItems
        Adds context menu items for the SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWirelessHandler::OnAddMenuItems
(
    ITFSNode *              pNode,
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    LPDATAOBJECT            lpDataObject, 
    DATA_OBJECT_TYPES       type, 
    DWORD                   dwType,
    long *                  pInsertionAllowed
)
{ 
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    LONG        fFlags = 0, fLoadingFlags = 0;
    HRESULT     hr = S_OK;
    CString     strMenuItem;

    if (type == CCT_SCOPE)
    {
        if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
        {
        }

    }

    return hr; 
}

/*!--------------------------------------------------------------------------
    CWirelessHandler::AddMenuItems
        Adds context menu items for virtual list box (result pane) items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWirelessHandler::AddMenuItems
(
    ITFSComponent *         pComponent, 
    MMC_COOKIE              cookie,
    LPDATAOBJECT            pDataObject, 
    LPCONTEXTMENUCALLBACK   pContextMenuCallback, 
    long *                  pInsertionAllowed
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT     hr = hrOK;
    CString     strMenuItem;
    SPINTERNAL  spInternal;
    LONG        fFlags = 0;

    spInternal = ExtractInternalFormat(pDataObject);

    /* virtual listbox notifications come to the handler of the node that 
     * is selected. check to see if this notification is for a virtual 
     * listbox item or this SA node itself.
     */
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW)
    {
        //load and view menu items here
    }

    return hr;
}

 /*!--------------------------------------------------------------------------
    CWirelessHandler::OnRefresh
        Default implementation for the refresh functionality
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CWirelessHandler::OnRefresh
(
    ITFSNode *      pNode,
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg,
    LPARAM          param
)
{
	HRESULT hr = S_OK;
    int i = 0; 
    SPIConsole      spConsole;

    CORg(CHandler::OnRefresh(pNode, pDataObject, dwType, arg, param));

    CORg(m_spApDbInfo->EnumApData());
    
    i = m_spApDbInfo->GetApCount();
    
    // now notify the virtual listbox
    CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE));


Error:
	return hr;
}


/*---------------------------------------------------------------------------
    CWirelessHandler::OnCommand
        Handles context menu commands for SA scope pane node
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWirelessHandler::OnCommand
(
    ITFSNode *          pNode, 
    long                nCommandId, 
    DATA_OBJECT_TYPES   type, 
    LPDATAOBJECT        pDataObject, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

	//handle the scope context menu commands here

    return S_OK;
}

/*!--------------------------------------------------------------------------
    CWirelessHandler::Command
        Handles context menu commands for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWirelessHandler::Command
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    int             nCommandID,
    LPDATAOBJECT    pDataObject
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    HRESULT hr = S_OK;

    return hr;
}

/*!--------------------------------------------------------------------------
    CWirelessHandler::HasPropertyPages
        Implementation of ITFSNodeHandler::HasPropertyPages
    NOTE: the root node handler has to over-ride this function to 
    handle the snapin manager property page (wizard) case!!!
    
    Author: KennT
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWirelessHandler::HasPropertyPages
(
    ITFSNode *          pNode,
    LPDATAOBJECT        pDataObject, 
    DATA_OBJECT_TYPES   type, 
    DWORD               dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CWirelessHandler::CreatePropertyPages
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWirelessHandler::CreatePropertyPages
(
    ITFSNode *              pNode,
    LPPROPERTYSHEETCALLBACK lpSA,
    LPDATAOBJECT            pDataObject, 
    LONG_PTR                handle, 
    DWORD                   dwType
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    DWORD       dwError;
    DWORD       dwDynDnsFlags;

    //
    // Create the property page
    //
    SPIComponentData spComponentData;
    m_spNodeMgr->GetComponentData(&spComponentData);

    //CServerProperties * pServerProp = new CServerProperties(pNode, spComponentData, m_spTFSCompData, NULL);

    //
    // Object gets deleted when the page is destroyed
    //
    Assert(lpSA != NULL);

    //return pServerProp->CreateModelessSheet(lpSA, handle);
    return hrFalse;
}

/*---------------------------------------------------------------------------
    CWirelessHandler::OnPropertyChange
        Description
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CWirelessHandler::OnPropertyChange
(   
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataobject, 
    DWORD           dwType, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    //CServerProperties * pServerProp = reinterpret_cast<CServerProperties *>(lParam);

    LONG_PTR changeMask = 0;

    // tell the property page to do whatever now that we are back on the
    // main thread
    //pServerProp->OnPropertyChange(TRUE, &changeMask);

    //pServerProp->AcknowledgeNotify();

    if (changeMask)
        pNode->ChangeNode(changeMask);

    return hrOK;
}

/*---------------------------------------------------------------------------
    CWirelessHandler::OnExpand
        Handles enumeration of a scope item
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CWirelessHandler::OnExpand
(
    ITFSNode *      pNode, 
    LPDATAOBJECT    pDataObject,
    DWORD           dwType,
    LPARAM          arg, 
    LPARAM          param
)
{
    HRESULT hr = hrOK;

    if (m_bExpanded) 
        return hr;
    
    // do the default handling
    CORg (CIpsmHandler::OnExpand(pNode, pDataObject, dwType, arg, param));

Error:
    return hr;
}

/*!--------------------------------------------------------------------------
    CWirelessHandler::OnResultSelect
        Handles the MMCN_SELECT notifcation 
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CWirelessHandler::OnResultSelect
(
    ITFSComponent * pComponent, 
    LPDATAOBJECT    pDataObject, 
    MMC_COOKIE      cookie,
    LPARAM          arg, 
    LPARAM          lParam
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    HRESULT         hr = hrOK;
    SPINTERNAL      spInternal;
    SPIConsole      spConsole;
    SPIConsoleVerb  spConsoleVerb;
    SPITFSNode      spNode;
    BOOL            bStates[ARRAYLEN(g_ConsoleVerbs)];
    int             i;
    LONG_PTR        dwNodeType;
    BOOL            fSelect = HIWORD(arg);

	// virtual listbox notifications come to the handler of the node that is selected.
    // check to see if this notification is for a virtual listbox item or the active
    // registrations node itself.
    CORg (pComponent->GetConsoleVerb(&spConsoleVerb));

	m_verbDefault = MMC_VERB_OPEN;
    if (!fSelect)
	{
        return hr;
	}

    if (m_spApDbInfo)
    {
        DWORD dwInitInfo;

        dwInitInfo=m_spApDbInfo->GetInitInfo();
        if (!(dwInitInfo & MON_LOG_DATA)) {
            CORg(m_spApDbInfo->EnumApData());            
            m_spApDbInfo->SetInitInfo(dwInitInfo | MON_LOG_DATA);
        }
        m_spApDbInfo->SetActiveInfo(MON_LOG_DATA);


        // Get the current count
        i = m_spApDbInfo->GetApCount();

        // now notify the virtual listbox
        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
        CORg ( spConsole->UpdateAllViews(pDataObject, i, RESULT_PANE_SET_VIRTUAL_LB_SIZE) ); 
    }

    // now update the verbs...
    spInternal = ExtractInternalFormat(pDataObject);
    Assert(spInternal);


    if (spInternal->HasVirtualIndex())
    {
        //TODO add to here if we want to have some result console verbs
        // we gotta do special stuff for the virtual index items
        dwNodeType = WLANMON_APDATA_ITEM;
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = FALSE);
        
        //Set to enable the "properties" menu in the result context menu
        bStates[MMC_VERB_PROPERTIES & 0x000F] = FALSE;
        m_verbDefault = MMC_VERB_PROPERTIES;
    }
    else
    {
        // enable/disable delete depending if the node supports it
        CORg (m_spNodeMgr->FindNode(cookie, &spNode));
        dwNodeType = spNode->GetData(TFS_DATA_TYPE);
        
        for (i = 0; i < ARRAYLEN(g_ConsoleVerbs); bStates[i++] = TRUE);
        
        //hide "delete" context menu
        bStates[MMC_VERB_DELETE & 0x000F] = FALSE;
        bStates[MMC_VERB_REFRESH & 0x000F] = TRUE;
    }

    EnableVerbs(spConsoleVerb, g_ConsoleVerbStates[dwNodeType], bStates);
	
COM_PROTECT_ERROR_LABEL;
    return hr;
}

/*!--------------------------------------------------------------------------
    CWirelessHandler::OnDelete
        The base handler calls this when MMC sends a MMCN_DELETE for a 
        scope pane item.  We just call our delete command handler.
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CWirelessHandler::OnDelete
(
    ITFSNode *  pNode, 
    LPARAM      arg, 
    LPARAM      lParam
)
{
    return S_FALSE;
}

/*!--------------------------------------------------------------------------
    CWirelessHandler::HasPropertyPages
        Handle the result notification
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWirelessHandler::HasPropertyPages(
   ITFSComponent *pComponent,
   MMC_COOKIE cookie,
   LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
    HRESULT hr = S_FALSE;

    return hr;
}

/*!--------------------------------------------------------------------------
    CWirelessHandler::CreatePropertyPages
        Handle the result notification. Create the filter property sheet
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP CWirelessHandler::CreatePropertyPages
(
	ITFSComponent * 		pComponent, 
   MMC_COOKIE			   cookie,
   LPPROPERTYSHEETCALLBACK lpProvider, 
   LPDATAOBJECT 		 pDataObject, 
   LONG_PTR 			 handle
)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    HRESULT	hr = hrOK;
    SPINTERNAL  spInternal;
    SPITFSNode  spNode;
    int		nIndex;
    SPIComponentData spComponentData;
    CLogDataInfo LogDataInfo;
    
    return hr;
}


/*---------------------------------------------------------------------------
    CWirelessHandler::OnGetResultViewType
        Return the result view that this node is going to support
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CWirelessHandler::OnGetResultViewType
(
    ITFSComponent * pComponent, 
    MMC_COOKIE            cookie, 
    LPOLESTR *      ppViewType,
    long *          pViewOptions
)
{
    if (cookie != NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    }

    return S_FALSE;
}

/*---------------------------------------------------------------------------
    CWirelessHandler::GetVirtualImage
        Returns the image index for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
int CWirelessHandler::GetVirtualImage(int nIndex)
{
    HRESULT hr = S_OK;
    int nImgIndex = ICON_IDX_LOGDATA_UNKNOWN;
    CApInfo apData;
    
    CORg(m_spApDbInfo->GetApInfo(nIndex, &apData));

    switch(apData.m_ApInfo.wlanConfig.InfrastructureMode)
    {
    case Ndis802_11IBSS:
        if (TRUE == apData.m_ApInfo.bAssociated)
            nImgIndex = ICON_IDX_AP_ASSOC_ADHOC;
        else
            nImgIndex = ICON_IDX_AP_ADHOC;
        break;
        
    case Ndis802_11Infrastructure:
        if (TRUE == apData.m_ApInfo.bAssociated)
            nImgIndex = ICON_IDX_AP_ASSOC_INFRA;
        else
            nImgIndex = ICON_IDX_AP_INFRA;
        break;
        
    default:
        break;
    }

    COM_PROTECT_ERROR_LABEL;
    return nImgIndex;
}

/*---------------------------------------------------------------------------
    CWirelessHandler::GetVirtualString
        returns a pointer to the string for virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------*/
LPCWSTR CWirelessHandler::GetVirtualString(int nIndex, int nCol)
{
    HRESULT hr = S_OK;
    static CString strTemp;
    CApInfo apData;

    strTemp.Empty();
    if (nCol >= DimensionOf(aColumns[WLANMON_APDATA]))
        return NULL;
    
    CORg(m_spApDbInfo->GetApInfo(nIndex, &apData));

    switch (aColumns[WLANMON_APDATA][nCol])
    {
    case IDS_COL_APDATA_GUID:
        strTemp = apData.m_ApInfo.wszGuid;
        break;

    case IDS_COL_APDATA_SSID:
        SSIDToString(apData.m_ApInfo.wlanConfig.Ssid, strTemp);
        break;

    case IDS_COL_APDATA_MAC:
        MacToString(apData.m_ApInfo.wlanConfig.MacAddress, strTemp);
        break;

    case IDS_COL_APDATA_INF_MODE:
        InfraToString(apData.m_ApInfo.wlanConfig.InfrastructureMode, &strTemp);
        break;

    case IDS_COL_APDATA_PRIVACY:
        PrivacyToString(apData.m_ApInfo.wlanConfig.Privacy, &strTemp);
        break;
        
    case IDS_COL_APDATA_RSSI:
        strTemp.Format(_T("%ld"), apData.m_ApInfo.wlanConfig.Rssi);
        break;

    case IDS_COL_APDATA_CHANNEL:
        ChannelToString(&(apData.m_ApInfo.wlanConfig.Configuration), &strTemp);
        break;

    case IDS_COL_APDATA_RATE:
        RateToString(apData.m_ApInfo.wlanConfig.SupportedRates, &strTemp);
        break;

    default:
        Panic0("CWirelessHandler::GetVirtualString - Unknown column!\n");
        break;
    }
    
COM_PROTECT_ERROR_LABEL;
    return strTemp;
}

/*---------------------------------------------------------------------------
    CWirelessHandler::CacheHint
        MMC tells us which items it will need before it requests things
    Author: NSun
 ---------------------------------------------------------------------------*/
STDMETHODIMP 
CWirelessHandler::CacheHint
(
    int nStartIndex, 
    int nEndIndex
)
{
    HRESULT hr = hrOK;;

    Trace2("CacheHint - Start %d, End %d\n", nStartIndex, nEndIndex);
    return hr;
}

/*---------------------------------------------------------------------------
    CWirelessHandler::SortItems
        We are responsible for sorting of virtual listbox items
    Author: NSun
 ---------------------------------------------------------------------------
STDMETHODIMP 
CWirelessHandler::SortItems
(
    int     nColumn, 
    DWORD   dwSortOptions, 
    LPARAM    lUserParam
)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	HRESULT hr = S_OK;

	if (nColumn >= DimensionOf(aColumns[IPWLMON_WLDATA]))
		return E_INVALIDARG;
	
	BEGIN_WAIT_CURSOR
	
	DWORD	dwIndexType = aColumns[IPWLMON_WLDATA][nColumn];

	hr = m_spApDbInfo->SortLogData(dwIndexType, dwSortOptions);
	
	END_WAIT_CURSOR
    return hr;
}
*/

/*!--------------------------------------------------------------------------
    CWirelessHandler::OnResultUpdateView
        Implementation of ITFSResultHandler::OnResultUpdateView
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT CWirelessHandler::OnResultUpdateView
(
    ITFSComponent *pComponent, 
    LPDATAOBJECT  pDataObject, 
    LPARAM        data, 
    LONG_PTR      hint
)
{
    HRESULT    hr = hrOK;
    SPITFSNode spSelectedNode;

    pComponent->GetSelectedNode(&spSelectedNode);
    if (spSelectedNode == NULL)
        return S_OK; // no selection for our IComponentData

    if ( hint == IPFWMON_UPDATE_STATUS )
    {
        SPINTERNAL spInternal = ExtractInternalFormat(pDataObject);
        ITFSNode * pNode = reinterpret_cast<ITFSNode *>(spInternal->m_cookie);
        SPITFSNode spSelectedNode;

        pComponent->GetSelectedNode(&spSelectedNode);

        if (pNode == spSelectedNode)
        {       
            // if we are the selected node, then we need to update
            SPIResultData spResultData;

            CORg (pComponent->GetResultData(&spResultData));
            CORg (spResultData->SetItemCount((int) data, MMCLV_UPDATE_NOSCROLL));
        }
    }
    else
    {
        // we don't handle this message, let the base class do it.
        return CIpsmHandler::OnResultUpdateView(pComponent, pDataObject, data, hint);
    }

COM_PROTECT_ERROR_LABEL;

    return hr;
}



/*!--------------------------------------------------------------------------
    CWirelessHandler::LoadColumns
        Set the correct column header and then call the base class
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CWirelessHandler::LoadColumns
(
    ITFSComponent * pComponent, 
    MMC_COOKIE      cookie, 
    LPARAM          arg, 
    LPARAM          lParam
)
{
	//set column info
    return CIpsmHandler::LoadColumns(pComponent, cookie, arg, lParam);
}

/*---------------------------------------------------------------------------
    Command handlers
 ---------------------------------------------------------------------------*/

 
/*---------------------------------------------------------------------------
    CWirelessHandler::OnDelete
        Removes a service SA
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT 
CWirelessHandler::OnDelete
(
    ITFSNode * pNode
)
{
    HRESULT         hr = S_FALSE;
    return hr;
}

/*---------------------------------------------------------------------------
    CWirelessHandler::UpdateStatus
        -
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CWirelessHandler::UpdateStatus
(
    ITFSNode * pNode
)
{
    HRESULT             hr = hrOK;

    SPIComponentData    spComponentData;
    SPIConsole          spConsole;
    IDataObject *       pDataObject;
    SPIDataObject       spDataObject;
    int                 i = 0;
    
    Trace0("CWirelessHandler::UpdateStatus - Updating status for Filter");

    // force the listbox to update.  We do this by setting the count and 
    // telling it to invalidate the data
    CORg(m_spNodeMgr->GetComponentData(&spComponentData));
    CORg(m_spNodeMgr->GetConsole(&spConsole));
    
    // grab a data object to use
    CORg(spComponentData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
    spDataObject = pDataObject;

    i = m_spApDbInfo->GetApCount();
    CORg(spConsole->UpdateAllViews(pDataObject, i, IPFWMON_UPDATE_STATUS));

COM_PROTECT_ERROR_LABEL;

    return hr;
}

/*---------------------------------------------------------------------------
    Misc functions
 ---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------
    CWirelessHandler::InitData
        Initializes data for this node
    Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
CWirelessHandler::InitApData
(
    IApDbInfo *     pApDbInfo
)
{

    m_spApDbInfo.Set(pApDbInfo);

    return hrOK;
}

/*
HRESULT 
CWirelessHandler::UpdateViewType(ITFSNode * pNode, FILTER_TYPE NewFltrType)
{
	// clear the listbox then set the size

    HRESULT             hr = hrOK;
    SPIComponentData    spCompData;
    SPIConsole          spConsole;
    IDataObject*        pDataObject;
    SPIDataObject       spDataObject;
    LONG_PTR            command;               
    int i;

    COM_PROTECT_TRY
    {
		m_FltrType = NewFltrType;

		//tell the spddb to update its index manager for QM filter
		m_spSpdInfo->ChangeLogDataViewType(m_FltrType);

        i = m_spSpdInfo->GetLogDataCountOfCurrentViewType();

		m_spNodeMgr->GetComponentData(&spCompData);

        CORg ( spCompData->QueryDataObject((MMC_COOKIE) pNode, CCT_RESULT, &pDataObject) );
        spDataObject = pDataObject;

        CORg ( m_spNodeMgr->GetConsole(&spConsole) );
    
		//update the result pane virtual list
        CORg ( spConsole->UpdateAllViews(spDataObject, i, RESULT_PANE_CLEAR_VIRTUAL_LB) ); 

        COM_PROTECT_ERROR_LABEL;
    }
    COM_PROTECT_CATCH

    return hr;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\wirelessnode.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1998 **/
/**********************************************************************/

/*
	FltrNode.h

    FILE HISTORY:
        
*/

#ifndef _WIRELESS_NODE_H
#define _WIRELESS_NODE_H

#ifndef _IPSMHAND_H
#include "ipsmhand.h"
#endif

#ifndef _APINFO_H
#include "apinfo.h"
#endif

/*---------------------------------------------------------------------------
	Class:	CFilterHandler
 ---------------------------------------------------------------------------*/
class CWirelessHandler : public CIpsmHandler
{
public:
    CWirelessHandler(ITFSComponentData* pTFSComponentData);
	virtual ~CWirelessHandler();

// Interface
public:
	// base handler functionality we override
	OVERRIDE_NodeHandler_HasPropertyPages();
    OVERRIDE_NodeHandler_CreatePropertyPages();
	OVERRIDE_NodeHandler_OnAddMenuItems();
	OVERRIDE_NodeHandler_OnCommand();
	OVERRIDE_NodeHandler_GetString()
			{ return (nCol == 0) ? GetDisplayName() : NULL; }

	// Base handler notifications we handle
	OVERRIDE_BaseHandlerNotify_OnExpand();
    OVERRIDE_BaseHandlerNotify_OnDelete();
    OVERRIDE_BaseHandlerNotify_OnPropertyChange();    

	// Result handler functionality we override
    OVERRIDE_BaseResultHandlerNotify_OnResultSelect();
    OVERRIDE_BaseResultHandlerNotify_OnResultUpdateView();

    OVERRIDE_ResultHandler_OnGetResultViewType();
	OVERRIDE_ResultHandler_GetVirtualString(); 
	OVERRIDE_ResultHandler_GetVirtualImage();
    OVERRIDE_ResultHandler_AddMenuItems();
    OVERRIDE_ResultHandler_Command();
	OVERRIDE_ResultHandler_HasPropertyPages();
	OVERRIDE_ResultHandler_CreatePropertyPages();

	STDMETHODIMP CacheHint(int nStartIndex, int nEndIndex);

	/*
	STDMETHODIMP SortItems(int     nColumn, 
						   DWORD   dwSortOptions,    
						   LPARAM  lUserParam);
	*/

    // base handler overrides
	virtual HRESULT LoadColumns(ITFSComponent *, MMC_COOKIE, LPARAM, LPARAM);

	// CHandler overridden
    virtual HRESULT OnRefresh(ITFSNode *, LPDATAOBJECT, DWORD, LPARAM, LPARAM);


    // multi select support
    virtual const GUID * GetVirtualGuid(int nIndex) 
	{ 
		return &GUID_IpfmWirelessNodeType; 
	}

public:
	// CMTIpsmHandler functionality
	virtual HRESULT  InitializeNode(ITFSNode * pNode);
	virtual int      GetImageIndex(BOOL bOpenImage);
	ITFSQueryObject* OnCreateQuery(ITFSNode * pNode);

public:
	// implementation specific	
    HRESULT InitApData(IApDbInfo * pApDbInfo);
    HRESULT UpdateStatus(ITFSNode * pNode);
    
// Implementation
private:
	// Command handlers
    HRESULT OnDelete(ITFSNode * pNode);
	//HRESULT UpdateViewType(ITFSNode * pNode, FILTER_TYPE NewFltrType);

private:
    SPIApDbInfo  m_spApDbInfo;
	//FILTER_TYPE	m_FltrType;
};
/*
SPITFSNode spWirelessNode;
		CWirelessHandler * pWirelessHandler = new CWirelessHandler(m_spTFSCompData);
		CreateContainerTFSNode(	&spWirelessNode,
								&GUID_IpfmWirelessNodeType,
								pWirelessHandler,
								pWirelessHandler,
								m_spNodeMgr);
		pWirelessHandler->InitData(m_spApDbInfo);
		pWirelessHandler->InitializeNode(spWirelessNode);
		pWirelessHandler->Release();
		pNode->AddChild(spWirelessNode);
*/

#endif _WIRELESS_NODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\mmc\wlanmon\stdafx.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corporation, 1997 - 1999 **/
/**********************************************************************/

/*
	stdafx.h
		include file for standard system include files,
		or project specific include files that are used frequently,
		but are changed infrequently

	FILE HISTORY:
        
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#ifdef ASSERT
#undef ASSERT
#endif

#include <afxwin.h>
#include <afxdisp.h>
#include <afxcmn.h>
#include <afxtempl.h>
#include <afxcview.h>
#include <afxext.h>
#include <afxmt.h>

#include <atlbase.h>
#include <htmlhelp.h>

//Files from \net\inc
#include <wzcsapi.h>
#include <wzcmon.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//#pragma comment(lib, "mmc")
#include <mmc.h>

extern "C"
{
	#include "winsock.h"     //  WinSock definitions
	#include "lmerr.h"

    // for get user stuff
    #include <wtypes.h>
}


#include "resource.h"

// Global defines for IPSecMon snapin
#include "ipsmsnap.h"

// Files from ..\tfscore
#include <dbgutil.h>
#include <std.h>
#include <errutil.h>
#include <register.h>

// Files from ..\common
#include <ccdata.h>
#include <about.h>
#include <dataobj.h>
#include <proppage.h>
#include <ipaddr.hpp>
#include <dialog.h>
#include <objpick.h>
#include <esent.h>



// project specific
#include "ipsmcomp.h"
#include "ipsmhelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\lib\ndisapi.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ndisapi.c

Abstract:

    NDIS User-Mode apis to support PnP from the network UI

Author:

    JameelH

Environment:

    Kernel mode, FSD

Revision History:

    Aug 1997     JameelH    Initial version

--*/

#include <windows.h>
#include <wtypes.h>
#include <ntddndis.h>
#include <ndisprv.h>
#include <devioctl.h>

#ifndef UNICODE_STRING

typedef struct _UNICODE_STRING
{
    USHORT  Length;
    USHORT  MaximumLength;
    PWSTR   Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

#endif

#include <ndispnp.h>
#include <ndisprv.h>
#define MAC_ADDRESS_SIZE    6
#define VENDOR_ID_SIZE      3

extern
VOID
InitUnicodeString(
    IN  PUNICODE_STRING     DestinationString,
    IN  PCWSTR              SourceString
    );

extern
LONG
AppendUnicodeStringToString(
    IN  PUNICODE_STRING     Destination,
    IN  PUNICODE_STRING     Source
    );

extern
HANDLE
OpenDevice(
    IN  PUNICODE_STRING     DeviceName
    );

//
// UNICODE_STRING_SIZE calculates the size of the buffer needed to
// store a given UNICODE_STRING including an appended null-terminator.
//
// ULONG
// UNICODE_STRING_SIZE(
//     PUNICODE_STRING String
// );
//

#define UNICODE_STRING_SIZE(x) \
    ((((x) == NULL) ? 0 : (x)->Length) + sizeof(WCHAR))

VOID
NdispUnicodeStringToVar(
    IN     PVOID Base,
    IN     PUNICODE_STRING String,
    IN OUT PNDIS_VAR_DATA_DESC NdisVar
    )

/*++

Routine Description:

    This function copies the contents of a UNICODE_STRING to an
    NDIS_VAR_DATA structure.  NdisVar->Offset is treated as an input parameter
    and represents the offset into Base that the string characters should be
    copied to.

Arguments:

    Base - Specifies the base address of the IOCTL buffer.

    String - Supplies a pointer to the UNICODE_STRING that should be copied.

    NdisVar - Supplies a pointer to the target NDIS_VAR_DATA_DESC.  Its Offset
              field is taken as input, and its Length and MaximumLength fields
              are treated as output.

Return Value:

    None.

--*/

{
    PWCHAR destination;

    //
    // NdisVar->Offset is assumed to be filled in and is treated
    // as an input parameter.
    // 

    destination = (PWCHAR)(((PCHAR)Base) + NdisVar->Offset);

    //
    // Copy over the UNICODE_STRING, if any, and set NdisVar->Length
    //

    if ((String != NULL) && (String->Length > 0)) {
        NdisVar->Length = String->Length;
        memcpy(destination, String->Buffer, NdisVar->Length );
    } else {
        NdisVar->Length = 0;
    }

    //
    // Null-terminate, fill in MaxiumLength and we're done.
    //

    *(destination + NdisVar->Length / sizeof(WCHAR)) = L'\0';
    NdisVar->MaximumLength = NdisVar->Length + sizeof(WCHAR);
}

UINT
NdisHandlePnPEvent(
    IN  UINT            Layer,
    IN  UINT            Operation,
    IN  PUNICODE_STRING LowerComponent      OPTIONAL,
    IN  PUNICODE_STRING UpperComponent      OPTIONAL,
    IN  PUNICODE_STRING BindList            OPTIONAL,
    IN  PVOID           ReConfigBuffer      OPTIONAL,
    IN  UINT            ReConfigBufferSize  OPTIONAL
    )
{
    PNDIS_PNP_OPERATION Op;
    NDIS_PNP_OPERATION  tempOp;
    HANDLE              hDevice;
    BOOL                fResult = FALSE;
    UINT                cb, Size;
    DWORD               Error;
    ULONG               padding;

    do
    {
        //
        // Validate Layer & Operation
        //
        if (((Layer != NDIS) && (Layer != TDI)) ||
            ((Operation != BIND) && (Operation != UNBIND) && (Operation != RECONFIGURE) &&
             (Operation != UNLOAD) && (Operation != REMOVE_DEVICE) &&
             (Operation != ADD_IGNORE_BINDING) &&
             (Operation != DEL_IGNORE_BINDING) &&
             (Operation != BIND_LIST)))
        {
            Error = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Allocate and initialize memory for the block to be passed down.  The buffer
        // will look like this:
        //
        //
        //         +=================================+
        //         | NDIS_PNP_OPERATION              |
        //         |     ReConfigBufferOff           | ----+
        //    +--- |     LowerComponent.Offset       |     |
        //    |    |     UpperComponent.Offset       | --+ |
        //  +-|--- |     BindList.Offset             |   | |
        //  | +--> +---------------------------------+   | |
        //  |      | LowerComponentStringBuffer      |   | |
        //  |      +---------------------------------+ <-+ |
        //  |      | UpperComponentStringBuffer      |     |
        //  +----> +---------------------------------+     |
        //         | BindListStringBuffer            |     |
        //         +---------------------------------+     |
        //         | Padding to ensure ULONG_PTR     |     |
        //         |     alignment of ReConfigBuffer |     |
        //         +---------------------------------+ <---+
        //         | ReConfigBuffer                  | 
        //         +=================================+
        //
        // tempOp is a temporary structure into which we will store offsets as
        // they are calculated.  This temporary structure will be moved to
        // the head of the real buffer once its size is known and it is
        // allocated.
        //

        Size = sizeof(NDIS_PNP_OPERATION);
        tempOp.LowerComponent.Offset = Size;

        Size += UNICODE_STRING_SIZE(LowerComponent);
        tempOp.UpperComponent.Offset = Size;

        Size += UNICODE_STRING_SIZE(UpperComponent);
        tempOp.BindList.Offset = Size;

        Size += UNICODE_STRING_SIZE(BindList);

        padding = (sizeof(ULONG_PTR) - (Size & (sizeof(ULONG_PTR) - 1))) &
                    (sizeof(ULONG_PTR) - 1);

        Size += padding;
        tempOp.ReConfigBufferOff = Size;

        Size += ReConfigBufferSize + 1;

        Op = (PNDIS_PNP_OPERATION)LocalAlloc(LPTR, Size);
        if (Op == NULL)
        {
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // We have a buffer of the necessary size.  Copy in the partially-
        // filled in tempOp, then fill in the remaining fields and copy the
        // data into the buffer.
        // 

        *Op = tempOp;

        Op->Layer = Layer;
        Op->Operation = Operation;

        //
        // Copy over the three unicode strings
        //

        NdispUnicodeStringToVar( Op, LowerComponent, &Op->LowerComponent );
        NdispUnicodeStringToVar( Op, UpperComponent, &Op->UpperComponent );
        NdispUnicodeStringToVar( Op, BindList, &Op->BindList );

        //
        // Finally, copy over the ReConfigBuffer
        //

        Op->ReConfigBufferSize = ReConfigBufferSize;
        if (ReConfigBufferSize > 0)
        {
            memcpy((PUCHAR)Op + Op->ReConfigBufferOff,
                   ReConfigBuffer,
                   ReConfigBufferSize);
        }
        *((PUCHAR)Op + Op->ReConfigBufferOff + ReConfigBufferSize) = 0;

        hDevice = CreateFile(L"\\\\.\\NDIS",
                             GENERIC_READ | GENERIC_WRITE,
                             0,                 // sharing mode - not significant
                             NULL,              // security attributes
                             OPEN_EXISTING,
                             0,                 // file attributes and flags
                             NULL);             // handle to template file

        if (hDevice != INVALID_HANDLE_VALUE)
        {
            fResult = DeviceIoControl(hDevice,
                                      IOCTL_NDIS_DO_PNP_OPERATION,
                                      Op,                                   // input buffer
                                      Size,                                 // input buffer size
                                      NULL,                                 // output buffer
                                      0,                                    // output buffer size
                                      &cb,                                  // bytes returned
                                      NULL);                                // OVERLAPPED structure
            Error = GetLastError();
            CloseHandle(hDevice);
        }
        else
        {
            Error = GetLastError();
        }

        LocalFree(Op);

    } while (FALSE);

    SetLastError(Error);

    return(fResult);
}


NDIS_OID    StatsOidList[] =
    {
        OID_GEN_LINK_SPEED,
        OID_GEN_MEDIA_IN_USE | NDIS_OID_PRIVATE,
        OID_GEN_MEDIA_CONNECT_STATUS | NDIS_OID_PRIVATE,
        OID_GEN_XMIT_OK,
        OID_GEN_RCV_OK,
        OID_GEN_XMIT_ERROR,
        OID_GEN_RCV_ERROR,
        OID_GEN_DIRECTED_FRAMES_RCV | NDIS_OID_PRIVATE,
        OID_GEN_DIRECTED_BYTES_XMIT | NDIS_OID_PRIVATE,
        OID_GEN_DIRECTED_BYTES_RCV | NDIS_OID_PRIVATE,
        OID_GEN_ELAPSED_TIME | NDIS_OID_PRIVATE,
        OID_GEN_INIT_TIME_MS | NDIS_OID_PRIVATE,
        OID_GEN_RESET_COUNTS | NDIS_OID_PRIVATE,
        OID_GEN_MEDIA_SENSE_COUNTS | NDIS_OID_PRIVATE,
        OID_GEN_PHYSICAL_MEDIUM | NDIS_OID_PRIVATE
    };
UINT    NumOidsInList = sizeof(StatsOidList)/sizeof(NDIS_OID);

UINT
NdisQueryStatistics(
    IN  PUNICODE_STRING     Device,
    OUT PNIC_STATISTICS     Statistics
    )
{
    NDIS_STATISTICS_VALUE   StatsBuf[4*sizeof(StatsOidList)/sizeof(NDIS_OID)];
    PNDIS_STATISTICS_VALUE  pStatsBuf;
    HANDLE                  hDevice;
    BOOL                    fResult = FALSE;
    UINT                    cb, Size, Index;
    DWORD                   Error;

    if (Statistics->Size != sizeof(NIC_STATISTICS))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    memset(Statistics, 0, sizeof(NIC_STATISTICS));
    Statistics->DeviceState = DEVICE_STATE_DISCONNECTED;
    Statistics->MediaState  = MEDIA_STATE_UNKNOWN;
    hDevice = OpenDevice(Device);

    if (hDevice != NULL)
    {
        Statistics->MediaState  = MEDIA_STATE_CONNECTED;                // default, if the device does not support
        Statistics->DeviceState = DEVICE_STATE_CONNECTED;
        fResult = DeviceIoControl(hDevice,
                                  IOCTL_NDIS_QUERY_SELECTED_STATS,
                                  StatsOidList,                         // input buffer
                                  sizeof(StatsOidList),                 // input buffer size
                                  StatsBuf,                             // output buffer
                                  sizeof(StatsBuf),                     // output buffer size
                                  &cb,                                  // bytes returned
                                  NULL);                                // OVERLAPPED structure
        Error = GetLastError();
        CloseHandle(hDevice);

        if (fResult)
        {
            Error = NO_ERROR;

            for (Index = Size = 0, pStatsBuf = StatsBuf; Size < cb; Index++)
            {
                LARGE_INTEGER   Value;
                NDIS_OID        Oid;

                Value.QuadPart = 0;
                if (pStatsBuf->DataLength == sizeof(LARGE_INTEGER))
                {
                    // Use memcpy rather than assignment to avoid unalignment
                    // faults on ia64.
                    //
                    memcpy(&Value.QuadPart, &pStatsBuf->Data[0], pStatsBuf->DataLength);
                }
                else
                {
                    Value.LowPart = *(PULONG)(&pStatsBuf->Data[0]);
                }
                Size += (pStatsBuf->DataLength + FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data));
                Oid = pStatsBuf->Oid;
                pStatsBuf = (PNDIS_STATISTICS_VALUE)((PUCHAR)pStatsBuf +
                                                     FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data) +
                                                     pStatsBuf->DataLength);

                switch (Oid & ~NDIS_OID_PRIVATE)
                {
                  case OID_GEN_LINK_SPEED:
                    Statistics->LinkSpeed = Value.LowPart;
                    break;

                  case OID_GEN_MEDIA_CONNECT_STATUS:
                    Statistics->MediaState = (Value.LowPart == NdisMediaStateConnected) ?
                                                MEDIA_STATE_CONNECTED : MEDIA_STATE_DISCONNECTED;
                    break;

                  case OID_GEN_MEDIA_IN_USE:
                    Statistics->MediaType = Value.LowPart;
                    break;

                  case OID_GEN_XMIT_OK:
                    Statistics->PacketsSent = Value.QuadPart;
                    break;

                  case OID_GEN_RCV_OK:
                    Statistics->PacketsReceived = Value.QuadPart;
                    break;

                  case OID_GEN_XMIT_ERROR:
                    Statistics->PacketsSendErrors = Value.LowPart;
                    break;

                  case OID_GEN_RCV_ERROR:
                    Statistics->PacketsReceiveErrors = Value.LowPart;
                    break;

                  case OID_GEN_DIRECTED_BYTES_XMIT:
                    Statistics->BytesSent += Value.QuadPart;
                    break;

                  case OID_GEN_MULTICAST_BYTES_XMIT:
                    Statistics->BytesSent += Value.QuadPart;
                    break;

                  case OID_GEN_BROADCAST_BYTES_XMIT:
                    Statistics->BytesSent += Value.QuadPart;
                    break;

                  case OID_GEN_DIRECTED_BYTES_RCV:
                    Statistics->BytesReceived += Value.QuadPart;
                    Statistics->DirectedBytesReceived = Value.QuadPart;
                    break;

                  case OID_GEN_DIRECTED_FRAMES_RCV:
                    Statistics->DirectedPacketsReceived = Value.QuadPart;
                    break;

                  case OID_GEN_MULTICAST_BYTES_RCV:
                    Statistics->BytesReceived += Value.QuadPart;
                    break;

                  case OID_GEN_BROADCAST_BYTES_RCV:
                    Statistics->BytesReceived += Value.QuadPart;
                    break;

                  case OID_GEN_ELAPSED_TIME:
                    Statistics->ConnectTime = Value.LowPart;
                    break;

                  case OID_GEN_INIT_TIME_MS:
                    Statistics->InitTime = Value.LowPart;
                    break;

                  case OID_GEN_RESET_COUNTS:
                    Statistics->ResetCount = Value.LowPart;
                    break;

                  case OID_GEN_MEDIA_SENSE_COUNTS:
                    Statistics->MediaSenseConnectCount = Value.LowPart >> 16;
                    Statistics->MediaSenseDisconnectCount = Value.LowPart & 0xFFFF;
                    break;

                  case OID_GEN_PHYSICAL_MEDIUM:
                    Statistics->PhysicalMediaType = Value.LowPart;
                    break;

                  default:
                    // ASSERT(0);
                    break;
                }
            }
        }
        else
        {
            Error = GetLastError();
        }
    }
    else
    {
        Error = GetLastError();
    }

    SetLastError(Error);

    return(fResult);
}


UINT
NdisEnumerateInterfaces(
    IN  PNDIS_ENUM_INTF Interfaces,
    IN  UINT            Size
    )
{
    HANDLE              hDevice;
    BOOL                fResult = FALSE;
    UINT                cb;
    DWORD               Error = NO_ERROR;

    do
    {
        hDevice = CreateFile(L"\\\\.\\NDIS",
                             GENERIC_READ | GENERIC_WRITE,
                             0,                 // sharing mode - not significant
                             NULL,              // security attributes
                             OPEN_EXISTING,
                             0,                 // file attributes and flags
                             NULL);             // handle to template file

        if (hDevice != INVALID_HANDLE_VALUE)
        {
            fResult = DeviceIoControl(hDevice,
                                      IOCTL_NDIS_ENUMERATE_INTERFACES,
                                      NULL,                                 // input buffer
                                      0,                                    // input buffer size
                                      Interfaces,                           // output buffer
                                      Size,                                 // output buffer size
                                      &cb,                                  // bytes returned
                                      NULL);                                // OVERLAPPED structure
            Error = GetLastError();
            CloseHandle(hDevice);

            if (Error == NO_ERROR)
            {
                UINT    i;

                //
                // Fix-up pointers
                //
                for (i = 0; i < Interfaces->TotalInterfaces; i++)
                {
                    OFFSET_TO_POINTER(Interfaces->Interface[i].DeviceName.Buffer, Interfaces);
                    OFFSET_TO_POINTER(Interfaces->Interface[i].DeviceDescription.Buffer, Interfaces);
                }
            }
        }
        else
        {
            Error = GetLastError();
        }
    } while (FALSE);

    SetLastError(Error);

    return(fResult);
}

#if 0
UINT
NdisQueryDeviceBundle(
    IN  PUNICODE_STRING Device,
    OUT PDEVICE_BUNDLE  BundleBuffer,
    IN  UINT            BufferSize
    )
{
    HANDLE              hDevice;
    BOOL                fResult = FALSE;
    UINT                cb;
    DWORD               Error = NO_ERROR;

    do
    {
        if (BufferSize < (sizeof(DEVICE_BUNDLE) + Device->MaximumLength))
        {
            Error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        hDevice = OpenDevice(Device);
        if (hDevice != NULL)
        {
            fResult = DeviceIoControl(hDevice,
                                      IOCTL_NDIS_GET_DEVICE_BUNDLE,
                                      NULL,                                 // input buffer
                                      0,                                    // input buffer size
                                      BundleBuffer,                         // output buffer
                                      BufferSize,                           // output buffer size
                                      &cb,                                  // bytes returned
                                      NULL);                                // OVERLAPPED structure
            Error = GetLastError();
            CloseHandle(hDevice);

            if (Error == NO_ERROR)
            {
                UINT    i;

                //
                // Fix-up pointers
                //
                for (i = 0; i < BundleBuffer->TotalEntries; i++)
                {
                    OFFSET_TO_POINTER(BundleBuffer->Entries[i].Name.Buffer, BundleBuffer);
                }
            }
        }
        else
        {
            Error = ERROR_FILE_NOT_FOUND;
        }
    } while (FALSE);

    SetLastError(Error);

    return(fResult);
}

#endif

UINT
NdisQueryHwAddress(
    IN  PUNICODE_STRING Device,
    OUT PUCHAR          CurrentAddress,
    OUT PUCHAR          PermanentAddress,
    OUT PUCHAR          VendorId
    )
{
    UCHAR                   Buf[3*sizeof(NDIS_STATISTICS_VALUE) + 48];
    PNDIS_STATISTICS_VALUE  pBuf;
    NDIS_OID                Oids[] = { OID_802_3_CURRENT_ADDRESS, OID_802_3_PERMANENT_ADDRESS, OID_GEN_VENDOR_ID };
    HANDLE                  hDevice;
    BOOL                    fResult = FALSE;
    UINT                    cb;
    DWORD                   Error;

    memset(CurrentAddress, 0, MAC_ADDRESS_SIZE);
    memset(PermanentAddress, 0, MAC_ADDRESS_SIZE);
    memset(VendorId, 0, VENDOR_ID_SIZE);
    hDevice = OpenDevice(Device);

    if (hDevice != NULL)
    {
        fResult = DeviceIoControl(hDevice,
                                  IOCTL_NDIS_QUERY_SELECTED_STATS,
                                  &Oids,                                // input buffer
                                  sizeof(Oids),                         // input buffer size
                                  Buf,                                  // output buffer
                                  sizeof(Buf),                          // output buffer size
                                  &cb,                                  // bytes returned
                                  NULL);                                // OVERLAPPED structure
        Error = GetLastError();
        CloseHandle(hDevice);

        if (fResult)
        {
            UINT        Size, tmp;

            Error = NO_ERROR;

            pBuf = (PNDIS_STATISTICS_VALUE)Buf;
            for (Size = 0; Size < cb; )
            {
                tmp = (pBuf->DataLength + FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data));
                Size += tmp;

                switch (pBuf->Oid)
                {
                    case OID_802_3_CURRENT_ADDRESS:
                        memcpy(CurrentAddress, pBuf->Data, MAC_ADDRESS_SIZE);
                        break;

                    case OID_802_3_PERMANENT_ADDRESS:
                        memcpy(PermanentAddress, pBuf->Data, MAC_ADDRESS_SIZE);
                        break;

                    case OID_GEN_VENDOR_ID:
                        memcpy(VendorId, pBuf->Data, VENDOR_ID_SIZE);
                }
                pBuf = (PNDIS_STATISTICS_VALUE)((PUCHAR)pBuf + tmp);
            }
        }
        else
        {
            Error = GetLastError();
        }
    }
    else
    {
        Error = ERROR_FILE_NOT_FOUND;
    }

    SetLastError(Error);

    return(fResult);
}

VOID
XSetLastError(
    IN  ULONG       Error
    )
{
    SetLastError(Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\loopback\precomp.h ===
#include <ndis.h>
#include "debug.h"
#include "lbmini.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\loopback\lbmini.h ===
/*++
Copyright (c) 1992  Microsoft Corporation

Module Name:

	lbmini.h

Abstract:

	NDIS loopback miniport prototypes

Author:

	Jameel Hyder

Environment:

	Kernel mode, FSD

Revision History:

--*/

#define	NDIS_MAJOR_VERSION				0x3
#define	NDIS_MINOR_VERSION				0x0

#define	LOOP_MAJOR_VERSION				0x5
#define	LOOP_MINOR_VERSION				0x0

#define	ETH_CARD_ADDRESS				"\02\0LOOP"
#define	ETH_MAX_MULTICAST_ADDRESS		16
#define	TR_CARD_ADDRESS					"\100\0LOOP"
#define	FDDI_CARD_ADDRESS				"\02\0LOOP"
#define	FDDI_MAX_MULTICAST_LONG			16
#define	FDDI_MAX_MULTICAST_SHORT		16
#define	LTALK_CARD_ADDRESS				0xAB
#define	ARC_CARD_ADDRESS				'L'

//
// arbitrary maximums...
//
#define	MAX_LOOKAHEAD					256
#define	INDICATE_MAXIMUM				256

#define	OID_TYPE_MASK					0xFFFF0000
#define	OID_TYPE						0xFF000000
#define	OID_TYPE_GENERAL				0x00000000
#define	OID_TYPE_GENERAL_OPERATIONAL	0x00010000
#define	OID_TYPE_GENERAL_STATISTICS		0x00020000
#define	OID_TYPE_802_3					0x01000000
#define	OID_TYPE_802_3_OPERATIONAL		0x01010000
#define	OID_TYPE_802_3_STATISTICS		0x01020000
#define	OID_TYPE_802_5					0x02000000
#define	OID_TYPE_802_5_OPERATIONAL		0x02010000
#define	OID_TYPE_802_5_STATISTICS		0x02020000
#define	OID_TYPE_FDDI					0x03000000
#define	OID_TYPE_FDDI_OPERATIONAL		0x03010000
#define	OID_TYPE_LTALK					0x05000000
#define	OID_TYPE_LTALK_OPERATIONAL		0x05010000
#define	OID_TYPE_ARCNET					0x06000000
#define	OID_TYPE_ARCNET_OPERATIONAL		0x06010000

#define	OID_REQUIRED_MASK				0x0000FF00
#define	OID_REQUIRED_MANDATORY			0x00000100
#define	OID_REQUIRED_OPTIONAL			0x00000200

#define	OID_INDEX_MASK					0x000000FF

#define	GM_TRANSMIT_GOOD				0x00
#define	GM_RECEIVE_GOOD					0x01
#define	GM_TRANSMIT_BAD					0x02
#define	GM_RECEIVE_BAD					0x03
#define	GM_RECEIVE_NO_BUFFER			0x04
#define	GM_ARRAY_SIZE					0x05

#define PACKET_FILTER_802_3				0xF07F
#define PACKET_FILTER_802_5				0xF07F
#define PACKET_FILTER_DIX				0xF07F
#define PACKET_FILTER_FDDI  			0xF07F
#define PACKET_FILTER_LTALK				0x8009
#define PACKET_FILTER_ARCNET			0x8009

#define	LT_IS_BROADCAST(Address)	(BOOLEAN)(Address == 0xFF)

#define	ARC_IS_BROADCAST(Address)	(BOOLEAN)(!(Address))

typedef struct _MEDIA_INFO
{
	ULONG			MaxFrameLen;
	UINT			MacHeaderLen;
	ULONG			PacketFilters;
	ULONG			LinkSpeed;
} MEDIA_INFO, *PMEDIA_INFO;

typedef struct _ADAPTER
{
	NDIS_MEDIUM		Medium;

	//
	// NDIS Context for this interface
	NDIS_HANDLE		MiniportHandle;
	UINT			MaxLookAhead;
	UINT			AddressLength;
	ULONG			PacketFilter;

	//
	// Constants for the adapter
	//
	ULONG                   MediumLinkSpeed;
	ULONG			MediumMinPacketLen;
	ULONG			MediumMaxPacketLen;
	UINT			MediumMacHeaderLen;
	ULONG			MediumMaxFrameLen;
	ULONG			MediumPacketFilters;

	//
	// media specific info
	//
	UCHAR			PermanentAddress[ETH_LENGTH_OF_ADDRESS];
	UCHAR			CurrentAddress[ETH_LENGTH_OF_ADDRESS];

	// statistics
	ULONG			GeneralMandatory[GM_ARRAY_SIZE];

	UCHAR			LoopBuffer[MAX_LOOKAHEAD];

	ULONG			SendPackets;

} ADAPTER, *PADAPTER;

//
// This macro returns a pointer to the LOOP reserved portion of the packet
//
#define	PRESERVED_FROM_PACKET(Packet)	 ((PPACKET_RESERVED)((PVOID)((Packet)->MacReserved)))

#define	PPACKET_FROM_RESERVED(Reserved) ((PNDIS_PACKET)((PVOID)((Reserved)->Packet)))

typedef struct _PACKET_RESERVED
{
	PNDIS_PACKET	Next;
	USHORT			PacketLength;
	UCHAR			HeaderLength;
} PACKET_RESERVED, *PPACKET_RESERVED;

//
// Miniport proto-types
//
NDIS_STATUS
LBInitialize(
	OUT PNDIS_STATUS			OpenErrorStatus,
	OUT PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM			MediumArray,
	IN	UINT					MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				ConfigurationContext
	);

NDIS_STATUS
LBSend(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet,
	IN	UINT					Flags
	);

NDIS_STATUS
LBQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesWritten,
	OUT PULONG					BytesNeeded
	);

NDIS_STATUS
LBSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesRead,
	OUT PULONG					BytesNeeded
	);

VOID
LBHalt(
	IN	NDIS_HANDLE				MiniportAdapterContext
	);

NDIS_STATUS
LBReset(
	OUT PBOOLEAN				AddressingReset,
	IN	NDIS_HANDLE				MiniportAdapterContext
	);

BOOLEAN
LBCheckForHang(
	IN	NDIS_HANDLE				MiniportAdapterContext
	);

NDIS_STATUS
LBTransferData(
	OUT PNDIS_PACKET			Packet,
	OUT PUINT					BytesTransferred,
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_HANDLE				MiniportReceiveContext,
	IN	UINT					ByteOffset,
	IN	UINT					BytesToTransfer
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\pnptst\winstuff.c ===
#include <stdio.h>
#include <windows.h>

LONG
xxGetLastError(
	void
	)
{
	return(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\loopback\lbmini.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

	lpmini.c

Abstract:

	Loopback miniport

Author:

	Jameel Hyder	jameelh@microsoft.com

Environment:


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NDIS_OID LBSupportedOidArray[] =
{
	OID_GEN_SUPPORTED_LIST,
	OID_GEN_HARDWARE_STATUS,
	OID_GEN_MEDIA_SUPPORTED,
	OID_GEN_MEDIA_IN_USE,
	OID_GEN_MAXIMUM_LOOKAHEAD,
	OID_GEN_MAXIMUM_FRAME_SIZE,
	OID_GEN_MAC_OPTIONS,
	OID_GEN_PROTOCOL_OPTIONS,
	OID_GEN_LINK_SPEED,
	OID_GEN_TRANSMIT_BUFFER_SPACE,
	OID_GEN_RECEIVE_BUFFER_SPACE,
	OID_GEN_TRANSMIT_BLOCK_SIZE,
	OID_GEN_RECEIVE_BLOCK_SIZE,
	OID_GEN_VENDOR_ID,
	OID_GEN_VENDOR_DESCRIPTION,
	OID_GEN_CURRENT_PACKET_FILTER,
	OID_GEN_CURRENT_LOOKAHEAD,
	OID_GEN_DRIVER_VERSION,
	OID_GEN_MAXIMUM_TOTAL_SIZE,

	OID_GEN_XMIT_OK,
	OID_GEN_RCV_OK,
	OID_GEN_XMIT_ERROR,
	OID_GEN_RCV_ERROR,
	OID_GEN_RCV_NO_BUFFER,

	OID_802_3_PERMANENT_ADDRESS,
	OID_802_3_CURRENT_ADDRESS,
	OID_802_3_MULTICAST_LIST,
	OID_802_3_MAXIMUM_LIST_SIZE,

	OID_802_3_RCV_ERROR_ALIGNMENT,
	OID_802_3_XMIT_ONE_COLLISION,
	OID_802_3_XMIT_MORE_COLLISIONS,

	OID_802_5_PERMANENT_ADDRESS,
	OID_802_5_CURRENT_ADDRESS,
	OID_802_5_CURRENT_FUNCTIONAL,
	OID_802_5_CURRENT_GROUP,
	OID_802_5_LAST_OPEN_STATUS,
	OID_802_5_CURRENT_RING_STATUS,
	OID_802_5_CURRENT_RING_STATE,

	OID_802_5_LINE_ERRORS,
	OID_802_5_LOST_FRAMES,

	OID_FDDI_LONG_PERMANENT_ADDR,
	OID_FDDI_LONG_CURRENT_ADDR,
	OID_FDDI_LONG_MULTICAST_LIST,
	OID_FDDI_LONG_MAX_LIST_SIZE,
	OID_FDDI_SHORT_PERMANENT_ADDR,
	OID_FDDI_SHORT_CURRENT_ADDR,
	OID_FDDI_SHORT_MULTICAST_LIST,
	OID_FDDI_SHORT_MAX_LIST_SIZE,

	OID_LTALK_CURRENT_NODE_ID,

	OID_ARCNET_PERMANENT_ADDRESS,
	OID_ARCNET_CURRENT_ADDRESS
};

UINT	LBSupportedOids = sizeof(LBSupportedOidArray)/sizeof(NDIS_OID);
UCHAR	LBVendorDescription[] = "MS LoopBack Driver";
UCHAR	LBVendorId[3] = {0xFF, 0xFF, 0xFF};
const	NDIS_PHYSICAL_ADDRESS physicalConst = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
LONG	LoopDebugLevel = DBG_LEVEL_ERR;
LONG	LoopDebugComponent = DBG_COMP_ALL;

const MEDIA_INFO MediaParams[] =
	{
		/* NdisMedium802_3     */   { 1500, 14, PACKET_FILTER_802_3, 100000},
		/* NdisMedium802_5     */   { 4082, 14, PACKET_FILTER_802_5,  40000},
		/* NdisMediumFddi      */   { 4486, 13, PACKET_FILTER_FDDI, 1000000},
		/* NdisMediumWan       */   { 0, 0, 0, 0},
		/* NdisMediumLocalTalk */   {  600,  3, PACKET_FILTER_LTALK, 2300},
		/* NdisMediumDix       */   { 1500, 14, PACKET_FILTER_DIX, 100000},
		/* NdisMediumArcnetRaw */   { 1512,  3, PACKET_FILTER_ARCNET, 25000},
		/* NdisMediumArcnet878_2 */ {1512, 3, PACKET_FILTER_ARCNET, 25000}
	};

NTSTATUS
DriverEntry(
	IN	PDRIVER_OBJECT		DriverObject,
	IN	PUNICODE_STRING		RegistryPath
	)
/*++

Routine Description:


Arguments:

Return Value:


--*/
{
	NDIS_STATUS						Status;
	NDIS_MINIPORT_CHARACTERISTICS	MChars;
	NDIS_STRING						Name;
	NDIS_HANDLE						WrapperHandle;

	//
	// Register the miniport with NDIS.
	//
    NdisMInitializeWrapper(&WrapperHandle, DriverObject, RegistryPath, NULL);

	NdisZeroMemory(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

	MChars.MajorNdisVersion = NDIS_MAJOR_VERSION;
	MChars.MinorNdisVersion = NDIS_MINOR_VERSION;

	MChars.InitializeHandler = LBInitialize;
	MChars.QueryInformationHandler = LBQueryInformation;
	MChars.SetInformationHandler = LBSetInformation;
	MChars.ResetHandler = LBReset;
	MChars.TransferDataHandler = LBTransferData;
	MChars.SendHandler = LBSend;
	MChars.HaltHandler = LBHalt;
	MChars.CheckForHangHandler = LBCheckForHang;

	Status = NdisMRegisterMiniport(WrapperHandle,
								   &MChars,
								   sizeof(MChars));
	if (Status != NDIS_STATUS_SUCCESS)
	{
		NdisTerminateWrapper(WrapperHandle, NULL);
	}

	return(Status);
}


NDIS_STATUS
LBInitialize(
	OUT PNDIS_STATUS			OpenErrorStatus,
	OUT PUINT					SelectedMediumIndex,
	IN	PNDIS_MEDIUM			MediumArray,
	IN	UINT					MediumArraySize,
	IN	NDIS_HANDLE				MiniportAdapterHandle,
	IN	NDIS_HANDLE				ConfigurationContext
	)
/*++

Routine Description:

	This is the initialize handler.

Arguments:

	OpenErrorStatus			Not used by us.
	SelectedMediumIndex		Place-holder for what media we are using
	MediumArray				Array of ndis media passed down to us to pick from
	MediumArraySize			Size of the array
	MiniportAdapterHandle	The handle NDIS uses to refer to us
	WrapperConfigurationContext	For use by NdisOpenConfiguration

Return Value:

	NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
	UINT							i, Length;
	PADAPTER						pAdapt;
	NDIS_MEDIUM						AdapterMedium;
	NDIS_HANDLE 					ConfigHandle = NULL;
	PNDIS_CONFIGURATION_PARAMETER	Parameter;
	PUCHAR							NetworkAddress;
	NDIS_STRING						MediumKey = NDIS_STRING_CONST("Medium");
	NDIS_STATUS						Status;

	do
	{
		//
		// Start off by allocating the adapter block
		//
		NdisAllocateMemory(&pAdapt,
						   sizeof(ADAPTER),
						   0,
						   physicalConst);
		if (pAdapt == NULL)
		{
			Status = NDIS_STATUS_RESOURCES;
			break;
		}
	
		NdisZeroMemory(pAdapt, sizeof(ADAPTER));
		pAdapt->MiniportHandle = MiniportAdapterHandle;
	
		NdisOpenConfiguration(&Status,
							  &ConfigHandle,
							  ConfigurationContext);
	
		if (Status != NDIS_STATUS_SUCCESS)
		{
			DBGPRINT(DBG_COMP_REGISTRY, DBG_LEVEL_FATAL,
					("Unable to open configuration database!\n"));
			break;
		}
	
		NdisReadConfiguration(&Status,
							  &Parameter,
							  ConfigHandle,
							  &MediumKey,
							  NdisParameterInteger);
	
		AdapterMedium = NdisMedium802_3;	// Default
		if (Status == NDIS_STATUS_SUCCESS)
		{
			AdapterMedium = (NDIS_MEDIUM)Parameter->ParameterData.IntegerData;
			if ((AdapterMedium != NdisMedium802_3)		&&
				(AdapterMedium != NdisMedium802_5)		&&
				(AdapterMedium != NdisMediumFddi)		&&
				(AdapterMedium != NdisMediumLocalTalk)	&&
				(AdapterMedium != NdisMediumArcnet878_2))
			{
				DBGPRINT(DBG_COMP_REGISTRY, DBG_LEVEL_FATAL,
						("Unable to find 'Medium' keyword or invalid value!\n"));
				Status = NDIS_STATUS_NOT_SUPPORTED;
				break;
			}

		}

		switch (AdapterMedium)
		{
		  case NdisMedium802_3:
			NdisMoveMemory(pAdapt->PermanentAddress,
						   ETH_CARD_ADDRESS,
						   ETH_LENGTH_OF_ADDRESS);
	
			NdisMoveMemory(pAdapt->CurrentAddress,
						   ETH_CARD_ADDRESS,
						   ETH_LENGTH_OF_ADDRESS);
			break;
		  case NdisMedium802_5:
			NdisMoveMemory(pAdapt->PermanentAddress,
						   TR_CARD_ADDRESS,
						   TR_LENGTH_OF_ADDRESS);
	
			NdisMoveMemory(pAdapt->CurrentAddress,
						   TR_CARD_ADDRESS,
						   TR_LENGTH_OF_ADDRESS);
			break;
		  case NdisMediumFddi:
			NdisMoveMemory(pAdapt->PermanentAddress,
						   FDDI_CARD_ADDRESS,
						   FDDI_LENGTH_OF_LONG_ADDRESS);
	
			NdisMoveMemory(pAdapt->CurrentAddress,
						   FDDI_CARD_ADDRESS,
						   FDDI_LENGTH_OF_LONG_ADDRESS);
			break;
		  case NdisMediumLocalTalk:
			pAdapt->PermanentAddress[0] = LTALK_CARD_ADDRESS;
	
			pAdapt->CurrentAddress[0] = LTALK_CARD_ADDRESS;
			break;
		  case NdisMediumArcnet878_2:
			pAdapt->PermanentAddress[0] = ARC_CARD_ADDRESS;
			pAdapt->CurrentAddress[0] = ARC_CARD_ADDRESS;
			break;
		}
	
		pAdapt->Medium = AdapterMedium;
		pAdapt->MediumLinkSpeed = MediaParams[(UINT)AdapterMedium].LinkSpeed;
		pAdapt->MediumMinPacketLen = MediaParams[(UINT)AdapterMedium].MacHeaderLen;
		pAdapt->MediumMaxPacketLen = MediaParams[(UINT)AdapterMedium].MacHeaderLen+
									 MediaParams[(UINT)AdapterMedium].MaxFrameLen;
		pAdapt->MediumMacHeaderLen = MediaParams[(UINT)AdapterMedium].MacHeaderLen;
		pAdapt->MediumMaxFrameLen  = MediaParams[(UINT)AdapterMedium].MaxFrameLen;
		pAdapt->MediumPacketFilters = MediaParams[(UINT)AdapterMedium].PacketFilters;

		NdisReadNetworkAddress(&Status,
							   &NetworkAddress,
							   &Length,
							   ConfigHandle);
	
		if (Status == NDIS_STATUS_SUCCESS)
		{
			//
			// verify the address is appropriate for the specific media and
			// ensure that the locally administered address bit is set
			//
			switch (AdapterMedium)
			{
			  case NdisMedium802_3:
			  case NdisMediumFddi:
				if ((Length != ETH_LENGTH_OF_ADDRESS) ||
					ETH_IS_MULTICAST(NetworkAddress) ||
					((NetworkAddress[0] & 0x02) == 0))
				{
					Length = 0;
				}
				break;
	
			  case NdisMedium802_5:
				if ((Length != TR_LENGTH_OF_ADDRESS) ||
					(NetworkAddress[0] & 0x80) ||
					((NetworkAddress[0] & 0x40) == 0))
				{
					Length = 0;
				}
				break;
	
			  case NdisMediumLocalTalk:
				if ((Length != 1) || LT_IS_BROADCAST(NetworkAddress[0]))
				{
					Length = 0;
				}
				break;
	
			  case NdisMediumArcnet878_2:
				if ((Length != 1) || ARC_IS_BROADCAST(NetworkAddress[0]))
				{
					Length = 0;
				}
				break;
			}
	
			if (Length == 0)
			{
				DBGPRINT(DBG_COMP_REGISTRY, DBG_LEVEL_FATAL,
						("Invalid NetAddress in registry!\n"));
			}
			else
			{
				NdisMoveMemory(pAdapt->CurrentAddress,
							   NetworkAddress,
							   Length);
			}
		}
	
		//
		// Make sure the medium saved is one of the ones being offered
		//
		for (i = 0; i < MediumArraySize; i++)
		{
			if (MediumArray[i] == AdapterMedium)
			{
				*SelectedMediumIndex = i;
				break;
			}
		}
	
		if (i == MediumArraySize)
		{
			Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
			break;
		}
	
		//
		// Set the attributes now.
		//
		NdisMSetAttributesEx(MiniportAdapterHandle,
							 pAdapt,
							 0,										// CheckForHangTimeInSeconds
							 NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT|NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT,
							 0);
		Status = NDIS_STATUS_SUCCESS;
	} while (FALSE);

	if (ConfigHandle != NULL)
	{
		NdisCloseConfiguration(ConfigHandle);
	}

	if (Status != NDIS_STATUS_SUCCESS)
	{
		if (pAdapt != NULL)
		{
			NdisFreeMemory(pAdapt, sizeof(ADAPTER), 0);
		}
	}

	return Status;
}


VOID
LBHalt(
	IN	NDIS_HANDLE				MiniportAdapterContext
	)
/*++

Routine Description:

	Halt handler.

Arguments:

	MiniportAdapterContext	Pointer to the Adapter

Return Value:

	None.

--*/
{
	PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;

	//
	// Free the resources now
	//
	NdisFreeMemory(pAdapt, sizeof(ADAPTER), 0);
}


NDIS_STATUS
LBReset(
	OUT PBOOLEAN				AddressingReset,
	IN	NDIS_HANDLE				MiniportAdapterContext
	)
/*++

Routine Description:

	Reset Handler. We just don't do anything.

Arguments:

	AddressingReset			To let NDIS know whether we need help from it with our reset
	MiniportAdapterContext	Pointer to our adapter

Return Value:

	
--*/
{
	PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;

	*AddressingReset = FALSE;

	return(NDIS_STATUS_SUCCESS);
}


NDIS_STATUS
LBSend(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	PNDIS_PACKET			Packet,
	IN	UINT					Flags
	)
/*++

Routine Description:

	Send handler. Just re-wrap the packet and send it below. Re-wrapping is necessary since
	NDIS uses the WrapperReserved for its own use.

Arguments:

	MiniportAdapterContext	Pointer to the adapter
	Packet					Packet to send
	Flags					Unused, passed down below

Return Value:

	Return code from NdisSend

--*/
{
    
        PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;
    
        pAdapt->SendPackets++;
	
        return NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
LBQueryInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesWritten,
	OUT PULONG					BytesNeeded
	)
/*++

Routine Description:

	Miniport QueryInfo handler.

Arguments:

	MiniportAdapterContext	Pointer to the adapter structure
	Oid						Oid for this query
	InformationBuffer		Buffer for information
	InformationBufferLength	Size of this buffer
	BytesWritten			Specifies how much info is written
	BytesNeeded				In case the buffer is smaller than what we need, tell them how much is needed

Return Value:

	Return code from the NdisRequest below.

--*/
{
	PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;
	NDIS_STATUS	Status = NDIS_STATUS_SUCCESS;
	UINT		i;
	NDIS_OID	MaskOid;
	PVOID		SourceBuffer;
	UINT		SourceBufferLength;
	ULONG		GenericUlong = 0;
	USHORT		GenericUshort;

    *BytesWritten = 0;
    *BytesNeeded = 0;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
			("OID = %lx\n", Oid));


	for (i = 0;i < LBSupportedOids; i++)
	{
		if (Oid == LBSupportedOidArray[i])
			break;
	}

	if ((i == LBSupportedOids) ||
		(((Oid & OID_TYPE) != OID_TYPE_GENERAL)		 &&
		 (((pAdapt->Medium == NdisMedium802_3)		 && ((Oid & OID_TYPE) != OID_TYPE_802_3)) ||
		  ((pAdapt->Medium == NdisMedium802_5)		 && ((Oid & OID_TYPE) != OID_TYPE_802_5)) ||
		  ((pAdapt->Medium == NdisMediumFddi)		 && ((Oid & OID_TYPE) != OID_TYPE_FDDI))  ||
		  ((pAdapt->Medium == NdisMediumLocalTalk)   && ((Oid & OID_TYPE) != OID_TYPE_LTALK)) ||
		  ((pAdapt->Medium == NdisMediumArcnet878_2) && ((Oid & OID_TYPE) != OID_TYPE_ARCNET)))))
	{
		return NDIS_STATUS_INVALID_OID;
	}

	//
	// Initialize these once, since this is the majority of cases.
	//

	SourceBuffer = (PVOID)&GenericUlong;
	SourceBufferLength = sizeof(ULONG);

	switch (Oid & OID_TYPE_MASK)
	{
	  case OID_TYPE_GENERAL_OPERATIONAL:
                switch (Oid)
		{
		  case OID_GEN_MAC_OPTIONS:
			GenericUlong = (ULONG)(NDIS_MAC_OPTION_NO_LOOPBACK);
			break;

		  case OID_GEN_SUPPORTED_LIST:
			SourceBuffer = LBSupportedOidArray;
			SourceBufferLength = LBSupportedOids * sizeof(ULONG);
			break;

		  case OID_GEN_HARDWARE_STATUS:
			GenericUlong = NdisHardwareStatusReady;
			break;

		  case OID_GEN_MEDIA_SUPPORTED:
		  case OID_GEN_MEDIA_IN_USE:
			GenericUlong = pAdapt->Medium;
			break;

		  case OID_GEN_MAXIMUM_LOOKAHEAD:
			GenericUlong = MAX_LOOKAHEAD;
			break;

		  case OID_GEN_MAXIMUM_FRAME_SIZE:
			GenericUlong = pAdapt->MediumMaxFrameLen;
			break;

		  case OID_GEN_LINK_SPEED:
			GenericUlong = pAdapt->MediumLinkSpeed;
			break;

		  case OID_GEN_TRANSMIT_BUFFER_SPACE:
			GenericUlong = pAdapt->MediumMaxPacketLen;
			break;

		  case OID_GEN_RECEIVE_BUFFER_SPACE:
			GenericUlong = pAdapt->MediumMaxPacketLen;
			break;

		  case OID_GEN_TRANSMIT_BLOCK_SIZE:
			GenericUlong = 1;
			break;

		  case OID_GEN_RECEIVE_BLOCK_SIZE:
			GenericUlong = 1;
			break;

		  case OID_GEN_VENDOR_ID:
			SourceBuffer = LBVendorId;
			SourceBufferLength = sizeof(LBVendorId);
			break;

		  case OID_GEN_VENDOR_DESCRIPTION:
			SourceBuffer = LBVendorDescription;
			SourceBufferLength = sizeof(LBVendorDescription);
			break;

		  case OID_GEN_CURRENT_PACKET_FILTER:
			GenericUlong = pAdapt->PacketFilter;
			break;

		  case OID_GEN_CURRENT_LOOKAHEAD:
			GenericUlong = pAdapt->MaxLookAhead;
			break;

		  case OID_GEN_DRIVER_VERSION:
			GenericUshort = (LOOP_MAJOR_VERSION << 8) + LOOP_MINOR_VERSION;
			SourceBuffer = &GenericUshort;
			SourceBufferLength = sizeof(USHORT);
			break;

		  case OID_GEN_MAXIMUM_TOTAL_SIZE:
			GenericUlong = pAdapt->MediumMaxPacketLen;
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
		break;

          case OID_TYPE_GENERAL_STATISTICS:
                MaskOid = (Oid & OID_INDEX_MASK) - 1;
                switch (Oid & OID_REQUIRED_MASK)
                {
                  case OID_REQUIRED_MANDATORY:
                        switch(Oid)
                        {
                   
                          case OID_GEN_XMIT_OK:
                                SourceBuffer = &(pAdapt->SendPackets);
                                SourceBufferLength = sizeof(ULONG);
                                break;
                      
                          default: 
                                ASSERT (MaskOid < GM_ARRAY_SIZE);
                                GenericUlong = pAdapt->GeneralMandatory[MaskOid];
                                break;
                        }
              
                        break;

                  default:
                        ASSERT(FALSE);
                        break;
                }
                break;

	  case OID_TYPE_802_3_OPERATIONAL:

		switch (Oid)
		{
		  case OID_802_3_PERMANENT_ADDRESS:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = ETH_LENGTH_OF_ADDRESS;
			break;
		  case OID_802_3_CURRENT_ADDRESS:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = ETH_LENGTH_OF_ADDRESS;
			break;

		  case OID_802_3_MAXIMUM_LIST_SIZE:
			GenericUlong = ETH_MAX_MULTICAST_ADDRESS;
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
		break;

	  case OID_TYPE_802_3_STATISTICS:

		switch (Oid)
		{
		  case OID_802_3_RCV_ERROR_ALIGNMENT:
		  case OID_802_3_XMIT_ONE_COLLISION:
		  case OID_802_3_XMIT_MORE_COLLISIONS:
			GenericUlong = 0;
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
		break;

	  case OID_TYPE_802_5_OPERATIONAL:

		switch (Oid)
		{
		  case OID_802_5_PERMANENT_ADDRESS:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = TR_LENGTH_OF_ADDRESS;
			break;

		  case OID_802_5_CURRENT_ADDRESS:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = TR_LENGTH_OF_ADDRESS;
			break;

		  case OID_802_5_LAST_OPEN_STATUS:
			GenericUlong = 0;
			break;

		  case OID_802_5_CURRENT_RING_STATUS:
			GenericUlong = NDIS_RING_SINGLE_STATION;
			break;

		  case OID_802_5_CURRENT_RING_STATE:
			GenericUlong = NdisRingStateOpened;
			break;

		  default:
			ASSERT(FALSE);
			break;

		}
		break;

	  case OID_TYPE_802_5_STATISTICS:

		switch (Oid)
		{
		  case OID_802_5_LINE_ERRORS:
		  case OID_802_5_LOST_FRAMES:
			GenericUlong = 0;
			break;

		  default:
			ASSERT(FALSE);
			break;
		}
		break;

	  case OID_TYPE_FDDI_OPERATIONAL:

		switch (Oid)
		{
		  case OID_FDDI_LONG_PERMANENT_ADDR:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = FDDI_LENGTH_OF_LONG_ADDRESS;
			break;

		  case OID_FDDI_LONG_CURRENT_ADDR:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = FDDI_LENGTH_OF_LONG_ADDRESS;
			break;

		  case OID_FDDI_LONG_MAX_LIST_SIZE:
			GenericUlong = FDDI_MAX_MULTICAST_LONG;
			break;

		  case OID_FDDI_SHORT_PERMANENT_ADDR:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = FDDI_LENGTH_OF_SHORT_ADDRESS;
			break;

		  case OID_FDDI_SHORT_CURRENT_ADDR:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = FDDI_LENGTH_OF_SHORT_ADDRESS;
			break;

		  case OID_FDDI_SHORT_MAX_LIST_SIZE:
			GenericUlong = FDDI_MAX_MULTICAST_SHORT;
			break;

		default:
			ASSERT(FALSE);
			break;
		}
		break;

  case OID_TYPE_LTALK_OPERATIONAL:

		switch(Oid)
		{
		  case OID_LTALK_CURRENT_NODE_ID:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = 1;
			break;

		default:
			ASSERT(FALSE);
			break;
		}
		break;

    case OID_TYPE_ARCNET_OPERATIONAL:
		switch(Oid)
		{
		  case OID_ARCNET_PERMANENT_ADDRESS:
			SourceBuffer = pAdapt->PermanentAddress;
			SourceBufferLength = 1;
			break;

		  case OID_ARCNET_CURRENT_ADDRESS:
			SourceBuffer = pAdapt->CurrentAddress;
			SourceBufferLength = 1;
			break;

		  default:
			ASSERT(FALSE);
			break;

		}
		break;

	  default:
		ASSERT(FALSE);
		break;
	}

	if (SourceBufferLength > InformationBufferLength)
	{
		*BytesNeeded = SourceBufferLength;
		return NDIS_STATUS_BUFFER_TOO_SHORT;
	}

	NdisMoveMemory(InformationBuffer, SourceBuffer, SourceBufferLength);
	*BytesWritten = SourceBufferLength;
	
    return(Status);
}


NDIS_STATUS
LBSetInformation(
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_OID				Oid,
	IN	PVOID					InformationBuffer,
	IN	ULONG					InformationBufferLength,
	OUT PULONG					BytesRead,
	OUT PULONG					BytesNeeded
	)
/*++

Routine Description:

	Miniport SetInfo handler.

Arguments:

	MiniportAdapterContext	Pointer to the adapter structure
	Oid						Oid for this query
	InformationBuffer		Buffer for information
	InformationBufferLength	Size of this buffer
	BytesRead				Specifies how much info is read
	BytesNeeded				In case the buffer is smaller than what we need, tell them how much is needed

Return Value:

	Return code from the NdisRequest below.

--*/
{
	PADAPTER	pAdapt = (PADAPTER)MiniportAdapterContext;
	NDIS_STATUS	Status = NDIS_STATUS_SUCCESS;

    *BytesRead = 0;
    *BytesNeeded = 0;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
			("SetInformation: OID = %lx\n", Oid));

    switch (Oid)
	{
	  case OID_GEN_CURRENT_PACKET_FILTER:
        if (InformationBufferLength != sizeof(ULONG))
		{
            Status = NDIS_STATUS_INVALID_DATA;
        }
		else
		{
			ULONG	PacketFilter;

			PacketFilter = *(UNALIGNED ULONG *)InformationBuffer;

			if (PacketFilter != (PacketFilter & pAdapt->MediumPacketFilters))
			{
				Status = NDIS_STATUS_NOT_SUPPORTED;
			}
			else
			{
				pAdapt->PacketFilter = PacketFilter;
				*BytesRead = InformationBufferLength;
			}
		}
        break;

	  case OID_GEN_CURRENT_LOOKAHEAD:
        if (InformationBufferLength != sizeof(ULONG))
		{
			Status = NDIS_STATUS_INVALID_DATA;
		}
		else
		{
			ULONG	CurrentLookahead;

			CurrentLookahead = *(UNALIGNED ULONG *)InformationBuffer;
	
			if (CurrentLookahead > MAX_LOOKAHEAD)
			{
				Status = NDIS_STATUS_INVALID_LENGTH;
			}
			else if (CurrentLookahead >= pAdapt->MaxLookAhead)
			{
				pAdapt->MaxLookAhead = CurrentLookahead;
				*BytesRead = sizeof(ULONG);
				Status = NDIS_STATUS_SUCCESS;
			}
		}
		break;

	  case OID_802_3_MULTICAST_LIST:
		if (pAdapt->Medium != NdisMedium802_3)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if ((InformationBufferLength % ETH_LENGTH_OF_ADDRESS) != 0)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_802_5_CURRENT_FUNCTIONAL:
		if (pAdapt->Medium != NdisMedium802_5)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if (InformationBufferLength != TR_LENGTH_OF_FUNCTIONAL)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_802_5_CURRENT_GROUP:
		if (pAdapt->Medium != NdisMedium802_5)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if (InformationBufferLength != TR_LENGTH_OF_FUNCTIONAL)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_FDDI_LONG_MULTICAST_LIST:
		if (pAdapt->Medium != NdisMediumFddi)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if ((InformationBufferLength % FDDI_LENGTH_OF_LONG_ADDRESS) != 0)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_FDDI_SHORT_MULTICAST_LIST:
		if (pAdapt->Medium != NdisMediumFddi)
		{
			Status = NDIS_STATUS_INVALID_OID;
			break;
		}

		if ((InformationBufferLength % FDDI_LENGTH_OF_SHORT_ADDRESS) != 0)
		{
			Status = NDIS_STATUS_INVALID_LENGTH;
			break;
		}
		break;

	  case OID_GEN_PROTOCOL_OPTIONS:
		Status = NDIS_STATUS_SUCCESS;
		break;

	  default:
		Status = NDIS_STATUS_INVALID_OID;
		break;
    }

	return(Status);
}

BOOLEAN
LBCheckForHang(
	IN	NDIS_HANDLE				MiniportAdapterContext
	)
{
	return FALSE;
}


NDIS_STATUS
LBTransferData(
	OUT PNDIS_PACKET			Packet,
	OUT PUINT					BytesTransferred,
	IN	NDIS_HANDLE				MiniportAdapterContext,
	IN	NDIS_HANDLE				MiniportReceiveContext,
	IN	UINT					ByteOffset,
	IN	UINT					BytesToTransfer
	)
{
	ASSERT (0);

	return NDIS_STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\adapter.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Adapter Adapter_h

@module Adapter.h |

    This module defines the interface to the <t MINIPORT_ADAPTER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Adapter_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.1 Adapter Overview |

    This section describes the interfaces defined in <f Adapter\.h>.

    This module isolates most the NDIS specific, logical adapter interfaces.
    It should require very little change if you follow this same overall
    architecture.  You should try to isolate your changes to the <t CARD_OBJECT>
    that is contained within the logical adapter <t MINIPORT_ADAPTER_OBJECT>.

    The driver assumes one <t MINIPORT_ADAPTER_OBJECT> per physical ISDN card.
    Each adapter contains a single logical D-Channel, and an aribitrary number
    of logical B-Channels.  It is up to you to map these logical interfaces to
    the physical interfaces on your card.  I have been pretty successful at
    using this model on a variety of ISDN hardware including BRI, PRI, T1, and
    E1.  By maintaining the logical abstraction, you can configure your cards
    and lines any way you choose, and then let Windows think they are B Channels.
    Even though they may be configured as bonded DS-0's on a T1 using robbed
    bit signalling.  Just hide those details in your Card, Port, and BChannel
    objects.

@end
*/

#ifndef _ADAPTER_H
#define _ADAPTER_H

#define MINIPORT_ADAPTER_OBJECT_TYPE    ((ULONG)'A')+\
                                        ((ULONG)'D'<<8)+\
                                        ((ULONG)'A'<<16)+\
                                        ((ULONG)'P'<<24)


/* @doc INTERNAL Adapter Adapter_h MINIPORT_ADAPTER_OBJECT


@struct MINIPORT_ADAPTER_OBJECT |

    This structure contains the data associated with a single Miniport
    adapter instance.  Here, Adapter is defined as the manager of specific
    Network Interface Card (NIC) installed under the NDIS wrapper.  This
    adapter is responsible for managing all interactions between the NIC and
    the host operating system using the NDIS library.

@comm

    This structure must contain a reference to all other objects being managed
    by this adapter object.  The adapter object is the only reference passed
    between NDIS and the Miniport.  This is the <t MiniportAdapterContext> we
    pass into <f NdisMSetAttributes> from <f MiniportInitialize>.  This value
    is passed as a parameter to the Miniport entry points called by the NDIS
    wrapper.

    One of these objects is created each time that our <f MiniportInitialize>
    routine is called.  The NDIS wrapper calls this routine once for each of
    our devices installed and enabled in the system.  In the case of a hot
    swappable NIC (e.g. PCMCIA) the adapter might come and go several times
    during a single Windows session.

*/

typedef struct MINIPORT_ADAPTER_OBJECT
{
#if DBG
    ULONG                       DbgFlags;                   // @field
    // Debug flags control how much debug is displayed in the checked version.
    // Put it at the front so we can set it easily with debugger.

    UCHAR                       DbgID[12];                  // @field
    // This field is initialized to an ASCII decimal string containing the
    // adapter instance number 1..N.  It is only used to output debug messages.
#endif
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'ADAP'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    NDIS_HANDLE                 MiniportAdapterHandle;      // @field
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    NDIS_HANDLE                 WrapperConfigurationContext;// @field
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.

    PCARD_OBJECT                pCard;                      // @field
    // Pointer to the hardware specific <t CARD_OBJECT>.  Created by
    // <f CardCreate>.

    PDCHANNEL_OBJECT            pDChannel;                  // @field
    // Pointer to the <t DCHANNEL_OBJECT> created by <f DChannelCreate>.
    // One for the entire NIC.

    ULONG                       NumBChannels;               // @field
    // The number of <t BCHANNEL_OBJECT>'s supported by the NIC.

    PBCHANNEL_OBJECT *          pBChannelArray;             // @field
    // An array of <t BCHANNEL_OBJECT>'s created by <f BChannelCreate>.
    // One entry for each logical BChannel on NIC.

    LIST_ENTRY                  BChannelAvailableList;      // @field
    // Linked list of available BChannels.
    // Keep listening BChannel's at the end of the available list,
    // so they can be easily allocated to incoming calls.
    // By using those on the front of the list for outgoing calls,
    // we can help insure that there will be a BChannel available for
    // an incoming call.  But still, we may end up using a listening
    // BChannel for an outgoing call, and that's okay; we're just trying
    // to be prudent with the allocation scheme.

    ULONG                       NumLineOpens;               // @field
    // The number of line open calls currently on this adapter.

    NDIS_SPIN_LOCK              TransmitLock;               // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the transmit queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  TransmitPendingList;        // @field
    // Packets waiting to be sent when the controller is available.
    // See <t NDIS_PACKET>.

    LIST_ENTRY                  TransmitCompleteList;       // @field
    // Packets waiting for completion processing.  After the packet is
    // transmitted, the protocol stack is given an indication.
    // See <t NDIS_PACKET>.

    NDIS_SPIN_LOCK              ReceiveLock;                // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the receive queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  ReceiveCompleteList;        // @field
    // Buffers waiting to be processed by the

    NDIS_SPIN_LOCK              EventLock;                  // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the event queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  EventList;                  // @field
    // driver callback events waiting to be processed.
    // See <t BCHANNEL_EVENT_OBJECT>.

    NDIS_MINIPORT_TIMER         EventTimer;                 // @field
    // This timer is used to schedule the event processing routine to run
    // when the system reaches a quiescent state.

    ULONG                       NextEvent;                  // @field
    // Where do we store the next event.

    long                        NestedEventHandler;         // @field
    // Keeps track of entry to and exit from the event handler.

    long                        NestedDataHandler;          // @field
    // Keeps track of entry to and exit from the Tx/Rx handlers.

    NDIS_HANDLE                 NdisAfHandle;               // @field
    // Used to store the NDIS address family handle passed into
    // <f ProtocolCmOpenAf>.

    ULONG                       Flags;
#   define ADAP_PENDING_SAP_CLOSE   0x00000002

    NDIS_WAN_CO_INFO            WanInfo;                    // @field
    // A copy of our <t NDIS_WAN_CO_INFO> structure is setup at init
    // time and doesn't change.

    BOOLEAN                     NeedStatusCompleteIndication;   // @field
    // This flag indicates whether or not <f NdisMIndicateStatusComplete>
    // needs to be called after the completion of requests or event processing.
    // This is set TRUE if <f NdisMIndicateStatus> is called while
    // processing a request or event.

    ULONG                       TotalRxBytes;               // @field
    // Total bytes read by driver during this session.

    ULONG                       TotalTxBytes;               // @field
    // Total bytes written by driver during this session.

    ULONG                       TotalRxPackets;             // @field
    // Total packets read by driver during this session.

    ULONG                       TotalTxPackets;             // @field
    // Total packets written by driver during this session.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} MINIPORT_ADAPTER_OBJECT;

extern PMINIPORT_ADAPTER_OBJECT g_Adapters[MAX_ADAPTERS];

/*


    Function prototypes.

*/

NDIS_STATUS AdapterCreate(
    OUT PMINIPORT_ADAPTER_OBJECT *ppAdapter,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              WrapperConfigurationContext
    );

void AdapterDestroy(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

NDIS_STATUS AdapterInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

#endif // _ADAPTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\adapter.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Adapter Adapter_c

@module Adapter.c |

    This module implements the interface to the <t MINIPORT_ADAPTER_OBJECT>.
    Supports the high-level adapter control functions used by the NDIS WAN
    Minport driver.

@comm

    This module isolates most the NDIS specific, logical adapter interfaces.
    It should require very little change if you follow this same overall
    architecture.  You should try to isolate your changes to the <t CARD_OBJECT>
    that is contained within the logical adapter <t MINIPORT_ADAPTER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Adapter_c

@end

*/

#define  __FILEID__             MINIPORT_ADAPTER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


PMINIPORT_ADAPTER_OBJECT        g_Adapters[MAX_ADAPTERS]    // @globalv
// Keeps track of all the <t MINIPORT_ADAPTER_OBJECT>s created by the driver.
                                = { 0 };

DBG_STATIC ULONG                g_AdapterInstanceCounter    // @globalv
// Keeps track of how many <t MINIPORT_ADAPTER_OBJECT>s are created and
// stored in the <p g_Adapters> array.
                                = 0;

DBG_STATIC UCHAR                g_AnsiDriverName[]          // @globalv
// ANSI string used to identify the driver to the system; usually defined
// as VER_PRODUCT_STR.
                                = VER_PRODUCT_STR;

DBG_STATIC UCHAR                g_AnsiVendorDescription[]   // @globalv
// ANSI string used to identify the vendor's device to the system; usually
// defined as VER_DEVICE_STR " Adapter".
                                = VER_DEVICE_STR " Adapter";


/* @doc INTERNAL EXTERNAL Adapter Adapter_c g_AdapterParameters


@topic 5.1 Adapter Parameters |

    This section describes the registry parameters read into the
    <t MINIPORT_ADAPTER_OBJECT>.

@globalv DBG_STATIC <t PARAM_TABLE> | g_AdapterParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t MINIPORT_ADAPTER_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t MINIPORT_ADAPTER_OBJECT>
    you will need to modify <f AdapterReadParameters> and add the parameter
    definitions to the <f g_AdapterParameters> table.

@flag <f DebugFlags> (OPTIONAL) (DEBUG VERSION ONLY) |

    This DWORD parameter allows you to control how much debug information is
    displayed to the debug monitor.  This is a bit OR'd flag using the values
    defined in <t DBG_FLAGS>.  This value is not used by the released version
    of the driver.<nl>

*/

DBG_STATIC PARAM_TABLE  g_AdapterParameters[] =
{
#if DBG
    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                DbgFlags, PARAM_DebugFlags,
                FALSE, NdisParameterHexInteger, 0,
                DBG_DEFAULTS | DBG_TAPICALL_ON, 0, 0xffffffff),
                // TODO: Change the debug flags to meet your needs.
#endif
    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL Adapter Adapter_c AdapterReadParameters


@func

    <f AdapterReadParameters> reads the adapter parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f AdapterCreate>.

    <f Note>:
    If you add any registry based data members to <t MINIPORT_ADAPTER_OBJECT>
    you will need to modify <f AdapterReadParameters> and add the parameter
    definitions to the <f g_AdapterParameters> table.

@rdesc

    <f AdapterReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS AdapterReadParameters(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterReadParameters")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Parse the registry parameters.
    */
    Result = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pAdapter,
                    g_AdapterParameters
                    );

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pAdapter->TODO)
        {
            DBG_ERROR(DbgInfo,("Invalid value 'TODO'\n",
                        pAdapter->TODO));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pAdapter->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Result = NDIS_STATUS_FAILURE;
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterCreateObjects


@func

    <f AdapterCreateObjects> calls the create routines for all the objects
    contained in <t MINIPORT_ADAPTER_OBJECT>.  This should only be called
    by <f AdapterCreate>.

    <f Note>:
    If you add any new objects to <t MINIPORT_ADAPTER_OBJECT> you will need
    to modify <f AdapterCreateObjects> and <f AdapterDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f AdapterCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS AdapterCreateObjects(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterCreateObjects")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ULONG                       Index;
    // Loop counter.

    ULONG                       NumBChannels;
    // The number of BChannels supported by the NIC.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Create the Card object.
    */
    Result = CardCreate(&pAdapter->pCard, pAdapter);

    /*
    // Create the DChannel object.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        Result = DChannelCreate(&pAdapter->pDChannel, pAdapter);
    }

    /*
    // Allocate space for the BChannels.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        NumBChannels = CardNumChannels(pAdapter->pCard);

        Result = ALLOCATE_MEMORY(pAdapter->pBChannelArray,
                                 sizeof(PVOID) * NumBChannels,
                                 pAdapter->MiniportAdapterHandle);
    }

    /*
    // Create the BChannel objects.
    */
    InitializeListHead(&pAdapter->BChannelAvailableList);
    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < NumBChannels; Index++)
    {
        Result = BChannelCreate(&pAdapter->pBChannelArray[Index],
                                Index,
                                pAdapter);

        /*
        // Put entry on available list.
        */
        InsertTailList(&pAdapter->BChannelAvailableList,
                       &pAdapter->pBChannelArray[Index]->LinkList);

        /*
        // Keep track of how many are created.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            pAdapter->NumBChannels++;
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterCreate


@func

    <f AdapterCreate> allocates memory for a <t MINIPORT_ADAPTER_OBJECT> and
    then initializes the data members to their starting state.
    If successful, <p ppAdapter> will be set to point to the newly created
    <t MINIPORT_ADAPTER_OBJECT>.  Otherwise, <p ppAdapter> will be set to
    NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f AdapterDestroy> must be called to
    release the <t MINIPORT_ADAPTER_OBJECT> created by this function.

@rdesc

    <f AdapterCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS AdapterCreate(
    OUT PMINIPORT_ADAPTER_OBJECT *ppAdapter,                // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t MINIPORT_ADAPTER_OBJECT>.

    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    IN NDIS_HANDLE              WrapperConfigurationContext // @parm
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.
    )
{
    DBG_FUNC("AdapterCreate")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // Pointer to our newly allocated object.

    DBG_ENTER(DbgInfo);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppAdapter = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pAdapter, MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pAdapter->ObjectType = MINIPORT_ADAPTER_OBJECT_TYPE;
        pAdapter->ObjectID = ++g_AdapterInstanceCounter;
        ASSERT(g_AdapterInstanceCounter <= MAX_ADAPTERS);
        if (g_AdapterInstanceCounter <= MAX_ADAPTERS)
        {
            g_Adapters[g_AdapterInstanceCounter-1] = pAdapter;
        }

        /*
        // We use the instance number in debug messages to help when debugging
        // with multiple adapters.
        */
#if DBG
        pAdapter->DbgID[0] = (UCHAR) ((pAdapter->ObjectID & 0x0F) + '0');
        pAdapter->DbgID[1] = ':';
        ASSERT (sizeof(VER_TARGET_STR) <= sizeof(pAdapter->DbgID)-2);
        memcpy(&pAdapter->DbgID[2], VER_TARGET_STR, sizeof(VER_TARGET_STR));
#endif
        /*
        // Initialize the member variables to their default settings.
        */
        pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;
        pAdapter->WrapperConfigurationContext = WrapperConfigurationContext;

        /*
        // Allocate spin locks to use for MUTEX queue protection.
        */
        NdisAllocateSpinLock(&pAdapter->EventLock);
        NdisAllocateSpinLock(&pAdapter->TransmitLock);
        NdisAllocateSpinLock(&pAdapter->ReceiveLock);

        /*
        // Parse the registry parameters.
        */
        Result = AdapterReadParameters(pAdapter);
#if DBG
        // DbgInfo->DbgFlags = pAdapter->DbgFlags;
#endif // DBG
        DBG_DISPLAY(("NOTICE: Adapter#%d=0x%X DbgFlags=0x%X\n",
                    pAdapter->ObjectID, pAdapter, pAdapter->DbgFlags));

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = AdapterCreateObjects(pAdapter);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppAdapter = pAdapter;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            AdapterDestroy(pAdapter);
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterDestroyObjects


@func

    <f AdapterDestroyObjects> calls the destroy routines for all the objects
    contained in <t MINIPORT_ADAPTER_OBJECT>.  This should only be called
    by <f AdapterDestroy>.

    <f Note>:
    If you add any new objects to <t MINIPORT_ADAPTER_OBJECT> you will need
    to modify <f AdapterCreateObjects> and <f AdapterDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void AdapterDestroyObjects(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterDestroyObjects")

    UINT                        NumBChannels;
    // The number of BChannels supported by the NIC.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Destroy the BChannel objects.
    */
    NumBChannels = pAdapter->NumBChannels;
    while (NumBChannels--)
    {
        BChannelDestroy(pAdapter->pBChannelArray[NumBChannels]);
    }
    pAdapter->NumBChannels = 0;

    /*
    // Free space for the BChannels.
    */
    if (pAdapter->pBChannelArray)
    {
        NumBChannels = CardNumChannels(pAdapter->pCard);
        FREE_MEMORY(pAdapter->pBChannelArray, sizeof(PVOID) * NumBChannels);
    }

    /*
    // Destroy the DChannel object.
    */
    DChannelDestroy(pAdapter->pDChannel);

    /*
    // Destroy the Card object.
    */
    CardDestroy(pAdapter->pCard);

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Adapter Adapter_c AdapterDestroy


@func

    <f AdapterDestroy> frees the memory for this <t MINIPORT_ADAPTER_OBJECT>.
    All memory allocated by <f AdapterCreate> will be released back to the OS.

*/

void AdapterDestroy(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterDestroy")

    DBG_ENTER(DbgInfo);

    if (pAdapter)
    {
        ASSERT(pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

        /*
        // Release all objects allocated within this object.
        */
        AdapterDestroyObjects(pAdapter);

        if (pAdapter->EventLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->EventLock);
        }

        if (pAdapter->TransmitLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->TransmitLock);
        }

        if (pAdapter->ReceiveLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->ReceiveLock);
        }

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        if (pAdapter->ObjectType <= MAX_ADAPTERS)
        {
            g_Adapters[pAdapter->ObjectType-1] = NULL;
        }
        pAdapter->ObjectType = 0;
        FREE_OBJECT(pAdapter);
    }

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Adapter Adapter_c AdapterInitialize


@func

    <f AdapterInitialize> prepares the <t MINIPORT_ADAPTER_OBJECT> and all
    its sub-components for use by the NDIS wrapper.  Upon successful
    completion of this routine, the NIC will be ready to accept requests
    from the NDIS wrapper.

@rdesc

    <f AdapterInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS AdapterInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("AdapterInitialize")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    ULONG                       Index;
    // Loop counter.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(pAdapter);

    /*
    // Initialize the WAN information structure to match the capabilities of
    // the adapter.
    */
    pAdapter->WanInfo.MaxFrameSize   = pAdapter->pCard->BufferSize - NDISWAN_EXTRA_SIZE;
    pAdapter->WanInfo.MaxSendWindow  = pAdapter->pCard->TransmitBuffersPerLink;

    /*
    // We only support PPP, and multi-link PPP framing.
    */
    pAdapter->WanInfo.FramingBits    = PPP_FRAMING |
                                       PPP_MULTILINK_FRAMING;

    /*
    // This value is ignored by this driver, but its default behavior is such
    // that all these control bytes would appear to be handled transparently.
    */
    pAdapter->WanInfo.DesiredACCM    = 0;

    /*
    // Initialize the packet management queues to empty.
    */
    InitializeListHead(&pAdapter->EventList);
    InitializeListHead(&pAdapter->TransmitPendingList);
    InitializeListHead(&pAdapter->TransmitCompleteList);
    InitializeListHead(&pAdapter->ReceiveCompleteList);

    /*
    // Setup the timer event handler.
    */
    NdisMInitializeTimer(&pAdapter->EventTimer,
                         pAdapter->MiniportAdapterHandle,
                         MiniportTimer,
                         pAdapter);

    /*
    // Initialize the DChannel object.
    */
    DChannelInitialize(pAdapter->pDChannel);

    /*
    // Initialize all the BChannel objects.
    */
    for (Index = 0; Index < pAdapter->NumBChannels; ++Index)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, Index);
        BChannelInitialize(pBChannel);
    }

    /*
    // Now, we can initialize the Card object.
    */
    Result = CardInitialize(pAdapter->pCard);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\bchannel.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL BChannel BChannel_c

@module BChannel.c |

    This module implements the interface to the <t BCHANNEL_OBJECT>.
    Supports the high-level channel control functions used by the CONDIS WAN
    Miniport driver.

@comm

    This module isolates most the channel specific interfaces.  It will require
    some changes to accomodate your hardware device's channel access methods.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | BChannel_c

@end

*/

#define  __FILEID__             BCHANNEL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                g_BChannelInstanceCounter   // @globalv
// Keeps track of how many <t BCHANNEL_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL BChannel BChannel_c g_BChannelParameters


@topic 5.3 BChannel Parameters |

    This section describes the registry parameters read into the
    <t BCHANNEL_OBJECT>.

@globalv PARAM_TABLE | g_BChannelParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t BCHANNEL_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t BCHANNEL_OBJECT>
    you will need to modify <f BChannelReadParameters> and add the parameter
    definitions to the <f g_BChannelParameters> table.

*/

DBG_STATIC PARAM_TABLE          g_BChannelParameters[] =
{
    PARAM_ENTRY(BCHANNEL_OBJECT,
                TODO, PARAM_TODO,
                FALSE, NdisParameterInteger, 0,
                0, 0, 0),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL BChannel BChannel_c BChannelReadParameters


@func

    <f BChannelReadParameters> reads the BChannel parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f BChannelCreate>.

@rdesc

    <f BChannelReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

    <f Note>:
    If you add any registry based data members to <t BCHANNEL_OBJECT>
    you will need to modify <f BChannelReadParameters> and add the parameter
    definitions to the <f g_BChannelParameters> table.

*/

DBG_STATIC NDIS_STATUS BChannelReadParameters(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pBChannel,
                    g_BChannelParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pBChannel->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pBChannel->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL BChannel BChannel_c BChannelCreateObjects


@func

    <f BChannelCreateObjects> calls the create routines for all the objects
    contained in <t BCHANNEL_OBJECT>.  This should only be called
    by <f BChannelCreate>.

    <f Note>:
    If you add any new objects to <t BCHANNEL_OBJECT> you will need
    to modify <f BChannelCreateObjects> and <f BChannelDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f BChannelCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS BChannelCreateObjects(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelCreate


@func

    <f BChannelCreate> allocates memory for a <t BCHANNEL_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppBChannel> will be set to point to the newly created
    <t BCHANNEL_OBJECT>.  Otherwise, <p ppBChannel> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f BChannelDestroy> must be called to
    release the <t BCHANNEL_OBJECT> created by this function.

@rdesc

    <f BChannelCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelCreate(
    OUT PBCHANNEL_OBJECT *      ppBChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t BCHANNEL_OBJECT>.

    IN ULONG                    BChannelIndex,              // @parm
    // Index into the pBChannelArray.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.
    )
{
    DBG_FUNC("BChannelCreate")

    PBCHANNEL_OBJECT            pBChannel;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppBChannel = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pBChannel, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pBChannel->ObjectType = BCHANNEL_OBJECT_TYPE;
        pBChannel->ObjectID = ++g_BChannelInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pBChannel->pAdapter = pAdapter;
        pBChannel->BChannelIndex = BChannelIndex;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = BChannelReadParameters(pBChannel);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = BChannelCreateObjects(pBChannel);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            InitializeListHead(&pBChannel->LinkList);
            *ppBChannel = pBChannel;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            BChannelDestroy(pBChannel);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelDestroyObjects


@func

    <f BChannelDestroyObjects> calls the destroy routines for all the objects
    contained in <t BCHANNEL_OBJECT>.  This should only be called by
    <f BChannelDestroy>.

    <f Note>:
    If you add any new objects to <t PBCHANNEL_OBJECT> you will need to
    modify <f BChannelCreateObjects> and <f BChannelDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void BChannelDestroyObjects(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here
    if (pBChannel->pInCallParms != NULL)
    {
        FREE_MEMORY(pBChannel->pInCallParms, pBChannel->CallParmsSize);
        pBChannel->pInCallParms = NULL;
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelDestroy


@func

    <f BChannelDestroy> frees the memory for this <t BCHANNEL_OBJECT>.
    All memory allocated by <f BChannelCreate> will be released back to the
    OS.

*/

void BChannelDestroy(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pBChannel)
    {
        ASSERT(pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        BChannelDestroyObjects(pBChannel);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pBChannel->ObjectType = 0;
        FREE_OBJECT(pBChannel);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL BChannel BChannel_c BChannelInitialize


@func

    <f BChannelInitialize> resets all the internal data members contained
    in <t BCHANNEL_OBJECT> back to their initial state.

    <f Note>:
    If you add any new members to <t BCHANNEL_OBJECT> you will need to
    modify <f BChannelInitialize> to initialize your new data mamebers.

*/

void BChannelInitialize(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelInitialize")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    /*
    // Initially, the BChannel is not allocated to anyone and these fields
    // must be reset.
    */
    ASSERT(pBChannel->NdisVcHandle == NULL);

    /*
    // Setup the static features of the link.
    */
    pBChannel->LinkSpeed         = _64KBPS;
    pBChannel->BearerModesCaps   = LINEBEARERMODE_DATA
                                 // | LINEBEARERMODE_VOICE
                                 ;
    pBChannel->MediaModesCaps    = LINEMEDIAMODE_DIGITALDATA
                                 | LINEMEDIAMODE_UNKNOWN
                                 // | LINEMEDIAMODE_DATAMODEM
                                 ;

    /*
    // Initialize the TAPI event capabilities supported by the link.
    */
    pBChannel->DevStatesCaps     = LINEDEVSTATE_RINGING
                                 | LINEDEVSTATE_CONNECTED
                                 | LINEDEVSTATE_DISCONNECTED
                                 | LINEDEVSTATE_INSERVICE
                                 | LINEDEVSTATE_OUTOFSERVICE
                                 | LINEDEVSTATE_OPEN
                                 | LINEDEVSTATE_CLOSE
                                 | LINEDEVSTATE_REINIT
                                 ;
    pBChannel->AddressStatesCaps = 0;
    pBChannel->CallStatesCaps    = LINECALLSTATE_IDLE
                                 | LINECALLSTATE_DIALING
                                 | LINECALLSTATE_OFFERING
                                 | LINECALLSTATE_CONNECTED
                                 | LINECALLSTATE_DISCONNECTED
                                 ;

    /*
    // Set the TransmitBusyList and ReceivePendingList to empty.
    */
    InitializeListHead(&pBChannel->TransmitBusyList);
    InitializeListHead(&pBChannel->ReceivePendingList);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelOpen


@func

    <f BChannelOpen> makes the BChannel connection ready to transmit and
    receive data.

@rdesc

    <f BChannelOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelOpen(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_HANDLE              NdisVcHandle                // @parm
    // Handle by which NDIS wrapper will refer to this BChannel.
    )
{
    DBG_FUNC("BChannelOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    if (!pBChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening BChannel #%d\n",
                   pBChannel->ObjectID));

        /*
        // The NdisVcHandle field is used to associate this BChannel with
        // the CoNdis Wrapper.  Reset all the state information for
        // this BChannel.
        */
        pBChannel->NdisVcHandle      = NdisVcHandle;
        pBChannel->CallClosing       = FALSE;
        pBChannel->CallState         = 0;
        pBChannel->MediaMode         = 0;
        pBChannel->TotalRxPackets    = 0;

        /*
        // Initialize the default BChannel information structure.  It may be
        // changed later by MiniportCoRequest.
        */
        pBChannel->WanLinkInfo.MaxSendFrameSize    = pAdapter->WanInfo.MaxFrameSize;
        pBChannel->WanLinkInfo.MaxRecvFrameSize    = pAdapter->WanInfo.MaxFrameSize;
        pBChannel->WanLinkInfo.SendFramingBits     = pAdapter->WanInfo.FramingBits;
        pBChannel->WanLinkInfo.RecvFramingBits     = pAdapter->WanInfo.FramingBits;
        pBChannel->WanLinkInfo.SendCompressionBits = 0;
        pBChannel->WanLinkInfo.RecvCompressionBits = 0;
        pBChannel->WanLinkInfo.SendACCM            = pAdapter->WanInfo.DesiredACCM;
        pBChannel->WanLinkInfo.RecvACCM            = pAdapter->WanInfo.DesiredACCM;

#if defined(SAMPLE_DRIVER)
        // Sample just tells tapi that the line is connected and in service.
#else  // SAMPLE_DRIVER
        // TODO - Add code here
#endif // SAMPLE_DRIVER

        pBChannel->IsOpen = TRUE;
    }
    else
    {
        Result = NDIS_STATUS_FAILURE;
        DBG_ERROR(pAdapter,("BChannel #%d already opened\n",
                  pBChannel->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelClose


@func

    <f BChannelClose> closes the given B-channel.

*/

void BChannelClose(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    if (pBChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing BChannel #%d\n",
                   pBChannel->ObjectID));

        /*
        // Make sure call is cleared and B channel is disabled.
        */
        DChannelCloseCall(pAdapter->pDChannel, pBChannel);

        // TODO - Add code here

        pBChannel->Flags        = 0;
        pBChannel->CallState    = 0;
        pBChannel->NdisVcHandle = NULL;
        pBChannel->IsOpen       = FALSE;
    }
    else
    {
        DBG_ERROR(pAdapter,("BChannel #%d already closed\n",
                  pBChannel->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\pnptst\netpnp.c ===
typedef	unsigned int	UINT;

#include <ntosp.h>
#include <stdio.h>
#include <string.h>
#include <wchar.h>
#include <ndispnp.h>

WCHAR				LCBuf[256];
WCHAR				UCBuf[256];
WCHAR				BLBuf[4096];
CHAR				ASBuf[128];
NIC_STATISTICS	    Stats;
UNICODE_STRING		LC = {0, sizeof(LCBuf), LCBuf};
UNICODE_STRING		UC = {0, sizeof(UCBuf), UCBuf};
UNICODE_STRING		BL = {0, sizeof(BLBuf), BLBuf};
ANSI_STRING			AS = {0, sizeof(ASBuf), ASBuf};
PNDIS_ENUM_INTF		Interfaces = (PNDIS_ENUM_INTF)BLBuf;
int					Layer = -1, Operation = -1;
extern	LONG		xxGetLastError();
char *				Ops[9] = { "", "BIND", "UNBIND", "RECONFIGURE", "", "", "", "STATS", "ENUM"};
char *				Intf[3] = { "", "NDIS", "TDI" };
#define	STATS		0x7
#define	ENUM		0x8
#define	MACADDR		0x9

void
help(
	void
	)
{
	fprintf(stderr, "netpnp -u<UpperComponent> -l<LowerComponent> -i<Interface> -a<Action> [-b<BindList>]\n");
	fprintf(stderr, "       where Interface is either NDIS or TDI\n");
	fprintf(stderr, "       where Action is BIND, UNBIND, ENUM, STATS, MACADDR or RECONFIGURE\n");
	fprintf(stderr, "  e.g. netpnp -uTCPIP -l\\Device\\{GUID} -iNDIS -aUNBIND\n");
	fprintf(stderr, "  e.g. netpnp -uSRV -l\\Device\\NETBT_{GUID} -iTDI -aBIND -b\"\\Device\\NETBT_{GUID} \\Device\\NETBT_{GUID}\n");
	fprintf(stderr, "  e.g. netpnp -l\\Device\\{GUID} -iNDIS -aSTATS\n");
}

BOOLEAN
icmp(
	char	*s1,
	char	*s2
	)
{
	char c1, c2;

	while (((c1 = *s1) != 0) && ((c2 = *s2) != 0))
	{
		c1 |= 0x20; c2 |= 0x20;
		if (c1 != c2)
		{
			break;
		}
		s1 ++; s2++;
	}

	return((*s1 == 0) && (*s2 == 0));
}


BOOLEAN
GetOptions(
    int     argc,
    char ** argv
	)
{
	int		i;
	char	c;

	if (argc < 2)
	{
		help();
		return(FALSE);
	}

	//
	// Default upper and lower component to NONE
	//
	UC.Length = 0;
	LC.Length = 0;

	for (i = 1; i < argc; i++)
	{
		c = argv[i][0];
		if (c == '-' || c == '/')
		{
			c = argv[i][1];
			switch (c)
			{
				case 'u':
				case 'U':
					RtlInitAnsiString(&AS, &argv[i][2]);
					RtlAnsiStringToUnicodeString(&UC, &AS, FALSE);
					break;
	
				case 'l':
				case 'L':
					RtlInitAnsiString(&AS, &argv[i][2]);
					RtlAnsiStringToUnicodeString(&LC, &AS, FALSE);
					break;
	
				case 'i':
				case 'I':
					if (icmp(&argv[i][2], "ndis"))
					{
						Layer = NDIS;
					}
					else if (icmp(&argv[i][2], "tdi"))
					{
						Layer = TDI;
					}
					break;
	
				case 'a':
				case 'A':
					if (icmp(&argv[i][2], "bind"))
					{
						Operation = BIND;
					}
					else if (icmp(&argv[i][2], "unbind"))
					{
						Operation = UNBIND;
					}
					else if (icmp(&argv[i][2], "reconfigure"))
					{
						Operation = RECONFIGURE;
					}
					else if (icmp(&argv[i][2], "stats"))
					{
						Operation = STATS;
					}
					else if (icmp(&argv[i][2], "enum"))
					{
						Operation = ENUM;
					}
					else if (icmp(&argv[i][2], "macaddr"))
					{
						Operation = MACADDR;
					}
					break;
	
				case 'b':
				case 'B':
					RtlInitAnsiString(&AS, &argv[i][2]);
					RtlAnsiStringToUnicodeString(&BL, &AS, FALSE);
					//
					// Convert the space separated strings to MULTI_SZ format.
					//
					for (i = 0; i < BL.Length; i++)
					{
						if (BL.Buffer[i] == L' ')
							BL.Buffer[i] = 0;
					}
					break;
	
				case '?':
				default:
					help();
					break;
			}
		}
	}

	if ((Operation <= 0) ||
		(Operation < STATS) && ((Layer <= 0) || (LC.Length == 0)))
	{
		help();
		fprintf(stderr, "Current parameters:\n");
		fprintf(stderr, "UpperComp %Z\n", &UC);
		fprintf(stderr, "LowerComp %Z\n", &LC);
		fprintf(stderr, "BindList %Z\n", &BL);
		fprintf(stderr, "Action %s\n", (Operation <= 0) ? "INVALID" : Ops[Operation]);
		fprintf(stderr, "Interface %s\n", (Layer <= 0) ? "INVALID" : Intf[Layer]);
		return(FALSE);
	}

	return(TRUE);
}

VOID
UTOA(
	IN	PUNICODE_STRING	U,
	OUT	PANSI_STRING	A
	)
{
	A->Length = 0;
	RtlUnicodeStringToAnsiString(A, U, FALSE);
}

#define	SECS_PER_DAY	(24*60*60)
#define	SECS_PER_HOUR	(60*60)
#define	SECS_PER_MIN	60

VOID _cdecl
main(
    int     argc,
    char ** argv
	)
{
	NTSTATUS		Status;
	UINT			i;

	if (!GetOptions(argc, argv))
		return;
	
	if (Operation == ENUM)
	{
		if (NdisEnumerateInterfaces(Interfaces, sizeof(BLBuf)))
		{
			ANSI_STRING	A;
			UCHAR		Buf[256];

			A.MaximumLength = sizeof(Buf);
			A.Buffer = Buf;

			for (i = 0; i < Interfaces->TotalInterfaces; i++)
			{
				UTOA(&Interfaces->Interface[i].DeviceName, &A),
				fprintf(stderr, "Device: %s\n\t",
						A.Buffer);
				UTOA(&Interfaces->Interface[i].DeviceDescription, &A);
				fprintf(stderr, "Description: %s\n",
						A.Buffer);
			}
		}
		else
		{
			Status = xxGetLastError();
			fprintf(stderr, "Enumerate failed %lx\n", Status);
		}
	}
	else if (Operation == MACADDR)
	{
		UCHAR	MacAddr[6];
		UCHAR	PMacAddr[6];
		UCHAR	VendorId[3];
		UINT	i;

		if (NdisQueryHwAddress(&LC, MacAddr, PMacAddr, VendorId))
		{
			fprintf(stderr, "HW Address:");
			for (i = 0; i < 5; i++)
			{
				fprintf(stderr, "%02x-", MacAddr[i]);
			}
			fprintf(stderr, "%02x\n", MacAddr[i]);

			fprintf(stderr, "Vendor Id:");
			for (i = 0; i < 2; i++)
			{
				fprintf(stderr, "%02x-", VendorId[i]);
			}
			fprintf(stderr, "%02x\n", VendorId[i]);
		}
		else
		{
			Status = xxGetLastError();
			fprintf(stderr, "Operation failed %lx\n", Status);
		}
	}
	else if (Operation == STATS)
	{
		Stats.Size = sizeof(NIC_STATISTICS);
		if (NdisQueryStatistics(&LC, &Stats))
		{
			fprintf(stderr, "Device Status:      %s\n",
					(Stats.DeviceState == DEVICE_STATE_CONNECTED) ? "On" : "Off");
			fprintf(stderr, "Link Status:        %s\n",
					(Stats.MediaState == MEDIA_STATE_CONNECTED) ? "On" : "Off");

			fprintf(stderr, "Init Time   :       %d ms\n", Stats.InitTime);
			fprintf(stderr, "Connect Time:       ");
			if (Stats.ConnectTime > SECS_PER_DAY)
			{
				fprintf(stderr, "%d days, ", Stats.ConnectTime / SECS_PER_DAY);
				Stats.ConnectTime %= SECS_PER_DAY;
			}
			fprintf(stderr, "%02d:", Stats.ConnectTime / SECS_PER_HOUR);
			Stats.ConnectTime %= SECS_PER_HOUR;
			fprintf(stderr, "%02d:", Stats.ConnectTime / SECS_PER_MIN);
			Stats.ConnectTime %= SECS_PER_MIN;
			fprintf(stderr, "%02d\n", Stats.ConnectTime);

            Stats.LinkSpeed *= 100;
			if (Stats.LinkSpeed >= 1000000000)
			  fprintf(stderr, "Media Speed:        %d Gbps\n", Stats.LinkSpeed / 1000000);
			else if (Stats.LinkSpeed >= 1000000)
			  fprintf(stderr, "Media Speed:        %d Mbps\n", Stats.LinkSpeed / 1000000);
			else if (Stats.LinkSpeed >= 1000)
			  fprintf(stderr, "Media Speed:        %d Kbps\n", Stats.LinkSpeed / 1000);
			else
			  fprintf(stderr, "Media Speed:        %d bps\n", Stats.LinkSpeed);

			fprintf(stderr, "\n");

			fprintf(stderr, "Packets Sent:       %I64d\n", Stats.PacketsSent);
			fprintf(stderr, "Bytes Sent:         %I64d\n", Stats.BytesSent);

			fprintf(stderr, "\n");

			fprintf(stderr, "Packets Received:   %I64d\n", Stats.PacketsReceived);
			fprintf(stderr, "Directed Pkts Recd: %I64d\n", Stats.DirectedPacketsReceived);
			fprintf(stderr, "Bytes Received:     %I64d\n", Stats.BytesReceived);
			fprintf(stderr, "Directed Bytes Recd:%I64d\n", Stats.DirectedBytesReceived);

			fprintf(stderr, "\n");

			if (Stats.PacketsSendErrors != 0)
				fprintf(stderr, "Packets SendError:  %d\n", Stats.PacketsSendErrors);
			if (Stats.PacketsReceiveErrors != 0)
				fprintf(stderr, "Packets RecvError:  %d\n", Stats.PacketsReceiveErrors);
			if (Stats.ResetCount != 0)
				fprintf(stderr, "Reset Count      :  %d\n", Stats.ResetCount);
			if (Stats.MediaSenseConnectCount != 0)
				fprintf(stderr, "Media Connects   :  %d\n", Stats.MediaSenseConnectCount);
			if (Stats.MediaSenseDisconnectCount != 0)
				fprintf(stderr, "Media Disconnects:  %d\n", Stats.MediaSenseDisconnectCount);
		}
		else
		{
			Status = xxGetLastError();
			fprintf(stderr, "GetStats failed %lx\n", Status);
		}
	}
	else if (!NdisHandlePnPEvent(Layer, Operation, &LC, &UC, &BL, NULL, 0))
	{
		Status = xxGetLastError();
		fprintf(stderr, "NdisHandlePnPEvent failed %lx\n", Status);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\bchannel.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL BChannel BChannel_h

@module BChannel.h |

    This module defines the interface to the <t BCHANNEL_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | BChannel_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.4 BChannel Overview |

    This section describes the interfaces defined in <f BChannel\.h>.

    This module isolates most the channel specific interfaces.  It will require
    some changes to accomodate your hardware device's channel access methods.
    
    There should be one <t BCHANNEL_OBJECT> for each logical channel your card
    supports.  For instance, if your PRI card has two ports with 24 channels
    each, you would publish up 48 BChannels to NDIS.
    
    The driver uses the <t BCHANNEL_OBJECT> as a synonym for CO-NDIS VC.  The
    VC handle we pass up to NDIS, is actually a pointer to a <t BCHANNEL_OBJECT>.
    
    The driver is written to assume a homogenous BChannel configuration.  If
    your card supports multiple ISDN ports that are provisioned differrently,
    you will have to make some serious changes throughout the driver.
*/

#ifndef _BCHANNEL_H
#define _BCHANNEL_H

#define BCHANNEL_OBJECT_TYPE    ((ULONG)'B')+\
                                ((ULONG)'C'<<8)+\
                                ((ULONG)'H'<<16)+\
                                ((ULONG)'N'<<24)


/* @doc INTERNAL BChannel BChannel_h BCHANNEL_OBJECT


@struct BCHANNEL_OBJECT |

    This structure contains the data associated with an ISDN BChannel.
    Here, BChannel is defined as any channel or collection of channels
    capable of carrying "user" data over and existing connection.  This
    channel is responsible for making sure the data payload is sent to or
    received from the remote end-point exactly as it is appeared at the
    originating station.

@comm

    This logical BChannel does not necessarily map to a physical BChannel
    on the NIC.  The NIC may in fact be bonding multiple BChannels into this
    logical BChannel.  The NIC may in fact not have BChannels at all, as
    may be the case with channelized T-1.  The BChannel is just a convenient
    abstraction for a point-to-point, bi-directional communication link.

    There will be one BChannel created for each communication channel on the
    NIC.  The number of channels depends on how many ports the NIC has, and
    how they are provisioned and configured.  The number of BChannels can be
    configured at install time or changed using the control panel.  The driver
    does not allow the configuration to change at run-time, so the computer
    or the adapter must be restarted to enable the configuration changes.

*/

typedef struct BCHANNEL_OBJECT
{
    LIST_ENTRY                  LinkList;
    // Used to maintain the linked list of available BChannels for each 
    // adapter.

    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'BCHN'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this BChannel is open, otherwise set FALSE.

//
//  NDIS data members

    ULONG                       BChannelIndex;              // @field
    // This is a zero based index associated with this BChannel.
                                                            
    NDIS_HANDLE                 NdisVcHandle;               // @field
    // This is the WAN Wrapper's VC context which is associated with this
    // link in response to the Miniport calling <f NdisMIndicateStatus>
    // to indicate a <t NDIS_MAC_LINE_UP> condition.  This value is passed
    // back to the WAN Wrapper to indicate activity associated with this link,
    // such as <f NdisMWanIndicateReceive> and <f NdisMIndicateStatus>.
    // See <F MiniportCoActivateVc>.

    NDIS_HANDLE                 NdisSapHandle;              // @field
    // Used to store the NDIS SAP handle passed into 
    // <f ProtocolCmRegisterSap>.
    
    LONG                        SapRefCount;
    
    CO_AF_TAPI_SAP              NdisTapiSap;                // @field
    // A copy of the SAP registered by NDIS TAPI Proxy.

    ULONG                       LinkSpeed;                  // @field
    // The speed provided by the link in bits per second.  This value is
    // passed up by the Miniport during the LINE_UP indication.

    LIST_ENTRY                  ReceivePendingList;         // @field
    // Buffers currently submitted to the controller waiting for receive.

    LIST_ENTRY                  TransmitBusyList;           // @field
    // Packets currently submitted to the controller waiting for completion.
    // See <t NDIS_PACKET>.

    BOOLEAN                     NeedReceiveCompleteIndication;  // @field
    // This flag indicates whether or not <f NdisMWanIndicateReceiveComplete>
    // needs to be called after the completion of the event processing loop.
    // This is set TRUE if <f NdisMWanReceiveComplete> is called while
    // processing the event queues.

    NDIS_WAN_CO_SET_LINK_INFO   WanLinkInfo;                // @field
    // The current settings associated with this link as passed in via
    // the OID_WAN_SET_LINK_INFO request.

    ULONG                       TotalRxPackets;             // @field
    // Total packets read by driver during this session.

//
//  TAPI data members.

    BOOLEAN                     CallClosing;                // @field
    // Set TRUE if call is being closed.

    ULONG                       CallState;                  // @field
    // The current TAPI LINECALLSTATE of the associated with the link.

    ULONG                       CallStatesCaps;             // @field
    // Events currently supported

    ULONG                       AddressStatesCaps;          // @field
    // Events currently supported

    ULONG                       DevStatesCaps;              // @field
    // Events currently supported

    ULONG                       MediaMode;                  // @field
    // The current TAPI media mode(s) supported by the card.

    ULONG                       MediaModesCaps;             // @field
    // Events currently supported

    ULONG                       BearerMode;                 // @field
    // The current TAPI bearer mode in use.

    ULONG                       BearerModesCaps;            // @field
    // TAPI bearer mode(s) supported by the card.

    ULONG                       CallParmsSize;              // @field
    // Size of <p pInCallParms> memory area in bytes.
    
    PCO_CALL_PARAMETERS         pInCallParms;               // @field
    // Incoming call parameters.  Allocated as needed.

    PCO_CALL_PARAMETERS         pOutCallParms;              // @field
    // Pointer to the client's call parameters passed into
    // <f ProtocolCmMakeCall>.

    ULONG                       Flags;                      // @field
    // Bit flags used to keep track of VC state.
#   define  VCF_INCOMING_CALL   0x00000001
#   define  VCF_OUTGOING_CALL   0x00000002
#   define  VCF_VC_ACTIVE       0x00000004

//
//  CARD data members.

    ULONG                       TODO;                       // @field
    // Add your data members here.

#if defined(SAMPLE_DRIVER)
    PBCHANNEL_OBJECT            pPeerBChannel;              // @field
    // Peer BChannel of caller or callee depending on who orginated the
    // call.

#endif // SAMPLE_DRIVER

} BCHANNEL_OBJECT;

#define GET_ADAPTER_FROM_BCHANNEL(pBChannel)    (pBChannel->pAdapter)


/* @doc INTERNAL BChannel BChannel_h IS_VALID_BCHANNEL


@func ULONG | IS_VALID_BCHANNEL |
    Use this macro to determine if a <t BCHANNEL_OBJECT> is really valid.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t PBCHANNEL_OBJECT> | pBChannel |
    A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

@rdesc Returns TRUE if the BChannel is valid, otherwise FALSE is returned.

*/
#define IS_VALID_BCHANNEL(pAdapter, pBChannel) \
        (pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE)


/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_INDEX


@func <t PBCHANNEL_OBJECT> | GET_BCHANNEL_FROM_INDEX |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with a zero-based Index.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm ULONG | BChannelIndex |
    Miniport BChannelIndex associated with a specific link.

@rdesc Returns a pointer to the associated <t BCHANNEL_OBJECT>.

*/
#define GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex) \
        (pAdapter->pBChannelArray[BChannelIndex]); \
        ASSERT(BChannelIndex < pAdapter->NumBChannels)

/*


    Function prototypes.

*/

NDIS_STATUS BChannelCreate(
    OUT PBCHANNEL_OBJECT *      pBChannel,
    IN ULONG                    BChannelIndex,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void BChannelDestroy(
    IN PBCHANNEL_OBJECT         pBChannel
    );

void BChannelInitialize(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS BChannelOpen(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_HANDLE              NdisVcHandle
    );

void BChannelClose(
    IN PBCHANNEL_OBJECT         pBChannel
    );

#endif // _BCHANNEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\callmgr.h ===
/*

                                                                             
    (C) Copyright 1998 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL CallMgr CallMgr_h

@module CallMgr.h |

    This module defines the interface to the <t CALL_MANAGER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | CallMgr_h

@end

*/

#ifndef _CALLMGR_H
#define _CALLMGR_H

#define CALL_MANAGER_OBJECT_TYPE    ((ULONG)'C')+\
                                    ((ULONG)'M'<<8)+\
                                    ((ULONG)'G'<<16)+\
                                    ((ULONG)'R'<<24)

VOID CompleteCmOpenAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmOpenAf(
    IN NDIS_HANDLE              CallMgrBindingContext,
    IN PCO_ADDRESS_FAMILY       AddressFamily,
    IN NDIS_HANDLE              NdisAfHandle,
    OUT PNDIS_HANDLE            CallMgrAfContext 
    );

VOID CompleteCmCloseAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmCloseAf(
    IN NDIS_HANDLE              CallMgrAfContext 
    );

VOID CompleteCmRegisterSap(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmRegisterSap(
    IN NDIS_HANDLE              CallMgrAfContext ,
    IN PCO_SAP                  Sap,
    IN NDIS_HANDLE              NdisSapHandle,
    OUT PNDIS_HANDLE            CallMgrSapContext
    );

VOID CompleteCmDeregisterSap(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmDeregisterSap(
    IN NDIS_HANDLE              CallMgrSapContext
    );

NDIS_STATUS ProtocolCoCreateVc(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_HANDLE              NdisVcHandle,
    OUT PNDIS_HANDLE            ppBChannel
    );

NDIS_STATUS ProtocolCoDeleteVc(
    OUT PBCHANNEL_OBJECT        pBChannel
    );

VOID CompleteCmMakeCall(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmMakeCall(
    IN NDIS_HANDLE              CallMgrVcContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN NDIS_HANDLE              NdisPartyHandle,
    OUT PNDIS_HANDLE            CallMgrPartyContext
    );

VOID CompleteCmCloseCall(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN NDIS_STATUS              Status
    );

NDIS_STATUS ProtocolCmCloseCall(
    IN NDIS_HANDLE              CallMgrVcContext,
    IN NDIS_HANDLE              CallMgrPartyContext,
    IN PVOID                    CloseData,
    IN UINT                     Size
    );

VOID ProtocolCmIncomingCallComplete(
    IN NDIS_STATUS              Status,
    IN NDIS_HANDLE              CallMgrVcContext,
    IN PCO_CALL_PARAMETERS      CallParameters
    );

VOID ProtocolCmActivateVcComplete(
    IN NDIS_STATUS              Status,
    IN NDIS_HANDLE              CallMgrVcContext,
    IN PCO_CALL_PARAMETERS      CallParameters
    );

VOID ProtocolCmDeactivateVcComplete(
    IN NDIS_STATUS              Status,
    IN NDIS_HANDLE              CallMgrVcContext
    );

NDIS_STATUS MiniportCoActivateVc(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN OUT PCO_CALL_PARAMETERS  pCallParameters
    );

NDIS_STATUS MiniportCoDeactivateVc(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS ProtocolCmModifyCallQoS(
    IN NDIS_HANDLE              CallMgrVcContext,
    IN PCO_CALL_PARAMETERS      CallParameters
    );

NDIS_STATUS ProtocolCoRequest(
    IN  NDIS_HANDLE             ProtocolAfContext,
    IN  NDIS_HANDLE             ProtocolVcContext       OPTIONAL,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

VOID ProtocolCoRequestComplete(
    IN NDIS_STATUS              Status,
    IN NDIS_HANDLE              ProtocolAfContext,
    IN NDIS_HANDLE              ProtocolVcContext       OPTIONAL,
    IN NDIS_HANDLE              ProtocolPartyContext    OPTIONAL,
    IN PNDIS_REQUEST            NdisRequest
    );

PCO_CALL_PARAMETERS AllocateIncomingCallParameters(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS SetupIncomingCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT *       ppBChannel
    );

VOID InitiateCallTeardown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID CallMgrTimerHandler(
    IN PVOID                    SystemSpecific1,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PVOID                    SystemSpecific2,
    IN PVOID                    SystemSpecific3
    );

#endif // _CALLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\dchannel.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL DChannel DChannel_h

@module DChannel.h |

    This module defines the interface to the <t DCHANNEL_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | DChannel_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.3 DChannel Overview |

    This section describes the interfaces defined in <f DChannel\.h>.

    This module isolates most the vendor specific Call Control interfaces.
    It will require some changes to accomodate your hardware device's call
    control mechanism.  
    
    The driver is written to assume a single logical <t DCHANNEL_OBJECT> for 
    each adapter.  If your card supports more than one ISDN line, you will 
    need to use the given BChannel object to identify which <t PORT_OBJECT> 
    the real DChannel is located on.  You can then manage the physical call
    control using that interface, and the logicial call control using the
    DChannel interface.
*/

#ifndef _DCHANNEL_H
#define _DCHANNEL_H

#define DCHANNEL_OBJECT_TYPE    ((ULONG)'D')+\
                                ((ULONG)'C'<<8)+\
                                ((ULONG)'H'<<16)+\
                                ((ULONG)'N'<<24)

/* @doc INTERNAL DChannel DChannel_h DCHANNEL_OBJECT


@struct DCHANNEL_OBJECT |

    This structure contains the data associated with an ISDN DChannel.  Here,
    DChannel is defined as an interface by which to setup and teardown a
    BChannel connection between two end-points.  This channel is responsible
    for establishing a point-to-point connection over one of the available
    BChannels.

@comm

    This logical DChannel does not necessarily map to a physical DChannel
    on the NIC.  The NIC may in fact have multiple DChannels depending on
    how many ports and whether it is BRI, PRI, T-1, or E-1.  The NIC may in
    fact not have DChannels at all, as may be the case with channelized T-1.
    The DChannel is just a convenient abstraction for announcing and
    answering incoming calls, and for placing outgoing calls.


    There will be one DChannel created for each NIC.  The number of physical
    D-channels depends on how many ports the NIC has, and how the ports are
    provisioned and configured.  The provisioning can be configured at install
    time or changed using the control panel.  The driver does not allow the
    configuration to change at run-time, so the computer or the adapter must
    be restarted to enable the configuration changes.

*/

typedef struct DCHANNEL_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'DCHN'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    UINT                        IsOpen;                     // @field
    // Set non-zero if this DChannel is open, otherwise set zero.

    ULONG                       TotalMakeCalls;             // @field
    // Total number of <f DChannelMakeCall> requests.

    ULONG                       TotalAnswers;               // @field
    // Total number of <f DChannelAnswerCall> requests.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} DCHANNEL_OBJECT;

#define GET_ADAPTER_FROM_DCHANNEL(pDChannel)    (pDChannel->pAdapter)


/*


    Function prototypes.

*/

NDIS_STATUS DChannelCreate(
    OUT PDCHANNEL_OBJECT *      ppDChannel,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void DChannelDestroy(
    IN PDCHANNEL_OBJECT         pDChannel
    );

void DChannelInitialize(
    IN PDCHANNEL_OBJECT         pDChannel
    );

NDIS_STATUS DChannelOpen(
    IN PDCHANNEL_OBJECT         pDChannel
    );

void DChannelClose(
    IN PDCHANNEL_OBJECT         pDChannel
    );

NDIS_STATUS DChannelMakeCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PUCHAR                   DialString,
    IN USHORT                   DialStringLength,
    IN PLINE_CALL_PARAMS        pLineCallParams
    );

NDIS_STATUS DChannelAnswerCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS DChannelCloseCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID DChannelRejectCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

#endif // _DCHANNEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\card.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Card Card_c

@module Card.c |

    This module implements the interface to the <t CARD_OBJECT>.
    Supports the low-level hardware control functions used by the NDIS WAN
    Minport driver.

@comm

    This module isolates most the vendor specific hardware access interfaces.
    It will require signficant changes to accomodate your hardware device.
    You should try to isolate your changes to the <t CARD_OBJECT> rather then
    the <t MINIPORT_ADAPTER_OBJECT>.  This will make it eaiser to reuse the
    upper portions of the driver should your hardware change in the future.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Card_c

@end

*/

#define  __FILEID__             CARD_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                g_CardInstanceCounter       // @globalv
// Keeps track of how many <t CARD_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL Card Card_c g_CardParameters


@topic 5.2 Card Parameters |

    This section describes the registry parameters read into the
    <t CARD_OBJECT>.

@globalv PARAM_TABLE | g_CardParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t CARD_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t CARD_OBJECT>
    you will need to modify <f CardReadParameters> and add the parameter
    definitions to the <f g_CardParameters> table.

@flag <f BufferSize> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum buffer size used
    to transmit and receive packets over the IDSN line.  Typically, this is
    defined to be 1500 bytes for most Point to Point (PPP) connections.<nl>

    <tab><f Default Value:><tab><tab>1532<nl>
    <tab><f Valid Range N:><tab><tab>532 <lt>= N <lt>= 4032<nl>

    <f Note>: You must add 32 bytes to the maximum packet size you
    expect to send or receive.  Therefore, if you have a maximum packet size
    of 1500 bytes, excluding media headers, you should set the <f BufferSize>
    value to 1532.<nl>

@flag <f ReceiveBuffersPerLink> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of incoming
    packets that can in progress at any one time.  The Miniport will allocate
    this number of packets per BChannel and set them up for incoming packets.
    Typically, three or four should be sufficient to handle a few short bursts
    that may occur with small packets.  If the Miniport is not able to service
    the incoming packets fast enough, new packets will be dropped and it is up
    to the NDIS WAN Wrapper to resynchronize with the remote station.<nl>

    <tab><f Default Value:><tab><tab>3<nl>
    <tab><f Valid Range N:><tab><tab>2 <lt>= N <lt>= 16<nl>

@flag <f TransmitBuffersPerLink> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of outgoing
    packets that can in progress at any one time.  The Miniport will allow
    this number of packets per BChannel to be outstanding (i.e. in progress).
    Typically, two or three should be sufficient to keep the channel busy for
    normal sized packets.  If there are alot of small packets being sent, the
    BChannel may become idle for brief periods while new packets are being
    queued.  Windows does not normally work this way if it has large amounts
    of data to transfer, so the default value should be sufficient. <nl>

    <tab><f Default Value:><tab><tab>2<nl>
    <tab><f Valid Range N:><tab><tab>1 <lt>= N <lt>= 16<nl>

@flag <f IsdnNumDChannels> (OPTIONAL) |

    This DWORD parameter allows you to control the number of ISDN D Channels
    allocated for the adapter.  The driver assumes only one logical
    <t DCHANNEL_OBJECT>, but the card can have multiple physical D channels
    managed by the <t PORT_OBJECT>.

    <tab><f Default Value:><tab><tab>1<nl>
    <tab><f Valid Range N:><tab><tab>1 <lt>= N <lt>= 16<nl>

*/

DBG_STATIC PARAM_TABLE          g_CardParameters[] =
{
#if defined(PCI_BUS)
    PARAM_ENTRY(CARD_OBJECT,
                PciSlotNumber, PARAM_PciSlotNumber,
                TRUE, NdisParameterInteger, 0,
                0, 0, 31),
#endif // PCI_BUS

    PARAM_ENTRY(CARD_OBJECT,
                BufferSize, PARAM_BufferSize,
                FALSE, NdisParameterInteger, 0,
                CARD_DEFAULT_PACKET_SIZE, CARD_MIN_PACKET_SIZE, CARD_MAX_PACKET_SIZE),

    PARAM_ENTRY(CARD_OBJECT,
                ReceiveBuffersPerLink, PARAM_ReceiveBuffersPerLink,
                FALSE, NdisParameterInteger, 0,
                2, 2, 16),

    PARAM_ENTRY(CARD_OBJECT,
                TransmitBuffersPerLink, PARAM_TransmitBuffersPerLink,
                FALSE, NdisParameterInteger, 0,
                2, 1, 16),

    PARAM_ENTRY(CARD_OBJECT,
                NumDChannels, PARAM_NumDChannels,
                FALSE, NdisParameterInteger, 0,
                1, 1, 4),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL Card Card_c CardReadParameters


@func

    <f CardReadParameters> reads the Card parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f CardCreate>.

    <f Note>:
    If you add any registry based data members to <t CARD_OBJECT>
    you will need to modify <f CardReadParameters> and add the parameter
    definitions to the <f g_CardParameters> table.

@rdesc

    <f CardReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardReadParameters(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pCard,
                    g_CardParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pCard->BufferSize & 0x1F)
        {
            DBG_ERROR(pAdapter,("Invalid value 'BufferSize'=0x0x%X must be multiple of 32\n",
                        pCard->BufferSize));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pCard->BufferSize,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Card Card_c CardFindNIC


@func

    <f CardFindNIC> locates the NIC associated with this NDIS device.

@rdesc

    <f CardFindNIC> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardFindNIC(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardFindNIC")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

#if defined(PCI_BUS)
    ULONG                       Index;
    // Loop counter.

    PNDIS_RESOURCE_LIST         pPciResourceList;

    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPciResource;

#endif // PCI_BUS

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(PCI_BUS)
    /*
    // Read the PCI data and initialize the driver data structure
    // with the data returned.
    */
    pPciResourceList = NULL;

    Result = NdisMPciAssignResources(pAdapter->MiniportAdapterHandle,
                                     pCard->PciSlotNumber,
                                     &pPciResourceList);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter,("NdisMPciAssignResources Result=0x%X\n",
                  Result));
        NdisWriteErrorLogEntry(
                pAdapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                4,
                pCard->PciSlotNumber,
                Result,
                __FILEID__,
                __LINE__
                );
    }

    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < pPciResourceList->Count; ++Index)
    {
        ASSERT(pPciResourceList);
        pPciResource = &pPciResourceList->PartialDescriptors[Index];
        ASSERT(pPciResource);

        switch (pPciResource->Type)
        {
        case CmResourceTypePort:
#if defined(CARD_MIN_IOPORT_SIZE)
            if (pPciResource->u.Port.Start.LowPart &&
                pPciResource->u.Port.Length >= CARD_MIN_IOPORT_SIZE)
            {
                DBG_NOTICE(pAdapter,("Port: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Port.Start.LowPart,
                          pPciResource->u.Port.Length,
                          CARD_MIN_IOPORT_SIZE));
                pCard->ResourceInformation.IoPortPhysicalAddress =
                        pPciResource->u.Port.Start;
                pCard->ResourceInformation.IoPortLength =
                        pPciResource->u.Port.Length;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Port: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Port.Start,
                          pPciResource->u.Port.Length,
                          CARD_MIN_IOPORT_SIZE));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Port.Length,
                        CARD_MIN_IOPORT_SIZE,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
#endif // CARD_MIN_IOPORT_SIZE
            break;

        case CmResourceTypeInterrupt:
#if defined(CARD_REQUEST_ISR)
            if (pPciResource->u.Interrupt.Level)
            {
                DBG_NOTICE(pAdapter,("Interrupt: Lev=%d,Vec=%d\n",
                           pPciResource->u.Interrupt.Level,
                           pPciResource->u.Interrupt.Vector));
                pCard->ResourceInformation.InterruptLevel =
                        pPciResource->u.Interrupt.Level;
                pCard->ResourceInformation.InterruptVector =
                        pPciResource->u.Interrupt.Vector;

                pCard->ResourceInformation.InterruptShared = CARD_INTERRUPT_SHARED;
                pCard->ResourceInformation.InterruptMode = CARD_INTERRUPT_MODE;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Interrupt: Lev=%d,Vec=%d\n",
                          pPciResource->u.Interrupt.Level,
                          pPciResource->u.Interrupt.Vector));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Interrupt.Level,
                        pPciResource->u.Interrupt.Vector,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
#endif // defined(CARD_REQUEST_ISR)
            break;

        case CmResourceTypeMemory:
#if defined(CARD_MIN_MEMORY_SIZE)
            if (pPciResource->u.Memory.Start.LowPart &&
                pPciResource->u.Memory.Length >= CARD_MIN_MEMORY_SIZE)
            {
                DBG_NOTICE(pAdapter,("Memory: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Memory.Start.LowPart,
                          pPciResource->u.Memory.Length,
                          CARD_MIN_MEMORY_SIZE));
                pCard->ResourceInformation.MemoryPhysicalAddress =
                        pPciResource->u.Memory.Start;
                pCard->ResourceInformation.MemoryLength =
                        pPciResource->u.Memory.Length;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Memory: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Memory.Start.LowPart,
                          pPciResource->u.Memory.Length,
                          CARD_MIN_MEMORY_SIZE));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Memory.Length,
                        CARD_MIN_MEMORY_SIZE,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
            break;
#endif // CARD_MIN_MEMORY_SIZE

        default:
            DBG_ERROR(pAdapter,("Unknown resource type=%d\n",
                      pPciResource->Type));
            break;
        }
    }
    pCard->ResourceInformation.BusInterfaceType = NdisInterfacePci;

#endif // PCI_BUS

    pCard->ResourceInformation.Master = CARD_IS_BUS_MASTER;
#if (CARD_IS_BUS_MASTER)
    pCard->ResourceInformation.DmaChannel = 0;
    pCard->ResourceInformation.Dma32BitAddresses = TRUE,
    pCard->ResourceInformation.MaximumPhysicalMapping = pCard->BufferSize;
    pCard->ResourceInformation.PhysicalMapRegistersNeeded = CARD_MAP_REGISTERS_NEEDED;
#endif // (CARD_IS_BUS_MASTER)

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreateInterface


@func

    <f CardCreateInterface> allocates a shared memory pool and uses it to
    establish the message interface between the Miniport and the NIC.

@rdesc

    <f CardCreateInterface> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardCreateInterface(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreateObjects


@func

    <f CardCreateObjects> calls the create routines for all the objects
    contained in <t CARD_OBJECT>.  This should only be called
    by <f CardCreate>.

    <f Note>:
    If you add any new objects to <t CARD_OBJECT> you will need
    to modify <f CardCreateObjects> and <f CardDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f CardCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardCreateObjects(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ULONG                       Index;
    // Loop counter.

    ULONG                       NumPorts;
    // The number of Ports supported by the NIC.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Try to locate the NIC on the PCI bus.
    */
    Result = CardFindNIC(pCard);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto ExceptionExit;
    }

    /*
    // Create the message interface to the NIC.
    */
    Result = CardCreateInterface(pCard);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto ExceptionExit;
    }

    /*
    // Create the Port objects.
    */
    NumPorts = CardNumPorts(pCard);
    Result = ALLOCATE_MEMORY(pCard->pPortArray,
                             sizeof(PVOID) * NumPorts,
                             pAdapter->MiniportAdapterHandle);
    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < NumPorts; Index++)
    {
        Result = PortCreate(&pCard->pPortArray[Index], pCard);

        /*
        // Keep track of how many are created.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            pCard->NumPorts++;
        }
    }

    /*
    // We allocate (ReceiveBuffersPerLink * NumBChannels) buffers
    // to be used to receive incoming messages from the card.
    */
    pCard->NumMessageBuffers = (CardNumChannels(pCard) *
                                pCard->ReceiveBuffersPerLink);

    Result = ALLOCATE_MEMORY(pCard->MessagesVirtualAddress,
                             pCard->NumMessageBuffers * pCard->BufferSize,
                             pAdapter->MiniportAdapterHandle);
    if (Result == NDIS_STATUS_SUCCESS)
    {
        PUCHAR  MessageBuffer = pCard->MessagesVirtualAddress;

        ASSERT(pCard->MessagesVirtualAddress);

        /*
        // Allocate the buffer list spin lock to use as a MUTEX.
        */
        NdisAllocateSpinLock(&pCard->MessageBufferLock);

        InitializeListHead(&pCard->MessageBufferList);

        for (Index = 0; Index < pCard->NumMessageBuffers; Index++)
        {
            InsertTailList(&pCard->MessageBufferList,
                           (PLIST_ENTRY)MessageBuffer);
            MessageBuffer += pCard->BufferSize;
        }
    }

    /*
    // Allocate the message buffer pool.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        NdisAllocateBufferPool(&Result,
                               &pCard->BufferPoolHandle,
                               pCard->NumMessageBuffers
                               );
        if (Result != NDIS_STATUS_SUCCESS)
        {
            pCard->BufferPoolHandle = NULL_BUFFER_POOL;
            DBG_ERROR(pAdapter,("NdisAllocateBufferPool: Result=0x%X\n",
                      Result));
            NdisWriteErrorLogEntry(
                    pCard->pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                    3,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            ASSERT(pCard->BufferPoolHandle != NULL_BUFFER_POOL);
            DBG_FILTER(pAdapter, DBG_BUFFER_ON,
                      ("BufferPoolSize=%d\n",
                       pCard->NumMessageBuffers
                       ));
        }
    }

    /*
    // Allocate the message packet pool.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        NdisAllocatePacketPool(&Result,
                               &pCard->PacketPoolHandle,
                               pCard->NumMessageBuffers,
                               0
                               );
        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisAllocatePacketPool: Result=0x%X\n",
                      Result));
            NdisWriteErrorLogEntry(
                    pCard->pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                    3,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            ASSERT(pCard->PacketPoolHandle);
            DBG_FILTER(pAdapter, DBG_PACKET_ON,
                      ("PacketPoolSize=%d\n",
                       pCard->NumMessageBuffers
                       ));
        }
    }

ExceptionExit:

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreate


@func

    <f CardCreate> allocates memory for a <t CARD_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppCard> will be set to point to the newly created
    <t CARD_OBJECT>.  Otherwise, <p ppCard> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f CardDestroy> must be called to
    release the <t CARD_OBJECT> created by this function.

@rdesc

    <f CardCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardCreate(
    OUT PCARD_OBJECT *          ppCard,                     // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t CARD_OBJECT>.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("CardCreate")

    PCARD_OBJECT                pCard;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppCard = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pCard, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pCard->ObjectType = CARD_OBJECT_TYPE;
        pCard->ObjectID = ++g_CardInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pCard->pAdapter = pAdapter;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = CardReadParameters(pCard);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = CardCreateObjects(pCard);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppCard = pCard;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            CardDestroy(pCard);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardDestroyObjects


@func

    <f CardDestroyObjects> calls the destroy routines for all the objects
    contained in <t CARD_OBJECT>.  This should only be called by
    <f CardDestroy>.

    <f Note>:
    If you add any new objects to <t PCARD_OBJECT> you will need to
    modify <f CardCreateObjects> and <f CardDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void CardDestroyObjects(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardDestroyObjects")

    ULONG                       NumPorts;
    // The number of Ports supported by the NIC.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here
    /*
    // Release the packet, buffer, and message memory back to NDIS.
    */
    if (pCard->PacketPoolHandle)
    {
        NdisFreePacketPool(pCard->PacketPoolHandle);
    }

    if (pCard->BufferPoolHandle != NULL_BUFFER_POOL)
    {
        NdisFreeBufferPool(pCard->BufferPoolHandle);
    }

    if (pCard->MessagesVirtualAddress)
    {
        FREE_MEMORY(pCard->MessagesVirtualAddress,
                    pCard->NumMessageBuffers * pCard->BufferSize);
    }

    if (pCard->MessageBufferLock.SpinLock)
    {
        NdisFreeSpinLock(&pCard->MessageBufferLock);
    }

    /*
    // Destory the Port objects.
    */
    NumPorts = pCard->NumPorts;
    while (NumPorts--)
    {
        PortDestroy(pCard->pPortArray[NumPorts]);
    }
    pCard->NumPorts = 0;

    /*
    // Free space for the Ports.
    */
    if (pCard->pPortArray)
    {
        NumPorts = CardNumPorts(pCard);
        FREE_MEMORY(pCard->pPortArray, sizeof(PVOID) * NumPorts);
    }

    /*
    // Release the system resources back to NDIS.
    */
#if defined(CARD_REQUEST_ISR)
    if (pCard->Interrupt.InterruptObject)
    {
        NdisMDeregisterInterrupt(&pCard->Interrupt);
        pCard->Interrupt.InterruptObject = NULL;
    }
#endif // defined(CARD_REQUEST_ISR)

#if defined(CARD_MIN_IOPORT_SIZE)
    if (pCard->pIoPortVirtualAddress)
    {
        NdisMDeregisterIoPortRange(
                pAdapter->MiniportAdapterHandle,
                pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                pCard->ResourceInformation.IoPortLength,
                pCard->pIoPortVirtualAddress);
        pCard->pIoPortVirtualAddress = NULL;
    }
#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_MIN_MEMORY_SIZE)
    if (pCard->pMemoryVirtualAddress)
    {
        NdisMUnmapIoSpace(
                pAdapter->MiniportAdapterHandle,
                pCard->pMemoryVirtualAddress,
                pCard->ResourceInformation.MemoryLength
                );
        pCard->pMemoryVirtualAddress = NULL;
    }
#endif // CARD_MIN_MEMORY_SIZE

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardDestroy


@func

    <f CardDestroy> frees the memory for this <t CARD_OBJECT>.  All memory
    allocated by <f CardCreate> will be released back to the OS.

*/

void CardDestroy(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pCard)
    {
        ASSERT(pCard->ObjectType == CARD_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_CARD(pCard);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        CardDestroyObjects(pCard);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pCard->ObjectType = 0;
        FREE_OBJECT(pCard);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Card Card_c CardNumPorts


@func

    <f CardNumPorts> will return the total number of ports available on the
    NIC.

@rdesc

    <f CardNumPorts> returns the total number of ports available.

*/

ULONG CardNumPorts(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardNumPorts")

    // TODO - Get the actual number of ports from the card.
    return (pCard->NumDChannels);
}


/* @doc INTERNAL Card Card_c CardNumChannels


@func

    <f CardNumChannels> will return the total number of channels capable
    of supporting data connections to a remote end-point.

@rdesc

    <f CardNumChannels> returns the total number of data channels supported
    on all the NIC ports.

*/

ULONG CardNumChannels(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardNumChannels")

    UINT                        PortIndex;
    // Loop index.

    if (pCard->NumChannels == 0)
    {
        // NumPorts should already be known.
        ASSERT(pCard->NumPorts);

        // Get the actual number of channels configured on all ports.
        for (PortIndex = 0; PortIndex < pCard->NumPorts; PortIndex++)
        {
            pCard->NumChannels += pCard->pPortArray[PortIndex]->NumChannels;
        }
        ASSERT(pCard->NumChannels);
    }

    return (pCard->NumChannels);
}


/* @doc INTERNAL Card Card_c CardInitialize


@func

    <f CardInitialize> will attempt to initialize the NIC, but will not
    enable transmits or receives.

@rdesc

    <f CardInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardInitialize(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardInitialize")

    int                         num_dial_chan = 0;
    int                         num_sync_chan = 0;
    // The number of channels supported by card is based on InterfaceType.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Inform the wrapper of the physical attributes of this adapter.
    // This must be called before any NdisMRegister functions!
    // This call also associates the MiniportAdapterHandle with this pAdapter.
    */
    NdisMSetAttributes(pAdapter->MiniportAdapterHandle,
                       (NDIS_HANDLE) pAdapter,
                       pCard->ResourceInformation.Master,
                       pCard->ResourceInformation.BusInterfaceType
                       );
#if (CARD_IS_BUS_MASTER)
    if (pCard->ResourceInformation.Master)
    {
        ASSERT(pCard->ResourceInformation.DmaChannel == 0 ||
               pCard->ResourceInformation.BusInterfaceType == NdisInterfaceIsa);
        Result = NdisMAllocateMapRegisters(
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.DmaChannel,
                        pCard->ResourceInformation.Dma32BitAddresses,
                        pCard->ResourceInformation.PhysicalMapRegistersNeeded + 1,
                        pCard->ResourceInformation.MaximumPhysicalMapping
                        );

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMAllocateMapRegisters(%d,%d) Result=0x%X\n",
                      pCard->ResourceInformation.PhysicalMapRegistersNeeded,
                      pCard->ResourceInformation.MaximumPhysicalMapping,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.PhysicalMapRegistersNeeded,
                    pCard->ResourceInformation.MaximumPhysicalMapping,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
    }
#endif // (CARD_IS_BUS_MASTER)

#if defined(CARD_MIN_MEMORY_SIZE)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.MemoryLength)
    {
        Result = NdisMMapIoSpace(
                        &pCard->pMemoryVirtualAddress,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.MemoryPhysicalAddress,
                        pCard->ResourceInformation.MemoryLength);

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMMapIoSpace(0x%X,0x%X) Result=0x%X\n",
                      pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                      pCard->ResourceInformation.MemoryLength,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                    pCard->ResourceInformation.MemoryLength,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            DBG_NOTICE(pAdapter,("NdisMMapIoSpace(0x%X,0x%X) VirtualAddress=0x%X\n",
                      pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                      pCard->ResourceInformation.MemoryLength,
                      pCard->pMemoryVirtualAddress));
        }
    }
#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.IoPortLength)
    {
        Result = NdisMRegisterIoPortRange(
                        &pCard->pIoPortVirtualAddress,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                        pCard->ResourceInformation.IoPortLength);

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMRegisterIoPortRange(0x%X,0x%X) Result=0x%X\n",
                      pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                      pCard->ResourceInformation.IoPortLength,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                    pCard->ResourceInformation.IoPortLength,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            DBG_NOTICE(pAdapter,("NdisMRegisterIoPortRange(0x%X,0x%X) VirtualAddress=0x%X\n",
                      pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                      pCard->ResourceInformation.IoPortLength,
                      pCard->pIoPortVirtualAddress));
        }
    }
#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_REQUEST_ISR)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.InterruptVector)
    {
        ASSERT(pCard->ResourceInformation.InterruptShared == FALSE ||
               (pCard->ResourceInformation.InterruptMode == NdisInterruptLevelSensitive &&
                CARD_REQUEST_ISR == TRUE));
        Result = NdisMRegisterInterrupt(
                        &pCard->Interrupt,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.InterruptVector,
                        pCard->ResourceInformation.InterruptLevel,
                        CARD_REQUEST_ISR,
                        pCard->ResourceInformation.InterruptShared,
                        pCard->ResourceInformation.InterruptMode
                        );
        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMRegisterInterrupt failed: Vec=%d, Lev=%d\n",
                     (UINT)pCard->ResourceInformation.InterruptVector,
                     (UINT)pCard->ResourceInformation.InterruptLevel));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.InterruptVector,
                    pCard->ResourceInformation.InterruptLevel,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
    }
#endif // defined(CARD_REQUEST_ISR)

    // TODO - Add your card initialization here.

    if (Result == NDIS_STATUS_SUCCESS)
    {

    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardTransmitPacket


@func

    <f CardTransmitPacket> will start sending the current packet out.

@rdesc

    <f CardTransmitPacket> returns TRUE if the packet is being transmitted,
    otherwise FALSE is returned.

*/

BOOLEAN CardTransmitPacket(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_PACKET             pNdisPacket                  // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_PACKET>.
    )
{
    DBG_FUNC("CardTransmitPacket")

    BOOLEAN                     bResult = FALSE;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(SAMPLE_DRIVER)
{
    PBCHANNEL_OBJECT            pPeerBChannel;
    // A pointer to the peer <t BCHANNEL_OBJECT>.

    PCARD_EVENT_OBJECT          pEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    // If you can transmit the packet on pBChannel, do it now.
    pPeerBChannel = pBChannel->pPeerBChannel;
    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            /*
            // Append the packet onto TransmitBusyList while it is being sent.
            // Then move it to the TransmitCompleteList in CardInterruptHandler
            // after the card is done with it.
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
            InsertTailList(&pBChannel->TransmitBusyList,
                           GET_QUEUE_FROM_PACKET(pNdisPacket));
            NdisReleaseSpinLock(&pAdapter->TransmitLock);
            pEvent->ulEventCode      = CARD_EVENT_RECEIVE;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            pEvent->pNdisPacket      = pNdisPacket;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            bResult = TRUE;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to transmit the packet.
    DBG_TX(pAdapter, pBChannel->ObjectID,
           BytesToSend, pNdisPacket->CurrentBuffer);
#endif // SAMPLE_DRIVER

    DBG_RETURN(pAdapter, bResult);
    return (bResult);
}


/* @doc EXTERNAL Card Card_c TpiCopyFromPacketToBuffer


@func

    <f TpiCopyFromPacketToBuffer> copies from an NDIS packet into a memory
    buffer.

*/

DBG_STATIC VOID TpiCopyFromPacketToBuffer(
    IN PNDIS_PACKET            Packet,                      // @parm
    // The packet to copy from.

    IN UINT                    Offset,                      // @parm
    // The offset from which to start the copy.

    IN UINT                    BytesToCopy,                 // @parm
    // The number of bytes to copy from the packet.

    IN PUCHAR                   Buffer,                     // @parm
    // The destination of the copy.

    OUT PUINT                   BytesCopied                 // @parm
    // The number of bytes actually copied.  Can be less then
    // BytesToCopy if the packet is shorter than BytesToCopy.
    )
{
    UINT                        NdisBufferCount;
    PNDIS_BUFFER                CurrentBuffer;
    PVOID                       VirtualAddress;
    UINT                        CurrentLength;
    UINT                        LocalBytesCopied = 0;
    UINT                        AmountToMove;

    *BytesCopied = 0;
    if (!BytesToCopy)
    {
        return;
    }

    //
    // Get the first buffer.
    //
    NdisQueryPacket(
        Packet,
        NULL,
        &NdisBufferCount,
        &CurrentBuffer,
        NULL
        );

    //
    // Could have a null packet.
    //
    if (!NdisBufferCount)
    {
        return;
    }

    NdisQueryBufferSafe(
        CurrentBuffer,
        &VirtualAddress,
        &CurrentLength,
        NormalPagePriority
        );

    while (LocalBytesCopied < BytesToCopy)
    {
        if (!CurrentLength)
        {
            NdisGetNextBuffer(
                CurrentBuffer,
                &CurrentBuffer
                );

            //
            // We've reached the end of the packet.  We return
            // with what we've done so far. (Which must be shorter
            // than requested.
            //
            if (!CurrentBuffer)
            {
                break;
            }

            NdisQueryBufferSafe(
                CurrentBuffer,
                &VirtualAddress,
                &CurrentLength,
                NormalPagePriority
                );
            continue;

        }

        //
        // Try to get us up to the point to start the copy.
        //
        if (Offset)
        {
            if (Offset > CurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //
                Offset -= CurrentLength;
                CurrentLength = 0;
                continue;

            }
            else
            {
                VirtualAddress = (PCHAR)VirtualAddress + Offset;
                CurrentLength -= Offset;
                Offset = 0;
            }
        }

        //
        // Copy the data.
        //
        AmountToMove =
                   ((CurrentLength <= (BytesToCopy - LocalBytesCopied)) ?
                    (CurrentLength):(BytesToCopy - LocalBytesCopied));

        NdisMoveMemory(Buffer,VirtualAddress,AmountToMove);

        Buffer = (PUCHAR)Buffer + AmountToMove;
        VirtualAddress = (PCHAR)VirtualAddress + AmountToMove;

        LocalBytesCopied += AmountToMove;
        CurrentLength -= AmountToMove;
    }

    *BytesCopied = LocalBytesCopied;
}


/* @doc INTERNAL Card Card_c CardInterruptHandler


@func

    <f CardInterruptHandler> dequeues an event from the asynchronous event
    callback queue <t CARD_EVENT_OBJECT>, and processes it according to
    whether it is a BChannel event, Card event, or B-Advise event.
    The associated callback routines are responsible for processing the
    event.

@comm

    <f NdisAcquireSpinLock> and <f NdisReleaseSpinLock> are used to provide
    protection around the dequeueing code and keep it from being re-entered
    as a result of another asynchronous callback event.

*/

VOID CardInterruptHandler(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardInterruptHandler")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    // DBG_ENTER(pAdapter);

#if defined(SAMPLE_DRIVER)
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    PNDIS_BUFFER                pDstNdisBuffer;
    // A pointer to the NDIS buffer we use to indicate the receive.

    PUCHAR                      pMemory;
    // A pointer to a memory area we use to create a copy of the incoming
    // packet.

    ULONG                       ByteCount = 0;
    ULONG                       BytesCopied = 0;
    PLIST_ENTRY                 pList;

    PCARD_EVENT_OBJECT          pEvent;
    PCARD_EVENT_OBJECT          pNewEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    PBCHANNEL_OBJECT            pBChannel;
    PBCHANNEL_OBJECT            pPeerBChannel;
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    /*
    // Clear out all packets in the receive buffer.
    */
    NdisDprAcquireSpinLock(&pAdapter->EventLock);
    while (!IsListEmpty(&pAdapter->EventList))
    {
        pEvent = (PCARD_EVENT_OBJECT)RemoveHeadList(&pAdapter->EventList);
        NdisDprReleaseSpinLock(&pAdapter->EventLock);

        ASSERT(pEvent->pReceivingObject);

        switch (pEvent->ulEventCode)
        {
        case CARD_EVENT_RING:
            // The caller has already removed the BChannel from the available
            // list, so we just pass it up to SetupIncomingCall so it can
            // get the same one from ProtocolCoCreateVc.
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            pPeerBChannel = pEvent->pSendingObject;
            ASSERT(pPeerBChannel && pPeerBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

            pBChannel->pPeerBChannel = pPeerBChannel;
            DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                       ("#%d CallState=0x%X CARD_EVENT_RING from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                        (pBChannel->pPeerBChannel == NULL) ? -1 :
                             pBChannel->pPeerBChannel->ObjectID));

            Status = SetupIncomingCall(pAdapter, &pBChannel);
            if (Status == NDIS_STATUS_SUCCESS)
            {
                ASSERT(pBChannel == pEvent->pReceivingObject);
            }
            else if (Status != NDIS_STATUS_PENDING)
            {
                DChannelRejectCall(pAdapter->pDChannel, pBChannel);
            }
            else
            {
                ASSERT(pBChannel == pEvent->pReceivingObject);
            }
            break;

        case CARD_EVENT_CONNECT:
            // The other side answered the call.
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            pBChannel->pPeerBChannel = pEvent->pSendingObject;

            DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                       ("#%d CallState=0x%X CARD_EVENT_CONNECT from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                        (pBChannel->pPeerBChannel == NULL) ? -1 :
                             pBChannel->pPeerBChannel->ObjectID));
            if (pBChannel->Flags & VCF_OUTGOING_CALL)
            {
                // The other side answered the call.
                CompleteCmMakeCall(pBChannel, NDIS_STATUS_SUCCESS);
            }
            break;

        case CARD_EVENT_DISCONNECT:
            // The other side has closed the call.
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

            DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                       ("#%d CallState=0x%X CARD_EVENT_DISCONNECT from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                       (pBChannel->pPeerBChannel == NULL) ? -1 :
                            pBChannel->pPeerBChannel->ObjectID));
            pBChannel->pPeerBChannel = NULL;
            if (pBChannel->Flags & VCF_OUTGOING_CALL)
            {
                if (pBChannel->CallState != LINECALLSTATE_CONNECTED)
                {
                    // Call never made it to the connected state.
                    CompleteCmMakeCall(pBChannel, NDIS_STATUS_FAILURE);
                }
                else
                {
                    // Call was disconnected by remote endpoint.
                    InitiateCallTeardown(pAdapter, pBChannel);
                }
            }
            else if (pBChannel->Flags & VCF_INCOMING_CALL)
            {
                InitiateCallTeardown(pAdapter, pBChannel);
            }
            break;

        case CARD_EVENT_RECEIVE:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

            DBG_FILTER(pAdapter,DBG_TXRX_VERBOSE_ON,
                       ("#%d CallState=0x%X CARD_EVENT_RECEIVE from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                       (pBChannel->pPeerBChannel == NULL) ? -1 :
                            pBChannel->pPeerBChannel->ObjectID));

            if (pBChannel->CallState == LINECALLSTATE_CONNECTED)
            {
                // Find out how big the packet is.
                NdisQueryPacket(pEvent->pNdisPacket, NULL, NULL, NULL,
                                &ByteCount);

                // Allocate memory for a copy of the data.
                Status = ALLOCATE_MEMORY(pMemory, ByteCount,
                                         pAdapter->MiniportAdapterHandle);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    NdisAllocateBuffer(&Status, &pDstNdisBuffer,
                                       pAdapter->pCard->BufferPoolHandle,
                                       pMemory, ByteCount);

                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        TpiCopyFromPacketToBuffer(pEvent->pNdisPacket, 0,
                                                  ByteCount, pMemory,
                                                  &BytesCopied);
                        ASSERT(BytesCopied == ByteCount);
                        ReceivePacketHandler(pBChannel, pDstNdisBuffer,
                                             ByteCount);
                    }
                    else
                    {
                       FREE_MEMORY(pMemory, ByteCount);
                       DBG_ERROR(pAdapter,("NdisAllocateBuffer Error=0x%X\n",
                                 Status));
                    }
                }
            }

            pPeerBChannel = pBChannel->pPeerBChannel;
            if (pPeerBChannel)
            {
                pNewEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
                if (pNewEvent)
                {
                    pNewEvent->ulEventCode      = CARD_EVENT_TRANSMIT_COMPLETE;
                    pNewEvent->pSendingObject   = pBChannel;
                    pNewEvent->pReceivingObject = pPeerBChannel;
                    CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pNewEvent);
                }
            }
            else
            {
                DBG_WARNING(pAdapter,("pPeerBChannel == NULL\n"));
            }
            break;

        case CARD_EVENT_TRANSMIT_COMPLETE:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

            DBG_FILTER(pAdapter,DBG_TXRX_VERBOSE_ON,
                       ("#%d CallState=0x%X CARD_EVENT_TRANSMIT_COMPLETE from #%d\n",
                       pBChannel->ObjectID, pBChannel->CallState,
                       (pBChannel->pPeerBChannel == NULL) ? -1 :
                            pBChannel->pPeerBChannel->ObjectID));
            /*
            // Remove the packet from the BChannel's TransmitBusyList and
            // place it on the adapter's TransmitCompleteList now that the
            // card has completed the transmit.
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
            if (!IsListEmpty(&pBChannel->TransmitBusyList))
            {
                pList = RemoveHeadList(&pBChannel->TransmitBusyList);
                InsertTailList(&pBChannel->pAdapter->TransmitCompleteList, pList);
            }
            NdisReleaseSpinLock(&pAdapter->TransmitLock);
            TransmitCompleteHandler(pAdapter);
            break;

        default:
            DBG_ERROR(pAdapter,("Unknown event code=%d\n",
                      pEvent->ulEventCode));
            break;
        }
        CardEventRelease(pCard, pEvent);
        NdisDprAcquireSpinLock(&pAdapter->EventLock);
    }
    NdisDprReleaseSpinLock(&pAdapter->EventLock);
}
#else  // SAMPLE_DRIVER
    // TODO - Add interrupt handler code here
#endif // SAMPLE_DRIVER

    // DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardCleanPhoneNumber


@func

    <f CardCleanPhoneNumber> copies the phone number from the input string
    to the output string, deleting any non-phone number characters (i.e.
    dashes, parens, modem keywords, etc.).

@rdesc

    <f CardCleanPhoneNumber> returns the length of the output string in bytes.

*/

USHORT CardCleanPhoneNumber(
    OUT PUCHAR                  Dst,                        // @parm
    // A pointer to the output string.

    IN  PUSHORT                 Src,                        // @parm
    // A pointer to the input string.

    IN  USHORT                  Length                      // @parm
    // The length of the input string in bytes.
    )
{
    DBG_FUNC("CardCleanPhoneNumber")

    USHORT                  NumDigits;

    /*
    // Strip out any character which are not digits or # or *.
    */
    for (NumDigits = 0; Length > 0; --Length)
    {
        if ((*Src >= '0' && *Src <= '9') ||
            (*Src == '#' || *Src == '*'))
        {
            /*
            // Make sure dial string is within the limit of the adapter.
            */
            if (NumDigits < CARD_MAX_DIAL_DIGITS)
            {
                ++NumDigits;
                *Dst++ = (UCHAR) *Src;
            }
            else
            {
                break;
            }
        }
        Src++;
    }
    *Dst++ = 0;
    return (NumDigits);
}


/* @doc INTERNAL Card Card_c CardReset


@func

    <f CardReset> issues a hard reset to the NIC.  Same as power up.

@rdesc

    <f CardReset> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardReset(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardReset")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_BREAK(pAdapter);

    // TODO - Add code here to reset your hardware to its initial state.

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


#if defined(SAMPLE_DRIVER)

/* @doc INTERNAL Card Card_c GET_BCHANNEL_FROM_PHONE_NUMBER


@func

    <f GET_BCHANNEL_FROM_PHONE_NUMBER> assumes the phone number is a BChannel
    index, and uses it to lookup the associated BChannel on one of our
    adapters.  Zero means use the first availble BChannel on another adapter.

@rdesc

    <f GET_BCHANNEL_FROM_PHONE_NUMBER> returns a pointer to the associated
    <t BCHANNEL_OBJECT> if successful.  Otherwise, NULL is returned.

*/

PBCHANNEL_OBJECT GET_BCHANNEL_FROM_PHONE_NUMBER(
    IN  PUCHAR                 pDialString                      // @parm
    // A pointer to the dial string.
    )
{
    DBG_FUNC("GET_BCHANNEL_FROM_PHONE_NUMBER")

    ULONG                       ulCalledID = 0;
    // Phone number converted to BChannel ObjectID (spans all adapters).

    ULONG                       ulAdapterIndex;
    // Loop index.

    /*
    // Strip out any character which are not digits or # or *.
    */
    while (*pDialString)
    {
        if (*pDialString >= '0' && *pDialString <= '9')
        {
            ulCalledID *= 10;
            ulCalledID += *pDialString - '0';
        }
        else
        {
            break;
        }
        pDialString++;
    }
    if (*pDialString)
    {
        DBG_ERROR(DbgInfo,("Invalid dial string '%s'\n", pDialString));
    }
    else
    {
        PMINIPORT_ADAPTER_OBJECT    pAdapter;

        for (ulAdapterIndex = 0; ulAdapterIndex < MAX_ADAPTERS; ++ulAdapterIndex)
        {
            // Does call want to look on specific adapter, or any?
            if (ulCalledID == 0 || ulCalledID == ulAdapterIndex+1)
            {
                pAdapter = g_Adapters[ulAdapterIndex];
                if (pAdapter)
                {
                    // Find first available channel.
                    NdisAcquireSpinLock(&pAdapter->EventLock);
                    if (!IsListEmpty(&pAdapter->BChannelAvailableList))
                    {
                        PBCHANNEL_OBJECT    pBChannel;
                        pBChannel = (PBCHANNEL_OBJECT) pAdapter->BChannelAvailableList.Blink;
                        if (pBChannel->NdisSapHandle &&
                            pBChannel->NdisVcHandle == NULL)
                        {
                            // Find first available listening channel.
                            pBChannel = (PBCHANNEL_OBJECT) RemoveTailList(
                                            &pAdapter->BChannelAvailableList);
                            // Reset the link info so we can tell that it's 
                            // not on the list.
                            InitializeListHead(&pBChannel->LinkList);
                            NdisReleaseSpinLock(&pAdapter->EventLock);
                            return (pBChannel);
                        }
                    }
                    NdisReleaseSpinLock(&pAdapter->EventLock);
                }
            }
        }
    }
    return (NULL);
}


/* @doc INTERNAL Card Card_c CardNotifyEvent


@func

    <f CardNotifyEvent> queues an IMS event to be processed by the DPC
    handler when things quiet down.

@comm

    We have to queue the event to be processed in DPC context.  We have
    to make sure that the queue is protected by a mutual exclusion
    primative which cannot be violated by the callback.

*/

VOID CardNotifyEvent(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PCARD_EVENT_OBJECT       pEvent                      // @parm
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.
    )
{
    DBG_FUNC("CardNotifyEvent")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    // DBG_ENTER(pAdapter);

    /*
    // Schedule the event handler to run as soon as possible.
    // We must schedule the event to go through the NDIS wrapper
    // so the proper spin locks will be held.
    // Don't schedule another event if processing is already in progress.
    */
    NdisAcquireSpinLock(&pAdapter->EventLock);
    InsertTailList(&pAdapter->EventList, &pEvent->Queue);
    NdisReleaseSpinLock(&pAdapter->EventLock);
    if (pEvent->ulEventCode == CARD_EVENT_RING ||
        pEvent->ulEventCode == CARD_EVENT_CONNECT ||
        pEvent->ulEventCode == CARD_EVENT_DISCONNECT)
    {
        NdisMSetTimer(&pAdapter->EventTimer, 100);
    }
    else
    {
        NdisMSetTimer(&pAdapter->EventTimer, 0);
    }

    // DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardEventAllocate


@func

    <f CardEventAllocate> allocates an <t CARD_EVENT_OBJECT> from the
    <p pCard>'s EventList.

@rdesc

    <f CardEventAllocate> returns a pointer to a <t CARD_EVENT_OBJECT>
    if it is successful.<nl>
    Otherwise, a NULL return value indicates an error condition.

*/

PCARD_EVENT_OBJECT CardEventAllocate(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    PCARD_EVENT_OBJECT          pEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    pEvent = &pCard->EventArray[pCard->NextEvent++];
    ASSERT(pEvent->pReceivingObject == NULL);
    if (pCard->NextEvent >= MAX_EVENTS)
    {
        pCard->NextEvent = 0;
    }
    return (pEvent);
}


/* @doc INTERNAL Card Card_c CardEventRelease


@func

    <f CardEventRelease> returns a previously allocate <t CARD_EVENT_OBJECT>
    to the <p pCard>'s EventList.

*/

VOID CardEventRelease(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PCARD_EVENT_OBJECT       pEvent                      // @parm
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.
    )
{
    pEvent->pReceivingObject = NULL;
}

#endif // SAMPLE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\card.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Card Card_h

@module Card.h |

    This module defines the hardware specific structures and values used to
    control the network interface card.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Card_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.2 Card Overview |

    This section describes the interfaces defined in <f Card\.h>.

    This module isolates most the vendor specific hardware access interfaces.
    It will require signficant changes to accomodate your hardware device.
    You should try to isolate your changes to the <t CARD_OBJECT> rather then
    the <t MINIPORT_ADAPTER_OBJECT>.  This will make it eaiser to reuse the
    upper portions of the driver should your hardware change in the future.

    The driver assumes one <t CARD_OBJECT> per physical ISDN card.  The card
    object is always available via the <t MINIPORT_ADAPTER_OBJECT> which is
    available in nearly every interface the driver supports.  Each
    <t CARD_OBJECT> contains one or more <t PORT_OBJECT>s depending on how
    many physical ISDN lines your card supports.

    You should add all your physical card related data to the <t CARD_OBJECT>.
    You can also add any card related registry parameters to this structure,
    and the <f g_CardParameters> table.
*/

#ifndef _CARD_H
#define _CARD_H

#define CARD_OBJECT_TYPE                ((ULONG)'C')+\
                                        ((ULONG)'A'<<8)+\
                                        ((ULONG)'R'<<16)+\
                                        ((ULONG)'D'<<24)

/*
// TODO - These values will normally come from the NIC or the installer.
*/
#define MAX_ADAPTERS                    8
#define CARD_NUM_PORTS                  1

//#define CARD_MIN_IOPORT_SIZE            256
// TODO - How many I/O ports does the card have?  (undefined if none)

//#define CARD_MIN_MEMORY_SIZE            256
// TODO - How much memory does the card have?  (undefined if none)

#define CARD_IS_BUS_MASTER              FALSE
// TODO - Is the card a bus master device?  (TRUE or FALSE)
#if (CARD_IS_BUS_MASTER)
#   define CARD_MAP_REGISTERS_NEEDED    NUM_DEV_PER_ADAP
// TODO - How many map registers needed to transmit data to card.
#endif

//#define CARD_REQUEST_ISR                TRUE
// TODO - How do you want to handle interrupts from the card?
// TRUE if you want to always use MiniportISR().
// FALSE if you want to use MiniportDisable() and MiniportEnable().
// Undefined if your card does not generate interrupts.

#if defined(CARD_REQUEST_ISR)

#define CARD_INTERRUPT_SHARED           TRUE
// TODO - Is your interrupt shared? (TRUE or FALSE).

#define CARD_INTERRUPT_MODE             NdisInterruptLevelSensitive
// TODO - Is your interrupt latched or level sensitve?

#endif // defined(CARD_REQUEST_ISR)

/*
// Maximum packet size allowed by the adapter -- must be restricted to
// 1500 bytes at this point, and must also allow for frames at least 32
// bytes longer.
*/
#define NDISWAN_EXTRA_SIZE              32
#define CARD_MIN_PACKET_SIZE            ( 480 + NDISWAN_EXTRA_SIZE)
#define CARD_MAX_PACKET_SIZE            (2016 + NDISWAN_EXTRA_SIZE)
#define CARD_DEFAULT_PACKET_SIZE        (1504 + NDISWAN_EXTRA_SIZE)

/*
// The WAN miniport must indicate the entire packet when it is received.
*/
#define CARD_MAX_LOOKAHEAD              (pAdapter->pCard->BufferSize)

/*
// Number of digits allowed in a phone number (not including spaces).
*/
#define CARD_MAX_DIAL_DIGITS            32

#define NULL_BUFFER_POOL                ((NDIS_HANDLE) -1)

/* @doc INTERNAL Card Card_h CARD_RESOURCES


@struct CARD_RESOURCES |

    This structure contains the data associated with the hardware resources
    required to configure the NIC.  These values are isolated from the rest
    of the <t CARD_OBJECT> because they depend on the underlying hardware.

@comm

    The contents of this structure depends on compile time flags and should
    only include information about the resource actually used by the NIC.

    This structure is filled in by <f CardFindNIC> and is used to configure
    and allocate resources from NDIS when <f CardInitialize> is called.

*/

typedef struct CARD_RESOURCES
{
    NDIS_INTERFACE_TYPE         BusInterfaceType;           // @field
    // This value is used to tell NDIS what type of adapter this is.
    // This is usually the same as the registry parameter BusType, but
    // may be different in the case of a bridged adapter.

    BOOLEAN                     Master;                     // @field
    // This is TRUE if the adapter is capable of bus master transfers.
    // Use the <t CARD_IS_BUS_MASTER> defininition to set this value
    // so the other bus master values will be included if needed.
    // See <f NdisMAllocateMapRegisters> for more details on the bus
    // master parameters.

#if (CARD_IS_BUS_MASTER)
    BOOLEAN                     Dma32BitAddresses;          // @field
    // This is TRUE if the bus master device uses 32-bit addresses.
    // Almost always TRUE for today's devices.

    ULONG                       PhysicalMapRegistersNeeded; // @field
    // This should be set to the maximum number of outstanding DMA
    // transfers that can be active at one time.  One for each physical
    // buffer segment.

    ULONG                       MaximumPhysicalMapping;     // @field
    // This should be set to the maximum number of contigous bytes that
    // can make up a single DMA transfer.

    ULONG                       DmaChannel;                 // @field
    // This should only be set if your adapter is an ISA bus master and
    // requires the use of one of the host DMA channels.

#endif // (CARD_IS_BUS_MASTER)

#if defined(CARD_MIN_MEMORY_SIZE)
    ULONG                       MemoryLength;               // @field
    // The number of bytes of memory the NIC has on board.
    // Use the <t CARD_MIN_MEMORY_SIZE> defininition to set the minimum value
    // so the other NIC based memory values will be included if needed.

    NDIS_PHYSICAL_ADDRESS       MemoryPhysicalAddress;      // @field
    // System physical address assigned to the NIC's on board memory.

#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    ULONG                       IoPortLength;               // @field
    // The number of bytes of I/O ports the NIC has on board.
    // Use the <t CARD_MIN_IOPORT_SIZE> defininition to set the minimum value
    // so the other NIC based memory values will be included if needed.

    NDIS_PHYSICAL_ADDRESS       IoPortPhysicalAddress;      // @field
    // System physical address assigned to the NIC's on board I/O ports.

#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_REQUEST_ISR)
    ULONG                       InterruptVector;            // @field
    // System interrupt vector assigned to the NIC's interrupt request line.

    ULONG                       InterruptLevel;             // @field
    // System interrupt level assigned to the NIC's interrupt request line.

    ULONG                       InterruptMode;              // @field
    // Set this value to NdisInterruptLevelSensitive or NdisInterruptLatched.
    // Use the <t CARD_INTERRUPT_MODE> defininition to set this value.

    BOOLEAN                     InterruptShared;            // @field
    // Set TRUE if you want to allow the NIC's <f InterruptVector> to be
    // shared with other drivers in the system.
    // Use the <t CARD_INTERRUPT_SHARED> defininition to set this value.

#endif // defined(CARD_REQUEST_ISR)

} CARD_RESOURCES;


#if !defined(CARD_REQUEST_ISR)


/* @doc INTERNAL Card Card_h CARD_EVENT_CODE


@enum CARD_EVENT_CODE |

    This enumeration defines the events generated by the card.

*/

typedef enum CARD_EVENT_CODE
{
    CARD_EVENT_NULL,                                        // @emem
    // Not used for anything.

    CARD_EVENT_RING,                                        // @emem
    // Indicates that a call is incoming on the given BChannel.

    CARD_EVENT_CONNECT,                                     // @emem
    // Indicates that a call is connected on the given BChannel.

    CARD_EVENT_DISCONNECT,                                  // @emem
    // Indicates that a call is disconnected on the given BChannel.

    CARD_EVENT_RECEIVE,                                     // @emem
    // Indicates that a packet is incoming on the given BChannel.

    CARD_EVENT_TRANSMIT_COMPLETE                            // @emem
    // Indicates that the transmit is complete on the given BChannel.

} CARD_EVENT_CODE;

/* @doc INTERNAL Card Card_h CARD_EVENT_OBJECT


@struct CARD_EVENT_OBJECT |

    This structure is used to keep track of events passed between the
    callee and caller.  Each <t CARD_OBJECT> keeps a list of these events.
*/

typedef struct CARD_EVENT_OBJECT
{
    LIST_ENTRY                  Queue;                      // @field
    // Used to place the buffer on one of the receive lists.

    CARD_EVENT_CODE             ulEventCode;                // @field
    // Reason for event notification.

    PVOID                       pSendingObject;             // @field
    // Interface object that is notifying.  See <t BCHANNEL_OBJECT> or
    // <t DCHANNEL_OBJECT>,

    PVOID                       pReceivingObject;           // @field
    // Interface object that is notifying.  See <t BCHANNEL_OBJECT> or
    // <t DCHANNEL_OBJECT>,

    PNDIS_PACKET                pNdisPacket;                // @field
    // A pointer to the associated NDIS packet structure <t NDIS_PACKET>.

} CARD_EVENT_OBJECT, *PCARD_EVENT_OBJECT;

#endif // !defined(CARD_REQUEST_ISR)


/* @doc INTERNAL Card Card_h CARD_OBJECT


@struct CARD_OBJECT |

    This structure contains the data associated with the Network Interface
    Card (NIC).  This object is responsible for managing all the hardware
    specific components of the NIC.

@comm

    The <t MINIPORT_ADAPTER_OBJECT> manages the interface between NDIS and
    the driver, and then passes off the hardware specific interface to this
    object.  There is one <t CARD_OBJECT> for each <t MINIPORT_ADAPTER_OBJECT>.

    One of these objects is created each time that our <f MiniportInitialize>
    routine is called.  The NDIS wrapper calls this routine once for each of
    NIC installed and enabled in the system.  In the case of a hot swappable
    NIC (e.g. PCMCIA) the adapter might come and go several times during a
    single Windows session.

*/

typedef struct CARD_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'CARD'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    CARD_RESOURCES              ResourceInformation;        // @field
    // Contains adapter specific resource requirements and settings.
    // See <t CARD_RESOURCES>.

    ULONG                       InterruptStatus;            // @field
    // Bits indicating which interrupts need to be processed.

    NDIS_MINIPORT_INTERRUPT     Interrupt;                  // @field
    // Miniport interrupt object used by NDIS.

    USHORT                      ReceiveBuffersPerLink;      // @field
    // Maximum number of receive buffers per channel, registry parameter.

    USHORT                      TransmitBuffersPerLink;     // @field
    // Maximum number of transmit buffers per channel, registry parameter.

    USHORT                      BufferSize;                 // @field
    // The maxmimum packet size.  The NDISWAN spec says this must be 1500+32,
    // but everything seems to work okay if it is set smaller.

    ULONG                       NumChannels;                // @field
    // Number of communication channels configured on the NIC.

    ULONG                       NumPorts;                   // @field
    // Number of <t PORT_OBJECT>'s allocated in <p pPortArray>.

    PPORT_OBJECT *              pPortArray;                 // @field
    // An array of <t PORT_OBJECT>'s created by <f PortCreate>.
    // One entry for each port on NIC.

#if defined(PCI_BUS)
    ULONG                       PciSlotNumber;              // @field
    // PCI slot number for this adapter (FunctionNumber * 32) + DeviceNumber.

#endif // PCI_BUS

#if defined(CARD_MIN_MEMORY_SIZE)
    PCHAR                       pMemoryVirtualAddress;      // @field
    // Virtual adress of NIC memory area.

#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    PCHAR                       pIoPortVirtualAddress;      // @field
    // Virtual adress of NIC I/O port area.

#endif // CARD_MIN_IOPORT_SIZE

#if (CARD_IS_BUS_MASTER)
    ULONG                       MapRegisterIndex;           // @field
    // Next map register index to be used for DMA transfer.

    long                        MapRegistersInUse;          // @field
    // Number of map registers currently in use.

#endif // (CARD_IS_BUS_MASTER)

    NDIS_HANDLE                 PacketPoolHandle;           // @field
    // Internal message packet pool.

    NDIS_HANDLE                 BufferPoolHandle;           // @field
    // Internal message buffer pool.

    PUCHAR                      MessagesVirtualAddress;     // @field
    // Pointer to the message buffer area used for incoming packets.

    LIST_ENTRY                  MessageBufferList;          // @field
    // List of available message buffers.

    NDIS_SPIN_LOCK              MessageBufferLock;          // @field
    // Spin lock used to protect <p MessageBufferList>.

    ULONG                       NumMessageBuffers;          // @field
    // Number of message buffers to allocate for <p MessageBufferList>.

    ULONG                       TODO;                       // @field
    // Add your data members here.

    ULONG                       NumDChannels;               // @field
    // The sample driver uses this registry value to determine the number
    // of ports to simulate.

#if defined(SAMPLE_DRIVER)

    LIST_ENTRY                  EventList;                  // @field
    // Events waiting to be processed.  See <t CARD_EVENT_OBJECT>.

#   define MAX_EVENTS 32
    CARD_EVENT_OBJECT           EventArray[MAX_EVENTS];     // @field
    // Card event allocation array.

    ULONG                       NextEvent;                  // @field
    // Index into EventArray.

#endif // SAMPLE_DRIVER

} CARD_OBJECT;

#define GET_ADAPTER_FROM_CARD(pCard)        (pCard->pAdapter)

#define GET_QUEUE_FROM_PACKET(pNdisPacket)\
                ((PLIST_ENTRY) pNdisPacket->MiniportReservedEx)
#define GET_PACKET_FROM_QUEUE(pList)\
                CONTAINING_RECORD(pList, NDIS_PACKET, MiniportReservedEx)

/*

    Object Interface Prototypes
*/

NDIS_STATUS CardCreate(
    OUT PCARD_OBJECT *          ppCard,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void CardDestroy(
    IN PCARD_OBJECT             pCard
    );

NDIS_STATUS CardInitialize(
    IN PCARD_OBJECT             pCard
    );

ULONG CardNumChannels(
    IN PCARD_OBJECT             pCard
    );

ULONG CardNumPorts(
    IN PCARD_OBJECT             pCard
    );

void CardInterruptHandler(
    IN PCARD_OBJECT             pCard
    );

BOOLEAN CardTransmitPacket(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PNDIS_PACKET             pNdisPacket
    );

USHORT CardCleanPhoneNumber(
    OUT PUCHAR                  Dst,
    IN  PUSHORT                 Src,
    IN  USHORT                  Length
    );

NDIS_STATUS CardReset(
    IN PCARD_OBJECT             pCard
    );

#if defined(SAMPLE_DRIVER)

PBCHANNEL_OBJECT GET_BCHANNEL_FROM_PHONE_NUMBER(
    IN  PUCHAR                  pDialString
    );

VOID CardNotifyEvent(
    IN PCARD_OBJECT             pCard,
    IN PCARD_EVENT_OBJECT       pEvent
    );

PCARD_EVENT_OBJECT CardEventAllocate(
    IN PCARD_OBJECT             pCard
    );

VOID CardEventRelease(
    IN PCARD_OBJECT             pCard,
    IN PCARD_EVENT_OBJECT       pEvent
    );

#endif // SAMPLE_DRIVER

#endif // _CARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\keywords.h ===
/*

                                                                             
    (C) Copyright 1999 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Keywords Keywords_h

@module Keywords.h |

    This file defines the driver parameter keywords used in the registry.
    This file should be #include'd into the driver module defining the
    configuration parameter table <t PARAM_TABLE>.

@comm

    The configuration parmaeters should be parsed early in the initialization
    process so they can be used to configure software and hardware settings.

    You can easily add new parameters using the following procuedure:<nl>
    1) #define a new keyword string here in <f Keywords\.h>.<nl>
    2) Add a corresponding <f PARAM_ENTRY> into your parameter table <t PARAM_TABLE>.<nl>
    3) Add a variable to the associated data structure (e.g. <t MINIPORT_ADAPTER_OBJECT>).

    These values can then be parsed by calling <f ParamParseRegistry> with a 
    pointer to your configuration parameter table <t PARAM_TABLE>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Keywords_h

@end

*/


/* @doc EXTERNAL INTERNAL


@topic 5.0 Registry Parameters |

    This section describes the registry parameters used by the driver.
    These parameters are stored in the following registry path.<nl>
    
    Windows registry path:<nl>
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\"Net"\0001><nl>

    On Windows 2000 "Net" is defined as GUID: {4D36E972-xxxx}

    On Windows 98 "Net" is just a sub key.

    The final path key "\0001" depends on the adapter instance number assigned
    by NDIS during installation.<nl>

    <f Note>: Windows 98 DWORD registry parameters are stored as strings.  
    The NDIS wrapper converts them to integers when they are read.  The string 
    can be decimal or hexadecimal as long as you read it with the appropriate 
    NDIS parameter type NdisParameterInteger or NdisParameterHexInteger.

    These values are declared as entries in the <t PARAM_TABLE> and are parsed 
    from the registry using the <f ParamParseRegistry> routine.  Each object
    in the driver has its own parameter table.
	
*/

#ifndef _KEYWORDS_H
#define _KEYWORDS_H

#define PARAM_MAX_KEYWORD_LEN               128

/*
// These parameters are placed in the registry during installation.
*/
#define PARAM_NumDChannels                  "IsdnNumDChannels"
#define PARAM_NumBChannels                  "IsdnNumBChannels"

/*
// These parameters are not placed in the registry by default, but they
// will be used if present.
*/
#define PARAM_BufferSize                    "BufferSize"
#define PARAM_ReceiveBuffersPerLink         "ReceiveBuffersPerLink"
#define PARAM_TransmitBuffersPerLink        "TransmitBuffersPerLink"
#define PARAM_DebugFlags                    "DebugFlags"

#define PARAM_TODO                          "TODO"
// Add your keywords here, and place them in the proper parameter table.

// Port based parameters
#define PARAM_PORT_PREFIX                   "Line" // Line0 .. Line9
#define PARAM_SwitchType                    "IsdnSwitchType"

#endif // _KEYWORDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\dchannel.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL DChannel DChannel_c

@module DChannel.c |

    This module implements the interface to the <t DCHANNEL_OBJECT>.
    Supports the high-level channel control functions used by the CONDIS WAN
    Minport driver.

@comm

    This module isolates most the vendor specific Call Control interfaces.
    It will require some changes to accomodate your hardware device's call
    control mechanism.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | DChannel_c

@end

*/

#define  __FILEID__             DCHANNEL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                g_DChannelInstanceCounter   // @globalv
// Keeps track of how many <t DCHANNEL_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL DChannel DChannel_c g_DChannelParameters


@topic 5.4 DChannel Parameters |

    This section describes the registry parameters read into the
    <t DCHANNEL_OBJECT>.

@globalv PARAM_TABLE | g_DChannelParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t DCHANNEL_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t DCHANNEL_OBJECT>
    you will need to modify <f DChannelReadParameters> and add the parameter
    definitions to the <f g_DChannelParameters> table.

*/

DBG_STATIC PARAM_TABLE          g_DChannelParameters[] =
{
    PARAM_ENTRY(DCHANNEL_OBJECT,
                TODO, PARAM_TODO,
                FALSE, NdisParameterInteger, 0,
                0, 0, 0),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL DChannel DChannel_c DChannelReadParameters


@func

    <f DChannelReadParameters> reads the DChannel parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f DChannelCreate>.

    <f Note>:
    If you add any registry based data members to <t DCHANNEL_OBJECT>
    you will need to modify <f DChannelReadParameters> and add the parameter
    definitions to the <f g_DChannelParameters> table.

@rdesc

    <f DChannelReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS DChannelReadParameters(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pDChannel,
                    g_DChannelParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pDChannel->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pDChannel->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCreateObjects


@func

    <f DChannelCreateObjects> calls the create routines for all the objects
    contained in <t DCHANNEL_OBJECT>.  This should only be called
    by <f DChannelCreate>.

    <f Note>:
    If you add any new objects to <t DCHANNEL_OBJECT> you will need
    to modify <f DChannelCreateObjects> and <f DChannelDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f DChannelCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS DChannelCreateObjects(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to allocate any sub-objects needed to support
    // your physical DChannels.

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCreate


@func

    <f DChannelCreate> allocates memory for a <t DCHANNEL_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppDChannel> will be set to point to the newly created
    <t DCHANNEL_OBJECT>.  Otherwise, <p ppDChannel> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f DChannelDestroy> must be called to
    release the <t DCHANNEL_OBJECT> created by this function.

@rdesc

    <f DChannelCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelCreate(
    OUT PDCHANNEL_OBJECT *      ppDChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t DCHANNEL_OBJECT>.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("DChannelCreate")

    PDCHANNEL_OBJECT            pDChannel;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppDChannel = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pDChannel, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pDChannel->ObjectType = DCHANNEL_OBJECT_TYPE;
        pDChannel->ObjectID = ++g_DChannelInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pDChannel->pAdapter = pAdapter;

        // TODO - Add code here to allocate any resources needed to support
        // your physical DChannels.

        /*
        // Parse the registry parameters.
        */
        Result = DChannelReadParameters(pDChannel);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = DChannelCreateObjects(pDChannel);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppDChannel = pDChannel;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            DChannelDestroy(pDChannel);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDestroyObjects


@func

    <f DChannelDestroyObjects> calls the destroy routines for all the objects
    contained in <t DCHANNEL_OBJECT>.  This should only be called by
    <f DChannelDestroy>.

    <f Note>: If you add any new objects to <t PDCHANNEL_OBJECT> you will need to
    modify <f DChannelCreateObjects> and <f DChannelDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void DChannelDestroyObjects(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to release any sub-objects allocated by
    // DChannelCreateObjects.

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDestroy


@func

    <f DChannelDestroy> frees the memory for this <t DCHANNEL_OBJECT>.
    All memory allocated by <f DChannelCreate> will be released back to the
    OS.

*/

void DChannelDestroy(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pDChannel)
    {
        ASSERT(pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

        DBG_ENTER(pAdapter);

        // TODO - Add code here to release any resources allocated by
        // DChannelCreate.

        /*
        // Release all objects allocated within this object.
        */
        DChannelDestroyObjects(pDChannel);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pDChannel->ObjectType = 0;
        FREE_OBJECT(pDChannel);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL DChannel DChannel_c DChannelInitialize


@func

    <f DChannelInitialize> resets all the internal data members contained
    in <t BCHANNEL_OBJECT> back to their initial state.

    <f Note>:
    If you add any new members to <t DCHANNEL_OBJECT> you will need to
    modify <f DChannelInitialize> to initialize your new data mamebers.

*/

void DChannelInitialize(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelInitialize")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to initialize all the physical D-Channels on
    // your adapter.

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelOpen


@func

    <f DChannelOpen> establishes a communications path between the miniport
    and the DChannel.

@rdesc

    <f DChannelOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelOpen(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (++pDChannel->IsOpen == 1)
    {
        DBG_NOTICE(pAdapter,("Opening DChannel #%d\n",
                   pDChannel->ObjectID));

        // TODO - Add code here to open all the physical D-Channels on
        // your adapter.
    }
    else
    {
        DBG_NOTICE(pAdapter,("DChannel #%d already opened\n",
                   pDChannel->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelClose


@func

    <f DChannelClose> tears down the communications path between the miniport
    and the DChannel.

*/

void DChannelClose(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (pDChannel->IsOpen == 1)
    {
        DBG_NOTICE(pAdapter,("Closing DChannel #%d\n",
                   pDChannel->ObjectID));

        // TODO - Add code here to close all the physical D-Channels on
        // your adapter.
        pDChannel->IsOpen = 0;
    }
    else if (pDChannel->IsOpen == 0)
    {
        DBG_WARNING(pAdapter,("DChannel #%d already closed\n",
                    pDChannel->ObjectID));
    }
    else
    {
        pDChannel->IsOpen--;
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelMakeCall


@func

    <f DChannelMakeCall> places a call over the selected line device.

@rdesc

    <f DChannelMakeCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelMakeCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PUCHAR                   DialString,                 // @parm
    // A pointer to an ASCII null-terminated string of digits.

    IN USHORT                   DialStringLength,           // @parm
    // Number of bytes in dial string.

    IN PLINE_CALL_PARAMS        pLineCallParams             // @parm
    // A pointer to the TAPI <t LINE_CALL_PARAMS> to be used for this call.
    )
{
    DBG_FUNC("DChannelMakeCall")

    NDIS_STATUS                 Result = NDIS_STATUS_RESOURCES;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    pDChannel->TotalMakeCalls++;
    pBChannel->Flags |= VCF_OUTGOING_CALL;
    pBChannel->CallState = LINECALLSTATE_DIALING;

#if defined(SAMPLE_DRIVER)
    // This sample code uses the phone number to select one of the other
    // BChannels on which to complete the connection.
{
    PBCHANNEL_OBJECT            pPeerBChannel;
    PCARD_EVENT_OBJECT          pEvent;

    pPeerBChannel = GET_BCHANNEL_FROM_PHONE_NUMBER(DialString);
    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            pEvent->ulEventCode      = CARD_EVENT_RING;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            pBChannel->pPeerBChannel = pPeerBChannel;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            Result = NDIS_STATUS_PENDING;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("Cannot map phone number '%s' to BChannel\n",
                  DialString));
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to place a call.
#endif // SAMPLE_DRIVER

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelAnswerCall


@func

    <f DChannelAnswerCall> answers the incoming call so it can be connected.

@rdesc

    <f DChannelAnswerCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelAnswerCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelAnswerCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    pDChannel->TotalAnswers++;

#if defined(SAMPLE_DRIVER)
    // This sample code sends a connect over to the calling BChannel.
{
    PCARD_EVENT_OBJECT          pEvent;
    PBCHANNEL_OBJECT            pPeerBChannel = pBChannel->pPeerBChannel;

    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            pEvent->ulEventCode      = CARD_EVENT_CONNECT;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
        }
        else
        {
            Result = NDIS_STATUS_RESOURCES;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
        Result = NDIS_STATUS_RESOURCES;
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to answer a call.

    // If you return NDIS_STATUS_PENDING from here, you must perform the
    // following actions when the call is finally answered.
    //      pBChannel->CallState = LINECALLSTATE_CONNECTED;
    //      NdisMCmDispatchCallConnected(pBChannel->NdisVcHandle);
    // If you fail to answer for some reason you must call:
    //      InitiateCallTeardown(pAdapter, pBChannel);

#endif // SAMPLE_DRIVER

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCloseCall


@func

    <f DChannelCloseCall> closes a previously opened call instance as
    initiated from <f DChannelMakeCall> or <f DChannelAnswerCall>.  After
    the call is closed, no one else should reference it.

@rdesc

    <f DChannelCloseCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelCloseCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelCloseCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    // This routine may be called several times during line/call cleanup.
    // If the call is already closed, just return success.
    if (pBChannel->CallState != 0 &&
        pBChannel->CallState != LINECALLSTATE_IDLE)
    {
#if defined(SAMPLE_DRIVER)
        // This sample code sends a disconnect over to the connected BChannel.
        PCARD_EVENT_OBJECT      pEvent;
        PBCHANNEL_OBJECT        pPeerBChannel = pBChannel->pPeerBChannel;

        if (pPeerBChannel)
        {
            pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
            if (pEvent)
            {
                // Indicate call disconnect to the other channel.
                pEvent->ulEventCode      = CARD_EVENT_DISCONNECT;
                pEvent->pSendingObject   = pBChannel;
                pEvent->pReceivingObject = pPeerBChannel;
                CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            }
            pBChannel->pPeerBChannel = NULL;
        }
        else
        {
            DBG_WARNING(pAdapter,("#%d NO PEER CHANNEL - CALLSTATE=%X\n",
                        pBChannel->ObjectID, pBChannel->CallState));
        }
        // Return any pending packets to the protocol stack.
        pBChannel->CallState = LINECALLSTATE_IDLE;
#else  // SAMPLE_DRIVER
        // TODO - Add code here to drop a call.
#endif // SAMPLE_DRIVER

        // Make sure there are no packets left on this channel before it closes.
        FlushSendPackets(pAdapter, pBChannel);
    }
    else
    {
        DBG_NOTICE(pAdapter,("#%d ALREADY IDLE - CALLSTATE=%X\n",
                   pBChannel->ObjectID, pBChannel->CallState));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelRejectCall


@func

    <f DChannelRejectCall> rejects an incoming call on the specified
    channel.

*/

VOID DChannelRejectCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelRejectCall")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (pBChannel->CallState != 0 &&
        pBChannel->CallState != LINECALLSTATE_IDLE)
    {
#if defined(SAMPLE_DRIVER)
        // This sample code sends a disconnect over to the connected BChannel.
        PCARD_EVENT_OBJECT      pEvent;
        PBCHANNEL_OBJECT        pPeerBChannel = pBChannel->pPeerBChannel;

        if (pPeerBChannel)
        {
            pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
            if (pEvent)
            {
                // Indicate call disconnect to the other channel.
                pEvent->ulEventCode      = CARD_EVENT_DISCONNECT;
                pEvent->pSendingObject   = pBChannel;
                pEvent->pReceivingObject = pPeerBChannel;
                CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            }
            pBChannel->pPeerBChannel = NULL;
        }
        else
        {
            DBG_WARNING(pAdapter,("#%d NO PEER CHANNEL - CALLSTATE=%X\n",
                        pBChannel->ObjectID, pBChannel->CallState));
        }
        // Return any pending packets to the protocol stack.
        pBChannel->CallState = LINECALLSTATE_IDLE;
#else  // SAMPLE_DRIVER
        // TODO - Add code here to reject an incoming call.
#endif // SAMPLE_DRIVER
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\callmgr.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL CallMgr CallMgr_c

@module CallMgr.c |

    This module defines the interface to the <t CALL_MANAGER_OBJECT>.
    Supports the interface between NDISPROXY and the Miniport.  All the
    Address Family, SAP, VC, and call related events pass through these
    interface on their way to and from NDPROXY.

@comm

    This module will require some changes depending on how your hardware
    works.  But in general, you should try to isolate your changes down in
    <f DChannel\.c> and <f Card\.c>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | CallMgr_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.1 Call Manager Interface |

    The NDPROXY driver is a provider for the Windows Telephony service.
    Applications make TAPI requests and the Windows Telephony service routes
    these requests to NDPROXY. NDPROXY implements the Telephony Service Provider
    Interface (TSPI) for the Windows Telephony service. NDPROXY then
    communicates through NDIS with the NDISWAN driver and CoNDIS WAN miniport
    drivers. These CoNDIS WAN miniport drivers must provide TAPI capability.

    The NDPROXY driver passes TAPI requests by encapsulating TAPI parameters in
    NDIS structures. NDPROXY presents a client interface to CoNDIS WAN miniport
    drivers and a call manager interface to NDISWAN. NDISWAN presents a client
    interface to NDPROXY. CoNDIS WAN miniport drivers present a call manager
    interface to NDPROXY and a CoNDIS miniport interface to NDISWAN.

    A TAPI-capable CoNDIS WAN miniport driver registers and initializes itself
    as a user of both WAN and TAPI services. After registration and
    initialization are complete, a user-level application can make telephonic
    requests to the Windows Telephony service module, which converts TAPI
    requests to TSPI requests. The Windows Telephony service module passes these
    requests to the NDPROXY driver. NDPROXY encapsulates parameters for TAPI
    requests in NDIS structures and routes the requests to the appropriate
    CoNDIS WAN miniport driver. These requests are routed in order to set up,
    monitor, and tear down lines, and calls.

    A TAPI-capable CoNDIS WAN miniport driver can also communicate changes in
    the states of lines and calls, for instance the arrival of an incoming call
    or a remote disconnection.

@ex Registering and opening the TAPI address family between NDPROXY and MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    |                                  | NdisMCmRegisterAddressFamily     |
    | ProtocolCoAfRegisterNotify       |---------------------------------|
    |---------------------------------|                                  |
    | NdisClOpenAddressFamily          |                                  |
    |---------------------------------| ProtocolCmOpenAf                 |
    |                                  |---------------------------------|
    |                                  |                 CompleteCmOpenAf |
    |                                  | NdisCmOpenAddressFamilyComplete  |
    | ProtocolOpenAfComplete           |---------------------------------|
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@ex Closing the TAPI address family between NDPROXY and MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisClCloseAddressFamily         |                                  |
    |---------------------------------| ProtocolCmCloseAf                |
    |                                  |---------------------------------|
    |                                  |                CompleteCmCloseAf |
    |                                  | NdisMCmCloseAddressFamilyComplete|
    | ProtocolClCloseAfComplete        |---------------------------------|
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@ex Registering a SAP between NDPROXY and MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisClRegisterSap                |                                  |
    |---------------------------------| ProtocolCmRegisterSap            |
    |                                  |---------------------------------|
    |                                  |            CompleteCmRegisterSap |
    |                                  | NdisMCmRegisterSapComplete       |
    | ProtocolClRegisterSapComplete    |---------------------------------|
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@ex Deregistering a SAP between NDPROXY and MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisClDeregisterSap              |                                  |
    |---------------------------------| ProtocolCmDeregisterSap          |
    |                                  |---------------------------------|
    |                                  |          CompleteCmDeregisterSap |
    |                                  | NdisMCmDeregisterSapComplete     |
    | ProtocolClDeregisterSapComplete  |---------------------------------|
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@ex Seting up an outgoing call from NDPROXY to MCM |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisCoCreateVc                   | ProtocolCoCreateVC               |
    |---------------------------------|--------------------------------|
    | NdisClMakeCall                   | ProtocolCmMakeCall               |
    |---------------------------------|---------------------------------|
    |               .                  |                .                 |
    |               .                  |                .                 |
    |               .                  |                .                 |
    |                                  | NdisMCmActivateVC                |
    |                                  |---------------------------------|
    |                                  | ProtocolCmActivateVcComplete     |
    |                                  |---------------------------------|
    | ProtocolClMakeCallComplete       | NdisMCmMakeCallComplete          |
    |--------------------------------|---------------------------------|
    |               .                  |                .                 |
    |               .    "Tranmit & receive packets"    .                 |
    |               .                  |                .                 |
    |              "Client/MCM initiated call termination"                |
    | NdisCoDeleteVc                   | ProtocolCoDeleteVc               |
    |---------------------------------|--------------------------------|
    |----------------------------------|----------------------------------|

@ex Setting up an incoming call from MCM to NDPROXY |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisCoCreateVc                   | NdisMCmCreateVC                  |
    |--------------------------------|---------------------------------|
    |                                  | NdisMCmActivateVC                |
    |                                  |---------------------------------|
    |                                  | ProtocolCmActivateVcComplete     |
    |                                  |---------------------------------|
    | ProtocolClIncomingCall           | NdisMCmDispatchIncomingCall      |
    |---------------------------------|---------------------------------|
    |                                  |                                  |
    | NdisClIncomingCallComplete       | ProtocolCmIncomingCallComplete   |
    |---------------------------------|--------------------------------|
    | ProtocolClCallConnected          | NdisMCmDispatchCallConnected     |
    |--------------------------------|---------------------------------|
    |               .                  |                .                 |
    |               .    "Tranmit & receive packets"    .                 |
    |               .                  |                .                 |
    |              "Client/MCM initiated call termination"                |
    | ProtocolCoDeleteVc               | NdisMCmDeleteVc                  |
    |--------------------------------|---------------------------------|
    |----------------------------------|----------------------------------|

@ex NDPROXY initiated call termination |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | NdisClCloseCall                  | ProtocolCmCloseCall              |
    |---------------------------------|---------------------------------|
    |                                  | NdisMCmDeactivateVc              |
    |                                  |---------------------------------|
    |                                  | ProtocolCmDeactivateVcComplete   |
    |                                  |---------------------------------|
    | ProtocolClCloseCallComplete      | NdisCmCloseCallComplete          |
    |--------------------------------|---------------------------------|
    |----------------------------------|----------------------------------|

@ex MCM initiated call termination |

    NDPROXY                           NDIS                             MCM
    |----------------------------------|----------------------------------|
    | ProtocolClIncomingCloseCall      | NdisMCmDispatchIncomingCloseCall |
    |---------------------------------|---------------------------------|
    | NdisClCloseCall                  | ProtocolCmCloseCall              |
    |---------------------------------|---------------------------------|
    |                                  | NdisMCmDeactivateVc              |
    |                                  |---------------------------------|
    |                                  | ProtocolCmDeactivateVcComplete   |
    |                                  |---------------------------------|
    | ProtocolClCloseCallComplete      | NdisCmCloseCallComplete          |
    |--------------------------------|---------------------------------|
    |----------------------------------|----------------------------------|

@end
*/

#define  __FILEID__             CALL_MANAGER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


BOOLEAN ReferenceSap(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel               
    )
{
    BOOLEAN bResult;
    
    NdisAcquireSpinLock(&pAdapter->EventLock);

    if(pBChannel->SapRefCount > 0)
    {
        ASSERT(pBChannel->NdisSapHandle);
        
        pBChannel->SapRefCount++;           
        bResult = TRUE;
    }
    else
    {
        bResult = FALSE;
    }

    NdisReleaseSpinLock(&pAdapter->EventLock);
    
    return bResult;
}

VOID DereferenceSap(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel               
    )
{
    LONG lRef;
    
    NdisAcquireSpinLock(&pAdapter->EventLock);

    lRef = --pBChannel->SapRefCount;            
    
    ASSERT(pBChannel->NdisSapHandle);
    ASSERT(pBChannel->SapRefCount >= 0);

    NdisReleaseSpinLock(&pAdapter->EventLock);
    
    if(lRef == 0)
    {
        CompleteCmDeregisterSap(pBChannel, NDIS_STATUS_SUCCESS);
    }
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmOpenAf


@func

    <f CompleteCmOpenAf> is called when the miniport is done processing the
    <f ProtocolCmOpenAf> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmOpenAf>, you must
    call <f CompleteCmOpenAf> so that <f NdisMCmOpenAddressFamilyComplete>
    can be called to complete the request.

*/

VOID CompleteCmOpenAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // The NDIS status code to be passed to NdisMCmOpenAddressFamilyComplete.
    )
{
    DBG_FUNC("CompleteCmOpenAf")

    DBG_ENTER(pAdapter);

    /*
    // Try to connect to the DChannel.
    */
    DChannelOpen(pAdapter->pDChannel);

    NdisMCmOpenAddressFamilyComplete(Status, pAdapter->NdisAfHandle, pAdapter);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmOpenAf


@func

    <f ProtocolCmOpenAf> is a required function that allocates per-open
    resources for a call manager to interact with a connection-oriented NDIS
    client that is opening the address family.

@comm

    ProtocolCmOpenAf performs any required allocations of dynamic resources
    and structures that the call manager writer deems necessary to perform
    operations on behalf of the client that is opening an instance of this
    address family. Such resources include, but are not limited to, memory
    buffers, data structures, events, and other such similar resources. A call
    manager should also initialize any relevant per-open data before returning
    control to NDIS.

    When a call manager has allocated its per-open state area, the address of
    the state area should be set in the CallMgrAfContext handle before returning
    control to NDIS. To do this, dereference CallMgrAfContext and store a
    pointer to the data area as the value of the handle. For example:

    *CallMgrAfContext = SomeBuffer;     // We use <t MINIPORT_ADAPTER_OBJECT>.

    If ProtocolCmOpenAf cannot allocate the per-open resources it needs to
    carry out subsequent requests on behalf of the client opening this address
    family, it should free all resources that it allocated for the open and
    return control to the NDIS with NDIS_STATUS_RESOURCES.

    If ProtocolCmOpenAf has completed its required operations and the CM is
    ready to accept requests from the client, ProtocolCmOpenAf should return
    control as quickly as possible with a status of NDIS_STATUS_SUCCESS.

    ProtocolCmOpenAf must be written so that it can run at IRQL DISPATCH_LEVEL.

@rdesc

    ProtocolCmOpenAf returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager has successfully allocated and initialized
    any resources necessary to accept requests from the client to this address
    family.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the requested operation is being handled asynchronously. The
    call manager must call NdisCmOpenAddressFamilyComplete when it has completed
    all its open-AF operations to indicate to NDIS (and the client) that the
    operation(s) has been completed.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager could not complete its necessary
    operation(s) because of a lack of available system resources, such as
    memory.

@rvalue NDIS_STATUS_XXX |

    Indicates that the call manager could not set itself into a state where it
    can accept requests from the client to operate on this address family. This
    could be an error status propagated from another NDIS library function or
    any error status determined appropriate by the driver writer.

@xref

    NdisClOpenAddressFamily, NdisCmOpenAddressFamilyComplete,
    NdisCmRegisterAddressFamily, NdisOpenAdapter, <f ProtocolCmCloseAf>
*/

NDIS_STATUS ProtocolCmOpenAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.  AKA CallMgrBindingContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call managers maintains its per-binding state information. The call
    // manager supplied this handle when it called NdisOpenAdapter.

    IN PCO_ADDRESS_FAMILY       AddressFamily,              // @parm
    // Specifies the address family that a client is opening. This address
    // family was registered by the call manager when it called
    // NdisCmRegisterAddressFamily.

    IN NDIS_HANDLE              NdisAfHandle,               // @parm
    // Specifies a handle, supplied by NDIS, that uniquely identifies this
    // address family instance. This handle is opaque to the call manager and
    // reserved for system use.

    OUT PNDIS_HANDLE            CallMgrAfContext            // @parm
    // Specifies the handle to a call manager-supplied context area in which
    // the call manager maintains state about this open of an address family it
    // provides.
    )
{
    DBG_FUNC("ProtocolCmOpenAf")

    NDIS_STATUS                 Status;

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    if (pAdapter->NdisAfHandle != NULL)
    {
        // Our AF has already been opened and it doesn't make any sense to
        // accept another since there is no way to distinguish which should
        // receive incoming calls.
        DBG_ERROR(pAdapter, ("Attempting to open AF again!\n"));
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        pAdapter->NdisAfHandle = NdisAfHandle;

        DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                   ("TAPI AF=0x%X AddressFamily=0x%X MajorVersion=0x%X MinorVersion=0x%X\n",
                   NdisAfHandle,
                   AddressFamily->AddressFamily,
                   AddressFamily->MajorVersion,
                   AddressFamily->MinorVersion
                   ));

        // Since we return NDIS_STATUS_PENDING here, we must call
        // NdisMCmOpenAddressFamilyComplete to complete this request.
        // If necessary, you can do the completion asynchronously.
        *CallMgrAfContext = pAdapter;
        CompleteCmOpenAf(pAdapter, NDIS_STATUS_SUCCESS);
        Status = NDIS_STATUS_PENDING;
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmCloseAf


@func

    <f CompleteCmCloseAf> is called when the miniport is done processing the
    <f ProtocolCmCloseAf> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmCloseAf>, you must
    call <f CompleteCmCloseAf> so that <f NdisMCmCloseAddressFamilyComplete>
    can be called to complete the request.
*/

VOID CompleteCmCloseAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // The NDIS status code to be passed to NdisMCmCloseAddressFamilyComplete.
    )
{
    DBG_FUNC("CompleteCmCloseAf")

    NDIS_HANDLE                 NdisAfHandle;

    DBG_ENTER(pAdapter);

    NdisAfHandle = pAdapter->NdisAfHandle;
    pAdapter->NdisAfHandle = NULL;

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                ("TAPI AF=0x%X\n",
                NdisAfHandle));

    NdisMCmCloseAddressFamilyComplete(Status, NdisAfHandle);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmCloseAf


@func

    <f ProtocolCmCloseAf> is a required function that releases per-open
    resources for an address family that a call manager supports.

@comm

    ProtocolCmCloseAf releases and/or deactivates any resources that were
    allocated by the call manager in its ProtocolCmOpenAf function. The call
    manager also should undo any other actions it took on behalf of the
    connection-oriented client when the address family was opened by that
    client.

    If there are any outstanding requests or connections still open on an
    address family stored in the CallMgrAfContext, a call manager can respond to
    a client's request to close the address family in either of the following
    ways:

    The call manager can fail the request with NDIS_STATUS_NOT_ACCEPTED.

    The call manager can return NDIS_STATUS_PENDING. After the client has closed
    all calls and deregistered all SAPs, the call manager can then close the
    address family and call Ndis(M)CmCloseAddressFamilyComplete to notify the
    client. This is the preferred response.

    ProtocolCmCloseAf must be written so that it can run at IRQL DISPATCH_LEVEL.

@rdesc

    ProtocolCmCloseAf returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager has successfully released or deactivated any
    resources that is allocated on behalf of the connection-oriented client that
    opened this instance of the address family.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the request to close the open instance of the address family
    will be completed asynchronously. The call manager must call
    NdisCmCloseAddressFamilyComplete when all such operations have been
    completed.

@xref

    NdisCmCloseAddressFamilyComplete, <f ProtocolCmOpenAf>
*/

NDIS_STATUS ProtocolCmCloseAf(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f ProtocolCmOpenAf>.  AKA CallMgrAfContext.<nl>
    // Specifies the handle to the call manager's per-AF context area,
    // originally supplied to NDIS by the call manager's ProtocolCmOpenAf
    // function.
    )
{
    DBG_FUNC("ProtocolCmCloseAf")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    // Since we return NDIS_STATUS_PENDING here, we must call
    // NdisMCmCloseAddressFamilyComplete to complete this request.
    // TODO: If necessary, you can do the completion asynchronously.
    DChannelClose(pAdapter->pDChannel);
    CompleteCmCloseAf(pAdapter, NDIS_STATUS_SUCCESS);
    Result = NDIS_STATUS_PENDING;

    DBG_RETURN(pAdapter, Result);
    return (Result);
}

VOID CompleteCmRegisterSap(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // The NDIS status code to be passed to NdisMCmRegisterSapComplete.
    )
{
    DBG_FUNC("CompleteCmRegisterSap")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // TODO: What statistics do you want to collect and report?
    */
    pAdapter->TotalRxBytes            = 0;
    pAdapter->TotalTxBytes            = 0;
    pAdapter->TotalRxPackets          = 0;
    pAdapter->TotalTxPackets          = 0;

    // If you return NDIS_STATUS_PENDING from ProtocolCmRegisterSap, you
    // must call NdisMCmRegisterSapComplete to complete the request.
    NdisMCmRegisterSapComplete(Status, pBChannel->NdisSapHandle, pBChannel);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmRegisterSap


@func

    <f ProtocolCmRegisterSap> is a required function that is called by NDIS to
    request that a call manager register a SAP (service access point) on behalf
    of a connection-oriented client.

@comm

    ProtocolCmRegisterSap communicates with network control devices or other
    media-specific agents, as necessary, to register the SAP, as specified at
    Sap, on the network for a connection-oriented client. Such actions could
    include, but are not limited to communicating with switching hardware,
    communicating with a network control station, or other actions that are
    appropriate to the network medium.

    If a call manager is required to communicate with networking control agents
    (e.g. a network switch) it should use a virtual connection to the network
    control agent that it established in its ProtocolBindAdapter function.
    Standalone call managers communicate through the underlying NIC miniport by
    calling NdisCoSendPackets. NIC miniports with integrated call-management
    support never call NdisCoSendPackets. Instead, they transmit the data
    directly across the network.

    In addition, ProtocolCmRegisterSap should perform any necessary allocations
    of dynamic resources and structures that the call manager needs to maintain
    state information about the SAP on behalf of the connection-oriented client.
    Such resources include, but are not limited to, memory buffers, data
    structures, events, and other such similar resources. A call manager must
    also initialize any resources it allocates before returning control to NDIS.
    Call managers must store the NDIS-supplied handle identifying the SAP,
    provided at NdisSapHandle, in their context area for future use.

    If ProtocolCmRegisterSap will return NDIS_STATUS_SUCCESS, it should, after
    allocating the per-SAP state area, set the address of this state area in
    CallMgrSapContext before returning control to NDIS. To do this, dereference
    CallMgrSapContext and store a pointer to the data area as the value of the
    handle. For example:

    *CallMgrSapContext = SomeBuffer;    // We use <t BCHANNEL_OBJECT>.

    If the given SAP that is already registered by another connection-oriented
    client, the call manager must fail the request and return
    NDIS_STATUS_INVALID_DATA.

    After a call manager has registered a SAP on behalf of a connection-oriented
    client, it notifies that client of an incoming call offer directed to that
    SAP by calling NdisCmDispatchIncomingCall.

    ProtocolCmRegisterSap must be written so that it can run at IRQL DISPATCH_LEVEL.

@rdesc

    ProtocolCmRegisterSap returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully allocated and/or initialized
    any necessary resources to register and maintain the SAP. In addition, it
    also indicates that the SAP was registered successfully as required by the
    network media that the call manager supports.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the processing of this request
    asynchronously. Call managers must call NdisCmRegisterSapComplete when all
    processing has been completed to signal NDIS that the registration is
    finished.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager was unable to allocated and/or initialize
    its resources required to register the SAP on behalf of the
    connection-oriented client.

@rvalue NDIS_STATUS_INVALID_DATA |

    Indicates that the specification provided at Sap is invalid or cannot be
    supported.

@rvalue NDIS_STATUS_XXX |

    Indicates that the call manager encountered an error in attempting to
    register the SAP for the connection-oriented client. The return code is
    appropriate to the error and could be a return code propagated from another
    NDIS library function.

@xref

    NdisCmDispatchIncomingCall, NdisCmRegisterSapComplete, NdisCoSendPackets,
    <f ProtocolCmDeregisterSap>, <f ProtocolCmOpenAf>
*/

NDIS_STATUS ProtocolCmRegisterSap(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f ProtocolCmOpenAf>.  AKA CallMgrAfContext.<nl>
    // Specifies the handle to a call-manager allocated context area in which
    // the call manager maintains its per-open AF state. The call manager
    // supplied this handle to NDIS from its ProtocolCmOpenAf function.

    IN PCO_SAP                  Sap,                        // @parm
    // Points to a media-specific CO_SAP structure that contains the specific
    // SAP that a connection-oriented client is registering.

    IN NDIS_HANDLE              NdisSapHandle,              // @parm
    // Specifies a handle, supplied by NDIS, that uniquely identifies this SAP.
    // This handle is opaque to the call manager and reserved for NDIS library
    // use.

    OUT PNDIS_HANDLE            CallMgrSapContext           // @parm
    // On return, specifies the handle to a call manager-supplied context area
    // in which the call manager maintains state about this SAP.  We will
    // return a pointer to the <t BCHANNEL_OBJECT> instance identified by this
    // SAP's lineID.
    )
{
    DBG_FUNC("ProtocolCmRegisterSap")

    PCO_AF_TAPI_SAP             pTapiSap = (PCO_AF_TAPI_SAP) Sap->Sap;

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    if (pTapiSap->ulLineID < pAdapter->NumBChannels)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, pTapiSap->ulLineID);

        NdisAcquireSpinLock(&pAdapter->EventLock);
                                                      
        if (pBChannel->NdisSapHandle != NULL)
        {
            NdisReleaseSpinLock(&pAdapter->EventLock);
        
            // A SAP has already been registered and it doesn't make any sense to
            // accept another since there are no SAP parameters to distinguish
            // them.
            DBG_ERROR(pAdapter, ("#%d Attempting to register SAP again!\n",
                      pBChannel->ObjectID));
            Result = NDIS_STATUS_SAP_IN_USE;
        }
        else
        {
            pBChannel->NdisSapHandle = NdisSapHandle;
            pBChannel->SapRefCount = 1;

            ASSERT(Sap->SapType == AF_TAPI_SAP_TYPE);
            ASSERT(Sap->SapLength == sizeof(CO_AF_TAPI_SAP));
            pBChannel->NdisTapiSap = *pTapiSap;

            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                       ("#%d SAP=0x%X ulLineID=0x%X ulAddressID=0x%X ulMediaModes=0x%X\n",
                       pBChannel->ObjectID,
                       NdisSapHandle,
                       pBChannel->NdisTapiSap.ulLineID,
                       pBChannel->NdisTapiSap.ulAddressID,
                       pBChannel->NdisTapiSap.ulMediaModes
                       ));

            // If this BChannel is currently on the available list, move it
            // to the end of the list, so listening BChannels can be easily
            // allocated to incoming calls from the end of the list.
            if (!IsListEmpty(&pBChannel->LinkList))
            {
                RemoveEntryList(&pBChannel->LinkList);
                InsertTailList(&pAdapter->BChannelAvailableList,
                               &pBChannel->LinkList);
            }
            
            NdisReleaseSpinLock(&pAdapter->EventLock);

            // Since we return NDIS_STATUS_PENDING here, we must call
            // NdisMCmRegisterSapComplete to complete this request.
            // TODO: If necessary, you can do the completion asynchronously.
            *CallMgrSapContext = pBChannel;
            CompleteCmRegisterSap(pBChannel, NDIS_STATUS_SUCCESS);
            Result = NDIS_STATUS_PENDING;
        }
    }
    else
    {
        DBG_ERROR(pAdapter, ("Attempting to register invalid SAP=%d\n",
                  pTapiSap->ulLineID));
        Result = NDIS_STATUS_INVALID_DATA;
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmDeregisterSap


@func

    <f CompleteCmDeregisterSap> is called when the miniport is done processing
    the <f ProtocolCmDeregisterSap> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmDeregisterSap>, you
    must call <f CompleteCmDeregisterSap> so that
    <f NdisMCmDeregisterSapComplete> can be called to complete the request.
*/

VOID CompleteCmDeregisterSap(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // The NDIS status code to be passed to NdisMCmRegisterSapComplete.
    )
{
    DBG_FUNC("CompleteCmDeregisterSap")

    NDIS_HANDLE                 NdisSapHandle;

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    NdisSapHandle = pBChannel->NdisSapHandle;
    
    NdisAcquireSpinLock(&pAdapter->EventLock);
    pBChannel->NdisSapHandle = NULL;
    NdisReleaseSpinLock(&pAdapter->EventLock);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
               ("#%d SAP=0x%X\n",
               pBChannel->ObjectID,
               NdisSapHandle
               ));

    NdisMCmDeregisterSapComplete(Status, NdisSapHandle);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmDeregisterSap


@func

    <f ProtocolCmDeregisterSap> is a required function that is called by NDIS
    to request that a call manager deregister a SAP on behalf of a
    connection-oriented client.

@comm

    ProtocolCmDeregisterSap communicates with network control devices or other
    media-specific agents, as necessary, to deregister the SAP on the network.
    Such actions could include, but are not limited to:

    Communicating with a switching hardware
    Communicating with a network control station
    Communicating with other media-specific network agents

    If a call manager is required to communicate with networking control agents,
    such as a network switch, it should use a virtual connection to the network
    control agent that it established in its ProtocolBindAdapter function.
    Standalone call managers communicate through the underlying NIC miniport by
    calling NdisCoSendPackets. NIC miniports that provide integrated
    call-management support never call NdisCoSendPackets. Instead, they transmit
    the data directly across the network.

    In addition, ProtocolCmDeregisterSap must free any dynamically-allocated
    resources in its per-SAP area, provided at CallMgrSapContext, as well as
    freeing the state area itself before returning control to NDIS.

    ProtocolCmDeregisterSap must be written such that it can be run at IRQL
    DISPATCH_LEVEL.

@rdesc

    ProtocolCmDeregisterSap returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully removed the SAP registration
    and freed any resources allocated to maintain per-SAP information.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the request to deregister the
    SAP asynchronously. The call manager must call NdisCmDeregisterSapComplete
    to signal NDIS when the operation is complete.

@xref

    NdisCmDeregisterSapComplete, NdisCoSendPackets, ProtocolBindAdapter,
    <f ProtocolCmRegisterSap>
*/

NDIS_STATUS ProtocolCmDeregisterSap(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmRegisterSap>.  AKA CallMgrSapContext.<nl>
    // Specifies the handle to a call-manager allocated context area in which
    // the call manager maintains its per-SAP state information. The call
    // manager supplied this handle to NDIS from its ProtocolCmRegisterSap
    // function.
    )
{
    DBG_FUNC("ProtocolCmDeregisterSap")

    NDIS_STATUS                 Result = NDIS_STATUS_PENDING;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DereferenceSap(pAdapter, pBChannel);

    // If you return NDIS_STATUS_PENDING here, you must call
    // NdisMCmDeregisterSapComplete to complete this request.
    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL BChannel BChannel_c ProtocolCoCreateVc


@func

    <f ProtocolCoCreateVc> is a required function for connection-oriented
    miniports.  <f ProtocolCoCreateVc> is called by NDIS to indicate to
    the miniport that a new VC is being created.

@comm

    ProtocolCoCreateVc must be written as a synchronous function and cannot,
    under any circumstances, return NDIS_STATUS_PENDING without causing a
    system-wide failure.

    ProtocolCoCreateVc allocates any necessary resources that the miniport
    requires to maintain state information about the VC. The resources could
    include, but are not limited to memory buffers, events, data structures,
    and other such similar resources.

    After allocating all required resources the miniport should initialize the
    resources into a usable state and return a pointer to the state area in
    MiniportVcContext. The handle is set by dereferencing the handle and
    storing a pointer to the state buffer as the value of the handle. For
    example:

    *MiniportVcContext = SomeBuffer;    // We use <t BCHANNEL_OBJECT>.

    Miniport drivers must store the handle to the VC, NdisVcHandle, in their
    state area as it is a required parameter to other NDIS library routines
    that are subsequently called by the miniport.

    ProtocolCoCreateVc must be written such that it can be run at IRQL
    DISPATCH_LEVEL.

@rdesc

    Call managers or clients cannot return NDIS_STATUS_PENDING from their
    ProtocolCoCreateVc functions. Returning pending will render this virtual
    connection unusable and the NDIS library will call the client or call
    manager to delete it.

    ProtocolCoCreateVc returns the status of its operation(s) as one of the
    following values:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager or client successfully allocated and/or
    initialized any necessary resources that were needed to establish and
    maintain a virtual connection.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager or client was unable to allocate and/or
    initialize its resources for establishing and maintaining a virtual
    connection.

@rvalue NDIS_STATUS_XXX |

    Indicates that the call manager or client could not set itself into a state
    where it could establish a virtual connection. This can could be an error
    return value propagated from another NDIS library routine.

@xref

    <f MiniportInitialize>, NdisMSetAttributes, NdisMSetAttributesEx,
    <f ProtocolCoDeleteVc>, <f MiniportCoActivateVc>, <f MiniportCoDeactivateVc>
*/

NDIS_STATUS ProtocolCoCreateVc(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.  AKA ProtocolAfContext.<nl>

    IN NDIS_HANDLE              NdisVcHandle,               // @parm
    // Specifies a handle, supplied by NDIS, that uniquely identifies
    // the VC being created.  This handle is opaque to the miniport
    // and reserved for NDIS library use.

    OUT PBCHANNEL_OBJECT *      ppBChannel                  // @parm
    // Specifies, on output, a handle to a miniport-supplied context
    // area in which the miniport maintains state about the VC.
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("ProtocolCoCreateVc")

    NDIS_STATUS                 Result = NDIS_STATUS_VC_NOT_AVAILABLE;
    // Holds the result code returned by this function.

    PBCHANNEL_OBJECT            pBChannel = NULL;
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(ppBChannel);

    DBG_ENTER(pAdapter);

    // Allocate BChannel for VC based on whether it's incoming or outgoing.
#if defined(SAMPLE_DRIVER)
    if (NdisVcHandle == NULL)
    {
        // The calling side has already removed the BChannel from the available
        // list, so we just need to use it.
        ASSERT(ppBChannel && *ppBChannel && (*ppBChannel)->ObjectType == BCHANNEL_OBJECT_TYPE);
        pBChannel = *ppBChannel;
    }
    else
    {
#endif // SAMPLE_DRIVER

    NdisAcquireSpinLock(&pAdapter->EventLock);
    if (!IsListEmpty(&pAdapter->BChannelAvailableList))
    {
        if (NdisVcHandle)
        {
            // Pull from the head of the available list, so we can avoid
            // using the BChannels that are setup with listening SAPs at
            // the end of the list.
            pBChannel = (PBCHANNEL_OBJECT) RemoveHeadList(
                                            &pAdapter->BChannelAvailableList);
            // Reset the link info so we can tell that it's not on the list.
            InitializeListHead(&pBChannel->LinkList);
        }
        else
        {
            // Pull from the tail of the available list, to see if there
            // are any listening SAPs that can accept this call.
            pBChannel = (PBCHANNEL_OBJECT) RemoveTailList(
                                            &pAdapter->BChannelAvailableList);
            // Reset the link info so we can tell that it's not on the list.
            InitializeListHead(&pBChannel->LinkList);
            if (pBChannel->NdisSapHandle)
            {
                // TODO: You should look to make sure the incoming call matches
                // the SAP of the listener.  The sample driver just assumes it.
            }
            else
            {
                // Sorry, no one up there wants to hear about it.
                InsertTailList(&pAdapter->BChannelAvailableList,
                               &pBChannel->LinkList);
                pBChannel = NULL;
            }
        }
    }
    NdisReleaseSpinLock(&pAdapter->EventLock);

#if defined(SAMPLE_DRIVER)
    }
#endif // SAMPLE_DRIVER

    if (pBChannel == NULL)
    {
        DBG_ERROR(pAdapter, ("BChannelAvailableList is empty\n"));
    }
    else if (BChannelOpen(pBChannel, NdisVcHandle) == NDIS_STATUS_SUCCESS)
    {
        Result = NDIS_STATUS_SUCCESS;
        DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                  ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
                   pBChannel->ObjectID,
                   pBChannel->NdisVcHandle, pBChannel->CallState,
                   Result
                  ));
    }
    else
    {
        // BChannel was already open - this should never happen...
        DBG_ERROR(pAdapter,("BChannelOpen failed, but it should be availble\n"));
        NdisAcquireSpinLock(&pAdapter->EventLock);
        if (NdisVcHandle)
        {
            // Put it back on the head of the available list.
            InsertHeadList(&pAdapter->BChannelAvailableList,
                           &pBChannel->LinkList);
        }
        else
        {
            // Put it back on the tail of the available list.
            InsertTailList(&pAdapter->BChannelAvailableList,
                           &pBChannel->LinkList);
        }
        NdisReleaseSpinLock(&pAdapter->EventLock);
        pBChannel = NULL;
    }
    *ppBChannel = pBChannel;

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL BChannel BChannel_c ProtocolCoDeleteVc


@func

    <f ProtocolCoDeleteVc> is a required function for connection-oriented
    miniports.  <f ProtocolCoDeleteVc> indicates that a VC is being torn
    down and deleted by NDIS.

@comm

    ProtocolCoDeleteVc must be written as a synchronous function and cannot,
    under any circumstances, return NDIS_STATUS_PENDING without causing a
    system-wide failure.

    ProtocolCoDeleteVc frees any resources allocated on a per-VC basis and
    stored in the context area MiniportVcContext. The miniport must also free
    the MiniportVcContext that is allocated in its ProtocolCoCreateVc
    function.

    <f ProtocolCoDeleteVc> must be written such that it can be run from IRQL
    DISPATCH_LEVEL.

@rdesc

    ProtocolCoDeleteVc can return one of the following:

@rvalue NDIS_STATUS_SUCCESS |

    The protocol has released or prepared for reuse all the resources that it
    originally allocated for the VC.

@rvalue NDIS_STATUS_NOT_ACCEPTED |

    The VC is still active and the protocol has outstanding operations pending
    on the VC so it could not be destroyed.

@rvalue NDIS_STATUS_XXX |

    The protocol failed the VC deletion for a driver-determined reason.

@xref

    NdisClCloseCall, NdisCmDispatchIncomingCloseCall, NdisCoCreateVc,
    NdisCoDeleteVc, <f ProtocolCoCreateVc>, <f MiniportCoActivateVc>,
    <f MiniportCoDeactivateVc>
*/

NDIS_STATUS ProtocolCoDeleteVc(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.  AKA ProtocolVcContext.<nl>
    // Specifies the handle to the client's or call manager's per-VC context
    // area. The protocol originally supplied this handle from its
    // <f ProtocolCoCreateVc> function.
    )
{
    DBG_FUNC("ProtocolCoDeleteVc")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState,
               Result
              ));

    BChannelClose(pBChannel);
    NdisAcquireSpinLock(&pAdapter->EventLock);
    if (pBChannel->NdisSapHandle)
    {
        // Listening BChannels are kept at the end of the list.
        InsertTailList(&pAdapter->BChannelAvailableList, &pBChannel->LinkList);
    }
    else
    {
        // Non-listening BChannels are kept at the end of the list.
        InsertHeadList(&pAdapter->BChannelAvailableList, &pBChannel->LinkList);
    }
    NdisReleaseSpinLock(&pAdapter->EventLock);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL Link Link_c MiniportCoActivateVc


@func

    <f MiniportCoActivateVc> is a required function for connection-oriented
    miniports.  <f MiniportCoActivateVc> is called by NDIS to indicate to the
    miniport that a virtual connection is being activated.

@comm

    The miniport driver must validate the call parameters for this VC, as
    specified in CallParameters, to verify that the adapter can support the
    requested call. If the requested call parameters cannot be satisfied, the
    miniport should fail the request with NDIS_STATUS_INVALID_DATA.

    MiniportCoActivateVc can be called many times for a single VC in order to
    change the call parameters for an already active call. At every call, the
    miniport should validate the parameters and perform any processing as
    required by its adapter in order to satisfy the request. However, if it
    cannot set the given call parameters, MiniportCoActivateVc must leave the
    VC in a usable state, because the connection-oriented client or a call
    manager can continue to send or receive data using the older call
    parameters.

    If the ROUND_UP_FLOW or ROUND_DOWN_FLOW flags are set in the call
    parameters structure at CallParameters-\>MediaParameters-\>Flags, the
    miniport has been requested to return the actual flow rate of the VC after
    the flow rate has been rounded according to the appropriate flag that has
    been set. If the miniport does change any of the call parameters because
    these flags have been set, it must return the actual call parameters in
    use for the VC at CallParameters.

    If the call parameters are acceptable, MiniportCoActivateVc communicates
    with its adapter as necessary to prepare the adapter to receive or
    transmit data across the virtual connection (e.g. programming receive
    buffers).

    MiniportCoActivateVc must be written so that it can be run from IRQL
    DISPATCH_LEVEL.

@rdesc

    MiniportCoActivateVc can return one of the following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the VC was activated successfully.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the miniport will complete the request to activate a VC
    asynchronously. When the miniport has finished with its operations, it must
    call NdisMCoActivateVcComplete.

@rvalue NDIS_STATUS_INVALID_DATA |

    Indicates that the call parameters specified at CallParameters are invalid
    or illegal for the media type that this miniport supports.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the miniport could not activate the VC because it could not
    allocate all of the required resources that the miniport needs to maintain
    state information about the active VC.

@xref

    <f ProtocolCoCreateVc>, <f MiniportCoDeactivateVc>, NdisMCoActivateVcComplete
*/

NDIS_STATUS MiniportCoActivateVc(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.  AKA MiniportVcContext.<nl>
    // Specifies the handle to a miniport-allocated context area in which the
    // miniport maintains its per-VC state. The miniport supplied this handle
    // to NDIS from its <f ProtocolCoCreateVc> function.

    IN OUT PCO_CALL_PARAMETERS  pCallParameters             // @parm
    // A pointer to the <t CO_CALL_PARAMETERS>
    // Specifies the call parameters, as specified by the call manager, to be
    // established for this VC. On output, the miniport returns altered call
    // parameters if certain flags are set in the CO_CALL_PARAMETERS structure.
    )
{
    DBG_FUNC("MiniportCoActivateVc")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO: Add code here if needed

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL Link Link_c MiniportCoDeactivateVc


@func

    <f MiniportCoDeactivateVc> is a required function for connection-oriented
    miniports.  <f MiniportCoDeactivateVc> is called by NDIS to indicate that
    a VC is being marked as unusable.

@comm

    MiniportCoDeactivateVc communicates with its network adapter to terminate
    all communication across this VC (e.g. deprogramming receive or send buffers
    on the adapter). The miniport should also mark the VC, it its context area,
    as being inactive to prevent any further communication across the VC.

    There is not a one-to-one relationship between calls to MiniportCoActivateVc
    and MiniportCoDeactivateVc. While NDIS may call MiniportCoActivateVc
    multiple times on a single VC, only one call to MiniportCoDeactivateVc is
    made to shut down a virtual connection. For example, a VC can be reused for
    different calls possibly causing multiple calls to MiniportCoActivateVc.

@rdesc

    MiniportCoDeactivateVc can return one of the following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the miniport successfully halted any communication across the
    VC and marked it as unusable.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the miniport will complete the request to halt the VC
    asynchronously. When the miniport has completed halting the VC, it must then
    call NdisMCoDeactivateVcComplete to signal NDIS that this operation has been
    completed.

@xref

    <f MiniportCoActivateVc>, NdisMCoDeactivateVcComplete
*/

NDIS_STATUS MiniportCoDeactivateVc(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.  AKA MiniportVcContext.<nl>
    // Specified the handle to a miniport-allocated context area in which the
    // miniport maintains state information per-VC. The miniport supplied this
    // handle to NDIS from its <f ProtocolCoCreateVc> function.

    )
{
    DBG_FUNC("MiniportCoDeactivateVc")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO: Add code here if needed

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmMakeCall


@func

    <f CompleteCmMakeCall> is called when the miniport is done processing the
    <f ProtocolCmMakeCall> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmMakeCall>, you must
    call <f CompleteCmMakeCall> so that <f NdisMCmMakeCallComplete>
    can be called to complete the request.

    This routine also activates the VC and marks the call state as connected.
*/

VOID CompleteCmMakeCall(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_STATUS              Status                      // @parm
    // Status to return to <f NdisMCmMakeCallComplete>.  If status does not
    // equal NDIS_STATUS_SUCCESS, the call is closed and the BChannel is
    // released.
    )
{
    DBG_FUNC("CompleteCmMakeCall")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState,
               Status
              ));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        pBChannel->pOutCallParms->CallMgrParameters->Receive.PeakBandwidth =
        pBChannel->pOutCallParms->CallMgrParameters->Transmit.PeakBandwidth =
                                                    pBChannel->LinkSpeed/8;

        Status = NdisMCmActivateVc(pBChannel->NdisVcHandle,
                                   pBChannel->pOutCallParms);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            pBChannel->Flags |= VCF_VC_ACTIVE;
            pBChannel->CallState = LINECALLSTATE_CONNECTED;
        }
        else
        {
            DBG_ERROR(pAdapter,("NdisMCmActivateVc Error=0x%X\n",Status));
        }
    }
    NdisMCmMakeCallComplete(Status, pBChannel->NdisVcHandle,
                            NULL, NULL,
                            pBChannel->pOutCallParms);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        // The call failed, so cleanup and bail out.
        pBChannel->Flags &= ~VCF_OUTGOING_CALL;
    }

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmMakeCall


@func

    <f ProtocolCmMakeCall> is a required function that sets up media specific
    parameters for a virtual connection (VC) and activates the virtual
    connection.

@comm

    If ProtocolCmMakeCall is given an explicit NdisPartyHandle, this VC was
    created by the client for a multipoint call. The call manager must allocate
    and initialize any necessary resources required to maintain state
    information and control a multipoint call. Such resources include, but are
    not limited to, memory buffers, data structures, events, and other similar
    resources. If the call manager cannot allocate or initialize the needed
    resources for its state area(s), it should return control to NDIS with
    NDIS_STATUS_RESOURCES.

    ProtocolCmMakeCall communicates with network control devices or other
    media-specific actors, as necessary, to make a connection between the local
    node and a remote node based on the call parameters specified at
    CallParameters. Such actions could include, but are not limited to,
    communication with switching hardware, communications with a network control
    station, or other actions as appropriate to the network medium.

    If a call manager is required to communication with networking hardware
    (e.g. a networking switch) it should use a virtual connection to the network
    control device that it established in its ProtocolBindAdapter function. Call
    managers communicate with their network hardware through the miniport driver
    by calling NdisCoSendPackets. NIC miniports with integrated call-management
    support will not call NdisCoSendPackets, but rather will transmit the data
    themselves.

    After a call manager has done all necessary communication with its
    networking hardware as required by its medium, call managers must call
    NdisCmActivateVc.

    If this call was a multipoint call, after the call manager has communicated
    with the networking hardware, verified call parameters, and allocated and
    initialized its per-party state data, the address of its state block should
    be set in the handle CallMgrPartyContext before returning control to NDIS.
    The handle is set by dereferencing the handle and storing a pointer to the
    state block as the value of the handle. For example:

    *CallMgrPartyContext = SomeBuffer;  // We use NULL

    If ProtocolCmMakeCall has completed the required operations for its network
    and the VC has been successfully activated through NdisCmActivateVc,
    ProtocolCmMakeCall should return control as quickly as possible with a
    status of NDIS_STATUS_SUCCESS.

    After ProtocolCmMakeCall returns control to NDIS, the call manager should
    expect to take no further actions on this call to set it up.
    ProtocolCmMakeCall is responsible for establishing the connection so that
    the client can make data transfers over the network on this VC. However, the
    call manager can be called subsequently to modify the call's quality of
    service, to add or drop parties if this is a multipoint VC, and eventually
    to terminate this call.

    ProtocolCmMakeCall must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@rdesc

    <f ProtocolCmMakeCall> returns the status of its operation(s) as one of
    the following values:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully allocated the necessary
    resources to make the call and was able to activate the virtual connection
    with the miniport driver.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the request to make a call
    asynchronously. When the call manager has completed all operations for
    making a call, it must call NdisCmMakeCallComplete to signal NDIS that this
    call has been completed.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager was unable to allocate and/or initialize its
    resources for activating the virtual connection as requested by the client.

@rvalue NDIS_STATUS_NOT_SUPPORTED |

    Indicates that the call manager was unable to activate a virtual connection
    because the caller requested invalid or unavailable features in the call
    parameters specified at CallParameters.

@xref

    NdisClMakeCall, NdisCmActivateVc, NdisCmMakeCallComplete,
    <f ProtocolCoCreateVc>
*/

NDIS_STATUS ProtocolCmMakeCall(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call managers maintains its per-VC state. The call manager supplied
    // this handle to NDIS from its ProtocolCoCreateVc function.

    IN OUT PCO_CALL_PARAMETERS  pCallParameters,            // @parm
    // Points to a CO_CALL_PARAMETERS structure that contains the parameters,
    // specified by a connection-oriented client, for this outgoing call.

    IN NDIS_HANDLE              NdisPartyHandle,            // @parm
    // Specifies a handle, supplied by NDIS, that uniquely identifies the
    // initial party on the multipoint virtual connection. This handle is
    // opaque to the call manager and reserved for NDIS library use. This
    // handle is NULL if the client is not setting up an outgoing multipoint
    // call.

    OUT PNDIS_HANDLE            CallMgrPartyContext         // @parm
    // On return, specifies a handle to a call manager-supplied context area in
    // which the call manager maintains state about the initial party on the
    // multipoint call. If NdisPartyHandle is NULL, this handle must be set to
    // NULL.
    )
{
    DBG_FUNC("ProtocolCmMakeCall")

    PCO_AF_TAPI_MAKE_CALL_PARAMETERS    pTapiCallParameters;
    // Points to the TAPI call parameters contained in pCallParameters.

    PLINE_CALL_PARAMS           pLineCallParams;
    // Points to the LINE call parameters contained in pTapiCallParameters.

    USHORT                      DialStringLength;
    // Length of the dial string in bytes.

    PUSHORT                     pDialString;
    // Points to the dial string contained in pTapiCallParameters.

    UCHAR                       DialString[CARD_MAX_DIAL_DIGITS+1];
    // Temporary copy of dial string.  One extra for NULL terminator.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    // Check a few preconditions ;)  Maybe the NDPROXY will change the rules
    // someday, and we'll have to change our assumptions...
    ASSERT(NdisPartyHandle == NULL);
    ASSERT(pCallParameters->Flags == 0);
    ASSERT(pCallParameters->CallMgrParameters);
    ASSERT(pCallParameters->CallMgrParameters->Transmit.TokenRate ==
           pBChannel->LinkSpeed/8);
    ASSERT(pCallParameters->CallMgrParameters->Receive.TokenRate ==
           pBChannel->LinkSpeed/8);
    ASSERT(pCallParameters->CallMgrParameters->CallMgrSpecific.ParamType == 0);
    ASSERT(pCallParameters->CallMgrParameters->CallMgrSpecific.Length == 0);
    ASSERT(pCallParameters->MediaParameters);
    ASSERT(pCallParameters->MediaParameters->Flags & TRANSMIT_VC);
    ASSERT(pCallParameters->MediaParameters->Flags & RECEIVE_VC);
    ASSERT(pCallParameters->MediaParameters->ReceiveSizeHint >=
           pAdapter->pCard->BufferSize);
    ASSERT(pCallParameters->MediaParameters->MediaSpecific.ParamType == 0);
    ASSERT(pCallParameters->MediaParameters->MediaSpecific.Length >=
           sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS));
    pTapiCallParameters = (PCO_AF_TAPI_MAKE_CALL_PARAMETERS)
                    pCallParameters->MediaParameters->MediaSpecific.Parameters;
    ASSERT(pTapiCallParameters->ulLineID < pAdapter->NumBChannels);
    ASSERT(pTapiCallParameters->ulAddressID == TSPI_ADDRESS_ID);
    ASSERT(pTapiCallParameters->ulFlags & CO_TAPI_FLAG_OUTGOING_CALL);
    ASSERT(pTapiCallParameters->DestAddress.Length > sizeof(USHORT));
    ASSERT(pTapiCallParameters->DestAddress.MaximumLength >=
           pTapiCallParameters->DestAddress.Length);
    ASSERT(pTapiCallParameters->DestAddress.Offset >=
           sizeof(NDIS_VAR_DATA_DESC));
    DialStringLength = pTapiCallParameters->DestAddress.Length;
    pDialString = (PUSHORT)
                        ((PUCHAR)&pTapiCallParameters->DestAddress +
                                  pTapiCallParameters->DestAddress.Offset);
    ASSERT(pTapiCallParameters->LineCallParams.Length >= sizeof(LINE_CALL_PARAMS));
    ASSERT(pTapiCallParameters->LineCallParams.MaximumLength >=
           pTapiCallParameters->LineCallParams.Length);
    ASSERT(pTapiCallParameters->LineCallParams.Offset >=
           sizeof(NDIS_VAR_DATA_DESC));

    pLineCallParams = (PLINE_CALL_PARAMS)
                        ((PUCHAR)&pTapiCallParameters->LineCallParams +
                                  pTapiCallParameters->LineCallParams.Offset);

    // This was useful for debugging the nested call parameter structures.
    DBG_NOTICE(pAdapter,(
                "\t\tsizeof(CO_CALL_PARAMETERS)                 =%03d\n"
                "\t\tsizeof(CO_CALL_MANAGER_PARAMETERS)         =%03d\n"
                "\t\tsizeof(CO_MEDIA_PARAMETERS)                =%03d\n"
                "\t\tsizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS)    =%03d\n"
                "\t\tsizeof(LINE_CALL_PARAMS)                   =%03d\n",
                "\t\tMaximumLength                              =%03d\n",
                sizeof(CO_CALL_PARAMETERS),
                sizeof(CO_CALL_MANAGER_PARAMETERS),
                sizeof(CO_MEDIA_PARAMETERS),
                sizeof(CO_AF_TAPI_MAKE_CALL_PARAMETERS),
                sizeof(LINE_CALL_PARAMS),
                pTapiCallParameters->LineCallParams.MaximumLength
                ));

    /*
    // TODO: The sample driver doesn't support multi-party calls.
    */
    *CallMgrPartyContext = NULL;

    /*
    // Make sure the call parameters are valid for us.
    */
    if (pLineCallParams->ulBearerMode & ~pBChannel->BearerModesCaps)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALBEARERMODE=0x%X\n",
                    pLineCallParams->ulBearerMode));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else if (pLineCallParams->ulMediaMode & ~pBChannel->MediaModesCaps)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALMEDIAMODE=0x%X\n",
                    pLineCallParams->ulMediaMode));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else if (pLineCallParams->ulMinRate > _64KBPS ||
        pLineCallParams->ulMinRate > pLineCallParams->ulMaxRate)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALRATE=%d:%d\n",
                    pLineCallParams->ulMinRate,pLineCallParams->ulMaxRate));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else if (pLineCallParams->ulMaxRate && pLineCallParams->ulMaxRate < _56KBPS)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALRATE=%d:%d\n",
                    pLineCallParams->ulMinRate,pLineCallParams->ulMaxRate));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else if (DialStringLength == 0)
    {
        DBG_WARNING(pAdapter, ("TAPI_INVALPARAM=No dial string\n"));
        Result = NDIS_STATUS_NOT_SUPPORTED;
    }
    else
    {
        /*
        // Dial the number, but don't include the null terminator.
        */
        DialStringLength = CardCleanPhoneNumber(DialString,
                                                pDialString,
                                                DialStringLength);

        if (DialStringLength > 0)
        {
            /*
            // Save the call parameters.
            */
            pBChannel->MediaMode  = pLineCallParams->ulMediaMode;
            pBChannel->BearerMode = pLineCallParams->ulBearerMode;
            pBChannel->LinkSpeed  = pLineCallParams->ulMaxRate == 0 ?
                                    _64KBPS : pLineCallParams->ulMaxRate;
            pBChannel->pOutCallParms  = pCallParameters;

            DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                        ("#%d VC=0x%X CallState=0x%X DIALING: '%s'\n"
                         "\tLineID=%d - AddressID=%d - "
                         "Rate=%d-%d - MediaMode=0x%X - BearerMode=0x%X\n",
                        pBChannel->ObjectID,
                        pBChannel->NdisVcHandle, pBChannel->CallState,
                        DialString,
                        pTapiCallParameters->ulLineID,
                        pTapiCallParameters->ulAddressID,
                        pLineCallParams->ulMinRate,
                        pLineCallParams->ulMaxRate,
                        pLineCallParams->ulMediaMode,
                        pLineCallParams->ulBearerMode
                        ));

            // Now we're ready to tell the network about the call.
            Result = DChannelMakeCall(pAdapter->pDChannel,
                                      pBChannel,
                                      DialString,
                                      DialStringLength,
                                      pLineCallParams);

            if (Result != NDIS_STATUS_PENDING)
            {
                CompleteCmMakeCall(pBChannel, Result);
                Result = NDIS_STATUS_PENDING;
            }
        }
        else
        {
            DBG_WARNING(pAdapter, ("TAPI_INVALPARAM=Invalid dial string=%s\n",
                        pDialString));
            Result = NDIS_STATUS_NOT_SUPPORTED;
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL CallMgr CallMgr_c CompleteCmCloseCall


@func

    <f CompleteCmCloseCall> is called when the miniport is done processing the
    <f ProtocolCmCloseCall> request.

@comm

    If you return NDIS_STATUS_PENDING from <f ProtocolCmCloseCall>, you must
    call <f CompleteCmCloseCall> so that <f NdisMCmCloseCallComplete>
    can be called to complete the request.

    Upon return from this routine, you can no longer access the BChannel/VC
    as it has been deactivated and returned to the available pool.
*/

VOID CompleteCmCloseCall(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.

    IN NDIS_STATUS              Status                      // @parm
    // Status to return to <f NdisMCmCloseCallComplete>.  Regardless of the
    // status, the VC is deactivated and deleted.
    )
{
    DBG_FUNC("CompleteCmCloseCall")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    // Deactivate the VC if needed.
    if (pBChannel->Flags & VCF_VC_ACTIVE)
    {
        pBChannel->Flags &= ~VCF_VC_ACTIVE;
        NdisMCmDeactivateVc(pBChannel->NdisVcHandle);
    }

    // Tell NDPROXY we're done.
    NdisMCmCloseCallComplete(Status, pBChannel->NdisVcHandle, NULL);

    // If it was an incoming call, it's up to us to delete the VC.
    if (pBChannel->Flags & VCF_INCOMING_CALL)
    {
        pBChannel->Flags &= ~VCF_INCOMING_CALL;
        if (pBChannel->NdisVcHandle)
        {
            NdisMCmDeleteVc(pBChannel->NdisVcHandle);
            pBChannel->NdisVcHandle = NULL;
            ProtocolCoDeleteVc((NDIS_HANDLE) pBChannel);
        }
    }
    else if (pBChannel->Flags & VCF_OUTGOING_CALL)
    {
        pBChannel->Flags &= ~VCF_OUTGOING_CALL;
    }

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmCloseCall


@func

    <f ProtocolCmCloseCall> is a required function that terminates an existing
    call and releases any resources that the call manager allocated for the
    call.

@comm

    ProtocolCmCloseCall communicated with network control devices or other
    media-specific actors, as necessitated by its media, to terminate a
    connection between the local node and a remote node. If the call manager is
    required to communicate with network control devices (e.g. a networking
    switch) it should use a virtual connection to the network control device
    that it established in its ProtocolBindAdapter function. Standalone call
    managers communicate to such network devices by calling NdisCoSendPackets.
    NIC miniports with integrated call-management support never call
    NdisCoSendPackets. Instead, they transmit the data directly across the
    network.

    If CloseData is nonNULL and sending data at connection termination is
    supported by the media that this call manager handles, the call manager
    should transmit the data specified at CloseData to the remote node before
    completing the call termination. If sending data concurrent with a
    connection being terminated is not supported, call managers should return
    NDIS_STATUS_INVALID_DATA.

    If ProtocolCmCloseCall is passed an explicit CallMgrPartyContext, then the
    call being terminated is a multipoint VC, and the call manager must perform
    any necessary network communication with its networking hardware, as
    appropriate to its media type, to terminate the call as a multipoint call.
    The call manager must also free the memory that it allocated earlier, in
    ProtocolCmMakeCall, for its per-party state that is pointed to by
    CallMgrPartyContext. Failure to properly release, de-allocate, or otherwise
    deactivate those resources causes a memory leak.

    After the call has been terminated with the network, any close data has been
    sent, and any resources at CallMgrPartyContext have been freed, the call
    manager must call NdisCmDeactivateVc. This notifies NDIS and the underlying
    NIC miniport, if any, to expect no further transfers on the given VC.

    ProtocolCmCloseCall must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@rdesc

    ProtocolCmCloseCall returns the status of its operation(s) as one of the
    following:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully terminated the call.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the request to terminate the
    call asynchronously. When the call manager has completed all operations
    required to terminate the connection, it must then call
    NdisCmCloseCallComplete to signal NDIS that the call has been closed.

@rvalue NDIS_STATUS_INVALID_DATA |

    Indicates that CloseData was specified, but the underlying network medium
    does not support sending data concurrent with terminating a call.

@rvalue NDIS_STATUS_XXX |

    Indicates that the call manager could not terminate the call. The actual
    error returned can be a status propagated from another NDIS library routine.

@xref

    NdisClMakeCall, NdisCmDeactivateVc, NdisCoSendPackets,
    <f ProtocolCmMakeCall>
*/

NDIS_STATUS ProtocolCmCloseCall(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. This handle was provided to
    // NDIS from the call managers <f ProtocolCmMakeCall> function.

    IN NDIS_HANDLE              CallMgrPartyContext,        // @parm
    // Specifies the handle, if any, to a call manager-allocated context area
    // in which the call manager maintain information about a party on a
    // multipoint VC. This handle is NULL if the call being closed is not a
    // multipoint call.

    IN PVOID                    CloseData,                  // @parm
    // Points to a buffer containing connection-oriented client-specified data
    // that should be sent across the connection before the call is terminated.
    // This parameter is NULL if the underlying network medium does not support
    // transfers of data when closing a connection.

    IN UINT                     Size                        // @parm
    // Specifies the length, in bytes, of the buffer at CloseData, zero if
    // CloseData is NULL.
    )
{
    DBG_FUNC("ProtocolCmCloseCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState
              ));

    Result = DChannelCloseCall(pAdapter->pDChannel, pBChannel);
    if (Result != NDIS_STATUS_PENDING)
    {
        CompleteCmCloseCall(pBChannel, Result);
        Result = NDIS_STATUS_PENDING;
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmIncomingCallComplete


@func

    <f ProtocolCmIncomingCallComplete> is a required function that, when called
    by NDIS, indicates to the call manager that the connection-oriented client
    has finished processing of an incoming call offer that the call manager
    previously dispatched through NdisCmDispatchIncomingCall.

@comm

    When the connection-oriented client has completed processing of an incoming
    connection offer that the call manager dispatched to it, this routine will
    be called if NdisCmDispatchIncomingCall returned NDIS_STATUS_PENDING. The
    final status of the incoming call is found in Status. Possible values for
    Status include, but are not limited to:

@flag NDIS_STATUS_SUCCESS |

    Indicates that the call manager has accepted the incoming call.

@flag NDIS_STATUS_FAILURE |

    Indicates that either the address family or the SAP that the call dispatched
    for is currently in the process of closing.

@flag NDIS_STATUS_RESOURCES |

    Indicates that the incoming call was not accepted because the
    connection-oriented client was unable to dynamically allocate resources
    required for it to process the call.

@flag NDIS_STATUS_INVALID_DATA |

    Indicates that the connection-oriented client rejected the call because the
    call parameters specified were invalid.

@normal

    If the client accepts the incoming call, the call manager should send
    signaling message(s) to indicate to the calling entity that the call has
    been accepted. If the client does not accept the call, the call manager
    should send signaling message(s) to indicate that the call has been
    rejected.

    ProtocolCmIncomingCallComplete must be written so that is can be run at IRQL
    DISPATCH_LEVEL.

@xref

    NdisCmDispatchIncomingCall, ProtocolClIncomingCall, <f ProtocolCmRegisterSap>
*/

VOID ProtocolCmIncomingCallComplete(
    IN NDIS_STATUS              Status,                     // @parm
    // Indicates the final status of the operation to dispatch an incoming call
    // to a connection-oriented client.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. The call manager supplied
    // this handle from its <f ProtocolCoCreateVc> function.

    IN PCO_CALL_PARAMETERS      pCallParameters             // @parm
    // Points to the call parameters as specified by the call manager in the
    // call to NdisCmDispatchIncomingCall. The signaling protocol determines
    // which call parameters, if any, the call manager can change.
    )
{
    DBG_FUNC("ProtocolCmIncomingCallComplete")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    if (Status != NDIS_STATUS_SUCCESS)
    {
        // We're not going to answer this call.
        DChannelRejectCall(pAdapter->pDChannel, pBChannel);

        if (pBChannel->Flags & VCF_VC_ACTIVE)
        {
            pBChannel->Flags &= ~VCF_VC_ACTIVE;
            NdisMCmDeactivateVc(pBChannel->NdisVcHandle);
        }

        if (pBChannel->NdisVcHandle)
        {
            NdisMCmDeleteVc(pBChannel->NdisVcHandle);
            pBChannel->NdisVcHandle = NULL;
            ProtocolCoDeleteVc((NDIS_HANDLE) pBChannel);
        }
    }
    else
    {
        Status = DChannelAnswerCall(pAdapter->pDChannel, pBChannel);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            pBChannel->CallState = LINECALLSTATE_CONNECTED;
            NdisMCmDispatchCallConnected(pBChannel->NdisVcHandle);
        }
        else if (Status != NDIS_STATUS_PENDING)
        {
            InitiateCallTeardown(pAdapter, pBChannel);
        }
    }

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmActivateVcComplete


@func

    <f ProtocolCmActivateVcComplete> is a required function that indicates to
    the call manager that a previous call to NdisCoActivateVc has been completed
    by the miniport.

@comm

    When other network components have completed their operations for activating
    a virtual connection, initiated when the call manager called
    NdisCmActivateVc, NDIS notifies the call manager that the VC has been
    activated by calling its ProtocolCmActivateVcComplete function. The status
    of the activation is found in Status. Possible values for Status include,
    but are not limited to:

@flag NDIS_STATUS_SUCCESS |

    Indicates that the VC completed successfully and the call manager can
    continue operations on this VC as required by its media.

@flag NDIS_STATUS_RESOURCES |

    Indicates that another component in the activation has failed to activate
    the virtual connection because of a lack of memory or an inability allocate
    another type of resource.

@flag NDIS_STATUS_NOT_ACCEPTED |

    Indicates that an activation is currently pending on the virtual connection.
    Only one activation can be processed at a time for a virtual connection. The
    request to activate the VC should be tried again at a later time.

@flag NDIS_STATUS_CLOSING |

    Indicates that a deactivation is pending on the VC and the VC is no longer
    available for network communication until the deactivation has been
    completed and a successful activation has taken place.

@flag NDIS_STATUS_INVALID_DATA |

    Indicates that the miniport has rejected the call parameters at
    CallParamters as invalid for the adapter.

@normal

    ProtocolCmActivateVcComplete must check the status returned in Status to
    ensure that the virtual connection has been activated successfully. The call
    manager must not attempt to communicate over the virtual connection if
    Status is not NDIS_STATUS_SUCCESS.

    Call managers must complete any processing required by their network media
    to ensure that the virtual connection is ready for data transmission before
    returning control to NDIS.

    If the call manager specified either ROUND_UP_FLOW or ROUND_DOWN_FLOW in the
    CallParameters->MediaParamters->Flags, the call parameters returned in
    CallParamters can have been changed by the miniport. Call managers should
    examine the call parameters that were returned to ensure proper operation.
    If the new call parameters are unsatisfactory, the call manager should
    either call NdisCmActivateVc again with new call parameters or deactivate
    the VC with NdisCmDeactivateVc.

    ProtocolCmActivateVcComplete must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@xref

    NdisCmActivateVc, NdisCmDeactivateVc, <f ProtocolCmMakeCall>
*/

VOID ProtocolCmActivateVcComplete(
    IN NDIS_STATUS              Status,                     // @parm
    // Specifies the final status, as indicated by the miniport, of the request
    // by the call manager to activate a VC.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. The call manager supplied
    // this handle from its <f ProtocolCoCreateVc> function.

    IN PCO_CALL_PARAMETERS      pCallParameters             // @parm
    // Points the call parameters as specified by the call manager in a call to
    // NdisCmActivateVc.
    )
{
    DBG_FUNC("ProtocolCmActivateVcComplete")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmDeactivateVcComplete


@func

    <f ProtocolCmDeactivateVcComplete> is a required function that completes the
    processing of a call-manager initiated request that the underlying miniport
    (and NDIS) deactivate a VC for which NdisCmDeactivateVc previously returned
    NDIS_STATUS_PENDING.

@comm

    NDIS usually calls ProtocolCmDeactivateVcComplete in the context of the call
    manager's closing down a call on behalf of a connection-oriented client. The
    call manager typically calls NdisCmDeactivateVc from its ProtocolCmCloseCall
    function. Whenever NdisCmDeactivateVc returns NDIS_STATUS_PENDING, NDIS
    subsequently calls its ProtocolCmDeactivateVcComplete function.

    That is, when the underlying connection-oriented miniport has deactivated
    the VC, NDIS calls ProtocolCmDeactivateVcComplete. The final status of the
    deactivation is found in Status. Possible values for the final status
    include, but are not limited to:

@flag NDIS_STATUS_SUCCESS |

    Indicates that the VC was deactivated successfully.

@flag NDIS_STATUS_NOT_ACCEPTED |

    Indicates that an activation is pending on this VC. The call manager should
    attempt to deactivate the VC at a later time.

@flag NDIS_STATUS_CLOSING |

    Indicates that a deactivation is currently pending on this VC. The call
    manager need not call NdisCmDeactivateVc again as only one call to
    NdisCmDeactivateVc is required to deactivate a VC.

@normal

    ProtocolCmDeactivateVcComplete performs whatever postprocessing is necessary
    to complete the deactivation of a virtual connection, such as setting flags
    in its state area to indicate that the connection is inactive or releasing
    dynamically allocated resources used while the VC is active.

    Completion of the deactivation means that all call parameters for the VC
    used on activation are no longer valid. Any further use of the VC is
    prohibited except to reactivate it with a new set of call parameters.

    Call managers should release any resources that were allocated for the VC
    activation and return control as quickly as possible. If the call manager
    previously returned NDIS_STATUS_PENDING from its ProtocolCmCloseCall
    function and all operations to close the call have been completed,
    ProtocolCmDeactivateVcComplete should now call NdisCmCloseCallComplete.

    ProtocolCmDeactivateVcComplete must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@xref

    <f MiniportCoDeactivateVc>, NdisCmCloseCallComplete, NdisCmDeactivateVc,
    <f ProtocolCmCloseCall>
*/

VOID ProtocolCmDeactivateVcComplete(
    IN NDIS_STATUS              Status,                     // @parm
    // Specifies the final status of the deactivation.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. The call manager supplied
    // this handle from its <f ProtocolCoCreateVc> function.
    )
{
    DBG_FUNC("ProtocolCmDeactivateVcComplete")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCmModifyCallQoS


@func

    <f ProtocolCmModifyCallQoS> is a required function that is called by NDIS
    when a connection-oriented client requests that the call parameters be
    changed for an existing virtual connection (VC). If the underlying network
    medium does not support QoS, ProtocolCmModifyQoS should simply return
    NDIS_STATUS_NOT_SUPPORTED.

@comm

    ProtocolCmModifyQoS communicates with network control devices or other
    media-specific agents, as necessitated by its media, to modify the
    media-specific call parameters for an established virtual connection. If the
    call manager is required to communicate with network control agents (e.g. a
    networking switch) it should use a virtual connection to the network control
    agents that it established in its ProtocolBindAdapter function. Standalone
    call managers communicated to the network agents by calling
    NdisCoSendPackets. NIC miniports with integrated call-management support
    never call NdisCoSendPackets. Instead, such a driver simply transfers the
    data over the network to the target network agent.

    After communicating with the network and if the changes were successful, the
    call manager must then call NdisCmActivateVc with the new call parameters.
    This notifies NDIS and/or the connection-oriented miniport that the call
    parameters have changed and provides the miniport with an opportunity to
    validate those parameters.

    If either the network cannot accept the new call parameters or the
    underlying miniport cannot accept the parameters, the call manager must
    restore the virtual connection to the state that existed before any
    modifications were attempted, and return NDIS_STATUS_FAILURE.

    ProtocolCmModifyQoSComplete must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@rdesc

    ProtocolCmModifyQoS returns the status of its operation(s) as one of the
    following values:

@rvalue NDIS_STATUS_SUCCESS |

    Indicates that the call manager successfully changed the parameters of the
    call with the network to the call parameters specified at CallParameters.

@rvalue NDIS_STATUS_PENDING |

    Indicates that the call manager will complete the request to modify the call
    parameters asynchronously. When the call manager has completed all
    operations necessary to modify the call parameters, it must call
    NdisCmModifyCallQoSComplete.

@rvalue NDIS_STATUS_RESOURCES |

    Indicates that the call manager could not change the call parameters of the
    VC because dynamically allocated resources were not available.

@rvalue NDIS_STATUS_INVALID_DATA |

    Indicates that the call manager was unable to change the call parameters of
    the VC because the call parameters provided at CallParameters were illegal
    or invalid.

@rvalue NDIS_STATUS_FAILURE |

    Indicates that the call parameters could not be set to the call parameters
    provided because of a failure in the network or in another
    connection-oriented network component.


@xref

    NdisCmActivateVc, NdisCmModifyCallQoSComplete, NdisCoSendPackets,
    <f ProtocolCoCreateVc>
*/

NDIS_STATUS ProtocolCmModifyCallQoS(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCmMakeCall>.  AKA CallMgrVcContext.<nl>
    // Specifies the handle to a call manager-allocated context area in which
    // the call manager maintains its per-VC state. The call manager supplied
    // this handle from its <f ProtocolCoCreateVc> function.

    IN PCO_CALL_PARAMETERS      pCallParameters             // @parm
    // Points to a CO_CALL_PARAMETERS structure that contains the new call
    // parameters, as specified by a connection-oriented client, for the VC.
    )
{
    DBG_FUNC("ProtocolCmModifyCallQoS")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState
              ));

    // What do you want to do with this request?
    DBG_ERROR(pAdapter, ("pCallParameters=0x%X\n", pCallParameters));

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCoRequest


@func

    <f ProtocolCoRequest> is a required function that handles OID_CO_XXX
    requests initiated by calls to NdisCoRequest from the corresponding
    client(s) or stand-alone call manager or initiated by an MCM driver's calls
    to NdisMCmRequest.

@comm

    Connection-oriented clients and stand-alone call managers communicate
    information to each other by specifying an explicit NdisAfHandle when they
    call NdisCoRequest. Similarly, a connection-oriented miniport with
    integrated call-management support calls NdisMCmRequest with explicit
    NdisAfHandles to communicate information to its individual clients. Such a
    call to NdisCoRequest or NdisMCmRequest with an explicit NdisAfHandle causes
    NDIS to call the ProtocolCoRequest function of the client, stand-alone call
    manager, or MCM driver that shares the given NdisAfHandle.

    If the input NdisVcHandle and NdisPartyHandle are NULL, ProtocolCoRequest
    can consider the request global in nature. For example, ProtocolCoRequest
    satisfies any OID_GEN_CO_XXX query for which it is passed only an explicit
    NdisAfHandle by returning information about all currently active VCs,
    including any active multipoint VCs, on the given address family.

    An explicit NdisVcHandle or NdisPartyHandle indicates that ProtocolCoRequest
    should satisfy the given request on a per-VC or per-party basis,
    respectively.

    ProtocolCoRequest can assume that the buffer at NdisRequest was allocated
    from nonpaged pool and is, therefore, accessible at raised IRQL. The caller
    of NdisCoRequest (or NdisMCmRequest) is responsible for releasing this
    buffer and the internal buffer at InformationBuffer that it allocated when
    its request has been completed.

    If ProtocolCoRequest returns NDIS_STATUS_PENDING, the driver must make a
    subsequent call to NdisCoRequestComplete or, for an MCM driver, to
    NdisMCmRequestComplete when the driver completes its operations to satisfy
    the given request.

    For more information about the sets of OIDs defined for use with
    NdisCoRequest, NdisMCmRequest, and NdisRequest, see Part 2 of this manual.

    ProtocolCoRequest must be written so that it can run at IRQL DISPATCH_LEVEL.

@rdesc

    ProtocolCoRequest can return one of the following:

@rvalue NDIS_STATUS_SUCCESS |

    The client or call manager carried out the requested operation.

@rvalue NDIS_STATUS_PENDING |

    The client or call manager is handling this request asynchronously, and it
    will call NdisCoRequestComplete (or, from a NIC miniport with integrated
    call-management support, NdisMCmRequestComplete) when the requested
    operation is done.

@rvalue NDIS_STATUS_INVALID_LENGTH or NDIS_STATUS_BUFFER_TOO_SHORT |

    The driver is failing this request because the caller of NdisCoRequest or
    NdisMCmRequest did not supply an adequate InformationBuffer for the given
    request. The driver set the BytesNeeded member in the buffer at NdisRequest
    to the Oid-specific value of the InformationBufferLength required to carry
    out the requested operation.

@rvalue NDIS_STATUS_XXX |

    The client or call manager failed the request for some driver-determined
    reason, such as invalid input data specified for a set.

@rvalue NDIS_STATUS_NOT_SUPPORTED |

    The client or call manager failed this request because it did not recognize
    the OID_GEN_CO_XXX code in the Oid member in the buffer at NdisRequest.

@xref

    NdisClOpenAddressFamily, NdisCoRequest, NdisCoRequestComplete,
    NdisMCmRequest, NdisMCmRequestComplete, NdisRequest, NDIS_REQUEST,
    ProtocolCmOpenAf, ProtocolCoRequestComplete

*/

NDIS_STATUS ProtocolCoRequest(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.  AKA ProtocolAfContext.<nl>
    // Specifies the handle to the driver's per-AF context area. The client
    // supplied this handle when it called NdisClOpenAddressFamily to connect
    // itself to the call manager. The call manager supplied this handle from
    // its <f ProtocolCmOpenAf> function, so this handle effectively identifies
    // the particular client that issued this request.

    IN PBCHANNEL_OBJECT         pBChannel OPTIONAL,         // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f BChannelCreate>.  AKA ProtocolVcContext.<nl>
    // Specifies the handle identifying the active VC for which the client or
    // call manager is requesting or setting information if the request is
    // VC-specific. Otherwise, this parameter is NULL.

    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL, // @parm
    // Specifies the handle identifying the party on a multipoint VC for which
    // the client or call manager is requesting or setting information if the
    // request is party-specific. Otherwise, this parameter is NULL.

    IN OUT PNDIS_REQUEST        NdisRequest
    // Points to a buffer, formatted as an NDIS_REQUEST structure specifying
    // the operation to be carried out by ProtocolCoRequest. The Oid member of
    // the NDIS_REQUEST structure contains the system-defined OID_GEN_CO_XXX
    // code specifying the requested query or set operation, together with a
    // buffer in which the protocol returns the requested information for a
    // query or from which it transfers the given information for a set.
    )
{
    DBG_FUNC("ProtocolCmRequest")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    // ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    Result = MiniportCoRequest(pAdapter, pBChannel, NdisRequest);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL CallMgr CallMgr_c ProtocolCoRequestComplete


@func

    <f ProtocolCoRequestComplete> is a required function that postprocesses the
    results of a connection-oriented client's or stand-alone call manager's call
    to NdisCoRequest or of an MCM driver's call to NdisMCmRequest.

@comm

    ProtocolCoRequestComplete can use the input Status as follows:

    If this argument is NDIS_STATUS_SUCCESS, the BytesRead or BytesWritten
    member of the NDIS_REQUEST structure has been set to specify how much data
    was transferred into or from the buffer at InformationBuffer.

    If the given OID_GEN_CO_XXX was a query, ProtocolCoRequestComplete can use
    the data returned at InformationBuffer in any driver-determined way,
    depending on the value of the Oid member.

    ProtocolCoRequestComplete is responsible for releasing the driver-allocated
    buffers at NdisRequest and InformationBuffer when the driver completes its
    postprocessing of this request.

    If this argument is NDIS_STATUS_INVALID_LENGTH or
    NDIS_STATUS_BUFFER_TOO_SHORT, the BytesNeeded member specifies the
    Oid-specific value of the InformationBufferLength required to carry out the
    requested operation.

    In these circumstances, ProtocolCoRequestComplete can allocate sufficient
    buffer space for the request, set up another NDIS_REQUEST structure with the
    required InformationBufferLength and the same Oid value, and retry the
    driver's call to NdisCoRequest or NdisMCmRequest.

    If this argument is an NDIS_STATUS_XXX that indicates an unrecoverable
    error, ProtocolCoRequestComplete should release the buffer at NdisRequest
    and carry out any driver-determined operations that are necessary. For
    example, ProtocolCoRequestComplete might tear down the driver-created VC if
    a returned error status indicates that the driver cannot continue to make
    transfers on the virtual connection.

    Even if a driver's call to NdisCoRequest or NdisMCmRequest returns something
    other than NDIS_STATUS_PENDING, that driver should use its
    ProtocolCoRequestComplete function to postprocess completed requests. Making
    an internal call to the driver's own ProtocolCoRequestComplete function on
    return from NdisCoRequest or NdisMCmRequest has almost no adverse effect on
    the driver's performance, makes the driver's image smaller, and makes the
    driver easier to maintain from one OS release to the next since such a
    driver has no duplicate code doing status-return checking on
    driver-initiated requests.

    For more information about the sets of OIDs defined for use with
    NdisCoRequest and NdisMCmRequest, see Part 2 of this manual.

    ProtocolCoRequestComplete must be written so that it can run at IRQL
    DISPATCH_LEVEL.

@xref

    NdisCoRequest, NdisCoRequestComplete, NdisMCmRequest,
    NdisMCmRequestComplete, NDIS_REQUEST, <f ProtocolCoRequest>

*/

VOID ProtocolCoRequestComplete(
    IN NDIS_STATUS              Status,                     // @parm
    // Specifies the final status of the driver-initiated request, either
    // NDIS_STATUS_SUCCESS or a failure NDIS_STATUS_XXX that was set by the
    // corresponding client or call manager that handled this request. This
    // parameter is never NDIS_STATUS_PENDING.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.  AKA ProtocolAfContext.<nl>
    // Specifies the handle to the driver's per-AF context area. The client
    // supplied this handle when it called NdisClOpenAddressFamily to connect
    // itself to the call manager. The call manager supplied this handle from
    // its ProtocolCmOpenAf function, so this handle effectively identifies the
    // particular client to which this request was directed.

    IN PBCHANNEL_OBJECT         pBChannel OPTIONAL,         // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f BChannelCreate>.  AKA ProtocolVcContext.<nl>
    // Specifies the handle identifying the active VC for which the client or
    // call manager was requesting or setting information if the request was
    // VC-specific. Otherwise, this parameter is NULL.

    IN  NDIS_HANDLE             ProtocolPartyContext OPTIONAL, // @parm
    // Specifies the handle identifying the party on a multipoint VC for which
    // the client or call manager was requesting or setting information if the
    // request is party-specific. Otherwise, this parameter is NULL.

    IN PNDIS_REQUEST            NdisRequest                 // @parm
    // Points to the driver-allocated buffer, formatted as an NDIS_REQUEST
    // structure that the driver passed in a preceding call to NdisCoRequest or
    // NdisMCmRequest. The Oid member of the NDIS_REQUEST structure contains
    // the system-defined OID_GEN_CO_XXX code specifying the requested query or
    // set operation, together with a buffer in which the corresponding client
    // or call manager returned the requested information for a query or from
    // which it transferred the given information for a set if Status is
    // NDIS_STATUS_SUCCESS.
    )
{
    DBG_FUNC("ProtocolCmRequestComplete")

    // ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState, Status
              ));

    // MCM's don't typically need this, since there's nothing below...

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL CallMgr CallMgr_c AllocateIncomingCallParameters


@func

    <f AllocateIncomingCallParameters> is called by <f SetupIncomingCall>
    when getting ready to indicate an incoming call up to NDPROXY.

@comm

    AllocateIncomingCallParameters allocates memory for the incoming call
    parameters <t PCO_CALL_PARAMETERS>.  The memory is only allocated the
    first time a call comes in on a particular BChannel.  After that, the
    same structure is reused for each incoming call on that BChannel.

    The structure is defined by NDPROXY, CONDIS, and TAPI so it includes
    all the necessary media specific parameters.  The data structures are
    allocated and laid out end to end in the following format:

    <tab> sizeof(CO_CALL_PARAMETERS)<nl>
    <tab> sizeof(CO_CALL_MANAGER_PARAMETERS)<nl>
    <tab> sizeof(CO_MEDIA_PARAMETERS)<nl>
    <tab> sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)<nl>
    <tab> sizeof(LINE_CALL_INFO)<nl>

    The call parameters for the sample driver are hard coded, but you should
    fill in the correct information from incoming call request.

*/

PCO_CALL_PARAMETERS AllocateIncomingCallParameters(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.
    )
{
    DBG_FUNC("AllocateIncomingCallParameters")

    PCO_CALL_PARAMETERS         pCp;
    PCO_CALL_MANAGER_PARAMETERS pCmp;
    PCO_MEDIA_PARAMETERS        pMp;
    PCO_AF_TAPI_INCOMING_CALL_PARAMETERS pTcp;
    PLINE_CALL_INFO             pLci;

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pBChannel->NdisTapiSap.ulMediaModes & LINEMEDIAMODE_DIGITALDATA);
    pBChannel->MediaMode  = LINEMEDIAMODE_DIGITALDATA;
    pBChannel->BearerMode = LINEBEARERMODE_DATA;
    pBChannel->LinkSpeed  = _64KBPS;

    if (pBChannel->pInCallParms != NULL)
    {
        // Already allocated call parameters for this channel.
        return (pBChannel->pInCallParms);
    }

    pBChannel->CallParmsSize = sizeof(CO_CALL_PARAMETERS)
                             + sizeof(CO_CALL_MANAGER_PARAMETERS)
                             + sizeof(CO_MEDIA_PARAMETERS)
                             + sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)
                             + sizeof(LINE_CALL_INFO);

    ALLOCATE_MEMORY(pBChannel->pInCallParms,
                    pBChannel->CallParmsSize,
                    pAdapter->MiniportAdapterHandle);

    if (pBChannel->pInCallParms == NULL)
    {
        return (pBChannel->pInCallParms);
    }

    NdisZeroMemory(pBChannel->pInCallParms, pBChannel->CallParmsSize);

    DBG_NOTICE(pAdapter,(
                "\n"
                "\t\tsizeof(CO_CALL_PARAMETERS)                 =%03d\n"
                "\t\tsizeof(CO_CALL_MANAGER_PARAMETERS)         =%03d\n"
                "\t\tsizeof(CO_MEDIA_PARAMETERS)                =%03d\n"
                "\t\tsizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS)=%03d\n"
                "\t\tsizeof(LINE_CALL_INFO)                     =%03d\n"
                "\t\tTotal                                      =%03d\n",
                sizeof(CO_CALL_PARAMETERS),
                sizeof(CO_CALL_MANAGER_PARAMETERS),
                sizeof(CO_MEDIA_PARAMETERS),
                sizeof(CO_AF_TAPI_INCOMING_CALL_PARAMETERS),
                sizeof(LINE_CALL_INFO),
                pBChannel->CallParmsSize
                ));
    pCp  = (PCO_CALL_PARAMETERS)        pBChannel->pInCallParms;
    pCmp = (PCO_CALL_MANAGER_PARAMETERS)(pCp + 1);
    pMp  = (PCO_MEDIA_PARAMETERS)       (pCmp + 1);
    pTcp = (PCO_AF_TAPI_INCOMING_CALL_PARAMETERS)
                                        pMp->MediaSpecific.Parameters;
    pLci = (PLINE_CALL_INFO)            (pTcp + 1);

    // TODO: Fill in the call parameters as needed.

    pCp->Flags                          = PERMANENT_VC;
    pCp->CallMgrParameters              = pCmp;
    pCp->MediaParameters                = pMp;

    pCmp->Transmit.TokenRate            = pBChannel->LinkSpeed / 8;
    pCmp->Transmit.TokenBucketSize      = pAdapter->pCard->BufferSize;
    pCmp->Transmit.PeakBandwidth        = pBChannel->LinkSpeed / 8;
    pCmp->Transmit.Latency              = 0;
    pCmp->Transmit.DelayVariation       = 0;
    pCmp->Transmit.ServiceType          = SERVICETYPE_BESTEFFORT;
    pCmp->Transmit.MaxSduSize           = pAdapter->pCard->BufferSize;
    pCmp->Transmit.MinimumPolicedSize   = 0;
    pCmp->Receive                       = pCmp->Transmit;
    pCmp->CallMgrSpecific.ParamType     = 0;
    pCmp->CallMgrSpecific.Length        = 0;

    pMp->Flags                          = TRANSMIT_VC | RECEIVE_VC;
    pMp->ReceiveSizeHint                = pAdapter->pCard->BufferSize;
    pMp->MediaSpecific.ParamType        = 0;
    pMp->MediaSpecific.Length           = sizeof(*pTcp) + sizeof(*pLci);

    pTcp->ulLineID                      = pBChannel->NdisTapiSap.ulLineID;
    pTcp->ulAddressID                   = TSPI_ADDRESS_ID;
    pTcp->ulFlags                       = CO_TAPI_FLAG_INCOMING_CALL;
    pTcp->LineCallInfo.Length           = sizeof(*pLci);
    pTcp->LineCallInfo.MaximumLength    = sizeof(*pLci);
    pTcp->LineCallInfo.Offset           = sizeof(NDIS_VAR_DATA_DESC);

    pLci->ulTotalSize =
    pLci->ulNeededSize =
    pLci->ulUsedSize = sizeof(*pLci);

    /*
    // The link has all the call information we need to return.
    */
    pLci->hLine = (ULONG) (ULONG_PTR) pBChannel;
    pLci->ulLineDeviceID = pTcp->ulLineID;
    pLci->ulAddressID = pTcp->ulAddressID;

    pLci->ulBearerMode = pBChannel->BearerMode;
    pLci->ulRate = pBChannel->LinkSpeed;
    pLci->ulMediaMode = pBChannel->MediaMode;

    pLci->ulCallParamFlags = LINECALLPARAMFLAGS_IDLE;
    pLci->ulCallStates = pBChannel->CallStatesCaps;

    /*
    // We don't support any of the callerid functions.
    */
    pLci->ulCallerIDFlags =
    pLci->ulCalledIDFlags =
    pLci->ulConnectedIDFlags =
    pLci->ulRedirectionIDFlags =
    pLci->ulRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;

    DBG_RETURN(pAdapter, pBChannel->pInCallParms);
    return (pBChannel->pInCallParms);
}


/* @doc INTERNAL CallMgr CallMgr_c SetupIncomingCall


@func

    <f SetupIncomingCall> is called by the card level DPC routine when it
    detects an incoming call from the network.

@comm

    Before calling this routine, the caller should save information about
    the call so it can be used by <f AllocateIncomingCallParameters> to
    setup the incoming call parameters for NDPROXY.

@rdesc

    <f SetupIncomingCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS SetupIncomingCall(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.

    OUT PBCHANNEL_OBJECT *      ppBChannel                  // @parm
    // Specifies, on output, a pointer to the <t BCHANNEL_OBJECT> instance
    // returned by <f ProtocolCoCreateVc> that is to be associated with this
    // incoming call.
    )
{
    DBG_FUNC("SetupIncomingCall")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PCO_CALL_PARAMETERS         pCallParams;
    // Pointer to the incoming call parameters.

    PBCHANNEL_OBJECT            pBChannel;

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    // See if there's a VC availble for this call.
    Result = ProtocolCoCreateVc(pAdapter, NULL, ppBChannel);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto exit;
    }

    // Save the VC info and allocate the call parameters.
    pBChannel = *ppBChannel;
    pBChannel->Flags |= VCF_INCOMING_CALL;
    pCallParams = AllocateIncomingCallParameters(pBChannel);

    // Make sure we have the parameters
    if (pCallParams == NULL)
    {
        Result = NDIS_STATUS_RESOURCES;
        goto error2;
    }

    // Tell NDPROXY to create a VC for this call.
    Result = NdisMCmCreateVc(pAdapter->MiniportAdapterHandle,
                             pAdapter->NdisAfHandle,
                             pBChannel,
                             &pBChannel->NdisVcHandle);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter, ("NdisMCmCreateVc Status=0x%X\n", Result));
        goto error2;
    }

    // Tell NDPROXY to activate the VC.
    Result = NdisMCmActivateVc(pBChannel->NdisVcHandle, pCallParams);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter, ("NdisMCmActivateVc Status=0x%X\n", Result));
        goto error3;
    }

    // Mark the VC as active and update the call state.
    pBChannel->Flags |= VCF_VC_ACTIVE;
    pBChannel->CallState = LINECALLSTATE_OFFERING;

    DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
              ("#%d VC=0x%X AF=0x%X SAP=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle,
               pAdapter->NdisAfHandle, pBChannel->NdisSapHandle
              ));
       
    // Need to use the NDIS SAP handle             
    if(!ReferenceSap(pAdapter, pBChannel))
    {
        NdisMCmDeactivateVc(pBChannel->NdisVcHandle);
        goto error3;
    }

    // Tell NDPROXY to dispatch the call to the TAPI clients.
    Result = NdisMCmDispatchIncomingCall(pBChannel->NdisSapHandle,
                                         pBChannel->NdisVcHandle,
                                         pCallParams);
    switch (Result)
    {
        case NDIS_STATUS_SUCCESS:
            DBG_NOTICE(pAdapter,("NdisMCmDispatchIncomingCall completed synchronously\n"));
            ProtocolCmIncomingCallComplete(Result, pBChannel, NULL);
            goto exit;

        case NDIS_STATUS_PENDING:
            DBG_NOTICE(pAdapter,("NdisMCmDispatchIncomingCall returned pending\n"));
            // Let ProtocolCmIncomingCallComplete deal with it now.
            goto exit;
    }
    
    // Done with the NDIS SAP handle                                                   
    DereferenceSap(pAdapter, pBChannel);            
        
    // BUMMER - There must be a problem with NDPRROXY...
    DBG_ERROR(pAdapter, ("NdisMCmDispatchIncomingCall Status=0x%X\n", Result));

    pBChannel->CallState = LINECALLSTATE_IDLE;
    if (pBChannel->Flags & VCF_VC_ACTIVE)
    {
        pBChannel->Flags &= ~VCF_VC_ACTIVE;
        NdisMCmDeactivateVc(pBChannel->NdisVcHandle);
    }

error3:
    if (pBChannel->NdisVcHandle)
    {
        NdisMCmDeleteVc(pBChannel->NdisVcHandle);
        pBChannel->NdisVcHandle = NULL;
    }

error2:
    ProtocolCoDeleteVc((NDIS_HANDLE) pBChannel);

exit:

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL CallMgr CallMgr_c InitiateCallTeardown


@func

    <f InitiateCallTeardown> is called by the card level DPC routine when it
    detects a call disconnect from the network.

@comm

    The disconnect here is coming from the telephone network rather than from
    NDIS.  This can be called on either an incoming call or an outgoing call
    when the miniport has determined that the link has been lost to the remote
    endpoint.

*/

VOID InitiateCallTeardown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance return by
    // <f AdapterCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreateVc>.
    )
{
    DBG_FUNC("InitiateCallTeardown")

    NDIS_STATUS                 Status;

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    if (pBChannel->Flags & VCF_VC_ACTIVE)
    {
        // Normal teardown.
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        // Call never fully established.
        Status = NDIS_STATUS_FAILURE;
    }
    DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
              ("#%d VC=0x%X CallState=0x%X Status=0x%X\n",
               pBChannel->ObjectID,
               pBChannel->NdisVcHandle, pBChannel->CallState,
               Status
              ));

    pBChannel->CallState = LINECALLSTATE_DISCONNECTED;

    // Make sure there are no packets left on this channel before it closes.
    FlushSendPackets(pAdapter, pBChannel);

    // Notify NDPROXY that the call's connection has been lost.
    NdisMCmDispatchIncomingCloseCall(Status,
                                     pBChannel->NdisVcHandle,
                                     NULL, 0);

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\interupt.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Interrupt Interrupt_c

@module Interrupt.c |

    This module implements the Miniport interrupt processing routines and
    asynchronous processing routines.  
    
    The sample driver does not support physical hardware, so there is no need
    for the typical interrupt handler routines.  However, the driver does
    have an asynchronous event handler which is contained in this module.

@comm

    This module is very dependent on the hardware/firmware interface and should 
    be looked at whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Interupt_c

@end

*/

#define  __FILEID__             INTERRUPT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportCheckForHang


@func

    <f MiniportCheckForHang> reports the state of the network interface card.

@comm

    The NDIS library calls <f MiniportCheckForHang> once every two seconds to
    check the state of the network interface card.  If this function returns
    TRUE, the NDIS library then attempts to reset the NIC by calling
    <f MiniportReset>.  <f MiniportCheckForHang> should do nothing more than
    check the internal state of the NIC and return TRUE if it detects that
    the NIC is not operating correctly.

    Interrupts can be in any state when MiniportCheckForHang is called.

    <f Note>:
    If your hardware/firmware is flakey you can request that the NDIS
    wrapper call your MiniportReset routine by returning TRUE from this
    routine.  For well behaved hardware/firmware you should always return
    FALSE from this routine.

@rdesc

    <f MiniportCheckForHang> returns FALSE if the NIC is working properly.<nl>
    Otherwise, a TRUE return value indicates that the NIC needs to be reset.

*/

BOOLEAN MiniportCheckForHang(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportCheckForHang")
    // If your hardware can lockup, then you can return TRUE here.
    // If you return TRUE, your MiniportReset routine will be called.
    return (FALSE);
}


#if defined(CARD_REQUEST_ISR)
#if (CARD_REQUEST_ISR == FALSE)

/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportDisableInterrupt


@func

    <f MiniportDisableInterrupt> disables the NIC from generating interrupts.

@comm

    Typically, this function disables interrupts by writing a mask value
    specific to the network interface card.

    If the NIC does not support enabling and disabling interrupts, the
    miniport driver must register a miniport interrupt service routine with
    the NDIS library.  Within the interrupt service routine, the miniport
    driver must acknowledge and save the interrupt information.

    In some cases, the NIC must be in a certain state for
    <f MiniportDisableInterrupt> to execute correctly. In these cases, the
    miniport driver must encapsulate within a function all portions of the
    driver which violate the required state and which can be called when
    interrupts are enabled.  Then the miniport driver must call the
    encapsulated code through the NdisMSynchronizeWithInterrupt function.
    For example, on some network interface cards, the I/O ports are paged
    and must be set to page 0 for the deferred processing routine to run
    correctly.  With this kind of NIC, the DPC must be synchronized with
    interrupts.

    Interrupts can be in any state when <f MiniportDisableInterrupt> is
    called.

*/

void MiniportDisableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportDisableInterrupt")
    DBG_ERROR(pAdapter,("This should not be called!\n"));
}


/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportEnableInterrupt


@func

    <f MiniportEnableInterrupt> enables the NIC to generate interrupts.

@comm

    Typically, this function enables interrupts by writing a mask value
    specific to the network interface card.

    If the NIC does not support enabling and disabling interrupts, the
    miniport driver must register a miniport interrupt service routine with
    the NDIS library. Within the interrupt service routine, the miniport
    driver must acknowledge and save the interrupt information.

    Interrupts can be in any state when <f MiniportEnableInterrupt> is called.

*/

void MiniportEnableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportEnableInterrupt")
    DBG_ERROR(pAdapter,("This should not be called!\n"));
}

#else // !(CARD_REQUEST_ISR == FALSE)

/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportISR


@func

    <f MiniportISR> is the miniport driver's interrupt service routine. This
    function runs at a high priority in response to an interrupt. The driver
    should do as little work as possible in this function. It should set
    <p InterruptRecognized> to TRUE if it recognizes the interrupt as
    belonging to its network interface card, or FALSE otherwise. It should
    return FALSE as soon as possible if the interrupt is not generated by
    its NIC. It should set <f QueueMiniportHandleInterrupt> to TRUE if a
    call to <f MiniportHandleInterrupt> at a lower priority is required to
    complete the handling of the interrupt.

    <f Note>: <f MiniportISR> must not call any support functions in the NDIS
    interface library or the transport driver.

@comm

    <f MiniportISR> is called in the following cases:<nl>

    o   The NIC generates an interrupt when there is an outstanding call to
        <f MiniportInitialize>.

    o   The miniport driver supports sharing its interrupt line with another
        NIC.

    o   The miniport driver specifies that this function must be called for
        every interrupt.

    <f Note>: A deferred processing routine is not queued if the miniport
    driver is currently executing <f MiniportHalt> or <f MiniportInitialize>.

*/

void MiniportISR(
    OUT PBOOLEAN                InterruptRecognized,        // @parm
    // If the miniport driver is sharing an interrupt line and it detects
    // that the interrupt came from its NIC, <f MiniportISR> should set
    // this parameter to TRUE.

    OUT PBOOLEAN                QueueMiniportHandleInterrupt, // @parm
    // If the miniport driver is sharing an interrupt line and if
    // <f MiniportHandleInterrupt> must be called to complete handling of
    // the interrupt, <f MiniportISR> should set this parameter to TRUE.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportISR")

    ULONG                       InterruptStatus;

    // TODO: Get the interrupt status from your card.
    if ((InterruptStatus = pAdapter->TODO) == 0)
    {
        *InterruptRecognized =
        *QueueMiniportHandleInterrupt = FALSE;
    }
    else
    {
        pAdapter->pCard->InterruptStatus = InterruptStatus;
        *InterruptRecognized =
        *QueueMiniportHandleInterrupt = TRUE;
    }
}

#endif // (CARD_REQUEST_ISR == FALSE)
#endif // defined(CARD_REQUEST_ISR)

/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportHandleInterrupt


@func

    <f MiniportHandleInterrupt> is called by the deferred processing routine
    in the NDIS library to process an interrupt.

@comm

    During a call to <f MiniportHandleInterrupt>, the miniport driver should
    handle all outstanding interrupts and start any new operations.

    Interrupts are disabled during a call to <f MiniportHandleInterrupt>.

*/

void MiniportHandleInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportHandleInterrupt")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    ULONG                       BChannelIndex;
    // Index into the pBChannelArray.

    /*
    // Process NIC interrupt.
    */
    CardInterruptHandler(pAdapter->pCard);

    /*
    // Walk through all the links to see if there is any post-proccessing
    // that needs to be done.
    */
    for (BChannelIndex = 0; BChannelIndex < pAdapter->NumBChannels; ++BChannelIndex)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex);

        if (pBChannel->IsOpen)
        {
            /*
            // Indicate a receive complete if it's needed.
            */
            if (pBChannel->NeedReceiveCompleteIndication)
            {
                pBChannel->NeedReceiveCompleteIndication = FALSE;

                /*
                // Indicate receive complete to the NDIS wrapper.
                */
                DBG_RXC(pAdapter, pBChannel->ObjectID);
                NdisMCoReceiveComplete(pAdapter->MiniportAdapterHandle);
            }
        }
    }

    /*
    // Indicate a status complete if it's needed.
    */
    if (pAdapter->NeedStatusCompleteIndication)
    {
        pAdapter->NeedStatusCompleteIndication = FALSE;
        NdisMIndicateStatusComplete(pAdapter->MiniportAdapterHandle);
    }
}


/* @doc EXTERNAL INTERNAL Interupt Interupt_c MiniportTimer


@func

    <f MiniportTimer> is a required function if a Minipor's NIC does not
    generate interrupts.  Otherwise, one or more <f MiniportTimer> functions
    are optional.

    The driver of a NIC that does not generate interrupts must have a <f
    MiniportTimer> function to poll the state of the NIC. After such a
    Miniport's MiniportInitialize function sets up the driver-allocated timer
    object with NdisMInitializeTimer, a call to NdisMSetPeriodicTimer causes
    the <f MiniportTimer> function associated with the timer object to be run
    repeatedly and automatically at the interval specified by
    MillisecondsPeriod. Such a polling <f MiniportTimer> function monitors the
    state of the NIC to determine when to make indications, when to complete
    pending sends, and so forth. In effect, such a polling <f MiniportTimer>
    function has the same functionality as the MiniportHandleInterrupt
    function in the driver of a NIC that does generate interrupts.

    By contrast, calling NdisMSetTimer causes the <f MiniportTimer> function
    associated with the timer object to be run once when the given
    MillisecondsToDelay expires.  Such a <f MiniportTimer> function usually
    performs some driver-determined action if a particular operation times
    out.

    If either type of <f MiniportTimer> function shares resources with other
    driver functions, the driver should synchronize access to those resources
    with a spin lock.

    A Miniport can have more than one <f MiniportTimer> function at the
    discretion of the driver writer. Each such <f MiniportTimer> function must
    be associated with a driver-allocated and initialized timer object.

    A call to NdisMCancelTimer cancels execution of a nonpolling
    <f MiniportTimer> function, provided that the interval passed in the
    immediately preceding call to NdisMSetTimer has not yet expired. After a
    call to NdisMSetPeriodicTimer, a call to NdisMSetTimer or NdisMCancelTimer
    with the same timer object disables a polling <f MiniportTimer> function:
    either the <f MiniportTimer> function runs once, or it is canceled.

    The MiniportHalt function of any driver with a <f MiniportTimer> function
    should call NdisMCancelTimer to ensure that the <f MiniportTimer> function
    does not attempt to access resources that MiniportHalt has already
    released.

    By default, <f MiniportTimer> runs at IRQL DISPATCH_LEVEL.

*/

void MiniportTimer(
    IN PVOID                    SystemSpecific1,            // @parm
    // UNREFERENCED_PARAMETER

    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PVOID                    SystemSpecific2,            // @parm
    // UNREFERENCED_PARAMETER

    IN PVOID                    SystemSpecific3             // @parm
    // UNREFERENCED_PARAMETER
    )
{
    DBG_FUNC("MiniportTimer")

    // DBG_ENTER(pAdapter);

    /*
    // If this is a nested callback, just return, and we'll loop back to
    // the DoItAgain before leaving the outermost callback.
    */
    if (++(pAdapter->NestedEventHandler) > 1)
    {
        DBG_WARNING(pAdapter,("NestedEventHandler=%d > 1\n",
                  pAdapter->NestedEventHandler));
        return;
    }

DoItAgain:
#if defined(SAMPLE_DRIVER)
    /*
    // This sample driver uses timer to simulate interrupts.
    */
    MiniportHandleInterrupt(pAdapter);
#else  // SAMPLE_DRIVER
    // TODO - Add code here to handle timer interrupt events.
#endif // SAMPLE_DRIVER

    /*
    // If we got a nested callback, we have to loop back around.
    */
    if (--(pAdapter->NestedEventHandler) > 0)
    {
        goto DoItAgain;
    }
    else if (pAdapter->NestedEventHandler < 0)
    {
        DBG_ERROR(pAdapter,("NestedEventHandler=%d < 0\n",
                  pAdapter->NestedEventHandler));
    }

    // DBG_LEAVE(pAdapter);

    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\miniport.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Miniport Miniport_c

@module Miniport.c |

    This module implements the <f DriverEntry> routine, which is the first
    routine called when the driver is loaded into memory.  The Miniport
    initialization and termination routines are also implemented here.

@comm

    This module should not require any changes.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Miniport_c

@end

*/

#define  __FILEID__             MINIPORT_DRIVER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects
#include "TpiParam.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC NDIS_HANDLE          g_NdisWrapperHandle = NULL;     // @globalv
// Receives the context value representing the Miniport wrapper
// as returned from NdisMInitializeWrapper.

NDIS_PHYSICAL_ADDRESS           g_HighestAcceptableAddress =    // @globalv
// This constant is used for places where NdisAllocateMemory needs to be
// called and the g_HighestAcceptableAddress does not matter.
                                NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);


/* @doc EXTERNAL INTERNAL Miniport Miniport_c DriverEntry


@func

    <f DriverEntry> is called by the operating system when a driver is loaded.
    This function creates an association between the miniport NIC driver and
    the NDIS library and registers the miniport's characteristics with NDIS.

    DriverEntry calls NdisMInitializeWrapper and then NdisMRegisterMiniport.
    DriverEntry passes both pointers it received to NdisMInitializeWrapper,
    which returns a wrapper handle.  DriverEntry passes the wrapper handle to
    NdisMRegisterMiniport.

    The registry contains data that is persistent across system boots, as well
    as configuration information generated anew at each system boot.  During
    driver installation, data describing the driver and the NIC is stored in
    the registry. The registry contains adapter characteristics that are read
    by the NIC driver to initialize itself and the NIC. See the Kernel-Mode
    Driver Design Guide for more about the registry and the Programmer's Guide
    for more information about the .inf files that install the driver and
    write to the registry.

@comm

    Every miniport driver must provide a function called DriverEntry.  By
    convention, DriverEntry is the entry point address for a driver.  If a
    driver does not use the name DriverEntry, the driver developer must define
    the name of its entry function to the linker so that the entry point
    address can be known into the OS loader.

    It is interesting to note, that at the time DriverEntry is called, the OS
    doesn't know that the driver is an NDIS driver.  The OS thinks it is just
    another driver being loaded.  So it is possible to do anything any driver
    might do at this point.  Since NDIS is the one who requested this driver
    to be loaded, it would be polite to register with the NDIS wrapper.  But
    you can also hook into other OS functions to use and provide interfaces
    outside the NDIS wrapper.  (Not recommended for the faint of heart).

@comm

    The parameters passed to DriverEntry are OS specific! NT passes in valid
    values, but Windows 3.1 and Windows 95 just pass in zeros.  We don't
    care, because we just pass them to the NDIS wrapper anyway.

@rdesc

    <f DriverEntry> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT           DriverObject,               // @parm
    // A pointer to the driver object, which was created by the I/O system.

    IN PUNICODE_STRING          RegistryPath                // @parm
    // A pointer to the registry path, which specifies where driver-specific
    // parameters are stored.
    )
{
    DBG_FUNC("DriverEntry")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    NTSTATUS                    Result;
    // Result code returned by this function.

    NDIS_MINIPORT_CHARACTERISTICS NdisCharacteristics;
    // Characteristics table passed to NdisMWanRegisterMiniport.

    /*
    // Setup default debug flags then breakpoint so we can tweak them
    // when this module is first loaded.  It is also useful to see the
    // build date and time to be sure it's the one you think it is.
    */
#if DBG
    DbgInfo->DbgFlags = DBG_DEFAULTS;
    DbgInfo->DbgID[0] = '0';
    DbgInfo->DbgID[1] = ':';
    ASSERT (sizeof(VER_TARGET_STR) <= sizeof(DbgInfo->DbgID)-2);
    memcpy(&DbgInfo->DbgID[2], VER_TARGET_STR, sizeof(VER_TARGET_STR));
#endif // DBG
    DBG_PRINT((VER_TARGET_STR": Build Date:"__DATE__" Time:"__TIME__"\n"));
    DBG_PRINT((VER_TARGET_STR": DbgInfo=0x%X DbgFlags=0x%X\n",
               DbgInfo, DbgInfo->DbgFlags));
    DBG_BREAK(DbgInfo);

    DBG_ENTER(DbgInfo);
    DBG_PARAMS(DbgInfo,
              ("\n"
               "\t|DriverObject=0x%X\n"
               "\t|RegistryPath=0x%X\n",
               DriverObject,
               RegistryPath
              ));

    /*
    // Initialize the Miniport wrapper - THIS MUST BE THE FIRST NDIS CALL.
    */
    NdisMInitializeWrapper(
            &g_NdisWrapperHandle,
            DriverObject,
            RegistryPath,
            NULL
            );
    ASSERT(g_NdisWrapperHandle);

    /*
    // Initialize the characteristics table, exporting the Miniport's entry
    // points to the Miniport wrapper.
    */
    NdisZeroMemory((PVOID)&NdisCharacteristics, sizeof(NdisCharacteristics));
    NdisCharacteristics.MajorNdisVersion        = NDIS_MAJOR_VERSION;
    NdisCharacteristics.MinorNdisVersion        = NDIS_MINOR_VERSION;
    NdisCharacteristics.Reserved                = NDIS_USE_WAN_WRAPPER;

    NdisCharacteristics.InitializeHandler       = MiniportInitialize;
    NdisCharacteristics.CheckForHangHandler     = MiniportCheckForHang;
    NdisCharacteristics.HaltHandler             = MiniportHalt;
    NdisCharacteristics.ResetHandler            = MiniportReset;
    NdisCharacteristics.ReturnPacketHandler     = MiniportReturnPacket;

    NdisCharacteristics.CoActivateVcHandler     = MiniportCoActivateVc;
    NdisCharacteristics.CoDeactivateVcHandler   = MiniportCoDeactivateVc;
    NdisCharacteristics.CoRequestHandler        = MiniportCoRequest;
    NdisCharacteristics.CoSendPacketsHandler    = MiniportCoSendPackets;

    // These two routines are not needed because we are an MCM.
    // NdisCharacteristics.CoCreateVcHandler       = MiniportCoCreateVc;
    // NdisCharacteristics.CoDeleteVcHandler       = MiniportCoDeleteVc;

    /*
    // If the adapter does not generate an interrupt, these entry points
    // are not required.  Otherwise, you can use the have the ISR routine
    // called each time an interupt is generated, or you can use the
    // enable/disable routines.
    */
#if defined(CARD_REQUEST_ISR)
# if (CARD_REQUEST_ISR == FALSE)
    NdisCharacteristics.DisableInterruptHandler = MiniportDisableInterrupt;
    NdisCharacteristics.EnableInterruptHandler  = MiniportEnableInterrupt;
# endif // CARD_REQUEST_ISR == FALSE
    NdisCharacteristics.HandleInterruptHandler  = MiniportHandleInterrupt;
    NdisCharacteristics.ISRHandler              = MiniportISR;
#endif // defined(CARD_REQUEST_ISR)

    /*
    // Register the driver with the Miniport wrapper.
    */
    Status = NdisMRegisterMiniport(
                    g_NdisWrapperHandle,
                    (PNDIS_MINIPORT_CHARACTERISTICS) &NdisCharacteristics,
                    sizeof(NdisCharacteristics)
                    );

    /*
    // The driver will not load if this call fails.
    // The system will log the error for us.
    */
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(DbgInfo,("Status=0x%X\n",Status));
        Result = STATUS_UNSUCCESSFUL;
    }
    else
    {
        DBG_NOTICE(DbgInfo,("Status=0x%X\n",Status));
        Result = STATUS_SUCCESS;
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL Miniport Miniport_c MiniportInitialize


@func

    <f MiniportInitialize> is a required function that sets up a NIC (or
    virtual NIC) for network I/O operations, claims all hardware resources
    necessary to the NIC in the registry, and allocates resources the driver
    needs to carry out network I/O operations.

@comm

    No other outstanding requests to the miniport driver are possible when
    MiniportInitialize is called. No other request is submitted to the
    miniport driver until initialization is completed.

    The NDIS library supplies an array of supported media types. The miniport
    driver reads this array and provides the index of the media type that the
    NDIS library should use with this miniport driver. If the miniport driver
    is emulating a media type, its emulation must be transparent to the NDIS
    library.

    MiniportInitialize must call NdisMSetAttributes in order to return
    MiniportAdapterContext.

    If the miniport driver cannot find a common media type supported by both
    itself and the NDIS library, it should return
    NDIS_STATUS_UNSUPPORTED_MEDIA.

    If NDIS_STATUS_OPEN_ERROR is returned, the NDIS wrapper can examine the
    output parameter OpenErrorStatus to obtain more information about the
    error.

    MiniportInitialize is called with interrupts enabled. MiniportISR is
    called if the NIC generates any interrupts. The NDIS library will not call
    MiniportDisableInterrupt and MiniportEnableInterrupt during the
    MiniportInitialize function, so it is the responsibility of the miniport
    driver to acknowledge and clear any interrupts generated.

@rdesc

    <f MiniportInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS MiniportInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,            // @parm
    // Points to a variable that MiniportInitialize sets to an
    // NDIS_STATUS_XXX code specifying additional information about the
    // error if MiniportInitialize will return NDIS_STATUS_OPEN_ERROR.

    OUT PUINT                   SelectedMediumIndex,        // @parm
    // Points to a variable in which MiniportInitialize sets the index of
    // the MediumArray element that specifies the medium type the driver
    // or its NIC uses.

    IN PNDIS_MEDIUM             MediumArray,                // @parm
    // Specifies an array of NdisMediumXxx values from which
    // MiniportInitialize selects one that its NIC supports or that the
    // driver supports as an interface to higher-level drivers.

    IN UINT                     MediumArraySize,            // @parm
    // Specifies the number of elements at MediumArray.

    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    IN NDIS_HANDLE              WrapperConfigurationContext // @parm
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.
    )
{
    DBG_FUNC("MiniportInitialize")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // Pointer to our newly allocated object.

    UINT                        Index;
    // Loop counter.

    NDIS_CALL_MANAGER_CHARACTERISTICS   McmCharacteristics;
    // Characteristics table passed to NdisMCmRegisterAddressFamily.

    CO_ADDRESS_FAMILY                   McmAddressFamily;
    // Address family passed to NdisMCmRegisterAddressFamily.

    DBG_ENTER(DbgInfo);
    DBG_PARAMS(DbgInfo,
              ("\n"
               "\t|OpenErrorStatus=0x%X\n"
               "\t|SelectedMediumIndex=0x%X\n"
               "\t|MediumArray=0x%X\n"
               "\t|MediumArraySize=0x%X\n"
               "\t|MiniportAdapterHandle=0x%X\n"
               "\t|WrapperConfigurationContext=0x%X\n",
               OpenErrorStatus,
               SelectedMediumIndex,
               MediumArray,
               MediumArraySize,
               MiniportAdapterHandle,
               WrapperConfigurationContext
              ));

    /*
    // Search the MediumArray for the NdisMediumCoWan media type.
    */
    for (Index = 0; Index < MediumArraySize; Index++)
    {
        if (MediumArray[Index] == NdisMediumCoWan)
        {
            break;
        }
    }

    /*
    // Make sure the protocol has requested the proper media type.
    */
    if (Index < MediumArraySize)
    {
        /*
        // Allocate memory for the adapter information structure.
        */
        Status = AdapterCreate(
                        &pAdapter,
                        MiniportAdapterHandle,
                        WrapperConfigurationContext
                        );

        if (Status == NDIS_STATUS_SUCCESS)
        {
            /*
            // Now it's time to initialize the hardware resources.
            */
            Status = AdapterInitialize(pAdapter);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                /*
                // Initialize the address family so NDIS know's what we support.
                */
                NdisZeroMemory(&McmAddressFamily, sizeof(McmAddressFamily));
                McmAddressFamily.MajorVersion   = NDIS_MAJOR_VERSION;
                McmAddressFamily.MinorVersion   = NDIS_MINOR_VERSION;
                McmAddressFamily.AddressFamily  = CO_ADDRESS_FAMILY_TAPI_PROXY;

                /*
                // Initialize the characteristics table, exporting the Miniport's entry
                // points to the Miniport wrapper.
                */
                NdisZeroMemory((PVOID)&McmCharacteristics, sizeof(McmCharacteristics));
                McmCharacteristics.MajorVersion                  = NDIS_MAJOR_VERSION;
                McmCharacteristics.MinorVersion                  = NDIS_MINOR_VERSION;
                McmCharacteristics.CmCreateVcHandler             = ProtocolCoCreateVc;
                McmCharacteristics.CmDeleteVcHandler             = ProtocolCoDeleteVc;
                McmCharacteristics.CmOpenAfHandler               = ProtocolCmOpenAf;
                McmCharacteristics.CmCloseAfHandler              = ProtocolCmCloseAf;
                McmCharacteristics.CmRegisterSapHandler          = ProtocolCmRegisterSap;
                McmCharacteristics.CmDeregisterSapHandler        = ProtocolCmDeregisterSap;
                McmCharacteristics.CmMakeCallHandler             = ProtocolCmMakeCall;
                McmCharacteristics.CmCloseCallHandler            = ProtocolCmCloseCall;
                McmCharacteristics.CmIncomingCallCompleteHandler = ProtocolCmIncomingCallComplete;
                McmCharacteristics.CmActivateVcCompleteHandler   = ProtocolCmActivateVcComplete;
                McmCharacteristics.CmDeactivateVcCompleteHandler = ProtocolCmDeactivateVcComplete;
                McmCharacteristics.CmModifyCallQoSHandler        = ProtocolCmModifyCallQoS;
                McmCharacteristics.CmRequestHandler              = ProtocolCoRequest;
                McmCharacteristics.CmRequestCompleteHandler      = ProtocolCoRequestComplete;

                DBG_NOTICE(pAdapter,("Calling NdisMCmRegisterAddressFamily\n"));
                Status = NdisMCmRegisterAddressFamily(
                                MiniportAdapterHandle,
                                &McmAddressFamily,
                                &McmCharacteristics,
                                sizeof(McmCharacteristics)
                                );

                if (Status != NDIS_STATUS_SUCCESS)
                {
                    DBG_ERROR(DbgInfo,("NdisMCmRegisterAddressFamily Status=0x%X\n",
                              Status));
                    /*
                    // Log error message and return.
                    */
                    NdisWriteErrorLogEntry(
                            MiniportAdapterHandle,
                            NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                            3,
                            Status,
                            __FILEID__,
                            __LINE__
                            );
                }
            }

            if (Status == NDIS_STATUS_SUCCESS)
            {
                /*
                // Save the selected media type.
                */
                *SelectedMediumIndex = Index;
            }
            else
            {
                /*
                // Something went wrong, so let's make sure everything is
                // cleaned up.
                */
                MiniportHalt(pAdapter);
            }
        }
    }
    else
    {
        DBG_ERROR(DbgInfo,("No NdisMediumCoWan found (Array=0x%X, ArraySize=%d)\n",
                  MediumArray, MediumArraySize));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                3,
                Index,
                __FILEID__,
                __LINE__
                );

        Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    /*
    // If all goes well, register a shutdown handler for this adapter.
    */
    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisMRegisterAdapterShutdownHandler(MiniportAdapterHandle,
                                            pAdapter, MiniportShutdown);
    }

    DBG_NOTICE(DbgInfo,("Status=0x%X\n",Status));

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc EXTERNAL INTERNAL Miniport Miniport_c MiniportHalt


@func

    <f MiniportHalt> request is used to halt the adapter such that it is
    no longer functioning.

@comm

    The Miniport should stop the adapter and deregister all of its resources
    before returning from this routine.

    It is not necessary for the Miniport to complete all outstanding
    requests and no other requests will be submitted to the Miniport
    until the operation is completed.

    Interrupts are enabled during the call to this routine.

*/

VOID MiniportHalt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportHalt")

    DBG_ENTER(DbgInfo);

    /*
    // Remove our shutdown handler from the system.
    */
    NdisMDeregisterAdapterShutdownHandler(pAdapter->MiniportAdapterHandle);

    /*
    // Free adapter instance.
    */
    AdapterDestroy(pAdapter);

    DBG_LEAVE(DbgInfo);
}


/* @doc EXTERNAL INTERNAL Miniport Miniport_c MiniportShutdown


@func

    <f MiniportShutdown> is an optional function that restores a NIC to its
    initial state when the system is shut down, whether by the user or because
    an unrecoverable system error occurred.

@comm

    Every NIC driver should have a <f MiniportShutdown> function.
    <f MiniportShutdown> does nothing more than restore the NIC to its initial
    state (before the miniport's DriverEntry function runs). However, this
    ensures that the NIC is in a known state and ready to be reinitialized
    when the machine is rebooted after a system shutdown occurs for any
    reason, including a crash dump.

    A NIC driver's MiniportInitialize function must call
    NdisMRegisterAdapterShutdownHandler to set up a <f MiniportShutdown>
    function. The driver's MiniportHalt function must make a reciprocal call
    to NdisMDeregisterAdapterShutdownHandler.

    If <f MiniportShutdown> is called due to a user-initiated system shutdown,
    it runs at IRQL PASSIVE_LEVEL in a system-thread context. If it is called
    due to an unrecoverable error, <f MiniportShutdown> runs at an arbitrary
    IRQL and in the context of whatever component raised the error. For
    example, <f MiniportShutdown> might be run at high DIRQL in the context of
    an ISR for a device essential to continued execution of the system.

    <f MiniportShutdown> should call no NdisXxx functions.

*/

VOID MiniportShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportShutdown")

    DBG_ENTER(pAdapter);

    /*
    // Reset the hardware and bial out - don't release any resources!
    */
    CardReset(pAdapter->pCard);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL Miniport Miniport_c MiniportReset


@func

    <f MiniportReset> request instructs the Miniport to issue a hardware
    reset to the network adapter.  The Miniport also resets its software
    state.

    The <F MiniportReset> request may also reset the parameters of the adapter.
    If a hardware reset of the adapter resets the current station address
    to a value other than what it is currently configured to, the Miniport
    driver automatically restores the current station address following the
    reset.  Any multicast or functional addressing masks reset by the
    hardware do not have to be reprogrammed by the Miniport.

    <f Note>: This is change from the NDIS 3.0 driver specification.  If the
    multicast or functional addressing information, the packet filter, the
    lookahead size, and so on, needs to be restored, the Miniport indicates
    this with setting the flag AddressingReset to TRUE.

    It is not necessary for the Miniport to complete all outstanding requests
    and no other requests will be submitted to the Miniport until the
    operation is completed.  Also, the Miniport does not have to signal
    the beginning and ending of the reset with NdisMIndicateStatus.

    <f Note>: These are different than the NDIS 3.0 driver specification.

    The Miniport must complete the original request, if the orginal
    call to <F MiniportReset> return NDIS_STATUS_PENDING, by calling
    NdisMResetComplete.

    If the underlying hardware does not provide a reset function under
    software control, then this request completes abnormally with
    NDIS_STATUS_NOT_RESETTABLE.  If the underlying hardware attempts a
    reset and finds recoverable errors, the request completes successfully
    with NDIS_STATUS_SOFT_ERRORS.  If the underlying hardware resets and,
    in the process, finds nonrecoverable errors, the request completes
    successfully with the status NDIS_STATUS_HARD_ERRORS.  If the
    underlying  hardware reset is accomplished without any errors,
    the request completes successfully with the status NDIS_STATUS_SUCCESS.

    Interrupts are in any state during this call.

@comm

    I have only seen MiniportReset called when the driver is not working
    properly.  If this gets called, your code is probably broken, so fix
    it.  Don't try to recover here unless there is some hardware/firmware
    problem you must work around.

@rdesc

    <f MiniportReset> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS MiniportReset(
    OUT PBOOLEAN                AddressingReset,            // @parm
    // The Miniport indicates if the wrapper needs to call
    // <f MiniportCoRequest> to restore the addressing information
    // to the current values by setting this value to TRUE.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportReset")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Result code returned by this function.

    DBG_ENTER(pAdapter);

    DBG_ERROR(pAdapter,("##### !!! THIS SHOULD NEVER BE CALLED !!! #####\n"));

    /*
    // If anything goes wrong here, it's very likely an unrecoverable
    // hardware failure.  So we'll just shut this thing down for good.
    */
    Result = NDIS_STATUS_HARD_ERRORS;
    *AddressingReset = TRUE;

    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\miniport.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Miniport Miniport_h

@module Miniport.h |

    This module defines the interface to the <t MINIPORT_DRIVER_OBJECT_TYPE>.

@comm

    This module defines the software structures and values used to support
    the NDIS WAN/TAPI Minport.  It's a good place to look when your trying
    to figure out how the driver structures are related to each other.

    Include this file at the top of each module in the Miniport.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Miniport_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 1.0 Miniport Call Manager Overview |

    The NDIS wrapper provides services to both the Transport drivers, and the
    Miniport drivers.  The NDIS wrapper provides an abstraction layer between
    the two which allows them to interoperate with each other as long as they
    both adhere to the NDIS interfaces defined for Transports and Miniports.

    The NDIS wrapper also provides a set of services which isolates NDIS
    drivers from the specifics of the Operating System (Windows 98 vs
    Windows 2000), as well as the platform specifics (Processor, Bus,
    Interrupts).  The advantage of using the NDIS wrapper is that the Miniport
    can be easily ported to other Windows environments with little or no
    re-coding.

    An MCM consists of two, cooperating, drivers contained the the same binary.
    The DATA portion of the driver handles packet transmits and receives.  The
    CONNECTION portion handles call setup and tear down.

    The DATA side of the Miniport is very similar to an NDIS LAN style Miniport,
    except that some of the NDIS interfaces have been modified to support the
    WAN media type.  The primary difference from the Miniport's point of view is
    that we use a different set of NDIS requests, and more importantly the line
    can go up and down.

    The CONNECTION portion of the Miniport adds significant complexity to the
    Miniport.  The MCM Miniport must provide a pseudo Telephony Service Provider
    Interface (TSPI) which lives under NDPROXY.  The NDPROXY TSPI loads under
    TAPI as the 'real' service provider, and then routes all TAPI events to the
    MCM.

    NDPROXY can have multiple MCM's living under its TSPI interface.  And since
    Remote Access Services (RAS) usess the TAPI interface to place and accept
    all calls, any Dial Up Networking (DUN) requests associated with the MCM,
    will end up at the MCM via CONDIS requests from NDPROXY.

@topic 1.1 Reference Documents |

    The most reliable source of information is provided on the Microsoft
    Developer Network CD.  These documents will provide you with the complete
    NDIS interface requirements and architectural overviews.  In addition,
    there are many addendums and developer notes in the Microsoft Knowledge
    Base.  The most important references are:

@iex
    Product Documentation\DDKs\Windows 2000 DDK\Network Drivers\
        Design Guide\Part 2: Miniport NIC Drivers
            Chapters 1-7 discuss all the NDIS interface routines.
            Chapters 8 provide details on WAN/TAPI extensions.
            Section 8.7 discuss CoNdis extensions to support TAPI.

    Product Documentation\SDKs\Platform SDK\Networking and Directory Services\
        Telephone Application Programming Interfaces\TAPI Service Providers
        This section defines the Windows TSPI implementation.

@normal

@end
*/

/* @doc EXTERNAL INTERNAL


@topic 2.0 Installing and Configuring the Sample Driver |

    The sample driver implements a fully functional ISDN style CO-NDIS WAN
    driver.  It layers in under NDPROXY which translates the RAS/WAN/TAPI
    interfaces into a more generic CO-NDIS interface.  The driver supports
    multiple adapter instances, so you can install it more than once to
    create multiple adapters.

    Each adapter can emulate multiple ISDN B channels.  By default, each
    adapter is setup with 2 channels, but you can modify the "IsdnBChannels"
    and "WanEndPoints" registry entries to creates as many as you'd like.
    Alternatively, you can just modify these values in the INF file before
    you install the adapter.  Either way works fine.

@topic 2.1 Installation |

    The driver can be installed as a non-plug-n-play device using the Windows
    device manager interface as follows:

    1) Right-click the "My Computer" icon on the desktop and select the
    Properties item from the context menu.

    2) Select the "Hardware" tab on the "System Properties" dialog.

    3) Click the "Hardware Wizard" button, then click "Next" when the welcome
    dialog appears.

    4) Click "Next" again to "Add/Troubleshoot a device".

    5) Select "Add a new device" from the list presented, then click "Next".

    6) Select "No, I want to select the hardware from a list" radio button,
    then click "Next".

    7) Select "Network adapters" from the list presented, then click "Next".

    8) Click the "Have Disk" button, then browse to the location of the driver
    and INF file, then click OK."

    9) You should now see "TriplePoint COISDN Adapter" on the screen.  Click
    "Next" and then "Next" again to install the driver.  If Windows warns you
    about an unsigned driver, just click yes to install.  If you don't have
    permission to install such drivers, you'll have to exit and logon with the
    proper permissions.  You will have to disable the driver signing check on
    your system if it doesn't allow unsigned drivers to be installed.

    10) Now click "Finish" to load the driver.

@topic 2.2 Dial-In Setup |

    You must install and enable Dial-Up networking before you can accept an
    incoming call with the driver.  This can be done using the following
    procedure:

    1) Right-click the "My Network Places" icon on the desktop and select the
    Properties item from the context menu.

    2) Double-click the "Make New Connction" icon from the list.

    3) Select the "Accept incoming connections" radio button, then click "Next".

    4) Click the check box next to the "TriplePoint COISDN Adapter"(s) to allow
    incoming calls on the adapter.  All channels on that adapter are enabled
    for incoming calls.  Once you select the adapter(s), click "Next".

    5) Select "Do not allow virtual private connections", then click "Next".

    6) Select the users you want to have dial-in access, then click "Next".

    7) Select the protocols and services you want to support, then click "Next".

    8) Now click "Finish" to enable the dial-in connections.

@topic 2.3 Dial-Out Setup |

    The sample driver implements the following simple dialing method.

    A) "0" can be used to connect to any available more on any available
    adapter.  This is generally good enough for most testing.

    B) "N" specifies that the connection should be directed to a specific
    adapter instance.  Where N must match the ObjectID assigned to a particular
    adapter when the <f MiniportInitialize> routine is called.  Numbers are
    assigned from 1-M based on the adapter initialization order.  The call is
    then directed to any available listening channel on the selected adapter.

    You must create a dial-out connection before you can place call with the
    driver.  This can be done using the following procedure:

    1) Right-click the "My Network Places" icon on the desktop and select the
    Properties item from the context menu.

    2) Double-click the "Make New Connction" icon from the list.

    3) Select the "Dial-up to private network" radio button, then click "Next".

    4) Click the check box next to one or more "TriplePoint COISDN Adapter"
    ISDN Channels to allow outgoing calls on the channel.  Make sure you leave
    enough channels available to answer the call when it comes in...  You have
    no way to know which driver BChannel is actually going to be used, but that
    doesn't generally matter anyway. Once you select the channel(s), click "Next".

    5) Walk your way through the rest of the Wizard dialogs to setup the
    connection as you like.

    6) When you're done click "Finish" to enable the dial-out connection.

    Now you can double-click the dial-out connection to see how it all works.

    I suggest you also turn some debug flags in the driver to see how the call
    setup and teardown winds its way through the driver.  This can be quite
    useful before starting to modify the driver for your hardware.

@end
*/


/* @doc EXTERNAL INTERNAL


@topic 4.0 Functional Overview |

    This section describes the major functional objects defined by the driver.

    This driver is designed as a generic ISDN device driver.  It does not
    support any specific hardware, but does have the basic elements of an ISDN
    device.  The network interface is emulated by placing calls between one or
    more of the driver's BChannels.  This is accomplished using a set of
    software events that simulate typical network events (i.e MakeCall,
    AnnounceCall, Tranmit, Receive, Hangup, etc).

    By using this design approach you can compile and test the driver without
    having to purchase specific hardware.  The downside is that you cannot
    easily test the data flow because the networking infrastructure does not
    support terminating the endpoint on the local host.  However, the data flow
    is not usually very difficult to test once the call manager interfaces are
    reliable.  RAS does support connecting to the local host, but the NDIS
    protocols won't normally route traffic through the interface because they
    just loop back before it reaches the driver.  The PPP negotiation packets
    are routed through the interface, so this does give some data flow excersise,
    but nothing worth writing home about.  The NDISWAN tester has been modified
    to allow it to run over locally terminated connections, so this is the only
    real way to test the data pump.

    Because this driver does not support real hardware, all the hardware
    resource code has been ifdef'd out.  This code has been used in working
    drivers, so I'm pretty sure it will work if you add the corresponding
    compiler options.  However, it has not been verified and may require some
    modifications for your environment.

    There are several other good samples included on the DDK that can be useful
    for using other NDIS features.  This sample focuses primarily on the
    CO-NDIS call manager interfaces.

@end
*/

#ifndef _MPDMAIN_H
#define _MPDMAIN_H

#define MINIPORT_DRIVER_OBJECT_TYPE     ((ULONG)'D')+\
                                        ((ULONG)'R'<<8)+\
                                        ((ULONG)'V'<<16)+\
                                        ((ULONG)'R'<<24)

#define INTERRUPT_OBJECT_TYPE           ((ULONG)'I')+\
                                        ((ULONG)'N'<<8)+\
                                        ((ULONG)'T'<<16)+\
                                        ((ULONG)'R'<<24)

#define RECEIVE_OBJECT_TYPE             ((ULONG)'R')+\
                                        ((ULONG)'E'<<8)+\
                                        ((ULONG)'C'<<16)+\
                                        ((ULONG)'V'<<24)

#define TRANSMIT_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'R'<<8)+\
                                        ((ULONG)'A'<<16)+\
                                        ((ULONG)'N'<<24)

#define REQUEST_OBJECT_TYPE             ((ULONG)'R')+\
                                        ((ULONG)'Q'<<8)+\
                                        ((ULONG)'S'<<16)+\
                                        ((ULONG)'T'<<24)

/*
// NDIS_MINIPORT_DRIVER and BINARY_COMPATIBLE must be defined before the
// NDIS include files.  Normally, it is defined on the command line by
// setting the C_DEFINES variable in the SOURCES build file.
*/
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include "vTarget.h"
#include "TpiDebug.h"

#if !defined(IRP_MN_KERNEL_CALL) && !defined(PCI_SUBCLASS_DASP_OTHER)
// This should be defined in the NTDDK 5.0 ndis.h, but it's not.
// So I copied this here from ntddk.h to use with NdisQueryBufferSafe().
typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;
#endif

// Figure out which DDK we're building with.
#if defined(NDIS_LCODE)
#  if defined(NDIS_DOS)
#    define USING_WFW_DDK
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#  elif defined(OID_WAN_GET_INFO)
#    define USING_WIN98_DDK
#  elif defined(NDIS_WIN)
#    define USING_WIN95_DDK
#  else
#    error "BUILDING WITH UNKNOWN 9X DDK"
#  endif
#elif defined(NDIS_NT)
#  if defined(OID_GEN_MACHINE_NAME)
#    define USING_NT51_DDK
#  elif defined(OID_GEN_SUPPORTED_GUIDS)
#    define USING_NT50_DDK
#  elif defined(OID_GEN_MEDIA_CONNECT_STATUS)
#    define USING_NT40_DDK
#  elif defined(OID_WAN_GET_INFO)
#    define USING_NT351_DDK
#  else
#    define USING_NT31_DDK
#  endif
#else
#  error "BUILDING WITH UNKNOWN DDK"
#endif

// Figure out which DDK we should be building with.
#if defined(NDIS51) || defined(NDIS51_MINIPORT)
#  if defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x05
#    define NDIS_MINOR_VERSION          0x01
#  else
#    error "YOU MUST BUILD WITH THE NT 5.1 DDK"
#  endif
#elif defined(NDIS50) || defined(NDIS50_MINIPORT)
#  if defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x05
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 5.0 DDK"
#  endif
#elif defined(NDIS40) || defined(NDIS40_MINIPORT)
#  if defined(USING_NT40_DDK) || defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x04
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 4.0 or 5.0 DDK"
#  endif
#elif defined(NDIS_MINIPORT_DRIVER)
#  if defined(USING_NT351_DDK) || defined(USING_NT40_DDK) || defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 3.51, 4.0, or 5.0 DDK"
#  endif
#elif !defined(NDIS_MAJOR_VERSION) || !defined(NDIS_MINOR_VERSION)
//   Must be FULL MAC
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#endif

// Gotta nest NDIS_STRING_CONST or compiler/preprocessor won't be able to
// handle L##DEFINED_STRING.
#define INIT_STRING_CONST(name)     NDIS_STRING_CONST(name)
#define DECLARE_WIDE_STRING(name)   L##name
#define INIT_WIDE_STRING(name)      DECLARE_WIDE_STRING(name)

typedef struct MINIPORT_ADAPTER_OBJECT  *PMINIPORT_ADAPTER_OBJECT;
typedef struct BCHANNEL_OBJECT          *PBCHANNEL_OBJECT;
typedef struct DCHANNEL_OBJECT          *PDCHANNEL_OBJECT;
typedef struct CARD_OBJECT              *PCARD_OBJECT;
typedef struct PORT_OBJECT              *PPORT_OBJECT;

/*
// The <t NDIS_MAC_LINE_UP> structure is confusing, so I redefine the
// field name to be what makes sense.
*/
#define MiniportLinkContext                 NdisLinkHandle

#if defined(_VXD_) && !defined(NDIS_LCODE)
#  define NDIS_LCODE code_seg("_LTEXT", "LCODE")
#  define NDIS_LDATA data_seg("_LDATA", "LCODE")
#endif

/*
// The link speeds we support.
*/
#define _64KBPS                     64000
#define _56KBPS                     56000

#define MICROSECONDS                (1)
#define MILLISECONDS                (1000*MICROSECONDS)
#define SECONDS                     (1000*MILLISECONDS)

#define TSPI_ADDRESS_ID             0

/*
// Include everything here so the driver modules can just include this
// file and get all they need.
*/
#include "Keywords.h"
#include "Card.h"
#include "Adapter.h"
#include "BChannel.h"
#include "CallMgr.h"
#include "DChannel.h"
#include "Port.h"
#include "TpiParam.h"
#include "TpiMem.h"

/***************************************************************************
// These routines are defined in Miniport.c
*/

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath
    );

NDIS_STATUS MiniportInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN PNDIS_MEDIUM             MediumArray,
    IN UINT                     MediumArraySize,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              WrapperConfigurationContext
    );

void MiniportHalt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

NDIS_STATUS MiniportReset(
    OUT PBOOLEAN                AddressingReset,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

/***************************************************************************
// These routines are defined in interrup.c
*/
BOOLEAN MiniportCheckForHang(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportDisableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportEnableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportHandleInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportISR(
    OUT PBOOLEAN                InterruptRecognized,
    OUT PBOOLEAN                QueueMiniportHandleInterrupt,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportTimer(
    IN PVOID                    SystemSpecific1,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PVOID                    SystemSpecific2,
    IN PVOID                    SystemSpecific3
    );

/***************************************************************************
// These routines are defined in receive.c
*/
void ReceivePacketHandler(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PNDIS_BUFFER             pNdisBuffer,
    IN ULONG                    BytesReceived
    );

VOID MiniportReturnPacket(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PNDIS_PACKET             pNdisPacket
    );

/***************************************************************************
// These routines are defined in request.c
*/
NDIS_STATUS MiniportCoRequest(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN OUT PNDIS_REQUEST        NdisRequest
    );

/***************************************************************************
// These routines are defined in transmit.c
*/
VOID MiniportCoSendPackets(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PPNDIS_PACKET            PacketArray,
    IN UINT                     NumberOfPackets
    );

void TransmitCompleteHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void FlushSendPackets(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PBCHANNEL_OBJECT         pBChannel
    );

#endif // _MPDMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\port.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Port Port_h

@module Port.h |

    This module defines the interface to the <t PORT_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Port_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 4.5 Port Overview |

    This section describes the interfaces defined in <f Port\.h>.

    The sample does not use this interface, but it is anticipated that it would
    be used to maintain information associated with each physical ISDN line.
    Assuming that each card may have multiple ISDN lines plugged into it.
    
*/

#ifndef _PORT_H
#define _PORT_H

#define PORT_OBJECT_TYPE        ((ULONG)'P')+\
                                ((ULONG)'O'<<8)+\
                                ((ULONG)'R'<<16)+\
                                ((ULONG)'T'<<24)

#define MAX_PORTS               10
// The most I've ever seen is 4 - If you have more than 10, the code will
// have to change to handle more than a single digit "PortX" parameter.

/* @doc INTERNAL Port Port_h PORT_OBJECT


@struct PORT_OBJECT |

    This structure contains the data associated with an ISDN port.  Here,
    a port is defined as a single BRI, PRI, T-1, or E-1 physical interface.

*/

typedef struct PORT_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'PORT'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PCARD_OBJECT                pCard;                      // @field
    // Pointer to the <t CARD_OBJECT> owning this port.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this BChannel is open, otherwise set FALSE.

    ULONG                       NumChannels;                // @field
    // Number of communications channels configured on this port.

    ULONG                       PortIndex;                  // @field
    // Port Index (0 .. MAX_PORTS-1).

    ULONG                       SwitchType;                 // @field
    // ISDN switch type.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} PORT_OBJECT, *PPORT_OBJECT;

#define GET_ADAPTER_FROM_PORT(pPort)            (pPort->pCard->pAdapter)


/*


    Function prototypes.

*/

NDIS_STATUS PortCreate(
    OUT PPORT_OBJECT *          ppPort,
    IN PCARD_OBJECT             pCard
    );

void PortInitialize(
    PPORT_OBJECT                pPort
    );

void PortDestroy(
    PPORT_OBJECT                pPort
    );

#endif // _PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\port.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Port Port_c

@module Port.c |

    This module implements the interface to the <t PORT_OBJECT>.

@comm

    The sample does not use this interface, but it is anticipated that it would
    be used to maintain information associated with each physical ISDN line.
    Assuming that each card may have multiple ISDN lines plugged into it.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Port_c

@end

*/

#define  __FILEID__             PORT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                g_PortInstanceCounter = 0;
// Keeps track of how many <t PORT_OBJECT>s are created.


/* @doc EXTERNAL INTERNAL Port Port_c g_PortParameters


@topic 5.5 Port Parameters |

    This section describes the registry parameters read into the
    <t PORT_OBJECT>.

@globalv PARAM_TABLE | g_PortParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t PORT_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t PORT_OBJECT>
    you will need to modify <f PortReadParameters> and add the parameter
    definitions to the <f g_PortParameters> table.

@flag <f IsdnSwitchType> (OPTIONAL) |
    
    This DWORD parameter allows you to identify the switch type a particular
    Port is connected to.  The ISDN installation wizard should set this up
    during installation.<nl>

    <tab><f Default Value:><tab><tab>0x0001<nl>
    <tab><f Valid Range N:><tab><tab>0x0001 <lt>= N <lt>= 0x8000 (bit field)<nl>

@flag <f IsdnNumBChannels> (OPTIONAL) |
    
    This DWORD parameter allows you to control how many <t BCHANNEL_OBJECT>s
    will be allocated for the card.  This should include all the channels on
    all the ports of this adapter.<nl>

    <tab><f Default Value:><tab><tab>2<nl>
    <tab><f Valid Range N:><tab><tab>2 <lt>= N <lt>= 32<nl>

*/

DBG_STATIC PARAM_TABLE          g_PortParameters[] =
{
    PARAM_ENTRY(PORT_OBJECT,
                SwitchType, PARAM_SwitchType,
                FALSE, NdisParameterInteger, 0,
                0x0001, 0x0001, 0x8000),

    PARAM_ENTRY(PORT_OBJECT,
                NumChannels, PARAM_NumBChannels,
                FALSE, NdisParameterInteger, 0,
                2, 2, 32),

    /* The last entry must be an empty string! */
    { { 0 } }
};


DBG_STATIC NDIS_STRING          g_PortPrefix
                                = INIT_STRING_CONST(PARAM_PORT_PREFIX);


/* @doc INTERNAL Port Port_c PortReadParameters


@func

    <f PortReadParameters> reads the Port parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f PortCreate>.

    <f Note>:
    If you add any registry based data members to <t PORT_OBJECT>
    you will need to modify <f PortReadParameters> and add the parameter
    definitions to the <f g_PortParameters> table.

@rdesc

    <f PortReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS PortReadParameters(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pPort,
                    g_PortParameters
                    );

    DBG_NOTICE(pAdapter,("PortPrefixLen=%d:%d:%ls\n",
                g_PortPrefix.Length, g_PortPrefix.MaximumLength, g_PortPrefix.Buffer));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pPort->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pPort->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Port Port_c PortCreateObjects


@func

    <f PortCreateObjects> calls the create routines for all the objects
    contained in <t PORT_OBJECT>.  This should only be called
    by <f PortCreate>.

    <f Note>:
    If you add any new objects to <t PORT_OBJECT> you will need
    to modify <f PortCreateObjects> and <f PortDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f PortCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS PortCreateObjects(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortCreate


@func

    <f PortCreate> allocates memory for a <t PORT_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppPort> will be set to point to the newly created
    <t PORT_OBJECT>.  Otherwise, <p ppPort> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f PortDestroy> must be called to
    release the <t PORT_OBJECT> created by this function.

@rdesc

    <f PortCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS PortCreate(
    OUT PPORT_OBJECT *          ppPort,                     // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t PORT_OBJECT>.

    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("PortCreate")

    PPORT_OBJECT                pPort;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppPort = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pPort, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pPort->ObjectType = PORT_OBJECT_TYPE;
        pPort->ObjectID = ++g_PortInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pPort->pCard = pCard;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = PortReadParameters(pPort);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = PortCreateObjects(pPort);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppPort = pPort;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            PortDestroy(pPort);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortDestroyObjects


@func

    <f PortDestroyObjects> calls the destroy routines for all the objects
    contained in <t PORT_OBJECT>.  This should only be called by
    <f PortDestroy>.

    <f Note>:
    If you add any new objects to <t PPORT_OBJECT> you will need to
    modify <f PortCreateObjects> and <f PortDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void PortDestroyObjects(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> instance.
    )
{
    DBG_FUNC("PortDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Port Port_c PortDestroy


@func

    <f PortDestroy> frees the memory for this <t PORT_OBJECT>.
    All memory allocated by <f PortCreate> will be released back to the
    OS.

*/

void PortDestroy(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pPort)
    {
        ASSERT(pPort->ObjectType == PORT_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_PORT(pPort);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        PortDestroyObjects(pPort);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pPort->ObjectType = 0;
        FREE_OBJECT(pPort);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Port Port_c PortOpen


@func

    <f PortOpen> makes the Port connection ready to transmit and
    receive data.

@rdesc

    <f PortOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS PortOpen(
    IN PPORT_OBJECT             pPort,                      // @parm
    // A pointer to the <t PORT_OBJECT> associated with this request.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> to be associated with this
    // Port.
    )
{
    DBG_FUNC("PortOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel);
    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    if (!pPort->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening Port #%d\n",
                   pPort->ObjectID));

        // TODO - Add code here

        pPort->IsOpen = TRUE;
    }
    else
    {
        DBG_ERROR(pAdapter,("Port #%d already opened\n",
                  pPort->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortClose


@func

    <f PortClose> closes the given B-channel.

*/

void PortClose(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> associated with this request.
    )
{
    DBG_FUNC("PortClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    if (pPort->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing Port #%d\n",
                   pPort->ObjectID));

        // TODO - Add code here

        pPort->IsOpen = FALSE;
    }
    else
    {
        DBG_ERROR(pAdapter,("Port #%d already closed\n",
                  pPort->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\receive.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Receive Receive_c

@module Receive.c |

    This module implements the Miniport packet receive routines.  Basically,
    the asynchronous receive processing routine.  This module is very
    dependent on the hardware/firmware interface and should be looked at
    whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Receive_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.4 Receiving Packets |

    A connection-oriented miniport or MCM calls NdisMCoIndicateReceivePacket to
    indicate one or more received packets up to a connection-oriented client or
    call manager. If the miniport or MCM handles interrupts, it calls
    NdisMCoIndicateReceivePacket from its MiniportHandleInterrupt function.

@ex Receiving packets through an MCM |

    Miniport                          NDIS                         NdisWan
    |----------------------------------|----------------------------------|
    |  NdisMCoIndicateReceivePacket    |                                  |
    |---------------------------------|                                  |
    |                                  |  ProtocolCoReceivePacket         |
    |                                  |---------------------------------|
    |  NdisMCoIndicateReceivePacket    |                                  |
    |---------------------------------|                                  |
    |              .                   |  ProtocolCoReceivePacket         |
    |              .                   |---------------------------------|
    |              .                   |            .                     |
    |                                  |            .                     |
    |  NdisMCoReceiveComplete          |            .                     |
    |---------------------------------|                                  |
    |                                  |  ProtocolReceiveComplete         |
    |                                  |---------------------------------|
    |                                  |                                  |
    |                                  |  NdisReturnPackets               |
    |                                  |---------------------------------|
    |  MiniportReturnPacket            |            .                     |
    |---------------------------------|            .                     |
    |  MiniportReturnPacket            |            .                     |
    |---------------------------------|                                  |
    |              .                   |                                  |
    |              .                   |                                  |
    |              .                   |                                  |
    |----------------------------------|----------------------------------|

@normal

    In the call to NdisMCoIndicateReceivePacket, the miniport or MCM passes a
    pointer to an array of packet descriptor pointers. The miniport or MCM also
    passes an NdisVcHandle that identifies the VC on which the packets were
    received. Before calling NdisMCoIndicateReceivePacket, the miniport or MCM
    must set up a packet array (see Part 2, Section 4.6). 

    The call to NdisMCoIndicateReceivePacket causes NDIS to call the
    ProtocolCoReceivePacket function of the protocol driver (connection-oriented
    client or call manager) that shares the indicated VC with the miniport. The
    ProtocolCoReceivePacket function processes the receive indication.

    After some miniport-determined number of calls to
    NdisMCoIndicateReceivePacket, the miniport must call NdisMCoReceiveComplete
    to indicate the completion of the previous receive indications made with one
    or more calls to NdisMCoIndicateReceivePacket. The call to
    NdisMCoReceiveComplete causes NDIS to call the ProtocolReceiveComplete
    function of the connection-oriented client or call manager.

    If a protocol does not return the miniport-allocated resources for a receive
    indication promptly enough, the miniport or MCM can call
    NdisMCoIndicateStatus with NDIS_STATUS_RESOURCES to alert the offending
    protocol that the miniport or MCM is running low on available packet or
    buffer descriptors (or even on NIC receive buffer space) for subsequent
    receive indications.

@end
*/

#define  __FILEID__             RECEIVE_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Receive Receive_c ReceivePacketHandler


@func

    <f ReceivePacketHandler> is called from <f MiniportTimer> to handle
    a packet receive event.  We enter here with interrupts enabled on
    the adapter and the processor, but the NDIS Wrapper holds a spin lock
    since we are executing on an NDIS timer thread.

@comm

    We loop in here until all the available incoming packets have been passed
    up to the protocol stack.  As we find each good packet, it is passed up
    to the protocol stack using <f NdisMWanIndicateReceive>.  When NDIS
    returns control from this call, we resubmit the packet to the adapter
    so it can be used to receive another incoming packet.  The link flag
    <p NeedReceiveCompleteIndication> is set TRUE if any packets are received
    on a particular link.  This is used later, before returning from the
    async event handler, to notify NDIS of any ReceiveCompleteIndications.

*/

void ReceivePacketHandler(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    IN PNDIS_BUFFER             pNdisBuffer,                // @parm
    // A pointer to the NDIS buffer we use to indicate the receive.

    IN ULONG                    BytesReceived               // @parm
    // Number of bytes received.
    )
{
    DBG_FUNC("ReceivePacketHandler")

    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    PUCHAR                      ReceiveBuffer;
    // Pointer to first byte received.

    ULONG                       BufferLength;
    // Length of first buffer.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    PNDIS_PACKET                pNdisPacket;
    // A pointer to the NDIS packet we use to indicate the receive.


    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);
    ASSERT(pNdisBuffer);

    DBG_ENTER(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (++(pAdapter->NestedDataHandler) > 1)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d > 1\n",
                  pAdapter->NestedDataHandler));
    }

    NdisQueryBufferSafe(pNdisBuffer, &ReceiveBuffer, &BufferLength,
                        NormalPagePriority);
    ASSERT(ReceiveBuffer && BufferLength);

    /*
    // Is there someone up there who cares?
    */
    if (pBChannel->NdisVcHandle == NULL)
    {
        DBG_WARNING(pAdapter, ("Packet recvd on disconnected channel #%d\n",pBChannel->ObjectID));

        FREE_MEMORY(ReceiveBuffer, BufferLength);
        NdisFreeBuffer(pNdisBuffer);
    }
    else
    {
        pAdapter->TotalRxBytes += BytesReceived;
        pAdapter->TotalRxPackets++;

        /*
        // We have to accept the frame if possible, I just want to know
        // if somebody has lied to us...
        */
        if (BytesReceived > pBChannel->WanLinkInfo.MaxRecvFrameSize)
        {
            DBG_NOTICE(pAdapter,("Packet size=%d > %d\n",
                       BytesReceived, pBChannel->WanLinkInfo.MaxRecvFrameSize));
        }

        DBG_RX(pAdapter, pBChannel->ObjectID, BufferLength, ReceiveBuffer);

        /*
        // Indiciate the packet up to the protocol stack.
        */
        NdisAllocatePacket(&Status, &pNdisPacket, 
                           pAdapter->pCard->PacketPoolHandle);
        if (Status == NDIS_STATUS_SUCCESS)
        {
            NdisChainBufferAtFront(pNdisPacket, pNdisBuffer);
            NDIS_SET_PACKET_STATUS(pNdisPacket, NDIS_STATUS_SUCCESS);
            NDIS_SET_PACKET_HEADER_SIZE(pNdisPacket, 0);
            NdisMCoIndicateReceivePacket(
                    pBChannel->NdisVcHandle,
                    &pNdisPacket,   // PacketArray
                    1               // NumberOfPackets
                    );
            pBChannel->NeedReceiveCompleteIndication = TRUE;
        }
        else
        {
            DBG_ERROR(pAdapter,("NdisAllocatePacket Error=0x%X\n",Status));
        }
    }

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (--(pAdapter->NestedDataHandler) < 0)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d < 0\n",
                  pAdapter->NestedDataHandler));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL Receive Receive_c MiniportReturnPacket


@func

    <f MiniportReturnPacket> is a required function in drivers that
    indicate receives with NdisMIndicateReceivePacket.

@comm

    A miniport driver of a busmaster DMA NIC that supports multipacket
    receives and a miniport driver that supplies media-specific information,
    such as packet priorities, with its receive indications must have a
    MiniportReturnPacket function. An NDIS intermediate driver that binds
    itself to such a miniport driver also must have a MiniportReturnPacket
    function.

    Any packet with associated NDIS_PACKET_OOB_DATA in which the Status is set
    to NDIS_STATUS_PENDING on return from NdisMIndicateReceivePacket will be
    returned to MiniportReturnPacket. When all bound protocols have called
    NdisReturnPackets as many times as necessary to release their references
    to the originally indicated packet array, NDIS returns pended packets from
    the array to the MiniportReturnPacket function of the driver that
    originally allocated the packet array.

    Usually, MiniportReturnPacket prepares such a returned packet to be used
    in a subsequent receive indication. Although MiniportReturnPacket could
    return the buffer descriptors chained to the packet to buffer pool and the
    packet descriptor itself to packet pool, it is far more efficient to reuse
    returned descriptors.

    MiniportReturnPacket must call NdisUnchainBufferAtXxx as many times as
    necessary to save the pointers to all chained buffer descriptors before it
    calls NdisReinitializePacket. Otherwise, MiniportReturnPacket cannot
    recover the buffer descriptors the driver originally chained to the packet
    for the indication.

    MiniportReturnPacket also can call NdisZeroMemory with the pointer
    returned by NDIS_OOB_DATA_FROM_PACKET to prepare the packet's associated
    out-of-band block for reuse.

    If a particular buffer descriptor was shortened to match the size of an
    indicated range of data, MiniportReturnPacket should call
    NdisAdjustBufferLength with that buffer descriptor to restore its mapping
    of the NIC's receive buffer range.

    By default, MiniportReturnPacket runs at IRQL DISPATCH_LEVEL.

@rdesc

    <f MiniportReturnPacket> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

@xref

    <f NdisAdjustBufferLength>, <f NdisAllocateBuffer>, <f NdisAllocatePacket>,
    <f NdisMIndicateReceivePacket>, <t NDIS_OOB_DATA_FROM_PACKET>,
    <t NDIS_PACKET>, <t NDIS_PACKET_OOB_DATA>, <f NdisReinitializePacket>,
    <f NdisReturnPackets>, <f NdisUnchainBufferAtBack>,
    <f NdisUnchainBufferAtFront>, <f NdisZeroMemory>

*/

VOID MiniportReturnPacket(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PNDIS_PACKET             pNdisPacket                 // @parm
    // A pointer to a <t NDIS_PACKET> that was passed up thru the NDIS
    // wrapper by an earlier call to <f NdisMIndicateReceivePacket>.
    )
{
    DBG_FUNC("MiniportReturnPacket")

    PNDIS_BUFFER                pNdisBuffer;

    ULONG                       ByteCount = 0;
    
    PUCHAR                      pMemory = NULL;

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(pNdisPacket);

    DBG_ENTER(pAdapter);

    NdisUnchainBufferAtFront(pNdisPacket, &pNdisBuffer);
    ASSERT(pNdisBuffer);

    NdisQueryBufferSafe(pNdisBuffer, &pMemory, &ByteCount, NormalPagePriority);
    ASSERT(pMemory && ByteCount);

    FREE_MEMORY(pMemory, ByteCount);

    NdisFreeBuffer(pNdisBuffer);

    NdisFreePacket(pNdisPacket);

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\request.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Request Request_c

@module Request.c |

    This module implements the NDIS request routines for the Miniport.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Request_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.2 NDIS Request Processing |

    A connection-oriented client or call manager calls NdisCoRequest to query or
    set information maintained by another protocol driver on a binding or by the
    underlying miniport.

    Before it calls NdisCoRequest, a client or call manager allocates a buffer
    for its request and initializes an NDIS_REQUEST structure. This structure
    specifies the type of request (query or set), identifies the information
    (OID) being queried or set, and points to buffers used for passing OID data.

    If the connection-oriented client or call manager passes a valid
    NdisAfHandle (see Section 1.2.1), NDIS calls the <f ProtocolCoRequest>
    function of each protocol driver on the binding.

    If the connection-oriented client or call manager passes a NULL address
    family handle, NDIS calls the <f MiniportCoRequest> function of the 
    underlying miniport or MCM.

    The caller of NdisCoRequest or NdisMCmRequest can narrow the scope of the
    request by specifying a VC handle that identifies a VC, or a party handle
    that identifies a party on a multipoint VC. Passing a NULL NdisVcHandle
    makes such a request global in nature, whether the request is directed to
    the client, call manager, miniport, or MCM.

    <f ProtocolCoRequest> or <f MiniportCoRequest> can complete synchronously,
    or these functions can complete asynchronously with NdisCoRequestComplete.
    The call to NdisCoRequestComplete causes NDIS to call the
    <f ProtocolCoRequestComplete> function of the driver that called 
    NdisCoRequest.

@comm

    Since only one NDIS request can be outstanding at a time, this mechanism
    should not be used for requests that need to be pended indefintely.  For
    such long term requests, you should use a system event mechanism such as 
    NdisSetEvent to trigger the request.

@end
*/

#define  __FILEID__             REQUEST_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif

/*
// The following is a list of all the possible NDIS QuereyInformation requests
// that might be directed to the miniport.
// Comment out any that are not supported by this driver.
*/
DBG_STATIC const NDIS_OID       g_SupportedOidArray[] =
{
    OID_GEN_CO_SUPPORTED_LIST,
    OID_GEN_CO_HARDWARE_STATUS,
    OID_GEN_CO_MEDIA_SUPPORTED,
    OID_GEN_CO_MEDIA_IN_USE,
    OID_GEN_CO_LINK_SPEED,
    OID_GEN_CO_VENDOR_ID,
    OID_GEN_CO_VENDOR_DESCRIPTION,
    OID_GEN_CO_DRIVER_VERSION,
    OID_GEN_CO_PROTOCOL_OPTIONS,
    OID_GEN_CO_MAC_OPTIONS,
    OID_GEN_CO_MEDIA_CONNECT_STATUS,
    OID_GEN_CO_VENDOR_DRIVER_VERSION,
    OID_GEN_CO_SUPPORTED_GUIDS,

    OID_CO_TAPI_CM_CAPS,
    OID_CO_TAPI_LINE_CAPS,
    OID_CO_TAPI_ADDRESS_CAPS,

    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,

    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_MEDIUM_SUBTYPE,

    OID_WAN_CO_GET_INFO,
    OID_WAN_CO_SET_LINK_INFO,
    OID_WAN_CO_GET_LINK_INFO,

    OID_WAN_LINE_COUNT,

    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,

    0
};

DBG_STATIC const NDIS_GUID      g_SupportedGuidArray[] =
{
    0
};

#if DBG

/*
// Make sure the following list is in the same order as the list above!
*/
DBG_STATIC char *               g_SupportedOidNames[] =
{
    "OID_GEN_CO_SUPPORTED_LIST",
    "OID_GEN_CO_HARDWARE_STATUS",
    "OID_GEN_CO_MEDIA_SUPPORTED",
    "OID_GEN_CO_MEDIA_IN_USE",
    "OID_GEN_CO_LINK_SPEED",
    "OID_GEN_CO_VENDOR_ID",
    "OID_GEN_CO_VENDOR_DESCRIPTION",
    "OID_GEN_CO_DRIVER_VERSION",
    "OID_GEN_CO_PROTOCOL_OPTIONS",
    "OID_GEN_CO_MAC_OPTIONS",
    "OID_GEN_CO_MEDIA_CONNECT_STATUS",
    "OID_GEN_CO_VENDOR_DRIVER_VERSION",
    "OID_GEN_CO_SUPPORTED_GUIDS",

    "OID_CO_TAPI_CM_CAPS",
    "OID_CO_TAPI_LINE_CAPS",
    "OID_CO_TAPI_ADDRESS_CAPS",

    "OID_802_3_PERMANENT_ADDRESS",
    "OID_802_3_CURRENT_ADDRESS",

    "OID_WAN_PERMANENT_ADDRESS",
    "OID_WAN_CURRENT_ADDRESS",
    "OID_WAN_MEDIUM_SUBTYPE",

    "OID_WAN_CO_GET_INFO",
    "OID_WAN_CO_SET_LINK_INFO",
    "OID_WAN_CO_GET_LINK_INFO",

    "OID_WAN_LINE_COUNT",

    "OID_PNP_CAPABILITIES",
    "OID_PNP_SET_POWER",
    "OID_PNP_QUERY_POWER",

    "OID_UNKNOWN"
};

#define NUM_OID_ENTRIES (sizeof(g_SupportedOidArray) / sizeof(g_SupportedOidArray[0]))

/*
// This debug routine will lookup the printable name for the selected OID.
*/
DBG_STATIC char * DbgGetOidString(
    IN NDIS_OID                 Oid
    )
{
    UINT i;

    for (i = 0; i < NUM_OID_ENTRIES-1; i++)
    {
        if (g_SupportedOidArray[i] == Oid)
        {
            break;
        }
    }
    return(g_SupportedOidNames[i]);
}

#endif // DBG

DBG_STATIC UCHAR        g_PermanentWanAddress[6]            // @globalv
// Returned from an OID_WAN_PERMANENT_ADDRESS MiniportCoQueryInformation
// request. The WAN wrapper wants the miniport to return a unique address 
// for this adapter.  This is used as an ethernet address presented to the 
// protocols.  The least significant bit of the first byte must not be a 1, 
// or it could be interpreted as an ethernet multicast address.  If the 
// vendor has an assigned ethernet vendor code (the first 3 bytes), they 
// should be used to assure that the address does not conflict with another 
// vendor's address.  The last digit is replaced during the call with the 
// adapter instance number.  Usually defined as VER_VENDOR_ID.  
// See also <f g_Vendor3ByteID>.
                        = VER_VENDOR_ID;

DBG_STATIC UCHAR        g_Vendor3ByteID[4]                  // @globalv
// Returned from an OID_GEN_CO_VENDOR_ID MiniportCoQueryInformation request.
// Again, the vendor's assigned ethernet vendor code should be used if possible.
// Usually defined as VER_VENDOR_ID.  See also <f g_PermanentWanAddress>.
                        = VER_VENDOR_ID;

DBG_STATIC NDIS_STRING  g_VendorDescriptionString           // @globalv
// Returned from an OID_GEN_CO_VENDOR_DESCRIPTION MiniportCoQueryInformation 
// request.  This is an arbitrary string which may be used by upper layers to 
// present a user friendly description of the adapter.
// Usually defined as VER_PRODUCT_NAME_STR.
                        = INIT_STRING_CONST(VER_PRODUCT_NAME_STR);

/* @doc INTERNAL Request Request_c MiniportCoQueryInformation


@func

    <f MiniportCoQueryInformation> allows the inspection of the Miniport's
    capabilities and current status.

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMQueryInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesWritten, and BytesNeeded until the request
    completes.

    No other requests will be submitted to the Miniport until this request 
    has been completed.

    <f Note>: that the wrapper will intercept all queries of the following OIDs:
        OID_GEN_CURRENT_PACKET_FILTER,
        OID_GEN_PROTOCOL_OPTIONS,
        OID_802_5_CURRENT_FUNCTIONAL,
        OID_802_3_MULTICAST_LIST,
        OID_FDDI_LONG_MULTICAST_LIST,
        OID_FDDI_SHORT_MULTICAST_LIST.

    <f Note>: Interrupts will be in any state when called.

@rdesc

    <f MiniportCoQueryInformation> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS MiniportCoQueryInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_OID                 Oid,                        // @parm
    // The OID.  (See section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs.)

    IN PVOID                    InformationBuffer,          // @parm
    // The buffer that will receive the information. (See section 7.4 of the
    // NDIS 3.0 specification for a description of the length required for
    // each OID.)

    IN ULONG                    InformationBufferLength,    // @parm
    // The length in bytes of InformationBuffer.

    OUT PULONG                  BytesWritten,               // @parm
    // Returns the number of bytes written into InformationBuffer.

    OUT PULONG                  BytesNeeded                 // @parm
    // Returns the number of additional bytes needed to satisfy the OID.
    )
{
    DBG_FUNC("MiniportCoQueryInformation")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the status result returned by this function.

    PVOID                       SourceBuffer;
    // Pointer to driver data to be copied back to caller's InformationBuffer

    ULONG                       SourceBufferLength;
    // Number of bytes to be copied from driver.

    ULONG                       GenericULong = 0;
    // Most return values are long integers, so this is used to hold the
    // return value of a constant or computed result.

    UCHAR                       VendorId[4];
    // Used to store vendor ID string.

    NDIS_PNP_CAPABILITIES       PnpCapabilities;
    // Used to return our PNP capabilities.

    NDIS_CO_LINK_SPEED          LinkSpeed;
    // Used to return our link speed.

    UINT                        InfoOffset;
    // Offset from the start of the buffer to the various information
    // fields we fill in and return to the caller.

    UINT                        InfoLength;
    // Length of the information being copied.

    DBG_STATIC WCHAR            LineSwitchName[]  = 
        INIT_WIDE_STRING(VER_DEVICE_STR) DECLARE_WIDE_STRING(" Switch");
    // TODO: Replace with unicode string to identify the ISDN switch.

    DBG_STATIC WCHAR            LineAddressName[] = 
        INIT_WIDE_STRING(VER_DEVICE_STR) DECLARE_WIDE_STRING(" Address 00");
    // TODO: The SAMPLE_DRIVER only handles 1 address per line.  You may want 
    // to modify the driver to present multiple addresses per line.

    DBG_ENTER(pAdapter);
    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X\n",
               Oid, DbgGetOidString(Oid),
               InformationBufferLength,
               InformationBuffer
              ));

    /*
    // Initialize these once, since this is the majority of cases.
    */
    SourceBuffer = &GenericULong;
    SourceBufferLength = sizeof(ULONG);
    *BytesWritten = 0;

    /*
    // Determine which OID is being requested and do the right thing.
    // Refer to section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs and their return values.
    */
    switch (Oid)
    {
    case OID_GEN_CO_SUPPORTED_LIST:
        /*
        // NDIS wants to know which OID's to pass down to us.
        // So we report back these new IOCTL's in addition to any NDIS OID's.
        */
        SourceBuffer =  (PVOID)g_SupportedOidArray;
        SourceBufferLength = sizeof(g_SupportedOidArray);
        break;

    case OID_GEN_CO_SUPPORTED_GUIDS:
        SourceBuffer =  (PVOID)g_SupportedGuidArray;
        SourceBufferLength = sizeof(g_SupportedGuidArray);
        break;

    case OID_GEN_CO_HARDWARE_STATUS:
        GenericULong = NdisHardwareStatusReady;
        break;

    case OID_GEN_CO_MEDIA_SUPPORTED:
        GenericULong = NdisMediumCoWan;
        break;

    case OID_GEN_CO_MEDIA_IN_USE:
        GenericULong = NdisMediumCoWan;
        break;

    case OID_GEN_CO_LINK_SPEED:
        LinkSpeed.Outbound = _64KBPS / 100;
        LinkSpeed.Inbound  = _64KBPS / 100;
        SourceBuffer = &LinkSpeed;
        SourceBufferLength = sizeof(LinkSpeed);
        break;

    case OID_GEN_CO_VENDOR_ID:
        NdisMoveMemory((PVOID)VendorId, (PVOID)g_PermanentWanAddress, 3);
        VendorId[3] = 0x0;
        SourceBuffer = &VendorId[0];
        SourceBufferLength = sizeof(VendorId);
        break;

    case OID_GEN_CO_VENDOR_DESCRIPTION:
        SourceBuffer = (PUCHAR) g_VendorDescriptionString.Buffer;
        SourceBufferLength = g_VendorDescriptionString.MaximumLength;
        break;

    case OID_GEN_CO_DRIVER_VERSION:
        GenericULong = (NDIS_MAJOR_VERSION << 8) + NDIS_MINOR_VERSION;
        break;

    case OID_GEN_CO_MAC_OPTIONS:
        GenericULong = 0;   // Reserved - leave it set to zero.
        break;

    case OID_GEN_CO_MEDIA_CONNECT_STATUS:
        GenericULong = NdisMediaStateConnected;
        break;

    case OID_GEN_CO_VENDOR_DRIVER_VERSION:
        GenericULong = (VER_FILE_MAJOR_NUM << 8) + VER_FILE_MINOR_NUM;
        break;

    case OID_CO_TAPI_CM_CAPS:
        {
            PCO_TAPI_CM_CAPS        pCallManagerCaps = InformationBuffer;
            
            SourceBufferLength = sizeof(*pCallManagerCaps);
            if (InformationBufferLength >= SourceBufferLength)
            {
                pCallManagerCaps->ulCoTapiVersion = CO_TAPI_VERSION;
                pCallManagerCaps->ulNumLines = pAdapter->NumBChannels;
                pCallManagerCaps->ulFlags = 0;

                // No need to copy, it's filled in already.
                SourceBuffer = InformationBuffer;
            }
            else
            {
                DBG_ERROR(pAdapter,("OID_CO_TAPI_CM_CAPS: Invalid size=%d expected=%d\n",
                          InformationBufferLength, SourceBufferLength));
            }
        }
        break;

    case OID_CO_TAPI_LINE_CAPS:
        {
            PCO_TAPI_LINE_CAPS      pLineCaps = InformationBuffer;
            
            SourceBufferLength = sizeof(*pLineCaps);
            if (InformationBufferLength >= SourceBufferLength)
            {
                NdisZeroMemory(pLineCaps, SourceBufferLength);
            
                pLineCaps->ulFlags = 0;

                pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, 
                                                    pLineCaps->ulLineID);

                // We're gonna write at least this much, maybe more.
                *BytesWritten = SourceBufferLength;

                DBG_NOTICE(pAdapter,("OID_CO_TAPI_LINE_CAPS: Line=0x%X\n",
                           pLineCaps->ulLineID));

                pLineCaps->LineDevCaps.ulNeededSize =
                pLineCaps->LineDevCaps.ulUsedSize = sizeof(pLineCaps->LineDevCaps);
            
                /*
                // The driver numbers lines sequentially from 1, so this will 
                // always be the same number.
                */
                pLineCaps->LineDevCaps.ulPermanentLineID = pBChannel->ObjectID;
            
                /*
                // All the strings are ASCII format rather than UNICODE.
                */
                pLineCaps->LineDevCaps.ulStringFormat = STRINGFORMAT_UNICODE;
            
                /*
                // Report the capabilities of this device.
                */
                pLineCaps->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID;
                pLineCaps->LineDevCaps.ulNumAddresses = 1;
                pLineCaps->LineDevCaps.ulBearerModes  = pBChannel->BearerModesCaps;
                pLineCaps->LineDevCaps.ulMaxRate      = pBChannel->LinkSpeed;
                pLineCaps->LineDevCaps.ulMediaModes   = pBChannel->MediaModesCaps;
            
                /*
                // Each line on the PRI only supports a single call.
                */
                pLineCaps->LineDevCaps.ulDevCapFlags = LINEDEVCAPFLAGS_CLOSEDROP;
                pLineCaps->LineDevCaps.ulMaxNumActiveCalls = 1;
                pLineCaps->LineDevCaps.ulAnswerMode = LINEANSWERMODE_DROP;
                pLineCaps->LineDevCaps.ulRingModes  = 1;
                pLineCaps->LineDevCaps.ulLineStates = pBChannel->DevStatesCaps;
                pLineCaps->LineDevCaps.ulLineFeatures = LINEFEATURE_MAKECALL;

                /*
                // RASTAPI requires TSPI provider name to be placed in the
                // ProviderInfo field at the end of this structure.
                */
                InfoOffset = sizeof(pLineCaps->LineDevCaps);
                InfoLength = g_VendorDescriptionString.MaximumLength;
                pLineCaps->LineDevCaps.ulNeededSize += InfoLength;
                SourceBufferLength += InfoLength;
                if (pLineCaps->LineDevCaps.ulNeededSize <= 
                    pLineCaps->LineDevCaps.ulTotalSize)
                {
                    pLineCaps->LineDevCaps.ulProviderInfoSize   = InfoLength;
                    pLineCaps->LineDevCaps.ulProviderInfoOffset = InfoOffset;
                    NdisMoveMemory((PUCHAR) &pLineCaps->LineDevCaps + InfoOffset,
                            g_VendorDescriptionString.Buffer,
                            InfoLength
                            );
                    pLineCaps->LineDevCaps.ulUsedSize += InfoLength;
                    InfoOffset += InfoLength;
                }
            
                /*
                // SwitchName is not yet displayed by the Dialup Networking App,
                // but we'll return something reasonable just in case.
                */
                InfoLength = sizeof(LineSwitchName);
                pLineCaps->LineDevCaps.ulNeededSize += InfoLength;
                SourceBufferLength += InfoLength;
                if (pLineCaps->LineDevCaps.ulNeededSize <= 
                    pLineCaps->LineDevCaps.ulTotalSize)
                {
                    pLineCaps->LineDevCaps.ulSwitchInfoSize   = InfoLength;
                    pLineCaps->LineDevCaps.ulSwitchInfoOffset = InfoOffset;
                    NdisMoveMemory((PUCHAR) &pLineCaps->LineDevCaps + InfoOffset,
                            LineSwitchName,
                            InfoLength
                            );
                    pLineCaps->LineDevCaps.ulUsedSize += InfoLength;
                    InfoOffset += InfoLength;
                }
                else
                {
                    DBG_PARAMS(pAdapter,
                               ("STRUCTURETOOSMALL %d<%d\n",
                               pLineCaps->LineDevCaps.ulTotalSize,
                               pLineCaps->LineDevCaps.ulNeededSize));
                }

                // No need to copy, it's filled in already.
                SourceBuffer = InformationBuffer;
            }
            else
            {
                DBG_ERROR(pAdapter,("OID_CO_TAPI_LINE_CAPS: Invalid size=%d expected=%d\n",
                          InformationBufferLength, SourceBufferLength));
            }
        }
        break;

    case OID_CO_TAPI_ADDRESS_CAPS:
        {
            PCO_TAPI_ADDRESS_CAPS   pAddressCaps = InformationBuffer;

            SourceBufferLength = sizeof(*pAddressCaps);
            if (InformationBufferLength >= SourceBufferLength)
            {
                NdisZeroMemory(pAddressCaps, SourceBufferLength);
            
                pAddressCaps->ulFlags = 0;

                pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, 
                                                    pAddressCaps->ulLineID);

                // We're gonna write at least this much, maybe more.
                *BytesWritten = SourceBufferLength;

                DBG_NOTICE(pAdapter,("OID_CO_TAPI_ADDRESS_CAPS: Line=0x%X Addr=0x%X\n",
                           pAddressCaps->ulLineID, pAddressCaps->ulAddressID));

                pAddressCaps->LineAddressCaps.ulNeededSize =
                pAddressCaps->LineAddressCaps.ulUsedSize = 
                                        sizeof(pAddressCaps->LineAddressCaps);
            
                pAddressCaps->LineAddressCaps.ulLineDeviceID = 
                                        pBChannel->ObjectID;
            
                /*
                // Return the various address capabilites for the adapter.
                */
                pAddressCaps->LineAddressCaps.ulAddressSharing = 
                                        LINEADDRESSSHARING_PRIVATE;
                pAddressCaps->LineAddressCaps.ulAddressStates = 
                                        pBChannel->AddressStatesCaps;
                pAddressCaps->LineAddressCaps.ulCallStates = 
                                        pBChannel->CallStatesCaps;
                pAddressCaps->LineAddressCaps.ulDialToneModes = 
                                        LINEDIALTONEMODE_NORMAL;
                pAddressCaps->LineAddressCaps.ulDisconnectModes =
                                        LINEDISCONNECTMODE_NORMAL |
                                        LINEDISCONNECTMODE_UNKNOWN |
                                        LINEDISCONNECTMODE_BUSY |
                                        LINEDISCONNECTMODE_NOANSWER;
                /*
                // This driver does not support conference calls, transfers, 
                // or holds.
                */
                pAddressCaps->LineAddressCaps.ulMaxNumActiveCalls = 1;
                pAddressCaps->LineAddressCaps.ulAddrCapFlags = 
                                        LINEADDRCAPFLAGS_DIALED;
                pAddressCaps->LineAddressCaps.ulCallFeatures = 
                                        LINECALLFEATURE_ACCEPT |
                                        LINECALLFEATURE_ANSWER |
                                        LINECALLFEATURE_DROP;
                pAddressCaps->LineAddressCaps.ulAddressFeatures = LINEADDRFEATURE_MAKECALL;
            
                /*
                // AddressName is displayed by the Dialup Networking App.
                */
                InfoOffset = sizeof(pAddressCaps->LineAddressCaps);
                InfoLength = sizeof(LineAddressName);
                pAddressCaps->LineAddressCaps.ulNeededSize += InfoLength;
                SourceBufferLength += InfoLength;
                if (pAddressCaps->LineAddressCaps.ulNeededSize <= 
                    pAddressCaps->LineAddressCaps.ulTotalSize)
                {
                    pAddressCaps->LineAddressCaps.ulAddressSize = InfoLength;
                    pAddressCaps->LineAddressCaps.ulAddressOffset = InfoOffset;
                    NdisMoveMemory(
                            (PUCHAR) &pAddressCaps->LineAddressCaps + InfoOffset,
                            LineAddressName,
                            InfoLength);
                    pAddressCaps->LineAddressCaps.ulUsedSize += InfoLength;
                    InfoOffset += InfoLength;
                }
                else
                {
                    DBG_PARAMS(pAdapter,
                               ("STRUCTURETOOSMALL %d<%d\n",
                               pAddressCaps->LineAddressCaps.ulTotalSize,
                               pAddressCaps->LineAddressCaps.ulNeededSize));
                }

                // No need to copy, it's filled in already.
                SourceBuffer = InformationBuffer;
            }
            else
            {
                DBG_ERROR(pAdapter,("OID_CO_TAPI_ADDRESS_CAPS: Invalid size=%d expected=%d\n",
                          InformationBufferLength, SourceBufferLength));
            }
        }
        break;

    case OID_802_3_PERMANENT_ADDRESS:
    case OID_802_3_CURRENT_ADDRESS:
    case OID_WAN_PERMANENT_ADDRESS:
    case OID_WAN_CURRENT_ADDRESS:
        g_PermanentWanAddress[5] = (UCHAR) ((pAdapter->ObjectID & 0xFF) + '0');
        SourceBuffer = g_PermanentWanAddress;
        SourceBufferLength = sizeof(g_PermanentWanAddress);
        break;

    case OID_WAN_MEDIUM_SUBTYPE:
        GenericULong = NdisWanMediumIsdn;
        break;

    case OID_WAN_CO_GET_INFO:
        SourceBuffer = &pAdapter->WanInfo;
        SourceBufferLength = sizeof(NDIS_WAN_CO_INFO);
        break;

    case OID_WAN_CO_GET_LINK_INFO:
        {
            /*
            // Make sure what I just said is true.
            */
            if (!IS_VALID_BCHANNEL(pAdapter, pBChannel))
            {
                SourceBufferLength = 0;
                Result = NDIS_STATUS_INVALID_DATA;
                break;
            }

            DBG_PARAMS(pAdapter,
                        ("Returning:\n"
                        "MaxSendFrameSize    = %08lX\n"
                        "MaxRecvFrameSize    = %08lX\n"
                        "SendFramingBits     = %08lX\n"
                        "RecvFramingBits     = %08lX\n"
                        "SendCompressionBits = %08lX\n"
                        "RecvCompressionBits = %08lX\n"
                        "SendACCM            = %08lX\n"
                        "RecvACCM            = %08lX\n",
                        pBChannel->WanLinkInfo.MaxSendFrameSize   ,
                        pBChannel->WanLinkInfo.MaxRecvFrameSize   ,
                        pBChannel->WanLinkInfo.SendFramingBits    ,
                        pBChannel->WanLinkInfo.RecvFramingBits    ,
                        pBChannel->WanLinkInfo.SendCompressionBits,
                        pBChannel->WanLinkInfo.RecvCompressionBits,
                        pBChannel->WanLinkInfo.SendACCM           ,
                        pBChannel->WanLinkInfo.RecvACCM         ));

            SourceBuffer = &(pBChannel->WanLinkInfo);
            SourceBufferLength = sizeof(NDIS_WAN_CO_GET_LINK_INFO);
        }
        break;

    case OID_WAN_LINE_COUNT:
        GenericULong = pAdapter->NumBChannels;
        break;

    case OID_PNP_CAPABILITIES:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        PnpCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp =
                                               NdisDeviceStateUnspecified;
        PnpCapabilities.WakeUpCapabilities.MinPatternWakeUp =
                                               NdisDeviceStateUnspecified;
        PnpCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp =
                                                NdisDeviceStateUnspecified;
        SourceBuffer = &PnpCapabilities;
        SourceBufferLength = sizeof(PnpCapabilities);
        break;

    case OID_PNP_QUERY_POWER:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        SourceBufferLength = 0;
        break;

    default:
        /*
        // Unknown OID
        */
        Result = NDIS_STATUS_INVALID_OID;
        SourceBufferLength = 0;
        DBG_WARNING(pAdapter,("UNSUPPORTED Oid=0x%08x\n", Oid));
        break;
    }

    /*
    // Now we copy the data into the caller's buffer if there's enough room,
    // otherwise, we report the error and tell em how much we need.
    */
    if (SourceBufferLength > InformationBufferLength)
    {
        *BytesNeeded = SourceBufferLength;
        Result = NDIS_STATUS_INVALID_LENGTH;
    }
    else if (SourceBufferLength)
    {
        // Don't copy if it's already there.
        if (InformationBuffer != SourceBuffer)
        {
            NdisMoveMemory(InformationBuffer,
                           SourceBuffer,
                           SourceBufferLength
                          );
        }
        *BytesNeeded = *BytesWritten = SourceBufferLength;
    }
    else
    {
        *BytesNeeded = *BytesWritten = 0;
    }
    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Written=%d\n",
               Result, *BytesNeeded, *BytesWritten));

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Request Request_c MiniportCoSetInformation


@func

    <f MiniportCoSetInformation> allows for control of the Miniport by
    changing information maintained by the Miniport.

    Any of the settable NDIS Global Oids may be used. (see section 7.4 of
    the NDIS 3.0 specification for a complete description of the NDIS Oids.)

    If the Miniport does not complete the call immediately (by returning
    NDIS_STATUS_PENDING), it must call NdisMSetInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesRead, and BytesNeeded until the request completes.

    <f Note>: Interrupts are in any state during the call, and no other
    requests will be submitted to the Miniport until this request is
    completed.

@rdesc

    <f MiniportCoSetInformation> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS MiniportCoSetInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN NDIS_OID                 Oid,                        // @parm
    // The OID.  (See section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs.)

    IN PVOID                    InformationBuffer,          // @parm
    // Points to a buffer containing the OID-specific data used by 
    // <f MiniportCoSetInformation> for the set.
    // See section 7.4 of the
    // NDIS 3.0 specification for a description of the length required for
    // each OID.)

    IN ULONG                    InformationBufferLength,    // @parm
    // Specifies the number of bytes at <p InformationBuffer>.

    OUT PULONG                  BytesRead,                  // @parm
    // Points to a variable that <f MiniportCoSetInformation> sets to the
    // number of bytes it read from the buffer at InformationBuffer. 

    OUT PULONG                  BytesNeeded                 // @parm
    // Points to a variable that <f MiniportCoSetInformation> sets to the
    // number of additional bytes it needs to satisfy the request if
    // <p InformationBufferLength> is less than Oid requires. 
        
    )
{
    DBG_FUNC("MiniportCoSetInformation")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the status result returned by this function.

    DBG_ENTER(pAdapter);
    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X\n",
               Oid, DbgGetOidString(Oid),
               InformationBufferLength,
               InformationBuffer
              ));

    /*
    // Assume no extra bytes are needed.
    */
    ASSERT(BytesRead && BytesNeeded);
    *BytesRead = 0;
    *BytesNeeded = 0;

    /*
    // Determine which OID is being requested and do the right thing.
    */
    switch (Oid)
    {
    case OID_GEN_CURRENT_LOOKAHEAD:
        /*
        // WAN drivers always indicate the entire packet regardless of the
        // lookahead size.  So this request should be politely ignored.
        */
        DBG_NOTICE(pAdapter,("OID_GEN_CURRENT_LOOKAHEAD: set=%d expected=%d\n",
                    *(PULONG) InformationBuffer, CARD_MAX_LOOKAHEAD));
        ASSERT(InformationBufferLength == sizeof(ULONG));
        *BytesNeeded = *BytesRead = sizeof(ULONG);
        break;

    case OID_WAN_CO_SET_LINK_INFO:

        if (InformationBufferLength == sizeof(NDIS_WAN_CO_SET_LINK_INFO))
        {
            /*
            // Make sure what I just said is true.
            */
            if (!IS_VALID_BCHANNEL(pAdapter, pBChannel))
            {
                Result = NDIS_STATUS_INVALID_DATA;
                break;
            }

            ASSERT(!(pBChannel->WanLinkInfo.SendFramingBits & 
                     ~pAdapter->WanInfo.FramingBits));
            ASSERT(!(pBChannel->WanLinkInfo.RecvFramingBits & 
                     ~pAdapter->WanInfo.FramingBits));

            /*
            // Copy the data into our WanLinkInfo sturcture.
            */
            NdisMoveMemory(&(pBChannel->WanLinkInfo),
                           InformationBuffer,
                           InformationBufferLength
                          );
            *BytesRead = sizeof(NDIS_WAN_CO_SET_LINK_INFO);

            if (pBChannel->WanLinkInfo.MaxSendFrameSize != 
                    pAdapter->WanInfo.MaxFrameSize ||
                pBChannel->WanLinkInfo.MaxRecvFrameSize != 
                    pAdapter->WanInfo.MaxFrameSize)
            {
                DBG_NOTICE(pAdapter,("Line=%d - "
                            "SendFrameSize=%08lX - "
                            "RecvFrameSize=%08lX\n",
                            pBChannel->ObjectID,
                            pBChannel->WanLinkInfo.MaxSendFrameSize,
                            pBChannel->WanLinkInfo.MaxRecvFrameSize));
            }

            DBG_PARAMS(pAdapter,
                       ("\n                   setting    expected\n"
                        "MaxSendFrameSize = %08lX=?=%08lX\n"
                        "MaxRecvFrameSize = %08lX=?=%08lX\n"
                        "SendFramingBits  = %08lX=?=%08lX\n"
                        "RecvFramingBits  = %08lX=?=%08lX\n"
                        "SendACCM         = %08lX=?=%08lX\n"
                        "RecvACCM         = %08lX=?=%08lX\n",
                        pBChannel->WanLinkInfo.MaxSendFrameSize, 
                            pAdapter->WanInfo.MaxFrameSize,
                        pBChannel->WanLinkInfo.MaxRecvFrameSize, 
                            pAdapter->WanInfo.MaxFrameSize,
                        pBChannel->WanLinkInfo.SendFramingBits, 
                            pAdapter->WanInfo.FramingBits,
                        pBChannel->WanLinkInfo.RecvFramingBits, 
                            pAdapter->WanInfo.FramingBits,
                        pBChannel->WanLinkInfo.SendCompressionBits, 
                            0,
                        pBChannel->WanLinkInfo.RecvCompressionBits, 
                            0,
                        pBChannel->WanLinkInfo.SendACCM, 
                            pAdapter->WanInfo.DesiredACCM,
                        pBChannel->WanLinkInfo.RecvACCM, 
                            pAdapter->WanInfo.DesiredACCM));
        }
        else
        {
            DBG_WARNING(pAdapter, ("OID_WAN_CO_SET_LINK_INFO: Invalid size:%d expected:%d\n",
                        InformationBufferLength, 
                        sizeof(NDIS_WAN_CO_SET_LINK_INFO)));
            Result = NDIS_STATUS_INVALID_LENGTH;
        }
        *BytesNeeded = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
        break;

    case OID_PNP_SET_POWER:
        // TODO: The sample just returns success for all PM events even though we
        // don't really do anything with them.
        break;

    case OID_GEN_CO_PROTOCOL_OPTIONS:
        // TODO: If an intermediate driver slips in below us, we may want to
        // handle this OID.  Although, it's probably safe to ignore it...
        break;

    default:
        /*
        // Unknown OID
        */
        Result = NDIS_STATUS_INVALID_OID;
        DBG_WARNING(pAdapter,("UNSUPPORTED Oid=0x%08x\n", Oid));
        break;
    }
    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Read=%d\n",
               Result, *BytesNeeded, *BytesRead));

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc EXTERNAL INTERNAL Request Request_c MiniportCoRequest


@func

    <f MiniportCoRequest> is a required function for connection-oriented
    miniports.  <f MiniportCoRequest> handles a protocol-initiated request 
    to get or set information from the miniport.

@comm

    NDIS calls the <f MiniportCoRequest> function either on its own behalf
    or on behalf of a bound protocol driver that called <f NdisCoRequest>.
    Miniport drivers should examine the request supplied at <f NdisRequest>
    and take the action requested.  For more information about the required
    and optional OID_GEN_CO_XXX that connection-oriented miniport drivers 
    must handle, see Part 2. 

    <f MiniportCoRequest> must be written such that it can be run from IRQL
    DISPATCH_LEVEL.

@rdesc

    <f MiniportCoRequest> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS MiniportCoRequest(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    // Specifies the handle to a miniport-allocated context area in which
    // the miniport maintains state information about this instance of the
    // adapter. The miniport provided this handle to NDIS by calling
    // <f NdisMSetAttributes> or <f NdisMSetAttributesEx> from its 
    // <f MiniportInitialize> function. 

    IN PBCHANNEL_OBJECT         pBChannel OPTIONAL,         // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    // Specifies the handle to a miniport-allocated context area in which the
    // miniport maintains its per-VC state.  The miniport supplied this handle
    // to NDIS from its <f MiniportCoCreateVc> function. 

    IN OUT PNDIS_REQUEST        NdisRequest                 // @parm
    // Points to a <t NDIS_REQUEST> structure that contains both the buffer 
    // and the request packet for the miniport to handle.  Depending on the 
    // request, the miniport returns requested information in the structure 
    // provided. 
    )
{
    DBG_FUNC("MiniportCoRequest")

    NDIS_STATUS                 Result;
    // Holds the status result returned by this function.
        
    // ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    ASSERT(NdisRequest);

    switch (NdisRequest->RequestType)
    {
    case NdisRequestQueryStatistics:

    case NdisRequestQueryInformation:
        Result = MiniportCoQueryInformation(
                        pAdapter,
                        pBChannel,
                        NdisRequest->DATA.QUERY_INFORMATION.Oid,
                        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                        &NdisRequest->DATA.QUERY_INFORMATION.BytesWritten,
                        &NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded
                        );
        break;

    case NdisRequestSetInformation:
        Result = MiniportCoSetInformation(
                        pAdapter,
                        pBChannel,
                        NdisRequest->DATA.SET_INFORMATION.Oid,
                        NdisRequest->DATA.SET_INFORMATION.InformationBuffer,
                        NdisRequest->DATA.SET_INFORMATION.InformationBufferLength,
                        &NdisRequest->DATA.SET_INFORMATION.BytesRead,
                        &NdisRequest->DATA.SET_INFORMATION.BytesNeeded
                        );
        break;

    default:
        DBG_ERROR(pAdapter,("UNKNOWN RequestType=%d\n",
                  NdisRequest->RequestType));
        Result = NDIS_STATUS_NOT_SUPPORTED;
        break;
    }
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\tpidebug.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiDebug TpiDebug_c

@module TpiDebug.c |

    This module, along with <f TpiDebug\.h>, implements code and macros to
    support NDIS driver debugging.  This file must be linked with the driver
    to support debug dumps and logging.

@comm

    The code and macros defined by these modules is only generated during
    development debugging when the C pre-processor macro flag (DBG == 1).
    If (DBG == 0) no code will be generated, and all debug strings will be
    removed from the image.

    This is a device independent module which can be re-used, without
    change, by any driver or application.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiDebug_c

@end

*/

#if defined(_EXE_) || defined(_DLL_)
typedef char CHAR, *PCHAR;
typedef unsigned char  UCHAR,  *PUCHAR;
typedef unsigned short USHORT, *PUSHORT;
typedef unsigned long  ULONG,  *PULONG;
typedef unsigned int  *PUINT;

# include <windows.h>
#elif defined(_VXD_)
# include <basedef.h>
# include <vmm.h>
# pragma VxD_LOCKED_CODE_SEG
# pragma VxD_LOCKED_DATA_SEG
#else
# include <windef.h>
#endif

#include "TpiDebug.h"

#if DBG

/*
// Sometimes the debug output seriously impacts the run-time performance,
// so it is necessary to turn off the debug output.  In this case, you can
// capture some debug trace information into the DbgLogBuffer, and it can
// be examined later without impacting the run-time performance.
*/
#define DBG_LOG_ENTRIES     100     // Maximum number of FIFO log entries.
#define DBG_LOG_SIZE        128     // Maximum number of bytes per entry.

#if defined(_VXD_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'V','X','D',0 } };
#elif defined(_EXE_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'E','X','E',0 } };
#elif defined(_DLL_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'D','L','L',0 } };
#elif defined(_SYS_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'S','Y','S',0 } };
#else
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'T','P','I',0 } };
#endif

PDBG_SETTINGS   DbgInfo = &DbgSettings;
UINT            DbgLogIndex = 0;
UCHAR           DbgLogBuffer[DBG_LOG_ENTRIES][DBG_LOG_SIZE] = { { 0 } };


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrintData


@func

    <f DbgPrintData> outputs data to the debug display formatted in HEX and
    ASCII for easy viewing.

    <f Note>: This routine is used for debug output only.
    It is not compiled into the retail version.

@ex <tab> |
    DbgPrintData(ReceiveBuffer, 14, 0);                     // Packet header
    DbgPrintData(ReceiveBuffer+14, BytesReceived-14, 14);   // Packet data

0000: ff ff ff ff ff ff 0a 22 23 01 02 03 00 10        ......."#.....
000E: 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 40  ABCDEFGHIJKMNOPQ

*/

VOID DbgPrintData(
    IN PUCHAR                   Data,                       // @parm
    // Pointer to first byte of data to be displayed.

    IN UINT                     NumBytes,                   // @parm
    // Number of bytes to be displayed.

    IN ULONG                    Offset                      // @parm
    // Value to be added to the offset counter displayed at the start of each
    // line.  This is useful for viewing data whose base offset is relative to
    // another, non-zero starting address.

    )
{
    UINT                        LineStart;
    UINT                        LineIndex;

    /*
    // Display the caller's buffer with up to 16 bytes per line.
    */
    for (LineStart = 0; LineStart < NumBytes; LineStart += 16)
    {
        /*
        // Display the starting offset of the line.
        */
        DbgPrint("%04lx: ", LineStart + Offset);

        /*
        // Display a line of HEX byte values.
        */
        for (LineIndex = LineStart; LineIndex < (LineStart+16); LineIndex++)
        {
            if (LineIndex < NumBytes)
            {
                DbgPrint("%02x ",(UINT)((UCHAR)*(Data+LineIndex)));
            }
            else
            {
                DbgPrint("   ");
            }
        }
        DbgPrint("  ");     // A little white space between HEX and ASCII.

        /*
        // Display the corresponding ASCII byte values if they are printable.
        // (i.e. 0x20 <= N <= 0x7F).
        */
        for (LineIndex = LineStart; LineIndex < (LineStart+16); LineIndex++)
        {
            if (LineIndex < NumBytes)
            {
                char c = *(Data+LineIndex);

                if (c < ' ' || c > 'z')
                {
                    c = '.';
                }
                DbgPrint("%c", (UINT)c);
            }
            else
            {
                DbgPrint(" ");
            }
        }
        DbgPrint("\n");     // End of line.
    }
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgQueueData


@func

    <f DbgQueueData> saves data to the DbgLogBuffer so it can be viewed later
    with the debugger.

    <f Note>: This routine is used for debug output only.
    It is not compiled into the retail version.

*/

VOID DbgQueueData(
    IN PUCHAR                   Data,                       // @parm
    // Pointer to first byte of data to be displayed.

    IN UINT                     NumBytes,                   // @parm
    // Number of bytes to be displayed.

    IN UINT                     Flags                       // @parm
    // A flag descriptor to help identify the log entry.
    )
{
    /*
    // Point to the next available entry in the DbgLogBuffer.
    */
    PUCHAR LogEntry = &DbgLogBuffer[DbgLogIndex++][0];

    /*
    // Wrap around on the next entry if needed.
    */
    if (DbgLogIndex >= DBG_LOG_ENTRIES)
    {
        DbgLogIndex = 0;
    }

    /*
    // Save the flags parameter in the first WORD of the log buffer.
    */
    *((PUSHORT) LogEntry) = (USHORT) Flags;
    LogEntry += sizeof(PUSHORT);

    /*
    // Save the NumBytes parameter in the second WORD of the log buffer.
    */
    *((PUSHORT) LogEntry) = (USHORT) NumBytes;
    LogEntry += sizeof(NumBytes);

    /*
    // Don't try to save more than we have room for.
    */
    if (NumBytes > DBG_LOG_SIZE - sizeof(USHORT) * 2)
    {
        NumBytes = DBG_LOG_SIZE - sizeof(USHORT) * 2;
    }

    /*
    // Save the rest of the data in the remaining portion of the log buffer.
    */
    while (NumBytes--)
    {
        *LogEntry++ = *Data++;
    }
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgBreakPoint


@func VOID | DbgBreakPoint |

    <f DbgBreakPoint> is defined in the NT kernel for SYS drivers, but we
    override it here so we can support for SYS's, EXE's, VXD's, and DLL's.

*/
#if defined(_MSC_VER) && (_MSC_VER <= 800)
// Must be building with 16-bit compiler
VOID __cdecl DbgBreakPoint(VOID)
#else
// Must be building with 32-bit compiler
VOID __stdcall DbgBreakPoint(VOID)
#endif
{
#if !defined(_WIN64)
    __asm int 3;
#endif
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrint


@func ULONG __cdecl | DbgPrint |

    <f DbgPrint> is defined in the kernel for SYS drivers, otherwise it is
    supported here for EXE's, VXD's, and DLL's.

@parm PCHAR | Format |
    printf style format string.

@parm OPTIONAL | Params |
    Zero or more optional parameters as needed by the format string.

*/

#if defined(_VXD_)

#if !defined(NDIS_DOS)
ULONG __cdecl DbgPrint(PCHAR Format, ...)
{
    ULONG   result = 0;

    __asm lea  eax, (Format + 4)
    __asm push eax
    __asm push Format
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 4*2
    __asm mov result, eax

    return (result);
}
#endif

#elif defined(_EXE_) || defined(_DLL_)

UCHAR   DbgString[1024];

ULONG __cdecl DbgPrint(PCHAR Format, ...)
{
    ULONG   result;

    result = wvsprintf(DbgString, Format, ((PCHAR) &Format) + sizeof(PCHAR));

    OutputDebugString(DbgString);

    if (result >= sizeof(DbgString))
    {
        // We just blew the stack!
        // Since we can't return, we have to generate a stack-fault interrupt
        __asm int 1;
        __asm int 3;
        __asm int 12;
    }
    return (result);
}
#endif // DbgPrint

/*
 * If DBG_SILENT is set, all TERSE debug goes here. An assertion
 * will dump the block.
 */
#define DBG_QUEUE_LEN       4096
UINT    DbgIndex=0;
UINT    DbgLen=0;
UCHAR   DbgQueue[DBG_QUEUE_LEN] =  {0};
UCHAR   DbgLock=0;


/* @doc INTERNAL TpiDebug TpiDebug_c DbgDumpSilentQueue


@func

    <f DbgDumpSilentQueue> dumps the contents of the silent debug queue to
    the monitor.

*/

void DbgDumpSilentQueue(
    void
    )
{
    if (DbgLen >= DBG_QUEUE_LEN)
    {
        DbgPrintData(
            &DbgQueue[DbgIndex],
            DBG_QUEUE_LEN-DbgIndex,
            0);
        if (DbgIndex)
        {
            DbgPrint("\n");
            DbgPrintData(
                DbgQueue,
                DbgIndex-1,
                0);
        }
        DbgPrint("\n");
    }
    else if (DbgLen)
    {
        DbgPrintData(
                DbgQueue,
                DbgIndex-1,
                0);
        DbgPrint("\n");
    }
}

#if NDIS_NT

/* @doc INTERNAL TpiDebug TpiDebug_c _assert


@func

    <f _assert> overrides the assertion function provided by the operating
    system. Dumps the contents of debug queue, prints the assertion, and
    then traps to the debugger.  Used for debugging only.

*/

void _CRTAPI1 _assert(
    void *                      exp,                        // @parm
    // ASCIIZ pointer to the expression causing the fault.

    void *                      file,                       // @parm
    // ASCIIZ pointer to the name of the file.

    unsigned                    line                        // @parm
    // Line offset within the file where the assertion is defined.
    )
{
    DbgDumpSilentQueue();
    DbgPrint("Assertion Failed: %s at %s:%d\n",exp,file,line);
    DbgBreakPoint();
}
#endif


/* @doc INTERNAL TpiDebug TpiDebug_c DbgSilentQueue


@func

    <f DbgSilentQueue> logs a string to the debug queue which can be
    displayed later using <f DbgDumpSilentQueue>.  Used for debugging only.

*/

void DbgSilentQueue(
    PUCHAR                      str                         // @parm
    // Pointer to string to be placed in DbgQueue.
    )
{
    /*
    // If the debug queue is busy, just
    // bail out.
    */
    if ((++DbgLock) > 1)
    {
        goto exit;
    }

    while (str && *str)
    {
        DbgQueue[DbgIndex] = *str++;
        DbgLen++;
        if ((++DbgIndex) >= DBG_QUEUE_LEN)
        {
            DbgIndex = 0;
        }
    }
exit:
    DbgLock--;
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrintFieldTable


@func

    <f DbgPrintFieldTable> displays the contents of a C data structure in
    a formatted output to the debugger.  This can be used when symbolic
    debugging is not available on the target platform.

*/

void DbgPrintFieldTable(
    IN PDBG_FIELD_TABLE         pFields,                    // @parm
    // A pointer to an array of field records <t DBG_FIELD_TABLE>.

    IN PUCHAR                   pBaseContext,               // @parm
    // References the base of the structure where the values will be displayed
    // from.  This should be a pointer to the first byte of the structure.

    IN PUCHAR                   pBaseName                   // @parm
    // Pointer to C string containing the name of the structure being displayed.
    )
{
    DbgPrint("STRUCTURE: @0x%08X %s\n", pBaseContext, pBaseName);

    while (pFields->FieldName)
    {
        switch (pFields->FieldType)
        {
        case sizeof(ULONG):
            DbgPrint("\t%04X: %-32s=0x%08X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PULONG)(pBaseContext+pFields->FieldOffset));
            break;

        case sizeof(USHORT):
            DbgPrint("\t%04X: %-32s=0x%04X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PUSHORT)(pBaseContext+pFields->FieldOffset));
            break;

        case sizeof(UCHAR):
            DbgPrint("\t%04X: %-32s=0x%02X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PUCHAR)(pBaseContext+pFields->FieldOffset));
            break;

        default:
            ASSERT(0);
            break;
        }
        pFields++;
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\tpidebug.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiDebug TpiDebug_h

@module TpiDebug.h |

    This module, along with <f TpiDebug\.c>, implements code and macros to
    support NDIS driver debugging.  This file should be #include'd in all
    the driver source code modules.

@comm

    The code and macros defined by these modules is only generated during
    development debugging when the C pre-processor macro flag (DBG == 1).
    If (DBG == 0) no code will be generated, and all debug strings will be
    removed from the image.

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiDebug_h

@end

*/

#ifndef _TPIDEBUG_H
#define _TPIDEBUG_H

/* @doc INTERNAL TpiDebug TpiDebug_h


@topic Debug Globals |

    Debug macros are used to display error conditions, warnings, interesting
    events, and general flow through the components.  Setting one or more bits
    in the <f DbgInfo> global variable will enable the output from these
    macros.  See <t DEBUG_FLAGS> for details of the bits.  Only the debug
    version of the driver will contain code for this purpose.  All these
    macros will be compiled out in the release version.

    Each component has a separate <f DbgInfo> variable, so you can control
    debug output for each module separately.  By default, all the modules
    breakpoint at their entry point to display the current value and memory
    location of the module's <f DbgInfo> variable.  This way you can use
    the debugger to change the flags when the module is started.  The default
    flag for each module is set at compile time, but can be overridden at
    run time using the debugger.

@globalv DBG_SETTINGS | DbgInfo |

    DbgInfo is a global variable which points to the <t DBG_SETTINGS> for
    the module linked with <f TpiDebug\.c>.  It is passed to most of
    the debug output macros to control which output is to be displayed.  
    See <t DBG_FLAGS> to determine which bits to set.

*/

/*
// Module ID numbers to use for error logging
*/
#define TPI_MODULE_PARAMS               ((unsigned long)'P')+\
                                        ((unsigned long)'A'<<8)+\
                                        ((unsigned long)'R'<<16)+\
                                        ((unsigned long)'M'<<24)
#define TPI_MODULE_DEBUG                ((unsigned long)'D')+\
                                        ((unsigned long)'B'<<8)+\
                                        ((unsigned long)'U'<<16)+\
                                        ((unsigned long)'G'<<24)
#define TPI_MODULE_PERF                 ((unsigned long)'P')+\
                                        ((unsigned long)'E'<<8)+\
                                        ((unsigned long)'R'<<16)+\
                                        ((unsigned long)'F'<<24)
#define TPI_MODULE_WRAPS                ((unsigned long)'W')+\
                                        ((unsigned long)'R'<<8)+\
                                        ((unsigned long)'A'<<16)+\
                                        ((unsigned long)'P'<<24)

// In case these aren't defined in the current environment.
#if !defined(IN)
# define    IN
# define    OUT
#endif

/* @doc INTERNAL TpiDebug TpiDebug_h DBG_FLAGS


@enum DBG_FLAGS |

    The registry parameter <f DebugFlags> is read by the driver at
    initialization time and saved in the <f DbgFlags> field of the
    debug settings structure (See <t DBG_SETTINGS>).  This value
    controls the output of debug information according to the
    following bit OR'd flags.  The most significant 16 bits of the
    DbgFlags is available to use as you please, and can be used
    with the <f DBG_FILTER> macro.

*/

#define DBG_ERROR_ON        0x0001L
        // @emem DBG_ERROR_ON | (0x0001) Display <f DBG_ERROR> messages.

#define DBG_WARNING_ON      0x0002L
        // @emem DBG_WARNING_ON | (0x0002) Display <f DBG_WARNING> messages.

#define DBG_NOTICE_ON       0x0004L
        // @emem DBG_NOTICE_ON | (0x0004) Display <f DBG_NOTICE> messages.

#define DBG_TRACE_ON        0x0008L
        // @emem DBG_TRACE_ON | (0x0008) Display <f DBG_ENTER>, <f DBG_LEAVE>,
        // and <f DBG_TRACE> messages.

#define DBG_REQUEST_ON      0x0010L
        // @emem DBG_REQUEST_ON | (0x0010) Display NDIS Set/Query request
        // parameters using <f DBG_REQUEST>.

#define DBG_INDICATE_ON     0x0020L
        // @emem DBG_INDICATE_ON | (0x0020) Display NDIS status indications.

#define DBG_TAPICALL_ON     0x0040L
        // @emem DBG_TAPICALL_ON | (0x0040) Display TAPI call state messages
        // using <f DBG_FILTER>.

#define DBG_PARAMS_ON       0x0080L
        // @emem DBG_PARAMS_ON | (0x0080) Display function parameters and
        // return values using <f DBG_PARAMS>.

#define DBG_TXRX_LOG_ON     0x0100L
        // @emem DBG_TXRX_LOG_ON | (0x0100) Enable Tx/Rx data logging.

#define DBG_TXRX_ON         0x0200L
        // @emem DBG_TXRX_ON | (0x0200) Display Tx/Rx terse packet info.
        // This flag will just display the link index and packet length Rx#:#.

#define DBG_TXRX_HEADERS_ON 0x0400L
        // @emem DBG_TXRX_HEADERS_ON | (0x0400) Display Tx/Rx packet headers.

#define DBG_HEADERS_ON      DBG_TXRX_HEADERS_ON

#define DBG_TXRX_VERBOSE_ON 0x0800L
        // @emem DBG_TXRX_VERBOSE_ON | (0x0800) Display Tx/Rx packet data.

#define DBG_PACKETS_ON      DBG_TXRX_VERBOSE_ON

#define DBG_MEMORY_ON       0x1000L
        // @emem DBG_MEMORY_ON | (0x1000) Display memory allocate and
        // free usage information.

#define DBG_BUFFER_ON       0x2000L
        // @emem DBG_BUFFER_ON | (0x2000) Display buffer allocate and
        // free usage information.

#define DBG_PACKET_ON       0x4000L
        // @emem DBG_PACKET_ON | (0x4000) Display packet allocate and
        // free usage information.

#define DBG_BREAK_ON        0x8000L
        // @emem DBG_BREAK_ON | (0x8000) Enable <f DBG_BREAK> breakpoints.

#define DbgFlags            DebugFlags      // For compatability
#define DbgID               AnsiDeviceName  // For compatability

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/* @doc INTERNAL TpiDebug TpiDebug_h DBG_SETTINGS


@struct DBG_SETTINGS |

    This structure is used to control debug output for a given module.
    You can set and clear bits in the DbgFlags field to enabled and
    disable various debug macros.  See <t DBG_FLAGS> to determine which 
    bits to set.

*/

typedef struct DBG_SETTINGS
{
    unsigned long DbgFlags;                                 // @field
    // Debug flags control how much debug is displayed in the checked build.
    // Put this field at the front so you can set it easily with debugger.
    // See <t DBG_FLAGS> to determine which bits to set in this field.

    unsigned char DbgID[12];                                // @field
    // This field is initialized to an ASCII string containing a unique
    // module identifier.  It is used to prefix debug messages.  If you
    // have more than one module based on this code, you may want to
    // change the default value to a unqiue string for each module.
    // This string is used a C string, so the last byte must be a zero.

} DBG_SETTINGS, *PDBG_SETTINGS;

extern PDBG_SETTINGS DbgInfo;


/* @doc INTERNAL TpiDebug TpiDebug_h DBG_FIELD_TABLE


@struct DBG_FIELD_TABLE |

    This structure contains the data associated with a C data structure.
    You can use the <f DBG_FIELD_ENTRY> macro to add entries into a
    <t DBG_FIELD_TABLE>.  At run-time you can pass this table pointer to
    the <f DbgPrintFieldTable> routine, and it will display the current
    contents of that data structure.  This is useful for debugging drivers
    or code where no symbolic debugger is available, or if you have want to
    dump structure contents when certain run-time events are encountered.

@comm

    If you have nested structures, you must display them separately.  The
    <f DBG_FIELD_ENTRY> macro can only be used to declare integer type
    fields, and pointers.  Pointers will be displayed as a long integer.<nl>

    The last entry in the table must be all zeros {0}.

*/

typedef struct DBG_FIELD_TABLE
{
    unsigned int    FieldOffset;                            // @parm
    // This value indicates the offset, in bytes, from the <f pBaseContext>
    // pointer passed into <f DbgPrintFieldTable>.  The value for the field
    // will be displayed from this offset from <f pBaseContext>.
    // <nl>*(PUINT)((PUCHAR)BaseContext+Offset) = (UINT) Value;

    unsigned int    FieldType;                              // @parm
    // This value determines how the value will be displayed.
    // <f FieldType> can be one of the following values:
    // <nl>1=UCHAR  - unsigned char integer (8 bits).
    // <nl>2=USHORT - unsigned short integer (16 bits).
    // <nl>4=ULONG  - unsigned long integer (32 bits).

    unsigned char * FieldName;                              // @parm
    // This value points to a C String which is the name of the field within
    // the structure.

} DBG_FIELD_TABLE, *PDBG_FIELD_TABLE;

#define DBG_FIELD_BUFF      0
#define DBG_FIELD_CHAR      1
#define DBG_FIELD_SHORT     2
#define DBG_FIELD_LONG      4

#define DBG_FIELD_OFFSET(Strct, Field) ((unsigned int)((unsigned char *) &((Strct *) 0)->Field))
#define DBG_FIELD_SIZEOF(Strct, Field) sizeof(((Strct *) 0)->Field)
#define DBG_FIELD_ENTRY(Strct, Field) \
    { DBG_FIELD_OFFSET(Strct, Field), \
      DBG_FIELD_SIZEOF(Strct, Field), \
      #Field )

extern VOID DbgPrintFieldTable(
    IN PDBG_FIELD_TABLE     pFields,
    IN unsigned char *               pBaseContext,
    IN unsigned char *               pBaseName
    );

extern VOID DbgPrintData(
    IN unsigned char *               Data,
    IN unsigned int                 NumBytes,
    IN unsigned long                Offset
    );

extern VOID DbgQueueData(
    IN unsigned char *               Data,
    IN unsigned int                 NumBytes,
    IN unsigned int                 Flags
    );

#if !defined(NDIS_WIN) || !defined(DEBUG)
extern unsigned long __cdecl DbgPrint(char * Format, ...);
#endif

// DbgBreakPoint is ugly because it is defined by NTDDK as _stdcall,
// and 95DDK #defines it, and we must define our own for non-DDK builds.
// So all these ifdefs are used to figure out how to handle it.
#ifdef DbgBreakPoint
#   undef DbgBreakPoint
#endif // DbgBreakPoint

#if defined(_MSC_VER) && (_MSC_VER <= 800)
    // Must be building with 16-bit compiler
    extern VOID __cdecl DbgBreakPoint(VOID);
#else
    // Must be building with 32-bit compiler
    extern VOID __stdcall DbgBreakPoint(VOID);
#endif

extern VOID DbgSilentQueue(unsigned char * str);

#ifdef __cplusplus
};
#endif // __cplusplus

// NDIS builds define DBG=0 or DBG=1
#if defined(DEBUG) || defined(_DEBUG)
# ifndef DBG
#  define DBG 1
# endif
#else
# ifndef DBG
#  define DBG 0
# endif
#endif

//###############################################################################
#if DBG
//###############################################################################

#ifndef ASSERTS_ENABLED
#   define ASSERTS_ENABLED  1
#endif

#ifndef DBG_DEFAULTS
#   define DBG_DEFAULTS (DBG_ERROR_ON | DBG_WARNING_ON | DBG_BREAK_ON)
#endif

/* @doc INTERNAL TpiDebug TpiDebug_h


*/

#   define STATIC
#   define DBG_STATIC
    // Make all variables and functions global, so debugger can see them.

#   define TRAPFAULT        DbgBreakPoint()
    // Use this macro to insert an unconditional INT-1 breakpoint.  This
    // is used to distinguish between normal debugger breakpoints (INT-3)
    // and any special cases, such as ASSERT.

#   define BREAKPOINT       DbgBreakPoint()
    // Use this macro to insert an unconditional INT-3 breakpoint.

#   define DBG_FUNC(F)      static const char __FUNC__[] = F;
    // @func const char [] | DBG_FUNC |
    //
    // Use this macro to define the __FUNC__ string used by the rest of the
    // debugger macros to report the name of the function calling the macro.
    //
    // @parm const char * | FunctionName | Name of the function being defined.
    //
    // @ex <tab> | DBG_FUNC("MyFunctionName");

#   define DBG_BREAK(A)     {if ((A) && ((A)->DbgFlags & DBG_BREAK_ON) || !(A)) \
                                BREAKPOINT;}
    // @func VOID | DBG_BREAK |
    //
    // Use this macro to insert a conditional INT-3 breakpoint.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_BREAK(DbgInfo);

#   define DBG_ENTER(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON)) \
                                {DbgPrint("%s:>>>:%s\n",(A)->DbgID,__FUNC__);}}
    // @func VOID | DBG_ENTER |
    //
    // Use this macro to report entry to a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_ENTER(DbgInfo);

#   define DBG_TRACE(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON)) \
                                {DbgPrint("%s:%d:%s\n",(A)->DbgID,__LINE__,\
                                 __FUNC__);}}
    // @func VOID | DBG_TRACE |
    //
    // Use this macro to report a trace location within a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_TRACE(DbgInfo);

#   define DBG_LEAVE(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON))  \
                                {DbgPrint("%s:<<<:%s\n",(A)->DbgID,__FUNC__);}}
    // @func VOID | DBG_LEAVE |
    //
    // Use this macro to report exit from a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_LEAVE(DbgInfo);

#   define DBG_RETURN(A,S)  {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON))  \
                                {DbgPrint("%s:<<<:%s Return(0x%lX)\n",(A)->DbgID,__FUNC__,S);}}
    // @func VOID | DBG_RETURN |
    //
    // Use this macro to report exit from a function with a result.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_RETURN(DbgInfo, Result);

#   define DBG_ERROR(A,S)   {if ((A) && ((A)->DbgFlags & DBG_ERROR_ON))   \
                                {DbgPrint("%s:ERROR:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S; \
                                 if ((A)->DbgFlags & DBG_BREAK_ON) \
                                    {TRAPFAULT;}}}
    // @func VOID | DBG_ERROR |
    //
    // Use this macro to report any unexpected error conditions.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_ERROR(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_WARNING(A,S) {if ((A) && ((A)->DbgFlags & DBG_WARNING_ON)) \
                                {DbgPrint("%s:WARNING:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_WARNING |
    //
    // Use this macro to report any unusual run-time conditions.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_WARNING(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_NOTICE(A,S)  {if ((A) && ((A)->DbgFlags & DBG_NOTICE_ON))  \
                                {DbgPrint("%s:NOTICE:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_NOTICE |
    //
    // Use this macro to report any verbose debug information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_NOTICE(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_REQUEST(A,S)  {if ((A) && ((A)->DbgFlags & DBG_REQUEST_ON))  \
                                {DbgPrint("%s:REQUEST:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_REQUEST |
    //
    // Use this macro to report NDIS Set/Query request information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_REQUEST(DbgInfo, ("Oid #0x%08X - %s\n", Oid, DbgGetOidString(Oid)));

#   define DBG_PARAMS(A,S)  {if ((A) && ((A)->DbgFlags & DBG_PARAMS_ON))  \
                                {DbgPrint("%s:PARAMS:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_PARAMS |
    //
    // Use this macro to report NDIS Set/Query request information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_PARAMS(DbgInfo, ("\n\tNum=0x%X\n\tStr='%s'\n", Num, Str));

#   define DBG_TX(A,I,N,B)  {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Tx%d:%03X:\n",(A)->DbgID,I,N); \
                                if (((A)->DbgFlags & DBG_TXRX_VERBOSE_ON))  \
                                    DbgPrintData((unsigned char *)B, (unsigned int)N, 0); \
                                else if (((A)->DbgFlags & DBG_TXRX_HEADERS_ON))  \
                                    DbgPrintData((unsigned char *)B, 0x10, 0); \
                                }\
                             if ((A) && ((A)->DbgFlags & DBG_TXRX_LOG_ON)) \
                                DbgQueueData((unsigned char *)B, (unsigned int)N, \
                                              (USHORT)((I<< 8) + 0x4000)); \
                            }
    // @func VOID | DBG_TX |
    //
    // Use this macro to report outgoing packet information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @parm IN UINT | NumBytes | Number of bytes being transmitted.
    //
    // @parm IN PUCHAR | Buffer | Pointer to data buffer being transmitted.
    //
    // @ex <tab> | DBG_TX(DbgInfo, BChannelIndex, BytesToSend, CurrentBuffer);

#   define DBG_TXC(A,I)     {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Tc%d\n",(A)->DbgID,I); \
                                }}
    // @func VOID | DBG_TXC |
    //
    // Use this macro to report outgoing packet completion.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @ex <tab> | DBG_TXC(DbgInfo, BChannelIndex);

#   define DBG_RX(A,I,N,B)  {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Rx%d:%03X:\n",(A)->DbgID,I,N); \
                                if (((A)->DbgFlags & DBG_TXRX_VERBOSE_ON))  \
                                    DbgPrintData((unsigned char *)B, (unsigned int)N, 0); \
                                else if (((A)->DbgFlags & DBG_TXRX_HEADERS_ON))  \
                                    DbgPrintData((unsigned char *)B, 0x10, 0); \
                                }\
                             if ((A) && ((A)->DbgFlags & DBG_TXRX_LOG_ON)) \
                                DbgQueueData((unsigned char *)B, (unsigned int)N, \
                                              (USHORT)((I<< 8) + 0x8000)); \
                            }
    // @func VOID | DBG_RX |
    //
    // Use this macro to report incoming packet information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @parm IN UINT | NumBytes | Number of bytes being received.
    //
    // @parm IN PUCHAR | Buffer | Pointer to data buffer being received.
    //
    // @ex <tab> | DBG_RX(DbgInfo, BChannelIndex, BytesReceived, ReceiveBuffer);

#   define DBG_RXC(A,I)     {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Rc%d\n",(A)->DbgID,I); \
                                }}
    // @func VOID | DBG_RXC |
    //
    // Use this macro to report incoming packet completion.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @ex <tab> | DBG_RXC(DbgInfo, BChannelIndex);

#   define DBG_FILTER(A,M,S){if ((A) && ((A)->DbgFlags & (M)))            \
                                {DbgPrint("%s:%s: ",(A)->DbgID,__FUNC__); \
                                 DbgPrint S;}}
    // @func VOID | DBG_FILTER |
    //
    // Use this macro to filter for specific DbgFlag combinations.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN DBG_FLAGS | DbgMask | OR'd mask of <t DBG_FLAGS>.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_FILTER(DbgInfo, DBG_FILTER1_ON | DBG_REQUEST_ON,
    //                 ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_DISPLAY(S)   {DbgPrint("%s: ",__FUNC__); DbgPrint S;}
    // @func VOID | DBG_DISPLAY |
    //
    // Use this macro to unconditionally report a message.  This macro does
    // not take a pointer to the DBG_SETTINGS structure, so it can be used in
    // any module or function of the driver.  There is no way to disable the
    // display of these messages.  The funcion name precedes the output string.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_DISPLAY(("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_PRINT(S)     {DbgPrint S;}
    // @func VOID | DBG_PRINT |
    //
    // Use this macro to unconditionally report a message.  This macro does
    // not take a pointer to the DBG_SETTINGS structure, so it can be used in
    // any module or function of the driver.  There is no way to disable the
    // display of these messages.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_PRINT(("What happened at line %d!\n",__LINE__));

//###############################################################################
#else // !DBG
//###############################################################################

#ifndef ASSERTS_ENABLED
#   define ASSERTS_ENABLED  0
#endif

#   define DBG_DEFAULTS (0)

/*
// When (DBG == 0) we disable all the debug macros.
*/

#   define STATIC           static
#   define DBG_STATIC       static
#   define TRAPFAULT        DbgBreakPoint()
#   define BREAKPOINT
#   define DBG_FUNC(F)
#   define DBG_BREAK(A)
#   define DBG_ENTER(A)
#   define DBG_TRACE(A)
#   define DBG_LEAVE(A)
#   define DBG_RETURN(A,S)
#   define DBG_ERROR(A,S)
#   define DBG_WARNING(A,S)
#   define DBG_NOTICE(A,S)
#   define DBG_REQUEST(A,S)
#   define DBG_PARAMS(A,S)
#   define DBG_TX(A,I,N,P)
#   define DBG_TXC(A,I)
#   define DBG_RX(A,I,N,P)
#   define DBG_RXC(A,I)
#   define DBG_FILTER(A,M,S)
#   define DBG_DISPLAY(S)
#   define DBG_PRINT(S)

//###############################################################################
#endif // DBG
//###############################################################################

#ifdef ASSERT
#   undef ASSERT
#endif
#ifdef assert
#   undef  assert
#endif

#if ASSERTS_ENABLED
#define ASSERT(C)   if (!(C)) { \
                        DbgPrint("ASSERT(%s) -- FILE:%s LINE:%d\n", \
                                 #C, __FILE__, __LINE__); \
                        TRAPFAULT; \
                    }
    // @func VOID | ASSERT |
    //
    // Use this macro to conditionally report a fatal error if the condition
    // specified is NOT true.
    //
    // @parm BOOLEAN_EXPRESSION | Expression | Any valid if (Expression).
    //
    // @ex <tab> | ASSERT(Actual == Expected);

#   define assert(C) ASSERT(C)
#else // !ASSERTS_ENABLED
#   define ASSERT(C)
#   define assert(C)
#endif // ASSERTS_ENABLED


#endif // _TPIDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\tpimem.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiMem TpiMem_c

@module TpiMem.c |

    This module implements the interface to the memory allocation wrappers.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiMem_c

@end

*/

#define  __FILEID__             TPIMEMORY_OBJECT_TYPE
// Unique file ID for error logging

#include "TpiMem.h"
#include "TpiDebug.h"

DBG_STATIC ULONG                g_MemoryAllocated = 0;
DBG_STATIC ULONG                g_MemoryFreed = 0;
DBG_STATIC ULONG                g_SharedMemoryAllocated = 0;
DBG_STATIC ULONG                g_SharedMemoryFreed = 0;


/* @doc INTERNAL TpiMem TpiMem_c TpiAllocateMemory


@func

    <f TpiAllocateMemory> provides a wrapper interface for standard memory
    allocation via <f NdisAllocateMemory>.  This interface is used to help
    debug memory allocation problems.  It can be used to keep track of how
    much memory has been allocated and freed by the Miniport, and can report
    the usage counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisAllocateMemory> (i.e. non-paged system memory).  Do not use this
    routine to allocate continuous or non-cached memory.

@rdesc

    <f TpiAllocateMemory> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS TpiAllocateMemory(
    OUT PVOID *                 ppObject,                   // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber,               // @parm
    // Line number of the file where called from.

    IN NDIS_HANDLE              MiniportAdapterHandle       // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.
    )
{
    DBG_FUNC("TpiAllocateMemory")

    NDIS_STATUS                 Status;
    // Holds the status result returned from an NDIS function call.

    ASSERT(ppObject);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|ppObject=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               ppObject,
               dwSize,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    /*
    // Allocate memory from NDIS.
    */
#if !defined(NDIS50_MINIPORT)
    Status = NdisAllocateMemory(ppObject, dwSize, 0, g_HighestAcceptableAddress);
#else  // NDIS50_MINIPORT
    Status = NdisAllocateMemoryWithTag(ppObject, dwSize, dwFileID);
#endif // NDIS50_MINIPORT

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ASSERT(*ppObject);
        NdisZeroMemory(*ppObject, dwSize);
        g_MemoryAllocated += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("Memory Allocated=%d Freed=%d -- Ptr=0x%X\n",
                   g_MemoryAllocated, g_MemoryFreed, *ppObject));
    }
    else
    {
        DBG_ERROR(DbgInfo,("NdisAllocateMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                  dwSize, szFileName, dwLineNumber, Status));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                3,
                Status,
                dwFileID,
                dwLineNumber
                );

        *ppObject = NULL;
    }

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiFreeMemory


@func

    <f TpiFreeMemory> provides a wrapper interface for <f NdisFreeMemory>.
    This interface is used to help debug memory allocation problems.  It can
    be used to keep track of how much memory has been allocated and freed by
    the Miniport, and can report the usage counters via the debugger.

    <f TpiFreeMemory> provides a wrapper interface for standard memory free
    via <f NdisFreeMemory>.  This interface is used to help debug memory
    allocation problems.  It can be used to keep track of how much memory
    has been allocated and freed by the Miniport, and can report the usage
    counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisFreeMemory> (i.e. non-paged system memory).  Do no use this
    routine to free continuous or non-cached memory.

*/

void TpiFreeMemory(
    IN OUT PVOID *              ppObject,                   // @parm
    // Points to a caller-defined memory location which this function
    // passes to <f NdisFreeMemory> and then writes NULL to.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiFreeMemory")

    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|ppObject=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               ppObject,
               dwSize,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    if (ppObject && *ppObject)
    {
        /*
        // Release memory to NDIS.
        */
        NdisFreeMemory(*ppObject, dwSize, 0);
        g_MemoryFreed += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("Memory Allocated=%d Freed=%d -- Ptr=0x%X\n",
                   g_MemoryAllocated, g_MemoryFreed, *ppObject));

        *ppObject = NULL;
    }
    else
    {
        DBG_ERROR(DbgInfo,("NULL POINTER (Size=%d, File=%s, Line=%d)\n",
                  dwSize, szFileName, dwLineNumber));
    }

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiAllocateSharedMemory


@func

    <f TpiAllocateSharedMemory> provides a wrapper interface for shared memory
    allocation via <f NdisMAllocateSharedMemory>.  This interface is used to help
    debug memory allocation problems.  It can be used to keep track of how
    much memory has been allocated and freed by the Miniport, and can report
    the usage counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisMAllocateSharedMemory> (i.e. non-paged system memory).  Do not
    use this routine to allocate continuous or non-cached memory.

@rdesc

    <f TpiAllocateSharedMemory> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS TpiAllocateSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN BOOLEAN                  bCached,                    // @parm
    // Specifies whether the requested memory is cached or not.

    OUT PVOID *                 pVirtualAddress,            // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,           // @parm
    // Points to a caller-defined memory location to which this function
    // writes the physical address of the allocated memory.  If memory of
    // the specified type is not available, the physical address is zero.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiAllocateSharedMemory")

    NDIS_STATUS                 Status;
    // Holds the status result returned from an NDIS function call.

    ASSERT(pVirtualAddress);
    ASSERT(pPhysicalAddress);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|pVirtualAddress=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|bCached=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               pVirtualAddress,
               dwSize,
               bCached,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    /*
    // Allocate memory from NDIS.
    */
    NdisMAllocateSharedMemory(MiniportAdapterHandle,
                              dwSize,
                              bCached,
                              pVirtualAddress,
                              pPhysicalAddress
                              );


    if (*pVirtualAddress)
    {
        Status = NDIS_STATUS_SUCCESS;

        NdisZeroMemory(*pVirtualAddress, dwSize);
        g_SharedMemoryAllocated += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("SharedMemory Allocated=%d Freed=%d -- Ptr=0x%X @0x%X\n",
                   g_SharedMemoryAllocated, g_SharedMemoryFreed,
                   *pVirtualAddress, pPhysicalAddress->LowPart));
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;

        DBG_ERROR(DbgInfo,("NdisAllocateSharedMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                  dwSize, szFileName, dwLineNumber, Status));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                3,
                Status,
                dwFileID,
                dwLineNumber
                );

        *pVirtualAddress = NULL;
        pPhysicalAddress->LowPart = 0;
        pPhysicalAddress->HighPart = 0;
    }

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiFreeSharedMemory


@func

    <f TpiFreeSharedMemory> provides a wrapper interface for <f NdisFreeSharedMemory>.
    This interface is used to help debug memory allocation problems.  It can
    be used to keep track of how much memory has been allocated and freed by
    the Miniport, and can report the usage counters via the debugger.

    <f TpiFreeSharedMemory> provides a wrapper interface for standard memory free
    via <f NdisFreeSharedMemory>.  This interface is used to help debug memory
    allocation problems.  It can be used to keep track of how much memory
    has been allocated and freed by the Miniport, and can report the usage
    counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisFreeSharedMemory> (i.e. non-paged system memory).  Do no use this
    routine to free continuous or non-cached memory.

*/

void TpiFreeSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN BOOLEAN                  bCached,                    // @parm
    // Specifies whether the requested memory is cached or not.

    IN PVOID *                  pVirtualAddress,            // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    IN NDIS_PHYSICAL_ADDRESS *  pPhysicalAddress,           // @parm
    // Points to a caller-defined memory location to which this function
    // writes the physical address of the allocated memory.  If memory of
    // the specified type is not available, the physical address is zero.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiFreeSharedMemory")

    ASSERT(pVirtualAddress);
    ASSERT(pPhysicalAddress);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|pVirtualAddress=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|bCached=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               pVirtualAddress,
               dwSize,
               bCached,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    if (pVirtualAddress && *pVirtualAddress)
    {
        /*
        // Release memory to NDIS.
        */
        NdisMFreeSharedMemory(MiniportAdapterHandle,
                              dwSize,
                              bCached,
                              *pVirtualAddress,
                              *pPhysicalAddress
                              );
        g_SharedMemoryFreed += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("SharedMemory Allocated=%d Freed=%d -- Ptr=0x%X @0x%X\n",
                   g_SharedMemoryAllocated, g_SharedMemoryFreed,
                   *pVirtualAddress, pPhysicalAddress->LowPart));

        *pVirtualAddress = NULL;
        pPhysicalAddress->LowPart = 0;
        pPhysicalAddress->HighPart = 0;
    }
    else
    {
        DBG_ERROR(DbgInfo,("NULL POINTER (Size=%d, File=%s, Line=%d)\n",
                  dwSize, szFileName, dwLineNumber));
    }

    DBG_LEAVE(DbgInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\tpiparam.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiParam TpiParam_c

@module TpiParam.c |

    This module, along with <f TpiParam\.h>, implements a table driven parser
    for the NDIS registry parameters.

@comm

    See <f Keywords\.h> for details of how to add new parameters.<nl>

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiParam_c

@end

*/

#define  __FILEID__     TPI_MODULE_PARAMS   // Unique file ID for error logging

#include <ndis.h>
#include "TpiDebug.h"
#include "TpiParam.h"

#if defined(_VXD_) && !defined(NDIS_LCODE)
#  define NDIS_LCODE code_seg("_LTEXT", "LCODE")
#  define NDIS_LDATA data_seg("_LDATA", "LCODE")
#endif

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif

static NDIS_PHYSICAL_ADDRESS    g_HighestAcceptableAddress =
                                    NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);

static NDIS_STRING              g_NullString =
                                    NDIS_STRING_CONST("\0");


/* @doc INTERNAL TpiParam TpiParam_c ustrlen


@func

    <f ustrlen> counts the number of characters in
    a UNICODE (wide) string.

@comm

@rdesc

    <f ustrlen> returns the length of the UNICODE string
    pointed to by <p string>.  The terminating NULL character is not
    counted.

*/
USHORT ustrlen(
    IN PUSHORT                  string                      // @parm
    // Pointer to the beginning of a UNICODE string ending
    // with a 0x0000 value.
    )
{
    USHORT                      ct;

    for (ct = 0; *string != 0x0000; string++, ct++)
        ;

    return(ct);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamUnicodeStringToAnsiString


@func

    <f ParamUnicodeStringToAnsiString> converts a double byte string to a
    single byte string.

@comm

    The original release of the NDIS Wrapper for Windows 95 and 3.1 does not
    return UNICODE strings from the NdisReadConfiguration routine.  So this
    routine attempts to auto detect this situation by examining the first
    character of the string.  If the second byte of the first character is
    a zero, the string is assumed to be UNICODE, and it is converted to an
    ANSI string; otherwise the ANSI string is just copied.
    <nl>
    <f Note>: This also assumes that the first character of any UNICODE
    string will not use the second byte (i.e. not an extended character).
    This routine will only successfully convert non-extended character
    strings anyway.

@xref
    <f ParamParseRegistry>
*/

VOID ParamUnicodeStringToAnsiString(
    OUT PANSI_STRING            out,                        // @parm
    // A pointer to where the converted ANSI string is to be stored.

    IN PUNICODE_STRING          in                          // @parm
    // A pointer to the UNICODE string to be converted.
    )
{
    DBG_FUNC("ParamUnicodeStringToAnsiString")

    UINT Index;

    /* CAVEAT - NDIS_BUG
    // NDIS driver for Windows 95 does not return UNICODE from
    // registry parser, so we need to kludge it up here.
    */
    if (in->Length > 1)
    {
        if (((PUCHAR)(in->Buffer))[1] == 0)
        {
            /*
            // Probably a UNICODE string since all our parameters are ASCII
            // strings.
            */
            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("UNICODE STRING IN @%x#%d='%ls'\n",
                       in->Buffer, in->Length, in->Buffer));
            for (Index = 0; Index < (in->Length / sizeof(WCHAR)) &&
                 Index < out->MaximumLength; Index++)
            {
                out->Buffer[Index] = (UCHAR) in->Buffer[Index];
            }
        }
        else
        {
            /*
            // Probably an ANSI string since all our parameters are more
            // than 1 byte long and should not be zero in the second byte.
            */
            PANSI_STRING in2 = (PANSI_STRING) in;

            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("ANSI STRING IN @%x#%d='%s'\n",
                       in2->Buffer, in2->Length, in2->Buffer));

            for (Index = 0; Index < in2->Length &&
                 Index < out->MaximumLength; Index++)
            {
                out->Buffer[Index] = in2->Buffer[Index];
            }
        }
    }
    else
    {
        DBG_WARNING(DbgInfo,("1 BYTE STRING IN @%x=%04x\n",
                    in->Buffer, in->Buffer[0]));
        out->Buffer[0] = (UCHAR) in->Buffer[0];
        Index = 1;
    }
    out->Length = (USHORT) Index; // * sizeof(UCHAR);

    // NULL terminate the string if there's room.
    if (out->Length <= (out->MaximumLength - sizeof(UCHAR)))
    {
        out->Buffer[Index] = 0;
    }
    ASSERT(out->Length <= out->MaximumLength);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamUnicodeCopyString


@func

    <f ParamUnicodeCopyString> copies a double byte string to a double byte
    string.

@comm

    The original release of the NDIS Wrapper for Windows 95 and 3.1 does not
    return UNICODE strings from the NdisReadConfiguration routine.  So this
    routine attempts to auto detect this situation by examining the first
    character of the string.  If the second byte of the first character is
    a zero, the string is assumed to be UNICODE, and it just copied;
    otherwise the ANSI string is converted to UNICODE.
    <nl>
    <f Note>: This also assumes that the first character of any UNICODE
    string will not use the second byte (i.e. not an extended character).
    This routine will only successfully convert non-extended character
    strings anyway.

@xref
    <f ParamParseRegistry>

*/

VOID ParamUnicodeCopyString(
    OUT PUNICODE_STRING         out,                        // @parm
    // A pointer to where the new UNICODE string is to be stored.

    IN PUNICODE_STRING          in                          // @parm
    // A pointer to the UNICODE string to be copied.
    )
{
    DBG_FUNC("ParamUnicodeCopyString")

    UINT Index;

    /* CAVEAT - NDIS_BUG
    // NDIS driver for Windows 95 does not return UNICODE from
    // registry parser, so we need to kludge it up here.
    */
    if (in->Length > 1)
    {
        if (((PUCHAR)(in->Buffer))[1] == 0)
        {
            /*
            // Probably a UNICODE string since all our parameters are ASCII
            // strings.
            */
            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("UNICODE STRING IN @%x#%d='%ls'\n",
                       in->Buffer, in->Length, in->Buffer));
            for (Index = 0; Index < (in->Length / sizeof(WCHAR)) &&
                 Index < (out->MaximumLength / sizeof(WCHAR)); Index++)
            {
                out->Buffer[Index] = in->Buffer[Index];
            }
        }
        else
        {
            /*
            // Probably an ANSI string since all our parameters are more
            // than 1 byte long and should not be zero in the second byte.
            */
            PANSI_STRING in2 = (PANSI_STRING) in;

            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("ANSI STRING IN @%x#%d='%s'\n",
                       in2->Buffer, in2->Length, in2->Buffer));
            for (Index = 0; Index < in2->Length &&
                 Index < (out->MaximumLength / sizeof(WCHAR)); Index++)
            {
                out->Buffer[Index] = (WCHAR) in2->Buffer[Index];
            }
        }
    }
    else
    {
        DBG_WARNING(DbgInfo,("1 BYTE STRING IN @%x=%04x\n",
                    in->Buffer, in->Buffer[0]));
        out->Buffer[0] = (WCHAR) in->Buffer[0];
        Index = 1;
    }
    out->Length = Index * sizeof(WCHAR);

    // NULL terminate the string if there's room.
    if (out->Length <= (out->MaximumLength - sizeof(WCHAR)))
    {
        out->Buffer[Index] = 0;
    }
    ASSERT(out->Length <= out->MaximumLength);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamGetNumEntries


@func

    <f ParamGetNumEntries> counts the number of records in the registry
    parameter table.

@rdesc

    <f ParamGetNumEntries> returns the number of entries in the parameter
    table.

@xref
    <f ParamParseRegistry>

*/

DBG_STATIC UINT ParamGetNumEntries(
    IN PPARAM_TABLE             Parameters                  // @parm
    // A pointer to an array of registry parameter records.
    )
{
    UINT NumRecs = 0;

    /*
    // Scan the parameter array until we find an entry with zero length name.
    */
    if (Parameters)
    {
        while (Parameters->RegVarName.Length)
        {
            NumRecs++;
            Parameters++;
        }
    }
    return(NumRecs);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamParseRegistry


@func

    <f ParamParseRegistry> parses the registry parameter table and attempts
    to read a value from the registry for each parameter record.

@rdesc

    <f ParamParseRegistry> returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE

@xref
    <f MiniportInitialize>
    <f ParamGetNumEntries>
    <f NdisOpenConfiguration>
    <f NdisWriteErrorLogEntry>
    <f NdisReadConfiguration>
    <f NdisCloseConfiguration>
    <f NdisAllocateMemory>
    <f NdisZeroMemory>
    <f ParamUnicodeStringToAnsiString>
    <f ParamUnicodeCopyString>
*/

NDIS_STATUS ParamParseRegistry(
    IN NDIS_HANDLE              AdapterHandle,              // @parm
    // Handle to pass to NdisWriteErrorLogEntry if any errors are encountered.

    IN NDIS_HANDLE              WrapperConfigurationContext,// @parm
    // Handle to pass to NdisOpenConfiguration.

    IN PUCHAR                   BaseContext,                // @parm
    // References the base of the structure where the values read from the
    // registry are written.  Typically, this will be a pointer to the first
    // byte of the adapter information structure.

    IN PPARAM_TABLE             Parameters                  // @parm
    // A pointer to an array of registry parameter records <t PARAM_TABLE>.
    )
{
    DBG_FUNC("ParamParseRegistry")

    PNDIS_CONFIGURATION_PARAMETER   pReturnedValue;
    NDIS_CONFIGURATION_PARAMETER    ReturnedValue;
    NDIS_PARAMETER_TYPE             ParamType;

    /*
    // The handle for reading from the registry.
    */
    NDIS_HANDLE     ConfigHandle;

    UINT            NumRecs = ParamGetNumEntries(Parameters);
    UINT            i;
    PPARAM_TABLE    pParameter;
    NDIS_STATUS     Status;
    UINT            Value;
    PANSI_STRING    pAnsi;
    UINT            Length;

    /*
    // Open the configuration registry so we can get our config values.
    */
    NdisOpenConfiguration(
            &Status,
            &ConfigHandle,
            WrapperConfigurationContext
            );

    if (Status != NDIS_STATUS_SUCCESS)
    {
        /*
        // Log error message and exit.
        */
        DBG_ERROR(DbgInfo,("NdisOpenConfiguration failed (Status=%X)\n",Status));

        NdisWriteErrorLogEntry(
                AdapterHandle,
                NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                3,
                Status,
                __FILEID__,
                __LINE__
                );
        return NDIS_STATUS_FAILURE;
    }

    /*
    // Walk through all the parameters in the table.
    */
    for (i = 0, pParameter = Parameters; i < NumRecs; i++, pParameter++)
    {
#if DBG
        ANSI_STRING ansiRegString;
        char        ansiRegName[64];

        /*
        // Get a printable parameter name.
        */
        ansiRegString.Length = 0;
        ansiRegString.MaximumLength = sizeof(ansiRegName);
        ansiRegString.Buffer = (PCHAR)ansiRegName;
        NdisZeroMemory(ansiRegName, sizeof(ansiRegName));
        ParamUnicodeStringToAnsiString(
                &ansiRegString,
                (PUNICODE_STRING)&pParameter->RegVarName
                );
#endif // DBG

        ASSERT(pParameter->Type <= (UINT) NdisParameterMultiString);

        /*
        // Attempt to read the parameter value from the registry.
        */
        ParamType = (NDIS_PARAMETER_TYPE) pParameter->Type;
        NdisReadConfiguration(&Status,
                              &pReturnedValue,
                              ConfigHandle,
                              &pParameter->RegVarName,
                              ParamType
                             );
        /*
        // If value is not present, and it is mandatory, return failure code.
        */
        if (Status != NDIS_STATUS_SUCCESS && pParameter->Mandantory)
        {
            /*
            // Log error message and exit.
            */
            DBG_ERROR(DbgInfo,("%s: NOT IN REGISTRY!\n",
                      ansiRegName));

            NdisWriteErrorLogEntry(
                    AdapterHandle,
                    NDIS_ERROR_CODE_MISSING_CONFIGURATION_PARAMETER,
                    4,
                    i,
                    Status,
                    __FILEID__,
                    __LINE__
                    );

            NdisCloseConfiguration(ConfigHandle);
            return NDIS_STATUS_FAILURE;
        }

        /*
        // Determine how the caller wants to interpret this parameter.
        */
        if (ParamType == NdisParameterInteger ||
            ParamType == NdisParameterHexInteger)
        {
            ASSERT(pParameter->Size <= sizeof(ULONG));

            /*
            // If value read, use it, otherwise use default.
            */
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Value = pReturnedValue->ParameterData.IntegerData;
            }
            else
            {
                Value = (UINT) (LONG_PTR)(pParameter->Default);
            }

            /*
            // If there are min/max boundaries, verify that value is in range.
            */
            if (pParameter->Min || pParameter->Max)
            {
                if (Value < pParameter->Min)
                {
                    DBG_ERROR(DbgInfo,("%s: Value=%X < Min=%X\n",
                              ansiRegName, Value, pParameter->Min));
                    Value = pParameter->Min;
                }
                else if (Value > pParameter->Max)
                {
                    DBG_ERROR(DbgInfo,("%s: Value=%X > Max=%X\n",
                              ansiRegName, Value, pParameter->Max));
                    Value = pParameter->Max;
                }
            }

            /*
            // Size of destination in bytes 1, 2, or 4 (default==INT).
            */
            switch (pParameter->Size)
            {
            case 0:
                *(PUINT)(BaseContext+pParameter->Offset)   = (UINT) Value;
                break;

            case 1:
                if (Value & 0xFFFFFF00)
                {
                    DBG_WARNING(DbgInfo,("%s: OVERFLOWS UCHAR\n",
                                ansiRegName));
                }
                *(PUCHAR)(BaseContext+pParameter->Offset)  = (UCHAR) Value;
                break;

            case 2:
                if (Value & 0xFFFF0000)
                {
                    DBG_WARNING(DbgInfo,("%s: OVERFLOWS USHORT\n",
                                ansiRegName));
                }
                *(PUSHORT)(BaseContext+pParameter->Offset) = (USHORT) Value;
                break;

            case 4:
                *(PULONG)(BaseContext+pParameter->Offset)  = (ULONG) Value;
                break;

            default:
                DBG_ERROR(DbgInfo,("%s: Invalid ParamSize=%d\n",
                          ansiRegName, pParameter->Size));
                NdisCloseConfiguration(ConfigHandle);
                return NDIS_STATUS_FAILURE;
                break;
            }

            if (ParamType == NdisParameterInteger)
            {
                DBG_PARAMS(DbgInfo,("%s: Value=%d Size=%d (%s)\n",
                           ansiRegName, Value, pParameter->Size,
                           (Status == NDIS_STATUS_SUCCESS) ?
                           "Registry" : "Default"));
            }
            else
            {
                DBG_PARAMS(DbgInfo,("%s: Value=0x%X Size=%d (%s)\n",
                           ansiRegName, Value, pParameter->Size,
                           (Status == NDIS_STATUS_SUCCESS) ?
                           "Registry" : "Default"));
            }
        }
        else if (ParamType == NdisParameterString ||
                 ParamType == NdisParameterMultiString)
        {
            ASSERT(pParameter->Size == sizeof(ANSI_STRING));

            /*
            // If value not read from registry.
            */
            if (Status != NDIS_STATUS_SUCCESS)
            {
                /*
                // Use our own temporary ReturnedValue.
                */
                pReturnedValue = &ReturnedValue;
                pReturnedValue->ParameterType = ParamType;

                /*
                // If default non-zero, use default value.
                */
                if (pParameter->Default != 0)
                {
                    NdisMoveMemory(&pReturnedValue->ParameterData.StringData,
                                   (PANSI_STRING) pParameter->Default,
                                   sizeof(ANSI_STRING));
                }
                else
                {
                    /*
                    // Otherwise, use null string value.
                    */
                    NdisMoveMemory(&pReturnedValue->ParameterData.StringData,
                                   &g_NullString,
                                   sizeof(g_NullString));
                }
            }

            /*
            // Assume the string is ANSI and points to the string data
            // structure.  We can get away with this because ANSI and
            // UNICODE strings have a common structure header.  An extra
            // character is allocated to make room for a null terminator.
            */
            pAnsi = (PANSI_STRING) (BaseContext+pParameter->Offset);
            Length = pReturnedValue->ParameterData.StringData.Length+1;

            /*
            // The caller wants a UNICODE string returned, we have to
            // allocated twice as many bytes to hold the result.
            // NOTE:
            // This wouldn't be necessary if NDIS would always return
            // a UNICODE string, but some Win95 versions of NDIS return
            // an ANSI string, so Length will be too small for UNICODE.
            // The down-side is that we may allocate twice as much as
            // we need to hold the string.  (oh well)
            */
            if (pParameter->Flags == PARAM_FLAGS_UNICODESTRING)
            {
                Length *= sizeof(WCHAR);
            }

            /*
            // Allocate memory for the string.
            */
#if !defined(NDIS50_MINIPORT)
            Status = NdisAllocateMemory(
                            (PVOID *) &(pAnsi->Buffer),
                            Length,
                            0,
                            g_HighestAcceptableAddress
                            );
#else  // NDIS50_MINIPORT
            Status = NdisAllocateMemoryWithTag(
                            (PVOID *) &(pAnsi->Buffer),
                            Length,
                            __FILEID__
                            );
#endif // NDIS50_MINIPORT

            if (Status != NDIS_STATUS_SUCCESS)
            {
                /*
                // Log error message and exit.
                */
                DBG_ERROR(DbgInfo,("NdisAllocateMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                          Length, __FILE__, __LINE__, Status));

                NdisWriteErrorLogEntry(
                        AdapterHandle,
                        NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                        4,
                        Status,
                        Length,
                        __FILEID__,
                        __LINE__
                        );
                NdisCloseConfiguration(ConfigHandle);
                return NDIS_STATUS_FAILURE;
            }
            else
            {
                DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                           ("NdisAllocateMemory(Size=%d, Ptr=0x%x)\n",
                            Length, pAnsi->Buffer));
            }
            /*
            // Zero the string buffer to start with.
            */
            ASSERT(pAnsi->Buffer);
            NdisZeroMemory(pAnsi->Buffer, Length);
            pAnsi->MaximumLength = (USHORT) Length;

            if (pParameter->Flags == PARAM_FLAGS_ANSISTRING)
            {
                /*
                // The caller wants an ANSI string returned, so we convert
                // it from UNICODE to ANSI.
                */
                ParamUnicodeStringToAnsiString(
                        pAnsi,
                        (PUNICODE_STRING) &(pReturnedValue->ParameterData.StringData)
                        );
#if DBG
                if (ParamType == NdisParameterMultiString)
                    {
                    USHORT        ct = 0;

                    while (ct < pAnsi->Length)
                        {
                        DBG_PARAMS(DbgInfo,("%s: ANSI='%s' Len=%d of %d\n",
                            ansiRegName,
                            &(pAnsi->Buffer[ct]),
                            (strlen(&(pAnsi->Buffer[ct]))),
                            pAnsi->Length));

                        ct = ct + (strlen(&(pAnsi->Buffer[ct])) + 1);
                        }
                    }
                else
                    {
                    DBG_PARAMS(DbgInfo,("%s: ANSI='%s' Len=%d\n",
                           ansiRegName, pAnsi->Buffer, pAnsi->Length));
                    }
#endif
            }
            else // PARAM_FLAGS_UNICODESTRING
            {
                /*
                // The caller wants a UNICODE string returned, so we can
                // just copy it.  The pAnsi buffer was allocated large
                // enough to hold the UNICODE string.
                */
                ParamUnicodeCopyString(
                        (PUNICODE_STRING) pAnsi,
                        (PUNICODE_STRING) &(pReturnedValue->ParameterData.StringData)
                        );
#if DBG
                if (ParamType == NdisParameterMultiString)
                    {
                    USHORT        ct = 0;

                    BREAKPOINT;

                    while (ct < (pAnsi->Length / 2))
                        {
                        DBG_PARAMS(DbgInfo,("%s: UNICODE='%ls' Len=%d of %d\n",
                           ansiRegName,
                           &((PUSHORT)pAnsi->Buffer)[ct],
                           (ustrlen(&((PUSHORT)pAnsi->Buffer)[ct]) * 2),
                           pAnsi->Length));

                        ct = ct + (ustrlen(&((PUSHORT)pAnsi->Buffer)[ct]) + 1);
                        }
                    }
                else
                    {
                    DBG_PARAMS(DbgInfo,("%s: UNICODE='%ls' Len=%d\n",
                               ansiRegName, pAnsi->Buffer, pAnsi->Length));
                    }
#endif

            }
        }
        else
        {
            /*
            // Report a bogus parameter type in the caller's table.
            */
            DBG_ERROR(DbgInfo,("Invalid ParamType=%d '%s'\n",
                      ParamType, ansiRegName));

            NdisCloseConfiguration(ConfigHandle);
            return NDIS_STATUS_FAILURE;
        }
    }
    NdisCloseConfiguration(ConfigHandle);
    return(NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\tpimem.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiMem TpiMem_h

@module TpiMem.h |

    This module defines the interface to the memory allocation wrappers.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiMem_h

@end

*/

#ifndef _TPIMEM_H
#define _TPIMEM_H

#include <ndis.h>

#define TPIMEMORY_OBJECT_TYPE           ((ULONG)'T')+\
                                        ((ULONG)'M'<<8)+\
                                        ((ULONG)'E'<<16)+\
                                        ((ULONG)'M'<<24)

#define ALLOCATE_MEMORY(pObject, dwSize, MiniportAdapterHandle)\
            TpiAllocateMemory((PVOID *)&(pObject), dwSize,\
                              __FILEID__, __FILE__, __LINE__,\
                              MiniportAdapterHandle)

#define FREE_MEMORY(pObject, dwSize)\
            TpiFreeMemory((PVOID *)&(pObject), dwSize,\
                          __FILEID__, __FILE__, __LINE__)

#define ALLOCATE_OBJECT(pObject, MiniportAdapterHandle)\
            ALLOCATE_MEMORY(pObject, sizeof(*(pObject)), MiniportAdapterHandle)

#define FREE_OBJECT(pObject)\
            FREE_MEMORY(pObject, sizeof(*(pObject)))

#define FREE_NDISSTRING(ndisString)\
            FREE_MEMORY(ndisString.Buffer, ndisString.MaximumLength)

NDIS_STATUS TpiAllocateMemory(
    OUT PVOID *                 ppObject,
    IN ULONG                    dwSize,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber,
    IN NDIS_HANDLE              MiniportAdapterHandle
    );

void TpiFreeMemory(
    IN OUT PVOID *              ppObject,
    IN ULONG                    dwSize,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

NDIS_STATUS TpiAllocateSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN ULONG                    dwSize,
    IN BOOLEAN                  bCached,
    OUT PVOID *                 pVirtualAddress,
    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

void TpiFreeSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN ULONG                    dwSize,
    IN BOOLEAN                  bCached,
    OUT PVOID *                 pVirtualAddress,
    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

extern NDIS_PHYSICAL_ADDRESS g_HighestAcceptableAddress;

#endif // _TPIMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\vlang.h ===
// Define the language and sublanguge supported by your program.
#define VER_LANGUAGE_NUM                0x0409
#define VER_SUBLANGUAGE_NUM             0x04B0
// Concatenate the two, 4 digit hex numbers above.
#define VER_LANGUAGE_STRING             "040904B0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\tpiparam.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiParam TpiParam_h

@module TpiParam.h |

    This module, along with <f TpiParam\.c>, implements a table driven parser
    for the NDIS registry parameters.  This file defines the parameter
    parsing structures and values used by the routine <f ParamParseRegistry>.
    You should #include this file into the driver module defining the
    configuration parameter table <t PARAM_TABLE>.

@comm

    See <f Keywords\.h> for details of how to add new parameters.

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiParam_h

@end

*/

#ifndef _TPIPARAM_H
#define _TPIPARAM_H

#if !defined(NDIS_NT) && !defined(UNICODE_NULL)

/*
// These types were culled from the NT ndis.h file
// We should be compiling with the NT DDK's ndis.h to get these,
// but sometimes we need to compile with the 95 DDK ndis.h.
*/

#undef PUNICODE_STRING
typedef USHORT  WCHAR;
typedef WCHAR   *PWSTR;

typedef STRING  ANSI_STRING;
typedef PSTRING PANSI_STRING;

/*
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
*/

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

#endif // NDIS_NT

/* @doc INTERNAL TpiParam TpiParam_h PARAM_ENTRY


@func <t PARAM_TABLE> | PARAM_ENTRY |

    This macro is used to define an entry in the registry parameter table,
    one entry per parameter.  See <t PARAM_TABLE> for more details on the
    expected input values.

@parm struct | Strct | The structure type associated with <f Field>.

@parm type | Field | The name of the field within the structure <f Strct>.

@parm const char * | Name | The name of the registry parameter key.

@parm BOOL | Required | True if parameter is required.

@parm NDIS_PARAMETER_TYPE | Type | The kind of parameter value.

@parm UCHAR | Flags | How to return a string parameter value (ANSI, UNICODE).

@parm UINT | Default | The default value for an undefined integer parameter.

@parm UINT | Min | The minimum value for an integer parameter.

@parm UINT | Max | The minimum value for an integer parameter.

@comm
    Parameters that need to be stored in different data structures, need to
    be declared in separate parameter tables, and then parsed separately
    using mulitple calls to <f ParamParseRegistry>.

@iex
    PARAM_TABLE ParameterTable[] =
    {
        PARAM_ENTRY(MINIPORT_CONTEXT, DbgFlags, PARAM_DEBUGFLAGS_STRING,
                    FALSE, NdisParameterHexInteger, 0,
                    DBG_ERROR_ON|DBG_WARNING_ON, 0, 0xffffffff),
        // The last entry must be an empty string!
        { { 0 } }
    };

@normal
*/
#define PARAM_OFFSET(Strct, Field) ((ULONG)(ULONG_PTR)&(((Strct *)0)->Field))
#define PARAM_SIZEOF(Strct, Field) sizeof(((Strct *) 0)->Field)
#define PARAM_ENTRY(Strct, Field, Name, \
                    Required, Type, Flags, \
                    Default, Min, Max) \
    { NDIS_STRING_CONST(Name), \
      Required, \
      Type, \
      Flags, \
      PARAM_SIZEOF(Strct, Field), \
      PARAM_OFFSET(Strct, Field), \
      (PVOID) (Default), \
      Min, \
      Max }


/* @doc INTERNAL TpiParam TpiParam_h PARAM_TABLE


@struct PARAM_TABLE |
    This structure defines how a parameter is to be parsed from the Windows
    registry.  The driver declares an array of these parameter records and
    passes it to <f ParamParseRegistry> during initialization.  The values
    for each parameter are then read from the registry and can be used to
    configure the driver.
    <nl>
    <f Note>: Multiple parameter tables can be used to parse parameters that
    must be stored in different memory locations.
*/
typedef struct PARAM_TABLE
{
    NDIS_STRING     RegVarName; // @field
    // Parameter name string declared as an <t NDIS_STRING>.  The registry
    // parameter key must match this string.

    UCHAR           Mandantory; // @field
    // Set to FALSE, zero, if parameter value is optional; otherwise set to
    // TRUE, non-zero, if the parameter is required to exist in the registry.
    // If FALSE, and the parameter does not exist, the <y Default> value will
    // be returned.  If TRUE, and the parameter does not exist, an error code
    // is returned and no further parsing is done.

    UCHAR           Type;       // @field
    // This value determines how the parameter will be parsed from the
    // registry.  The value can be one of the following values defined
    // by <t NDIS_PARAMETER_TYPE>.
    // <nl>0=NdisParameterInteger - Decimal integer value.
    // <nl>1=NdisParameterHexInteger - Hexadecimal integer value.
    // <nl>2=NdisParameterString - Single UNICODE string value.
    // <nl>3=NdisParameterMultiString - Multiple UNICODE string values.
    // These are returned as a list of N strings, separated by NULL
    // terminators, the last string is followed by two NULL terminators.

    UCHAR           Flags;      // @field
    // This value determines how a string parameter will be translated before
    // it is returned to the caller.  <f Flags> can be one of the following
    // values:
    // <nl>0=PARAM_FLAGS_ANSISTRING - Return string value as an ANSI string.
    // <nl>0=PARAM_FLAGS_ANSISTRING - Return string value as a UNICODE string.
#   define          PARAM_FLAGS_ANSISTRING      0
#   define          PARAM_FLAGS_UNICODESTRING   1

    UCHAR           Size;       // @field
    // This value determines how an integer parameter will be translated
    // before it is returned to the caller.  <f Size> can be one of the
    // following values:
    // <nl>0=UINT   - unsigned integer (16 or 32 bits).
    // <nl>1=UCHAR  - unsigned char integer (8 bits).
    // <nl>2=USHORT - unsigned short integer (16 bits).
    // <nl>4=ULONG  - unsigned long integer (32 bits).
    // <f Note>: The most-significant bits will be truncated in the conversion.

    UINT            Offset;     // @field
    // This value indicates the offset, in bytes, from the <f BaseContext>
    // pointer passed into <f ParamParseRegistry>.  The return value for
    // the parameter will be saved at this offset from <f BaseContext>.
    // <nl>*(PUINT)((PUCHAR)BaseContext+Offset) = (UINT) Value;

    PVOID           Default;    // @field
    // This value is used as the default value for the parameter if it is
    // not found in the registry, and it is not mandatory.  This only applys
    // to integer parameters.  String parameters must provide support for
    // their own default values.

    UINT            Min;        // @field
    // If this value is non-zero, and the parameter is an integer type, the
    // registry value will be compared to make sure it is \>= <f Min>.
    // If the registry value is less, the returned value will be set to
    // <f Min> and no error is returned.

    UINT            Max;        // @field
    // If this value is non-zero, and the parameter is an integer type, the
    // registry value will be compared to make sure it is \<= <f Max>.
    // If the registry value is greater, the returned value will be set to
    // <f Max> and no error is returned.

    UINT            Reserved;   // @field
    // This field is not currently used, and it must be zero for future
    // compatability.

} PARAM_TABLE, *PPARAM_TABLE;

extern USHORT ustrlen(
    IN PUSHORT          string
    );

extern NDIS_STATUS ParamParseRegistry(
    IN NDIS_HANDLE      AdapterHandle,
    IN NDIS_HANDLE      RegistryConfigHandle,
    IN PUCHAR           BaseContext,
    IN PPARAM_TABLE     Parameters
    );

extern VOID ParamUnicodeStringToAnsiString(
    OUT PANSI_STRING out,
    IN PUNICODE_STRING in
    );

extern VOID ParamUnicodeCopyString(
    OUT PUNICODE_STRING out,
    IN PUNICODE_STRING in
    );

#endif // _TPIPARAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\transmit.c ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Transmit Transmit_c

@module Transmit.c |

    This module implements the Miniport packet Transmit routines. This module is
    very dependent on the hardware/firmware interface and should be looked at
    whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Transmit_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.3 Sending Packets |

    To send packets over the network, a connection-oriented client or call
    manger calls NdisCoSendPackets. A connection-oriented client associated with
    an MCM also calls NdisCoSendPackets. An MCM, however, never calls
    NdisCoSendPackets; instead, since the interface between the call manager and
    MCM is internal to the MCM, the MCM passes packets directly to the NIC
    without notifying NDIS.

@ex Sending packets through an MCM |

    NdisWan                           NDIS                        Miniport
    |----------------------------------|----------------------------------|
    |  NdisCoSendPackets               |                                  |
    |---------------------------------|                                  |
    |                                  |  MiniportCoSendPackets           |
    |                                  |---------------------------------|
    |                                  |            .                     |
    |                                  |            .                     |
    |                                  |            .                     |
    |                                  |  NdisMCoSendComplete             |
    |                                  |---------------------------------|
    |  ProtocolCoSendComplete          |                                  |
    |---------------------------------|                                  |
    |----------------------------------|----------------------------------|

@normal

    MiniportCoSendPackets should transmit each packet in the array sequentially,
    preserving the order of packets in the array. MiniportCoSendPackets can call
    NdisQueryPacket to extract information, such as the number of buffer
    descriptors chained to the packet and the total size in bytes of the
    requested transfer.

    MiniportCoSendPackets can call NdisGetFirstBufferFromPacket,
    NdisQueryBuffer, or NdisQueryBufferOffset to extract information about
    individual buffers containing the data to be transmitted.
    MiniportCoSendPackets can retrieve protocol-supplied OOB information
    associated with each packet by using the appropriate NDIS_GET_PACKET_XXX
    macros. The MiniportCoSendPackets function usually ignores the Status member
    of the NDIS_PACKET_OOB_DATA block, but it can set this member to the same
    status that it subsequently passes to NdisMCoSendComplete.

    Rather than relying on NDIS to queue and resubmit send packets whenever
    MiniportCoSendPackets has insufficient resources to transmit the given
    packets, a connection-oriented miniport manages its own internal packet
    queueing. The miniport must hold incoming send packets in its internal queue
    until they can be transmitted over the network. This queue preserves the
    protocol-determined ordering of packet descriptors incoming to the
    miniport's MiniportCoSendPackets function.

    A connection-oriented miniport must complete each incoming send packet with
    NdisMCoSendComplete. It cannot call NdisMSendResourcesAvailable. A
    connection-oriented miniport should never pass STATUS_INSUFFICIENT_RESOURCES
    to NdisMCoSendComplete with a protocol-allocated packet descriptor that was
    originally submitted to its MiniportCoSendPackets function.

    The call to NdisMCoSendComplete causes NDIS to call the
    ProtocolCoSendComplete function of the client that initiated the send
    operation. ProtocolCoSendComplete performs any postprocessing necessary for
    a completed transmit operation, such as notifying the client that originally
    requested the protocol to send data over the network on the VC.

    Completion of a send operation usually implies that the underlying NIC
    driver actually has transmitted the given packet over the network. However,
    the driver of an "intelligent" NIC can consider a send complete as soon as
    it downloads the net packet to its NIC.

    Although NDIS always submits protocol-supplied packet arrays to the
    underlying miniport in the protocol-determined order passed in calls to
    NdisCoSendPackets, the underlying driver can complete the given packets in
    random order. That is, every bound protocol can rely on NDIS to submit the
    packets the protocol passes to NdisCoSendPackets in FIFO order to the
    underlying driver, but no protocol can rely on that underlying driver to
    call NdisMCoSendComplete with those packets in the same order.

@end
*/

#define  __FILEID__             TRANSMIT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 9x wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Transmit Transmit_c TransmitAddToQueue


@func

    <f TransmitAddToQueue> places the packet on the transmit queue.  If the
    queue was empty to begin with, TRUE is returned so the caller can kick
    start the transmiter.

@rdesc

    <f TransmitAddToQueue> returns TRUE if this is the only entry in the
    list, FALSE otherwise.

*/

DBG_STATIC BOOLEAN TransmitAddToQueue(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_PACKET             pNdisPacket                 // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_PACKET>.
    )
{
    DBG_FUNC("TransmitAddToQueue")

    BOOLEAN                     ListWasEmpty;
    // Note if the list is empty to begin with.

    DBG_ENTER(pAdapter);

    /*
    // Place the packet on the TransmitPendingList.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);
    *((PBCHANNEL_OBJECT *) &pNdisPacket->MiniportReservedEx[8]) = pBChannel;
    ListWasEmpty = IsListEmpty(&pAdapter->TransmitPendingList);
    InsertTailList(&pAdapter->TransmitPendingList,
                   GET_QUEUE_FROM_PACKET(pNdisPacket));
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    DBG_RETURN(pAdapter, ListWasEmpty);
    return (ListWasEmpty);
}


/* @doc INTERNAL Transmit Transmit_c TransmitPacketHandler


@func

    <f TransmitPacketHandler> removes an entry from the TransmitPendingList
    and places the packet on the appropriate B-channel and starts the
    transmission.  The packet is then placed on the <t TransmitBusyList> to
    await a transmit complete event processed by <f TransmitCompleteHandler>.

@comm

    The packets go out in a FIFO order for the entire driver, independent of
    the channel on which it goes out.  This means that a slow link, or one
    that is backed up can hold up all other channels.  There is no good way
    to get around this because we must to deliver packets in the order they
    are given to the Miniport, regardless of the link they are on.

*/

DBG_STATIC VOID TransmitPacketHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("TransmitPacketHandler")

    PNDIS_PACKET                pNdisPacket;
    // Holds the packet being transmitted.

    UINT                        BytesToSend;
    // Tells us how many bytes are to be transmitted.

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);

    /*
    // MUTEX to protect against async EventHandler access at the same time.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);

#if DBG
    {   // Sanity check!
        PLIST_ENTRY pList = &pAdapter->TransmitPendingList;
        ASSERT(pList->Flink && pList->Flink->Blink == pList);
        ASSERT(pList->Blink && pList->Blink->Flink == pList);
    }
#endif // DBG

    /*
    // This might be called when no packets are queued!
    */
    while (!IsListEmpty(&pAdapter->TransmitPendingList))
    {
        PLIST_ENTRY                 pList;
        /*
        // Remove the packet from the TransmitPendingList.
        */
        pList = RemoveHeadList(&pAdapter->TransmitPendingList);
        pNdisPacket = GET_PACKET_FROM_QUEUE(pList);

        /*
        // Release MUTEX
        */
        NdisReleaseSpinLock(&pAdapter->TransmitLock);

        /*
        // Retrieve the information we saved in the packet reserved fields.
        */
        pBChannel = *((PBCHANNEL_OBJECT *) &pNdisPacket->MiniportReservedEx[8]);
        ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

        /*
        // Make sure the link is still up and can accept transmits.
        */
        if (pBChannel->CallState != LINECALLSTATE_CONNECTED)
        {
            /*
            // Indicate send complete failure to the NDIS wrapper.
            */
            DBG_WARNING(pAdapter,("Flushing send on channel #%d (Packet=0x%X)\n",
                        pBChannel->ObjectID, pNdisPacket));
            if (pBChannel->NdisVcHandle)
            {
                NdisMCoSendComplete(NDIS_STATUS_FAILURE,
                                    pBChannel->NdisVcHandle,
                                    pNdisPacket
                                    );
            }

            /*
            // Reacquire MUTEX
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
        }
        else
        {
            NdisQueryPacket(pNdisPacket,
                            NULL,
                            NULL,
                            NULL,
                            &BytesToSend);
            pAdapter->TotalTxBytes += BytesToSend;
            pAdapter->TotalTxPackets++;

            /*
            // Attempt to place the packet on the NIC for transmission.
            */
            if (!CardTransmitPacket(pAdapter->pCard, pBChannel, pNdisPacket))
            {
                /*
                // ReQueue the packet on the TransmitPendingList and leave.
                // Reacquire MUTEX
                */
                NdisAcquireSpinLock(&pAdapter->TransmitLock);
                InsertTailList(&pAdapter->TransmitPendingList,
                               GET_QUEUE_FROM_PACKET(pNdisPacket));
                break;
            }

            /*
            // Reacquire MUTEX
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
        }
    }
    /*
    // Release MUTEX
    */
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Transmit Transmit_c TransmitCompleteHandler


@func

    <f TransmitCompleteHandler> is called by <f MiniportTimer> to handle a
    transmit complete event.  We walk the <t TransmitCompleteList> to find
    all the packets that have been sent out on the wire, and then tell the
    protocol stack that we're done with the packet, and it can be re-used.

*/

VOID TransmitCompleteHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("TransmitCompleteHandler")

    PNDIS_PACKET                pNdisPacket;
    // Holds the packet that's just been transmitted.

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (++(pAdapter->NestedDataHandler) > 1)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d > 1\n",
                  pAdapter->NestedDataHandler));
    }

    /*
    // MUTEX to protect against async EventHandler access at the same time.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);

#if DBG
    {   // Sanity check!
        PLIST_ENTRY pList = &pAdapter->TransmitCompleteList;
        ASSERT(pList->Flink && pList->Flink->Blink == pList);
        ASSERT(pList->Blink && pList->Blink->Flink == pList);
    }
#endif // DBG

    while (!IsListEmpty(&pAdapter->TransmitCompleteList))
    {
        PLIST_ENTRY                 pList;
        /*
        // Remove the packet from the TransmitCompleteList.
        */
        pList = RemoveHeadList(&pAdapter->TransmitCompleteList);
        pNdisPacket = GET_PACKET_FROM_QUEUE(pList);

        /*
        // Release MUTEX
        */
        NdisReleaseSpinLock(&pAdapter->TransmitLock);

        /*
        // Retrieve the information we saved in the packet reserved fields.
        */
        pBChannel = *((PBCHANNEL_OBJECT *) &pNdisPacket->MiniportReservedEx[8]);
        *((PBCHANNEL_OBJECT *) &pNdisPacket->MiniportReservedEx[8]) = NULL;
        ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

        /*
        // Indicate send complete to the NDIS wrapper.
        */
        DBG_TXC(pAdapter, pBChannel->ObjectID);
        NdisMCoSendComplete(NDIS_STATUS_SUCCESS,
                            pBChannel->NdisVcHandle,
                            pNdisPacket
                            );

        /*
        // Reacquire MUTEX
        */
        NdisAcquireSpinLock(&pAdapter->TransmitLock);
    }
    /*
    // Release MUTEX
    */
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    /*
    // Start any other pending transmits.
    */
    TransmitPacketHandler(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (--(pAdapter->NestedDataHandler) < 0)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d < 0\n",
                  pAdapter->NestedDataHandler));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Transmit Transmit_c FlushSendPackets


@func

    <f FlushSendPackets> is called by <f MiniportTimer> to handle a
    transmit complete event.  We walk the <t TransmitCompleteList> to find
    all the packets that have been sent out on the wire, and then tell the
    protocol stack that we're done with the packet, and it can be re-used.

*/

VOID FlushSendPackets(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    PBCHANNEL_OBJECT            pBChannel                   // @parm
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.
    )
{
    DBG_FUNC("FlushSendPackets")

    PLIST_ENTRY                 pList;

    DBG_ENTER(pAdapter);

    // Move all outstanding packets to the complete list.
    NdisAcquireSpinLock(&pAdapter->TransmitLock);
    while (!IsListEmpty(&pBChannel->TransmitBusyList))
    {
        pList = RemoveHeadList(&pBChannel->TransmitBusyList);
        InsertTailList(&pBChannel->pAdapter->TransmitCompleteList, pList);
    }
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    // This will complete all the packets now on the TransmitCompleteList,
    // and will fail any remaining packets left on the TransmitPendingList.
    TransmitCompleteHandler(pAdapter);

    DBG_LEAVE(pAdapter);
}


/* @doc EXTERNAL INTERNAL Transmit Transmit_c MiniportCoSendPackets


@func

    <f MiniportCoSendPackets> is a required function for connection-oriented
    miniports. MiniportCoSendPackets is called to transfer some number of
    packets, specified as an array of pointers, over the network.

@comm

    MiniportCoSendPackets is called by NDIS in response to a request by a bound
    protocol driver to send a ordered list of data packets across the network.

    MiniportCoSendPackets should transmit each packet in any given array
    sequentially. MiniportCoSendPackets can call NdisQueryPacket to extract
    information, such as the number of buffer descriptors chained to the packet
    and the total size in bytes of the requested transfer. It can call
    NdisGetFirstBufferFromPacket, NdisQueryBuffer, or NdisQueryBufferOffset to
    extract information about individual buffers containing the data to be
    transmitted.

    MiniportCoSendPackets can retrieve protocol-supplied out-of-band information
    associated with each packet by using the appropriate NDIS_GET_PACKET_XXX
    macros.

    MiniportCoSendPackets can use only the eight-byte area at MiniportReserved
    within the NDIS_PACKET structure for its own purposes.

    The NDIS library ignores the OOB block in all packet descriptors it submits
    to MiniportCoSendPackets and assumes that every connection-oriented miniport
    is a deserialized driver that will complete each input packet descriptor
    asynchronously with NdisMCoSendComplete. Consequently, such a deserialized
    driver's MiniportCoSendPackets function usually ignores the Status member of
    the NDIS_PACKET_OOB_DATA block, but it can set this member to the same
    status as it subsequently passes to NdisMCoSendComplete.

    Rather than relying on NDIS to queue and resubmit send packets whenever
    MiniportCoSendPackets has insufficient resources to transmit the given
    packets, a deserialized miniport manages its own internal packet queueing.
    Such a driver is responsible for holding incoming send packets in its
    internal queue until they can be transmitted over the network and for
    preserving the protocol-determined ordering of packet descriptors incoming
    to its MiniportCoSendPackets function. A deserialized miniport must complete
    each incoming send packet with NdisMCoSendComplete, and it cannot call
    NdisMSendResourcesAvailable.

    A deserialized miniport should never pass STATUS_INSUFFICIENT_RESOURCES to
    NdisMCoSendComplete with a protocol-allocated packet descriptor that was
    originally submitted to its MiniportCoSendPackets function. Such a returned
    status effectively fails the send operation requested by the protocol, and
    NDIS would return the packet descriptor and all associated resources to the
    protocol that originally allocated it.

    MiniportCoSendPackets can be called at any IRQL \<= DISPATCH_LEVEL.
    Consequently, MiniportCoSendPackets function is responsible for
    synchronizing access to its internal queue(s) of packet descriptors with the
    driver's other MiniportXxx functions that also access the same queue(s).

@xref

    <f ProtocolCoCreateVc>, <f MiniportCoRequest>, <f MiniportInitialize>,
    NdisAllocatePacket, NdisCoSendPackets, NdisGetBufferPhysicalArraySize,
    NdisGetFirstBufferFromPacket, NdisGetNextBuffer,
    NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO, NDIS_GET_PACKET_TIME_TO_SEND,
    NdisMCoSendComplete, NdisMoveMemory, NdisMoveToMappedMemory,
    NdisMSendResourcesAvailable, NdisMSetupDmaTransfer,
    NdisMStartBufferPhysicalMapping, NDIS_OOB_DATA_FROM_PACKET, NDIS_PACKET,
    NDIS_PACKET_OOB_DATA, NdisQueryBuffer, NdisQueryBufferOffset,
    NdisQueryPacket, NdisZeroMemory
*/

VOID MiniportCoSendPackets(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> instance returned by
    // <f ProtocolCoCreate>.  AKA MiniportVcContext.<nl>
    // Specifies the handle to a miniport-allocated context area in which the
    // miniport maintains its per-VC state. The miniport supplied this handle
    // to NDIS from its <f ProtocolCoCreateVc> function.

    IN PPNDIS_PACKET            PacketArray,                // @parm
    // Points to the initial element in a packet array, with each element
    // specifying the address of a packet descriptor for a packet to be
    // transmitted, along with an associated out-of-band data block containing
    // information such as the packet priority, an optional timestamp, and the
    // per-packet status to be set by MiniportCoSendPackets.

    IN UINT                     NumberOfPackets             // @parm
    // Specifies the number of pointers to packet descriptors at PacketArray.
    )
{
    DBG_FUNC("MiniportCoSendPackets")

    UINT                        BytesToSend;
    // Tells us how many bytes are to be transmitted.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    UINT                        Index;

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = pBChannel->pAdapter;
    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    if (pBChannel->CallClosing)
    {
        DBG_ERROR(pAdapter,("BChannel Closed\n"));
    }

    for (Index = 0; Index < NumberOfPackets; Index++)
    {
        /*
        // Return if call has been closed.
        */
        if (pBChannel->CallClosing)
        {
            NDIS_SET_PACKET_STATUS(PacketArray[Index], NDIS_STATUS_CLOSED);
            continue;
        }

        NdisQueryPacket(PacketArray[Index], NULL, NULL, NULL, &BytesToSend);

        /*
        // Make sure the packet size is something we can deal with.
        */
        if ((BytesToSend == 0) || (BytesToSend > pAdapter->pCard->BufferSize))
        {
            DBG_ERROR(pAdapter,("Bad packet size = %d\n",BytesToSend));
            NdisMCoSendComplete(NDIS_STATUS_INVALID_PACKET,
                                pBChannel->NdisVcHandle,
                                PacketArray[Index]
                                );
        }
        else
        {
            /*
            // We have to accept the frame if possible, I just want to know
            // if somebody has lied to us...
            */
            if (BytesToSend > pBChannel->WanLinkInfo.MaxSendFrameSize)
            {
                DBG_NOTICE(pAdapter,("Channel #%d  Packet size=%d > %d\n",
                           pBChannel->ObjectID, BytesToSend,
                           pBChannel->WanLinkInfo.MaxSendFrameSize));
            }

            /*
            // Place the packet in the transmit list.
            */
            if (TransmitAddToQueue(pAdapter, pBChannel, PacketArray[Index]) &&
                pAdapter->NestedDataHandler < 1)
            {
                /*
                // The queue was empty so we've gotta kick start it.
                // Once it's going, it runs off the DPC.
                //
                // No kick start is necessary if we're already running the the
                // TransmitCompleteHandler -- In fact, it will screw things up if
                // we call TransmitPacketHandler while TransmitCompleteHandler is
                // running.
                */
                TransmitPacketHandler(pAdapter);
            }
        }
        NDIS_SET_PACKET_STATUS(PacketArray[Index], NDIS_STATUS_PENDING);
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\vprodnum.h ===
// WARNING --- DO NOT CHANGE THIS FILE --- WARNING
// It is updated automatically by the TpiBuild procedure using VerInc.exe.
#define VER_PRODUCT_MAJOR_NUM      0
#define VER_PRODUCT_MINOR_NUM      7
#define VER_PRODUCT_SUB_MINOR_NUM  0
#define VER_PRODUCT_BUILD_NUM      30
#define VER_PRODUCT_MAJOR_STR      "0"
#define VER_PRODUCT_MINOR_STR      "07"
#define VER_PRODUCT_SUB_MINOR_STR  "00"
#define VER_PRODUCT_BUILD_STR      "0030"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\vtarget.h ===
/*


    (C) Copyright 1999
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiBuild vTarget vTarget_h

@module vTarget.h |

    This module defines the version information as displayed in the Windows
    file property sheet.  You must change the fields below as appropriate
    for your target.  This file is then included by <f vTarget\.rc> to
    define the necessary elements of the target file's version resource.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vTarget_h

@end

*/

#ifndef _VTARGET_H_
#define _VTARGET_H_

// The following file should be included from the project's include directory
#include <vProduct.h>   // Product specific information

// Base name of this target.
#define VER_TARGET_STR                  VER_PRODUCT_STR
// File name this target is distributed under.
#define VER_ORIGINAL_FILE_NAME_STR      DEFINE_STRING(VER_TARGET_STR ".sys")
// Description displayed in the Windows file property sheet - limit to 40 characters.
#define VER_FILE_DESCRIPTION_STR        DEFINE_STRING(VER_PRODUCT_STR \
                                        " NDIS WAN/TAPI Miniport for Windows.")
// Take credit for a job well done...
#define VER_INTERNAL_NAME_STR           "larryh@tpi.com"
// Look in winver.h for the proper settings of these values.
#define VER_FILE_OS                     VOS__WINDOWS32      // dwFileOS
#define VER_FILE_TYPE                   VFT_DRV             // dwFileType
#define VER_FILE_SUB_TYPE               VFT2_DRV_NETWORK    // dwFileSubtype

#endif // _VTARGET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\vproduct.h ===
/*

                                                                             
    (C) Copyright 1999 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiBuild vProduct vProduct_h

@module vProduct.h |

    This module defines the product version information.  It is included by 
    all the target components of the project by including <f vTarget\.h>.

    <f Note>:
    This file should not be changed.  The definitions used by this file 
    are defined in <f vVendor\.h>, <f vTarget\.h>, <f vProdNum\.h>, and 
    <f vTargNum\.h>

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vProduct_h

@end

*/

/* @doc EXTERNAL INTERNAL


@topic Versioning Overview |

    This section describes the interfaces defined in <f vProduct\.h>,
    <f vVendor\.h>, <f vTarget\.h>, <f vProdNum\.h>, and <f vTargNum\.h>

    A module is usually just one component of an entire product, so we've
    defined the versioning information for the module so that it can be
    easily included into a complete product package.
    
@flag <f vTarget\.rc> |
    Included this into your module specific rc file.  Do not change.
    You must remove any existing versioning information from your rc file.
    Place this file in a common include directory for the product.

@flag <f vTarget\.h> |
    Defines the module specific version information such as file name, type, etc.
    One of these files would exist for each component included in your product.

@flag <f vTargNum\.h> |
    Is meant to be updated whenever you make a change to a specific module.
    One of these files would exist for each component included in your product.
    This is separated from the rest of the versioning files so it can be easily 
    updated with a tool or script.
    
@flag <f vVendor\.h> |
    Defines the vendor specific version information such as company name,
    copyright. etc.  It is separate to allow easier OEM customization.
    Place this file in a common include directory for the product.
    
@flag <f vProdNum\.h> |
    Is meant to be updated whenever you release a new product version.
    This is separated from the rest of the versioning files so it can be easily 
    updated with a tool or script.
    Place this file in a common include directory for the product.
    
@flag <f vLang\.h> |
    Defines the language to be used to record the version information.
    If this file is modified for another language, you will generally have 
    to create localized versions of the vVendor.h and vTarget.h files as well.
    Place this file in a common include directory for the product.
    
@flag <f vProduct\.rc> |
    Is included by <f vTarget\.rc>.  Do not change.
    Place this file in a common include directory for the product.

@flag <f vProduct\.h> |
    Is included by <f vTarget\.h>.  You should not change this file unless you
    want to change the way version numbers are represented for all modules in
    your product.
    Place this file in a common include directory for the product.

*/

#ifndef _VPRODUCT_H_
#define _VPRODUCT_H_

#if !defined(_VTARGET_H_)
#  error You should not include vProduct.h directly, include vTarget.h instead.
#endif

// Only include winver.h if RC_INVOKED.  Otherwise we don't need it.
#if defined(RC_INVOKED)
# if defined(WIN32)
#  include <winver.h>
# else
#  include <ver.h>
# endif
#endif

#include "vVendor.h"    // Edit this file to change vendor specific information
#include "vLang.h"      // Edit this file to change language specific information

// The following file should be included from the target's include directory
#include "vTargNum.h"   // Target version information

#if !defined(VER_FILE_MAJOR_NUM) || !defined(VER_FILE_MINOR_NUM) || \
    !defined(VER_FILE_SUB_MINOR_NUM)
#  error Your vTargNum.h file is corrupt or missing required VER_xxx_NUM fields.
#endif
#if !defined(VER_FILE_MAJOR_STR) || !defined(VER_FILE_MINOR_STR) || \
    !defined(VER_FILE_SUB_MINOR_STR)
#  error Your vTargNum.h file is corrupt or missing required VER_xxx_STR fields.
#endif

// The following file should be included from the project's include directory
#include "vProdNum.h"   // Product version and build information

#if !defined(VER_PRODUCT_MAJOR_NUM) || !defined(VER_PRODUCT_MINOR_NUM) || \
    !defined(VER_PRODUCT_SUB_MINOR_NUM) || !defined(VER_PRODUCT_BUILD_NUM)
#  error Your vProdNum.h file is corrupt or missing required VER_xxx_NUM fields.
#endif
#if !defined(VER_PRODUCT_MAJOR_STR) || !defined(VER_PRODUCT_MINOR_STR) || \
    !defined(VER_PRODUCT_SUB_MINOR_STR) || !defined(VER_PRODUCT_BUILD_STR)
#  error Your vProdNum.h file is corrupt or missing required VER_xxx_STR fields.
#endif

// Macro used to force C preprocessor to concatenate string defines
#define DEFINE_STRING(STR)              STR

// Macro to make this stuff easier to read.
#define VER_STR_CAT(sep,maj,min,sub,bld) maj sep min sep sub sep bld

// PRODUCT version information is displayed in the About box of each
// component and is stored in the registry during installation.
// The About box code must get the value from the registry instead of
// using these macros in order to get the currently installed version.
// Therefore, these macros should only be used by the installer.
#define VER_PRODUCT_VERSION_NUM         ((VER_PRODUCT_MAJOR_NUM << 24) | \
                                            (VER_PRODUCT_MINOR_NUM << 16) | \
                                            (VER_PRODUCT_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_PRODUCT_VERSION_NUM_RC      VER_PRODUCT_MAJOR_NUM,\
                                            VER_PRODUCT_MINOR_NUM,\
                                            VER_PRODUCT_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_PRODUCT_VERSION_STR         VER_STR_CAT(".",\
                                            VER_PRODUCT_MAJOR_STR,\
                                            VER_PRODUCT_MINOR_STR,\
                                            VER_PRODUCT_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_PRODUCT_VERSION_STR_RC      VER_STR_CAT(".",\
                                            VER_PRODUCT_MAJOR_STR,\
                                            VER_PRODUCT_MINOR_STR,\
                                            VER_PRODUCT_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

// COMPONENT version information is displayed in the ProductVersion 
// field of a file's Windows property sheet.  It is the same as the
// FILE version info with the addition of the build number.
#define VER_COMPONENT_VERSION_NUM       ((VER_FILE_MAJOR_NUM << 24) | \
                                            (VER_FILE_MINOR_NUM << 16) | \
                                            (VER_FILE_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_COMPONENT_VERSION_NUM_RC    VER_FILE_MAJOR_NUM,\
                                            VER_FILE_MINOR_NUM,\
                                            VER_FILE_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_COMPONENT_VERSION_STR       VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_COMPONENT_VERSION_STR_RC    VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

// FILE version information is an abbreviated component version info
// and is displayed at the top of a file's Windows property sheet.
#define VER_FILE_VERSION_NUM            ((VER_FILE_MAJOR_NUM << 24) | \
                                            (VER_FILE_MINOR_NUM << 16) | \
                                            (VER_FILE_SUB_MINOR_NUM << 8) | \
                                            VER_PRODUCT_BUILD_NUM)

#define VER_FILE_VERSION_NUM_RC         VER_FILE_MAJOR_NUM,\
                                            VER_FILE_MINOR_NUM,\
                                            VER_FILE_SUB_MINOR_NUM,\
                                            VER_PRODUCT_BUILD_NUM

#define VER_FILE_VERSION_STR            VER_STR_CAT(".",\
                                            VER_FILE_MAJOR_STR,\
                                            VER_FILE_MINOR_STR,\
                                            VER_FILE_SUB_MINOR_STR,\
                                            VER_PRODUCT_BUILD_STR)

#define VER_FILE_VERSION_STR_RC         VER_FILE_MAJOR_STR "."\
                                            VER_FILE_MINOR_STR "."\
                                            VER_FILE_SUB_MINOR_STR

#endif /* _VPRODUCT_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\vvendor.h ===
/*

                                                                             
    (C) Copyright 1999 
        All rights reserved.


                                                                             
  Portions of this software are:

    (C) Copyright 1997 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiBuild vVendor vVendor_h

@module vVendor.h |

    This module defines the version information as displayed in the Windows 
    file property sheet.  You must change the fields below as appropriate 
    for your product.  This file is then included by <f vTarget\.rc> to 
    defined the necessary elements of the target file's version resource.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | vVendor_h

@end

*/

#ifndef _VVENDOR_H_
#define _VVENDOR_H_

// Short vendor name - no spaces - limit to 32 characters if possible.
#define VER_VENDOR_STR                  "TriplePoint"
// Long vendor name - legal name of the company.
#define VER_VENDOR_NAME_STR             "TriplePoint, Inc."
// Legal copyright notice - limit to to 40 characters for appearance.
#define VER_COPYRIGHT_STR               "Copyright \251 1999"
// Short product name - no spaces - limit to 32 characters if possible.
#define VER_PRODUCT_STR                 "CoIsdn"
// Long product name - usually the same as put on the product packaging.
#define VER_PRODUCT_NAME_STR            "TriplePoint COISDN Miniport for Windows."
// Vendor and product name - typically used as a registry key.
#define VER_VENDOR_PRODUCT_STR          VER_VENDOR_STR "\\" VER_PRODUCT_STR
// Device description used to identify the device in the NDIS/TAPI user interface.
#define VER_DEVICE_STR                  "TriplePoint COISDN"
// IEEE Organization Unique Identifier assigned to your company.
#define VER_VENDOR_ID                   "TPI"

#endif // _VVENDOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\im\precomp.h ===
#pragma warning(disable:4214)   // bit field types other than int

#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses
#pragma warning(disable:4127)   // conditional expression is constant
#pragma warning(disable:4054)   // cast of function pointer to PVOID
#pragma warning(disable:4244)   // conversion from 'int' to 'BOOLEAN', possible loss of data

#include <ndis.h>
#include "passthru.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\coisdn\vtargnum.h ===
// WARNING --- DO NOT CHANGE THIS FILE --- WARNING
// It is updated automatically by the TpiBuild procedure using VerInc.exe.
#define VER_FILE_MAJOR_NUM      0
#define VER_FILE_MINOR_NUM      7
#define VER_FILE_SUB_MINOR_NUM  0
#define VER_FILE_MAJOR_STR      "0"
#define VER_FILE_MINOR_STR      "07"
#define VER_FILE_SUB_MINOR_STR  "00"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\im\passthru.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation
 
Module Name:
 
    passthru.c

Abstract:

    Ndis Intermediate Miniport driver sample. This is a passthru driver.

Author:

Environment:


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#pragma NDIS_INIT_FUNCTION(DriverEntry)

NDIS_HANDLE         ProtHandle = NULL;
NDIS_HANDLE         DriverHandle = NULL;
NDIS_MEDIUM         MediumArray[4] =
                    {
                        NdisMedium802_3,    // Ethernet
                        NdisMedium802_5,    // Token-ring
                        NdisMediumFddi,     // Fddi
                        NdisMediumWan       // NDISWAN
                    };

NDIS_SPIN_LOCK     GlobalLock;

PADAPT             pAdaptList = NULL;
LONG               MiniportCount = 0;

NDIS_HANDLE        NdisWrapperHandle;

//
// To support ioctls from user-mode:
//

#define LINKNAME_STRING     L"\\DosDevices\\Passthru"
#define NTDEVICE_STRING     L"\\Device\\Passthru"

NDIS_HANDLE     NdisDeviceHandle = NULL;
PDEVICE_OBJECT  ControlDeviceObject = NULL;

enum _DEVICE_STATE
{
    PS_DEVICE_STATE_READY = 0,    // ready for create/delete
    PS_DEVICE_STATE_CREATING,    // create operation in progress
    PS_DEVICE_STATE_DELETING    // delete operation in progress
} ControlDeviceState = PS_DEVICE_STATE_READY;



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT        DriverObject,
    IN PUNICODE_STRING       RegistryPath
    )
/*++

Routine Description:

    First entry point to be called, when this driver is loaded.
    Register with NDIS as an intermediate driver.

Arguments:

    DriverObject - pointer to the system's driver object structure
        for this driver
    
    RegistryPath - system's registry path for this driver
    
Return Value:

    STATUS_SUCCESS if all initialization is successful, STATUS_XXX
    error code if not.

--*/
{
    NDIS_STATUS                        Status;
    NDIS_PROTOCOL_CHARACTERISTICS      PChars;
    NDIS_MINIPORT_CHARACTERISTICS      MChars;
    NDIS_STRING                        Name;

    Status = NDIS_STATUS_SUCCESS;
    NdisAllocateSpinLock(&GlobalLock);

    NdisMInitializeWrapper(&NdisWrapperHandle, DriverObject, RegistryPath, NULL);

    do
    {
        //
        // Register the miniport with NDIS. Note that it is the miniport
        // which was started as a driver and not the protocol. Also the miniport
        // must be registered prior to the protocol since the protocol's BindAdapter
        // handler can be initiated anytime and when it is, it must be ready to
        // start driver instances.
        //

        NdisZeroMemory(&MChars, sizeof(NDIS_MINIPORT_CHARACTERISTICS));

        MChars.MajorNdisVersion = PASSTHRU_MAJOR_NDIS_VERSION;
        MChars.MinorNdisVersion = PASSTHRU_MINOR_NDIS_VERSION;

        MChars.InitializeHandler = MPInitialize;
        MChars.QueryInformationHandler = MPQueryInformation;
        MChars.SetInformationHandler = MPSetInformation;
        MChars.ResetHandler = NULL;
        MChars.TransferDataHandler = MPTransferData;
        MChars.HaltHandler = MPHalt;
#ifdef NDIS51_MINIPORT
        MChars.CancelSendPacketsHandler = MPCancelSendPackets;
        MChars.PnPEventNotifyHandler = MPDevicePnPEvent;
        MChars.AdapterShutdownHandler = MPAdapterShutdown;
#endif // NDIS51_MINIPORT

        //
        // We will disable the check for hang timeout so we do not
        // need a check for hang handler!
        //
        MChars.CheckForHangHandler = NULL;
        MChars.ReturnPacketHandler = MPReturnPacket;

        //
        // Either the Send or the SendPackets handler should be specified.
        // If SendPackets handler is specified, SendHandler is ignored
        //
        MChars.SendHandler = NULL;    // MPSend;
        MChars.SendPacketsHandler = MPSendPackets;

        Status = NdisIMRegisterLayeredMiniport(NdisWrapperHandle,
                                                  &MChars,
                                                  sizeof(MChars),
                                                  &DriverHandle);
        if (Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

#ifndef WIN9X
        NdisMRegisterUnloadHandler(NdisWrapperHandle, PtUnload);
#endif

        //
        // Now register the protocol.
        //
        NdisZeroMemory(&PChars, sizeof(NDIS_PROTOCOL_CHARACTERISTICS));
        PChars.MajorNdisVersion = PASSTHRU_PROT_MAJOR_NDIS_VERSION;
        PChars.MinorNdisVersion = PASSTHRU_PROT_MINOR_NDIS_VERSION;

        //
        // Make sure the protocol-name matches the service-name
        // (from the INF) under which this protocol is installed.
        // This is needed to ensure that NDIS can correctly determine
        // the binding and call us to bind to miniports below.
        //
        NdisInitUnicodeString(&Name, L"Passthru");    // Protocol name
        PChars.Name = Name;
        PChars.OpenAdapterCompleteHandler = PtOpenAdapterComplete;
        PChars.CloseAdapterCompleteHandler = PtCloseAdapterComplete;
        PChars.SendCompleteHandler = PtSendComplete;
        PChars.TransferDataCompleteHandler = PtTransferDataComplete;
    
        PChars.ResetCompleteHandler = PtResetComplete;
        PChars.RequestCompleteHandler = PtRequestComplete;
        PChars.ReceiveHandler = PtReceive;
        PChars.ReceiveCompleteHandler = PtReceiveComplete;
        PChars.StatusHandler = PtStatus;
        PChars.StatusCompleteHandler = PtStatusComplete;
        PChars.BindAdapterHandler = PtBindAdapter;
        PChars.UnbindAdapterHandler = PtUnbindAdapter;
        PChars.UnloadHandler = PtUnloadProtocol;

        PChars.ReceivePacketHandler = PtReceivePacket;
        PChars.PnPEventHandler= PtPNPHandler;

        NdisRegisterProtocol(&Status,
                             &ProtHandle,
                             &PChars,
                             sizeof(NDIS_PROTOCOL_CHARACTERISTICS));

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NdisIMDeregisterLayeredMiniport(DriverHandle);
            break;
        }

        NdisIMAssociateMiniport(DriverHandle, ProtHandle);
    }
    while (FALSE);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        NdisTerminateWrapper(NdisWrapperHandle, NULL);
    }

    return(Status);
}


NDIS_STATUS
PtRegisterDevice(
    VOID
    )
/*++

Routine Description:

    Register an ioctl interface - a device object to be used for this
    purpose is created by NDIS when we call NdisMRegisterDevice.

    This routine is called whenever a new miniport instance is
    initialized. However, we only create one global device object,
    when the first miniport instance is initialized. This routine
    handles potential race conditions with PtDeregisterDevice via
    the ControlDeviceState and MiniportCount variables.

    NOTE: do not call this from DriverEntry; it will prevent the driver
    from being unloaded (e.g. on uninstall).

Arguments:

    None

Return Value:

    NDIS_STATUS_SUCCESS if we successfully register a device object.

--*/
{
    NDIS_STATUS            Status = NDIS_STATUS_SUCCESS;
    UNICODE_STRING         DeviceName;
    UNICODE_STRING         DeviceLinkUnicodeString;
    PDRIVER_DISPATCH       DispatchTable[IRP_MJ_MAXIMUM_FUNCTION+1];

    DBGPRINT(("==>PtRegisterDevice\n"));

    NdisAcquireSpinLock(&GlobalLock);

    ++MiniportCount;
    
    if (1 == MiniportCount)
    {
        ASSERT(ControlDeviceState != PS_DEVICE_STATE_CREATING);

        //
        // Another thread could be running PtDeregisterDevice on
        // behalf of another miniport instance. If so, wait for
        // it to exit.
        //
        while (ControlDeviceState != PS_DEVICE_STATE_READY)
        {
            NdisReleaseSpinLock(&GlobalLock);
            NdisMSleep(1);
            NdisAcquireSpinLock(&GlobalLock);
        }

        ControlDeviceState = PS_DEVICE_STATE_CREATING;

        NdisReleaseSpinLock(&GlobalLock);

    
        NdisZeroMemory(DispatchTable, (IRP_MJ_MAXIMUM_FUNCTION+1) * sizeof(PDRIVER_DISPATCH));

        DispatchTable[IRP_MJ_CREATE] = PtDispatch;
        DispatchTable[IRP_MJ_CLEANUP] = PtDispatch;
        DispatchTable[IRP_MJ_CLOSE] = PtDispatch;
        DispatchTable[IRP_MJ_DEVICE_CONTROL] = PtDispatch;
        

        NdisInitUnicodeString(&DeviceName, NTDEVICE_STRING);
        NdisInitUnicodeString(&DeviceLinkUnicodeString, LINKNAME_STRING);

        //
        // Create a device object and register our dispatch handlers
        //
        
        Status = NdisMRegisterDevice(
                    NdisWrapperHandle, 
                    &DeviceName,
                    &DeviceLinkUnicodeString,
                    &DispatchTable[0],
                    &ControlDeviceObject,
                    &NdisDeviceHandle
                    );

        NdisAcquireSpinLock(&GlobalLock);

        ControlDeviceState = PS_DEVICE_STATE_READY;
    }

    NdisReleaseSpinLock(&GlobalLock);

    DBGPRINT(("<==PtRegisterDevice: %x\n", Status));

    return (Status);
}


NTSTATUS
PtDispatch(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp
    )
/*++
Routine Description:

    Process IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object
    Irp      - pointer to an I/O Request Packet

Return Value:

    NTSTATUS - STATUS_SUCCESS always - change this when adding
    real code to handle ioctls.

--*/
{
    PIO_STACK_LOCATION  irpStack;
    NTSTATUS            status = STATUS_SUCCESS;

    UNREFERENCED_PARAMETER(DeviceObject);
    
    DBGPRINT(("==>Pt Dispatch\n"));
    irpStack = IoGetCurrentIrpStackLocation(Irp);
      

    switch (irpStack->MajorFunction)
    {
        case IRP_MJ_CREATE:
            break;
            
        case IRP_MJ_CLEANUP:
            break;
            
        case IRP_MJ_CLOSE:
            break;        
            
        case IRP_MJ_DEVICE_CONTROL:
            //
            // Add code here to handle ioctl commands sent to passthru.
            //
            break;        
        default:
            break;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(("<== Pt Dispatch\n"));

    return status;

} 


NDIS_STATUS
PtDeregisterDevice(
    VOID
    )
/*++

Routine Description:

    Deregister the ioctl interface. This is called whenever a miniport
    instance is halted. When the last miniport instance is halted, we
    request NDIS to delete the device object

Arguments:

    NdisDeviceHandle - Handle returned by NdisMRegisterDevice

Return Value:

    NDIS_STATUS_SUCCESS if everything worked ok

--*/
{
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;

    DBGPRINT(("==>PassthruDeregisterDevice\n"));

    NdisAcquireSpinLock(&GlobalLock);

    ASSERT(MiniportCount > 0);

    --MiniportCount;
    
    if (0 == MiniportCount)
    {
        //
        // All miniport instances have been halted. Deregister
        // the control device.
        //

        ASSERT(ControlDeviceState == PS_DEVICE_STATE_READY);

        //
        // Block PtRegisterDevice() while we release the control
        // device lock and deregister the device.
        // 
        ControlDeviceState = PS_DEVICE_STATE_DELETING;

        NdisReleaseSpinLock(&GlobalLock);

        if (NdisDeviceHandle != NULL)
        {
            Status = NdisMDeregisterDevice(NdisDeviceHandle);
            NdisDeviceHandle = NULL;
        }

        NdisAcquireSpinLock(&GlobalLock);
        ControlDeviceState = PS_DEVICE_STATE_READY;
    }

    NdisReleaseSpinLock(&GlobalLock);

    DBGPRINT(("<== PassthruDeregisterDevice: %x\n", Status));
    return Status;
    
}

VOID
PtUnload(
    IN PDRIVER_OBJECT        DriverObject
    )
//
// PassThru driver unload function
//
{
    UNREFERENCED_PARAMETER(DriverObject);
    
    DBGPRINT(("PtUnload: entered\n"));
    PtUnloadProtocol();
    NdisIMDeregisterLayeredMiniport(DriverHandle);
    DBGPRINT(("PtUnload: done!\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\im\protocol.c ===
/*++

Copyright(c) 1992-2000  Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    Ndis Intermediate Miniport driver sample. This is a passthru driver.

Author:

Environment:


Revision History:


--*/


#include "precomp.h"
#pragma hdrstop

#define MAX_PACKET_POOL_SIZE 0x0000FFFF
#define MIN_PACKET_POOL_SIZE 0x000000FF

VOID
PtBindAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             BindContext,
    IN  PNDIS_STRING            DeviceName,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2
    )
/*++

Routine Description:

    Called by NDIS to bind to a miniport below.

Arguments:

    Status            - Return status of bind here.
    BindContext        - Can be passed to NdisCompleteBindAdapter if this call is pended.
    DeviceName         - Device name to bind to. This is passed to NdisOpenAdapter.
    SystemSpecific1    - Can be passed to NdisOpenProtocolConfiguration to read per-binding information
    SystemSpecific2    - Unused

Return Value:

    NDIS_STATUS_PENDING    if this call is pended. In this case call NdisCompleteBindAdapter
    to complete.
    Anything else          Completes this call synchronously

--*/
{
    NDIS_HANDLE                     ConfigHandle = NULL;
    PNDIS_CONFIGURATION_PARAMETER   Param;
    NDIS_STRING                     DeviceStr = NDIS_STRING_CONST("UpperBindings");
    PADAPT                          pAdapt = NULL;
    NDIS_STATUS                     Sts;
    UINT                            MediumIndex;
    ULONG                           TotalSize;


    UNREFERENCED_PARAMETER(BindContext);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    
    DBGPRINT(("==> Protocol BindAdapter\n"));

    do
    {
        //
        // Access the configuration section for our binding-specific
        // parameters.
        //
        NdisOpenProtocolConfiguration(Status,
                                       &ConfigHandle,
                                       SystemSpecific1);

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Read the "UpperBindings" reserved key that contains a list
        // of device names representing our miniport instances corresponding
        // to this lower binding. Since this is a 1:1 IM driver, this key
        // contains exactly one name.
        //
        // If we want to implement a N:1 mux driver (N adapter instances
        // over a single lower binding), then UpperBindings will be a
        // MULTI_SZ containing a list of device names - we would loop through
        // this list, calling NdisIMInitializeDeviceInstanceEx once for
        // each name in it.
        //
        NdisReadConfiguration(Status,
                              &Param,
                              ConfigHandle,
                              &DeviceStr,
                              NdisParameterString);
        if (*Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Allocate memory for the Adapter structure. This represents both the
        // protocol context as well as the adapter structure when the miniport
        // is initialized.
        //
        // In addition to the base structure, allocate space for the device
        // instance string.
        //
        TotalSize = sizeof(ADAPT) + Param->ParameterData.StringData.MaximumLength;
        NdisAllocateMemoryWithTag(&pAdapt, TotalSize, TAG);

        if (pAdapt == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Initialize the adapter structure. We copy in the IM device
        // name as well, because we may need to use it in a call to
        // NdisIMCancelInitializeDeviceInstance. The string returned
        // by NdisReadConfiguration is active (i.e. available) only
        // for the duration of this call to our BindAdapter handler.
        //
        NdisZeroMemory(pAdapt, TotalSize);
        pAdapt->DeviceName.MaximumLength = Param->ParameterData.StringData.MaximumLength;
        pAdapt->DeviceName.Length = Param->ParameterData.StringData.Length;
        pAdapt->DeviceName.Buffer = (PWCHAR)((ULONG_PTR)pAdapt + sizeof(ADAPT));
        NdisMoveMemory(pAdapt->DeviceName.Buffer,
                       Param->ParameterData.StringData.Buffer,
                       Param->ParameterData.StringData.MaximumLength);

        NdisInitializeEvent(&pAdapt->Event);
        NdisAllocateSpinLock(&pAdapt->Lock);

        //
        // Allocate a packet pool for sends. We need this to pass sends down.
        // We cannot use the same packet descriptor that came down to our send
        // handler (see also NDIS 5.1 packet stacking).
        //
        NdisAllocatePacketPoolEx(Status,
                                   &pAdapt->SendPacketPoolHandle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   sizeof(SEND_RSVD));

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Allocate a packet pool for receives. We need this to indicate receives.
        // Same consideration as sends (see also NDIS 5.1 packet stacking).
        //
        NdisAllocatePacketPoolEx(Status,
                                   &pAdapt->RecvPacketPoolHandle,
                                   MIN_PACKET_POOL_SIZE,
                                   MAX_PACKET_POOL_SIZE - MIN_PACKET_POOL_SIZE,
                                   PROTOCOL_RESERVED_SIZE_IN_PACKET);

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // Now open the adapter below and complete the initialization
        //
        NdisOpenAdapter(Status,
                          &Sts,
                          &pAdapt->BindingHandle,
                          &MediumIndex,
                          MediumArray,
                          sizeof(MediumArray)/sizeof(NDIS_MEDIUM),
                          ProtHandle,
                          pAdapt,
                          DeviceName,
                          0,
                          NULL);

        if (*Status == NDIS_STATUS_PENDING)
        {
            NdisWaitEvent(&pAdapt->Event, 0);
            *Status = pAdapt->Status;
        }

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        pAdapt->Medium = MediumArray[MediumIndex];

        //
        // Now ask NDIS to initialize our miniport (upper) edge.
        // Set the flag below to synchronize with a possible call
        // to our protocol Unbind handler that may come in before
        // our miniport initialization happens.
        //
        pAdapt->MiniportInitPending = TRUE;
        NdisInitializeEvent(&pAdapt->MiniportInitEvent);

        *Status = NdisIMInitializeDeviceInstanceEx(DriverHandle,
                                           &pAdapt->DeviceName,
                                           pAdapt);

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            DBGPRINT(("BindAdapter: Adapt %p, IMInitializeDeviceInstance error %x\n",
                pAdapt, *Status));
            break;
        }

    } while(FALSE);

    //
    // Close the configuration handle now - see comments above with
    // the call to NdisIMInitializeDeviceInstanceEx.
    //
    if (ConfigHandle != NULL)
    {
        NdisCloseConfiguration(ConfigHandle);
    }

    if (*Status != NDIS_STATUS_SUCCESS)
    {
        if (pAdapt != NULL)
        {
            if (pAdapt->BindingHandle != NULL)
            {
                NDIS_STATUS    LocalStatus;

                //
                // Close the binding we opened above.
                //

                NdisResetEvent(&pAdapt->Event);
                
                NdisCloseAdapter(&LocalStatus, pAdapt->BindingHandle);
                pAdapt->BindingHandle = NULL;

                if (LocalStatus == NDIS_STATUS_PENDING)
                {
                     NdisWaitEvent(&pAdapt->Event, 0);
                     LocalStatus = pAdapt->Status;
                }
            }

            if (pAdapt->SendPacketPoolHandle != NULL)
            {
                 NdisFreePacketPool(pAdapt->SendPacketPoolHandle);
            }

            if (pAdapt->RecvPacketPoolHandle != NULL)
            {
                 NdisFreePacketPool(pAdapt->RecvPacketPoolHandle);
            }

            NdisFreeMemory(pAdapt, 0, 0);
            pAdapt = NULL;
        }
    }


    DBGPRINT(("<== Protocol BindAdapter: pAdapt %p, Status %x\n", pAdapt, *Status));
}


VOID
PtOpenAdapterComplete(
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  NDIS_STATUS             Status,
    IN  NDIS_STATUS             OpenErrorStatus
    )
/*++

Routine Description:

    Completion routine for NdisOpenAdapter issued from within the PtBindAdapter. Simply
    unblock the caller.

Arguments:

    ProtocolBindingContext    Pointer to the adapter
    Status                    Status of the NdisOpenAdapter call
    OpenErrorStatus            Secondary status(ignored by us).

Return Value:

    None

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;
    
    UNREFERENCED_PARAMETER(OpenErrorStatus);
    
    DBGPRINT(("==> PtOpenAdapterComplete: Adapt %p, Status %x\n", pAdapt, Status));
    pAdapt->Status = Status;
    NdisSetEvent(&pAdapt->Event);
}


VOID
PtUnbindAdapter(
    OUT PNDIS_STATUS        Status,
    IN  NDIS_HANDLE            ProtocolBindingContext,
    IN  NDIS_HANDLE            UnbindContext
    )
/*++

Routine Description:

    Called by NDIS when we are required to unbind to the adapter below.
    This functions shares functionality with the miniport's HaltHandler.
    The code should ensure that NdisCloseAdapter and NdisFreeMemory is called
    only once between the two functions

Arguments:

    Status                    Placeholder for return status
    ProtocolBindingContext    Pointer to the adapter structure
    UnbindContext            Context for NdisUnbindComplete() if this pends

Return Value:

    Status for NdisIMDeinitializeDeviceContext

--*/
{
    PADAPT         pAdapt =(PADAPT)ProtocolBindingContext;
    NDIS_STATUS    LocalStatus;

    UNREFERENCED_PARAMETER(UnbindContext);
    
    DBGPRINT(("==> PtUnbindAdapter: Adapt %p\n", pAdapt));

    //
    // Set the flag that the miniport below is unbinding, so the request handlers will
    // fail any request comming later
    // 
    NdisAcquireSpinLock(&pAdapt->Lock);
    pAdapt->UnbindingInProcess = TRUE;
    if (pAdapt->QueuedRequest == TRUE)
    {
        pAdapt->QueuedRequest = FALSE;
        NdisReleaseSpinLock(&pAdapt->Lock);

        PtRequestComplete(pAdapt,
                         &pAdapt->Request,
                         NDIS_STATUS_FAILURE );

    }
    else
    {
        NdisReleaseSpinLock(&pAdapt->Lock);
    }
#ifndef WIN9X
    //
    // Check if we had called NdisIMInitializeDeviceInstanceEx and
    // we are awaiting a call to MiniportInitialize.
    //
    if (pAdapt->MiniportInitPending == TRUE)
    {
        //
        // Try to cancel the pending IMInit process.
        //
        LocalStatus = NdisIMCancelInitializeDeviceInstance(
                        DriverHandle,
                        &pAdapt->DeviceName);

        if (LocalStatus == NDIS_STATUS_SUCCESS)
        {
            //
            // Successfully cancelled IM Initialization; our
            // Miniport Initialize routine will not be called
            // for this device.
            //
            pAdapt->MiniportInitPending = FALSE;
            ASSERT(pAdapt->MiniportHandle == NULL);
        }
        else
        {
            //
            // Our Miniport Initialize routine will be called
            // (may be running on another thread at this time).
            // Wait for it to finish.
            //
            NdisWaitEvent(&pAdapt->MiniportInitEvent, 0);
            ASSERT(pAdapt->MiniportInitPending == FALSE);
        }

    }
#endif // !WIN9X

    //
    // Call NDIS to remove our device-instance. We do most of the work
    // inside the HaltHandler.
    //
    // The Handle will be NULL if our miniport Halt Handler has been called or
    // if the IM device was never initialized
    //
    
    if (pAdapt->MiniportHandle != NULL)
    {
        *Status = NdisIMDeInitializeDeviceInstance(pAdapt->MiniportHandle);

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            *Status = NDIS_STATUS_FAILURE;
        }
    }
    else
    {
        //
        // We need to do some work here. 
        // Close the binding below us 
        // and release the memory allocated.
        //
        if(pAdapt->BindingHandle != NULL)
        {
            NdisResetEvent(&pAdapt->Event);

            NdisCloseAdapter(Status, pAdapt->BindingHandle);

            //
            // Wait for it to complete
            //
            if(*Status == NDIS_STATUS_PENDING)
            {
                 NdisWaitEvent(&pAdapt->Event, 0);
                 *Status = pAdapt->Status;
            }
            pAdapt->BindingHandle = NULL;
        }
        else
        {
            //
            // Both Our MiniportHandle and Binding Handle  should not be NULL.
            //
            *Status = NDIS_STATUS_FAILURE;
            ASSERT(0);
        }

        //
        //    Free the memory here, if was not released earlier(by calling the HaltHandler)
        //
        NdisFreeMemory(pAdapt, 0, 0);
    }

    DBGPRINT(("<== PtUnbindAdapter: Adapt %p\n", pAdapt));
}

VOID
PtUnloadProtocol(
    VOID
)
{
    NDIS_STATUS Status;

    if (ProtHandle != NULL)
    {
        NdisDeregisterProtocol(&Status, ProtHandle);
        ProtHandle = NULL;
    }

    DBGPRINT(("PtUnloadProtocol: done!\n"));
}



VOID
PtCloseAdapterComplete(
    IN    NDIS_HANDLE            ProtocolBindingContext,
    IN    NDIS_STATUS            Status
    )
/*++

Routine Description:

    Completion for the CloseAdapter call.

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    Status                    Completion status

Return Value:

    None.

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;

    DBGPRINT(("CloseAdapterComplete: Adapt %p, Status %x\n", pAdapt, Status));
    pAdapt->Status = Status;
    NdisSetEvent(&pAdapt->Event);
}


VOID
PtResetComplete(
    IN  NDIS_HANDLE            ProtocolBindingContext,
    IN  NDIS_STATUS            Status
    )
/*++

Routine Description:

    Completion for the reset.

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    Status                    Completion status

Return Value:

    None.

--*/
{

    UNREFERENCED_PARAMETER(ProtocolBindingContext);
    UNREFERENCED_PARAMETER(Status);
    //
    // We never issue a reset, so we should not be here.
    //
    ASSERT(0);
}


VOID
PtRequestComplete(
    IN  NDIS_HANDLE            ProtocolBindingContext,
    IN  PNDIS_REQUEST          NdisRequest,
    IN  NDIS_STATUS            Status
    )
/*++

Routine Description:

    Completion handler for the previously posted request. All OIDS
    are completed by and sent to the same miniport that they were requested for.
    If Oid == OID_PNP_QUERY_POWER then the data structure needs to returned with all entries =
    NdisDeviceStateUnspecified

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    NdisRequest                The posted request
    Status                    Completion status

Return Value:

    None

--*/
{
    PADAPT        pAdapt = (PADAPT)ProtocolBindingContext;
    NDIS_OID      Oid = pAdapt->Request.DATA.SET_INFORMATION.Oid ;

    //
    // Since our request is not outstanding anymore
    //
    ASSERT(pAdapt->OutstandingRequests == TRUE);

    pAdapt->OutstandingRequests = FALSE;

    //
    // Complete the Set or Query, and fill in the buffer for OID_PNP_CAPABILITIES, if need be.
    //
    switch (NdisRequest->RequestType)
    {
      case NdisRequestQueryInformation:

        //
        // We never pass OID_PNP_QUERY_POWER down.
        //
        ASSERT(Oid != OID_PNP_QUERY_POWER);

        if ((Oid == OID_PNP_CAPABILITIES) && (Status == NDIS_STATUS_SUCCESS))
        {
            MPQueryPNPCapabilities(pAdapt, &Status);
        }
        *pAdapt->BytesReadOrWritten = NdisRequest->DATA.QUERY_INFORMATION.BytesWritten;
        *pAdapt->BytesNeeded = NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded;

        if ((Oid == OID_GEN_MAC_OPTIONS) && (Status == NDIS_STATUS_SUCCESS))
        {
            //
            // Remove the no-loopback bit from mac-options. In essence we are
            // telling NDIS that we can handle loopback. We don't, but the
            // interface below us does. If we do not do this, then loopback
            // processing happens both below us and above us. This is wasteful
            // at best and if Netmon is running, it will see multiple copies
            // of loopback packets when sniffing above us.
            //
            // Only the lowest miniport is a stack of layered miniports should
            // ever report this bit set to NDIS.
            //
            *(PULONG)NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer &= ~NDIS_MAC_OPTION_NO_LOOPBACK;
        }

        NdisMQueryInformationComplete(pAdapt->MiniportHandle,
                                      Status);
        break;

      case NdisRequestSetInformation:

        ASSERT( Oid != OID_PNP_SET_POWER);

        *pAdapt->BytesReadOrWritten = NdisRequest->DATA.SET_INFORMATION.BytesRead;
        *pAdapt->BytesNeeded = NdisRequest->DATA.SET_INFORMATION.BytesNeeded;
        NdisMSetInformationComplete(pAdapt->MiniportHandle,
                                    Status);
        break;

      default:
        ASSERT(0);
        break;
    }
    
}


VOID
PtStatus(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  UINT                StatusBufferSize
    )
/*++

Routine Description:

    Status handler for the lower-edge(protocol).

Arguments:

    ProtocolBindingContext    Pointer to the adapter structure
    GeneralStatus             Status code
    StatusBuffer              Status buffer
    StatusBufferSize          Size of the status buffer

Return Value:

    None

--*/
{
    PADAPT      pAdapt = (PADAPT)ProtocolBindingContext;

    //
    // Pass up this indication only if the upper edge miniport is initialized
    // and powered on. Also ignore indications that might be sent by the lower
    // miniport when it isn't at D0.
    //
    if ((pAdapt->MiniportHandle != NULL)  &&
        (pAdapt->MPDeviceState == NdisDeviceStateD0) &&
        (pAdapt->PTDeviceState == NdisDeviceStateD0))    
    {
        if ((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || 
            (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT))
        {
            
            pAdapt->LastIndicatedStatus = GeneralStatus;
        }
        NdisMIndicateStatus(pAdapt->MiniportHandle,
                            GeneralStatus,
                            StatusBuffer,
                            StatusBufferSize);
    }
    //
    // Save the last indicated media status 
    //
    else
    {
        if ((pAdapt->MiniportHandle != NULL) && 
        ((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || 
            (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT)))
        {
            pAdapt->LatestUnIndicateStatus = GeneralStatus;
        }
    }
    
}


VOID
PtStatusComplete(
    IN NDIS_HANDLE            ProtocolBindingContext
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PADAPT      pAdapt = (PADAPT)ProtocolBindingContext;

    //
    // Pass up this indication only if the upper edge miniport is initialized
    // and powered on. Also ignore indications that might be sent by the lower
    // miniport when it isn't at D0.
    //
    if ((pAdapt->MiniportHandle != NULL)  &&
        (pAdapt->MPDeviceState == NdisDeviceStateD0) &&
        (pAdapt->PTDeviceState == NdisDeviceStateD0))    
    {
        NdisMIndicateStatusComplete(pAdapt->MiniportHandle);
    }
}


VOID
PtSendComplete(
    IN  NDIS_HANDLE            ProtocolBindingContext,
    IN  PNDIS_PACKET           Packet,
    IN  NDIS_STATUS            Status
    )
/*++

Routine Description:

    Called by NDIS when the miniport below had completed a send. We should
    complete the corresponding upper-edge send this represents.

Arguments:

    ProtocolBindingContext - Points to ADAPT structure
    Packet - Low level packet being completed
    Status - status of send

Return Value:

    None

--*/
{
    PADAPT            pAdapt = (PADAPT)ProtocolBindingContext;
    PNDIS_PACKET      Pkt; 
    NDIS_HANDLE       PoolHandle;

#ifdef NDIS51
    //
    // Packet stacking:
    //
    // Determine if the packet we are completing is the one we allocated. If so, then
    // get the original packet from the reserved area and completed it and free the
    // allocated packet. If this is the packet that was sent down to us, then just
    // complete it
    //
    PoolHandle = NdisGetPoolFromPacket(Packet);
    if (PoolHandle != pAdapt->SendPacketPoolHandle)
    {
        //
        // We had passed down a packet belonging to the protocol above us.
        //
        // DBGPRINT(("PtSendComp: Adapt %p, Stacked Packet %p\n", pAdapt, Packet));

        NdisMSendComplete(pAdapt->MiniportHandle,
                          Packet,
                          Status);
    }
    else
#endif // NDIS51
    {
        PSEND_RSVD        SendRsvd;

        SendRsvd = (PSEND_RSVD)(Packet->ProtocolReserved);
        Pkt = SendRsvd->OriginalPkt;
    
#ifndef WIN9X
        NdisIMCopySendCompletePerPacketInfo (Pkt, Packet);
#endif
    
        NdisDprFreePacket(Packet);

        NdisMSendComplete(pAdapt->MiniportHandle,
                                 Pkt,
                                 Status);
    }
    //
    // Decrease the outstanding send count
    //
    ADAPT_DECR_PENDING_SENDS(pAdapt);
}       


VOID
PtTransferDataComplete(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  PNDIS_PACKET        Packet,
    IN  NDIS_STATUS         Status,
    IN  UINT                BytesTransferred
    )
/*++

Routine Description:

    Entry point called by NDIS to indicate completion of a call by us
    to NdisTransferData.

    See notes under SendComplete.

Arguments:

Return Value:

--*/
{
    PADAPT      pAdapt =(PADAPT)ProtocolBindingContext;

    if(pAdapt->MiniportHandle)
    {
        NdisMTransferDataComplete(pAdapt->MiniportHandle,
                                  Packet,
                                  Status,
                                  BytesTransferred);
    }
}


NDIS_STATUS
PtReceive(
    IN  NDIS_HANDLE         ProtocolBindingContext,
    IN  NDIS_HANDLE         MacReceiveContext,
    IN  PVOID               HeaderBuffer,
    IN  UINT                HeaderBufferSize,
    IN  PVOID               LookAheadBuffer,
    IN  UINT                LookAheadBufferSize,
    IN  UINT                PacketSize
    )
/*++

Routine Description:

    Handle receive data indicated up by the miniport below. We pass
    it along to the protocol above us.

    If the miniport below indicates packets, NDIS would more
    likely call us at our ReceivePacket handler. However we
    might be called here in certain situations even though
    the miniport below has indicated a receive packet, e.g.
    if the miniport had set packet status to NDIS_STATUS_RESOURCES.
        
Arguments:

    <see DDK ref page for ProtocolReceive>

Return Value:

    NDIS_STATUS_SUCCESS if we processed the receive successfully,
    NDIS_STATUS_XXX error code if we discarded it.

--*/
{
    PADAPT            pAdapt = (PADAPT)ProtocolBindingContext;
    PNDIS_PACKET      MyPacket, Packet;
    NDIS_STATUS       Status = NDIS_STATUS_SUCCESS;

    if ((!pAdapt->MiniportHandle) || (pAdapt->MPDeviceState > NdisDeviceStateD0))
    {
        Status = NDIS_STATUS_FAILURE;
    }
    else do
    {
        //
        // Get at the packet, if any, indicated up by the miniport below.
        //
        Packet = NdisGetReceivedPacket(pAdapt->BindingHandle, MacReceiveContext);
        if (Packet != NULL)
        {
            //
            // The miniport below did indicate up a packet. Use information
            // from that packet to construct a new packet to indicate up.
            //

#ifdef NDIS51
            //
            // NDIS 5.1 NOTE: Do not reuse the original packet in indicating
            // up a receive, even if there is sufficient packet stack space.
            // If we had to do so, we would have had to overwrite the
            // status field in the original packet to NDIS_STATUS_RESOURCES,
            // and it is not allowed for protocols to overwrite this field
            // in received packets.
            //
#endif // NDIS51

            //
            // Get a packet off the pool and indicate that up
            //
            NdisDprAllocatePacket(&Status,
                                &MyPacket,
                                pAdapt->RecvPacketPoolHandle);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                //
                // Make our packet point to data from the original
                // packet. NOTE: this works only because we are
                // indicating a receive directly from the context of
                // our receive indication. If we need to queue this
                // packet and indicate it from another thread context,
                // we will also have to allocate a new buffer and copy
                // over the packet contents, OOB data and per-packet
                // information. This is because the packet data
                // is available only for the duration of this
                // receive indication call.
                //
                MyPacket->Private.Head = Packet->Private.Head;
                MyPacket->Private.Tail = Packet->Private.Tail;

                //
                // Get the original packet (it could be the same packet as the
                // one received or a different one based on the number of layered
                // miniports below) and set it on the indicated packet so the OOB
                // data is visible correctly at protocols above.
                //
                NDIS_SET_ORIGINAL_PACKET(MyPacket, NDIS_GET_ORIGINAL_PACKET(Packet));
                NDIS_SET_PACKET_HEADER_SIZE(MyPacket, HeaderBufferSize);

                //
                // Copy packet flags.
                //
                NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);

                //
                // Force protocols above to make a copy if they want to hang
                // on to data in this packet. This is because we are in our
                // Receive handler (not ReceivePacket) and we can't return a
                // ref count from here.
                //
                NDIS_SET_PACKET_STATUS(MyPacket, NDIS_STATUS_RESOURCES);

                //
                // By setting NDIS_STATUS_RESOURCES, we also know that we can reclaim
                // this packet as soon as the call to NdisMIndicateReceivePacket
                // returns.
                //

                NdisMIndicateReceivePacket(pAdapt->MiniportHandle, &MyPacket, 1);

                //
                // Reclaim the indicated packet. Since we had set its status
                // to NDIS_STATUS_RESOURCES, we are guaranteed that protocols
                // above are done with it.
                //
                NdisDprFreePacket(MyPacket);

                break;
            }
        }
        else
        {
            //
            // The miniport below us uses the old-style (not packet)
            // receive indication. Fall through.
            //
        }

        //
        // Fall through if the miniport below us has either not
        // indicated a packet or we could not allocate one
        //
        pAdapt->IndicateRcvComplete = TRUE;
        switch (pAdapt->Medium)
        {
            case NdisMedium802_3:
            case NdisMediumWan:
                NdisMEthIndicateReceive(pAdapt->MiniportHandle,
                                             MacReceiveContext,
                                             HeaderBuffer,
                                             HeaderBufferSize,
                                             LookAheadBuffer,
                                             LookAheadBufferSize,
                                             PacketSize);
                break;

            case NdisMedium802_5:
                NdisMTrIndicateReceive(pAdapt->MiniportHandle,
                                            MacReceiveContext,
                                            HeaderBuffer,
                                            HeaderBufferSize,
                                            LookAheadBuffer,
                                            LookAheadBufferSize,
                                            PacketSize);
                break;

            case NdisMediumFddi:
                NdisMFddiIndicateReceive(pAdapt->MiniportHandle,
                                              MacReceiveContext,
                                              HeaderBuffer,
                                              HeaderBufferSize,
                                              LookAheadBuffer,
                                              LookAheadBufferSize,
                                              PacketSize);
                break;

            default:
                ASSERT(FALSE);
                break;
        }

    } while(FALSE);

    return Status;
}


VOID
PtReceiveComplete(
    IN NDIS_HANDLE        ProtocolBindingContext
    )
/*++

Routine Description:

    Called by the adapter below us when it is done indicating a batch of
    received packets.

Arguments:

    ProtocolBindingContext    Pointer to our adapter structure.

Return Value:

    None

--*/
{
    PADAPT        pAdapt =(PADAPT)ProtocolBindingContext;

    if (((pAdapt->MiniportHandle != NULL)
                && (pAdapt->MPDeviceState > NdisDeviceStateD0))
                && (pAdapt->IndicateRcvComplete))
    {
        switch (pAdapt->Medium)
        {
            case NdisMedium802_3:
            case NdisMediumWan:
                NdisMEthIndicateReceiveComplete(pAdapt->MiniportHandle);
                break;

            case NdisMedium802_5:
                NdisMTrIndicateReceiveComplete(pAdapt->MiniportHandle);
                break;

            case NdisMediumFddi:
                NdisMFddiIndicateReceiveComplete(pAdapt->MiniportHandle);
                break;

            default:
                ASSERT(FALSE);
                break;
        }
    }

    pAdapt->IndicateRcvComplete = FALSE;
}


INT
PtReceivePacket(
    IN NDIS_HANDLE            ProtocolBindingContext,
    IN PNDIS_PACKET           Packet
    )
/*++

Routine Description:

    ReceivePacket handler. Called by NDIS if the miniport below supports
    NDIS 4.0 style receives. Re-package the buffer chain in a new packet
    and indicate the new packet to protocols above us. Any context for
    packets indicated up must be kept in the MiniportReserved field.

    NDIS 5.1 - packet stacking - if there is sufficient "stack space" in
    the packet passed to us, we can use the same packet in a receive
    indication.

Arguments:

    ProtocolBindingContext - Pointer to our adapter structure.
    Packet - Pointer to the packet

Return Value:

    == 0 -> We are done with the packet
    != 0 -> We will keep the packet and call NdisReturnPackets() this
            many times when done.
--*/
{
    PADAPT              pAdapt =(PADAPT)ProtocolBindingContext;
    NDIS_STATUS         Status;
    PNDIS_PACKET        MyPacket;
    BOOLEAN             Remaining;

    //
    // Drop the packet silently if the upper miniport edge isn't initialized or
    // the miniport edge is in low power state
    //
    if ((!pAdapt->MiniportHandle) || (pAdapt->MPDeviceState > NdisDeviceStateD0))
    {
          return 0;
    }

#ifdef NDIS51
    //
    // Check if we can reuse the same packet for indicating up.
    // See also: PtReceive(). 
    //
    (VOID)NdisIMGetCurrentPacketStack(Packet, &Remaining);
    if (Remaining)
    {
        //
        // We can reuse "Packet". Indicate it up and be done with it.
        //
        Status = NDIS_GET_PACKET_STATUS(Packet);
        NdisMIndicateReceivePacket(pAdapt->MiniportHandle, &Packet, 1);
        return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
    }
#endif // NDIS51

    //
    // Get a packet off the pool and indicate that up
    //
    NdisDprAllocatePacket(&Status,
                           &MyPacket,
                           pAdapt->RecvPacketPoolHandle);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        PRECV_RSVD            RecvRsvd;

        RecvRsvd = (PRECV_RSVD)(MyPacket->MiniportReserved);
        RecvRsvd->OriginalPkt = Packet;

        MyPacket->Private.Head = Packet->Private.Head;
        MyPacket->Private.Tail = Packet->Private.Tail;

        //
        // Get the original packet (it could be the same packet as the one
        // received or a different one based on the number of layered miniports
        // below) and set it on the indicated packet so the OOB data is visible
        // correctly to protocols above us.
        //
        NDIS_SET_ORIGINAL_PACKET(MyPacket, NDIS_GET_ORIGINAL_PACKET(Packet));

        //
        // Set Packet Flags
        //
        NdisGetPacketFlags(MyPacket) = NdisGetPacketFlags(Packet);

        Status = NDIS_GET_PACKET_STATUS(Packet);

        NDIS_SET_PACKET_STATUS(MyPacket, Status);
        NDIS_SET_PACKET_HEADER_SIZE(MyPacket, NDIS_GET_PACKET_HEADER_SIZE(Packet));

        NdisMIndicateReceivePacket(pAdapt->MiniportHandle, &MyPacket, 1);

        //
        // Check if we had indicated up the packet with NDIS_STATUS_RESOURCES
        // NOTE -- do not use NDIS_GET_PACKET_STATUS(MyPacket) for this since
        // it might have changed! Use the value saved in the local variable.
        //
        if (Status == NDIS_STATUS_RESOURCES)
        {
            //
            // Our ReturnPackets handler will not be called for this packet.
            // We should reclaim it right here.
            //
            NdisDprFreePacket(MyPacket);
        }

        return((Status != NDIS_STATUS_RESOURCES) ? 1 : 0);
    }
    else
    {
        //
        // We are out of packets. Silently drop it.
        //
        return(0);
    }
}




NDIS_STATUS
PtPNPHandler(
    IN NDIS_HANDLE        ProtocolBindingContext,
    IN PNET_PNP_EVENT     pNetPnPEvent
    )

/*++
Routine Description:

    This is called by NDIS to notify us of a PNP event related to a lower
    binding. Based on the event, this dispatches to other helper routines.

    NDIS 5.1: forward this event to the upper protocol(s) by calling
    NdisIMNotifyPnPEvent.

Arguments:

    ProtocolBindingContext - Pointer to our adapter structure. Can be NULL
                for "global" notifications

    pNetPnPEvent - Pointer to the PNP event to be processed.

Return Value:

    NDIS_STATUS code indicating status of event processing.

--*/
{
    PADAPT            pAdapt  =(PADAPT)ProtocolBindingContext;
    NDIS_STATUS       Status  = NDIS_STATUS_SUCCESS;

    DBGPRINT(("PtPnPHandler: Adapt %p, Event %d\n", pAdapt, pNetPnPEvent->NetEvent));

    switch (pNetPnPEvent->NetEvent)
    {
        case NetEventSetPower:
            Status = PtPnPNetEventSetPower(pAdapt, pNetPnPEvent);
            break;

         case NetEventReconfigure:
            Status = PtPnPNetEventReconfigure(pAdapt, pNetPnPEvent);
            break;

         default:
#ifdef NDIS51
            //
            // Pass on this notification to protocol(s) above, before
            // doing anything else with it.
            //
            if (pAdapt && pAdapt->MiniportHandle)
            {
                Status = NdisIMNotifyPnPEvent(pAdapt->MiniportHandle, pNetPnPEvent);
            }
#else
            Status = NDIS_STATUS_SUCCESS;

#endif // NDIS51

            break;
    }

    return Status;
}


NDIS_STATUS
PtPnPNetEventReconfigure(
    IN PADAPT            pAdapt,
    IN PNET_PNP_EVENT    pNetPnPEvent
    )
/*++
Routine Description:

    This routine is called from NDIS to notify our protocol edge of a
    reconfiguration of parameters for either a specific binding (pAdapt
    is not NULL), or global parameters if any (pAdapt is NULL).

Arguments:

    pAdapt - Pointer to our adapter structure.
    pNetPnPEvent - the reconfigure event

Return Value:

    NDIS_STATUS_SUCCESS

--*/
{
    NDIS_STATUS    ReconfigStatus = NDIS_STATUS_SUCCESS;
    NDIS_STATUS    ReturnStatus = NDIS_STATUS_SUCCESS;

    do
    {
        //
        // Is this is a global reconfiguration notification ?
        //
        if (pAdapt == NULL)
        {
            //
            // An important event that causes this notification to us is if
            // one of our upper-edge miniport instances was enabled after being
            // disabled earlier, e.g. from Device Manager in Win2000. Note that
            // NDIS calls this because we had set up an association between our
            // miniport and protocol entities by calling NdisIMAssociateMiniport.
            //
            // Since we would have torn down the lower binding for that miniport,
            // we need NDIS' assistance to re-bind to the lower miniport. The
            // call to NdisReEnumerateProtocolBindings does exactly that.
            //
            NdisReEnumerateProtocolBindings (ProtHandle);        
            break;
        }

#ifdef NDIS51
        //
        // Pass on this notification to protocol(s) above before doing anything
        // with it.
        //
        if (pAdapt->MiniportHandle)
        {
            ReturnStatus = NdisIMNotifyPnPEvent(pAdapt->MiniportHandle, pNetPnPEvent);
        }
#endif // NDIS51

        ReconfigStatus = NDIS_STATUS_SUCCESS;

    } while(FALSE);

    DBGPRINT(("<==PtPNPNetEventReconfigure: pAdapt %p\n", pAdapt));

#ifdef NDIS51
    //
    // Overwrite status with what upper-layer protocol(s) returned.
    //
    ReconfigStatus = ReturnStatus;
#endif

    return ReconfigStatus;
}


NDIS_STATUS
PtPnPNetEventSetPower(
    IN PADAPT            pAdapt,
    IN PNET_PNP_EVENT    pNetPnPEvent
    )
/*++
Routine Description:

    This is a notification to our protocol edge of the power state
    of the lower miniport. If it is going to a low-power state, we must
    wait here for all outstanding sends and requests to complete.

    NDIS 5.1:  Since we use packet stacking, it is not sufficient to
    check usage of our local send packet pool to detect whether or not
    all outstanding sends have completed. For this, use the new API
    NdisQueryPendingIOCount.

    NDIS 5.1: Use the 5.1 API NdisIMNotifyPnPEvent to pass on PnP
    notifications to upper protocol(s).

Arguments:

    pAdapt            -    Pointer to the adpater structure
    pNetPnPEvent    -    The Net Pnp Event. this contains the new device state

Return Value:

    NDIS_STATUS_SUCCESS or the status returned by upper-layer protocols.

--*/
{
    PNDIS_DEVICE_POWER_STATE       pDeviceState  =(PNDIS_DEVICE_POWER_STATE)(pNetPnPEvent->Buffer);
    NDIS_DEVICE_POWER_STATE        PrevDeviceState = pAdapt->PTDeviceState;  
    NDIS_STATUS                    Status;
    NDIS_STATUS                    ReturnStatus;
#ifdef NDIS51
    ULONG                          PendingIoCount = 0;
#endif // NDIS51

    ReturnStatus = NDIS_STATUS_SUCCESS;

    //
    // Set the Internal Device State, this blocks all new sends or receives
    //
    NdisAcquireSpinLock(&pAdapt->Lock);
    pAdapt->PTDeviceState = *pDeviceState;

    //
    // Check if the miniport below is going to a low power state.
    //
    if (pAdapt->PTDeviceState > NdisDeviceStateD0)
    {
        //
        // If the miniport below is going to standby, fail all incoming requests
        //
        if (PrevDeviceState == NdisDeviceStateD0)
        {
            pAdapt->StandingBy = TRUE;
        }

        NdisReleaseSpinLock(&pAdapt->Lock);

#ifdef NDIS51
        //
        // Notify upper layer protocol(s) first.
        //
        if (pAdapt->MiniportHandle != NULL)
        {
            ReturnStatus = NdisIMNotifyPnPEvent(pAdapt->MiniportHandle, pNetPnPEvent);
        }
#endif // NDIS51

        //
        // Wait for outstanding sends and requests to complete.
        //
        while (pAdapt->OutstandingSends != 0)
        {
            NdisMSleep(2);
        }

        while (pAdapt->OutstandingRequests == TRUE)
        {
            //
            // sleep till outstanding requests complete
            //
            NdisMSleep(2);
        }

        //
        // If the below miniport is going to low power state, complete the queued request
        //
        NdisAcquireSpinLock(&pAdapt->Lock);
        if (pAdapt->QueuedRequest)
        {
            pAdapt->QueuedRequest = FALSE;
            NdisReleaseSpinLock(&pAdapt->Lock);
            PtRequestComplete(pAdapt, &pAdapt->Request, NDIS_STATUS_FAILURE);
        }
        else
        {
            NdisReleaseSpinLock(&pAdapt->Lock);
        }
            

        ASSERT(NdisPacketPoolUsage(pAdapt->SendPacketPoolHandle) == 0);
        ASSERT(pAdapt->OutstandingRequests == FALSE);
    }
    else
    {
        //
        // If the physical miniport is powering up (from Low power state to D0), 
        // clear the flag
        //
        if (PrevDeviceState > NdisDeviceStateD0)
        {
            pAdapt->StandingBy = FALSE;
        }
        //
        // The device below is being turned on. If we had a request
        // pending, send it down now.
        //
        if (pAdapt->QueuedRequest == TRUE)
        {
            pAdapt->QueuedRequest = FALSE;
        
            pAdapt->OutstandingRequests = TRUE;
            NdisReleaseSpinLock(&pAdapt->Lock);

            NdisRequest(&Status,
                        pAdapt->BindingHandle,
                        &pAdapt->Request);

            if (Status != NDIS_STATUS_PENDING)
            {
                PtRequestComplete(pAdapt,
                                  &pAdapt->Request,
                                  Status);
                
            }
        }
        else
        {
            NdisReleaseSpinLock(&pAdapt->Lock);
        }


#ifdef NDIS51
        //
        // Pass on this notification to protocol(s) above
        //
        if (pAdapt->MiniportHandle)
        {
            ReturnStatus = NdisIMNotifyPnPEvent(pAdapt->MiniportHandle, pNetPnPEvent);
        }
#endif // NDIS51

    }

    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\im\miniport.c ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    Ndis Intermediate Miniport driver sample. This is a passthru driver.

Author:

Environment:


Revision History:


--*/

#include "precomp.h"
#pragma hdrstop



NDIS_STATUS
MPInitialize(
    OUT PNDIS_STATUS             OpenErrorStatus,
    OUT PUINT                    SelectedMediumIndex,
    IN  PNDIS_MEDIUM             MediumArray,
    IN  UINT                     MediumArraySize,
    IN  NDIS_HANDLE              MiniportAdapterHandle,
    IN  NDIS_HANDLE              WrapperConfigurationContext
    )
/*++

Routine Description:

    This is the initialize handler which gets called as a result of
    the BindAdapter handler calling NdisIMInitializeDeviceInstanceEx.
    The context parameter which we pass there is the adapter structure
    which we retrieve here.

    Arguments:

    OpenErrorStatus            Not used by us.
    SelectedMediumIndex        Place-holder for what media we are using
    MediumArray                Array of ndis media passed down to us to pick from
    MediumArraySize            Size of the array
    MiniportAdapterHandle    The handle NDIS uses to refer to us
    WrapperConfigurationContext    For use by NdisOpenConfiguration

Return Value:

    NDIS_STATUS_SUCCESS unless something goes wrong

--*/
{
    UINT            i;
    PADAPT          pAdapt;
    NDIS_STATUS     Status = NDIS_STATUS_FAILURE;
    NDIS_MEDIUM     Medium;

    UNREFERENCED_PARAMETER(WrapperConfigurationContext);
    
    do
    {
        //
        // Start off by retrieving our adapter context and storing
        // the Miniport handle in it.
        //
        pAdapt = NdisIMGetDeviceContext(MiniportAdapterHandle);
        pAdapt->MiniportHandle = MiniportAdapterHandle;

        DBGPRINT(("==> Miniport Initialize: Adapt %p\n", pAdapt));

        //
        // Usually we export the medium type of the adapter below as our
        // virtual miniport's medium type. However if the adapter below us
        // is a WAN device, then we claim to be of medium type 802.3.
        //
        Medium = pAdapt->Medium;

        if (Medium == NdisMediumWan)
        {
            Medium = NdisMedium802_3;
        }

        for (i = 0; i < MediumArraySize; i++)
        {
            if (MediumArray[i] == Medium)
            {
                *SelectedMediumIndex = i;
                break;
            }
        }

        if (i == MediumArraySize)
        {
            Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
            break;
        }


        //
        // Set the attributes now. NDIS_ATTRIBUTE_DESERIALIZE enables us
        // to make up-calls to NDIS without having to call NdisIMSwitchToMiniport
        // or NdisIMQueueCallBack. This also forces us to protect our data using
        // spinlocks where appropriate. Also in this case NDIS does not queue
        // packets on our behalf. Since this is a very simple pass-thru
        // miniport, we do not have a need to protect anything. However in
        // a general case there will be a need to use per-adapter spin-locks
        // for the packet queues at the very least.
        //
        NdisMSetAttributesEx(MiniportAdapterHandle,
                             pAdapt,
                             0,                                        // CheckForHangTimeInSeconds
                             NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT    |
                                NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT|
                                NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |
                                NDIS_ATTRIBUTE_DESERIALIZE |
                                NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
                             0);

        //
        // Initialize LastIndicatedStatus to be NDIS_STATUS_MEDIA_CONNECT
        //
        pAdapt->LastIndicatedStatus = NDIS_STATUS_MEDIA_CONNECT;
        
        //
        // Initialize the power states for both the lower binding (PTDeviceState)
        // and our miniport edge to Powered On.
        //
        pAdapt->MPDeviceState = NdisDeviceStateD0;
        pAdapt->PTDeviceState = NdisDeviceStateD0;

        //
        // Add this adapter to the global pAdapt List
        //
        NdisAcquireSpinLock(&GlobalLock);

        pAdapt->Next = pAdaptList;
        pAdaptList = pAdapt;

        NdisReleaseSpinLock(&GlobalLock);
        
        //
        // Create an ioctl interface
        //
        (VOID)PtRegisterDevice();

        Status = NDIS_STATUS_SUCCESS;
    }
    while (FALSE);

    //
    // If we had received an UnbindAdapter notification on the underlying
    // adapter, we would have blocked that thread waiting for the IM Init
    // process to complete. Wake up any such thread.
    //
    ASSERT(pAdapt->MiniportInitPending == TRUE);
    pAdapt->MiniportInitPending = FALSE;
    NdisSetEvent(&pAdapt->MiniportInitEvent);

    DBGPRINT(("<== Miniport Initialize: Adapt %p, Status %x\n", pAdapt, Status));

    *OpenErrorStatus = Status;
    
    return Status;
}


NDIS_STATUS
MPSend(
    IN NDIS_HANDLE             MiniportAdapterContext,
    IN PNDIS_PACKET            Packet,
    IN UINT                    Flags
    )
/*++

Routine Description:

    Send Packet handler. Either this or our SendPackets (array) handler is called
    based on which one is enabled in our Miniport Characteristics.

Arguments:

    MiniportAdapterContext    Pointer to the adapter
    Packet                    Packet to send
    Flags                     Unused, passed down below

Return Value:

    Return code from NdisSend

--*/
{
    PADAPT              pAdapt = (PADAPT)MiniportAdapterContext;
    NDIS_STATUS         Status;
    PNDIS_PACKET        MyPacket;
    PVOID               MediaSpecificInfo = NULL;
    ULONG               MediaSpecificInfoSize = 0;

    //
    // The driver should fail the send if the virtual miniport is in low 
    // power state
    //
    if (pAdapt->MPDeviceState > NdisDeviceStateD0)
    {
         return NDIS_STATUS_FAILURE;
    }

#ifdef NDIS51
    //
    // Use NDIS 5.1 packet stacking:
    //
    {
        PNDIS_PACKET_STACK        pStack;
        BOOLEAN                   Remaining;

        //
        // Packet stacks: Check if we can use the same packet for sending down.
        //

        pStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);
        if (Remaining)
        {
            //
            // We can reuse "Packet".
            //
            // NOTE: if we needed to keep per-packet information in packets
            // sent down, we can use pStack->IMReserved[].
            //
            ASSERT(pStack);
            //
            // If the below miniport is going to low power state, stop sending down any packet.
            //
            NdisAcquireSpinLock(&pAdapt->Lock);
            if (pAdapt->PTDeviceState > NdisDeviceStateD0)
            {
                NdisReleaseSpinLock(&pAdapt->Lock);
                return NDIS_STATUS_FAILURE;
            }
            pAdapt->OutstandingSends++;
            NdisReleaseSpinLock(&pAdapt->Lock);
            NdisSend(&Status,
                     pAdapt->BindingHandle,
                     Packet);

            if (Status != NDIS_STATUS_PENDING)
            {
                ADAPT_DECR_PENDING_SENDS(pAdapt);
            }

            return(Status);
        }
    }
#endif // NDIS51

    //
    // We are either not using packet stacks, or there isn't stack space
    // in the original packet passed down to us. Allocate a new packet
    // to wrap the data with.
    //
    //
    // If the below miniport is going to low power state, stop sending down any packet.
    //
    NdisAcquireSpinLock(&pAdapt->Lock);
    if (pAdapt->PTDeviceState > NdisDeviceStateD0)
    {
        NdisReleaseSpinLock(&pAdapt->Lock);
        return NDIS_STATUS_FAILURE;
    
    }
    pAdapt->OutstandingSends++;
    NdisReleaseSpinLock(&pAdapt->Lock);
    
    NdisAllocatePacket(&Status,
                       &MyPacket,
                       pAdapt->SendPacketPoolHandle);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        PSEND_RSVD            SendRsvd;

        //
        // Save a pointer to the original packet in our reserved
        // area in the new packet. This is needed so that we can
        // get back to the original packet when the new packet's send
        // is completed.
        //
        SendRsvd = (PSEND_RSVD)(MyPacket->ProtocolReserved);
        SendRsvd->OriginalPkt = Packet;

        MyPacket->Private.Flags = Flags;

        //
        // Set up the new packet so that it describes the same
        // data as the original packet.
        //
        MyPacket->Private.Head = Packet->Private.Head;
        MyPacket->Private.Tail = Packet->Private.Tail;
#ifdef WIN9X
        //
        // Work around the fact that NDIS does not initialize this
        // to FALSE on Win9x.
        //
        MyPacket->Private.ValidCounts = FALSE;
#endif

        //
        // Copy the OOB Offset from the original packet to the new
        // packet.
        //
        NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(MyPacket),
                       NDIS_OOB_DATA_FROM_PACKET(Packet),
                       sizeof(NDIS_PACKET_OOB_DATA));

#ifndef WIN9X
        //
        // Copy the right parts of per packet info into the new packet.
        // This API is not available on Win9x since task offload is
        // not supported on that platform.
        //
        NdisIMCopySendPerPacketInfo(MyPacket, Packet);
#endif
        
        //
        // Copy the Media specific information
        //
        NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(Packet,
                                            &MediaSpecificInfo,
                                            &MediaSpecificInfoSize);

        if (MediaSpecificInfo || MediaSpecificInfoSize)
        {
            NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(MyPacket,
                                                MediaSpecificInfo,
                                                MediaSpecificInfoSize);
        }

        NdisSend(&Status,
                 pAdapt->BindingHandle,
                 MyPacket);


        if (Status != NDIS_STATUS_PENDING)
        {
#ifndef WIN9X
            NdisIMCopySendCompletePerPacketInfo (Packet, MyPacket);
#endif
            NdisFreePacket(MyPacket);
            ADAPT_DECR_PENDING_SENDS(pAdapt);
        }
    }
    else
    {
        ADAPT_DECR_PENDING_SENDS(pAdapt);
        //
        // We are out of packets. Silently drop it. Alternatively we can deal with it:
        //    - By keeping separate send and receive pools
        //    - Dynamically allocate more pools as needed and free them when not needed
        //
    }

    return(Status);
}


VOID
MPSendPackets(
    IN NDIS_HANDLE             MiniportAdapterContext,
    IN PPNDIS_PACKET           PacketArray,
    IN UINT                    NumberOfPackets
    )
/*++

Routine Description:

    Send Packet Array handler. Either this or our SendPacket handler is called
    based on which one is enabled in our Miniport Characteristics.

Arguments:

    MiniportAdapterContext     Pointer to our adapter
    PacketArray                Set of packets to send
    NumberOfPackets            Self-explanatory

Return Value:

    None

--*/
{
    PADAPT              pAdapt = (PADAPT)MiniportAdapterContext;
    NDIS_STATUS         Status;
    UINT                i;
    PVOID               MediaSpecificInfo = NULL;
    UINT                MediaSpecificInfoSize = 0;
    

    for (i = 0; i < NumberOfPackets; i++)
    {
        PNDIS_PACKET    Packet, MyPacket;

        Packet = PacketArray[i];
        //
        // The driver should fail the send if the virtual miniport is in low 
        // power state
        //
        if (pAdapt->MPDeviceState > NdisDeviceStateD0)
        {
            NdisMSendComplete(ADAPT_MINIPORT_HANDLE(pAdapt),
                            Packet,
                            NDIS_STATUS_FAILURE);
            continue;
        }

#ifdef NDIS51

        //
        // Use NDIS 5.1 packet stacking:
        //
        {
            PNDIS_PACKET_STACK        pStack;
            BOOLEAN                   Remaining;

            //
            // Packet stacks: Check if we can use the same packet for sending down.
            //
            pStack = NdisIMGetCurrentPacketStack(Packet, &Remaining);
            if (Remaining)
            {
                //
                // We can reuse "Packet".
                //
                // NOTE: if we needed to keep per-packet information in packets
                // sent down, we can use pStack->IMReserved[].
                //
                ASSERT(pStack);
                //
                // If the below miniport is going to low power state, stop sending down any packet.
                //
                NdisAcquireSpinLock(&pAdapt->Lock);
                if (pAdapt->PTDeviceState > NdisDeviceStateD0)
                {
                    NdisReleaseSpinLock(&pAdapt->Lock);
                    NdisMSendComplete(ADAPT_MINIPORT_HANDLE(pAdapt),
                                        Packet,
                                        NDIS_STATUS_FAILURE);
                }
                else
                {
                    pAdapt->OutstandingSends++;
                    NdisReleaseSpinLock(&pAdapt->Lock);
                
                    NdisSend(&Status,
                              pAdapt->BindingHandle,
                              Packet);
        
                    if (Status != NDIS_STATUS_PENDING)
                    {
                        NdisMSendComplete(ADAPT_MINIPORT_HANDLE(pAdapt),
                                            Packet,
                                            Status);
                   
                        ADAPT_DECR_PENDING_SENDS(pAdapt);
                    }
                }
                continue;
            }
        }
#endif
        do 
        {
            NdisAcquireSpinLock(&pAdapt->Lock);
            //
            // If the below miniport is going to low power state, stop sending down any packet.
            //
            if (pAdapt->PTDeviceState > NdisDeviceStateD0)
            {
                NdisReleaseSpinLock(&pAdapt->Lock);
                Status = NDIS_STATUS_FAILURE;
                break;
            }
            pAdapt->OutstandingSends++;
            NdisReleaseSpinLock(&pAdapt->Lock);
            
            NdisAllocatePacket(&Status,
                               &MyPacket,
                               pAdapt->SendPacketPoolHandle);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                PSEND_RSVD        SendRsvd;

                SendRsvd = (PSEND_RSVD)(MyPacket->ProtocolReserved);
                SendRsvd->OriginalPkt = Packet;

                MyPacket->Private.Flags = NdisGetPacketFlags(Packet);

                MyPacket->Private.Head = Packet->Private.Head;
                MyPacket->Private.Tail = Packet->Private.Tail;
#ifdef WIN9X
                //
                // Work around the fact that NDIS does not initialize this
                // to FALSE on Win9x.
                //
                MyPacket->Private.ValidCounts = FALSE;
#endif // WIN9X

                //
                // Copy the OOB data from the original packet to the new
                // packet.
                //
                NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(MyPacket),
                            NDIS_OOB_DATA_FROM_PACKET(Packet),
                            sizeof(NDIS_PACKET_OOB_DATA));
                //
                // Copy relevant parts of the per packet info into the new packet
                //
#ifndef WIN9X
                NdisIMCopySendPerPacketInfo(MyPacket, Packet);
#endif

                //
                // Copy the Media specific information
                //
                NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(Packet,
                                                    &MediaSpecificInfo,
                                                    &MediaSpecificInfoSize);

                if (MediaSpecificInfo || MediaSpecificInfoSize)
                {
                    NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(MyPacket,
                                                        MediaSpecificInfo,
                                                        MediaSpecificInfoSize);
                }

                NdisSend(&Status,
                         pAdapt->BindingHandle,
                         MyPacket);

                if (Status != NDIS_STATUS_PENDING)
                {
#ifndef WIN9X
                    NdisIMCopySendCompletePerPacketInfo (Packet, MyPacket);
#endif
                    NdisFreePacket(MyPacket);
                    ADAPT_DECR_PENDING_SENDS(pAdapt);
                }
            }
            else
            {
                //
                // The driver cannot allocate a packet.
                // 
                ADAPT_DECR_PENDING_SENDS(pAdapt);
            }
        }
        while (FALSE);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisMSendComplete(ADAPT_MINIPORT_HANDLE(pAdapt),
                              Packet,
                              Status);
        }
    }
}


NDIS_STATUS
MPQueryInformation(
    IN NDIS_HANDLE                MiniportAdapterContext,
    IN NDIS_OID                   Oid,
    IN PVOID                      InformationBuffer,
    IN ULONG                      InformationBufferLength,
    OUT PULONG                    BytesWritten,
    OUT PULONG                    BytesNeeded
    )
/*++

Routine Description:

    Entry point called by NDIS to query for the value of the specified OID.
    Typical processing is to forward the query down to the underlying miniport.

    The following OIDs are filtered here:

    OID_PNP_QUERY_POWER - return success right here

    OID_GEN_SUPPORTED_GUIDS - do not forward, otherwise we will show up
    multiple instances of private GUIDs supported by the underlying miniport.

    OID_PNP_CAPABILITIES - we do send this down to the lower miniport, but
    the values returned are postprocessed before we complete this request;
    see PtRequestComplete.

    NOTE on OID_TCP_TASK_OFFLOAD - if this IM driver modifies the contents
    of data it passes through such that a lower miniport may not be able
    to perform TCP task offload, then it should not forward this OID down,
    but fail it here with the status NDIS_STATUS_NOT_SUPPORTED. This is to
    avoid performing incorrect transformations on data.

    If our miniport edge (upper edge) is at a low-power state, fail the request.

    If our protocol edge (lower edge) has been notified of a low-power state,
    we pend this request until the miniport below has been set to D0. Since
    requests to miniports are serialized always, at most a single request will
    be pended.

Arguments:

    MiniportAdapterContext    Pointer to the adapter structure
    Oid                       Oid for this query
    InformationBuffer         Buffer for information
    InformationBufferLength   Size of this buffer
    BytesWritten              Specifies how much info is written
    BytesNeeded               In case the buffer is smaller than what we need, tell them how much is needed


Return Value:

    Return code from the NdisRequest below.

--*/
{
    PADAPT        pAdapt = (PADAPT)MiniportAdapterContext;
    NDIS_STATUS   Status = NDIS_STATUS_FAILURE;

    do
    {
        if (Oid == OID_PNP_QUERY_POWER)
        {
            //
            //  Do not forward this.
            //
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        if (Oid == OID_GEN_SUPPORTED_GUIDS)
        {
            //
            //  Do not forward this, otherwise we will end up with multiple
            //  instances of private GUIDs that the underlying miniport
            //  supports.
            //
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        if (Oid == OID_TCP_TASK_OFFLOAD)
        {
            //
            // Fail this -if- this driver performs data transformations
            // that can interfere with a lower driver's ability to offload
            // TCP tasks.
            //
            // Status = NDIS_STATUS_NOT_SUPPORTED;
            // break;
            //
        }
        //
        // If the miniport below is unbinding, just fail any request
        //
        NdisAcquireSpinLock(&pAdapt->Lock);
        if (pAdapt->UnbindingInProcess == TRUE)
        {
            NdisReleaseSpinLock(&pAdapt->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        NdisReleaseSpinLock(&pAdapt->Lock);
        //
        // All other queries are failed, if the miniport is not at D0,
        //
        if (pAdapt->MPDeviceState > NdisDeviceStateD0) 
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        pAdapt->Request.RequestType = NdisRequestQueryInformation;
        pAdapt->Request.DATA.QUERY_INFORMATION.Oid = Oid;
        pAdapt->Request.DATA.QUERY_INFORMATION.InformationBuffer = InformationBuffer;
        pAdapt->Request.DATA.QUERY_INFORMATION.InformationBufferLength = InformationBufferLength;
        pAdapt->BytesNeeded = BytesNeeded;
        pAdapt->BytesReadOrWritten = BytesWritten;

        //
        // If the miniport below is binding, fail the request
        //
        NdisAcquireSpinLock(&pAdapt->Lock);
            
        if (pAdapt->UnbindingInProcess == TRUE)
        {
            NdisReleaseSpinLock(&pAdapt->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        //
        // If the Protocol device state is OFF, mark this request as being 
        // pended. We queue this until the device state is back to D0. 
        //
        if ((pAdapt->PTDeviceState > NdisDeviceStateD0) 
                && (pAdapt->StandingBy == FALSE))
        {
            pAdapt->QueuedRequest = TRUE;
            NdisReleaseSpinLock(&pAdapt->Lock);
            Status = NDIS_STATUS_PENDING;
            break;
        }
        //
        // This is in the process of powering down the system, always fail the request
        // 
        if (pAdapt->StandingBy == TRUE)
        {
            NdisReleaseSpinLock(&pAdapt->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        pAdapt->OutstandingRequests = TRUE;
        
        NdisReleaseSpinLock(&pAdapt->Lock);

        //
        // default case, most requests will be passed to the miniport below
        //
        NdisRequest(&Status,
                    pAdapt->BindingHandle,
                    &pAdapt->Request);


        if (Status != NDIS_STATUS_PENDING)
        {
            PtRequestComplete(pAdapt, &pAdapt->Request, Status);
            Status = NDIS_STATUS_PENDING;
        }

    } while (FALSE);

    return(Status);

}


VOID
MPQueryPNPCapabilities(
    IN OUT PADAPT            pAdapt,
    OUT PNDIS_STATUS         pStatus
    )
/*++

Routine Description:

    Postprocess a request for OID_PNP_CAPABILITIES that was forwarded
    down to the underlying miniport, and has been completed by it.

Arguments:

    pAdapt - Pointer to the adapter structure
    pStatus - Place to return final status

Return Value:

    None.

--*/

{
    PNDIS_PNP_CAPABILITIES           pPNPCapabilities;
    PNDIS_PM_WAKE_UP_CAPABILITIES    pPMstruct;

    if (pAdapt->Request.DATA.QUERY_INFORMATION.InformationBufferLength >= sizeof(NDIS_PNP_CAPABILITIES))
    {
        pPNPCapabilities = (PNDIS_PNP_CAPABILITIES)(pAdapt->Request.DATA.QUERY_INFORMATION.InformationBuffer);

        //
        // The following fields must be overwritten by an IM driver.
        //
        pPMstruct= & pPNPCapabilities->WakeUpCapabilities;
        pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
        pPMstruct->MinPatternWakeUp = NdisDeviceStateUnspecified;
        pPMstruct->MinLinkChangeWakeUp = NdisDeviceStateUnspecified;
        *pAdapt->BytesReadOrWritten = sizeof(NDIS_PNP_CAPABILITIES);
        *pAdapt->BytesNeeded = 0;


        //
        // Setting our internal flags
        // Default, device is ON
        //
        pAdapt->MPDeviceState = NdisDeviceStateD0;
        pAdapt->PTDeviceState = NdisDeviceStateD0;

        *pStatus = NDIS_STATUS_SUCCESS;
    }
    else
    {
        *pAdapt->BytesNeeded= sizeof(NDIS_PNP_CAPABILITIES);
        *pStatus = NDIS_STATUS_RESOURCES;
    }
}


NDIS_STATUS
MPSetInformation(
    IN NDIS_HANDLE             MiniportAdapterContext,
    IN NDIS_OID                Oid,
    IN PVOID                   InformationBuffer,
    IN ULONG                   InformationBufferLength,
    OUT PULONG                 BytesRead,
    OUT PULONG                 BytesNeeded
    )
/*++

Routine Description:

    Miniport SetInfo handler.

    In the case of OID_PNP_SET_POWER, record the power state and return the OID.    
    Do not pass below
    If the device is suspended, do not block the SET_POWER_OID 
    as it is used to reactivate the Passthru miniport

    
    PM- If the MP is not ON (DeviceState > D0) return immediately  (except for 'query power' and 'set power')
         If MP is ON, but the PT is not at D0, then queue the queue the request for later processing

    Requests to miniports are always serialized


Arguments:

    MiniportAdapterContext    Pointer to the adapter structure
    Oid                       Oid for this query
    InformationBuffer         Buffer for information
    InformationBufferLength   Size of this buffer
    BytesRead                 Specifies how much info is read
    BytesNeeded               In case the buffer is smaller than what we need, tell them how much is needed

Return Value:

    Return code from the NdisRequest below.

--*/
{
    PADAPT        pAdapt = (PADAPT)MiniportAdapterContext;
    NDIS_STATUS   Status;

    Status = NDIS_STATUS_FAILURE;

    do
    {
        //
        // The Set Power should not be sent to the miniport below the Passthru, but is handled internally
        //
        if (Oid == OID_PNP_SET_POWER)
        {
            MPProcessSetPowerOid(&Status, 
                                 pAdapt, 
                                 InformationBuffer, 
                                 InformationBufferLength, 
                                 BytesRead, 
                                 BytesNeeded);
            break;

        }

        //
        // If the miniport below is unbinding, fail the request
        //
        NdisAcquireSpinLock(&pAdapt->Lock);     
        if (pAdapt->UnbindingInProcess == TRUE)
        {
            NdisReleaseSpinLock(&pAdapt->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        NdisReleaseSpinLock(&pAdapt->Lock);
        //
        // All other Set Information requests are failed, if the miniport is
        // not at D0 or is transitioning to a device state greater than D0.
        //
        if (pAdapt->MPDeviceState > NdisDeviceStateD0)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        // Set up the Request and return the result
        pAdapt->Request.RequestType = NdisRequestSetInformation;
        pAdapt->Request.DATA.SET_INFORMATION.Oid = Oid;
        pAdapt->Request.DATA.SET_INFORMATION.InformationBuffer = InformationBuffer;
        pAdapt->Request.DATA.SET_INFORMATION.InformationBufferLength = InformationBufferLength;
        pAdapt->BytesNeeded = BytesNeeded;
        pAdapt->BytesReadOrWritten = BytesRead;

        //
        // If the miniport below is unbinding, fail the request
        //
        NdisAcquireSpinLock(&pAdapt->Lock);     
        if (pAdapt->UnbindingInProcess == TRUE)
        {
            NdisReleaseSpinLock(&pAdapt->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }
            
        //
        // If the device below is at a low power state, we cannot send it the
        // request now, and must pend it.
        //
        if ((pAdapt->PTDeviceState > NdisDeviceStateD0) 
                && (pAdapt->StandingBy == FALSE))
        {
            pAdapt->QueuedRequest = TRUE;
            NdisReleaseSpinLock(&pAdapt->Lock);
            Status = NDIS_STATUS_PENDING;
            break;
        }
        //
        // This is in the process of powering down the system, always fail the request
        // 
        if (pAdapt->StandingBy == TRUE)
        {
            NdisReleaseSpinLock(&pAdapt->Lock);
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        pAdapt->OutstandingRequests = TRUE;
        
        NdisReleaseSpinLock(&pAdapt->Lock);
        //
        // Forward the request to the device below.
        //
        NdisRequest(&Status,
                    pAdapt->BindingHandle,
                    &pAdapt->Request);

        if (Status != NDIS_STATUS_PENDING)
        {
            *BytesRead = pAdapt->Request.DATA.SET_INFORMATION.BytesRead;
            *BytesNeeded = pAdapt->Request.DATA.SET_INFORMATION.BytesNeeded;
            pAdapt->OutstandingRequests = FALSE;
        }

    } while (FALSE);

    return(Status);
}


VOID
MPProcessSetPowerOid(
    IN OUT PNDIS_STATUS          pNdisStatus,
    IN PADAPT                    pAdapt,
    IN PVOID                     InformationBuffer,
    IN ULONG                     InformationBufferLength,
    OUT PULONG                   BytesRead,
    OUT PULONG                   BytesNeeded
    )
/*++

Routine Description:
    This routine does all the procssing for a request with a SetPower Oid
    The miniport shoud accept  the Set Power and transition to the new state

    The Set Power should not be passed to the miniport below

    If the IM miniport is going into a low power state, then there is no guarantee if it will ever
    be asked go back to D0, before getting halted. No requests should be pended or queued.

    
Arguments:
    pNdisStatus           - Status of the operation
    pAdapt                - The Adapter structure
    InformationBuffer     - The New DeviceState
    InformationBufferLength
    BytesRead             - No of bytes read
    BytesNeeded           -  No of bytes needed


Return Value:
    Status  - NDIS_STATUS_SUCCESS if all the wait events succeed.

--*/
{

    
    NDIS_DEVICE_POWER_STATE NewDeviceState;

    DBGPRINT(("==>MPProcessSetPowerOid: Adapt %p\n", pAdapt)); 

    ASSERT (InformationBuffer != NULL);

    *pNdisStatus = NDIS_STATUS_FAILURE;

    do 
    {
        //
        // Check for invalid length
        //
        if (InformationBufferLength < sizeof(NDIS_DEVICE_POWER_STATE))
        {
            *pNdisStatus = NDIS_STATUS_INVALID_LENGTH;
            break;
        }

        NewDeviceState = (*(PNDIS_DEVICE_POWER_STATE)InformationBuffer);

        //
        // Check for invalid device state
        //
        if ((pAdapt->MPDeviceState > NdisDeviceStateD0) && (NewDeviceState != NdisDeviceStateD0))
        {
            //
            // If the miniport is in a non-D0 state, the miniport can only receive a Set Power to D0
            //
            ASSERT (!(pAdapt->MPDeviceState > NdisDeviceStateD0) && (NewDeviceState != NdisDeviceStateD0));

            *pNdisStatus = NDIS_STATUS_FAILURE;
            break;
        }    

        //
        // Is the miniport transitioning from an On (D0) state to an Low Power State (>D0)
        // If so, then set the StandingBy Flag - (Block all incoming requests)
        //
        if (pAdapt->MPDeviceState == NdisDeviceStateD0 && NewDeviceState > NdisDeviceStateD0)
        {
            pAdapt->StandingBy = TRUE;
        }

        //
        // If the miniport is transitioning from a low power state to ON (D0), then clear the StandingBy flag
        // All incoming requests will be pended until the physical miniport turns ON.
        //
        if (pAdapt->MPDeviceState > NdisDeviceStateD0 &&  NewDeviceState == NdisDeviceStateD0)
        {
            pAdapt->StandingBy = FALSE;
        }
        
        //
        // Now update the state in the pAdapt structure;
        //
        pAdapt->MPDeviceState = NewDeviceState;
        
        *pNdisStatus = NDIS_STATUS_SUCCESS;
    

    } while (FALSE);    
        
    if (*pNdisStatus == NDIS_STATUS_SUCCESS)
    {
        //
        // The miniport resume from low power state
        // 
        if (pAdapt->StandingBy == FALSE)
        {
            //
            // If we need to indicate the media connect state
            // 
            if (pAdapt->LastIndicatedStatus != pAdapt->LatestUnIndicateStatus)
            {
               NdisMIndicateStatus(pAdapt->MiniportHandle,
                                        pAdapt->LatestUnIndicateStatus,
                                        (PVOID)NULL,
                                        0);
               NdisMIndicateStatusComplete(pAdapt->MiniportHandle);
               pAdapt->LastIndicatedStatus = pAdapt->LatestUnIndicateStatus;
            }
        }
        else
        {
            //
            // Initialize LatestUnIndicatedStatus
            //
            pAdapt->LatestUnIndicateStatus = pAdapt->LastIndicatedStatus;
        }
        *BytesRead = sizeof(NDIS_DEVICE_POWER_STATE);
        *BytesNeeded = 0;
    }
    else
    {
        *BytesRead = 0;
        *BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE);
    }

    DBGPRINT(("<==MPProcessSetPowerOid: Adapt %p\n", pAdapt)); 
}


VOID
MPReturnPacket(
    IN NDIS_HANDLE             MiniportAdapterContext,
    IN PNDIS_PACKET            Packet
    )
/*++

Routine Description:

    NDIS Miniport entry point called whenever protocols are done with
    a packet that we had indicated up and they had queued up for returning
    later.

Arguments:

    MiniportAdapterContext    - pointer to ADAPT structure
    Packet    - packet being returned.

Return Value:

    None.

--*/
{
    PADAPT            pAdapt = (PADAPT)MiniportAdapterContext;

#ifdef NDIS51
    //
    // Packet stacking: Check if this packet belongs to us.
    //
    if (NdisGetPoolFromPacket(Packet) != pAdapt->RecvPacketPoolHandle)
    {
        //
        // We reused the original packet in a receive indication.
        // Simply return it to the miniport below us.
        //
        NdisReturnPackets(&Packet, 1);
    }
    else
#endif // NDIS51
    {
        //
        // This is a packet allocated from this IM's receive packet pool.
        // Reclaim our packet, and return the original to the driver below.
        //

        PNDIS_PACKET    MyPacket;
        PRECV_RSVD      RecvRsvd;
    
        RecvRsvd = (PRECV_RSVD)(Packet->MiniportReserved);
        MyPacket = RecvRsvd->OriginalPkt;
    
        NdisFreePacket(Packet);
        NdisReturnPackets(&MyPacket, 1);
    }
}


NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred,
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN NDIS_HANDLE              MiniportReceiveContext,
    IN UINT                     ByteOffset,
    IN UINT                     BytesToTransfer
    )
/*++

Routine Description:

    Miniport's transfer data handler.

Arguments:

    Packet                    Destination packet
    BytesTransferred          Place-holder for how much data was copied
    MiniportAdapterContext    Pointer to the adapter structure
    MiniportReceiveContext    Context
    ByteOffset                Offset into the packet for copying data
    BytesToTransfer           How much to copy.

Return Value:

    Status of transfer

--*/
{
    PADAPT        pAdapt = (PADAPT)MiniportAdapterContext;
    NDIS_STATUS   Status;

    //
    // Return, if the device is OFF
    //

    if (IsIMDeviceStateOn(pAdapt) == FALSE)
    {
        return NDIS_STATUS_FAILURE;
    }

    NdisTransferData(&Status,
                     pAdapt->BindingHandle,
                     MiniportReceiveContext,
                     ByteOffset,
                     BytesToTransfer,
                     Packet,
                     BytesTransferred);

    return(Status);
}

VOID
MPHalt(
    IN NDIS_HANDLE                MiniportAdapterContext
    )
/*++

Routine Description:

    Halt handler. All the hard-work for clean-up is done here.

Arguments:

    MiniportAdapterContext    Pointer to the Adapter

Return Value:

    None.

--*/
{
    PADAPT             pAdapt = (PADAPT)MiniportAdapterContext;
    NDIS_STATUS        Status;
    PADAPT            *ppCursor;

    DBGPRINT(("==>MiniportHalt: Adapt %p\n", pAdapt));

    //
    // Remove this adapter from the global list
    //
    NdisAcquireSpinLock(&GlobalLock);

    for (ppCursor = &pAdaptList; *ppCursor != NULL; ppCursor = &(*ppCursor)->Next)
    {
        if (*ppCursor == pAdapt)
        {
            *ppCursor = pAdapt->Next;
            break;
        }
    }

    NdisReleaseSpinLock(&GlobalLock);

    //
    // Delete the ioctl interface that was created when the miniport
    // was created.
    //
    (VOID)PtDeregisterDevice();

    //
    // If we have a valid bind, close the miniport below the protocol
    //
    if (pAdapt->BindingHandle != NULL)
    {
        //
        // Close the binding below. and wait for it to complete
        //
        NdisResetEvent(&pAdapt->Event);

        NdisCloseAdapter(&Status, pAdapt->BindingHandle);

        if (Status == NDIS_STATUS_PENDING)
        {
            NdisWaitEvent(&pAdapt->Event, 0);
            Status = pAdapt->Status;
        }

        ASSERT (Status == NDIS_STATUS_SUCCESS);

        pAdapt->BindingHandle = NULL;
    }

    //
    //  Free all resources on this adapter structure.
    //
    MPFreeAllPacketPools (pAdapt);
    NdisFreeMemory(pAdapt, 0, 0);

    DBGPRINT(("<== MiniportHalt: pAdapt %p\n", pAdapt));
}


#ifdef NDIS51_MINIPORT

VOID
MPCancelSendPackets(
    IN NDIS_HANDLE            MiniportAdapterContext,
    IN PVOID                  CancelId
    )
/*++

Routine Description:

    The miniport entry point to handle cancellation of all send packets
    that match the given CancelId. If we have queued any packets that match
    this, then we should dequeue them and call NdisMSendComplete for all
    such packets, with a status of NDIS_STATUS_REQUEST_ABORTED.

    We should also call NdisCancelSendPackets in turn, on each lower binding
    that this adapter corresponds to. This is to let miniports below cancel
    any matching packets.

Arguments:

    MiniportAdapterContext    - pointer to ADAPT structure
    CancelId    - ID of packets to be cancelled.

Return Value:

    None

--*/
{
    PADAPT    pAdapt = (PADAPT)MiniportAdapterContext;

    //
    // If we queue packets on our adapter structure, this would be 
    // the place to acquire a spinlock to it, unlink any packets whose
    // Id matches CancelId, release the spinlock and call NdisMSendComplete
    // with NDIS_STATUS_REQUEST_ABORTED for all unlinked packets.
    //

    //
    // Next, pass this down so that we let the miniport(s) below cancel
    // any packets that they might have queued.
    //
    NdisCancelSendPackets(pAdapt->BindingHandle, CancelId);

    return;
}

VOID
MPDevicePnPEvent(
    IN NDIS_HANDLE              MiniportAdapterContext,
    IN NDIS_DEVICE_PNP_EVENT    DevicePnPEvent,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength
    )
/*++

Routine Description:

    This handler is called to notify us of PnP events directed to
    our miniport device object.

Arguments:

    MiniportAdapterContext    - pointer to ADAPT structure
    DevicePnPEvent - the event
    InformationBuffer - Points to additional event-specific information
    InformationBufferLength - length of above

Return Value:

    None
--*/
{
    // TBD - add code/comments about processing this.

    UNREFERENCED_PARAMETER(MiniportAdapterContext);
    UNREFERENCED_PARAMETER(DevicePnPEvent);
    UNREFERENCED_PARAMETER(InformationBuffer);
    UNREFERENCED_PARAMETER(InformationBufferLength);
    
    return;
}

VOID
MPAdapterShutdown(
    IN NDIS_HANDLE                MiniportAdapterContext
    )
/*++

Routine Description:

    This handler is called to notify us of an impending system shutdown.

Arguments:

    MiniportAdapterContext    - pointer to ADAPT structure

Return Value:

    None
--*/
{
    UNREFERENCED_PARAMETER(MiniportAdapterContext);
    
    return;
}

#endif


VOID
MPFreeAllPacketPools(
    IN PADAPT                    pAdapt
    )
/*++

Routine Description:

    Free all packet pools on the specified adapter.
    
Arguments:

    pAdapt    - pointer to ADAPT structure

Return Value:

    None

--*/
{
    if (pAdapt->RecvPacketPoolHandle != NULL)
    {
        //
        // Free the packet pool that is used to indicate receives
        //
        NdisFreePacketPool(pAdapt->RecvPacketPoolHandle);

        pAdapt->RecvPacketPoolHandle = NULL;
    }

    if (pAdapt->SendPacketPoolHandle != NULL)
    {

        //
        //  Free the packet pool that is used to send packets below
        //

        NdisFreePacketPool(pAdapt->SendPacketPoolHandle);

        pAdapt->SendPacketPoolHandle = NULL;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\adapter.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Adapter Adapter_c

@module Adapter.c |

    This module implements the interface to the <t MINIPORT_ADAPTER_OBJECT>.
    Supports the high-level adapter control functions used by the NDIS WAN
    Minport driver.  This module isolates most the NDIS specific logical
    adapter interfaces.  It should require very little change if you follow
    this same overall architecture.  You should try to isolate your changes
    to the <t CARD_OBJECT> that is contained within the logical adapter
    <t MINIPORT_ADAPTER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Adapter_c

@end

*/

#define  __FILEID__             MINIPORT_ADAPTER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


PMINIPORT_ADAPTER_OBJECT        g_Adapters[MAX_ADAPTERS]    // @globalv
// Keeps track of all the <t MINIPORT_ADAPTER_OBJECT>s created by the driver.
                                = { 0 };

DBG_STATIC ULONG                g_AdapterInstanceCounter    // @globalv
// Keeps track of how many <t MINIPORT_ADAPTER_OBJECT>s are created and
// stored in the <p g_Adapters> array.
                                = 0;

DBG_STATIC UCHAR                g_AnsiDriverName[]          // @globalv
// ANSI string used to identify the driver to the system; usually defined
// as VER_PRODUCT_STR.
                                = VER_PRODUCT_STR;

DBG_STATIC UCHAR                g_AnsiVendorDescription[]   // @globalv
// ANSI string used to identify the vendor's device to the system; usually
// defined as VER_DEVICE_STR " Adapter".
                                = VER_DEVICE_STR " Adapter";


/* @doc INTERNAL EXTERNAL Adapter Adapter_c g_AdapterParameters


@topic 5.1 Adapter Parameters |

    This section describes the registry parameters read into the
    <t MINIPORT_ADAPTER_OBJECT>.

@globalv DBG_STATIC <t PARAM_TABLE> | g_AdapterParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t MINIPORT_ADAPTER_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t MINIPORT_ADAPTER_OBJECT>
    you will need to modify <f AdapterReadParameters> and add the parameter
    definitions to the <f g_AdapterParameters> table.

*/

DBG_STATIC NDIS_STRING      g_DefaultAddressList                // @globalv
// Default value to be used for AddressList if it's not in the registry.
                        = INIT_STRING_CONST(VER_DEFAULT_ADDRESSLIST);

DBG_STATIC NDIS_STRING      g_DefaultDeviceName                 // @globalv
// Default value to be used for DeviceName if it's not in the registry.
                        = INIT_STRING_CONST(VER_PRODUCT_STR);

DBG_STATIC NDIS_STRING      g_DefaultMediaType                  // @globalv
// Default value to be used for MediaType if it's not in the registry.
                        = INIT_STRING_CONST(VER_DEFAULT_MEDIATYPE);

DBG_STATIC PARAM_TABLE      g_AdapterParameters[] =
{
#if !defined(NDIS50_MINIPORT)
    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                BusNumber, PARAM_BusNumber,
                TRUE, NdisParameterInteger, 0,
                0, 0, 15),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                BusType, PARAM_BusType,
                TRUE, NdisParameterInteger, 0,
                0, Internal, MaximumInterfaceType),
#endif // NDIS50_MINIPORT

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                TapiAddressList, PARAM_AddressList,
                FALSE, NdisParameterMultiString, 0,
                &g_DefaultAddressList, 0, 0),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                DeviceName, PARAM_DeviceName,
                FALSE, NdisParameterString, 0,
                &g_DefaultDeviceName, 0, 0),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                MediaType, PARAM_MediaType,
                FALSE, NdisParameterString, 0,
                &g_DefaultMediaType, 0, 0),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                NoAnswerTimeOut, PARAM_NoAnswerTimeOut,
                FALSE, NdisParameterHexInteger, 0,
                CARD_NO_ANSWER_TIMEOUT, 5000, 120000),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                NoAcceptTimeOut, PARAM_NoAcceptTimeOut,
                FALSE, NdisParameterHexInteger, 0,
                CARD_NO_ACCEPT_TIMEOUT, 1000, 60000),

    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                RunningWin95, PARAM_RunningWin95,
                FALSE, NdisParameterInteger, 0,
                0, 0, 1),

#if DBG
    PARAM_ENTRY(MINIPORT_ADAPTER_OBJECT,
                DbgFlags, PARAM_DebugFlags,
                FALSE, NdisParameterHexInteger, 0,
                DBG_DEFAULTS | DBG_TAPICALL_ON, 0, 0xffffffff),
                // TODO: Change the debug flags to meet your needs.
#endif
    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL Adapter Adapter_c AdapterReadParameters


@func

    <f AdapterReadParameters> reads the adapter parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f AdapterCreate>.

    <f Note>:
    If you add any registry based data members to <t MINIPORT_ADAPTER_OBJECT>
    you will need to modify <f AdapterReadParameters> and add the parameter
    definitions to the <f g_AdapterParameters> table.

@rdesc

    <f AdapterReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS AdapterReadParameters(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterReadParameters")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Parse the registry parameters.
    */
    Result = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pAdapter,
                    g_AdapterParameters
                    );

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pAdapter->TODO)
        {
            DBG_ERROR(DbgInfo,("Invalid value 'TODO'\n",
                        pAdapter->TODO));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pAdapter->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Result = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Construct the "MediaType\0DeviceName" string for use by TAPI
            // on Windows NT.
            */
            strcpy(pAdapter->ProviderInfo, pAdapter->MediaType.Buffer);
            strcpy(pAdapter->ProviderInfo + pAdapter->MediaType.Length + 1,
                    pAdapter->DeviceName.Buffer);
            pAdapter->ProviderInfoSize = pAdapter->MediaType.Length + 1 +
                    pAdapter->DeviceName.Length + 1;

            DBG_NOTICE(DbgInfo,("ProviderInfoMedia='%s\\0%s'\n",
                       &pAdapter->ProviderInfo[0],
                       &pAdapter->ProviderInfo[pAdapter->MediaType.Length + 1]
                       ));
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterCreateObjects


@func

    <f AdapterCreateObjects> calls the create routines for all the objects
    contained in <t MINIPORT_ADAPTER_OBJECT>.  This should only be called
    by <f AdapterCreate>.

    <f Note>:
    If you add any new objects to <t MINIPORT_ADAPTER_OBJECT> you will need
    to modify <f AdapterCreateObjects> and <f AdapterDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f AdapterCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS AdapterCreateObjects(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterCreateObjects")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    ULONG                       Index;
    // Loop counter.

    ULONG                       NumBChannels;
    // The number of BChannels supported by the NIC.

    PANSI_STRING                pTapiAddressList;
    // MultiString of RAS address strings.

    PUCHAR                      pTapiLineAddress;
    // A pointer to the RAS/TAPI line address assigned to each RAS line.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Create the Card object.
    */
    Result = CardCreate(&pAdapter->pCard, pAdapter);

    /*
    // Create the DChannel object.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        Result = DChannelCreate(&pAdapter->pDChannel, pAdapter);
    }

    /*
    // Allocate space for the BChannels.
    */
    if (Result == NDIS_STATUS_SUCCESS)
    {
        NumBChannels = CardNumChannels(pAdapter->pCard);

        Result = ALLOCATE_MEMORY(pAdapter->pBChannelArray,
                                 sizeof(PVOID) * NumBChannels,
                                 pAdapter->MiniportAdapterHandle);
    }

    /*
    // Create the BChannel objects.
    */
    pTapiAddressList = &pAdapter->TapiAddressList;
    pTapiLineAddress = pTapiAddressList->Buffer;

    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < NumBChannels; Index++)
    {
        Result = BChannelCreate(&pAdapter->pBChannelArray[Index],
                                Index,
                                pTapiLineAddress,
                                pAdapter);

        /*
        // If we run off the end of the address list, we just point at the
        // null terminator for the other addresses.  This might happen if
        // some of the lines were not configured for use with RAS/TAPI.
        */
        pTapiLineAddress += strlen(pTapiLineAddress) + 1;
        if ((pTapiLineAddress - pTapiAddressList->Buffer) >=
             pTapiAddressList->Length)
        {
            --pTapiLineAddress;
        }

        /*
        // Keep track of how many are created.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            pAdapter->NumBChannels++;
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterCreate


@func

    <f AdapterCreate> allocates memory for a <t MINIPORT_ADAPTER_OBJECT> and
    then initializes the data members to their starting state.
    If successful, <p ppAdapter> will be set to point to the newly created
    <t MINIPORT_ADAPTER_OBJECT>.  Otherwise, <p ppAdapter> will be set to
    NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f AdapterDestroy> must be called to
    release the <t MINIPORT_ADAPTER_OBJECT> created by this function.

@rdesc

    <f AdapterCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS AdapterCreate(
    OUT PMINIPORT_ADAPTER_OBJECT *ppAdapter,                // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t MINIPORT_ADAPTER_OBJECT>.

    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    IN NDIS_HANDLE              WrapperConfigurationContext // @parm
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.
    )
{
    DBG_FUNC("AdapterCreate")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // Pointer to our newly allocated object.

    DBG_ENTER(DbgInfo);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppAdapter = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pAdapter, MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pAdapter->ObjectType = MINIPORT_ADAPTER_OBJECT_TYPE;
        pAdapter->ObjectID = ++g_AdapterInstanceCounter;
        ASSERT(g_AdapterInstanceCounter <= MAX_ADAPTERS);
        if (g_AdapterInstanceCounter <= MAX_ADAPTERS)
        {
            g_Adapters[g_AdapterInstanceCounter-1] = pAdapter;
        }

        /*
        // We use the instance number in debug messages to help when debugging
        // with multiple adapters.
        */
#if DBG
        pAdapter->DbgID[0] = (UCHAR) ((pAdapter->ObjectID & 0x0F) + '0');
        pAdapter->DbgID[1] = ':';
        ASSERT (sizeof(VER_TARGET_STR) <= sizeof(pAdapter->DbgID)-2);
        memcpy(&pAdapter->DbgID[2], VER_TARGET_STR, sizeof(VER_TARGET_STR));
#endif
        /*
        // Initialize the member variables to their default settings.
        */
        pAdapter->MiniportAdapterHandle = MiniportAdapterHandle;
        pAdapter->WrapperConfigurationContext = WrapperConfigurationContext;

        /*
        // Allocate spin locks to use for MUTEX queue protection.
        */
        NdisAllocateSpinLock(&pAdapter->EventLock);
        NdisAllocateSpinLock(&pAdapter->TransmitLock);
        NdisAllocateSpinLock(&pAdapter->ReceiveLock);

        /*
        // Parse the registry parameters.
        */
        Result = AdapterReadParameters(pAdapter);
#if DBG
        DbgInfo->DbgFlags = pAdapter->DbgFlags;
#endif // DBG
        DBG_DISPLAY(("NOTICE: Adapter#%d=0x%X DbgFlags=0x%X\n",
                    pAdapter->ObjectID, pAdapter, pAdapter->DbgFlags));

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = AdapterCreateObjects(pAdapter);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppAdapter = pAdapter;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            AdapterDestroy(pAdapter);
        }
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Adapter Adapter_c AdapterDestroyObjects


@func

    <f AdapterDestroyObjects> calls the destroy routines for all the objects
    contained in <t MINIPORT_ADAPTER_OBJECT>.  This should only be called
    by <f AdapterDestroy>.

    <f Note>:
    If you add any new objects to <t MINIPORT_ADAPTER_OBJECT> you will need
    to modify <f AdapterCreateObjects> and <f AdapterDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void AdapterDestroyObjects(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterDestroyObjects")

    UINT                        NumBChannels;
    // The number of BChannels supported by the NIC.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(DbgInfo);

    /*
    // Destroy the BChannel objects.
    */
    NumBChannels = pAdapter->NumBChannels;
    while (NumBChannels--)
    {
        BChannelDestroy(pAdapter->pBChannelArray[NumBChannels]);
    }
    pAdapter->NumBChannels = 0;

    /*
    // Free space for the BChannels.
    */
    if (pAdapter->pBChannelArray)
    {
        NumBChannels = CardNumChannels(pAdapter->pCard);
        FREE_MEMORY(pAdapter->pBChannelArray, sizeof(PVOID) * NumBChannels);
    }

    /*
    // Destroy the DChannel object.
    */
    DChannelDestroy(pAdapter->pDChannel);

    /*
    // Destroy the Card object.
    */
    CardDestroy(pAdapter->pCard);

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Adapter Adapter_c AdapterDestroy


@func

    <f AdapterDestroy> frees the memory for this <t MINIPORT_ADAPTER_OBJECT>.
    All memory allocated by <f AdapterCreate> will be released back to the OS.

*/

void AdapterDestroy(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterDestroy")

    DBG_ENTER(DbgInfo);

    if (pAdapter)
    {
        ASSERT(pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

        /*
        // Release all objects allocated within this object.
        */
        AdapterDestroyObjects(pAdapter);

        /*
        // Destroy any string parameter buffers created by ParamParseRegistry.
        */
        if (pAdapter->MediaType.Length)
        {
            FREE_NDISSTRING(pAdapter->MediaType);
        }
        if (pAdapter->DeviceName.Length)
        {
            FREE_NDISSTRING(pAdapter->DeviceName);
        }
        if (pAdapter->TapiAddressList.Length)
        {
            FREE_NDISSTRING(pAdapter->TapiAddressList);
        }

        if (pAdapter->EventLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->EventLock);
        }

        if (pAdapter->TransmitLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->TransmitLock);
        }

        if (pAdapter->ReceiveLock.SpinLock)
        {
            NdisFreeSpinLock(&pAdapter->ReceiveLock);
        }

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        if (pAdapter->ObjectType <= MAX_ADAPTERS)
        {
            g_Adapters[pAdapter->ObjectType-1] = NULL;
        }
        pAdapter->ObjectType = 0;
        FREE_OBJECT(pAdapter);
    }

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Adapter Adapter_c AdapterInitialize


@func

    <f AdapterInitialize> prepares the <t MINIPORT_ADAPTER_OBJECT> and all
    its sub-components for use by the NDIS wrapper.  Upon successful
    completion of this routine, the NIC will be ready to accept requests
    from the NDIS wrapper.

@rdesc

    <f AdapterInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS AdapterInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("AdapterInitialize")

    NDIS_STATUS                 Result;
    // Holds the result code returned by this function.

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    ULONG                       Index;
    // Loop counter.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);
    DBG_ENTER(pAdapter);

    /*
    // Initialize the WAN information structure to match the capabilities of
    // the adapter.
    */
    pAdapter->WanInfo.MaxFrameSize   = pAdapter->pCard->BufferSize - NDISWAN_EXTRA_SIZE;
    pAdapter->WanInfo.MaxTransmit    = pAdapter->pCard->TransmitBuffersPerLink;

    /*
    // Since we copy the packets to/from adapter RAM, no padding information is
    // needed in the WAN packets we get.  We can just use adapter RAM as needed.
    */
    pAdapter->WanInfo.HeaderPadding  = 0;
    pAdapter->WanInfo.TailPadding    = 0;

    /*
    // Transmits and received are copied to/from adapter RAM so cached memory
    // can be used for packet allocation and we don't really care if it's
    // physically contiguous or not, as long as it's virtually contiguous.
    */
    pAdapter->WanInfo.MemoryFlags    = 0;
    pAdapter->WanInfo.HighestAcceptableAddress = g_HighestAcceptableAddress;

    /*
    // We only support point to point framing, and we don't need to see the
    // address or control fields.  The TAPI_PROVIDER bit is set to indicate
    // that we can accept the TAPI OID requests.
    */
    pAdapter->WanInfo.FramingBits    = PPP_FRAMING | TAPI_PROVIDER |
                                       PPP_MULTILINK_FRAMING;

    /*
    // This value is ignored by this driver, but its default behavior is such
    // that all these control bytes would appear to be handled transparently.
    */
    pAdapter->WanInfo.DesiredACCM    = 0;

    /*
    // This value indicates how many point to point connections are allowed
    // per adapter.  Currently, the WAN wrapper only supports 1 connection
    // per NDIS link.
    */
    pAdapter->WanInfo.Endpoints = pAdapter->NumBChannels;

    /*
    // Setyup the default call parameters.
    */
    pAdapter->DefaultLineCallParams.ulTotalSize      = sizeof(pAdapter->DefaultLineCallParams);
    pAdapter->DefaultLineCallParams.ulBearerMode     = LINEBEARERMODE_DATA;
    pAdapter->DefaultLineCallParams.ulMinRate        = _56KBPS;
    pAdapter->DefaultLineCallParams.ulMaxRate        = _64KBPS;
    pAdapter->DefaultLineCallParams.ulMediaMode      = LINEMEDIAMODE_DIGITALDATA;
    pAdapter->DefaultLineCallParams.ulCallParamFlags = 0;
    pAdapter->DefaultLineCallParams.ulAddressMode    = LINEADDRESSMODE_ADDRESSID;
    pAdapter->DefaultLineCallParams.ulAddressID      = TSPI_ADDRESS_ID;

    /*
    // Initialize the packet management queues to empty.
    */
    InitializeListHead(&pAdapter->EventList);
    InitializeListHead(&pAdapter->TransmitPendingList);
    InitializeListHead(&pAdapter->TransmitCompleteList);
    InitializeListHead(&pAdapter->ReceiveCompleteList);

    /*
    // Setup the timer event handler.
    */
    NdisMInitializeTimer(&pAdapter->EventTimer,
                         pAdapter->MiniportAdapterHandle,
                         MiniportTimer,
                         pAdapter);

    /*
    // Initialize the DChannel object.
    */
    DChannelInitialize(pAdapter->pDChannel);

    /*
    // Initialize all the BChannel objects.
    */
    for (Index = 0; Index < pAdapter->NumBChannels; ++Index)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, Index);
        BChannelInitialize(pBChannel);
    }

    /*
    // Now, we can initialize the Card object.
    */
    Result = CardInitialize(pAdapter->pCard);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\im\passthru.h ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    passthru.h

Abstract:

    Ndis Intermediate Miniport driver sample. This is a passthru driver.

Author:

Environment:


Revision History:

 
--*/

#ifdef NDIS51_MINIPORT
#define PASSTHRU_MAJOR_NDIS_VERSION            5
#define PASSTHRU_MINOR_NDIS_VERSION            1
#else
#define PASSTHRU_MAJOR_NDIS_VERSION            4
#define PASSTHRU_MINOR_NDIS_VERSION            0
#endif

#ifdef NDIS51
#define PASSTHRU_PROT_MAJOR_NDIS_VERSION    5
#define PASSTHRU_PROT_MINOR_NDIS_VERSION    0
#else
#define PASSTHRU_PROT_MAJOR_NDIS_VERSION    4
#define PASSTHRU_PROT_MINOR_NDIS_VERSION    0
#endif

#define MAX_BUNDLEID_LENGTH 50

#define TAG 'ImPa'
#define WAIT_INFINITE 0



//advance declaration
typedef struct _ADAPT ADAPT, *PADAPT;

extern
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT            DriverObject,
    IN PUNICODE_STRING           RegistryPath
    );

NTSTATUS
PtDispatch(
    IN PDEVICE_OBJECT            DeviceObject,
    IN PIRP                      Irp
    );

NDIS_STATUS
PtRegisterDevice(
    VOID
    );

NDIS_STATUS
PtDeregisterDevice(
    VOID
   );

VOID
PtUnloadProtocol(
    VOID
    );

//
// Protocol proto-types
//
extern
VOID
PtOpenAdapterComplete(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN NDIS_STATUS                Status,
    IN NDIS_STATUS                OpenErrorStatus
    );

extern
VOID
PtCloseAdapterComplete(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN NDIS_STATUS                Status
    );

extern
VOID
PtResetComplete(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN NDIS_STATUS                Status
    );

extern
VOID
PtRequestComplete(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN PNDIS_REQUEST              NdisRequest,
    IN NDIS_STATUS                Status
    );

extern
VOID
PtStatus(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN NDIS_STATUS                GeneralStatus,
    IN PVOID                      StatusBuffer,
    IN UINT                       StatusBufferSize
    );

extern
VOID
PtStatusComplete(
    IN NDIS_HANDLE                ProtocolBindingContext
    );

extern
VOID
PtSendComplete(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN PNDIS_PACKET               Packet,
    IN NDIS_STATUS                Status
    );

extern
VOID
PtTransferDataComplete(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN PNDIS_PACKET               Packet,
    IN NDIS_STATUS                Status,
    IN UINT                       BytesTransferred
    );

extern
NDIS_STATUS
PtReceive(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN NDIS_HANDLE                MacReceiveContext,
    IN PVOID                      HeaderBuffer,
    IN UINT                       HeaderBufferSize,
    IN PVOID                      LookAheadBuffer,
    IN UINT                       LookaheadBufferSize,
    IN UINT                       PacketSize
    );

extern
VOID
PtReceiveComplete(
    IN NDIS_HANDLE                ProtocolBindingContext
    );

extern
INT
PtReceivePacket(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN PNDIS_PACKET               Packet
    );

extern
VOID
PtBindAdapter(
    OUT PNDIS_STATUS              Status,
    IN  NDIS_HANDLE               BindContext,
    IN  PNDIS_STRING              DeviceName,
    IN  PVOID                     SystemSpecific1,
    IN  PVOID                     SystemSpecific2
    );

extern
VOID
PtUnbindAdapter(
    OUT PNDIS_STATUS              Status,
    IN  NDIS_HANDLE               ProtocolBindingContext,
    IN  NDIS_HANDLE               UnbindContext
    );
    
VOID
PtUnload(
    IN PDRIVER_OBJECT             DriverObject
    );



extern 
NDIS_STATUS
PtPNPHandler(
    IN NDIS_HANDLE                ProtocolBindingContext,
    IN PNET_PNP_EVENT             pNetPnPEvent
    );




NDIS_STATUS
PtPnPNetEventReconfigure(
    IN PADAPT            pAdapt,
    IN PNET_PNP_EVENT    pNetPnPEvent
    );    

NDIS_STATUS 
PtPnPNetEventSetPower (
    IN PADAPT                    pAdapt,
    IN PNET_PNP_EVENT            pNetPnPEvent
    );
    

//
// Miniport proto-types
//
NDIS_STATUS
MPInitialize(
    OUT PNDIS_STATUS             OpenErrorStatus,
    OUT PUINT                    SelectedMediumIndex,
    IN PNDIS_MEDIUM              MediumArray,
    IN UINT                      MediumArraySize,
    IN NDIS_HANDLE               MiniportAdapterHandle,
    IN NDIS_HANDLE               WrapperConfigurationContext
    );

VOID
MPSendPackets(
    IN NDIS_HANDLE                MiniportAdapterContext,
    IN PPNDIS_PACKET              PacketArray,
    IN UINT                       NumberOfPackets
    );

NDIS_STATUS
MPSend(
    IN NDIS_HANDLE                MiniportAdapterContext,
    IN PNDIS_PACKET               Packet,
    IN UINT                       Flags
    );

NDIS_STATUS
MPQueryInformation(
    IN NDIS_HANDLE                MiniportAdapterContext,
    IN NDIS_OID                   Oid,
    IN PVOID                      InformationBuffer,
    IN ULONG                      InformationBufferLength,
    OUT PULONG                    BytesWritten,
    OUT PULONG                    BytesNeeded
    );

NDIS_STATUS
MPSetInformation(
    IN NDIS_HANDLE                MiniportAdapterContext,
    IN NDIS_OID                   Oid,
    IN PVOID                      InformationBuffer,
    IN ULONG                      InformationBufferLength,
    OUT PULONG                    BytesRead,
    OUT PULONG                    BytesNeeded
    );

VOID
MPReturnPacket(
    IN NDIS_HANDLE                MiniportAdapterContext,
    IN PNDIS_PACKET               Packet
    );

NDIS_STATUS
MPTransferData(
    OUT PNDIS_PACKET              Packet,
    OUT PUINT                     BytesTransferred,
    IN NDIS_HANDLE                MiniportAdapterContext,
    IN NDIS_HANDLE                MiniportReceiveContext,
    IN UINT                       ByteOffset,
    IN UINT                       BytesToTransfer
    );

VOID
MPHalt(
    IN NDIS_HANDLE                MiniportAdapterContext
    );


VOID
MPQueryPNPCapabilities(  
    OUT PADAPT                    MiniportProtocolContext, 
    OUT PNDIS_STATUS              Status
    );


NDIS_STATUS
MPSetMiniportSecondary ( 
    IN PADAPT                    Secondary, 
    IN PADAPT                    Primary
    );

#ifdef NDIS51_MINIPORT

VOID
MPCancelSendPackets(
    IN NDIS_HANDLE            MiniportAdapterContext,
    IN PVOID                  CancelId
    );

VOID
MPAdapterShutdown(
    IN NDIS_HANDLE                MiniportAdapterContext
    );

VOID
MPDevicePnPEvent(
    IN NDIS_HANDLE                MiniportAdapterContext,
    IN NDIS_DEVICE_PNP_EVENT      DevicePnPEvent,
    IN PVOID                      InformationBuffer,
    IN ULONG                      InformationBufferLength
    );

#endif // NDIS51_MINIPORT

VOID
MPFreeAllPacketPools(
    IN PADAPT                    pAdapt
    );

NDIS_STATUS 
MPPromoteSecondary ( 
    IN PADAPT                    pAdapt 
    );


NDIS_STATUS 
MPBundleSearchAndSetSecondary (
    IN PADAPT                    pAdapt 
    );

VOID
MPProcessSetPowerOid(
    IN OUT PNDIS_STATUS          pNdisStatus,
    IN PADAPT                    pAdapt,
    IN PVOID                     InformationBuffer,
    IN ULONG                     InformationBufferLength,
    OUT PULONG                   BytesRead,
    OUT PULONG                   BytesNeeded
    );


//
// There should be no DbgPrint's in the Free version of the driver
//
#if DBG

#define DBGPRINT(Fmt)                                        \
    {                                                        \
        DbgPrint("Passthru: ");                                \
        DbgPrint Fmt;                                        \
    }

#else // if DBG

#define DBGPRINT(Fmt)                                            

#endif // if DBG 

#define    NUM_PKTS_IN_POOL    256


//
// Protocol reserved part of a sent packet that is allocated by us.
//
typedef struct _SEND_RSVD
{
    PNDIS_PACKET    OriginalPkt;
} SEND_RSVD, *PSEND_RSVD;

//
// Miniport reserved part of a received packet that is allocated by
// us. Note that this should fit into the MiniportReserved space
// in an NDIS_PACKET.
//
typedef struct _RECV_RSVD
{
    PNDIS_PACKET    OriginalPkt;
} RECV_RSVD, *PRECV_RSVD;

C_ASSERT(sizeof(RECV_RSVD) <= sizeof(((PNDIS_PACKET)0)->MiniportReserved));

//
// Event Codes related to the PassthruEvent Structure
//

typedef enum 
{
    Passthru_Invalid,
    Passthru_SetPower,
    Passthru_Unbind

} PASSSTHRU_EVENT_CODE, *PPASTHRU_EVENT_CODE; 

//
// Passthru Event with  a code to state why they have been state
//

typedef struct _PASSTHRU_EVENT
{
    NDIS_EVENT Event;
    PASSSTHRU_EVENT_CODE Code;

} PASSTHRU_EVENT, *PPASSTHRU_EVENT;


//
// Structure used by both the miniport as well as the protocol part of the intermediate driver
// to represent an adapter and its corres. lower bindings
//
typedef struct _ADAPT
{
    struct _ADAPT *                Next;
    
    NDIS_HANDLE                    BindingHandle;    // To the lower miniport
    NDIS_HANDLE                    MiniportHandle;    // NDIS Handle to for miniport up-calls
    NDIS_HANDLE                    SendPacketPoolHandle;
    NDIS_HANDLE                    RecvPacketPoolHandle;
    NDIS_STATUS                    Status;            // Open Status
    NDIS_EVENT                     Event;            // Used by bind/halt for Open/Close Adapter synch.
    NDIS_MEDIUM                    Medium;
    NDIS_REQUEST                   Request;        // This is used to wrap a request coming down
                                                // to us. This exploits the fact that requests
                                                // are serialized down to us.
    PULONG                         BytesNeeded;
    PULONG                         BytesReadOrWritten;
    BOOLEAN                        IndicateRcvComplete;
    
    BOOLEAN                        OutstandingRequests;      // TRUE iff a request is pending
                                                        // at the miniport below
    BOOLEAN                        QueuedRequest;            // TRUE iff a request is queued at
                                                        // this IM miniport

    BOOLEAN                        StandingBy;                // True - When the miniport or protocol is transitioning from a D0 to Standby (>D0) State
    BOOLEAN                        UnbindingInProcess;
    NDIS_SPIN_LOCK                 Lock;
                                                        // False - At all other times, - Flag is cleared after a transition to D0

    NDIS_DEVICE_POWER_STATE        MPDeviceState;            // Miniport's Device State 
    NDIS_DEVICE_POWER_STATE        PTDeviceState;            // Protocol's Device State 
    NDIS_STRING                    DeviceName;                // For initializing the miniport edge
    NDIS_EVENT                     MiniportInitEvent;        // For blocking UnbindAdapter while
                                                        // an IM Init is in progress.
    BOOLEAN                        MiniportInitPending;    // TRUE iff IMInit in progress
    NDIS_STATUS                    LastIndicatedStatus;    // The last indicated media status
    NDIS_STATUS                    LatestUnIndicateStatus; // The latest suppressed media status
    ULONG                          OutstandingSends;

} ADAPT, *PADAPT;

extern    NDIS_HANDLE                        ProtHandle, DriverHandle;
extern    NDIS_MEDIUM                        MediumArray[4];
extern    PADAPT                             pAdaptList;
extern    NDIS_SPIN_LOCK                     GlobalLock;


#define ADAPT_MINIPORT_HANDLE(_pAdapt)    ((_pAdapt)->MiniportHandle)
#define ADAPT_DECR_PENDING_SENDS(_pAdapt)     \
    {                                         \
        NdisAcquireSpinLock(&(_pAdapt)->Lock);   \
        (_pAdapt)->OutstandingSends--;           \
        NdisReleaseSpinLock(&(_pAdapt)->Lock);   \
    }

//
// Custom Macros to be used by the passthru driver 
//
/*
BOOLEAN
IsIMDeviceStateOn(
   PADAPT 
   )

*/
#define IsIMDeviceStateOn(_pP)        ((_pP)->MPDeviceState == NdisDeviceStateD0 && (_pP)->PTDeviceState == NdisDeviceStateD0 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\adapter.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Adapter Adapter_h

@module Adapter.h |

    This module defines the interface to the <t MINIPORT_ADAPTER_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Adapter_h

@end

*/

#ifndef _ADAPTER_H
#define _ADAPTER_H

#define MINIPORT_ADAPTER_OBJECT_TYPE    ((ULONG)'A')+\
                                        ((ULONG)'D'<<8)+\
                                        ((ULONG)'A'<<16)+\
                                        ((ULONG)'P'<<24)


/* @doc INTERNAL Adapter Adapter_h MINIPORT_ADAPTER_OBJECT


@struct MINIPORT_ADAPTER_OBJECT |

    This structure contains the data associated with a single Miniport
    adapter instance.  Here, Adapter is defined as the manager of specific
    Network Interface Card (NIC) installed under the NDIS wrapper.  This
    adapter is responsible for managing all interactions between the NIC and
    the host operating system using the NDIS library.

@comm

    This structure must contain a reference to all other objects being managed
    by this adapter object.  The adapter object is the only reference passed
    between NDIS and the Miniport.  This is the <t MiniportAdapterContext> we
    pass into <f NdisMSetAttributes> from <f MiniportInitialize>.  This value
    is passed as a parameter to the Miniport entry points called by the NDIS
    wrapper.

    One of these objects is created each time that our <f MiniportInitialize>
    routine is called.  The NDIS wrapper calls this routine once for each of
    our devices installed and enabled in the system.  In the case of a hot
    swappable NIC (e.g. PCMCIA) the adapter might come and go several times
    during a single Windows session.

*/

typedef struct MINIPORT_ADAPTER_OBJECT
{
#if DBG
    ULONG                       DbgFlags;                   // @field
    // Debug flags control how much debug is displayed in the checked version.
    // Put it at the front so we can set it easily with debugger.

    UCHAR                       DbgID[12];                  // @field
    // This field is initialized to an ASCII decimal string containing the
    // adapter instance number 1..N.  It is only used to output debug messages.
#endif // DBG
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'ADAP'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    NDIS_HANDLE                 MiniportAdapterHandle;      // @field
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    NDIS_HANDLE                 WrapperConfigurationContext;// @field
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.

    PCARD_OBJECT                pCard;                      // @field
    // Pointer to the hardware specific <t CARD_OBJECT>.  Created by
    // <f CardCreate>.

    PDCHANNEL_OBJECT            pDChannel;                  // @field
    // Pointer to the <t DCHANNEL_OBJECT> created by <f DChannelCreate>.
    // One for the entire NIC.

    ULONG                       NumBChannels;               // @field
    // The number of <t BCHANNEL_OBJECT>'s supported by the NIC.

    PBCHANNEL_OBJECT *          pBChannelArray;             // @field
    // An array of <t BCHANNEL_OBJECT>'s created by <f BChannelCreate>.
    // One entry for each logical BChannel on NIC.

#if !defined(NDIS50_MINIPORT)
    ULONG                       BusNumber;                  // @field
    // Identifies which system bus this adapter is plugged in to.

    ULONG                       BusType;                    // @field
    // Identifies the bus type this adapter is plugged in to.

#endif // NDIS50_MINIPORT

    ULONG                       RunningWin95;               // @field
    // Set TRUE only if running on Windows 95 or Windows98.

    ULONG                       NumLineOpens;               // @field
    // The number of line open calls currently on this adapter.

    NDIS_SPIN_LOCK              TransmitLock;               // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the transmit queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  TransmitPendingList;        // @field
    // Packets waiting to be sent when the controller is available.
    // See <t NDIS_WAN_PACKET>.

    LIST_ENTRY                  TransmitCompleteList;       // @field
    // Packets waiting for completion processing.  After the packet is
    // transmitted, the protocol stack is given an indication.
    // See <t NDIS_WAN_PACKET>.

    NDIS_SPIN_LOCK              ReceiveLock;                // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the receive queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  ReceiveCompleteList;        // @field
    // Buffers waiting to be processed by the

    NDIS_SPIN_LOCK              EventLock;                  // @field
    // This spin lock is used to provide mutual exclusion around accesses
    // to the event queue manipulation routines.  This is necessary since
    // we can be called at any time by the B-channel services driver and
    // we could already be processing an NDIS request.

    LIST_ENTRY                  EventList;                  // @field
    // driver callback events waiting to be processed.
    // See <t BCHANNEL_EVENT_OBJECT>.

    NDIS_MINIPORT_TIMER         EventTimer;                 // @field
    // This timer is used to schedule the event processing routine to run
    // when the system reaches a quiescent state.

    ULONG                       NextEvent;                  // @field
    // Where do we store the next event.

    long                        NestedEventHandler;         // @field
    // Keeps track of entry to and exit from the event handler.

    long                        NestedDataHandler;          // @field
    // Keeps track of entry to and exit from the Tx/Rx handlers.

    ULONG                       DeviceIdBase;               // @field
    // The ulDeviceIDBase field passed in the PROVIDER_INIT request
    // informs a miniport of the zero-based starting index that the
    // Connection Wrapper will use when referring to a single adapters
    // line devices by index.  For example, if a ulDeviceIDBase of two is
    // specified and the adapter supports three line devices, then the
    // Connection Wrapper will use the identifiers two, three, and four
    // to refer to the adapters three devices.

    NDIS_WAN_INFO               WanInfo;                    // @field
    // A copy of our <t NDIS_WAN_INFO> structure is setup at init time
    // and doesn't change.

    CHAR                        ProviderInfo[48];           // @field
    // This holds the TAPI ProviderInfo string returned from TspiGetDevCaps
    // This is two null terminated strings packed end to end.
    // This size is the max allowed by RAS.

    ULONG                       ProviderInfoSize;           // @field
    // Size in bytes of both strings.

    ULONG                       NoAnswerTimeOut;            // @field
    // How many ms to wait for ALERTING

    ULONG                       NoAcceptTimeOut;            // @field
    // How many ms to wait for ACCEPT

    ANSI_STRING                 MediaType;                  // @field
    // The MediaType configuration parameter is read from the registry
    // at init time.

    ANSI_STRING                 DeviceName;                 // @field
    // The DeviceName configuration parameter is read from the registry
    // at init time.

    ANSI_STRING                 TapiAddressList;            // @field
    // The TAPI AddressList configuration parameter is read from the
    // registry at init time.

    LINE_CALL_PARAMS            DefaultLineCallParams;      // @field
    // The default call parameters used by TspiMakeCall

    BOOLEAN                     NeedStatusCompleteIndication;   // @field
    // This flag indicates whether or not <f NdisMIndicateStatusComplete>
    // needs to be called after the completion of requests or event processing.
    // This is set TRUE if <f NdisMIndicateStatus> is called while
    // processing a request or event.

    ULONG                       TotalRxBytes;               // @field
    // Total bytes read by driver during this session.

    ULONG                       TotalTxBytes;               // @field
    // Total bytes written by driver during this session.

    ULONG                       TotalRxPackets;             // @field
    // Total packets read by driver during this session.

    ULONG                       TotalTxPackets;             // @field
    // Total packets written by driver during this session.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} MINIPORT_ADAPTER_OBJECT;

extern PMINIPORT_ADAPTER_OBJECT g_Adapters[MAX_ADAPTERS];

/*


    Function prototypes.

*/

NDIS_STATUS AdapterCreate(
    OUT PMINIPORT_ADAPTER_OBJECT *ppAdapter,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              WrapperConfigurationContext
    );

void AdapterDestroy(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

NDIS_STATUS AdapterInitialize(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

#endif // _ADAPTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\bchannel.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL BChannel BChannel_h

@module BChannel.h |

    This module defines the interface to the <t BCHANNEL_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | BChannel_h

@end

*/

#ifndef _BCHANNEL_H
#define _BCHANNEL_H

#define BCHANNEL_OBJECT_TYPE    ((ULONG)'B')+\
                                ((ULONG)'C'<<8)+\
                                ((ULONG)'H'<<16)+\
                                ((ULONG)'N'<<24)


/* @doc INTERNAL BChannel BChannel_h BCHANNEL_OBJECT


@struct BCHANNEL_OBJECT |

    This structure contains the data associated with an ISDN BChannel.
    Here, BChannel is defined as any channel or collection of channels
    capable of carrying "user" data over and existing connection.  This
    channel is responsible for making sure the data payload is sent to or
    received from the remote end-point exactly as it is appeared at the
    originating station.

@comm

    This logical BChannel does not necessarily map to a physical BChannel
    on the NIC.  The NIC may in fact be bonding multiple BChannels into this
    logical BChannel.  The NIC may in fact not have BChannels at all, as
    may be the case with channelized T-1.  The BChannel is just a convenient
    abstraction for a point-to-point, bi-directional communication link.

    There will be one BChannel created for each communication channel on the
    NIC.  The number of channels depends on how many ports the NIC has, and
    how they are provisioned and configured.  The number of BChannels can be
    configured at install time or changed using the control panel.  The driver
    does not allow the configuration to change at run-time, so the computer
    or the adapter must be restarted to enable the configuration changes.

*/

typedef struct BCHANNEL_OBJECT
{
    struct BCHANNEL_OBJECT *    next;   /* Linked list pointer */

    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'BCHN'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this BChannel is open, otherwise set FALSE.

//
//  NDIS data members

    ULONG                       BChannelIndex;                  // @field
    // This is a zero based index associated with this BChannel.  It is used
    // to associate a TAPI <p DeviceID> with this link based on the value
    // TAPI provides for <p  DeviceIdBase>  (i.e. <p  DeviceID> = <p  DeviceIdBase>
    // + BChannelIndex).  See <f GET_DEVICEID_FROM_BCHANNEL>.

    NDIS_HANDLE                 NdisLinkContext;           // @field
    // This is the WAN Wrapper's link context which is associated with this
    // link in response to the Miniport calling <f NdisMIndicateStatus>
    // to indicate a <t NDIS_MAC_LINE_UP> condition.  This value is passed
    // back to the WAN Wrapper to indicate activity associated with this link,
    // such as <f NdisMWanIndicateReceive> and <f NdisMIndicateStatus>.
    // See <F LinkLineUp>.

    ULONG                       LinkSpeed;                  // @field
    // The speed provided by the link in bits per second.  This value is
    // passed up by the Miniport during the LINE_UP indication.

    LIST_ENTRY                  ReceivePendingList;         // @field
    // Buffers currently submitted to the controller waiting for receive.

    LIST_ENTRY                  TransmitBusyList;           // @field
    // Packets currently submitted to the controller waiting for completion.
    // See <t NDIS_WAN_PACKET>.

    BOOLEAN                     NeedReceiveCompleteIndication;  // @field
    // This flag indicates whether or not <f NdisMWanIndicateReceiveComplete>
    // needs to be called after the completion of the event processing loop.
    // This is set TRUE if <f NdisMWanReceiveComplete> is called while
    // processing the event queues.

    NDIS_WAN_SET_LINK_INFO      WanLinkInfo;                // @field
    // The current settings associated with this link as passed in via
    // the OID_WAN_SET_LINK_INFO request.

    ULONG                       TotalRxPackets;             // @field
    // Total packets read by driver during this session.

//
//  TAPI data members.

    HTAPI_LINE                  htLine;                     // @field
    // This is the Connection Wrapper's line context associated with this
    // link when <f TspiOpen> is called.  This handle is used when calling
    // <f NdisMIndicateStatus> with <t NDIS_STATUS_TAPI_INDICATION>.

    HTAPI_CALL                  htCall;                     // @field
    // This is the Connection Wrapper's call context associated with this
    // link during <f TspiMakeCall> or a call to <f NdisMIndicateStatus>
    // with a <t LINE_NEWCALL> event.  This handle is used as the
    // <f ConnectionWrapperID> in the <t NDIS_MAC_LINE_UP> structure used
    // by <f LinkLineUp>.

    BOOLEAN                     CallClosing;                // @field
    // Set TRUE if call is being closed.

    ULONG                       CallState;                  // @field
    // The current TAPI LINECALLSTATE of the associated with the link.

    ULONG                       CallStateMode;              // @field
    // Remember what mode the call was set to.

    ULONG                       CallStatesCaps;             // @field
    // Events currently supported

    ULONG                       CallStatesMask;             // @field
    // Events currently enabled

    ULONG                       AddressState;               // @field
    // The current TAPI LINEADDRESSSTATE of the associated with the link.

    ULONG                       AddressStatesCaps;          // @field
    // Events currently supported

    ULONG                       AddressStatesMask;          // @field
    // Events currently enabled

    ULONG                       DevState;                   // @field
    // The current TAPI LINEDEVSTATE of the associated with the link.

    ULONG                       DevStatesCaps;              // @field
    // Events currently supported

    ULONG                       DevStatesMask;              // @field
    // Events currently enabled

    ULONG                       MediaMode;                  // @field
    // The current TAPI media mode(s) supported by the card.

    ULONG                       MediaModesCaps;             // @field
    // Events currently supported

    ULONG                       BearerMode;                 // @field
    // The current TAPI bearer mode in use.

    ULONG                       BearerModesCaps;            // @field
    // TAPI bearer mode(s) supported by the card.

    ULONG                       MediaModesMask;             // @field
    // Events currently enabled

    ULONG                       AppSpecificCallInfo;        // @field
    // This value is set by OID_TAPI_SET_APP_SPECIFIC and queried by
    // OID_TAPI_GET_CALL_INFO.

    CHAR                        pTapiLineAddress[0x14];     // @field
    // TAPI line address is assigned during installation and saved in the
    // registry.  It is read from the registry and saved here at init time.

    NDIS_MINIPORT_TIMER         CallTimer;                  // @field
    // This timer is used to keep track of the call state when a call is
    // coming in or going out.

//
//  CARD data members.

    ULONG                       TODO;                       // @field
    // Add your data members here.

#if defined(SAMPLE_DRIVER)
    PBCHANNEL_OBJECT            pPeerBChannel;              // @field
    // Peer BChannel of caller or callee depending on who orginated the
    // call.

#endif // SAMPLE_DRIVER

} BCHANNEL_OBJECT;

#define GET_ADAPTER_FROM_BCHANNEL(pBChannel)    (pBChannel->pAdapter)
#define GET_NDIS_LINK_FROM_BCHANNEL(pBChannel)  (pBChannel)
#define GET_TAPI_LINE_FROM_BCHANNEL(pBChannel)  (pBChannel)


/* @doc INTERNAL BChannel BChannel_h IS_VALID_BCHANNEL


@func ULONG | IS_VALID_BCHANNEL |
    Use this macro to determine if a <t BCHANNEL_OBJECT> is really valid.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t PBCHANNEL_OBJECT> | pBChannel |
    A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

@rdesc Returns TRUE if the BChannel is valid, otherwise FALSE is returned.

*/
#define IS_VALID_BCHANNEL(pAdapter, pBChannel) \
        (pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE)


/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_INDEX


@func <t PBCHANNEL_OBJECT> | GET_BCHANNEL_FROM_INDEX |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with a zero-based Index.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm ULONG | BChannelIndex |
    Miniport BChannelIndex associated with a specific link.

@rdesc Returns a pointer to the associated <t BCHANNEL_OBJECT>.

*/
#define GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex) \
        (pAdapter->pBChannelArray[BChannelIndex]); \
        ASSERT(BChannelIndex < pAdapter->NumBChannels)


/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_DEVICEID


@func <t PBCHANNEL_OBJECT> | GET_BCHANNEL_FROM_DEVICEID |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with a specific TAPI DeviceID.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm ULONG | ulDeviceID | TAPI DeviceID associated with a specific link.

@rdesc Returns a pointer to the associated <t BCHANNEL_OBJECT>.

*/
#define GET_BCHANNEL_FROM_DEVICEID(pAdapter, ulDeviceID) \
        (pAdapter->pBChannelArray[ulDeviceID - pAdapter->DeviceIdBase]); \
        ASSERT(ulDeviceID >= pAdapter->DeviceIdBase); \
        ASSERT(ulDeviceID <  pAdapter->DeviceIdBase+pAdapter->NumBChannels)

/* @doc INTERNAL BChannel BChannel_h GET_DEVICEID_FROM_BCHANNEL


@func ULONG | GET_DEVICEID_FROM_BCHANNEL |
    Use this macro to get the TAPI DeviceID associated with a specific
    <t BCHANNEL_OBJECT>.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t PBCHANNEL_OBJECT> | pBChannel |
    A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

*/

#define GET_DEVICEID_FROM_BCHANNEL(pAdapter, pBChannel) \
        (pBChannel->BChannelIndex + pAdapter->DeviceIdBase)

/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_HDLINE


@func <t BCHANNEL_OBJECT> | GET_BCHANNEL_FROM_HDLINE |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with the TAPI hdLine handle.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t HTAPI_LINE> | hdLine |
    Miniport line handle associated with this <t BCHANNEL_OBJECT>.

@rdesc Returns a pointer to the associated <t PBCHANNEL_OBJECT>.

@devnote This driver associates TAPI lines 1:1 with BChannels so they are
    the same thing.

*/
#define GET_BCHANNEL_FROM_HDLINE(pAdapter, hdLine) \
        (PBCHANNEL_OBJECT) hdLine

/* @doc INTERNAL BChannel BChannel_h GET_BCHANNEL_FROM_HDCALL


@func <t BCHANNEL_OBJECT> | GET_BCHANNEL_FROM_HDCALL |
    Use this macro to get a pointer to the <t BCHANNEL_OBJECT> associated
    with the TAPI hdCall handle.

@parm <t MINIPORT_ADAPTER_OBJECT> | pAdapter |
    A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

@parm <t HTAPI_CALL> | hdCall |
    Miniport call handle associated with this <t BCHANNEL_OBJECT>.

@rdesc Returns a pointer to the associated <t PBCHANNEL_OBJECT>.

@devnote This driver associates TAPI calls 1:1 with BChannels so they are
    the same thing.

*/
#define GET_BCHANNEL_FROM_HDCALL(pAdapter, hdCall) \
        (PBCHANNEL_OBJECT) hdCall


/*


    Function prototypes.

*/

NDIS_STATUS BChannelCreate(
    OUT PBCHANNEL_OBJECT *      pBChannel,
    IN ULONG                    BChannelIndex,
    IN PUCHAR                   pTapiLineAddress,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void BChannelDestroy(
    IN PBCHANNEL_OBJECT         pBChannel
    );

void BChannelInitialize(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS BChannelOpen(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN HTAPI_LINE               htLine
    );

void BChannelClose(
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS BChannelAddToReceiveQueue(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PVOID                    pReceiveContext,
    IN PUCHAR                   BufferPointer,
    IN ULONG                    BufferSize
    );

NDIS_STATUS BChannelAddToTransmitQueue(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PVOID                    pTransmitContext,
    IN PUCHAR                   BufferPointer,
    IN ULONG                    BufferSize
    );

#endif // _BCHANNEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\bchannel.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL BChannel BChannel_c

@module BChannel.c |

    This module implements the interface to the <t BCHANNEL_OBJECT>.
    Supports the high-level channel control functions used by the NDIS WAN
    Minport driver.  This module isolates most the vendor specific channel
    access interfaces.  It will require some changes to accomodate your
    hardware device's channel access methods.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | BChannel_c

@end

*/

#define  __FILEID__             BCHANNEL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                    g_BChannelInstanceCounter   // @globalv
// Keeps track of how many <t BCHANNEL_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL BChannel BChannel_c g_BChannelParameters


@topic 5.3 BChannel Parameters |

    This section describes the registry parameters read into the
    <t BCHANNEL_OBJECT>.

@globalv PARAM_TABLE | g_BChannelParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t BCHANNEL_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t BCHANNEL_OBJECT>
    you will need to modify <f BChannelReadParameters> and add the parameter
    definitions to the <f g_BChannelParameters> table.

*/

DBG_STATIC PARAM_TABLE              g_BChannelParameters[] =
{
    PARAM_ENTRY(BCHANNEL_OBJECT,
                TODO, PARAM_TODO,
                FALSE, NdisParameterInteger, 0,
                0, 0, 0),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL BChannel BChannel_c BChannelReadParameters


@func

    <f BChannelReadParameters> reads the BChannel parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f BChannelCreate>.

@rdesc

    <f BChannelReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

    <f Note>:
    If you add any registry based data members to <t BCHANNEL_OBJECT>
    you will need to modify <f BChannelReadParameters> and add the parameter
    definitions to the <f g_BChannelParameters> table.

*/

DBG_STATIC NDIS_STATUS BChannelReadParameters(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pBChannel,
                    g_BChannelParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pBChannel->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pBChannel->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL BChannel BChannel_c BChannelCreateObjects


@func

    <f BChannelCreateObjects> calls the create routines for all the objects
    contained in <t BCHANNEL_OBJECT>.  This should only be called
    by <f BChannelCreate>.

    <f Note>:
    If you add any new objects to <t BCHANNEL_OBJECT> you will need
    to modify <f BChannelCreateObjects> and <f BChannelDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f BChannelCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS BChannelCreateObjects(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelCreate


@func

    <f BChannelCreate> allocates memory for a <t BCHANNEL_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppBChannel> will be set to point to the newly created
    <t BCHANNEL_OBJECT>.  Otherwise, <p ppBChannel> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f BChannelDestroy> must be called to
    release the <t BCHANNEL_OBJECT> created by this function.

@rdesc

    <f BChannelCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelCreate(
    OUT PBCHANNEL_OBJECT *      ppBChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t BCHANNEL_OBJECT>.

    IN ULONG                    BChannelIndex,              // @parm
    // Index into the pBChannelArray.

    IN PUCHAR                   pTapiLineAddress,           // @parm
    // A pointer to the RAS/TAPI line address assigned to each RAS line.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("BChannelCreate")

    PBCHANNEL_OBJECT            pBChannel;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppBChannel = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pBChannel, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pBChannel->ObjectType = BCHANNEL_OBJECT_TYPE;
        pBChannel->ObjectID = ++g_BChannelInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pBChannel->pAdapter = pAdapter;
        pBChannel->BChannelIndex = BChannelIndex;

        if(strlen(pTapiLineAddress) < sizeof(pBChannel->pTapiLineAddress))
        {
            strcpy(pBChannel->pTapiLineAddress, pTapiLineAddress);
        }
        else
        {
            strncpy(pBChannel->pTapiLineAddress, pTapiLineAddress, sizeof(pBChannel->pTapiLineAddress)-1);
            pBChannel->pTapiLineAddress[sizeof(pBChannel->pTapiLineAddress)-1] = '0';
        }

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = BChannelReadParameters(pBChannel);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = BChannelCreateObjects(pBChannel);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppBChannel = pBChannel;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            BChannelDestroy(pBChannel);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelDestroyObjects


@func

    <f BChannelDestroyObjects> calls the destroy routines for all the objects
    contained in <t BCHANNEL_OBJECT>.  This should only be called by
    <f BChannelDestroy>.

    <f Note>:
    If you add any new objects to <t PBCHANNEL_OBJECT> you will need to
    modify <f BChannelCreateObjects> and <f BChannelDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void BChannelDestroyObjects(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelDestroy


@func

    <f BChannelDestroy> frees the memory for this <t BCHANNEL_OBJECT>.
    All memory allocated by <f BChannelCreate> will be released back to the
    OS.

*/

void BChannelDestroy(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pBChannel)
    {
        ASSERT(pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        BChannelDestroyObjects(pBChannel);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pBChannel->ObjectType = 0;
        FREE_OBJECT(pBChannel);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL BChannel BChannel_c BChannelInitialize


@func

    <f BChannelInitialize> resets all the internal data members contained
    in <t BCHANNEL_OBJECT> back to their initial state.

    <f Note>:
    If you add any new members to <t BCHANNEL_OBJECT> you will need to
    modify <f BChannelInitialize> to initialize your new data mamebers.

*/

void BChannelInitialize(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelInitialize")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);


    /*
    // Initially, the BChannel is not allocated to anyone and these fields
    // must be reset.
    */
    ASSERT(pBChannel->NdisLinkContext == NULL);
    ASSERT(pBChannel->htLine == (HTAPI_LINE)0);
    ASSERT(pBChannel->htCall == (HTAPI_CALL)0);

    /*
    // Setup the static features of the link.
    */
    pBChannel->LinkSpeed         = _64KBPS;
    pBChannel->BearerModesCaps   = LINEBEARERMODE_DATA
                                 | LINEBEARERMODE_VOICE
                                 ;
    pBChannel->MediaModesCaps    = LINEMEDIAMODE_DIGITALDATA
                                 | LINEMEDIAMODE_UNKNOWN
                                 // | LINEMEDIAMODE_DATAMODEM
                                 ;

    /*
    // Initialize the TAPI event capabilities supported by the link.
    */
    pBChannel->DevStatesCaps     = LINEDEVSTATE_RINGING
                                 | LINEDEVSTATE_CONNECTED
                                 | LINEDEVSTATE_DISCONNECTED
                                 | LINEDEVSTATE_INSERVICE
                                 | LINEDEVSTATE_OUTOFSERVICE
                                 | LINEDEVSTATE_OPEN
                                 | LINEDEVSTATE_CLOSE
                                 | LINEDEVSTATE_REINIT
                                 ;
    pBChannel->AddressStatesCaps = 0;
    pBChannel->CallStatesCaps    = LINECALLSTATE_IDLE
                                 | LINECALLSTATE_DIALTONE
                                 | LINECALLSTATE_DIALING
                                 | LINECALLSTATE_PROCEEDING
                                 | LINECALLSTATE_RINGBACK
                                 | LINECALLSTATE_BUSY
                                 | LINECALLSTATE_OFFERING
                                 | LINECALLSTATE_ACCEPTED
                                 | LINECALLSTATE_CONNECTED
                                 | LINECALLSTATE_DISCONNECTED
                                 ;

    /*
    // We use this timer to keep track of incoming and outgoing call
    // status, and to provide timeouts for certain call states.
    */
    NdisMInitializeTimer(
            &pBChannel->CallTimer,
            pAdapter->MiniportAdapterHandle,
            TspiCallTimerHandler,
            pBChannel
            );

    /*
    // Set the TransmitBusyList and ReceivePendingList to empty.
    */
    InitializeListHead(&pBChannel->TransmitBusyList);
    InitializeListHead(&pBChannel->ReceivePendingList);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelOpen


@func

    <f BChannelOpen> makes the BChannel connection ready to transmit and
    receive data.

@rdesc

    <f BChannelOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelOpen(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN HTAPI_LINE               htLine
    )
{
    DBG_FUNC("BChannelOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    if (!pBChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening BChannel #%d\n",
                   pBChannel->ObjectID));

        /*
        // The htLine field is used to associate this BChannel with the
        // TAPI Connection Wrapper.  Reset all the state information for
        // this BChannel.
        */
        pBChannel->htLine            = htLine;
        pBChannel->CallClosing       = FALSE;
        // Don't clear the line state flags that are set by card.c
        pBChannel->DevState         &= (LINEDEVSTATE_CONNECTED |
                                        LINEDEVSTATE_INSERVICE);
        pBChannel->DevStatesMask     = 0;    // Default to indicate no line events
        pBChannel->AddressState      = 0;
        pBChannel->AddressStatesMask = 0;    // Default to indicate no address events
        pBChannel->CallState         = 0;
        pBChannel->CallStateMode     = 0;
        pBChannel->CallStatesMask    = pBChannel->CallStatesCaps;
        pBChannel->MediaMode         = 0;
        pBChannel->MediaModesMask    = 0;
        pBChannel->TotalRxPackets    = 0;
        pBChannel->AppSpecificCallInfo = 0;

        /*
        // Initialize the default BChannel information structure.  It may be
        // changed later by MiniportSetInformation.
        */
        pBChannel->WanLinkInfo.MiniportLinkContext = pBChannel;
        pBChannel->WanLinkInfo.MaxSendFrameSize = pAdapter->WanInfo.MaxFrameSize;
        pBChannel->WanLinkInfo.MaxRecvFrameSize = pAdapter->WanInfo.MaxFrameSize;
        pBChannel->WanLinkInfo.SendFramingBits  = pAdapter->WanInfo.FramingBits;
        pBChannel->WanLinkInfo.RecvFramingBits  = pAdapter->WanInfo.FramingBits;
        pBChannel->WanLinkInfo.SendACCM         = pAdapter->WanInfo.DesiredACCM;
        pBChannel->WanLinkInfo.RecvACCM         = pAdapter->WanInfo.DesiredACCM;

#if defined(SAMPLE_DRIVER)
        // Sample just tells tapi that the line is connected and in service.
        TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_CONNECTED);
        TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_INSERVICE);
#else  // SAMPLE_DRIVER
        // TODO - Add code here
        TspiLineDevStateHandler(pAdapter, pBChannel, LINEDEVSTATE_CONNECTED);
#endif // SAMPLE_DRIVER

        pBChannel->IsOpen = TRUE;
    }
    else
    {
        DBG_ERROR(pAdapter,("BChannel #%d already opened\n",
                  pBChannel->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelClose


@func

    <f BChannelClose> closes the given B-channel.

*/

void BChannelClose(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("BChannelClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    if (pBChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing BChannel #%d\n",
                   pBChannel->ObjectID));

        /*
        // Make sure call is cleared and B channel is disabled.
        */
        DChannelCloseCall(pAdapter->pDChannel, pBChannel);

        // TODO - Add code here

        // Don't clear the line state flags that are set by card.c
        pBChannel->DevState       &= (LINEDEVSTATE_CONNECTED |
                                      LINEDEVSTATE_INSERVICE);
        pBChannel->CallState       = 0;
        pBChannel->htLine          = (HTAPI_LINE)0;
        pBChannel->htCall          = (HTAPI_CALL)0;
        pBChannel->NdisLinkContext = NULL;

        pBChannel->IsOpen = FALSE;
    }
    else
    {
        DBG_ERROR(pAdapter,("BChannel #%d already closed\n",
                  pBChannel->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL BChannel BChannel_c BChannelAddToReceiveQueue


@func

    <f BChannelAddToReceiveQueue> adds a buffer to the queue of available
    receive buffers associated with this B-channel.

@rdesc

    <f BChannelAddToReceiveQueue> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelAddToReceiveQueue(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PVOID                    pReceiveContext,            // @parm
    // A context value to be passed back to <f TransmitComplete>.

    IN PUCHAR                   BufferPointer,              // @parm
    //  A pointer to the buffer to be transmitted.

    IN ULONG                    BufferSize                  // @parm
    // The size in bytes of the buffer to be transmitted.
    )
{
    DBG_FUNC("BChannelAddToReceiveQueue")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pBChannel->IsOpen);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL BChannel BChannel_c BChannelAddToTransmitQueue


@func

    <f BChannelAddToTransmitQueue>  adds a buffer to the queue of buffers
    to be transmitted on this B-channel.

@rdesc

    <f BChannelAddToTransmitQueue> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS BChannelAddToTransmitQueue(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PVOID                    pTransmitContext,           // @parm
    // A context value to be passed back to <f TransmitComplete>.

    IN PUCHAR                   BufferPointer,              // @parm
    //  A pointer to the buffer to be transmitted.

    IN ULONG                    BufferSize                  // @parm
    // The size in bytes of the buffer to be transmitted.
    )
{
    DBG_FUNC("BChannelAddToTransmitQueue")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pBChannel->IsOpen);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\card.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Card Card_c

@module Card.c |

    This module implements the interface to the <t CARD_OBJECT>.
    Supports the low-level hardware control functions used by the NDIS WAN
    Minport driver.  This module isolates most the vendor specific hardware
    access interfaces.  It will require signficant changes to accomodate
    your hardware device.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Card_c

@end

*/

#define  __FILEID__             CARD_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                    g_CardInstanceCounter       // @globalv
// Keeps track of how many <t CARD_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL Card Card_c g_CardParameters


@topic 5.3 Card Parameters |

    This section describes the registry parameters read into the
    <t CARD_OBJECT>.

@globalv PARAM_TABLE | g_CardParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t CARD_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t CARD_OBJECT>
    you will need to modify <f CardReadParameters> and add the parameter
    definitions to the <f g_CardParameters> table.

*/

DBG_STATIC PARAM_TABLE              g_CardParameters[] =
{
#if defined(PCI_BUS)
    PARAM_ENTRY(CARD_OBJECT,
                PciSlotNumber, PARAM_PciSlotNumber,
                TRUE, NdisParameterInteger, 0,
                0, 0, 31),
#endif // PCI_BUS

    PARAM_ENTRY(CARD_OBJECT,
                BufferSize, PARAM_BufferSize,
                FALSE, NdisParameterInteger, 0,
                CARD_DEFAULT_PACKET_SIZE, CARD_MIN_PACKET_SIZE, CARD_MAX_PACKET_SIZE),

    PARAM_ENTRY(CARD_OBJECT,
                ReceiveBuffersPerLink, PARAM_ReceiveBuffersPerLink,
                FALSE, NdisParameterInteger, 0,
                2, 2, 16),

    PARAM_ENTRY(CARD_OBJECT,
                TransmitBuffersPerLink, PARAM_TransmitBuffersPerLink,
                FALSE, NdisParameterInteger, 0,
                2, 1, 16),

    PARAM_ENTRY(CARD_OBJECT,
                NumDChannels, PARAM_NumDChannels,
                FALSE, NdisParameterInteger, 0,
                1, 1, 4),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL Card Card_c CardReadParameters


@func

    <f CardReadParameters> reads the Card parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f CardCreate>.

    <f Note>:
    If you add any registry based data members to <t CARD_OBJECT>
    you will need to modify <f CardReadParameters> and add the parameter
    definitions to the <f g_CardParameters> table.

@rdesc

    <f CardReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardReadParameters(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pCard,
                    g_CardParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pCard->BufferSize & 0x1F)
        {
            DBG_ERROR(pAdapter,("Invalid value 'BufferSize'=0x0x%X must be multiple of 32\n",
                        pCard->BufferSize));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pCard->BufferSize,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Card Card_c CardFindNIC


@func

    <f CardFindNIC> locates the NIC associated with this NDIS device.

@rdesc

    <f CardFindNIC> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardFindNIC(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardFindNIC")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

#if defined(PCI_BUS)
    ULONG                       Index;
    // Loop counter.

    PNDIS_RESOURCE_LIST         pPciResourceList;

    PCM_PARTIAL_RESOURCE_DESCRIPTOR pPciResource;

#endif // PCI_BUS

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(PCI_BUS)
    /*
    // Read the PCI data and initialize the driver data structure
    // with the data returned.
    */
    pPciResourceList = NULL;

    Result = NdisMPciAssignResources(pAdapter->MiniportAdapterHandle,
                                     pCard->PciSlotNumber,
                                     &pPciResourceList);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(pAdapter,("NdisMPciAssignResources Result=0x%X\n",
                  Result));
        NdisWriteErrorLogEntry(
                pAdapter->MiniportAdapterHandle,
                NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                4,
                pCard->PciSlotNumber,
                Result,
                __FILEID__,
                __LINE__
                );
    }

    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < pPciResourceList->Count; ++Index)
    {
        ASSERT(pPciResourceList);
        pPciResource = &pPciResourceList->PartialDescriptors[Index];
        ASSERT(pPciResource);

        switch (pPciResource->Type)
        {
        case CmResourceTypePort:
#if defined(CARD_MIN_IOPORT_SIZE)
            if (pPciResource->u.Port.Start.LowPart &&
                pPciResource->u.Port.Length >= CARD_MIN_IOPORT_SIZE)
            {
                DBG_NOTICE(pAdapter,("Port: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Port.Start.LowPart,
                          pPciResource->u.Port.Length,
                          CARD_MIN_IOPORT_SIZE));
                pCard->ResourceInformation.IoPortPhysicalAddress =
                        pPciResource->u.Port.Start;
                pCard->ResourceInformation.IoPortLength =
                        pPciResource->u.Port.Length;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Port: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Port.Start,
                          pPciResource->u.Port.Length,
                          CARD_MIN_IOPORT_SIZE));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Port.Length,
                        CARD_MIN_IOPORT_SIZE,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
#endif // CARD_MIN_IOPORT_SIZE
            break;

        case CmResourceTypeInterrupt:
#if defined(CARD_REQUEST_ISR)
            if (pPciResource->u.Interrupt.Level)
            {
                DBG_NOTICE(pAdapter,("Interrupt: Lev=%d,Vec=%d\n",
                           pPciResource->u.Interrupt.Level,
                           pPciResource->u.Interrupt.Vector));
                pCard->ResourceInformation.InterruptLevel =
                        pPciResource->u.Interrupt.Level;
                pCard->ResourceInformation.InterruptVector =
                        pPciResource->u.Interrupt.Vector;

                pCard->ResourceInformation.InterruptShared = CARD_INTERRUPT_SHARED;
                pCard->ResourceInformation.InterruptMode = CARD_INTERRUPT_MODE;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Interrupt: Lev=%d,Vec=%d\n",
                          pPciResource->u.Interrupt.Level,
                          pPciResource->u.Interrupt.Vector));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Interrupt.Level,
                        pPciResource->u.Interrupt.Vector,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
#endif // defined(CARD_REQUEST_ISR)
            break;

        case CmResourceTypeMemory:
#if defined(CARD_MIN_MEMORY_SIZE)
            if (pPciResource->u.Memory.Start.LowPart &&
                pPciResource->u.Memory.Length >= CARD_MIN_MEMORY_SIZE)
            {
                DBG_NOTICE(pAdapter,("Memory: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Memory.Start.LowPart,
                          pPciResource->u.Memory.Length,
                          CARD_MIN_MEMORY_SIZE));
                pCard->ResourceInformation.MemoryPhysicalAddress =
                        pPciResource->u.Memory.Start;
                pCard->ResourceInformation.MemoryLength =
                        pPciResource->u.Memory.Length;
            }
            else
            {
                DBG_ERROR(pAdapter,("Invalid Memory: Ptr=0x%X Len=%d<%d\n",
                          pPciResource->u.Memory.Start.LowPart,
                          pPciResource->u.Memory.Length,
                          CARD_MIN_MEMORY_SIZE));
                NdisWriteErrorLogEntry(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER,
                        4,
                        pPciResource->u.Memory.Length,
                        CARD_MIN_MEMORY_SIZE,
                        __FILEID__,
                        __LINE__
                        );
                Result = NDIS_STATUS_RESOURCE_CONFLICT;
            }
            break;
#endif // CARD_MIN_MEMORY_SIZE

        default:
            DBG_ERROR(pAdapter,("Unknown resource type=%d\n",
                      pPciResource->Type));
            break;
        }
    }
    pCard->ResourceInformation.BusInterfaceType = NdisInterfacePci;

#endif // PCI_BUS

    pCard->ResourceInformation.Master = CARD_IS_BUS_MASTER;
#if (CARD_IS_BUS_MASTER)
    pCard->ResourceInformation.DmaChannel = 0;
    pCard->ResourceInformation.Dma32BitAddresses = TRUE,
    pCard->ResourceInformation.MaximumPhysicalMapping = pCard->BufferSize;
    pCard->ResourceInformation.PhysicalMapRegistersNeeded = CARD_MAP_REGISTERS_NEEDED;
#endif // (CARD_IS_BUS_MASTER)

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreateInterface


@func

    <f CardCreateInterface> allocates a shared memory pool and uses it to
    establish the message interface between the Miniport and the NIC.

@rdesc

    <f CardCreateInterface> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardCreateInterface(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreateObjects


@func

    <f CardCreateObjects> calls the create routines for all the objects
    contained in <t CARD_OBJECT>.  This should only be called
    by <f CardCreate>.

    <f Note>:
    If you add any new objects to <t CARD_OBJECT> you will need
    to modify <f CardCreateObjects> and <f CardDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f CardCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS CardCreateObjects(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ULONG                       Index;
    // Loop counter.

    ULONG                       NumPorts;
    // The number of Ports supported by the NIC.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Try to locate the NIC on the PCI bus.
    */
    Result = CardFindNIC(pCard);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto ExceptionExit;
    }

    /*
    // Create the message interface to the NIC.
    */
    Result = CardCreateInterface(pCard);
    if (Result != NDIS_STATUS_SUCCESS)
    {
        goto ExceptionExit;
    }

    /*
    // Create the Port objects.
    */
    NumPorts = CardNumPorts(pCard);
    Result = ALLOCATE_MEMORY(pCard->pPortArray,
                             sizeof(PVOID) * NumPorts,
                             pAdapter->MiniportAdapterHandle);
    for (Index = 0; Result == NDIS_STATUS_SUCCESS &&
         Index < NumPorts; Index++)
    {
        Result = PortCreate(&pCard->pPortArray[Index], pCard);

        /*
        // Keep track of how many are created.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            pCard->NumPorts++;
        }
    }

ExceptionExit:

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardCreate


@func

    <f CardCreate> allocates memory for a <t CARD_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppCard> will be set to point to the newly created
    <t CARD_OBJECT>.  Otherwise, <p ppCard> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f CardDestroy> must be called to
    release the <t CARD_OBJECT> created by this function.

@rdesc

    <f CardCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardCreate(
    OUT PCARD_OBJECT *          ppCard,                     // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t CARD_OBJECT>.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("CardCreate")

    PCARD_OBJECT                pCard;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppCard = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pCard, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pCard->ObjectType = CARD_OBJECT_TYPE;
        pCard->ObjectID = ++g_CardInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pCard->pAdapter = pAdapter;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = CardReadParameters(pCard);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = CardCreateObjects(pCard);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppCard = pCard;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            CardDestroy(pCard);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardDestroyObjects


@func

    <f CardDestroyObjects> calls the destroy routines for all the objects
    contained in <t CARD_OBJECT>.  This should only be called by
    <f CardDestroy>.

    <f Note>:
    If you add any new objects to <t PCARD_OBJECT> you will need to
    modify <f CardCreateObjects> and <f CardDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void CardDestroyObjects(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardDestroyObjects")

    ULONG                       NumPorts;
    // The number of Ports supported by the NIC.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    /*
    // Destory the Port objects.
    */
    NumPorts = pCard->NumPorts;
    while (NumPorts--)
    {
        PortDestroy(pCard->pPortArray[NumPorts]);
    }
    pCard->NumPorts = 0;

    /*
    // Free space for the Ports.
    */
    if (pCard->pPortArray)
    {
        NumPorts = CardNumPorts(pCard);
        FREE_MEMORY(pCard->pPortArray, sizeof(PVOID) * NumPorts);
    }

    /*
    // Release the system resources back to NDIS.
    */
#if defined(CARD_REQUEST_ISR)
    if (pCard->Interrupt.InterruptObject)
    {
        NdisMDeregisterInterrupt(&pCard->Interrupt);
        pCard->Interrupt.InterruptObject = NULL;
    }
#endif // defined(CARD_REQUEST_ISR)

#if defined(CARD_MIN_IOPORT_SIZE)
    if (pCard->pIoPortVirtualAddress)
    {
        NdisMDeregisterIoPortRange(
                pAdapter->MiniportAdapterHandle,
                pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                pCard->ResourceInformation.IoPortLength,
                pCard->pIoPortVirtualAddress);
        pCard->pIoPortVirtualAddress = NULL;
    }
#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_MIN_MEMORY_SIZE)
    if (pCard->pMemoryVirtualAddress)
    {
        NdisMUnmapIoSpace(
                pAdapter->MiniportAdapterHandle,
                pCard->pMemoryVirtualAddress,
                pCard->ResourceInformation.MemoryLength
                );
        pCard->pMemoryVirtualAddress = NULL;
    }
#endif // CARD_MIN_MEMORY_SIZE

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardDestroy


@func

    <f CardDestroy> frees the memory for this <t CARD_OBJECT>.  All memory
    allocated by <f CardCreate> will be released back to the OS.

*/

void CardDestroy(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pCard)
    {
        ASSERT(pCard->ObjectType == CARD_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_CARD(pCard);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        CardDestroyObjects(pCard);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pCard->ObjectType = 0;
        FREE_OBJECT(pCard);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Card Card_c CardNumPorts


@func

    <f CardNumPorts> will return the total number of ports available on the
    NIC.

@rdesc

    <f CardNumPorts> returns the total number of ports available.

*/

ULONG CardNumPorts(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardNumPorts")

    // TODO - Get the actual number of ports from the card.
    return (pCard->NumDChannels);
}


/* @doc INTERNAL Card Card_c CardNumChannels


@func

    <f CardNumChannels> will return the total number of channels capable
    of supporting data connections to a remote end-point.

@rdesc

    <f CardNumChannels> returns the total number of data channels supported
    on all the NIC ports.

*/

ULONG CardNumChannels(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardNumChannels")

    UINT                        PortIndex;
    // Loop index.

    if (pCard->NumChannels == 0)
    {
        // NumPorts should already be known.
        ASSERT(pCard->NumPorts);

        // Get the actual number of channels configured on all ports.
        for (PortIndex = 0; PortIndex < pCard->NumPorts; PortIndex++)
        {
            pCard->NumChannels += pCard->pPortArray[PortIndex]->NumChannels;
        }
        ASSERT(pCard->NumChannels);
    }

    return (pCard->NumChannels);
}


/* @doc INTERNAL Card Card_c CardInitialize


@func

    <f CardInitialize> will attempt to initialize the NIC, but will not
    enable transmits or receives.

@rdesc

    <f CardInitialize> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardInitialize(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardInitialize")

    int                         num_dial_chan = 0;
    int                         num_sync_chan = 0;
    // The number of channels supported by card is based on InterfaceType.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Inform the wrapper of the physical attributes of this adapter.
    // This must be called before any NdisMRegister functions!
    // This call also associates the MiniportAdapterHandle with this pAdapter.
    */
    NdisMSetAttributes(pAdapter->MiniportAdapterHandle,
                       (NDIS_HANDLE) pAdapter,
                       pCard->ResourceInformation.Master,
                       pCard->ResourceInformation.BusInterfaceType
                       );
#if (CARD_IS_BUS_MASTER)
    if (pCard->ResourceInformation.Master)
    {
        ASSERT(pCard->ResourceInformation.DmaChannel == 0 ||
               pCard->ResourceInformation.BusInterfaceType == NdisInterfaceIsa);
        Result = NdisMAllocateMapRegisters(
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.DmaChannel,
                        pCard->ResourceInformation.Dma32BitAddresses,
                        pCard->ResourceInformation.PhysicalMapRegistersNeeded + 1,
                        pCard->ResourceInformation.MaximumPhysicalMapping
                        );

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMAllocateMapRegisters(%d,%d) Result=0x%X\n",
                      pCard->ResourceInformation.PhysicalMapRegistersNeeded,
                      pCard->ResourceInformation.MaximumPhysicalMapping,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.PhysicalMapRegistersNeeded,
                    pCard->ResourceInformation.MaximumPhysicalMapping,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
    }
#endif // (CARD_IS_BUS_MASTER)

#if defined(CARD_MIN_MEMORY_SIZE)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.MemoryLength)
    {
        Result = NdisMMapIoSpace(
                        &pCard->pMemoryVirtualAddress,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.MemoryPhysicalAddress,
                        pCard->ResourceInformation.MemoryLength);

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMMapIoSpace(0x%X,0x%X) Result=0x%X\n",
                      pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                      pCard->ResourceInformation.MemoryLength,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                    pCard->ResourceInformation.MemoryLength,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            DBG_NOTICE(pAdapter,("NdisMMapIoSpace(0x%X,0x%X) VirtualAddress=0x%X\n",
                      pCard->ResourceInformation.MemoryPhysicalAddress.LowPart,
                      pCard->ResourceInformation.MemoryLength,
                      pCard->pMemoryVirtualAddress));
        }
    }
#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.IoPortLength)
    {
        Result = NdisMRegisterIoPortRange(
                        &pCard->pIoPortVirtualAddress,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                        pCard->ResourceInformation.IoPortLength);

        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMRegisterIoPortRange(0x%X,0x%X) Result=0x%X\n",
                      pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                      pCard->ResourceInformation.IoPortLength,
                      Result));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                    pCard->ResourceInformation.IoPortLength,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
        else
        {
            DBG_NOTICE(pAdapter,("NdisMRegisterIoPortRange(0x%X,0x%X) VirtualAddress=0x%X\n",
                      pCard->ResourceInformation.IoPortPhysicalAddress.LowPart,
                      pCard->ResourceInformation.IoPortLength,
                      pCard->pIoPortVirtualAddress));
        }
    }
#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_REQUEST_ISR)
    if (Result == NDIS_STATUS_SUCCESS &&
        pCard->ResourceInformation.InterruptVector)
    {
        ASSERT(pCard->ResourceInformation.InterruptShared == FALSE ||
               (pCard->ResourceInformation.InterruptMode == NdisInterruptLevelSensitive &&
                CARD_REQUEST_ISR == TRUE));
        Result = NdisMRegisterInterrupt(
                        &pCard->Interrupt,
                        pAdapter->MiniportAdapterHandle,
                        pCard->ResourceInformation.InterruptVector,
                        pCard->ResourceInformation.InterruptLevel,
                        CARD_REQUEST_ISR,
                        pCard->ResourceInformation.InterruptShared,
                        pCard->ResourceInformation.InterruptMode
                        );
        if (Result != NDIS_STATUS_SUCCESS)
        {
            DBG_ERROR(pAdapter,("NdisMRegisterInterrupt failed: Vec=%d, Lev=%d\n",
                     (UINT)pCard->ResourceInformation.InterruptVector,
                     (UINT)pCard->ResourceInformation.InterruptLevel));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_RESOURCE_CONFLICT,
                    5,
                    pCard->ResourceInformation.InterruptVector,
                    pCard->ResourceInformation.InterruptLevel,
                    Result,
                    __FILEID__,
                    __LINE__
                    );
        }
    }
#endif // defined(CARD_REQUEST_ISR)

    // TODO - Add your card initialization here.

    if (Result == NDIS_STATUS_SUCCESS)
    {

    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardLineConnect


@func

    <f CardLineConnect> will connect a call to the selected line.

@rdesc

    <f CardLineConnect> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardLineConnect(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t NDIS_LINK_OBJECT> returned by <f NdisLinkCreate>.
    )
{
    DBG_FUNC("CardLineConnect")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Card Card_c CardLineDisconnect


@func

    <f CardLineDisconnect> will disconnect any call currently on the line.

*/

void CardLineDisconnect(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t NDIS_LINK_OBJECT> returned by <f NdisLinkCreate>.
    )
{
    DBG_FUNC("CardLineDisconnect")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardTransmitPacket


@func

    <f CardTransmitPacket> will start sending the current packet out.

@rdesc

    <f CardTransmitPacket> returns TRUE if the packet is being transmitted,
    otherwise FALSE is returned.

*/

BOOLEAN CardTransmitPacket(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_WAN_PACKET         pWanPacket                  // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.
    )
{
    DBG_FUNC("CardTransmitPacket")

    BOOLEAN                     bResult = FALSE;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(SAMPLE_DRIVER)
{
    PBCHANNEL_OBJECT            pPeerBChannel;
    // A pointer to the peer <t BCHANNEL_OBJECT>.

    PCARD_EVENT_OBJECT          pEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    // If you can transmit the packet on pBChannel, do it now.
    pPeerBChannel = pBChannel->pPeerBChannel;
    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            /*
            // Append the packet onto TransmitBusyList while it is being sent.
            // Then move it to the TransmitCompleteList in CardInterruptHandler
            // after the card is done with it.
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
            InsertTailList(&pBChannel->TransmitBusyList,
                           &pWanPacket->WanPacketQueue);
            NdisReleaseSpinLock(&pAdapter->TransmitLock);
            pEvent->ulEventCode      = CARD_EVENT_RECEIVE;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            pEvent->pWanPacket       = pWanPacket;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            bResult = TRUE;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to transmit the packet.
#endif // SAMPLE_DRIVER

    DBG_RETURN(pAdapter, bResult);
    return (bResult);
}


/* @doc INTERNAL Card Card_c CardGetReceiveInfo


@func

    <f CardGetReceiveInfo> will retrieve the packet header information from
    the receive buffer.  This assumes that the controller has notified the
    driver that a packet has been received.

@rdesc

    <f CardGetReceiveInfo> returns a pointer to the receive buffer if there
    is a packet available, otherwise NULL is returned.

*/

PUCHAR CardGetReceiveInfo(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    OUT PBCHANNEL_OBJECT *      ppBChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t BCHANNEL_OBJECT>.

    OUT PULONG                  pBytesReceived              // @parm
    // Points to a caller-defined memory location to which this function
    // writes the number of bytes received on this BChannel.
    )
{
    DBG_FUNC("CardGetReceiveInfo")

    PUCHAR                      pBuffer = NULL;

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // The length field tells us how many bytes are in the packet.
    // Make sure it isn't bigger than we expect!
    */
    *pBytesReceived = 0;
    *ppBChannel = NULL;

    DBG_RETURN(pAdapter, pBuffer);
    return (pBuffer);
}


/* @doc INTERNAL Card Card_c CardReceiveComplete


@func

    <f CardReceiveComplete> will return the last receive buffer to the
    B-channel queue so it can be used for another incoming packet.

*/

VOID CardReceiveComplete(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("CardReceiveComplete")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardInterruptHandler


@func

    <f CardInterruptHandler> dequeues an event from the asynchronous event
    callback queue <t CARD_EVENT_OBJECT>, and processes it according to
    whether it is a BChannel event, Card event, or B-Advise event.
    The associated callback routines are responsible for processing the
    event.

@comm

    <f NdisAcquireSpinLock> and <f NdisReleaseSpinLock> are used to provide
    protection around the dequeueing code and keep it from being re-entered
    as a result of another asynchronous callback event.

*/

VOID CardInterruptHandler(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardInterruptHandler")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

#if defined(SAMPLE_DRIVER)
{
    PCARD_EVENT_OBJECT          pEvent;
    PCARD_EVENT_OBJECT          pNewEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    PBCHANNEL_OBJECT            pBChannel;
    PBCHANNEL_OBJECT            pPeerBChannel;
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    PNDIS_WAN_PACKET            pWanPacket;
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.

    /*
    // Clear out all packets in the receive buffer.
    */
    NdisDprAcquireSpinLock(&pAdapter->EventLock);
    while (!IsListEmpty(&pAdapter->EventList))
    {
        pEvent = (PCARD_EVENT_OBJECT)RemoveHeadList(&pAdapter->EventList);
        NdisDprReleaseSpinLock(&pAdapter->EventLock);

        ASSERT(pEvent->pReceivingObject);

        switch (pEvent->ulEventCode)
        {
        case CARD_EVENT_RING:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_RING\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            pBChannel->pPeerBChannel = pEvent->pSendingObject;
            ASSERT(pBChannel->pPeerBChannel &&
                   pBChannel->pPeerBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            // We only have to spoof digital data for this sample.
            pBChannel->MediaMode  = LINEMEDIAMODE_DIGITALDATA;
            pBChannel->BearerMode = LINEBEARERMODE_DATA;
            pBChannel->LinkSpeed  = _64KBPS;
            TspiLineDevStateHandler(pAdapter, pBChannel,
                                    LINEDEVSTATE_RINGING);
            break;

        case CARD_EVENT_CONNECT:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_CONNECT\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_CONNECTED,
                                 0);
            break;

        case CARD_EVENT_DISCONNECT:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_DISCONNECT\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            pBChannel->pPeerBChannel = NULL;
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_DISCONNECTED,
                                 LINEDISCONNECTMODE_NORMAL);
            break;

        case CARD_EVENT_RECEIVE:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_RECEIVE\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            ReceivePacketHandler(pBChannel, pEvent->pWanPacket->CurrentBuffer,
                                 pEvent->pWanPacket->CurrentLength);

            pPeerBChannel = pBChannel->pPeerBChannel;
            if (pPeerBChannel)
            {
                pNewEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
                if (pNewEvent)
                {
                    pNewEvent->ulEventCode      = CARD_EVENT_TRANSMIT_COMPLETE;
                    pNewEvent->pSendingObject   = pBChannel;
                    pNewEvent->pReceivingObject = pPeerBChannel;
                    CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pNewEvent);
                }
            }
            else
            {
                DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
            }
            break;

        case CARD_EVENT_TRANSMIT_COMPLETE:
            pBChannel = pEvent->pReceivingObject;
            ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
            DBG_NOTICE(pAdapter,("#%d CallState=0x%X CARD_EVENT_TRANSMIT_COMPLETE\n",
                       pBChannel->BChannelIndex, pBChannel->CallState));
            /*
            // Remove the packet from the BChannel's TransmitBusyList and
            // place it on the adapter's TransmitCompleteList now that the
            // card has completed the transmit.
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
            pWanPacket = (PNDIS_WAN_PACKET)RemoveHeadList(
                                                &pBChannel->TransmitBusyList);
            InsertTailList(&pBChannel->pAdapter->TransmitCompleteList,
                           &pWanPacket->WanPacketQueue);
            NdisReleaseSpinLock(&pAdapter->TransmitLock);

            TransmitCompleteHandler(pAdapter);
            break;

        default:
            DBG_ERROR(pAdapter,("Unknown event code=%d\n",
                      pEvent->ulEventCode));
            break;
        }
        CardEventRelease(pCard, pEvent);
        NdisDprAcquireSpinLock(&pAdapter->EventLock);
    }
    NdisDprReleaseSpinLock(&pAdapter->EventLock);
}
#else  // SAMPLE_DRIVER
    // TODO - Add interrupt handler code here
#endif // SAMPLE_DRIVER

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardCleanPhoneNumber


@func

    <f CardCleanPhoneNumber> copies the phone number from the input string
    to the output string, deleting any non-phone number characters (i.e.
    dashes, parens, modem keywords, etc.).

@rdesc

    <f CardCleanPhoneNumber> returns the length of the output string in bytes.

*/

USHORT CardCleanPhoneNumber(
    OUT PUCHAR                  Dst,                        // @parm
    // A pointer to the output string.

    IN  PUCHAR                  Src,                        // @parm
    // A pointer to the input string.

    IN  USHORT                  Length                      // @parm
    // The length of the input string in bytes.
    )
{
    DBG_FUNC("CardCleanPhoneNumber")

    USHORT                  NumDigits;

    /*
    // Strip out any character which are not digits or # or *.
    */
    for (NumDigits = 0; Length > 0; --Length)
    {
        if ((*Src >= '0' && *Src <= '9') ||
            (*Src == '#' || *Src == '*'))
        {
            /*
            // Make sure dial string is within the limit of the adapter.
            */
            if (NumDigits < CARD_MAX_DIAL_DIGITS)
            {
                ++NumDigits;
                *Dst++ = *Src;
            }
            else
            {
                break;
            }
        }
        Src++;
    }
    *Dst++ = 0;
    return (NumDigits);
}


/* @doc INTERNAL Card Card_c CardReset


@func

    <f CardReset> issues a hard reset to the NIC.  Same as power up.

@rdesc

    <f CardReset> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS CardReset(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("CardReset")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_BREAK(pAdapter);

    // TODO - Add code here to reset your hardware to its initial state.

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


#if defined(SAMPLE_DRIVER)

/* @doc INTERNAL Card Card_c GET_BCHANNEL_FROM_PHONE_NUMBER


@func

    <f GET_BCHANNEL_FROM_PHONE_NUMBER> assumes the phone number is a tapi
    DeviceID, and uses it to lookup the associated BChannel on one of our
    adapters.

@rdesc

    <f GET_BCHANNEL_FROM_PHONE_NUMBER> returns a pointer to the associated
    <t BCHANNEL_OBJECT> if successful.  Otherwise, NULL is returned.

*/

PBCHANNEL_OBJECT GET_BCHANNEL_FROM_PHONE_NUMBER(
    IN  PUCHAR                 pDialString                      // @parm
    // A pointer to the dial string.
    )
{
    DBG_FUNC("GET_BCHANNEL_FROM_PHONE_NUMBER")

    ULONG                       ulCalledID = 0;
    // Phone number converted to BChannel ObjectID (spans all adapters).

    ULONG                       ulAdapterIndex;
    ULONG                       ulBChannelIndex;
    // Loop index.

    /*
    // Strip out any character which are not digits or # or *.
    */
    while (*pDialString)
    {
        if (*pDialString >= '0' && *pDialString <= '9')
        {
            ulCalledID *= 10;
            ulCalledID += *pDialString - '0';
        }
        else
        {
            break;
        }
        pDialString++;
    }
    if (*pDialString)
    {
        DBG_ERROR(DbgInfo,("Invalid dial string '%s'\n", pDialString));
    }
    else
    {
        PMINIPORT_ADAPTER_OBJECT    pAdapter;

        for (ulAdapterIndex = 0; ulAdapterIndex < MAX_ADAPTERS; ++ulAdapterIndex)
        {
            pAdapter = g_Adapters[ulAdapterIndex];
            if (pAdapter)
            {
                PBCHANNEL_OBJECT            pBChannel;

                for (ulBChannelIndex = 0;
                     ulBChannelIndex < pAdapter->NumBChannels;
                     ulBChannelIndex++)
                {
                    pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, ulBChannelIndex);
                    if (pBChannel->htCall == (HTAPI_CALL)0 &&
                        pBChannel->MediaModesMask != 0)
                    {
                        if (ulCalledID == 0)
                        {
                            // Find first available channel.
                            return (pBChannel);
                        }
                        else if (ulCalledID == pBChannel->ObjectID)
                        {
                            // Find selected channel.
                            return (pBChannel);
                        }
                    }
                }
            }
        }
    }
    return (NULL);
}


/* @doc INTERNAL Card Card_c CardNotifyEvent


@func

    <f CardNotifyEvent> queues an IMS event to be processed by the DPC
    handler when things quiet down.

@comm

    We have to queue the event to be processed in DPC context.  We have
    to make sure that the queue is protected by a mutual exclusion
    primative which cannot be violated by the callback.

*/

VOID CardNotifyEvent(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PCARD_EVENT_OBJECT       pEvent                      // @parm
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.
    )
{
    DBG_FUNC("CardNotifyEvent")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    DBG_NOTICE(pAdapter,("pEvent=%X\n",pEvent));

    /*
    // Schedule the event handler to run as soon as possible.
    // We must schedule the event to go through the NDIS wrapper
    // so the proper spin locks will be held.
    // Don't schedule another event if processing is already in progress.
    */
    NdisAcquireSpinLock(&pAdapter->EventLock);
    InsertTailList(&pAdapter->EventList, &pEvent->Queue);
    NdisReleaseSpinLock(&pAdapter->EventLock);
    NdisMSetTimer(&pAdapter->EventTimer, 0);

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Card Card_c CardEventAllocate


@func

    <f CardEventAllocate> allocates an <t CARD_EVENT_OBJECT> from the
    <p pCard>'s EventList.

@rdesc

    <f CardEventAllocate> returns a pointer to a <t CARD_EVENT_OBJECT>
    if it is successful.<nl>
    Otherwise, a NULL return value indicates an error condition.

*/

PCARD_EVENT_OBJECT CardEventAllocate(
    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    PCARD_EVENT_OBJECT          pEvent;
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.

    pEvent = &pCard->EventArray[pCard->NextEvent++];
    ASSERT(pEvent->pReceivingObject == NULL);
    if (pCard->NextEvent >= MAX_EVENTS)
    {
        pCard->NextEvent = 0;
    }
    return (pEvent);
}


/* @doc INTERNAL Card Card_c CardEventRelease


@func

    <f CardEventRelease> returns a previously allocate <t CARD_EVENT_OBJECT>
    to the <p pCard>'s EventList.

*/

VOID CardEventRelease(
    IN PCARD_OBJECT             pCard,                      // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.

    IN PCARD_EVENT_OBJECT       pEvent                      // @parm
    // A pointer to the <t CARD_EVENT_OBJECT> associated with this event.
    )
{
    pEvent->pReceivingObject = NULL;
}

#endif // SAMPLE_DRIVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\dchannel.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL DChannel DChannel_h

@module DChannel.h |

    This module defines the interface to the <t DCHANNEL_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | DChannel_h

@end

*/

#ifndef _DCHANNEL_H
#define _DCHANNEL_H

#define DCHANNEL_OBJECT_TYPE    ((ULONG)'D')+\
                                ((ULONG)'C'<<8)+\
                                ((ULONG)'H'<<16)+\
                                ((ULONG)'N'<<24)

/* @doc INTERNAL DChannel DChannel_h DCHANNEL_OBJECT


@struct DCHANNEL_OBJECT |

    This structure contains the data associated with an ISDN DChannel.  Here,
    DChannel is defined as an interface by which to setup and teardown a
    BChannel connection between two end-points.  This channel is responsible
    for establishing a point-to-point connection over one of the available
    BChannels.

@comm

    This logical DChannel does not necessarily map to a physical DChannel
    on the NIC.  The NIC may in fact have multiple DChannels depending on
    how many ports and whether it is BRI, PRI, T-1, or E-1.  The NIC may in
    fact not have DChannels at all, as may be the case with channelized T-1.
    The DChannel is just a convenient abstraction for announcing and
    answering incoming calls, and for placing outgoing calls.


    There will be one DChannel created for each NIC.  The number of physical
    D-channels depends on how many ports the NIC has, and how the ports are
    provisioned and configured.  The provisioning can be configured at install
    time or changed using the control panel.  The driver does not allow the
    configuration to change at run-time, so the computer or the adapter must
    be restarted to enable the configuration changes.

*/

typedef struct DCHANNEL_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'DCHN'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this DChannel is open, otherwise set FALSE.

    ULONG                       TotalMakeCalls;             // @field
    // Total number of <f DChannelMakeCall> requests.

    ULONG                       TotalAnswers;               // @field
    // Total number of <f DChannelAnswer> requests.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} DCHANNEL_OBJECT;

#define GET_ADAPTER_FROM_DCHANNEL(pDChannel)    (pDChannel->pAdapter)


/*


    Function prototypes.

*/

NDIS_STATUS DChannelCreate(
    OUT PDCHANNEL_OBJECT *      ppDChannel,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void DChannelDestroy(
    IN PDCHANNEL_OBJECT         pDChannel
    );

void DChannelInitialize(
    IN PDCHANNEL_OBJECT         pDChannel
    );

NDIS_STATUS DChannelOpen(
    IN PDCHANNEL_OBJECT         pDChannel
    );

void DChannelClose(
    IN PDCHANNEL_OBJECT         pDChannel
    );

NDIS_STATUS DChannelMakeCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PUCHAR                   DialString,
    IN USHORT                   DialStringLength,
    IN PLINE_CALL_PARAMS        pLineCallParams
    );

NDIS_STATUS DChannelAnswer(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS DChannelDropCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

NDIS_STATUS DChannelCloseCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID DChannelRejectCall(
    IN PDCHANNEL_OBJECT         pDChannel,
    IN PBCHANNEL_OBJECT         pBChannel
    );

#endif // _DCHANNEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\card.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Card Card_h

@module Card.h |

    This module defines the hardware specific structures and values used to
    control the network interface card.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Card_h

@end

*/

#ifndef _CARD_H
#define _CARD_H

#define CARD_OBJECT_TYPE                ((ULONG)'C')+\
                                        ((ULONG)'A'<<8)+\
                                        ((ULONG)'R'<<16)+\
                                        ((ULONG)'D'<<24)

/*
// TODO - These values will normally come from the NIC or the installer.
*/
#define MAX_ADAPTERS                    4
#define CARD_NUM_PORTS                  1

//#define CARD_MIN_IOPORT_SIZE            256
// TODO - How many I/O ports does the card have?  (undefined if none)

//#define CARD_MIN_MEMORY_SIZE            256
// TODO - How much memory does the card have?  (undefined if none)

#define CARD_IS_BUS_MASTER              FALSE
// TODO - Is the card a bus master device?  (TRUE or FALSE)
#if (CARD_IS_BUS_MASTER)
#   define CARD_MAP_REGISTERS_NEEDED    NUM_DEV_PER_ADAP
// TODO - How many map registers needed to transmit data to card.
#endif

//#define CARD_REQUEST_ISR                TRUE
// TODO - How do you want to handle interrupts from the card?
// TRUE if you want to always use MiniportISR().
// FALSE if you want to use MiniportDisable() and MiniportEnable().
// Undefined if your card does not generate interrupts.

#if defined(CARD_REQUEST_ISR)

#define CARD_INTERRUPT_SHARED           TRUE
// TODO - Is your interrupt shared? (TRUE or FALSE).

#define CARD_INTERRUPT_MODE             NdisInterruptLevelSensitive
// TODO - Is your interrupt latched or level sensitve?

#endif // defined(CARD_REQUEST_ISR)

/*
// Maximum packet size allowed by the adapter -- must be restricted to
// 1500 bytes at this point, and must also allow for frames at least 32
// bytes longer.
*/
#define NDISWAN_EXTRA_SIZE              32
#define CARD_MIN_PACKET_SIZE            ( 480 + NDISWAN_EXTRA_SIZE)
#define CARD_MAX_PACKET_SIZE            (2016 + NDISWAN_EXTRA_SIZE)
#define CARD_DEFAULT_PACKET_SIZE        (1504 + NDISWAN_EXTRA_SIZE)

/*
// The WAN miniport must indicate the entire packet when it is received.
*/
#define CARD_MAX_LOOKAHEAD              (pAdapter->pCard->BufferSize)

/*
// Number of digits allowed in a phone number (not including spaces).
*/
#define CARD_MAX_DIAL_DIGITS            32

/*
// These time out values depend on the card firmware and media contraints.
// We should then see an answer within at most 30 seconds.
// When a call arrives, it should be accepted within 10 seconds.
*/
#define CARD_NO_ANSWER_TIMEOUT          (30*1000)   // 30 seconds
#define CARD_NO_ACCEPT_TIMEOUT          (10*1000)   // 10 seconds
#define CARD_NO_CLOSECALL_TIMEOUT       (5*1000)    // 5 seconds - NDISWAN_BUG

#define NULL_BUFFER_POOL                ((NDIS_HANDLE) 0xFFFFFFFF)

/* @doc INTERNAL Card Card_h CARD_RESOURCES


@struct CARD_RESOURCES |

    This structure contains the data associated with the hardware resources
    required to configure the NIC.  These values are isolated from the rest
    of the <t CARD_OBJECT> because they depend on the underlying hardware.

@comm

    The contents of this structure depends on compile time flags and should
    only include information about the resource actually used by the NIC.

    This structure is filled in by <f CardFindNIC> and is used to configure
    and allocate resources from NDIS when <f CardInitialize> is called.

*/

typedef struct CARD_RESOURCES
{
    NDIS_INTERFACE_TYPE         BusInterfaceType;           // @field
    // This value is used to tell NDIS what type of adapter this is.
    // This is usually the same as the registry parameter BusType, but
    // may be different in the case of a bridged adapter.

    BOOLEAN                     Master;                     // @field
    // This is TRUE if the adapter is capable of bus master transfers.
    // Use the <t CARD_IS_BUS_MASTER> defininition to set this value
    // so the other bus master values will be included if needed.
    // See <f NdisMAllocateMapRegisters> for more details on the bus
    // master parameters.

#if (CARD_IS_BUS_MASTER)
    BOOLEAN                     Dma32BitAddresses;          // @field
    // This is TRUE if the bus master device uses 32-bit addresses.
    // Almost always TRUE for today's devices.

    ULONG                       PhysicalMapRegistersNeeded; // @field
    // This should be set to the maximum number of outstanding DMA
    // transfers that can be active at one time.  One for each physical
    // buffer segment.

    ULONG                       MaximumPhysicalMapping;     // @field
    // This should be set to the maximum number of contigous bytes that
    // can make up a single DMA transfer.

    ULONG                       DmaChannel;                 // @field
    // This should only be set if your adapter is an ISA bus master and
    // requires the use of one of the host DMA channels.

#endif // (CARD_IS_BUS_MASTER)

#if defined(CARD_MIN_MEMORY_SIZE)
    ULONG                       MemoryLength;               // @field
    // The number of bytes of memory the NIC has on board.
    // Use the <t CARD_MIN_MEMORY_SIZE> defininition to set the minimum value
    // so the other NIC based memory values will be included if needed.

    NDIS_PHYSICAL_ADDRESS       MemoryPhysicalAddress;      // @field
    // System physical address assigned to the NIC's on board memory.

#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    ULONG                       IoPortLength;               // @field
    // The number of bytes of I/O ports the NIC has on board.
    // Use the <t CARD_MIN_IOPORT_SIZE> defininition to set the minimum value
    // so the other NIC based memory values will be included if needed.

    NDIS_PHYSICAL_ADDRESS       IoPortPhysicalAddress;      // @field
    // System physical address assigned to the NIC's on board I/O ports.

#endif // CARD_MIN_IOPORT_SIZE

#if defined(CARD_REQUEST_ISR)
    ULONG                       InterruptVector;            // @field
    // System interrupt vector assigned to the NIC's interrupt request line.

    ULONG                       InterruptLevel;             // @field
    // System interrupt level assigned to the NIC's interrupt request line.

    ULONG                       InterruptMode;              // @field
    // Set this value to NdisInterruptLevelSensitive or NdisInterruptLatched.
    // Use the <t CARD_INTERRUPT_MODE> defininition to set this value.

    BOOLEAN                     InterruptShared;            // @field
    // Set TRUE if you want to allow the NIC's <f InterruptVector> to be
    // shared with other drivers in the system.
    // Use the <t CARD_INTERRUPT_SHARED> defininition to set this value.

#endif // defined(CARD_REQUEST_ISR)

} CARD_RESOURCES;


#if !defined(CARD_REQUEST_ISR)


/* @doc INTERNAL Card Card_h CARD_EVENT_CODE


@enum CARD_EVENT_CODE |

    This enumeration defines the events generated by the card.

*/

typedef enum CARD_EVENT_CODE
{
    CARD_EVENT_NULL,                                        // @emem
    // Not used for anything.

    CARD_EVENT_RING,                                        // @emem
    // Indicates that a call is incoming on the given BChannel.

    CARD_EVENT_CONNECT,                                     // @emem
    // Indicates that a call is connected on the given BChannel.

    CARD_EVENT_DISCONNECT,                                  // @emem
    // Indicates that a call is disconnected on the given BChannel.

    CARD_EVENT_RECEIVE,                                     // @emem
    // Indicates that a packet is incoming on the given BChannel.

    CARD_EVENT_TRANSMIT_COMPLETE                            // @emem
    // Indicates that the transmit is complete on the given BChannel.

} CARD_EVENT_CODE;

/* @doc INTERNAL Card Card_h CARD_EVENT_OBJECT


@struct CARD_EVENT_OBJECT |

    This structure is used to keep track of events passed between the
    callee and caller.  Each <t CARD_OBJECT> keeps a list of these events.
*/

typedef struct CARD_EVENT_OBJECT
{
    LIST_ENTRY                  Queue;                      // @field
    // Used to place the buffer on one of the receive lists.

    CARD_EVENT_CODE             ulEventCode;                // @field
    // Reason for event notification.

    PVOID                       pSendingObject;             // @field
    // Interface object that is notifying.  See <t BCHANNEL_OBJECT> or
    // <t DCHANNEL_OBJECT>,

    PVOID                       pReceivingObject;           // @field
    // Interface object that is notifying.  See <t BCHANNEL_OBJECT> or
    // <t DCHANNEL_OBJECT>,

    PNDIS_WAN_PACKET            pWanPacket;                 // @field
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.

} CARD_EVENT_OBJECT, *PCARD_EVENT_OBJECT;

#endif // !defined(CARD_REQUEST_ISR)


/* @doc INTERNAL Card Card_h CARD_OBJECT


@struct CARD_OBJECT |

    This structure contains the data associated with the Network Interface
    Card (NIC).  This object is responsible for managing all the hardware
    specific components of the NIC.

@comm

    The <t MINIPORT_ADAPTER_OBJECT> manages the interface between NDIS and
    the driver, and then passes off the hardware specific interface to this
    object.  There is one <t CARD_OBJECT> for each <t MINIPORT_ADAPTER_OBJECT>.

    One of these objects is created each time that our <f MiniportInitialize>
    routine is called.  The NDIS wrapper calls this routine once for each of
    NIC installed and enabled in the system.  In the case of a hot swappable
    NIC (e.g. PCMCIA) the adapter might come and go several times during a
    single Windows session.

*/

typedef struct CARD_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'CARD'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;                   // @field
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    CARD_RESOURCES              ResourceInformation;        // @field
    // Contains adapter specific resource requirements and settings.
    // See <t CARD_RESOURCES>.

    ULONG                       InterruptStatus;            // @field
    // Bits indicating which interrupts need to be processed.

    NDIS_MINIPORT_INTERRUPT     Interrupt;                  // @field
    // Miniport interrupt object used by NDIS.

    USHORT                      ReceiveBuffersPerLink;      // @field
    // Maximum number of receive buffers per channel, registry parameter.

    USHORT                      TransmitBuffersPerLink;     // @field
    // Maximum number of transmit buffers per channel, registry parameter.

    USHORT                      BufferSize;                 // @field
    // The maxmimum packet size.  The NDISWAN spec says this must be 1500+32,
    // but everything seems to work okay if it is set smaller.

    ULONG                       NumChannels;                // @field
    // Number of communication channels configured on the NIC.

    ULONG                       NumPorts;                   // @field
    // Number of <t PORT_OBJECT>'s allocated in <p pPortArray>.

    PPORT_OBJECT *              pPortArray;                 // @field
    // An array of <t PORT_OBJECT>'s created by <f PortCreate>.
    // One entry for each port on NIC.

#if defined(PCI_BUS)
    ULONG                       PciSlotNumber;              // @field
    // PCI slot number for this adapter (FunctionNumber * 32) + DeviceNumber.

#endif // PCI_BUS

#if defined(CARD_MIN_MEMORY_SIZE)
    PCHAR                       pMemoryVirtualAddress;      // @field
    // Virtual adress of NIC memory area.

#endif // CARD_MIN_MEMORY_SIZE

#if defined(CARD_MIN_IOPORT_SIZE)
    PCHAR                       pIoPortVirtualAddress;      // @field
    // Virtual adress of NIC I/O port area.

#endif // CARD_MIN_IOPORT_SIZE

#if (CARD_IS_BUS_MASTER)
    ULONG                       MapRegisterIndex;           // @field
    // Next map register index to be used for DMA transfer.

    long                        MapRegistersInUse;          // @field
    // Number of map registers currently in use.

#endif // (CARD_IS_BUS_MASTER)

    ULONG                       TODO;                       // @field
    // Add your data members here.

    ULONG                       NumDChannels;               // @field
    // The sample driver uses this registry value to determine the number
    // of ports to simulate.

#if defined(SAMPLE_DRIVER)

    LIST_ENTRY                  EventList;                  // @field
    // Events waiting to be processed.  See <t CARD_EVENT_OBJECT>.

#   define MAX_EVENTS 32
    CARD_EVENT_OBJECT           EventArray[MAX_EVENTS];     // @field
    // Card event allocation array.

    ULONG                       NextEvent;                  // @field
    // Index into EventArray.

#endif // SAMPLE_DRIVER

} CARD_OBJECT;

#define GET_ADAPTER_FROM_CARD(pCard)            (pCard->pAdapter)


/*

    Object Interface Prototypes
*/

NDIS_STATUS CardCreate(
    OUT PCARD_OBJECT *          ppCard,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void CardDestroy(
    IN PCARD_OBJECT             pCard
    );

NDIS_STATUS CardInitialize(
    IN PCARD_OBJECT             pCard
    );

ULONG CardNumChannels(
    IN PCARD_OBJECT             pCard
    );

ULONG CardNumPorts(
    IN PCARD_OBJECT             pCard
    );

void CardInterruptHandler(
    IN PCARD_OBJECT             pCard
    );

NDIS_STATUS CardLineConnect(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel
    );

void CardLineDisconnect(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel
    );

BOOLEAN CardTransmitPacket(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PNDIS_WAN_PACKET         pWanPacket
    );

PUCHAR CardGetReceiveInfo(
    IN PCARD_OBJECT             pCard,
    OUT PBCHANNEL_OBJECT *      ppBChannel,
    OUT PULONG                  pBytesReceived
    );

void CardReceiveComplete(
    IN PCARD_OBJECT             pCard,
    IN PBCHANNEL_OBJECT         pBChannel
    );

USHORT CardCleanPhoneNumber(
    OUT PUCHAR                  Dst,
    IN  PUCHAR                  Src,
    IN  USHORT                  Length
    );

NDIS_STATUS CardReset(
    IN PCARD_OBJECT             pCard
    );

#if defined(SAMPLE_DRIVER)

PBCHANNEL_OBJECT GET_BCHANNEL_FROM_PHONE_NUMBER(
    IN  PUCHAR                  pDialString
    );

VOID CardNotifyEvent(
    IN PCARD_OBJECT             pCard,
    IN PCARD_EVENT_OBJECT       pEvent
    );

PCARD_EVENT_OBJECT CardEventAllocate(
    IN PCARD_OBJECT             pCard
    );

VOID CardEventRelease(
    IN PCARD_OBJECT             pCard,
    IN PCARD_EVENT_OBJECT       pEvent
    );

#endif // SAMPLE_DRIVER

#endif // _CARD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\interupt.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Interupt Interupt_c

@module Interupt.c |

    This module implements the Miniport interrupt processing routines and
    asynchronous processing routines.  This module is very dependent on the
    hardware/firmware interface and should be looked at whenever changes
    to these interfaces occur.

@comm

    This driver does not support the physical hardware, so there is no need
    for the typical interrupt handler routines.  However, the driver does
    have an asynchronous event handler which is contained in this module.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Interupt_c

@end

*/

#define  __FILEID__             INTERRUPT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Interupt Interupt_c MiniportCheckForHang

@func

    <f MiniportCheckForHang> reports the state of the network interface card.

@comm

    In NIC drivers, <f MiniportCheckForHang> does nothing more than check
    the internal state of the NIC and return TRUE if it detects that
    the NIC is not operating correctly.

    In intermediate drivers, <f MiniportCheckForHang> can periodically check the
    state of the driver's virtual NIC to determine whether the underlying
    device driver appears to be hung.

    By default, the NDIS library calls <f MiniportCheckForHang> approximately
    every two seconds.

    If <f MiniportCheckForHang> returns TRUE, NDIS then calls the driver's
    MiniportReset function.

    If a NIC driver has no <f MiniportCheckForHang> function and NDIS
    judges the driver unresponsive as, for example, when NDIS holds
    many pending sends and requests queued to the miniport for a time-out
    interval, NDIS calls the driver's <f MiniportReset> function. The NDIS
    library's default time-out interval for queued sends and requests is
    around four seconds. However, a NIC driver's <f MiniportInitialize>
    function can extend NDIS's time-out interval by calling NdisMSetAttributesEx
    from <f MiniportInitialize> to avoid unnecessary resets.

    The <f MiniportInitialize> function of an intermediate driver
    should disable NDIS's time-out interval with NdisMSetAttributesEx
    because such a driver can neither control nor estimate a reasonable
    completion interval for the underlying device driver.

    <f MiniportCheckForHang> can be pre-empted by an interrupt.

    By default, <f MiniportCheckForHang> runs at IRQL DISPATCH_LEVEL.

    <f Note>:
    If your hardware/firmware is flakey you can request that the NDIS
    wrapper call your MiniportReset routine by returning TRUE from this
    routine.  For well behaved hardware/firmware you should always return
    FALSE from this routine.

@rdesc

    <f MiniportCheckForHang> returns FALSE if the NIC is working properly.<nl>
    Otherwise, a TRUE return value indicates that the NIC needs to be reset.

*/

BOOLEAN MiniportCheckForHang(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportCheckForHang")
    // If your hardware can lockup, then you can return TRUE here.
    // If you return TRUE, your MiniportReset routine will be called.
    return (FALSE);
}


#if defined(CARD_REQUEST_ISR)
#if (CARD_REQUEST_ISR == FALSE)

/* @doc INTERNAL Interupt Interupt_c MiniportDisableInterrupt

@func

    <f MiniportDisableInterrupt> disables the interrupt capability of
    the NIC to keep it from generating interrupts.

@comm

    <f MiniportDisableInterrupt> typically disables interrupts by writing
    a mask to the NIC. If a driver does not have this function, typically
    its <f MiniportISR> disables interrupts on the NIC.

    If the NIC does not support dynamic enabling and disabling of
    interrupts or if it shares an IRQ, the miniport driver must register
    a <f MiniportISR> function and set RequestIsr to TRUE when it calls
    NdisMRegisterMiniport. Such a driver's MiniportISR function must
    acknowledge each interrupt generated by the NIC and save any
    necessary interrupt information for the driver's
    MiniportHandleInterrupt function.

    By default, MiniportDisableInterrupt runs at DIRQL, in particular
    at the DIRQL assigned when the NIC driver's MiniportInitialize
    function called NdisMRegisterInterrupt. Therefore,
    MiniportDisableInterrupt can call only a subset of the NDIS library
    functions, such as the NdisRawXxx functions that are safe to call
    at any IRQL.

    If <f MiniportDisableInterrupt> shares resources, such as NIC registers,
    with another MiniportXxx that runs at a lower IRQL, that MiniportXxx
    must call NdisMSychronizeWithInterrupt so the driver's
    <f MiniportSynchronizeISR> function will access those shared
    resources in a synchronized and multiprocessor-safe manner.
    Otherwise, while it is accessing the shared resources, that
    MiniportXxx function can be pre-empted by <f MiniportDisableInterrupt>,
    possibly undoing the work just done by MiniportXxx.

@xref

    <f MiniportEnableInterrupt>
    <f MiniportHandleInterrupt>
    <f MiniportInitialize>
    <f MiniportISR>

*/

void MiniportDisableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportDisableInterrupt")
    DBG_ERROR(pAdapter,("This should not be called!\n"));
}


/* @doc INTERNAL Interupt Interupt_c MiniportEnableInterrupt

@func

    <f MiniportEnableInterrupt> enables the NIC to generate interrupts.

@comm

    <f MiniportEnableInterrupt> typically enables interrupts by writing
    a mask to the NIC.

    A NIC driver that exports a <f MiniportDisableInterrupt> function
    need not have a reciprocal <f MiniportEnableInterrupt> function.
    Such a driver's <f MiniportHandleInterrupt> function is responsible
    for re-enabling interrupts on the NIC.

    If its NIC does not support dynamic enabling and disabling of
    interrupts or if it shares an IRQ, the NIC driver must register
    a <f MiniportISR> function and set RequestIsr to TRUE when it calls
    NdisMRegisterMiniport. Such a driver's <f MiniportISR> function must
    acknowledge each interrupt generated by the NIC and save any
    necessary interrupt information for the driver's
    <f MiniportHandleInterrupt> function.

    <f MiniportEnableInterrupt> can be pre-empted by an interrupt.

    By default, <f MiniportEnableInterrupt> runs at IRQL DISPATCH_LEVEL.

@xref

    <f MiniportDisableInterrupt>
    <f MiniportHandleInterrupt>
    <f MiniportInitialize>
    <f MiniportISR>

*/

void MiniportEnableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportEnableInterrupt")
    DBG_ERROR(pAdapter,("This should not be called!\n"));
}

#else // !(CARD_REQUEST_ISR == FALSE)

/* @doc INTERNAL Interupt Interupt_c MiniportISR

@func

    <f MiniportISR> is the miniport driver's interrupt service routine
    and it runs at a high priority in response to an interrupt.


@comm

    Any NIC driver should do as little work as possible in its
    <f MiniportISR> function, deferring I/O operations for each
    interrupt the NIC generates to the <f MiniportHandleInterrupt>
    function. A NIC driver's ISR is not re-entrant, although two
    instantiations of a <f MiniportISR> function can execute concurrently
    in SMP machines, particularly if the miniport supports
    full-duplex sends and receives.

    Miniport ISR is called under the following conditions:

    An interrupt occurs on the NIC while the driver's <f MiniportInitialize>
    or <f MiniportHalt> function is running.  An interrupt occurs on the I/O bus
    and the NIC shares an IRQ with other devices on that bus.
    If the NIC shares an IRQ with other devices, that miniport's ISR
    must be called on every interrupt to determine whether its NIC
    actually generated the interrupt. If not, <f MiniportISR> should return
    FALSE immediately so the driver of the device that actually generated
    the interrupt is called quickly. This strategy maximizes I/O throughput
    for every device on the same bus.

    An interrupt occurs and the NIC driver specified that its ISR should be
    called to handle every interrupt when its <f MiniportInitialize> function
    called NdisMRegisterInterrupt.

    Miniports that do not provide <f MiniportDisableInterrupt>/<f MiniportEnableInterrupt>
    functionality must have their ISRs called on every interrupt.

    <f MiniportISR> dismisses the interrupt on the NIC, saves whatever state
    it must about the interrupt, and defers as much of the I/O processing
    for each interrupt as possible to the <f MiniportHandleInterrupt> function.

    After <f MiniportISR> returns control with the variables at InterruptRecognized
    and QueueMiniportHandleInterrupt set to TRUE, the corresponding
    <f MiniportHandleInterrupt> function runs at a lower hardware priority
    (IRQL DISPATCH_LEVEL) than that of the ISR (DIRQL). As a general
    rule, <f MiniportHandleInterrupt> should do all the work for interrupt-driven
    I/O operations except for determining whether the NIC actually generated
    the interrupt, and, if necessary, preserving the type (receive, send,
    reset...) of interrupt.

    However, a driver writer should not rely on a one-to-one correspondence
    between the execution of <f MiniportISR> and <f MiniportHandleInterrupt>. A
    <f MiniportHandleInterrupt> function should be written to handle the I/O
    processing for more than one NIC interrupt. Its MiniportISR and
    <f MiniportHandleInterrupt> functions can run concurrently in SMP machines.
    Moreover, as soon as <f MiniportISR> acknowledges a NIC interrupt, the NIC
    can generate another interrupt, while the <f MiniportHandleInterrupt> DPC
    can be queued for execution once for such a sequence of interrupts.

    The <f MiniportHandleInterrupt> function is not queued if the driver's
    <f MiniportHalt> or <f MiniportInitialize> function is currently executing.

    If <f MiniportISR> shares resources, such as NIC registers or state
    variables, with another MiniportXxx that runs at lower IRQL,
    that MiniportXxx must call NdisMSychronizeWithInterrupt so the
    driver's MiniportSynchronizeISR function will access those shared
    resources in a synchronized and multiprocessor-safe manner. Otherwise,
    while it is accessing the shared resources, that MiniportXxx function
    can be pre-empted by <f MiniportISR>, possibly undoing the work just done
    by MiniportXxx.

    By default, <f MiniportISR> runs at DIRQL, in particular at the DIRQL
    assigned when the driver initialized the interrupt object with
    NdisMRegisterInterrupt. Therefore, <f MiniportIsr> can call only a
    subset of the NDIS library functions, such as the NdisRawXxx or
    NdisRead/WriteRegisterXxx functions that are safe to call at
    any IRQL.

@devnote
    <f MiniportISR> must not call any support functions in the NDIS
    interface library or the transport driver.

@xref
    <f MiniportDisableInterrupt>
    <f MiniportEnableInterrupt>
    <f MiniportHalt>
    <f MiniportHandleInterrupt>
    <f MiniportInitialize>
    <f MiniportSynchronizeISR>

*/

void MiniportISR(
    OUT PBOOLEAN                InterruptRecognized,        // @parm
    // If the miniport driver is sharing an interrupt line and it detects
    // that the interrupt came from its NIC, <f MiniportISR> should set
    // this parameter to TRUE.

    OUT PBOOLEAN                QueueMiniportHandleInterrupt, // @parm
    // If the miniport driver is sharing an interrupt line and if
    // <f MiniportHandleInterrupt> must be called to complete handling of
    // the interrupt, <f MiniportISR> should set this parameter to TRUE.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportISR")

    ULONG                       InterruptStatus;

    if ((InterruptStatus = pAdapter->TODO) == 0)
    {
        *InterruptRecognized =
        *QueueMiniportHandleInterrupt = FALSE;
    }
    else
    {
        pAdapter->pCard->InterruptStatus = InterruptStatus;
        *InterruptRecognized =
        *QueueMiniportHandleInterrupt = TRUE;
    }
}

#endif // (CARD_REQUEST_ISR == FALSE)
#endif // defined(CARD_REQUEST_ISR)

/* @doc INTERNAL Interupt Interupt_c MiniportHandleInterrupt

@func

    <f MiniportHandleInterrupt> is called by the deferred processing routine
    in the NDIS library to process an interrupt.

@comm

    <f MiniportHandleInterrupt> does the deferred processing of all
    outstanding interrupt operations and starts any new operations.
    That is, the driver's <f MiniportISR> or <f MiniportDisableInterrupt>
    function dismisses the interrupt on the NIC, saves any necessary
    state about the operation, and returns control as quickly as possible,
    thereby deferring most interrupt-driven I/O operations to
    <f MiniportHandleInterrupt>.

    <f MiniportHandleInterrupt> carries out most operations to indicate
    receives on NICs that generate interrupts, including but not
    limited to the following:

    Adjusting the size of the buffer descriptor(s) to match the size of
    the received data and chaining the buffer descriptor(s) to the packet
    descriptor for the indication.

    Setting up an array of packet descriptors and setting up any
    out-of-band information for each packet in the array for the
    indication or, if the miniport does not support multipacket
    receive indications, setting up a lookahead buffer

    If the driver supports multipacket receives, it must indicate
    packet arrays in which the packet descriptors were allocated
    from packet pool and the buffer descriptors chained to those
    packets were allocated from buffer pool.

    Calling the appropriate Ndis..IndicateReceive function for the
    received data.

    <f MiniportHandleInterrupt> also can call NdisSendComplete on packets
    for which the MiniportSendPackets or <f MiniportWanSend> function
    returned NDIS_STATUS_PENDING.

    If the NIC shares an IRQ, <f MiniportHandleInterrupt> is called only i
    f the <f MiniportISR> function returned InterruptRecognized set to
    TRUE, thereby indicating that the NIC generated a particular interrupt.

    When <f MiniportHandleInterrupt> is called, interrupts are disabled
    on the NIC, either by the <f MiniportISR> or <f MiniportDisableInterrupt>
    function. Before it returns control, <f MiniportHandleInterrupt> can
    re-enable interrupts on the NIC. Otherwise, NDIS calls a driver-supplied
    MiniportEnableInterrupt function to do so when <f MiniportHandleInterrupt>
    returns control.

    By default, <f MiniportHandleInterrupt> runs at IRQL DISPATCH_LEVEL.

@xref

    <f MiniportDisableInterrupt>
    <f MiniportEnableInterrupt>
    <f MiniportInitialize>
    <f MiniportISR>
    <f MiniportWanSend>

*/

void MiniportHandleInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportHandleInterrupt")

    PBCHANNEL_OBJECT            pBChannel;
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    ULONG                       BChannelIndex;
    // Index into the pBChannelArray.

    /*
    // Process NIC interrupt.
    */
    CardInterruptHandler(pAdapter->pCard);

    /*
    // Walk through all the links to see if there is any post-proccessing
    // that needs to be done.
    */
    for (BChannelIndex = 0; BChannelIndex < pAdapter->NumBChannels; ++BChannelIndex)
    {
        pBChannel = GET_BCHANNEL_FROM_INDEX(pAdapter, BChannelIndex);

        if (pBChannel->IsOpen)
        {
            /*
            // If this is the last transmit queued on this link, and it has
            // been closed, close the link and notify the protocol that the
            // link has been closed.
            */
            if (IsListEmpty(&pBChannel->TransmitBusyList)
                && pBChannel->CallClosing)
            {
                DBG_FILTER(pAdapter, DBG_TAPICALL_ON,
                           ("#%d Call=0x%X CallState=0x%X CLOSE PENDED\n",
                            pBChannel->BChannelIndex,
                            pBChannel->htCall, pBChannel->CallState));

                /*
                // This must not be called until all transmits have been dequeued
                // and ack'd.  Otherwise the wrapper will hang waiting for transmit
                // request to complete.
                */
                DChannelCloseCall(pAdapter->pDChannel, pBChannel);

                /*
                // Indicate close complete to the wrapper.
                */
                NdisMSetInformationComplete(
                        pAdapter->MiniportAdapterHandle,
                        NDIS_STATUS_SUCCESS
                        );
            }

            /*
            // Indicate a receive complete if it's needed.
            */
            if (pBChannel->NeedReceiveCompleteIndication)
            {
                pBChannel->NeedReceiveCompleteIndication = FALSE;

                /*
                // Indicate receive complete to the NDIS wrapper.
                */
                DBG_RXC(pAdapter, pBChannel->BChannelIndex);
                NdisMWanIndicateReceiveComplete(
                        pAdapter->MiniportAdapterHandle,
                        pBChannel->NdisLinkContext
                        );
            }
        }
    }

    /*
    // Indicate a status complete if it's needed.
    */
    if (pAdapter->NeedStatusCompleteIndication)
    {
        pAdapter->NeedStatusCompleteIndication = FALSE;
        NdisMIndicateStatusComplete(pAdapter->MiniportAdapterHandle);
    }
}


/* @doc INTERNAL Interupt Interupt_c MiniportTimer


@func

    <f MiniportTimer> is a required function if a Miniport's NIC does not
    generate interrupts.  Otherwise, one or more <f MiniportTimer> functions
    are optional.

@comm

    For a NIC that does not generate interrupts, the <f MiniportTimer>
    function is used to poll the state of the NIC.

    After such a driver's <f MiniportInitialize> function sets up the
    driver-allocated timer object with NdisMInitializeTimer, a
    call to NdisMSetPeriodicTimer causes the <f MiniportTimer> function
    associated with the timer object to be run repeatedly and
    automatically at the interval specified by MillisecondsPeriod.
    Such a polling <f MiniportTimer> function monitors the state of the
    NIC to determine when to make indications, when to complete
    pending sends, and so forth. In effect, such a polling <f MiniportTimer>
    function has the same functionality as the <f MiniportHandleInterrupt>
    function in the driver of a NIC that does generate interrupts.

    By contrast, calling NdisMSetTimer causes the <f MiniportTimer>
    function associated with the timer object to be run once when
    the given MillisecondsToDelay expires. Such a <f MiniportTimer>
    function usually performs some driver-determined action if a
    particular operation times out.

    If either type of <f MiniportTimer> function shares resources with
    other driver functions, the driver should synchronize access to
    those resources with a spin lock.

    Any NIC driver or intermediate driver can have more than one
    <f MiniportTimer> function at the discretion of the driver writer.
    Each such <f MiniportTimer> function must be associated with a
    driver-allocated and initialized timer object.

    A call to NdisMCancelTimer cancels execution of a nonpolling
    <f MiniportTimer> function, provided that the interval passed in
    the immediately preceding call to NdisMSetTimer has not yet
    expired. After a call to NdisMSetPeriodicTimer, a call to
    NdisMSetTimer or NdisMCancelTimer with the same timer object
    disables a polling <f MiniportTimer> function: either the
    MiniportTimer function runs once, or it is canceled.

    The <f MiniportHalt> function of any driver with a <f MiniportTimer>
    function should call NdisMCancelTimer to ensure that the
    <f MiniportTimer> function does not attempt to access resources
    that <f MiniportHalt> has already released.

    By default, <f MiniportTimer> runs at IRQL DISPATCH_LEVEL.

@xref
    <f MiniportHalt>
    <f MiniportInitialize>
    <f NdisAcquireSpinLock>
    <f NdisAllocateSpinLock>


*/

void MiniportTimer(
    IN PVOID                    SystemSpecific1,            // @parm
    // Points to a system-specific variable, which is opaque
    // to <f MiniportTimer> and reserved for system use.
    // UNREFERENCED_PARAMETER

    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PVOID                    SystemSpecific2,            // @parm
    // UNREFERENCED_PARAMETER

    IN PVOID                    SystemSpecific3             // @parm
    // UNREFERENCED_PARAMETER
    )
{
    DBG_FUNC("MiniportTimer")

    DBG_ENTER(pAdapter);

    /*
    // If this is a nested callback, just return, and we'll loop back to
    // the DoItAgain before leaving the outermost callback.
    */
    if (++(pAdapter->NestedEventHandler) > 1)
    {
        DBG_WARNING(pAdapter,("NestedEventHandler=%d > 1\n",
                  pAdapter->NestedEventHandler));
        return;
    }

DoItAgain:
#if defined(SAMPLE_DRIVER)
    /*
    // This sample driver uses timer to simulate interrupts.
    */
    MiniportHandleInterrupt(pAdapter);
#else  // SAMPLE_DRIVER
    // TODO - Add code here to handle timer interrupt events.
#endif // SAMPLE_DRIVER

    /*
    // If we got a nested callback, we have to loop back around.
    */
    if (--(pAdapter->NestedEventHandler) > 0)
    {
        goto DoItAgain;
    }
    else if (pAdapter->NestedEventHandler < 0)
    {
        DBG_ERROR(pAdapter,("NestedEventHandler=%d < 0\n",
                  pAdapter->NestedEventHandler));
    }

    DBG_LEAVE(pAdapter);

    UNREFERENCED_PARAMETER(SystemSpecific1);
    UNREFERENCED_PARAMETER(SystemSpecific2);
    UNREFERENCED_PARAMETER(SystemSpecific3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\dchannel.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL DChannel DChannel_c

@module DChannel.c |

    This module implements the interface to the <t DCHANNEL_OBJECT>.
    Supports the high-level channel control functions used by the NDIS WAN
    Minport driver.  This module isolates most the vendor specific Call
    Control interfaces.  It will require some changes to accomodate your
    hardware device's call control mechanism.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | DChannel_c

@end

*/

#define  __FILEID__             DCHANNEL_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                    g_DChannelInstanceCounter   // @globalv
// Keeps track of how many <t DCHANNEL_OBJECT>s are created.
                                = 0;


/* @doc EXTERNAL INTERNAL DChannel DChannel_c g_DChannelParameters


@topic 5.4 DChannel Parameters |

    This section describes the registry parameters read into the
    <t DCHANNEL_OBJECT>.

@globalv PARAM_TABLE | g_DChannelParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t DCHANNEL_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t DCHANNEL_OBJECT>
    you will need to modify <f DChannelReadParameters> and add the parameter
    definitions to the <f g_DChannelParameters> table.

*/

DBG_STATIC PARAM_TABLE              g_DChannelParameters[] =
{
    PARAM_ENTRY(DCHANNEL_OBJECT,
                TODO, PARAM_TODO,
                FALSE, NdisParameterInteger, 0,
                0, 0, 0),

    /* The last entry must be an empty string! */
    { { 0 } }
};


/* @doc INTERNAL DChannel DChannel_c DChannelReadParameters


@func

    <f DChannelReadParameters> reads the DChannel parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f DChannelCreate>.

    <f Note>:
    If you add any registry based data members to <t DCHANNEL_OBJECT>
    you will need to modify <f DChannelReadParameters> and add the parameter
    definitions to the <f g_DChannelParameters> table.

@rdesc

    <f DChannelReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS DChannelReadParameters(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pDChannel,
                    g_DChannelParameters
                    );

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pDChannel->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pDChannel->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCreateObjects


@func

    <f DChannelCreateObjects> calls the create routines for all the objects
    contained in <t DCHANNEL_OBJECT>.  This should only be called
    by <f DChannelCreate>.

    <f Note>:
    If you add any new objects to <t DCHANNEL_OBJECT> you will need
    to modify <f DChannelCreateObjects> and <f DChannelDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f DChannelCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS DChannelCreateObjects(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to allocate any sub-objects needed to support
    // your physical DChannels.

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCreate


@func

    <f DChannelCreate> allocates memory for a <t DCHANNEL_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppDChannel> will be set to point to the newly created
    <t DCHANNEL_OBJECT>.  Otherwise, <p ppDChannel> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f DChannelDestroy> must be called to
    release the <t DCHANNEL_OBJECT> created by this function.

@rdesc

    <f DChannelCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelCreate(
    OUT PDCHANNEL_OBJECT *      ppDChannel,                 // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t DCHANNEL_OBJECT>.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("DChannelCreate")

    PDCHANNEL_OBJECT            pDChannel;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    ASSERT(pAdapter && pAdapter->ObjectType == MINIPORT_ADAPTER_OBJECT_TYPE);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppDChannel = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pDChannel, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pDChannel->ObjectType = DCHANNEL_OBJECT_TYPE;
        pDChannel->ObjectID = ++g_DChannelInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pDChannel->pAdapter = pAdapter;

        // TODO - Add code here to allocate any resources needed to support
        // your physical DChannels.

        /*
        // Parse the registry parameters.
        */
        Result = DChannelReadParameters(pDChannel);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = DChannelCreateObjects(pDChannel);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppDChannel = pDChannel;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            DChannelDestroy(pDChannel);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDestroyObjects


@func

    <f DChannelDestroyObjects> calls the destroy routines for all the objects
    contained in <t DCHANNEL_OBJECT>.  This should only be called by
    <f DChannelDestroy>.

    <f Note>: If you add any new objects to <t PDCHANNEL_OBJECT> you will need to
    modify <f DChannelCreateObjects> and <f DChannelDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void DChannelDestroyObjects(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to release any sub-objects allocated by
    // DChannelCreateObjects.

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDestroy


@func

    <f DChannelDestroy> frees the memory for this <t DCHANNEL_OBJECT>.
    All memory allocated by <f DChannelCreate> will be released back to the
    OS.

*/

void DChannelDestroy(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pDChannel)
    {
        ASSERT(pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

        DBG_ENTER(pAdapter);

        // TODO - Add code here to release any resources allocated by
        // DChannelCreate.

        /*
        // Release all objects allocated within this object.
        */
        DChannelDestroyObjects(pDChannel);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pDChannel->ObjectType = 0;
        FREE_OBJECT(pDChannel);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL DChannel DChannel_c DChannelInitialize


@func

    <f DChannelInitialize> resets all the internal data members contained
    in <t BCHANNEL_OBJECT> back to their initial state.

    <f Note>:
    If you add any new members to <t DCHANNEL_OBJECT> you will need to
    modify <f DChannelInitialize> to initialize your new data mamebers.

*/

void DChannelInitialize(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelInitialize")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to initialize all the physical D-Channels on
    // your adapter.

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelOpen


@func

    <f DChannelOpen> establishes a communications path between the miniport
    and the DChannel.

@rdesc

    <f DChannelOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelOpen(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (!pDChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening DChannel #%d\n",
                   pDChannel->ObjectID));

        // TODO - Add code here to open all the physical D-Channels on
        // your adapter.

        pDChannel->IsOpen = TRUE;
    }
    else
    {
        DBG_ERROR(pAdapter,("DChannel #%d already opened\n",
                  pDChannel->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelClose


@func

    <f DChannelClose> tears down the communications path between the miniport
    and the DChannel.

*/

void DChannelClose(
    IN PDCHANNEL_OBJECT         pDChannel                   // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.
    )
{
    DBG_FUNC("DChannelClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    if (pDChannel->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing DChannel #%d\n",
                   pDChannel->ObjectID));

        // TODO - Add code here to close all the physical D-Channels on
        // your adapter.

        pDChannel->IsOpen = FALSE;
    }
    else
    {
        DBG_WARNING(pAdapter,("DChannel #%d already closed\n",
                    pDChannel->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL DChannel DChannel_c DChannelMakeCall


@func

    <f DChannelMakeCall> places a call over the selected line device.

@rdesc

    <f DChannelMakeCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelMakeCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PUCHAR                   DialString,                 // @parm
    // A pointer to an ASCII null-terminated string of digits.

    IN USHORT                   DialStringLength,           // @parm
    // Number of bytes in dial string.

    IN PLINE_CALL_PARAMS        pLineCallParams             // @parm
    // A pointer to the TAPI <t LINE_CALL_PARAMS> to be used for this call.
    )
{
    DBG_FUNC("DChannelMakeCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    pDChannel->TotalMakeCalls++;

#if defined(SAMPLE_DRIVER)
    // This sample code uses the phone number to select one of the other
    // BChannels on which to complete the connection.
{
    PBCHANNEL_OBJECT            pPeerBChannel;
    PCARD_EVENT_OBJECT          pEvent;

    pPeerBChannel = GET_BCHANNEL_FROM_PHONE_NUMBER(DialString);
    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            /*
            // Start the call state sequence so we don't leave it in the
            // IDLE state.
            */
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_DIALING,
                                 0);

            /*
            // We should get an answer within N seconds if the call has gone
            // through.
            */
            NdisMSetTimer(&pBChannel->CallTimer, pAdapter->NoAnswerTimeOut);

            pEvent->ulEventCode      = CARD_EVENT_RING;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            pBChannel->pPeerBChannel = pPeerBChannel;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
        }
        else
        {
            Result = NDIS_STATUS_TAPI_RESOURCEUNAVAIL;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("Cannot map phone number '%s' to BChannel\n",
                  DialString));
        Result = NDIS_STATUS_TAPI_INVALPARAM;
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to place a call.
#endif // SAMPLE_DRIVER

    if (Result == NDIS_STATUS_SUCCESS)
    {
        LinkLineUp(pBChannel);
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelAnswer


@func

    <f DChannelAnswer> answers the incoming call so it can be connected.

@rdesc

    <f DChannelAnswer> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelAnswer(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelAnswer")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    pDChannel->TotalAnswers++;

#if defined(SAMPLE_DRIVER)
    // This sample code sends a connect over to the calling BChannel.
{
    PCARD_EVENT_OBJECT          pEvent;
    PBCHANNEL_OBJECT            pPeerBChannel = pBChannel->pPeerBChannel;

    if (pPeerBChannel)
    {
        pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
        if (pEvent)
        {
            pEvent->ulEventCode      = CARD_EVENT_CONNECT;
            pEvent->pSendingObject   = pBChannel;
            pEvent->pReceivingObject = pPeerBChannel;
            CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);

            // Indicate call connected to the calling channel.
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_CONNECTED,
                                 0);
        }
        else
        {
            Result = NDIS_STATUS_TAPI_CALLUNAVAIL;
        }
    }
    else
    {
        DBG_ERROR(pAdapter,("pPeerBChannel == NULL\n"));
        Result = NDIS_STATUS_TAPI_CALLUNAVAIL;
    }
}
#else  // SAMPLE_DRIVER
    // TODO - Add code here to answer a call.
#endif // SAMPLE_DRIVER

    if (Result == NDIS_STATUS_SUCCESS)
    {
        LinkLineUp(pBChannel);
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelDropCall


@func

    <f DChannelDropCall> drops a previously opened call instance.  The call
    remains open and can be queried after the call is dropped.

@rdesc

    <f DChannelDropCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelDropCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelDropCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    // Tell NDIS that the link is no longer available.
    LinkLineDown(pBChannel);

    // This routine may be called several times during line/call cleanup.
    // If the call is already closed, just return success.
    if (pBChannel->CallState != 0 &&
        pBChannel->CallState != LINECALLSTATE_IDLE)
    {
#if defined(SAMPLE_DRIVER)
        // This sample code sends a disconnect over to the connected BChannel.
        PCARD_EVENT_OBJECT      pEvent;
        PBCHANNEL_OBJECT        pPeerBChannel = pBChannel->pPeerBChannel;

        if (pPeerBChannel)
        {
            pEvent = CardEventAllocate(pPeerBChannel->pAdapter->pCard);
            if (pEvent)
            {
                pEvent->ulEventCode      = CARD_EVENT_DISCONNECT;
                pEvent->pSendingObject   = pBChannel;
                pEvent->pReceivingObject = pPeerBChannel;
                CardNotifyEvent(pPeerBChannel->pAdapter->pCard, pEvent);
            }
            pBChannel->pPeerBChannel = NULL;
            // Indicate call discconect to the calling channel.
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_DISCONNECTED,
                                 LINEDISCONNECTMODE_NORMAL);
            TspiCallStateHandler(pAdapter, pBChannel,
                                 LINECALLSTATE_IDLE,
                                 0);
        }
        else
        {
            DBG_WARNING(pAdapter,("#%d NO PEER CHANNEL - CALLSTATE=%X\n",
                        pBChannel->BChannelIndex, pBChannel->CallState));
        }
#else  // SAMPLE_DRIVER
        // TODO - Add code here to drop a call.
#endif // SAMPLE_DRIVER
    }
    else
    {
        DBG_NOTICE(pAdapter,("#%d ALREADY IDLE - CALLSTATE=%X\n",
                   pBChannel->BChannelIndex, pBChannel->CallState));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelCloseCall


@func

    <f DChannelCloseCall> closes a previously opened call instance as
    initiated from <f DChannelMakeCall> or <f DChannelAnswer>.  After the
    call is closed, no one else should reference it.

@rdesc

    <f DChannelCloseCall> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS DChannelCloseCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelCloseCall")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    ASSERT(pDChannel->IsOpen);

    // This routine may be called several times during line/call cleanup.
    // If the call is already closed, just return success.
    if (pBChannel->CallState != 0)
    {
        // Make sure the call is dropped before closing.
        DChannelDropCall(pDChannel, pBChannel);
        pBChannel->CallState = 0;
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL DChannel DChannel_c DChannelRejectCall


@func

    <f DChannelRejectCall> rejects an incoming call as initiated from a
    LINEDEVSTATE_RINGING event sent to <f TspiLineDevStateHandler>.

*/

VOID DChannelRejectCall(
    IN PDCHANNEL_OBJECT         pDChannel,                  // @parm
    // A pointer to the <t DCHANNEL_OBJECT> returned by <f DChannelCreate>.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("DChannelRejectCall")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pDChannel && pDChannel->ObjectType == DCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_DCHANNEL(pDChannel);

    DBG_ENTER(pAdapter);

    // TODO - Add code here to reject an incoming call.

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\port.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Port Port_c

@module Port.c |

    This module implements the interface to the <t PORT_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Port_c

@end

*/

#define  __FILEID__             PORT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC ULONG                    g_PortInstanceCounter = 0;
// Keeps track of how many <t PORT_OBJECT>s are created.


/* @doc EXTERNAL INTERNAL Port Port_c g_PortParameters


@topic 5.6 Port Parameters |

    This section describes the registry parameters read into the
    <t PORT_OBJECT>.

@globalv PARAM_TABLE | g_PortParameters |

    This table defines the registry based parameters to be assigned to data
    members of the <t PORT_OBJECT>.

    <f Note>:
    If you add any registry based data members to <t PORT_OBJECT>
    you will need to modify <f PortReadParameters> and add the parameter
    definitions to the <f g_PortParameters> table.

*/

DBG_STATIC PARAM_TABLE              g_PortParameters[] =
{
    PARAM_ENTRY(PORT_OBJECT,
                SwitchType, PARAM_SwitchType,
                FALSE, NdisParameterInteger, 0,
                0x0001, 0x0001, 0x8000),

    PARAM_ENTRY(PORT_OBJECT,
                NumChannels, PARAM_NumBChannels,
                FALSE, NdisParameterInteger, 0,
                2, 2, 24),

    /* The last entry must be an empty string! */
    { { 0 } }
};


DBG_STATIC NDIS_STRING  PortPrefix = INIT_STRING_CONST(PARAM_PORT_PREFIX);


/* @doc INTERNAL Port Port_c PortReadParameters


@func

    <f PortReadParameters> reads the Port parameters from the registry
    and initializes the associated data members.  This should only be called
    by <f PortCreate>.

    <f Note>:
    If you add any registry based data members to <t PORT_OBJECT>
    you will need to modify <f PortReadParameters> and add the parameter
    definitions to the <f g_PortParameters> table.

@rdesc

    <f PortReadParameters> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS PortReadParameters(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortReadParameters")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    /*
    // Parse the registry parameters.
    */
    Status = ParamParseRegistry(
                    pAdapter->MiniportAdapterHandle,
                    pAdapter->WrapperConfigurationContext,
                    (PUCHAR)pPort,
                    g_PortParameters
                    );

    DBG_NOTICE(pAdapter,("PortPrefixLen=%d:%d:%ls\n",
                PortPrefix.Length, PortPrefix.MaximumLength, PortPrefix.Buffer));

    if (Status == NDIS_STATUS_SUCCESS)
    {
        /*
        // Make sure the parameters are valid.
        */
        if (pPort->TODO)
        {
            DBG_ERROR(pAdapter,("Invalid parameter\n"
                      ));
            NdisWriteErrorLogEntry(
                    pAdapter->MiniportAdapterHandle,
                    NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                    3,
                    pPort->TODO,
                    __FILEID__,
                    __LINE__
                    );
            Status = NDIS_STATUS_FAILURE;
        }
        else
        {
            /*
            // Finish setting up data members based on registry settings.
            */
        }
    }

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Port Port_c PortCreateObjects


@func

    <f PortCreateObjects> calls the create routines for all the objects
    contained in <t PORT_OBJECT>.  This should only be called
    by <f PortCreate>.

    <f Note>:
    If you add any new objects to <t PORT_OBJECT> you will need
    to modify <f PortCreateObjects> and <f PortDestroyObjects> so they
    will get created and destroyed properly.

@rdesc

    <f PortCreateObjects> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

DBG_STATIC NDIS_STATUS PortCreateObjects(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortCreateObjects")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortCreate


@func

    <f PortCreate> allocates memory for a <t PORT_OBJECT> and then
    initializes the data members to their starting state.
    If successful, <p ppPort> will be set to point to the newly created
    <t PORT_OBJECT>.  Otherwise, <p ppPort> will be set to NULL.

@comm

    This function should be called only once when the Miniport is loaded.
    Before the Miniport is unloaded, <f PortDestroy> must be called to
    release the <t PORT_OBJECT> created by this function.

@rdesc

    <f PortCreate> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS PortCreate(
    OUT PPORT_OBJECT *          ppPort,                     // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated <t PORT_OBJECT>.

    IN PCARD_OBJECT             pCard                       // @parm
    // A pointer to the <t CARD_OBJECT> returned by <f CardCreate>.
    )
{
    DBG_FUNC("PortCreate")

    PPORT_OBJECT                pPort;
    // Pointer to our newly allocated object.

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pCard && pCard->ObjectType == CARD_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_CARD(pCard);

    DBG_ENTER(pAdapter);

    /*
    // Make sure the caller's object pointer is NULL to begin with.
    // It will be set later only if everything is successful.
    */
    *ppPort = NULL;

    /*
    // Allocate memory for the object.
    */
    Result = ALLOCATE_OBJECT(pPort, pAdapter->MiniportAdapterHandle);

    if (Result == NDIS_STATUS_SUCCESS)
    {
        /*
        // Zero everything to begin with.
        // Then set the object type and assign a unique ID .
        */
        pPort->ObjectType = PORT_OBJECT_TYPE;
        pPort->ObjectID = ++g_PortInstanceCounter;

        /*
        // Initialize the member variables to their default settings.
        */
        pPort->pCard = pCard;

        // TODO - Add code here

        /*
        // Parse the registry parameters.
        */
        Result = PortReadParameters(pPort);

        /*
        // If all goes well, we are ready to create the sub-components.
        */
        if (Result == NDIS_STATUS_SUCCESS)
        {
            Result = PortCreateObjects(pPort);
        }

        if (Result == NDIS_STATUS_SUCCESS)
        {
            /*
            // All is well, so return the object pointer to the caller.
            */
            *ppPort = pPort;
        }
        else
        {
            /*
            // Something went wrong, so let's make sure everything is
            // cleaned up.
            */
            PortDestroy(pPort);
        }
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortDestroyObjects


@func

    <f PortDestroyObjects> calls the destroy routines for all the objects
    contained in <t PORT_OBJECT>.  This should only be called by
    <f PortDestroy>.

    <f Note>:
    If you add any new objects to <t PPORT_OBJECT> you will need to
    modify <f PortCreateObjects> and <f PortDestroyObjects> so they
    will get created and destroyed properly.

*/

DBG_STATIC void PortDestroyObjects(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> instance.
    )
{
    DBG_FUNC("PortDestroyObjects")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    // TODO - Add code here

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Port Port_c PortDestroy


@func

    <f PortDestroy> frees the memory for this <t PORT_OBJECT>.
    All memory allocated by <f PortCreate> will be released back to the
    OS.

*/

void PortDestroy(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> returned by <f PortCreate>.
    )
{
    DBG_FUNC("PortDestroy")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    if (pPort)
    {
        ASSERT(pPort->ObjectType == PORT_OBJECT_TYPE);

        pAdapter = GET_ADAPTER_FROM_PORT(pPort);

        DBG_ENTER(pAdapter);

        // TODO - Add code here

        /*
        // Release all objects allocated within this object.
        */
        PortDestroyObjects(pPort);

        /*
        // Make sure we fail the ASSERT if we see this object again.
        */
        pPort->ObjectType = 0;
        FREE_OBJECT(pPort);

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Port Port_c PortOpen


@func

    <f PortOpen> makes the Port connection ready to transmit and
    receive data.

@rdesc

    <f PortOpen> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS PortOpen(
    IN PPORT_OBJECT             pPort,                      // @parm
    // A pointer to the <t PORT_OBJECT> associated with this request.

    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> to be associated with this
    // Port.
    )
{
    DBG_FUNC("PortOpen")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Holds the result code returned by this function.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel);
    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    if (!pPort->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Opening Port #%d\n",
                   pPort->ObjectID));

        // TODO - Add code here

        pPort->IsOpen = TRUE;
    }
    else
    {
        DBG_ERROR(pAdapter,("Port #%d already opened\n",
                  pPort->ObjectID));
    }

    DBG_RETURN(pAdapter, Result);
    return (Result);
}


/* @doc INTERNAL Port Port_c PortClose


@func

    <f PortClose> closes the given B-channel.

*/

void PortClose(
    IN PPORT_OBJECT             pPort                   // @parm
    // A pointer to the <t PORT_OBJECT> associated with this request.
    )
{
    DBG_FUNC("PortClose")

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pPort && pPort->ObjectType == PORT_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_PORT(pPort);

    DBG_ENTER(pAdapter);

    if (pPort->IsOpen)
    {
        DBG_NOTICE(pAdapter,("Closing Port #%d\n",
                   pPort->ObjectID));

        // TODO - Add code here

        pPort->IsOpen = FALSE;
    }
    else
    {
        DBG_ERROR(pAdapter,("Port #%d already closed\n",
                  pPort->ObjectID));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\keywords.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Keywords Keywords_h

@module Keywords.h |

    This file defines the driver parameter keywords used in the registry.
    This file should be #include'd into the driver module defining the
    configuration parameter table <t PARAM_TABLE>.

@comm

    The configuration parmaeters should be parsed early in the initialization
    process so they can be used to configure software and hardware settings.

    You can easily add new parameters using the following procuedure:<nl>
    1) #define a new keyword string here in <f Keywords\.h>.<nl>
    2) Add a corresponding <f PARAM_ENTRY> into your parameter table <t PARAM_TABLE>.<nl>
    3) Add a variable to the associated data structure (e.g. <t MINIPORT_ADAPTER_OBJECT>).

    These values can then be parsed by calling <f ParamParseRegistry> with a
    pointer to your configuration parameter table <t PARAM_TABLE>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Keywords_h

@end

*/


/* @doc EXTERNAL INTERNAL


@topic 5.0 Registry Parameters |

    This section describes the registry parameters used by the driver.
    These parameters are stored in the following registry path.<nl>

    Windows NT registry path:<nl>
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\"VER_PRODUCT_STR"<nl>

    Windows 95 registry path:<nl>
    HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\Class\Net\0001><nl>
    The final path key "\0001" depends on the adapter instance number assigned
    by NDIS during installation.<nl>

    <f Note>: Windows 95 DWORD registry parameters are stored as strings.
    The NDIS wrapper converts them to integers when they are read.  The string
    can be decimal or hexadecimal as long as you read it with the appropriate
    NDIS parameter type.

    These values are declared as entries in the <t PARAM_TABLE> and are parsed
    from the registry using the <f ParamParseRegistry> routine.
    
@flag <f AddressList> (HIDDEN) |

    This MULTI_STRING parameter contains the list of addresses assigned to
    each logical link exported by the Miniport to RAS.
    This parameter is required on Windows NT, but is not used by the
    Windows 95 Miniport.  It cannot be changed by the user. <nl>

    <tab><f Default Value:><tab><tab>"1-1-0"<nl>

@flag <f DeviceName> (HIDDEN) |

    This STRING parameter is the name we use to identify the Miniport to RAS.
    This parameter is required on Windows NT, but is not used by the
    Windows 95 Miniport.  It cannot be changed by the user. <nl>

    <tab><f Default Value:><tab><tab>"VER_PRODUCT_STR"

@flag <f MediaType> (HIDDEN) |

    This STRING parameter is the media type this Miniport supports for RAS.
    This parameter is required on Windows NT, but is not used by the
    Windows 95 Miniport.  It cannot be changed by the user. <nl>

    <tab><f Default Value:><tab><tab>"isdn"<nl>

@flag <f BufferSize> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum buffer size used
    to transmit and receive packets over the IDSN line.  Typically, this is
    defined to be 1500 bytes for most Point to Point (PPP) connections.<nl>

    <tab><f Default Value:><tab><tab>1532<nl>
    <tab><f Valid Range N:><tab><tab>532 <lt>= N <lt>= 4032<nl>

    <f Note>: You must add 32 bytes to the maximum packet size you
    expect to send or receive.  Therefore, if you have a maximum packet size
    of 1500 bytes, excluding media headers, you should set the <f BufferSize>
    value to 1532.<nl>

@flag <f ReceiveBuffersPerLink> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of incoming
    packets that can in progress at any one time.  The Miniport will allocate
    this number of packets per BChannel and set them up for incoming packets.
    Typically, three or four should be sufficient to handle a few short bursts
    that may occur with small packets.  If the Miniport is not able to service
    the incoming packets fast enough, new packets will be dropped and it is up
    to the NDIS WAN Wrapper to resynchronize with the remote station.<nl>

    <tab><f Default Value:><tab><tab>3<nl>
    <tab><f Valid Range N:><tab><tab>2 <lt>= N <lt>= 16<nl>

@flag <f TransmitBuffersPerLink> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of outgoing
    packets that can in progress at any one time.  The Miniport will allow
    this number of packets per BChannel to be outstanding (i.e. in progress).
    Typically, two or three should be sufficient to keep the channel busy for
    normal sized packets.  If there are alot of small packets being sent, the
    BChannel may become idle for brief periods while new packets are being
    queued.  Windows does not normally work this way if it has large amounts
    of data to transfer, so the default value should be sufficient. <nl>

    <tab><f Default Value:><tab><tab>2<nl>
    <tab><f Valid Range N:><tab><tab>1 <lt>= N <lt>= 16<nl>

@flag <f NoAnswerTimeOut> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of
    miliseconds that an outgoing call will be allowed to wait for the remote
    end to respond.  If the remote end does not respond within this time, the
    call will be disconnected and RAS will alert the user. <nl>

    <tab><f Default Value:><tab><tab>15000 (15 seconds)<nl>
    <tab><f Valid Range N:><tab><tab>5000 <lt>= N <lt>= 120000<nl>

@flag <f NoAcceptTimeOut> (OPTIONAL) |

    This DWORD parameter allows you to control the maximum number of
    miliseconds that an incoming call will be allowed to wait for the user or
    an application to accept the call.  If the local end does not respond
    within this time, the call will be rejected and the network will alert
    the caller. <nl>

    <tab><f Default Value:><tab><tab>10000 (10 seconds)<nl>
    <tab><f Valid Range N:><tab><tab>1000 <lt>= N <lt>= 60000<nl>

@flag <f DebugFlags> (OPTIONAL) (DEBUG VERSION ONLY) |

    This DWORD parameter allows you to control how much debug information is
    displayed to the debug monitor.  This is a bit OR'd flag using the values
    defined in <t DBG_FLAGS>.  This value is not used by the released version
    of the driver.<nl>

*/

#ifndef _KEYWORDS_H
#define _KEYWORDS_H

#define PARAM_MAX_KEYWORD_LEN               128

/*
// These parameters names are predefined by NDIS - don't change them.
*/
#define PARAM_BusNumber                     "BusNumber"
#define PARAM_BusType                       "BusType"
#define PARAM_MediaType                     "MediaType"

/*
// These parameters are placed in the registry during installation.
*/
#define PARAM_AddressList                   "AddressList"
#define PARAM_DeviceName                    "DeviceName"
#define PARAM_NumDChannels                  "IsdnNumDChannels"
#define PARAM_NumBChannels                  "IsdnNumBChannels"

/*
// These parameters are not placed in the registry by default, but they
// will be used if present.
*/
#define PARAM_BufferSize                    "BufferSize"
#define PARAM_ReceiveBuffersPerLink         "ReceiveBuffersPerLink"
#define PARAM_TransmitBuffersPerLink        "TransmitBuffersPerLink"
#define PARAM_NoAnswerTimeOut               "NoAnswerTimeOut"
#define PARAM_NoAcceptTimeOut               "NoAcceptTimeOut"
#define PARAM_RunningWin95                  "RunningWin95"
#define PARAM_DebugFlags                    "DebugFlags"

#define PARAM_TODO                          "TODO"
// Add your keywords here.

// Port based parameters
#define PARAM_PORT_PREFIX                   "Line" // Line0 .. Line9
#define PARAM_SwitchType                    "IsdnSwitchType"

#endif // _KEYWORDS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\miniport.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Miniport Miniport_h

@module Miniport.h |

    This module defines the interface to the <t MINIPORT_DRIVER_OBJECT_TYPE>.

@comm

    This module defines the software structures and values used to support
    the NDIS WAN/TAPI Minport.  It's a good place to look when your trying
    to figure out how the driver structures are related to each other.

    Include this file at the top of each module in the Miniport.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Miniport_h

@end

*/

#ifndef _MPDMAIN_H
#define _MPDMAIN_H

#define MINIPORT_DRIVER_OBJECT_TYPE     ((ULONG)'D')+\
                                        ((ULONG)'R'<<8)+\
                                        ((ULONG)'V'<<16)+\
                                        ((ULONG)'R'<<24)

#define INTERRUPT_OBJECT_TYPE           ((ULONG)'I')+\
                                        ((ULONG)'N'<<8)+\
                                        ((ULONG)'T'<<16)+\
                                        ((ULONG)'R'<<24)

#define RECEIVE_OBJECT_TYPE             ((ULONG)'R')+\
                                        ((ULONG)'E'<<8)+\
                                        ((ULONG)'C'<<16)+\
                                        ((ULONG)'V'<<24)

#define TRANSMIT_OBJECT_TYPE            ((ULONG)'T')+\
                                        ((ULONG)'R'<<8)+\
                                        ((ULONG)'A'<<16)+\
                                        ((ULONG)'N'<<24)

#define REQUEST_OBJECT_TYPE             ((ULONG)'R')+\
                                        ((ULONG)'Q'<<8)+\
                                        ((ULONG)'S'<<16)+\
                                        ((ULONG)'T'<<24)

/*
// NDIS_MINIPORT_DRIVER and BINARY_COMPATIBLE must be defined before the
// NDIS include files.  Normally, it is defined on the command line by
// setting the C_DEFINES variable in the SOURCES build file.
*/
#include <ndis.h>
#include <ndiswan.h>
#include <ndistapi.h>
#include "vTarget.h"
#include "TpiDebug.h"

// Figure out which DDK we're building with.
#if defined(NDIS_LCODE)
#  if defined(NDIS_DOS)
#    define USING_WFW_DDK
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#  elif defined(OID_WAN_GET_INFO)
#    define USING_WIN98_DDK
#  elif defined(NDIS_WIN)
#    define USING_WIN95_DDK
#  else
#    error "BUILDING WITH UNKNOWN 9X DDK"
#  endif
#elif defined(NDIS_NT)
#  if defined(OID_GEN_MACHINE_NAME)
#    define USING_NT51_DDK
#  elif defined(OID_GEN_SUPPORTED_GUIDS)
#    define USING_NT50_DDK
#  elif defined(OID_GEN_MEDIA_CONNECT_STATUS)
#    define USING_NT40_DDK
#  elif defined(OID_WAN_GET_INFO)
#    define USING_NT351_DDK
#  else
#    define USING_NT31_DDK
#  endif
#else
#  error "BUILDING WITH UNKNOWN DDK"
#endif

// Figure out which DDK we should be building with.
#if defined(NDIS51) || defined(NDIS51_MINIPORT)
#  if defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x05
#    define NDIS_MINOR_VERSION          0x01
#  else
#    error "YOU MUST BUILD WITH THE NT 5.1 DDK"
#  endif
#elif defined(NDIS50) || defined(NDIS50_MINIPORT)
#  if defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x05
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 5.0 or 5.1 DDK"
#  endif
#elif defined(NDIS40) || defined(NDIS40_MINIPORT)
#  if defined(USING_NT40_DDK) || defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x04
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 4.0 or 5.0 DDK"
#  endif
#elif defined(NDIS_MINIPORT_DRIVER)
#  if defined(USING_NT351_DDK) || defined(USING_NT40_DDK) || defined(USING_NT50_DDK) || defined(USING_NT51_DDK)
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#  else
#    error "YOU MUST BUILD WITH THE NT 3.51, 4.0, or 5.0 DDK"
#  endif
#elif !defined(NDIS_MAJOR_VERSION) || !defined(NDIS_MINOR_VERSION)
//   Must be FULL MAC
#    define NDIS_MAJOR_VERSION          0x03
#    define NDIS_MINOR_VERSION          0x00
#endif

// Gotta nest NDIS_STRING_CONST or compiler/preprocessor won't be able to
// handle L##DEFINED_STRING.
#define INIT_STRING_CONST(name) NDIS_STRING_CONST(name)

typedef struct MINIPORT_ADAPTER_OBJECT  *PMINIPORT_ADAPTER_OBJECT;
typedef struct BCHANNEL_OBJECT          *PBCHANNEL_OBJECT;
typedef struct DCHANNEL_OBJECT          *PDCHANNEL_OBJECT;
typedef struct CARD_OBJECT              *PCARD_OBJECT;
typedef struct PORT_OBJECT              *PPORT_OBJECT;

/*
// The <t NDIS_MAC_LINE_UP> structure is confusing, so I redefine the
// field name to be what makes sense.
*/
#define MiniportLinkContext                 NdisLinkHandle

#if defined(_VXD_) && !defined(NDIS_LCODE)
#  define NDIS_LCODE code_seg("_LTEXT", "LCODE")
#  define NDIS_LDATA data_seg("_LDATA", "LCODE")
#endif

/*
// The link speeds we support.
*/
#define _64KBPS                     64000
#define _56KBPS                     56000

#define MICROSECONDS                (1)
#define MILLISECONDS                (1000*MICROSECONDS)
#define SECONDS                     (1000*MILLISECONDS)

/*
// Include everything here so the driver modules can just include this
// file and get all they need.
*/
#include "Keywords.h"
#include "Card.h"
#include "Adapter.h"
#include "BChannel.h"
#include "DChannel.h"
#include "Link.h"
#include "Port.h"
#include "Tspi.h"
#include "TpiParam.h"
#include "TpiMem.h"

/***************************************************************************
// These routines are defined in Miniport.c
*/

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath
    );

NDIS_STATUS MiniportInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PUINT                   SelectedMediumIndex,
    IN PNDIS_MEDIUM             MediumArray,
    IN UINT                     MediumArraySize,
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN NDIS_HANDLE              WrapperConfigurationContext
    );

void MiniportHalt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

NDIS_STATUS MiniportReset(
    OUT PBOOLEAN                AddressingReset,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

/***************************************************************************
// These routines are defined in interrup.c
*/
BOOLEAN MiniportCheckForHang(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportDisableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportEnableInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportHandleInterrupt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportISR(
    OUT PBOOLEAN                InterruptRecognized,
    OUT PBOOLEAN                QueueMiniportHandleInterrupt,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

void MiniportTimer(
    IN PVOID                    SystemSpecific1,
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN PVOID                    SystemSpecific2,
    IN PVOID                    SystemSpecific3
    );

/***************************************************************************
// These routines are defined in receive.c
*/
void ReceivePacketHandler(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PUCHAR                   ReceiveBuffer,
    IN ULONG                    BytesReceived
    );

/***************************************************************************
// These routines are defined in request.c
*/
NDIS_STATUS MiniportQueryInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_OID                 Oid,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  BytesWritten,
    OUT PULONG                  BytesNeeded
    );

NDIS_STATUS MiniportSetInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,
    IN NDIS_OID                 Oid,
    IN PVOID                    InformationBuffer,
    IN ULONG                    InformationBufferLength,
    OUT PULONG                  BytesRead,
    OUT PULONG                  BytesNeeded
    );

/***************************************************************************
// These routines are defined in send.c
*/
NDIS_STATUS MiniportWanSend(
    IN NDIS_HANDLE              MacBindingHandle,
    IN PBCHANNEL_OBJECT         pBChannel,
    IN PNDIS_WAN_PACKET         pWanPacket
    );

void TransmitCompleteHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter
    );

#endif // _MPDMAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\link.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Link Link_h

@module Link.h |

    This module defines the interface to the <t NDISLINK_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Link_h

@end

*/

#ifndef _LINK_H
#define _LINK_H

#define LINK_OBJECT_TYPE        ((ULONG)'L')+\
                                ((ULONG)'I'<<8)+\
                                ((ULONG)'N'<<16)+\
                                ((ULONG)'K'<<24)

/*


    Function prototypes.

*/

VOID LinkLineUp(
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID LinkLineDown(
    IN PBCHANNEL_OBJECT         pBChannel
    );

VOID LinkLineError(
    IN PBCHANNEL_OBJECT         pBChannel,
    IN ULONG                    Errors
    );

#endif // _LINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\link.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Link Link_c

@module Link.c |

    This module implements the NDIS_MAC_LINE_UP, NDIS_MAC_LINE_DOWN, and
    NDIS_MAC_FRAGMENT interfaces between the NDIS WAN Miniport and the
    NDIS WAN Wrapper.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Link_c

@end

*/

#define  __FILEID__             LINK_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Link Link_c NDIS_MAC_LINE_UP


@struct NDIS_MAC_LINE_UP |
        This structure is passed to <f NdisMIndicateStatus> with the
        <t NDIS_STATUS_WAN_LINE_UP> status message when <f LinkLineUp> is
        called by the Miniport.

@field IN ULONG | LinkSpeed |
        The speed of the link, in 100 bps units (bits per second).

@field IN NDIS_WAN_QUALITY | Quality |
        The quality of service indicator for this link.

@field IN USHORT | SendWindow |
        The recommended send window, i.e., the number of packets that should
        be given to the adapter before pausing to wait for an acknowledgement.
        Some devices achieve higher throughput if they have several packets
        to send at once; others are especially unreliable.  A value of zero
        indicates no recommendation.

@field IN NDIS_HANDLE | ConnectionWrapperID |
        The Miniport supplied handle by which this line will be known to the
        Connection Wrapper clients.  This must be a unique handle across all
        drivers using the Connection Wrapper, so typically <f htCall> should
        be used to gaurantee it is unique.  This must be the same value
        returned from the OID_TAPI_GETID request for the <p  "ndis">
        DeviceClass (See <f TspiGetID>).  Refer to the Connection Wrapper
        Interface Specification for further details.  If not using the
        Connection Wrapper, this value must be zero.

@field IN NDIS_HANDLE | MiniportLinkContext |
        The Miniport supplied handle passed down in future Miniport calls
        (such as <f MiniportWanSend> for this link.  Typically, the Miniport
        will provide a pointer to its control block for that link.  The value
        must be unique, for the first LINE_UP indication on a particular
        link.  Subsequent LINE_UP indications may be called if line
        characteristics change.  When subsequent LINE_UP indication calls are
        made, the <p  MiniportLinkContext> must be filled with the value
        returned on the first LINE_UP indication call.

@field IN NDIS_HANDLE | NdisLinkContext |
        The WAN wrapper supplied handle to be used in future Miniport calls
        (such as <f NdisMWanIndicateReceive>) to the WAN Wrapper. The WAN
        Wrapper will provide a unique handle for every LINE_UP indication.
        The <p NdisLinkContext> must be zero if this is the first LINE_UP
        indication.  It must contain the value returned on the first LINE_UP
        indication for subsequent LINE_UP indication calls.

*/


/* @doc INTERNAL Link Link_c LinkLineUp


@func

    <f LinkLineUp> marks a link as connected and sends a LINE_UP indication
    to the WAN wrapper.

    A line up indication is generated when a new link becomes active. Prior
    to this the MAC will accept frames and may let them succeed or fail, but
    it is unlikely that they will actually be received by any remote. During
    this state protocols are encouraged to reduce their timers and retry
    counts so as to quickly fail any outgoing connection attempts.

    <f Note>: This indication must be sent to the WAN wrapper prior to returning
    from the OID_TAPI_ANSWER request, and prior to indicating the
    LINECALLSTATE_CONNECTED to the Connection Wrapper.  Otherwise, the
    Connection Wrapper client might attempt to send data to the WAN wrapper
    before it is aware of the line.

@comm

    The status code for the line up indication is <t NDIS_STATUS_WAN_LINE_UP>
    and is passed to <f NdisMIndicateStatus>.  The format of the StatusBuffer
    for this code is defined by <t NDIS_MAC_LINE_UP>.

*/

VOID LinkLineUp(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("LinkLineUp")

    NDIS_MAC_LINE_UP            LineUpInfo;
    // Line up structure passed to NdisMIndicateStatus.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    /*
    // We can't bring up a NULL link.
    */
    if (pBChannel->IsOpen && pBChannel->NdisLinkContext == NULL)
    {
        DBG_ENTER(pAdapter);
        ASSERT(pBChannel->htCall);

        /*
        // Initialize the LINE_UP event packet.
        */
        LineUpInfo.LinkSpeed           = pBChannel->LinkSpeed / 100;
        LineUpInfo.Quality             = NdisWanErrorControl;
        LineUpInfo.SendWindow          = (USHORT)pAdapter->WanInfo.MaxTransmit;
        LineUpInfo.ConnectionWrapperID = (NDIS_HANDLE) pBChannel->htCall;
        LineUpInfo.MiniportLinkContext = pBChannel;
        LineUpInfo.NdisLinkContext     = pBChannel->NdisLinkContext;

        /*
        // Indicate the event to the WAN wrapper.
        */
        NdisMIndicateStatus(pAdapter->MiniportAdapterHandle,
                            NDIS_STATUS_WAN_LINE_UP,
                            &LineUpInfo,
                            sizeof(LineUpInfo)
                            );
        pAdapter->NeedStatusCompleteIndication = TRUE;
        /*
        // Save the WAN wrapper link context for use when indicating received
        // packets and errors.
        */
        pBChannel->NdisLinkContext = LineUpInfo.NdisLinkContext;

        DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                  ("#%d Call=0x%X CallState=0x%X NdisLinkContext=0x%X MiniportLinkContext=0x%X\n",
                   pBChannel->BChannelIndex,
                   pBChannel->htCall, pBChannel->CallState,
                   pBChannel->NdisLinkContext,
                   pBChannel
                  ));

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Link Link_c NDIS_MAC_LINE_DOWN


@struct NDIS_MAC_LINE_DOWN |
        This structure is passed to <f NdisMIndicateStatus> with the
        <t NDIS_STATUS_WAN_LINE_DOWN> status message when <f LinkLineDown>
        is called by the Miniport.

@field IN NDIS_HANDLE | NdisLinkContext |
        The value returned in the <t NDIS_MAC_LINE_UP> structure during a
        previous call to <f LinkLineUp>.

*/


/* @doc INTERNAL Link Link_c LinkLineDown


@func

    <f LinkLineDown> marks a link as disconnected and sends a LINE_DOWN
    indication to the WAN wrapper.

    A line down indication is generated when a link goes down. Protocols
    should again reduce their timers and retry counts until the next line
    up indication.

@comm

    The status code for the line down indication is <t NDIS_STATUS_WAN_LINE_DOWN>
    and is passed to <f NdisMIndicateStatus>. The format of the StatusBuffer
    for this code is defined by <t NDIS_MAC_LINE_DOWN>.

*/

VOID LinkLineDown(
    IN PBCHANNEL_OBJECT         pBChannel                   // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.
    )
{
    DBG_FUNC("LinkLineDown")

    NDIS_MAC_LINE_DOWN          LineDownInfo;
    // Line down structure passed to NdisMIndicateStatus.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    /*
    // We can't allow indications to NULL...
    */
    if (pBChannel->NdisLinkContext)
    {
        DBG_ENTER(pAdapter);

        DBG_FILTER(pAdapter,DBG_TAPICALL_ON,
                  ("#%d Call=0x%X CallState=0x%X NdisLinkContext=0x%X MiniportLinkContext=0x%X\n",
                   pBChannel->BChannelIndex,
                   pBChannel->htCall, pBChannel->CallState,
                   pBChannel->NdisLinkContext,
                   pBChannel
                  ));

        /*
        // Setup the LINE_DOWN event packet and indicate the event to the
        // WAN wrapper.
        */
        LineDownInfo.NdisLinkContext = pBChannel->NdisLinkContext;

        NdisMIndicateStatus(pAdapter->MiniportAdapterHandle,
                            NDIS_STATUS_WAN_LINE_DOWN,
                            &LineDownInfo,
                            sizeof(LineDownInfo)
                            );
        pAdapter->NeedStatusCompleteIndication = TRUE;
        /*
        // The line is down, so there's no more context for receives.
        */
        pBChannel->NdisLinkContext = NULL;
        pBChannel->CallClosing     = FALSE;

        DBG_LEAVE(pAdapter);
    }
}


/* @doc INTERNAL Link Link_c NDIS_MAC_FRAGMENT


@struct NDIS_MAC_FRAGMENT |
        This structure is passed to <f NdisMIndicateStatus> with the
        <t NDIS_STATUS_WAN_FRAGMENT> status message when <f LinkLineError>
        is called by the Miniport.

@field IN NDIS_HANDLE | NdisLinkContext |
        The value returned in the <t NDIS_MAC_LINE_UP> structure during a
        previous call to <f LinkLineUp>.

@field IN ULONG | Errors |
     Is a bit OR'd mask of the following values:
     WAN_ERROR_CRC,
     WAN_ERROR_FRAMING,
     WAN_ERROR_HARDWAREOVERRUN,
     WAN_ERROR_BUFFEROVERRUN,
     WAN_ERROR_TIMEOUT,
     WAN_ERROR_ALIGNMENT

*/


/* @doc INTERNAL Link Link_c LinkLineError


@func

    <f LinkLineError> is used to indicate to the WAN wrapper that a partial
    packet was received from the remote end.  The <t NDIS_STATUS_WAN_FRAGMENT>
    indication is used to notify WAN wrapper.

    A fragment indication indicates that a partial packet was received from
    the remote. The protocol is encouraged to send frames to the remote that
    will notify it of this situation, rather than waiting for a timeout to
    occur.

    <f Note>: The WAN wrapper keeps track of dropped packets by counting the
    number of fragment indications on the link.

@comm

    The status code for the fragment indication is <t NDIS_STATUS_WAN_FRAGMENT>
    and is passed to <f NdisMIndicateStatus>.  The format of the StatusBuffer
    for this code is defined by <t NDIS_MAC_LINE_DOWN>.

*/

void LinkLineError(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN ULONG                    Errors                      // @parm
    // A bit field set to one or more bits indicating the reason the fragment
    // was received.  If no direct mapping from the WAN medium error to one
    // of the six errors listed below exists, choose the most apropriate
    // error.
    )
{
    DBG_FUNC("LinkLineError")

    NDIS_MAC_FRAGMENT           FragmentInfo;
    // Error information structure passed to NdisMIndicateStatus.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT>.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    /*
    // NOTE - Don't report any errors until we receive at least one
    // good packet.  Connecting to a Digi NT system, we get a burst
    // of bad packets while Digi tries some odd framing.  After a
    // couple seconds, Digi syncs up and things work okay.
    */
    if (pBChannel->TotalRxPackets == 0)
    {
        return;
    }

    /*
    // We can't allow indications to NULL...
    */
    if (pBChannel->NdisLinkContext)
    {
        DBG_ENTER(pAdapter);

        DBG_WARNING(pAdapter,
                  ("#%d Call=0x%X CallState=0x%X NdisLinkContext=0x%X Errors=0x%X NumRxPkts=%d\n",
                   pBChannel->BChannelIndex,
                   pBChannel->htCall, pBChannel->CallState,
                   pBChannel->NdisLinkContext,
                   Errors, pBChannel->TotalRxPackets
                  ));

        /*
        // Setup the FRAGMENT event packet and indicate it to the WAN wrapper.
        */
        FragmentInfo.NdisLinkContext = pBChannel->NdisLinkContext;
        FragmentInfo.Errors = Errors;
        NdisMIndicateStatus(pAdapter->MiniportAdapterHandle,
                            NDIS_STATUS_WAN_FRAGMENT,
                            &FragmentInfo,
                            sizeof(FragmentInfo)
                            );
        pAdapter->NeedStatusCompleteIndication = TRUE;
        DBG_LEAVE(pAdapter);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\port.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Port Port_h

@module Port.h |

    This module defines the interface to the <t PORT_OBJECT>.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Port_h

@end

*/

#ifndef _PORT_H
#define _PORT_H

#define PORT_OBJECT_TYPE        ((ULONG)'P')+\
                                ((ULONG)'O'<<8)+\
                                ((ULONG)'R'<<16)+\
                                ((ULONG)'T'<<24)

#define MAX_PORTS               10
// The most I've ever seen is 4 - If you have more than 10, the code will
// have to change to handle more than a single digit "PortX" parameter.

/* @doc INTERNAL Port Port_h PORT_OBJECT


@struct PORT_OBJECT |

    This structure contains the data associated with an ISDN port.  Here,
    a port is defined as a single BRI, PRI, T-1, or E-1 physical interface.

*/

typedef struct PORT_OBJECT
{
    ULONG                       ObjectType;                 // @field
    // Four characters used to identify this type of object 'PORT'.

    ULONG                       ObjectID;                   // @field
    // Instance number used to identify a specific object instance.

    PCARD_OBJECT                pCard;                      // @field
    // Pointer to the <t CARD_OBJECT> owning this port.

    BOOLEAN                     IsOpen;                     // @field
    // Set TRUE if this BChannel is open, otherwise set FALSE.

    ULONG                       NumChannels;                // @field
    // Number of communications channels configured on this port.

    ULONG                       PortIndex;                  // @field
    // Port Index (0 .. MAX_PORTS-1).

    ULONG                       SwitchType;                 // @field
    // ISDN switch type.

    ULONG                       TODO;                       // @field
    // Add your data members here.

} PORT_OBJECT, *PPORT_OBJECT;

#define GET_ADAPTER_FROM_PORT(pPort)            (pPort->pCard->pAdapter)


/*


    Function prototypes.

*/

NDIS_STATUS PortCreate(
    OUT PPORT_OBJECT *          ppPort,
    IN PCARD_OBJECT             pCard
    );

void PortInitialize(
    PPORT_OBJECT                pPort
    );

void PortDestroy(
    PPORT_OBJECT                pPort
    );

#endif // _PORT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tpimem.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiMem TpiMem_h

@module TpiMem.h |

    This module defines the interface to the memory allocation wrappers.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiMem_h

@end

*/

#ifndef _TPIMEM_H
#define _TPIMEM_H

#include <ndis.h>

#define TPIMEMORY_OBJECT_TYPE           ((ULONG)'T')+\
                                        ((ULONG)'M'<<8)+\
                                        ((ULONG)'E'<<16)+\
                                        ((ULONG)'M'<<24)

#define ALLOCATE_MEMORY(pObject, dwSize, MiniportAdapterHandle)\
            TpiAllocateMemory((PVOID *)&(pObject), dwSize,\
                              __FILEID__, __FILE__, __LINE__,\
                              MiniportAdapterHandle)

#define FREE_MEMORY(pObject, dwSize)\
            TpiFreeMemory((PVOID *)&(pObject), dwSize,\
                          __FILEID__, __FILE__, __LINE__)

#define ALLOCATE_OBJECT(pObject, MiniportAdapterHandle)\
            ALLOCATE_MEMORY(pObject, sizeof(*(pObject)), MiniportAdapterHandle)

#define FREE_OBJECT(pObject)\
            FREE_MEMORY(pObject, sizeof(*(pObject)))

#define FREE_NDISSTRING(ndisString)\
            FREE_MEMORY(ndisString.Buffer, ndisString.MaximumLength)

NDIS_STATUS TpiAllocateMemory(
    OUT PVOID *                 ppObject,
    IN ULONG                    dwSize,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber,
    IN NDIS_HANDLE              MiniportAdapterHandle
    );

void TpiFreeMemory(
    IN OUT PVOID *              ppObject,
    IN ULONG                    dwSize,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

NDIS_STATUS TpiAllocateSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN ULONG                    dwSize,
    IN BOOLEAN                  bCached,
    OUT PVOID *                 pVirtualAddress,
    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

void TpiFreeSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,
    IN ULONG                    dwSize,
    IN BOOLEAN                  bCached,
    OUT PVOID *                 pVirtualAddress,
    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,
    IN ULONG                    dwFileID,
    IN LPSTR                    szFileName,
    IN ULONG                    dwLineNumber
    );

extern NDIS_PHYSICAL_ADDRESS g_HighestAcceptableAddress;

#endif // _TPIMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\request.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Request Request_c

@module Request.c |

    This module implements the NDIS request routines for the Miniport.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Request_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.2 Query/Set Request Processing |

    For querying and setting network interface card binding information, the
    NDIS library calls <f MiniportQueryInformation> or <f MiniportSetInformation>.
    The upper layers place an object identifier (OID) in the structure for
    an object in the miniport NIC driver MIB that it wants to query or set.
    The <f MiniportQueryInformation> function fills in results and returns an
    appropriate status code to the NDIS library. See Part I of the Network
    Driver Reference for more information on OIDs.

    These two functions are potentially asynchronous. If they behave
    synchronously, they return immediately with a status code other than
    NDIS_STATUS_PENDING. If asynchronous, the function returns
    NDIS_STATUS_PENDING; and the miniport NIC driver later completes the
    request operation by a call to NdisMQueryInformationComplete for the
    query function or NdisMSetInformationComplete for the set function.

    The NDIS library guarantees that the miniport NIC driver will have only
    one outstanding request at a time so there is no need for the miniport
    NIC driver to queue requests.

@end
*/

#define  __FILEID__             REQUEST_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif

/*
// The following is a list of all the possible NDIS QuereyInformation requests
// that might be directed to the miniport.
// Comment out any that are not supported by this driver.
*/
static const NDIS_OID g_SupportedOidArray[] =
{
    OID_GEN_SUPPORTED_LIST,
    OID_GEN_HARDWARE_STATUS,
    OID_GEN_MEDIA_SUPPORTED,
    OID_GEN_MEDIA_IN_USE,
    OID_GEN_MAXIMUM_LOOKAHEAD,
    OID_GEN_MAC_OPTIONS,
    OID_GEN_VENDOR_ID,
    OID_GEN_VENDOR_DESCRIPTION,
    OID_GEN_DRIVER_VERSION,
    OID_GEN_CURRENT_LOOKAHEAD,

    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_MEDIUM_SUBTYPE,

    OID_WAN_GET_INFO,
    OID_WAN_SET_LINK_INFO,
    OID_WAN_GET_LINK_INFO,

#if defined(NDIS50_MINIPORT)
    OID_WAN_LINE_COUNT,

    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,
#endif // NDIS50_MINIPORT

    0
};

#if DBG

/*
// Make sure the following list is in the same order as the list above!
*/
static char *g_SupportedOidNames[] =
{
    "OID_GEN_SUPPORTED_LIST",
    "OID_GEN_HARDWARE_STATUS",
    "OID_GEN_MEDIA_SUPPORTED",
    "OID_GEN_MEDIA_IN_USE",
    "OID_GEN_MAXIMUM_LOOKAHEAD",
    "OID_GEN_MAC_OPTIONS",
    "OID_GEN_VENDOR_ID",
    "OID_GEN_VENDOR_DESCRIPTION",
    "OID_GEN_DRIVER_VERSION",
    "OID_GEN_CURRENT_LOOKAHEAD",

    "OID_WAN_PERMANENT_ADDRESS",
    "OID_WAN_CURRENT_ADDRESS",
    "OID_WAN_MEDIUM_SUBTYPE",

    "OID_WAN_GET_INFO",
    "OID_WAN_SET_LINK_INFO",
    "OID_WAN_GET_LINK_INFO",

#if defined(NDIS50_MINIPORT)
    "OID_WAN_LINE_COUNT",

    "OID_PNP_CAPABILITIES",
    "OID_PNP_SET_POWER",
    "OID_PNP_QUERY_POWER",
#endif // NDIS50_MINIPORT

    "OID_UNKNOWN"
};

#define NUM_OID_ENTRIES (sizeof(g_SupportedOidArray) / sizeof(g_SupportedOidArray[0]))

/*
// This debug routine will lookup the printable name for the selected OID.
*/
static char * DbgGetOidString(NDIS_OID Oid)
{
    UINT i;

    for (i = 0; i < NUM_OID_ENTRIES-1; i++)
    {
        if (g_SupportedOidArray[i] == Oid)
        {
            break;
        }
    }
    return(g_SupportedOidNames[i]);
}

#endif // DBG

/*
// Returned from an OID_WAN_PERMANENT_ADDRESS MiniportQueryInformation request.
// The WAN wrapper wants the miniport to return a unique address for this
// adapter.  This is used as an ethernet address presented to the protocols.
// The least significant bit of the first byte must not be a 1, or it could
// be interpreted as an ethernet multicast address.  If the vendor has an
// assigned ethernet vendor code (the first 3 bytes), they should be used
// to assure that the address does not conflict with another vendor's address.
// The last digit is replaced during the call with the adapter instance number.
*/
static UCHAR        g_PermanentWanAddress[6] = VER_VENDOR_ID;

/*
// Returned from an OID_GEN_VENDOR_ID MiniportQueryInformation request.
// Again, the vendor's assigned ethernet vendor code should be used if possible.
*/
static UCHAR        g_Vendor3ByteID[4] = VER_VENDOR_ID;

/*
// Returned from an OID_GEN_VENDOR_DESCRIPTION MiniportQueryInformation request.
// This is an arbitrary string which may be used by upper layers to present
// a user friendly description of the adapter.
*/
static NDIS_STRING  g_VendorDescriptionString = INIT_STRING_CONST(VER_PRODUCT_NAME_STR);


/* @doc INTERNAL Request Request_c MiniportQueryInformation


@func

    <f MiniportQueryInformation> is a required function that
    returns information about the capabilities and status of
    the driver and/or its NIC.

@comm

    NDIS calls the <f MiniportQueryInformation> function either
    on its own behalf, such as to determine which options the
    driver supports or to manage binding-specific information
    for the miniport, or when a bound protocol driver calls
    <f NdisRequest>.

    NDIS makes one or more calls to <f MiniportQueryInformation>
    just after a driver's <f MiniportInitialize> function returns
    NDIS_STATUS_SUCCESS. NDIS supplies the following OIDs in
    its initialization-time calls to the driver's
    <f MiniportQueryInformation> function:

    <f OID_GEN_MAXIMUM_LOOKAHEAD><nl>
        <f MiniportQueryInformation> must return how many bytes of lookahead
        data the NIC can provide, that is, the initial transfer capacity
        of the NIC.<nl>
        Even if a driver supports multipacket receives and, therefore,
        will indicate an array of pointers to fully set up packets,
        MiniportQueryInformation must supply this information. Such a
        driver should return the maximum packet size it can indicate.

    <f OID_GEN_MAC_OPTIONS><nl>
        <f MiniportQueryInformation> must return a bitmask set with the
        appropriate NDIS_MAC_OPTION_XXX flags indicating which options
        it (or its NIC) supports, or it can return zero at InformationBuffer
        if the driver supports none of the options designated by these flags.
        For example, a NIC driver always sets the
        NDIS_MAC_OPTION_NO_LOOPBACK flag if its NIC has no
        internal hardware support for loopback. This tells
        NDIS to manage loopback for the driver, which cannot
        provide software loopback code as efficient as the NDIS
        library's because NDIS manages all binding-specific
        information for miniports. Any miniport that tries to provide
        software loopback must check the destination address of every
        send packet against the currently set filter addresses to
        determine whether to loop back each packet. WAN NIC drivers
        must set this flag.

    If the NIC driver sets the NDIS_MAC_OPTION_FULL_DUPLEX flag,
    the NDIS library serializes calls to the MiniportSendPackets
    or <f MiniportWanSend> function separately from its serialized
    calls to other MiniportXxx functions in SMP machines. However,
    NDIS returns incoming send packets to protocols while such a
    driver's <f MiniportReset> function is executing: that is, NDIS
    never calls a full-duplex miniport to transmit a packet until
    its reset operation is completed. The designer of any full-duplex
    driver can expect that driver to achieve significantly higher
    performance in SMP machines, but the driver must synchronize
    its accesses to shared resources carefully to prevent race
    conditions or deadlocks from occurring. NDIS assumes that
    all intermediate drivers are full-duplex drivers.

    Depending on the NdisMediumXxx that <f MiniportInitialize> selected,
    NDIS submits additional intialization-time requests to
    <f MiniportQueryInformation>, such as the following:

    <f OID_XXX_CURRENT_ADDRESS><nl>
        If the driver's <f MiniportInitialize> function selected an NdisMediumXxx
        for which the system supplies a filter, NDIS calls
        <f MiniportQueryInformation> to return the NIC's current
        address in medium-specific format. For FDDI drivers, NDIS
        requests both long and short current addresses.

    <f OID_802_3_MAXIMUM_LIST_SIZE><nl>
        For Ethernet drivers, NDIS requests the multicast list size.

    <f OID_FDDI_LONG>/<f SHORT_MAX_LIST_SIZE><nl>
        For FDDI drivers, NDIS requests the multicast list sizes.

    If possible, <f MiniportQueryInformation> should not return
    <f NDIS_STATUS_PENDING> for initialization-time requests.
    Until NDIS has sufficient information to set up bindings
    to the miniport, such requests should be handled synchronously.

    If the Miniport does not complete the call immediately (by returning
    <f NDIS_STATUS_PENDING>), it must call NdisMQueryInformationComplete to
    complete the call.  The Miniport controls the buffers pointed to by
    InformationBuffer, BytesWritten, and BytesNeeded until the request
    completes.

    No other requests will be submitted to the Miniport until
    this request has been completed.

    <f Note>: that the wrapper will intercept all queries of the following OIDs:
        OID_GEN_CURRENT_PACKET_FILTER,
        OID_GEN_PROTOCOL_OPTIONS,
        OID_802_5_CURRENT_FUNCTIONAL,
        OID_802_3_MULTICAST_LIST,
        OID_FDDI_LONG_MULTICAST_LIST,
        OID_FDDI_SHORT_MULTICAST_LIST.

    <f Note>: Interrupts will be in any state when called.

@rdesc

    <f MiniportQueryInformation> can return one of the following:

    @flag NDIS_STATUS_SUCCESS |
        <f MiniportQueryInformation> returned the requested information at
        InformationBuffer and set the variable at BytesWritten to the amount
        of information it returned.

    @flag NDIS_STATUS_PENDING |
        The driver will complete the request asynchronously with a call to
        NdisMQueryInformationComplete when it has gathered the requested
        information.

    @flag NDIS_STATUS_INVALID_OID |
        <f MiniportQueryInformation> does not recognize the Oid.

    @flag NDIS_STATUS_INVALID_LENGTH |
        The InformationBufferLength does not match the length required
        by the given Oid. <f MiniportQueryInformation> returned how many
        bytes the buffer should be at BytesNeeded.

    @flag NDIS_STATUS_NOT_ACCEPTED |
        <f MiniportQueryInformation> attempted to gather the requested
        information from the NIC but was unsuccessful.

    @flag NDIS_STATUS_NOT_SUPPORTED |
        <f MiniportQueryInformation> does not support the Oid, which
        is optional.

    @flag NDIS_STATUS_RESOURCES |
        <f MiniportQueryInformation> could not allocate sufficient
        resources to return the requested information. This return
        value does not necessarily mean that the same request,
        submitted at a later time, will be failed for the same
        reason.

@xref

    <f MiniportInitialize>
    <f MiniportSetInformation>


*/

NDIS_STATUS MiniportQueryInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN NDIS_OID                 Oid,                        // @parm
    // The OID.  (See section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs.)

    IN PVOID                    InformationBuffer,          // @parm
    // The buffer that will receive the information. (See section 7.4 of the
    // NDIS 3.0 specification for a description of the length required for
    // each OID.)

    IN ULONG                    InformationBufferLength,    // @parm
    // The length in bytes of InformationBuffer.

    OUT PULONG                  BytesWritten,               // @parm
    // Returns the number of bytes written into InformationBuffer.

    OUT PULONG                  BytesNeeded                 // @parm
    // Returns the number of additional bytes needed to satisfy the OID.
    )
{
    DBG_FUNC("MiniportQueryInformation")

    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    // Holds the status result returned by this function.

    PVOID                       SourceBuffer;
    // Pointer to driver data to be copied back to caller's InformationBuffer

    ULONG                       SourceBufferLength;
    // Number of bytes to be copied from driver.

    ULONG                       GenericULong = 0;
    // Most return values are long integers, so this is used to hold the
    // return value of a constant or computed result.

    UCHAR                       VendorId[4];
    // Used to store vendor ID string.

#if defined(NDIS50_MINIPORT)
    NDIS_PNP_CAPABILITIES       PnpCapabilities;
    // Used to return our PNP capabilities.
#endif // NDIS50_MINIPORT

    /*
    // If this is a TAPI OID, pass it on over.
    */
    if ((Oid & 0xFFFFFF00L) == (OID_TAPI_ACCEPT & 0xFFFFFF00L))
    {
        Status = TspiRequestHandler(pAdapter,
                        Oid,
                        InformationBuffer,
                        InformationBufferLength,
                        BytesWritten,
                        BytesNeeded
                        );
        return (Status);
    }

    DBG_ENTER(pAdapter);
    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X\n",
               Oid, DbgGetOidString(Oid),
               InformationBufferLength,
               InformationBuffer
              ));

    /*
    // Initialize these once, since this is the majority of cases.
    */
    SourceBuffer = &GenericULong;
    SourceBufferLength = sizeof(ULONG);

    /*
    // Determine which OID is being requested and do the right thing.
    // Refer to section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs and their return values.
    */
    switch (Oid)
    {
    case OID_GEN_SUPPORTED_LIST:
        /*
        // NDIS wants to know which OID's to pass down to us.
        // So we report back these new IOCTL's in addition to any NDIS OID's.
        */
        SourceBuffer =  (PVOID)g_SupportedOidArray;
        SourceBufferLength = sizeof(g_SupportedOidArray);
        break;

    case OID_GEN_HARDWARE_STATUS:
        GenericULong = NdisHardwareStatusReady;
        break;

    case OID_GEN_MEDIA_SUPPORTED:
        GenericULong = NdisMediumWan;
        break;

    case OID_GEN_MEDIA_IN_USE:
        GenericULong = NdisMediumWan;
        break;

    case OID_GEN_VENDOR_ID:
        NdisMoveMemory((PVOID)VendorId, (PVOID)g_PermanentWanAddress, 3);
        VendorId[3] = 0x0;
        SourceBuffer = &g_PermanentWanAddress[0];
        SourceBufferLength = sizeof(VendorId);
        break;

    case OID_GEN_VENDOR_DESCRIPTION:
        SourceBuffer = (PUCHAR) g_VendorDescriptionString.Buffer;
        SourceBufferLength = g_VendorDescriptionString.MaximumLength;
        break;

    case OID_GEN_MAXIMUM_LOOKAHEAD:
        GenericULong = CARD_MAX_LOOKAHEAD;
        break;

    case OID_GEN_CURRENT_LOOKAHEAD:
        GenericULong = CARD_MAX_LOOKAHEAD;
        break;

    case OID_GEN_MAC_OPTIONS:
        GenericULong = NDIS_MAC_OPTION_RECEIVE_SERIALIZED |
                       NDIS_MAC_OPTION_NO_LOOPBACK |
                       NDIS_MAC_OPTION_TRANSFERS_NOT_PEND;
        break;

    case OID_WAN_PERMANENT_ADDRESS:
    case OID_WAN_CURRENT_ADDRESS:
        g_PermanentWanAddress[5] = (UCHAR) ((pAdapter->ObjectID & 0xFF) + '0');
        SourceBuffer = g_PermanentWanAddress;
        SourceBufferLength = sizeof(g_PermanentWanAddress);
        break;

    case OID_WAN_MEDIUM_SUBTYPE:
        GenericULong = NdisWanMediumIsdn;
        break;

    case OID_WAN_GET_INFO:
        SourceBuffer = &pAdapter->WanInfo;
        SourceBufferLength = sizeof(NDIS_WAN_INFO);
        break;

    case OID_WAN_GET_LINK_INFO:
        {
            PNDIS_WAN_GET_LINK_INFO pGetWanLinkInfo;

            PBCHANNEL_OBJECT        pBChannel;
            // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

            /*
            // The InformationBuffer really points to a NDIS_WAN_GET_LINK_INFO
            // which contains a pointer to one of our BCHANNEL_OBJECT's in the
            // NdisLinkHandle field.
            */
            pGetWanLinkInfo = (PNDIS_WAN_GET_LINK_INFO)InformationBuffer;
            pBChannel = (PBCHANNEL_OBJECT) pGetWanLinkInfo->NdisLinkHandle;

            /*
            // Make sure what I just said is true.
            */
            if (!IS_VALID_BCHANNEL(pAdapter, pBChannel))
            {
                SourceBufferLength = 0;
                Status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            DBG_PARAMS(pAdapter,
                        ("Returning:\n"
                        "NdisLinkHandle   = %08lX\n"
                        "MaxSendFrameSize = %08lX\n"
                        "MaxRecvFrameSize = %08lX\n"
                        "SendFramingBits  = %08lX\n"
                        "RecvFramingBits  = %08lX\n"
                        "SendACCM         = %08lX\n"
                        "RecvACCM         = %08lX\n",
                        pBChannel->WanLinkInfo.NdisLinkHandle,
                        pBChannel->WanLinkInfo.MaxSendFrameSize ,
                        pBChannel->WanLinkInfo.MaxRecvFrameSize ,
                        pBChannel->WanLinkInfo.SendFramingBits  ,
                        pBChannel->WanLinkInfo.RecvFramingBits  ,
                        pBChannel->WanLinkInfo.SendACCM         ,
                        pBChannel->WanLinkInfo.RecvACCM         ));

            SourceBuffer = &(pBChannel->WanLinkInfo);
            SourceBufferLength = sizeof(NDIS_WAN_GET_LINK_INFO);
        }
        break;

#if defined(NDIS50_MINIPORT)
    case OID_WAN_LINE_COUNT:
        GenericULong = pAdapter->NumBChannels;
        break;

    case OID_PNP_CAPABILITIES:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        PnpCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp =
                                               NdisDeviceStateUnspecified;
        PnpCapabilities.WakeUpCapabilities.MinPatternWakeUp =
                                               NdisDeviceStateUnspecified;
        PnpCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp =
                                                NdisDeviceStateUnspecified;
        SourceBuffer = &PnpCapabilities;
        SourceBufferLength = sizeof(PnpCapabilities);
        break;

    case OID_PNP_QUERY_POWER:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        break;
#endif // NDIS50_MINIPORT

    default:
        /*
        // Unknown OID
        */
        Status = NDIS_STATUS_INVALID_OID;
        SourceBufferLength = 0;
        DBG_WARNING(pAdapter,("UNSUPPORTED Oid=0x%08x\n", Oid));
        break;
    }

    /*
    // Now we copy the data into the caller's buffer if there's enough room,
    // otherwise, we report the error and tell em how much we need.
    */
    if (SourceBufferLength > InformationBufferLength)
    {
        *BytesNeeded = SourceBufferLength;
        *BytesWritten = 0;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else if (SourceBufferLength)
    {
        NdisMoveMemory(InformationBuffer,
                       SourceBuffer,
                       SourceBufferLength
                      );
        *BytesNeeded = *BytesWritten = SourceBufferLength;
    }
    else
    {
        *BytesNeeded = *BytesWritten = 0;
    }
    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Written=%d\n",
               Status, *BytesNeeded, *BytesWritten));

    DBG_RETURN(pAdapter, Status);
    return (Status);
}


/* @doc INTERNAL Request Request_c MiniportSetInformation


@func

    <f MiniportSetInformation> is a required function that allows
    bound protocol drivers (or NDIS) to request changes in the
    state information that the miniport maintains for
    particular OIDs, such as changes in multicast addresses.

@comm

    NDIS calls <f MiniportSetInformation> either on its own
    behalf, such as to manage bindings to the miniport, or
    when a bound protocol driver calls <f NdisRequest>.

    If <f MiniportSetInformation> returns NDIS_STATUS_PENDING, the
    driver must complete the request later by calling
    NdisMSetInformationComplete. Until it completes any request,
    the miniport can safely access the memory at InformationBuffer,
    BytesRead, and BytesNeeded. After the miniport completes any set
    request, ownership of these variables and the buffer reverts to
    NDIS or the caller of <f NdisRequest>, whichever allocated the memory.

    No other requests will be submitted to the WAN driver until the
    current set request is complete. If the WAN driver does not complete
    the call immediately (by returning NDIS_STATUS_PENDING), it must call
    NdisMSetInformationComplete to complete the call.

    Any of the settable NDIS global OIDs can be used, although a WAN
    miniport cannot set the <f NDIS_MAC_OPTION_FULL_DUPLEX> flag in
    response to an <f OID_GEN_MAC_OPTIONS> request. The following
    WAN-specific OID is passed to MiniportSetInformation.

    <f OID_WAN_SET_LINK_INFO><nl>
        This OID is used to set the link characteristics.
        The parameters in the structure passed for this OID
        are described previously for OID_WAN_GET_LINK_INFO.

    For more information about the system-defined OIDs, see Part 2 of the
    Network Drivers Network Reference document.

    <f MiniportSetInformation> can be pre-empted by an interrupt.

    By default, <f MiniportSetInformation> runs at IRQL DISPATCH_LEVEL.

    Calls to MiniportSetInformation changes information maintained by
    the miniport. This function definition and operation is the same
    as in a LAN miniport NIC driver except that certain WAN-specific
    OIDs must be recognized.



@rdesc

    <f MiniportSetInformation> can return one of the following:

    @flag NDIS_STATUS_SUCCESS |
        MiniportSetInformation used the data at InformationBuffer to
        set itself or its NIC to the state required by the given Oid,
        and it set the variable at BytesRead to the amount of supplied
        data it used.

    @flag NDIS_STATUS_PENDING |
        The driver will complete the request asynchronously with a call
        to NdisMSetInformationComplete when it has set itself or its NIC
        to the state requested.

    @flag NDIS_STATUS_INVALID_OID |
        MiniportSetInformation did not recognize the Oid.

    @flag NDIS_STATUS_INVALID_LENGTH |
        The InformationBufferLength does not match the length required
        by the given Oid. MiniportSetInformation returned how many bytes
        the buffer should be at BytesNeeded.

    @flag NDIS_STATUS_INVALID_DATA |
        The data supplied at InformationBuffer was invalid for the given Oid.

    @flag NDIS_STATUS_NOT_ACCEPTED |
        MiniportSetInformation attempted the requested set operation on
        the NIC but was unsuccessful.

    @flag NDIS_STATUS_NOT_SUPPORTED |
        MiniportSetInformation does not support the Oid, which is optional.

    @flag NDIS_STATUS_RESOURCES |
        MiniportSetInformation could not carry out the requested operation
        due to resource constraints. This return value does not necessarily
        mean that the same request, submitted at a later time, will be
        failed for the same reason.

@xref

    <f MiniportInitialize>
    <f MiniportQueryInformation>

*/

NDIS_STATUS MiniportSetInformation(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN NDIS_OID                 Oid,                        // @parm
    // The OID.  (See section 7.4 of the NDIS 3.0 specification for a complete
    // description of OIDs.)

    IN PVOID                    InformationBuffer,          // @parm
    // The buffer that will receive the information. (See section 7.4 of the
    // NDIS 3.0 specification for a description of the length required for
    // each OID.)

    IN ULONG                    InformationBufferLength,    // @parm
    // The length in bytes of InformationBuffer.

    OUT PULONG                  BytesRead,                  // @parm
    // Returns the number of bytes read from InformationBuffer.

    OUT PULONG                  BytesNeeded                 // @parm
    // Returns the number of additional bytes needed to satisfy the OID.
    )
{
    DBG_FUNC("MiniportSetInformation")

    NDIS_STATUS                 Status;
    // Holds the status result returned by this function.

    /*
    // If this is a TAPI OID, pass it on over.
    */
    if ((Oid & 0xFFFFFF00L) == (OID_TAPI_ACCEPT & 0xFFFFFF00L))
    {
        Status = TspiRequestHandler(pAdapter,
                        Oid,
                        InformationBuffer,
                        InformationBufferLength,
                        BytesRead,
                        BytesNeeded
                        );
        return (Status);
    }

    DBG_ENTER(pAdapter);
    DBG_REQUEST(pAdapter,
              ("(OID=0x%08X %s)\n\t\tInfoLength=%d InfoBuffer=0x%X\n",
               Oid, DbgGetOidString(Oid),
               InformationBufferLength,
               InformationBuffer
              ));

    /*
    // Assume no extra bytes are needed.
    */
    ASSERT(BytesRead && BytesNeeded);
    *BytesRead = 0;
    *BytesNeeded = 0;

    /*
    // Determine which OID is being requested and do the right thing.
    */
    switch (Oid)
    {
    case OID_GEN_CURRENT_LOOKAHEAD:
        /*
        // WAN drivers always indicate the entire packet regardless of the
        // lookahead size.  So this request should be politely ignored.
        */
        DBG_NOTICE(pAdapter,("OID_GEN_CURRENT_LOOKAHEAD: set=%d expected=%d\n",
                    *(PULONG) InformationBuffer, CARD_MAX_LOOKAHEAD));
        ASSERT(InformationBufferLength == sizeof(ULONG));
        *BytesNeeded = *BytesRead = sizeof(ULONG);
        Status = NDIS_STATUS_SUCCESS;
        break;

    case OID_WAN_SET_LINK_INFO:

        if (InformationBufferLength == sizeof(NDIS_WAN_SET_LINK_INFO))
        {
            PNDIS_WAN_SET_LINK_INFO pSetWanLinkInfo;

            PBCHANNEL_OBJECT        pBChannel;
            // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

            /*
            // The InformationBuffer really points to a NDIS_WAN_SET_LINK_INFO
            // which contains a pointer to one of our BCHANNEL_OBJECT's in the
            // NdisLinkHandle field.
            */
            pSetWanLinkInfo = (PNDIS_WAN_SET_LINK_INFO)InformationBuffer;
            pBChannel = (PBCHANNEL_OBJECT) pSetWanLinkInfo->NdisLinkHandle;

            /*
            // Make sure what I just said is true.
            */
            if (!IS_VALID_BCHANNEL(pAdapter, pBChannel))
            {
                Status = NDIS_STATUS_INVALID_DATA;
                break;
            }

            ASSERT(pBChannel->WanLinkInfo.NdisLinkHandle == pBChannel);
            ASSERT(!(pBChannel->WanLinkInfo.SendFramingBits & ~pAdapter->WanInfo.FramingBits));
            ASSERT(!(pBChannel->WanLinkInfo.RecvFramingBits & ~pAdapter->WanInfo.FramingBits));

            /*
            // Copy the data into our WanLinkInfo sturcture.
            */
            NdisMoveMemory(&(pBChannel->WanLinkInfo),
                           InformationBuffer,
                           InformationBufferLength
                          );
            *BytesRead = sizeof(NDIS_WAN_SET_LINK_INFO);
            Status = NDIS_STATUS_SUCCESS;

            if (pBChannel->WanLinkInfo.MaxSendFrameSize != pAdapter->WanInfo.MaxFrameSize ||
                pBChannel->WanLinkInfo.MaxRecvFrameSize != pAdapter->WanInfo.MaxFrameSize)
            {
                DBG_NOTICE(pAdapter,("Line=%d - "
                            "NdisLinkHandle=%08lX - "
                            "SendFrameSize=%08lX - "
                            "RecvFrameSize=%08lX\n",
                            pBChannel->BChannelIndex,
                            pBChannel->WanLinkInfo.NdisLinkHandle,
                            pBChannel->WanLinkInfo.MaxSendFrameSize,
                            pBChannel->WanLinkInfo.MaxRecvFrameSize));
            }

            DBG_PARAMS(pAdapter,
                       ("\n                   setting    expected\n"
                        "NdisLinkHandle   = %08lX=?=%08lX\n"
                        "MaxSendFrameSize = %08lX=?=%08lX\n"
                        "MaxRecvFrameSize = %08lX=?=%08lX\n"
                        "SendFramingBits  = %08lX=?=%08lX\n"
                        "RecvFramingBits  = %08lX=?=%08lX\n"
                        "SendACCM         = %08lX=?=%08lX\n"
                        "RecvACCM         = %08lX=?=%08lX\n",
                        pBChannel->WanLinkInfo.NdisLinkHandle   , pBChannel,
                        pBChannel->WanLinkInfo.MaxSendFrameSize , pAdapter->WanInfo.MaxFrameSize,
                        pBChannel->WanLinkInfo.MaxRecvFrameSize , pAdapter->WanInfo.MaxFrameSize,
                        pBChannel->WanLinkInfo.SendFramingBits  , pAdapter->WanInfo.FramingBits,
                        pBChannel->WanLinkInfo.RecvFramingBits  , pAdapter->WanInfo.FramingBits,
                        pBChannel->WanLinkInfo.SendACCM         , pAdapter->WanInfo.DesiredACCM,
                        pBChannel->WanLinkInfo.RecvACCM         , pAdapter->WanInfo.DesiredACCM));
        }
        else
        {
            DBG_WARNING(pAdapter, ("OID_WAN_SET_LINK_INFO: Invalid size:%d expected:%d\n",
                        InformationBufferLength, sizeof(NDIS_WAN_SET_LINK_INFO)));
            Status = NDIS_STATUS_INVALID_LENGTH;
        }
        *BytesNeeded = sizeof(NDIS_WAN_SET_LINK_INFO);
        break;

#if defined(NDIS50_MINIPORT)
    case OID_PNP_SET_POWER:
        // The sample just returns success for all PM events even though we
        // don't really do anything with them.
        break;
#endif // NDIS50_MINIPORT

    default:
        /*
        // Unknown OID
        */
        Status = NDIS_STATUS_INVALID_OID;
        DBG_WARNING(pAdapter,("UNSUPPORTED Oid=0x%08x\n", Oid));
        break;
    }
    DBG_REQUEST(pAdapter,
              ("RETURN: Status=0x%X Needed=%d Read=%d\n",
               Status, *BytesNeeded, *BytesRead));

    DBG_RETURN(pAdapter, Status);
    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tpimem.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiMem TpiMem_c

@module TpiMem.c |

    This module implements the interface to the memory allocation wrappers.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiMem_c

@end

*/

#define  __FILEID__             TPIMEMORY_OBJECT_TYPE
// Unique file ID for error logging

#include "TpiMem.h"
#include "TpiDebug.h"

DBG_STATIC ULONG                g_MemoryAllocated = 0;
DBG_STATIC ULONG                g_MemoryFreed = 0;
DBG_STATIC ULONG                g_SharedMemoryAllocated = 0;
DBG_STATIC ULONG                g_SharedMemoryFreed = 0;


/* @doc INTERNAL TpiMem TpiMem_c TpiAllocateMemory


@func

    <f TpiAllocateMemory> provides a wrapper interface for standard memory
    allocation via <f NdisAllocateMemory>.  This interface is used to help
    debug memory allocation problems.  It can be used to keep track of how
    much memory has been allocated and freed by the Miniport, and can report
    the usage counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisAllocateMemory> (i.e. non-paged system memory).  Do not use this
    routine to allocate continuous or non-cached memory.

@rdesc

    <f TpiAllocateMemory> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS TpiAllocateMemory(
    OUT PVOID *                 ppObject,                   // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber,               // @parm
    // Line number of the file where called from.

    IN NDIS_HANDLE              MiniportAdapterHandle       // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.
    )
{
    DBG_FUNC("TpiAllocateMemory")

    NDIS_STATUS                 Status;
    // Holds the status result returned from an NDIS function call.

    ASSERT(ppObject);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|ppObject=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               ppObject,
               dwSize,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    /*
    // Allocate memory from NDIS.
    */
#if !defined(NDIS50_MINIPORT)
    Status = NdisAllocateMemory(ppObject, dwSize, 0, g_HighestAcceptableAddress);
#else  // NDIS50_MINIPORT
    Status = NdisAllocateMemoryWithTag(ppObject, dwSize, dwFileID);
#endif // NDIS50_MINIPORT

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ASSERT(*ppObject);
        NdisZeroMemory(*ppObject, dwSize);
        g_MemoryAllocated += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("Memory Allocated=%d Freed=%d -- Ptr=0x%X\n",
                   g_MemoryAllocated, g_MemoryFreed, *ppObject));
    }
    else
    {
        DBG_ERROR(DbgInfo,("NdisAllocateMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                  dwSize, szFileName, dwLineNumber, Status));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                3,
                Status,
                dwFileID,
                dwLineNumber
                );

        *ppObject = NULL;
    }

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiFreeMemory


@func

    <f TpiFreeMemory> provides a wrapper interface for <f NdisFreeMemory>.
    This interface is used to help debug memory allocation problems.  It can
    be used to keep track of how much memory has been allocated and freed by
    the Miniport, and can report the usage counters via the debugger.

    <f TpiFreeMemory> provides a wrapper interface for standard memory free
    via <f NdisFreeMemory>.  This interface is used to help debug memory
    allocation problems.  It can be used to keep track of how much memory
    has been allocated and freed by the Miniport, and can report the usage
    counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisFreeMemory> (i.e. non-paged system memory).  Do no use this
    routine to free continuous or non-cached memory.

*/

void TpiFreeMemory(
    IN OUT PVOID *              ppObject,                   // @parm
    // Points to a caller-defined memory location which this function
    // passes to <f NdisFreeMemory> and then writes NULL to.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiFreeMemory")

    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|ppObject=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               ppObject,
               dwSize,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    if (ppObject && *ppObject)
    {
        /*
        // Release memory to NDIS.
        */
        NdisFreeMemory(*ppObject, dwSize, 0);
        g_MemoryFreed += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("Memory Allocated=%d Freed=%d -- Ptr=0x%X\n",
                   g_MemoryAllocated, g_MemoryFreed, *ppObject));

        *ppObject = NULL;
    }
    else
    {
        DBG_ERROR(DbgInfo,("NULL POINTER (Size=%d, File=%s, Line=%d)\n",
                  dwSize, szFileName, dwLineNumber));
    }

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiAllocateSharedMemory


@func

    <f TpiAllocateSharedMemory> provides a wrapper interface for shared memory
    allocation via <f NdisMAllocateSharedMemory>.  This interface is used to help
    debug memory allocation problems.  It can be used to keep track of how
    much memory has been allocated and freed by the Miniport, and can report
    the usage counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisMAllocateSharedMemory> (i.e. non-paged system memory).  Do not
    use this routine to allocate continuous or non-cached memory.

@rdesc

    <f TpiAllocateSharedMemory> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

*/

NDIS_STATUS TpiAllocateSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN BOOLEAN                  bCached,                    // @parm
    // Specifies whether the requested memory is cached or not.

    OUT PVOID *                 pVirtualAddress,            // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    OUT NDIS_PHYSICAL_ADDRESS * pPhysicalAddress,           // @parm
    // Points to a caller-defined memory location to which this function
    // writes the physical address of the allocated memory.  If memory of
    // the specified type is not available, the physical address is zero.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiAllocateSharedMemory")

    NDIS_STATUS                 Status;
    // Holds the status result returned from an NDIS function call.

    ASSERT(pVirtualAddress);
    ASSERT(pPhysicalAddress);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|pVirtualAddress=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|bCached=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               pVirtualAddress,
               dwSize,
               bCached,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    /*
    // Allocate memory from NDIS.
    */
    NdisMAllocateSharedMemory(MiniportAdapterHandle,
                              dwSize,
                              bCached,
                              pVirtualAddress,
                              pPhysicalAddress
                              );


    if (*pVirtualAddress)
    {
        Status = NDIS_STATUS_SUCCESS;

        NdisZeroMemory(*pVirtualAddress, dwSize);
        g_SharedMemoryAllocated += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("SharedMemory Allocated=%d Freed=%d -- Ptr=0x%X @0x%X\n",
                   g_SharedMemoryAllocated, g_SharedMemoryFreed,
                   *pVirtualAddress, pPhysicalAddress->LowPart));
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;

        DBG_ERROR(DbgInfo,("NdisAllocateSharedMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                  dwSize, szFileName, dwLineNumber, Status));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                3,
                Status,
                dwFileID,
                dwLineNumber
                );

        *pVirtualAddress = NULL;
        pPhysicalAddress->LowPart = 0;
        pPhysicalAddress->HighPart = 0;
    }

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL TpiMem TpiMem_c TpiFreeSharedMemory


@func

    <f TpiFreeSharedMemory> provides a wrapper interface for <f NdisFreeSharedMemory>.
    This interface is used to help debug memory allocation problems.  It can
    be used to keep track of how much memory has been allocated and freed by
    the Miniport, and can report the usage counters via the debugger.

    <f TpiFreeSharedMemory> provides a wrapper interface for standard memory free
    via <f NdisFreeSharedMemory>.  This interface is used to help debug memory
    allocation problems.  It can be used to keep track of how much memory
    has been allocated and freed by the Miniport, and can report the usage
    counters via the debugger.

@comm

    This routine uses zero for the <p MemoryFlags> parameter when calling
    <f NdisFreeSharedMemory> (i.e. non-paged system memory).  Do no use this
    routine to free continuous or non-cached memory.

*/

void TpiFreeSharedMemory(
    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library.

    IN ULONG                    dwSize,                     // @parm
    // Specifies the size, in bytes, of the requested memory.

    IN BOOLEAN                  bCached,                    // @parm
    // Specifies whether the requested memory is cached or not.

    IN PVOID *                  pVirtualAddress,            // @parm
    // Points to a caller-defined memory location to which this function
    // writes the virtual address of the allocated memory.  If memory of
    // the specified type is not available, the pointer value is NULL.

    IN NDIS_PHYSICAL_ADDRESS *  pPhysicalAddress,           // @parm
    // Points to a caller-defined memory location to which this function
    // writes the physical address of the allocated memory.  If memory of
    // the specified type is not available, the physical address is zero.

    IN ULONG                    dwFileID,                   // @parm
    // __FILEID__ of the caller.

    IN LPSTR                    szFileName,                 // @parm
    // File name of the caller.

    IN ULONG                    dwLineNumber                // @parm
    // Line number of the file where called from.
    )
{
    DBG_FUNC("TpiFreeSharedMemory")

    ASSERT(pVirtualAddress);
    ASSERT(pPhysicalAddress);
    ASSERT(dwSize);
    ASSERT(szFileName);

    DBG_ENTER(DbgInfo);
    DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
              ("\n"
               "\t|pVirtualAddress=0x%X\n"
               "\t|dwSize=%d\n"
               "\t|bCached=%d\n"
               "\t|dwFileID=0x%X\n"
               "\t|szFileName=%s\n"
               "\t|dwLineNumber=%d\n",
               pVirtualAddress,
               dwSize,
               bCached,
               dwFileID,
               szFileName,
               dwLineNumber
              ));

    if (pVirtualAddress && *pVirtualAddress)
    {
        /*
        // Release memory to NDIS.
        */
        NdisMFreeSharedMemory(MiniportAdapterHandle,
                              dwSize,
                              bCached,
                              *pVirtualAddress,
                              *pPhysicalAddress
                              );
        g_SharedMemoryFreed += dwSize;

        DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                  ("SharedMemory Allocated=%d Freed=%d -- Ptr=0x%X @0x%X\n",
                   g_SharedMemoryAllocated, g_SharedMemoryFreed,
                   *pVirtualAddress, pPhysicalAddress->LowPart));

        *pVirtualAddress = NULL;
        pPhysicalAddress->LowPart = 0;
        pPhysicalAddress->HighPart = 0;
    }
    else
    {
        DBG_ERROR(DbgInfo,("NULL POINTER (Size=%d, File=%s, Line=%d)\n",
                  dwSize, szFileName, dwLineNumber));
    }

    DBG_LEAVE(DbgInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\receive.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Receive Receive_c

@module Receive.c |

    This module implements the Miniport packet receive routines.  Basically,
    the asynchronous receive processing routine.  This module is very
    dependent on the hardware/firmware interface and should be looked at
    whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Receive_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.4 Receiving Packets General |

    A WAN miniport calls NdisMWanIndicateReceive to indicate that a
    packet has arrived and that the entire packet (there is no lookahead)
    is available for inspection. When this call is made, NDISWAN indicates
    the arrival of the packet to the ProtocolReceive handlers of bound
    higher-level drivers.

    <f Note>: Since the entire packet is always passed up, the miniport driver will
    never receive a transfer-data call (the data is copied by NDISWAN and
    then passed up to the next higher driver). The entire packet is always
    passed up due to compression and encryption that might have been applied
    to the packet. Also, because the link is point-to-point, at least one
    bound protocol will always want to look at the packet.

    The data contained in the header is the same as that received on the
    NIC. The NIC driver will not remove any headers or trailers from the
    data it receives. The transmitting driver cannot add padding to the
    packet.

    A WAN miniport calls NdisMWanIndicateReceiveComplete to indicate the
    end of one or more receive indications so that protocols can postprocess
    received packets. As a result, NDISWAN calls the ProtocolReceiveComplete
    handler(s) of bound protocols to notifying each protocol that it can
    now process the received data. In its receive-complete handler, a
    protocol need not operate under the severe time constraints that it
    does in its receive handler.

    The protocol should assume that interrupts are enabled during the
    call to ProtocolReceiveComplete. In an SMP machine, the receive
    handler and the receive complete handler can be running concurrently
    on different processors.

    Note that a WAN driver need not deliver NdisMWanIndicateReceiveComplete
    indications in one-to-one correspondence with NdisMWanIndicateReceive
    indications. It can issue a single receive-complete indication
    after several receive indications have occurred. For example, a
    WAN miniport could call NdisMWanIndicateReceiveComplete from its
    receive handler every ten packets or before exiting the handler,
    whichever occurs first.

@topic 3.5 Receiving Packets Specific |

    Packets are recevied asynchronously by the Miniport from the driver's
    BChannel services as a stream of raw HDLC frames.  See the Sending
    Packets section for details on the frame format.

    When a call is connected, the Miniport pre-loads the driver receive queue
    with the number of buffers defined by the registry parameter
    <p ReceiveBuffersPerLink>.

    When the driver has read an HDLC frame from the associated BChannel, it calls
    the Miniport routine <f BChannelEventHandler> with <t BREASON_RECEIVE_DONE>.
    The Miniport then calls <f CardNotifyReceive> which de-queues the buffer
    from the link's <p ReceivePendingList> and places it on the adapter's
    <p ReceiveCompleteList>.  <f CardNotifyReceive> then schedules the routine
    <f MiniportTimer> to be called as soon as it is safe to process the
    event (i.e. the Miniport can be re-entered).

    When <f MiniportTimer> runs, it calls <f ReceivePacketHandler> to
    process ALL the packets on the <p ReceiveCompleteList>.  Each packet is
    dequeued and passed up to <f NdisMWanIndicateReceive>.  After the packet
    is copied by the WAN wrapper, the buffer is then reset and posted back to
    the driver so it can be used to receive another frame.

    After all packets have been processed by the <f ReceivePacketHandler>,
    before leaving <f MiniportTimer>, <f NdisMWanIndicateReceiveComplete>
    is called so the WAN wrapper can do its post-processing.

@end
*/

#define  __FILEID__             RECEIVE_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Receive Receive_c ReceivePacketHandler


@func

    <f ReceivePacketHandler> is called from <f MiniportTimer> to handle
    a packet receive event.  We enter here with interrupts enabled on
    the adapter and the processor, but the NDIS Wrapper holds a spin lock
    since we are executing on an NDIS timer thread.

@comm

    We loop in here until all the available incoming packets have been passed
    up to the protocol stack.  As we find each good packet, it is passed up
    to the protocol stack using <f NdisMWanIndicateReceive>.  When NDIS
    returns control from this call, we resubmit the packet to the adapter
    so it can be used to receive another incoming packet.  The link flag
    <p NeedReceiveCompleteIndication> is set TRUE if any packets are received
    on a particular link.  This is used later, before returning from the
    async event handler, to notify NDIS of any ReceiveCompleteIndications.

*/

void ReceivePacketHandler(
    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A Pointer to one of our <t BCHANNEL_OBJECT>'s.

    IN PUCHAR                   ReceiveBuffer,              // @parm
    // Pointer to first byte received.

    IN ULONG                    BytesReceived               // @parm
    // Number of bytes received.
    )
{
    DBG_FUNC("ReceivePacketHandler")

    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    ASSERT(pBChannel && pBChannel->ObjectType == BCHANNEL_OBJECT_TYPE);
    pAdapter = GET_ADAPTER_FROM_BCHANNEL(pBChannel);

    DBG_ENTER(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (++(pAdapter->NestedDataHandler) > 1)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d > 1\n",
                  pAdapter->NestedDataHandler));
    }

    /*
    // Is there someone up there who cares?
    */
    if (pBChannel->NdisLinkContext == NULL)
    {
        DBG_WARNING(pAdapter, ("Packet recvd on disconnected line #%d\n",pBChannel->BChannelIndex));
    }
#ifdef NDISWAN_BUG // NDISWAN is sometimes setting this to zero - ignore it!
    /*
    // Return if we were told to expect nothing.
    */
    else if (pBChannel->WanLinkInfo.MaxRecvFrameSize == 0)
    {
        DBG_WARNING(pAdapter,("Packet size=%d > %d\n",
                    BytesReceived, pBChannel->WanLinkInfo.MaxRecvFrameSize));
    }
#endif // NDISWAN_BUG
    else
    {
        pAdapter->TotalRxBytes += BytesReceived;
        pAdapter->TotalRxPackets++;

        /*
        // We have to accept the frame if possible, I just want to know
        // if somebody has lied to us...
        */
        if (BytesReceived > pBChannel->WanLinkInfo.MaxRecvFrameSize)
        {
            DBG_NOTICE(pAdapter,("Packet size=%d > %d\n",
                       BytesReceived, pBChannel->WanLinkInfo.MaxRecvFrameSize));
        }
        DBG_RX(pAdapter, pBChannel->BChannelIndex,
               BytesReceived, ReceiveBuffer);

        /*
        // Indiciate the packet up to the protocol stack.
        */
        NdisMWanIndicateReceive(
                &Status,
                pAdapter->MiniportAdapterHandle,
                pBChannel->NdisLinkContext,
                ReceiveBuffer,
                BytesReceived
                );

        if (Status == NDIS_STATUS_SUCCESS)
        {
            pBChannel->NeedReceiveCompleteIndication = TRUE;
        }
        else
        {
            DBG_WARNING(pAdapter,("NdisMWanIndicateReceive returned error 0x%X\n",
                        Status));
        }
    }

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (--(pAdapter->NestedDataHandler) < 0)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d < 0\n",
                  pAdapter->NestedDataHandler));
    }

    DBG_LEAVE(pAdapter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tpidebug.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiDebug TpiDebug_c

@module TpiDebug.c |

    This module, along with <f TpiDebug\.h>, implements code and macros to
    support NDIS driver debugging.  This file must be linked with the driver
    to support debug dumps and logging.

@comm

    The code and macros defined by these modules is only generated during
    development debugging when the C pre-processor macro flag (DBG == 1).
    If (DBG == 0) no code will be generated, and all debug strings will be
    removed from the image.

    This is a device independent module which can be re-used, without
    change, by any driver or application.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiDebug_c

@end

*/

#if defined(_EXE_) || defined(_DLL_)
typedef char CHAR, *PCHAR;
typedef unsigned char  UCHAR,  *PUCHAR;
typedef unsigned short USHORT, *PUSHORT;
typedef unsigned long  ULONG,  *PULONG;
typedef unsigned int  *PUINT;

# include <windows.h>
#elif defined(_VXD_)
# include <basedef.h>
# include <vmm.h>
# pragma VxD_LOCKED_CODE_SEG
# pragma VxD_LOCKED_DATA_SEG
#else
# include <windef.h>
#endif

#include "TpiDebug.h"

#if DBG

/*
// Sometimes the debug output seriously impacts the run-time performance,
// so it is necessary to turn off the debug output.  In this case, you can
// capture some debug trace information into the DbgLogBuffer, and it can
// be examined later without impacting the run-time performance.
*/
#define DBG_LOG_ENTRIES     100     // Maximum number of FIFO log entries.
#define DBG_LOG_SIZE        128     // Maximum number of bytes per entry.

#if defined(_VXD_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'V','X','D',0 } };
#elif defined(_EXE_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'E','X','E',0 } };
#elif defined(_DLL_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'D','L','L',0 } };
#elif defined(_SYS_)
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'S','Y','S',0 } };
#else
DBG_SETTINGS    DbgSettings = { DBG_DEFAULTS, {'T','P','I',0 } };
#endif

PDBG_SETTINGS   DbgInfo = &DbgSettings;
UINT            DbgLogIndex = 0;
UCHAR           DbgLogBuffer[DBG_LOG_ENTRIES][DBG_LOG_SIZE] = { { 0 } };


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrintData


@func

    <f DbgPrintData> outputs data to the debug display formatted in HEX and
    ASCII for easy viewing.

    <f Note>: This routine is used for debug output only.
    It is not compiled into the retail version.

@ex <tab> |
    DbgPrintData(ReceiveBuffer, 14, 0);                     // Packet header
    DbgPrintData(ReceiveBuffer+14, BytesReceived-14, 14);   // Packet data

0000: ff ff ff ff ff ff 0a 22 23 01 02 03 00 10        ......."#.....
000E: 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 40  ABCDEFGHIJKMNOPQ

*/

VOID DbgPrintData(
    IN PUCHAR                   Data,                       // @parm
    // Pointer to first byte of data to be displayed.

    IN UINT                     NumBytes,                   // @parm
    // Number of bytes to be displayed.

    IN ULONG                    Offset                      // @parm
    // Value to be added to the offset counter displayed at the start of each
    // line.  This is useful for viewing data whose base offset is relative to
    // another, non-zero starting address.

    )
{
    UINT                        LineStart;
    UINT                        LineIndex;

    /*
    // Display the caller's buffer with up to 16 bytes per line.
    */
    for (LineStart = 0; LineStart < NumBytes; LineStart += 16)
    {
        /*
        // Display the starting offset of the line.
        */
        DbgPrint("%04lx: ", LineStart + Offset);

        /*
        // Display a line of HEX byte values.
        */
        for (LineIndex = LineStart; LineIndex < (LineStart+16); LineIndex++)
        {
            if (LineIndex < NumBytes)
            {
                DbgPrint("%02x ",(UINT)((UCHAR)*(Data+LineIndex)));
            }
            else
            {
                DbgPrint("   ");
            }
        }
        DbgPrint("  ");     // A little white space between HEX and ASCII.

        /*
        // Display the corresponding ASCII byte values if they are printable.
        // (i.e. 0x20 <= N <= 0x7F).
        */
        for (LineIndex = LineStart; LineIndex < (LineStart+16); LineIndex++)
        {
            if (LineIndex < NumBytes)
            {
                char c = *(Data+LineIndex);

                if (c < ' ' || c > 'z')
                {
                    c = '.';
                }
                DbgPrint("%c", (UINT)c);
            }
            else
            {
                DbgPrint(" ");
            }
        }
        DbgPrint("\n");     // End of line.
    }
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgQueueData


@func

    <f DbgQueueData> saves data to the DbgLogBuffer so it can be viewed later
    with the debugger.

    <f Note>: This routine is used for debug output only.
    It is not compiled into the retail version.

*/

VOID DbgQueueData(
    IN PUCHAR                   Data,                       // @parm
    // Pointer to first byte of data to be displayed.

    IN UINT                     NumBytes,                   // @parm
    // Number of bytes to be displayed.

    IN UINT                     Flags                       // @parm
    // A flag descriptor to help identify the log entry.
    )
{
    /*
    // Point to the next available entry in the DbgLogBuffer.
    */
    PUCHAR LogEntry = &DbgLogBuffer[DbgLogIndex++][0];

    /*
    // Wrap around on the next entry if needed.
    */
    if (DbgLogIndex >= DBG_LOG_ENTRIES)
    {
        DbgLogIndex = 0;
    }

    /*
    // Save the flags parameter in the first WORD of the log buffer.
    */
    *((PUSHORT) LogEntry) = (USHORT) Flags;
    LogEntry += sizeof(PUSHORT);

    /*
    // Save the NumBytes parameter in the second WORD of the log buffer.
    */
    *((PUSHORT) LogEntry) = (USHORT) NumBytes;
    LogEntry += sizeof(NumBytes);

    /*
    // Don't try to save more than we have room for.
    */
    if (NumBytes > DBG_LOG_SIZE - sizeof(USHORT) * 2)
    {
        NumBytes = DBG_LOG_SIZE - sizeof(USHORT) * 2;
    }

    /*
    // Save the rest of the data in the remaining portion of the log buffer.
    */
    while (NumBytes--)
    {
        *LogEntry++ = *Data++;
    }
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgBreakPoint


@func VOID | DbgBreakPoint |

    <f DbgBreakPoint> is defined in the NT kernel for SYS drivers, but we
    override it here so we can support for SYS's, EXE's, VXD's, and DLL's.

*/
#if defined(_MSC_VER) && (_MSC_VER <= 800)
// Must be building with 16-bit compiler
VOID __cdecl DbgBreakPoint(VOID)
#else
// Must be building with 32-bit compiler
VOID __stdcall DbgBreakPoint(VOID)
#endif
{
#if !defined(_WIN64)
    __asm int 3;
#endif
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrint


@func ULONG __cdecl | DbgPrint |

    <f DbgPrint> is defined in the kernel for SYS drivers, otherwise it is
    supported here for EXE's, VXD's, and DLL's.

@parm PCHAR | Format |
    printf style format string.

@parm OPTIONAL | Params |
    Zero or more optional parameters as needed by the format string.

*/

#if defined(_VXD_)

#if !defined(NDIS_DOS)
ULONG __cdecl DbgPrint(PCHAR Format, ...)
{
    ULONG   result = 0;

    __asm lea  eax, (Format + 4)
    __asm push eax
    __asm push Format
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 4*2
    __asm mov result, eax

    return (result);
}
#endif

#elif defined(_EXE_) || defined(_DLL_)

UCHAR   DbgString[1024];

ULONG __cdecl DbgPrint(PCHAR Format, ...)
{
    ULONG   result;

    result = wvsprintf(DbgString, Format, ((PCHAR) &Format) + sizeof(PCHAR));

    OutputDebugString(DbgString);

    if (result >= sizeof(DbgString))
    {
        // We just blew the stack!
        // Since we can't return, we have to generate a stack-fault interrupt
        __asm int 1;
        __asm int 3;
        __asm int 12;
    }
    return (result);
}
#endif // DbgPrint

/*
 * If DBG_SILENT is set, all TERSE debug goes here. An assertion
 * will dump the block.
 */
#define DBG_QUEUE_LEN       4096
UINT    DbgIndex=0;
UINT    DbgLen=0;
UCHAR   DbgQueue[DBG_QUEUE_LEN] =  {0};
UCHAR   DbgLock=0;


/* @doc INTERNAL TpiDebug TpiDebug_c DbgDumpSilentQueue


@func

    <f DbgDumpSilentQueue> dumps the contents of the silent debug queue to
    the monitor.

*/

void DbgDumpSilentQueue(
    void
    )
{
    if (DbgLen >= DBG_QUEUE_LEN)
    {
        DbgPrintData(
            &DbgQueue[DbgIndex],
            DBG_QUEUE_LEN-DbgIndex,
            0);
        if (DbgIndex)
        {
            DbgPrint("\n");
            DbgPrintData(
                DbgQueue,
                DbgIndex-1,
                0);
        }
        DbgPrint("\n");
    }
    else if (DbgLen)
    {
        DbgPrintData(
                DbgQueue,
                DbgIndex-1,
                0);
        DbgPrint("\n");
    }
}

#if NDIS_NT

/* @doc INTERNAL TpiDebug TpiDebug_c _assert


@func

    <f _assert> overrides the assertion function provided by the operating
    system. Dumps the contents of debug queue, prints the assertion, and
    then traps to the debugger.  Used for debugging only.

*/

void _CRTAPI1 _assert(
    void *                      exp,                        // @parm
    // ASCIIZ pointer to the expression causing the fault.

    void *                      file,                       // @parm
    // ASCIIZ pointer to the name of the file.

    unsigned                    line                        // @parm
    // Line offset within the file where the assertion is defined.
    )
{
    DbgDumpSilentQueue();
    DbgPrint("Assertion Failed: %s at %s:%d\n",exp,file,line);
    DbgBreakPoint();
}
#endif


/* @doc INTERNAL TpiDebug TpiDebug_c DbgSilentQueue


@func

    <f DbgSilentQueue> logs a string to the debug queue which can be
    displayed later using <f DbgDumpSilentQueue>.  Used for debugging only.

*/

void DbgSilentQueue(
    PUCHAR                      str                         // @parm
    // Pointer to string to be placed in DbgQueue.
    )
{
    /*
    // If the debug queue is busy, just
    // bail out.
    */
    if ((++DbgLock) > 1)
    {
        goto exit;
    }

    while (str && *str)
    {
        DbgQueue[DbgIndex] = *str++;
        DbgLen++;
        if ((++DbgIndex) >= DBG_QUEUE_LEN)
        {
            DbgIndex = 0;
        }
    }
exit:
    DbgLock--;
}


/* @doc INTERNAL TpiDebug TpiDebug_c DbgPrintFieldTable


@func

    <f DbgPrintFieldTable> displays the contents of a C data structure in
    a formatted output to the debugger.  This can be used when symbolic
    debugging is not available on the target platform.

*/

void DbgPrintFieldTable(
    IN PDBG_FIELD_TABLE         pFields,                    // @parm
    // A pointer to an array of field records <t DBG_FIELD_TABLE>.

    IN PUCHAR                   pBaseContext,               // @parm
    // References the base of the structure where the values will be displayed
    // from.  This should be a pointer to the first byte of the structure.

    IN PUCHAR                   pBaseName                   // @parm
    // Pointer to C string containing the name of the structure being displayed.
    )
{
    DbgPrint("STRUCTURE: @0x%08X %s\n", pBaseContext, pBaseName);

    while (pFields->FieldName)
    {
        switch (pFields->FieldType)
        {
        case sizeof(ULONG):
            DbgPrint("\t%04X: %-32s=0x%08X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PULONG)(pBaseContext+pFields->FieldOffset));
            break;

        case sizeof(USHORT):
            DbgPrint("\t%04X: %-32s=0x%04X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PUSHORT)(pBaseContext+pFields->FieldOffset));
            break;

        case sizeof(UCHAR):
            DbgPrint("\t%04X: %-32s=0x%02X\n", pFields->FieldOffset,
                     pFields->FieldName,
                     *(PUCHAR)(pBaseContext+pFields->FieldOffset));
            break;

        default:
            ASSERT(0);
            break;
        }
        pFields++;
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tpiparam.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiParam TpiParam_c

@module TpiParam.c |

    This module, along with <f TpiParam\.h>, implements a table driven parser
    for the NDIS registry parameters.

@comm

    See <f Keywords\.h> for details of how to add new parameters.<nl>

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiParam_c

@end

*/

#define  __FILEID__     TPI_MODULE_PARAMS   // Unique file ID for error logging

#include <ndis.h>
#include "TpiDebug.h"
#include "TpiParam.h"

#if defined(_VXD_) && !defined(NDIS_LCODE)
#  define NDIS_LCODE code_seg("_LTEXT", "LCODE")
#  define NDIS_LDATA data_seg("_LDATA", "LCODE")
#endif

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif

static NDIS_PHYSICAL_ADDRESS    g_HighestAcceptableAddress =
                                    NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);

static NDIS_STRING              g_NullString =
                                    NDIS_STRING_CONST("\0");


/* @doc INTERNAL TpiParam TpiParam_c ustrlen


@func

    <f ustrlen> counts the number of characters in
    a UNICODE (wide) string.

@comm

@rdesc

    <f ustrlen> returns the length of the UNICODE string
    pointed to by <p string>.  The terminating NULL character is not
    counted.

*/
USHORT ustrlen(
    IN PUSHORT                  string                      // @parm
    // Pointer to the beginning of a UNICODE string ending
    // with a 0x0000 value.
    )
{
    USHORT                      ct;

    for (ct = 0; *string != 0x0000; string++, ct++)
        ;

    return(ct);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamUnicodeStringToAnsiString


@func

    <f ParamUnicodeStringToAnsiString> converts a double byte string to a
    single byte string.

@comm

    The original release of the NDIS Wrapper for Windows 95 and 3.1 does not
    return UNICODE strings from the NdisReadConfiguration routine.  So this
    routine attempts to auto detect this situation by examining the first
    character of the string.  If the second byte of the first character is
    a zero, the string is assumed to be UNICODE, and it is converted to an
    ANSI string; otherwise the ANSI string is just copied.
    <nl>
    <f Note>: This also assumes that the first character of any UNICODE
    string will not use the second byte (i.e. not an extended character).
    This routine will only successfully convert non-extended character
    strings anyway.

@xref
    <f ParamParseRegistry>
*/

VOID ParamUnicodeStringToAnsiString(
    OUT PANSI_STRING            out,                        // @parm
    // A pointer to where the converted ANSI string is to be stored.

    IN PUNICODE_STRING          in                          // @parm
    // A pointer to the UNICODE string to be converted.
    )
{
    DBG_FUNC("ParamUnicodeStringToAnsiString")

    UINT Index;

    /* CAVEAT - NDIS_BUG
    // NDIS driver for Windows 95 does not return UNICODE from
    // registry parser, so we need to kludge it up here.
    */
    if (in->Length > 1)
    {
        if (((PUCHAR)(in->Buffer))[1] == 0)
        {
            /*
            // Probably a UNICODE string since all our parameters are ASCII
            // strings.
            */
            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("UNICODE STRING IN @%x#%d='%ls'\n",
                       in->Buffer, in->Length, in->Buffer));
            for (Index = 0; Index < (in->Length / sizeof(WCHAR)) &&
                 Index < out->MaximumLength; Index++)
            {
                out->Buffer[Index] = (UCHAR) in->Buffer[Index];
            }
        }
        else
        {
            /*
            // Probably an ANSI string since all our parameters are more
            // than 1 byte long and should not be zero in the second byte.
            */
            PANSI_STRING in2 = (PANSI_STRING) in;

            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("ANSI STRING IN @%x#%d='%s'\n",
                       in2->Buffer, in2->Length, in2->Buffer));

            for (Index = 0; Index < in2->Length &&
                 Index < out->MaximumLength; Index++)
            {
                out->Buffer[Index] = in2->Buffer[Index];
            }
        }
    }
    else
    {
        DBG_WARNING(DbgInfo,("1 BYTE STRING IN @%x=%04x\n",
                    in->Buffer, in->Buffer[0]));
        out->Buffer[0] = (UCHAR) in->Buffer[0];
        Index = 1;
    }
    out->Length = (USHORT) Index; // * sizeof(UCHAR);

    // NULL terminate the string if there's room.
    if (out->Length <= (out->MaximumLength - sizeof(UCHAR)))
    {
        out->Buffer[Index] = 0;
    }
    ASSERT(out->Length <= out->MaximumLength);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamUnicodeCopyString


@func

    <f ParamUnicodeCopyString> copies a double byte string to a double byte
    string.

@comm

    The original release of the NDIS Wrapper for Windows 95 and 3.1 does not
    return UNICODE strings from the NdisReadConfiguration routine.  So this
    routine attempts to auto detect this situation by examining the first
    character of the string.  If the second byte of the first character is
    a zero, the string is assumed to be UNICODE, and it just copied;
    otherwise the ANSI string is converted to UNICODE.
    <nl>
    <f Note>: This also assumes that the first character of any UNICODE
    string will not use the second byte (i.e. not an extended character).
    This routine will only successfully convert non-extended character
    strings anyway.

@xref
    <f ParamParseRegistry>

*/

VOID ParamUnicodeCopyString(
    OUT PUNICODE_STRING         out,                        // @parm
    // A pointer to where the new UNICODE string is to be stored.

    IN PUNICODE_STRING          in                          // @parm
    // A pointer to the UNICODE string to be copied.
    )
{
    DBG_FUNC("ParamUnicodeCopyString")

    UINT Index;

    /* CAVEAT - NDIS_BUG
    // NDIS driver for Windows 95 does not return UNICODE from
    // registry parser, so we need to kludge it up here.
    */
    if (in->Length > 1)
    {
        if (((PUCHAR)(in->Buffer))[1] == 0)
        {
            /*
            // Probably a UNICODE string since all our parameters are ASCII
            // strings.
            */
            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("UNICODE STRING IN @%x#%d='%ls'\n",
                       in->Buffer, in->Length, in->Buffer));
            for (Index = 0; Index < (in->Length / sizeof(WCHAR)) &&
                 Index < (out->MaximumLength / sizeof(WCHAR)); Index++)
            {
                out->Buffer[Index] = in->Buffer[Index];
            }
        }
        else
        {
            /*
            // Probably an ANSI string since all our parameters are more
            // than 1 byte long and should not be zero in the second byte.
            */
            PANSI_STRING in2 = (PANSI_STRING) in;

            DBG_FILTER(DbgInfo, DBG_TRACE_ON,
                       ("ANSI STRING IN @%x#%d='%s'\n",
                       in2->Buffer, in2->Length, in2->Buffer));
            for (Index = 0; Index < in2->Length &&
                 Index < (out->MaximumLength / sizeof(WCHAR)); Index++)
            {
                out->Buffer[Index] = (WCHAR) in2->Buffer[Index];
            }
        }
    }
    else
    {
        DBG_WARNING(DbgInfo,("1 BYTE STRING IN @%x=%04x\n",
                    in->Buffer, in->Buffer[0]));
        out->Buffer[0] = (WCHAR) in->Buffer[0];
        Index = 1;
    }
    out->Length = Index * sizeof(WCHAR);

    // NULL terminate the string if there's room.
    if (out->Length <= (out->MaximumLength - sizeof(WCHAR)))
    {
        out->Buffer[Index] = 0;
    }
    ASSERT(out->Length <= out->MaximumLength);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamGetNumEntries


@func

    <f ParamGetNumEntries> counts the number of records in the registry
    parameter table.

@rdesc

    <f ParamGetNumEntries> returns the number of entries in the parameter
    table.

@xref
    <f ParamParseRegistry>

*/

DBG_STATIC UINT ParamGetNumEntries(
    IN PPARAM_TABLE             Parameters                  // @parm
    // A pointer to an array of registry parameter records.
    )
{
    UINT NumRecs = 0;

    /*
    // Scan the parameter array until we find an entry with zero length name.
    */
    if (Parameters)
    {
        while (Parameters->RegVarName.Length)
        {
            NumRecs++;
            Parameters++;
        }
    }
    return(NumRecs);
}


/* @doc INTERNAL TpiParam TpiParam_c ParamParseRegistry


@func

    <f ParamParseRegistry> parses the registry parameter table and attempts
    to read a value from the registry for each parameter record.

@rdesc

    <f ParamParseRegistry> returns one of the following values:
    @flag NDIS_STATUS_SUCCESS |
        If this function is successful.

    <f Note>: A non-zero return value indicates one of the following error codes:

@iex
    NDIS_STATUS_FAILURE

@xref
    <f MiniportInitialize>
    <f ParamGetNumEntries>
    <f NdisOpenConfiguration>
    <f NdisWriteErrorLogEntry>
    <f NdisReadConfiguration>
    <f NdisCloseConfiguration>
    <f NdisAllocateMemory>
    <f NdisZeroMemory>
    <f ParamUnicodeStringToAnsiString>
    <f ParamUnicodeCopyString>
*/

NDIS_STATUS ParamParseRegistry(
    IN NDIS_HANDLE              AdapterHandle,              // @parm
    // Handle to pass to NdisWriteErrorLogEntry if any errors are encountered.

    IN NDIS_HANDLE              WrapperConfigurationContext,// @parm
    // Handle to pass to NdisOpenConfiguration.

    IN PUCHAR                   BaseContext,                // @parm
    // References the base of the structure where the values read from the
    // registry are written.  Typically, this will be a pointer to the first
    // byte of the adapter information structure.

    IN PPARAM_TABLE             Parameters                  // @parm
    // A pointer to an array of registry parameter records <t PARAM_TABLE>.
    )
{
    DBG_FUNC("ParamParseRegistry")

    PNDIS_CONFIGURATION_PARAMETER   pReturnedValue;
    NDIS_CONFIGURATION_PARAMETER    ReturnedValue;
    NDIS_PARAMETER_TYPE             ParamType;

    /*
    // The handle for reading from the registry.
    */
    NDIS_HANDLE     ConfigHandle;

    UINT            NumRecs = ParamGetNumEntries(Parameters);
    UINT            i;
    PPARAM_TABLE    pParameter;
    NDIS_STATUS     Status;
    UINT            Value;
    PANSI_STRING    pAnsi;
    UINT            Length;

    /*
    // Open the configuration registry so we can get our config values.
    */
    NdisOpenConfiguration(
            &Status,
            &ConfigHandle,
            WrapperConfigurationContext
            );

    if (Status != NDIS_STATUS_SUCCESS)
    {
        /*
        // Log error message and exit.
        */
        DBG_ERROR(DbgInfo,("NdisOpenConfiguration failed (Status=%X)\n",Status));

        NdisWriteErrorLogEntry(
                AdapterHandle,
                NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                3,
                Status,
                __FILEID__,
                __LINE__
                );
        return NDIS_STATUS_FAILURE;
    }

    /*
    // Walk through all the parameters in the table.
    */
    for (i = 0, pParameter = Parameters; i < NumRecs; i++, pParameter++)
    {
#if DBG
        ANSI_STRING ansiRegString;
        char        ansiRegName[64];

        /*
        // Get a printable parameter name.
        */
        ansiRegString.Length = 0;
        ansiRegString.MaximumLength = sizeof(ansiRegName);
        ansiRegString.Buffer = (PCHAR)ansiRegName;
        NdisZeroMemory(ansiRegName, sizeof(ansiRegName));
        ParamUnicodeStringToAnsiString(
                &ansiRegString,
                (PUNICODE_STRING)&pParameter->RegVarName
                );
#endif // DBG

        ASSERT(pParameter->Type <= (UINT) NdisParameterMultiString);

        /*
        // Attempt to read the parameter value from the registry.
        */
        ParamType = (NDIS_PARAMETER_TYPE) pParameter->Type;
        NdisReadConfiguration(&Status,
                              &pReturnedValue,
                              ConfigHandle,
                              &pParameter->RegVarName,
                              ParamType
                             );
        /*
        // If value is not present, and it is mandatory, return failure code.
        */
        if (Status != NDIS_STATUS_SUCCESS && pParameter->Mandantory)
        {
            /*
            // Log error message and exit.
            */
            DBG_ERROR(DbgInfo,("%s: NOT IN REGISTRY!\n",
                      ansiRegName));

            NdisWriteErrorLogEntry(
                    AdapterHandle,
                    NDIS_ERROR_CODE_MISSING_CONFIGURATION_PARAMETER,
                    4,
                    i,
                    Status,
                    __FILEID__,
                    __LINE__
                    );

            NdisCloseConfiguration(ConfigHandle);
            return NDIS_STATUS_FAILURE;
        }

        /*
        // Determine how the caller wants to interpret this parameter.
        */
        if (ParamType == NdisParameterInteger ||
            ParamType == NdisParameterHexInteger)
        {
            ASSERT(pParameter->Size <= sizeof(ULONG));

            /*
            // If value read, use it, otherwise use default.
            */
            if (Status == NDIS_STATUS_SUCCESS)
            {
                Value = pReturnedValue->ParameterData.IntegerData;
            }
            else
            {
                Value = (UINT) (LONG_PTR)(pParameter->Default);
            }

            /*
            // If there are min/max boundaries, verify that value is in range.
            */
            if (pParameter->Min || pParameter->Max)
            {
                if (Value < pParameter->Min)
                {
                    DBG_ERROR(DbgInfo,("%s: Value=%X < Min=%X\n",
                              ansiRegName, Value, pParameter->Min));
                    Value = pParameter->Min;
                }
                else if (Value > pParameter->Max)
                {
                    DBG_ERROR(DbgInfo,("%s: Value=%X > Max=%X\n",
                              ansiRegName, Value, pParameter->Max));
                    Value = pParameter->Max;
                }
            }

            /*
            // Size of destination in bytes 1, 2, or 4 (default==INT).
            */
            switch (pParameter->Size)
            {
            case 0:
                *(PUINT)(BaseContext+pParameter->Offset)   = (UINT) Value;
                break;

            case 1:
                if (Value & 0xFFFFFF00)
                {
                    DBG_WARNING(DbgInfo,("%s: OVERFLOWS UCHAR\n",
                                ansiRegName));
                }
                *(PUCHAR)(BaseContext+pParameter->Offset)  = (UCHAR) Value;
                break;

            case 2:
                if (Value & 0xFFFF0000)
                {
                    DBG_WARNING(DbgInfo,("%s: OVERFLOWS USHORT\n",
                                ansiRegName));
                }
                *(PUSHORT)(BaseContext+pParameter->Offset) = (USHORT) Value;
                break;

            case 4:
                *(PULONG)(BaseContext+pParameter->Offset)  = (ULONG) Value;
                break;

            default:
                DBG_ERROR(DbgInfo,("%s: Invalid ParamSize=%d\n",
                          ansiRegName, pParameter->Size));
                NdisCloseConfiguration(ConfigHandle);
                return NDIS_STATUS_FAILURE;
                break;
            }

            if (ParamType == NdisParameterInteger)
            {
                DBG_PARAMS(DbgInfo,("%s: Value=%d Size=%d (%s)\n",
                           ansiRegName, Value, pParameter->Size,
                           (Status == NDIS_STATUS_SUCCESS) ?
                           "Registry" : "Default"));
            }
            else
            {
                DBG_PARAMS(DbgInfo,("%s: Value=0x%X Size=%d (%s)\n",
                           ansiRegName, Value, pParameter->Size,
                           (Status == NDIS_STATUS_SUCCESS) ?
                           "Registry" : "Default"));
            }
        }
        else if (ParamType == NdisParameterString ||
                 ParamType == NdisParameterMultiString)
        {
            ASSERT(pParameter->Size == sizeof(ANSI_STRING));

            /*
            // If value not read from registry.
            */
            if (Status != NDIS_STATUS_SUCCESS)
            {
                /*
                // Use our own temporary ReturnedValue.
                */
                pReturnedValue = &ReturnedValue;
                pReturnedValue->ParameterType = ParamType;

                /*
                // If default non-zero, use default value.
                */
                if (pParameter->Default != 0)
                {
                    NdisMoveMemory(&pReturnedValue->ParameterData.StringData,
                                   (PANSI_STRING) pParameter->Default,
                                   sizeof(ANSI_STRING));
                }
                else
                {
                    /*
                    // Otherwise, use null string value.
                    */
                    NdisMoveMemory(&pReturnedValue->ParameterData.StringData,
                                   &g_NullString,
                                   sizeof(g_NullString));
                }
            }

            /*
            // Assume the string is ANSI and points to the string data
            // structure.  We can get away with this because ANSI and
            // UNICODE strings have a common structure header.  An extra
            // character is allocated to make room for a null terminator.
            */
            pAnsi = (PANSI_STRING) (BaseContext+pParameter->Offset);
            Length = pReturnedValue->ParameterData.StringData.Length+1;

            /*
            // The caller wants a UNICODE string returned, we have to
            // allocated twice as many bytes to hold the result.
            // NOTE:
            // This wouldn't be necessary if NDIS would always return
            // a UNICODE string, but some Win95 versions of NDIS return
            // an ANSI string, so Length will be too small for UNICODE.
            // The down-side is that we may allocate twice as much as
            // we need to hold the string.  (oh well)
            */
            if (pParameter->Flags == PARAM_FLAGS_UNICODESTRING)
            {
                Length *= sizeof(WCHAR);
            }

            /*
            // Allocate memory for the string.
            */
#if !defined(NDIS50_MINIPORT)
            Status = NdisAllocateMemory(
                            (PVOID *) &(pAnsi->Buffer),
                            Length,
                            0,
                            g_HighestAcceptableAddress
                            );
#else  // NDIS50_MINIPORT
            Status = NdisAllocateMemoryWithTag(
                            (PVOID *) &(pAnsi->Buffer),
                            Length,
                            __FILEID__
                            );
#endif // NDIS50_MINIPORT

            if (Status != NDIS_STATUS_SUCCESS)
            {
                /*
                // Log error message and exit.
                */
                DBG_ERROR(DbgInfo,("NdisAllocateMemory(Size=%d, File=%s, Line=%d) failed (Status=%X)\n",
                          Length, __FILE__, __LINE__, Status));

                NdisWriteErrorLogEntry(
                        AdapterHandle,
                        NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                        4,
                        Status,
                        Length,
                        __FILEID__,
                        __LINE__
                        );
                NdisCloseConfiguration(ConfigHandle);
                return NDIS_STATUS_FAILURE;
            }
            else
            {
                DBG_FILTER(DbgInfo, DBG_MEMORY_ON,
                           ("NdisAllocateMemory(Size=%d, Ptr=0x%x)\n",
                            Length, pAnsi->Buffer));
            }
            /*
            // Zero the string buffer to start with.
            */
            ASSERT(pAnsi->Buffer);
            NdisZeroMemory(pAnsi->Buffer, Length);
            pAnsi->MaximumLength = (USHORT) Length;

            if (pParameter->Flags == PARAM_FLAGS_ANSISTRING)
            {
                /*
                // The caller wants an ANSI string returned, so we convert
                // it from UNICODE to ANSI.
                */
                ParamUnicodeStringToAnsiString(
                        pAnsi,
                        (PUNICODE_STRING) &(pReturnedValue->ParameterData.StringData)
                        );
#if DBG
                if (ParamType == NdisParameterMultiString)
                    {
                    USHORT        ct = 0;

                    while (ct < pAnsi->Length)
                        {
                        DBG_PARAMS(DbgInfo,("%s: ANSI='%s' Len=%d of %d\n",
                            ansiRegName,
                            &(pAnsi->Buffer[ct]),
                            (strlen(&(pAnsi->Buffer[ct]))),
                            pAnsi->Length));

                        ct = ct + (strlen(&(pAnsi->Buffer[ct])) + 1);
                        }
                    }
                else
                    {
                    DBG_PARAMS(DbgInfo,("%s: ANSI='%s' Len=%d\n",
                           ansiRegName, pAnsi->Buffer, pAnsi->Length));
                    }
#endif
            }
            else // PARAM_FLAGS_UNICODESTRING
            {
                /*
                // The caller wants a UNICODE string returned, so we can
                // just copy it.  The pAnsi buffer was allocated large
                // enough to hold the UNICODE string.
                */
                ParamUnicodeCopyString(
                        (PUNICODE_STRING) pAnsi,
                        (PUNICODE_STRING) &(pReturnedValue->ParameterData.StringData)
                        );
#if DBG
                if (ParamType == NdisParameterMultiString)
                    {
                    USHORT        ct = 0;

                    BREAKPOINT;

                    while (ct < (pAnsi->Length / 2))
                        {
                        DBG_PARAMS(DbgInfo,("%s: UNICODE='%ls' Len=%d of %d\n",
                           ansiRegName,
                           &((PUSHORT)pAnsi->Buffer)[ct],
                           (ustrlen(&((PUSHORT)pAnsi->Buffer)[ct]) * 2),
                           pAnsi->Length));

                        ct = ct + (ustrlen(&((PUSHORT)pAnsi->Buffer)[ct]) + 1);
                        }
                    }
                else
                    {
                    DBG_PARAMS(DbgInfo,("%s: UNICODE='%ls' Len=%d\n",
                               ansiRegName, pAnsi->Buffer, pAnsi->Length));
                    }
#endif

            }
        }
        else
        {
            /*
            // Report a bogus parameter type in the caller's table.
            */
            DBG_ERROR(DbgInfo,("Invalid ParamType=%d '%s'\n",
                      ParamType, ansiRegName));

            NdisCloseConfiguration(ConfigHandle);
            return NDIS_STATUS_FAILURE;
        }
    }
    NdisCloseConfiguration(ConfigHandle);
    return(NDIS_STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tpidebug.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms 
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiDebug TpiDebug_h

@module TpiDebug.h |

    This module, along with <f TpiDebug\.c>, implements code and macros to
    support NDIS driver debugging.  This file should be #include'd in all
    the driver source code modules.

@comm

    The code and macros defined by these modules is only generated during
    development debugging when the C pre-processor macro flag (DBG == 1).
    If (DBG == 0) no code will be generated, and all debug strings will be
    removed from the image.

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiDebug_h

@end

*/

#ifndef _TPIDEBUG_H
#define _TPIDEBUG_H

/* @doc INTERNAL TpiDebug TpiDebug_h


@topic Debug Globals |

    Debug macros are used to display error conditions, warnings, interesting
    events, and general flow through the components.  Setting one or more bits
    in the <f DbgInfo> global variable will enable the output from these
    macros.  See <t DEBUG_FLAGS> for details of the bits.  Only the debug
    version of the driver will contain code for this purpose.  All these
    macros will be compiled out in the release version.

    Each component has a separate <f DbgInfo> variable, so you can control
    debug output for each module separately.  By default, all the modules
    breakpoint at their entry point to display the current value and memory
    location of the module's <f DbgInfo> variable.  This way you can use
    the debugger to change the flags when the module is started.  The default
    flag for each module is set at compile time, but can be overridden at
    run time using the debugger.

@globalv DBG_SETTINGS | DbgInfo |

    DbgInfo is a global variable which points to the <t DBG_SETTINGS> for
    the module linked with <f TpiDebug\.c>.  It is passed to most of
    the debug output macros to control which output is to be displayed.  
    See <t DBG_FLAGS> to determine which bits to set.

*/

/*
// Module ID numbers to use for error logging
*/
#define TPI_MODULE_PARAMS               ((unsigned long)'P')+\
                                        ((unsigned long)'A'<<8)+\
                                        ((unsigned long)'R'<<16)+\
                                        ((unsigned long)'M'<<24)
#define TPI_MODULE_DEBUG                ((unsigned long)'D')+\
                                        ((unsigned long)'B'<<8)+\
                                        ((unsigned long)'U'<<16)+\
                                        ((unsigned long)'G'<<24)
#define TPI_MODULE_PERF                 ((unsigned long)'P')+\
                                        ((unsigned long)'E'<<8)+\
                                        ((unsigned long)'R'<<16)+\
                                        ((unsigned long)'F'<<24)
#define TPI_MODULE_WRAPS                ((unsigned long)'W')+\
                                        ((unsigned long)'R'<<8)+\
                                        ((unsigned long)'A'<<16)+\
                                        ((unsigned long)'P'<<24)

// In case these aren't defined in the current environment.
#if !defined(IN)
# define    IN
# define    OUT
#endif

/* @doc INTERNAL TpiDebug TpiDebug_h DBG_FLAGS


@enum DBG_FLAGS |

    The registry parameter <f DebugFlags> is read by the driver at
    initialization time and saved in the <f DbgFlags> field of the
    debug settings structure (See <t DBG_SETTINGS>).  This value
    controls the output of debug information according to the
    following bit OR'd flags.  The most significant 16 bits of the
    DbgFlags is available to use as you please, and can be used
    with the <f DBG_FILTER> macro.

*/

#define DBG_ERROR_ON        0x0001L
        // @emem DBG_ERROR_ON | (0x0001) Display <f DBG_ERROR> messages.

#define DBG_WARNING_ON      0x0002L
        // @emem DBG_WARNING_ON | (0x0002) Display <f DBG_WARNING> messages.

#define DBG_NOTICE_ON       0x0004L
        // @emem DBG_NOTICE_ON | (0x0004) Display <f DBG_NOTICE> messages.

#define DBG_TRACE_ON        0x0008L
        // @emem DBG_TRACE_ON | (0x0008) Display <f DBG_ENTER>, <f DBG_LEAVE>,
        // and <f DBG_TRACE> messages.

#define DBG_REQUEST_ON      0x0010L
        // @emem DBG_REQUEST_ON | (0x0010) Display NDIS Set/Query request
        // parameters using <f DBG_REQUEST>.

#define DBG_INDICATE_ON     0x0020L
        // @emem DBG_INDICATE_ON | (0x0020) Display NDIS status indications.

#define DBG_TAPICALL_ON     0x0040L
        // @emem DBG_TAPICALL_ON | (0x0040) Display TAPI call state messages
        // using <f DBG_FILTER>.

#define DBG_PARAMS_ON       0x0080L
        // @emem DBG_PARAMS_ON | (0x0080) Display function parameters and
        // return values using <f DBG_PARAMS>.

#define DBG_TXRX_LOG_ON     0x0100L
        // @emem DBG_TXRX_LOG_ON | (0x0100) Enable Tx/Rx data logging.

#define DBG_TXRX_ON         0x0200L
        // @emem DBG_TXRX_ON | (0x0200) Display Tx/Rx terse packet info.
        // This flag will just display the link index and packet length Rx#:#.

#define DBG_TXRX_HEADERS_ON 0x0400L
        // @emem DBG_TXRX_HEADERS_ON | (0x0400) Display Tx/Rx packet headers.

#define DBG_HEADERS_ON      DBG_TXRX_HEADERS_ON

#define DBG_TXRX_VERBOSE_ON 0x0800L
        // @emem DBG_TXRX_VERBOSE_ON | (0x0800) Display Tx/Rx packet data.

#define DBG_PACKETS_ON      DBG_TXRX_VERBOSE_ON

#define DBG_MEMORY_ON       0x1000L
        // @emem DBG_MEMORY_ON | (0x1000) Display memory allocate and
        // free usage information.

#define DBG_BUFFER_ON       0x2000L
        // @emem DBG_BUFFER_ON | (0x2000) Display buffer allocate and
        // free usage information.

#define DBG_PACKET_ON       0x4000L
        // @emem DBG_PACKET_ON | (0x4000) Display packet allocate and
        // free usage information.

#define DBG_BREAK_ON        0x8000L
        // @emem DBG_BREAK_ON | (0x8000) Enable <f DBG_BREAK> breakpoints.

#define DbgFlags            DebugFlags      // For compatability
#define DbgID               AnsiDeviceName  // For compatability

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/* @doc INTERNAL TpiDebug TpiDebug_h DBG_SETTINGS


@struct DBG_SETTINGS |

    This structure is used to control debug output for a given module.
    You can set and clear bits in the DbgFlags field to enabled and
    disable various debug macros.  See <t DBG_FLAGS> to determine which 
    bits to set.

*/

typedef struct DBG_SETTINGS
{
    unsigned long DbgFlags;                                 // @field
    // Debug flags control how much debug is displayed in the checked build.
    // Put this field at the front so you can set it easily with debugger.
    // See <t DBG_FLAGS> to determine which bits to set in this field.

    unsigned char DbgID[12];                                // @field
    // This field is initialized to an ASCII string containing a unique
    // module identifier.  It is used to prefix debug messages.  If you
    // have more than one module based on this code, you may want to
    // change the default value to a unqiue string for each module.
    // This string is used a C string, so the last byte must be a zero.

} DBG_SETTINGS, *PDBG_SETTINGS;

extern PDBG_SETTINGS DbgInfo;


/* @doc INTERNAL TpiDebug TpiDebug_h DBG_FIELD_TABLE


@struct DBG_FIELD_TABLE |

    This structure contains the data associated with a C data structure.
    You can use the <f DBG_FIELD_ENTRY> macro to add entries into a
    <t DBG_FIELD_TABLE>.  At run-time you can pass this table pointer to
    the <f DbgPrintFieldTable> routine, and it will display the current
    contents of that data structure.  This is useful for debugging drivers
    or code where no symbolic debugger is available, or if you have want to
    dump structure contents when certain run-time events are encountered.

@comm

    If you have nested structures, you must display them separately.  The
    <f DBG_FIELD_ENTRY> macro can only be used to declare integer type
    fields, and pointers.  Pointers will be displayed as a long integer.<nl>

    The last entry in the table must be all zeros {0}.

*/

typedef struct DBG_FIELD_TABLE
{
    unsigned int    FieldOffset;                            // @parm
    // This value indicates the offset, in bytes, from the <f pBaseContext>
    // pointer passed into <f DbgPrintFieldTable>.  The value for the field
    // will be displayed from this offset from <f pBaseContext>.
    // <nl>*(PUINT)((PUCHAR)BaseContext+Offset) = (UINT) Value;

    unsigned int    FieldType;                              // @parm
    // This value determines how the value will be displayed.
    // <f FieldType> can be one of the following values:
    // <nl>1=UCHAR  - unsigned char integer (8 bits).
    // <nl>2=USHORT - unsigned short integer (16 bits).
    // <nl>4=ULONG  - unsigned long integer (32 bits).

    unsigned char * FieldName;                              // @parm
    // This value points to a C String which is the name of the field within
    // the structure.

} DBG_FIELD_TABLE, *PDBG_FIELD_TABLE;

#define DBG_FIELD_BUFF      0
#define DBG_FIELD_CHAR      1
#define DBG_FIELD_SHORT     2
#define DBG_FIELD_LONG      4

#define DBG_FIELD_OFFSET(Strct, Field) ((unsigned int)((unsigned char *) &((Strct *) 0)->Field))
#define DBG_FIELD_SIZEOF(Strct, Field) sizeof(((Strct *) 0)->Field)
#define DBG_FIELD_ENTRY(Strct, Field) \
    { DBG_FIELD_OFFSET(Strct, Field), \
      DBG_FIELD_SIZEOF(Strct, Field), \
      #Field )

extern VOID DbgPrintFieldTable(
    IN PDBG_FIELD_TABLE     pFields,
    IN unsigned char *               pBaseContext,
    IN unsigned char *               pBaseName
    );

extern VOID DbgPrintData(
    IN unsigned char *               Data,
    IN unsigned int                 NumBytes,
    IN unsigned long                Offset
    );

extern VOID DbgQueueData(
    IN unsigned char *               Data,
    IN unsigned int                 NumBytes,
    IN unsigned int                 Flags
    );

#if !defined(NDIS_WIN) || !defined(DEBUG)
extern unsigned long __cdecl DbgPrint(char * Format, ...);
#endif

// DbgBreakPoint is ugly because it is defined by NTDDK as _stdcall,
// and 95DDK #defines it, and we must define our own for non-DDK builds.
// So all these ifdefs are used to figure out how to handle it.
#ifdef DbgBreakPoint
#   undef DbgBreakPoint
#endif // DbgBreakPoint

#if defined(_MSC_VER) && (_MSC_VER <= 800)
    // Must be building with 16-bit compiler
    extern VOID __cdecl DbgBreakPoint(VOID);
#else
    // Must be building with 32-bit compiler
    extern VOID __stdcall DbgBreakPoint(VOID);
#endif

extern VOID DbgSilentQueue(unsigned char * str);

#ifdef __cplusplus
};
#endif // __cplusplus

// NDIS builds define DBG=0 or DBG=1
#if defined(DEBUG) || defined(_DEBUG)
# ifndef DBG
#  define DBG 1
# endif
#else
# ifndef DBG
#  define DBG 0
# endif
#endif

//###############################################################################
#if DBG
//###############################################################################

#ifndef ASSERTS_ENABLED
#   define ASSERTS_ENABLED  1
#endif

#ifndef DBG_DEFAULTS
#   define DBG_DEFAULTS (DBG_ERROR_ON | DBG_WARNING_ON | DBG_BREAK_ON)
#endif

/* @doc INTERNAL TpiDebug TpiDebug_h


*/

#   define STATIC
#   define DBG_STATIC
    // Make all variables and functions global, so debugger can see them.

#   define TRAPFAULT        DbgBreakPoint()
    // Use this macro to insert an unconditional INT-1 breakpoint.  This
    // is used to distinguish between normal debugger breakpoints (INT-3)
    // and any special cases, such as ASSERT.

#   define BREAKPOINT       DbgBreakPoint()
    // Use this macro to insert an unconditional INT-3 breakpoint.

#   define DBG_FUNC(F)      static const char __FUNC__[] = F;
    // @func const char [] | DBG_FUNC |
    //
    // Use this macro to define the __FUNC__ string used by the rest of the
    // debugger macros to report the name of the function calling the macro.
    //
    // @parm const char * | FunctionName | Name of the function being defined.
    //
    // @ex <tab> | DBG_FUNC("MyFunctionName");

#   define DBG_BREAK(A)     {if ((A) && ((A)->DbgFlags & DBG_BREAK_ON) || !(A)) \
                                BREAKPOINT;}
    // @func VOID | DBG_BREAK |
    //
    // Use this macro to insert a conditional INT-3 breakpoint.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_BREAK(DbgInfo);

#   define DBG_ENTER(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON)) \
                                {DbgPrint("%s:>>>:%s\n",(A)->DbgID,__FUNC__);}}
    // @func VOID | DBG_ENTER |
    //
    // Use this macro to report entry to a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_ENTER(DbgInfo);

#   define DBG_TRACE(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON)) \
                                {DbgPrint("%s:%d:%s\n",(A)->DbgID,__LINE__,\
                                 __FUNC__);}}
    // @func VOID | DBG_TRACE |
    //
    // Use this macro to report a trace location within a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_TRACE(DbgInfo);

#   define DBG_LEAVE(A)     {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON))  \
                                {DbgPrint("%s:<<<:%s\n",(A)->DbgID,__FUNC__);}}
    // @func VOID | DBG_LEAVE |
    //
    // Use this macro to report exit from a function.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_LEAVE(DbgInfo);

#   define DBG_RETURN(A,S)  {if ((A) && ((A)->DbgFlags & DBG_TRACE_ON))  \
                                {DbgPrint("%s:<<<:%s Return(0x%lX)\n",(A)->DbgID,__FUNC__,S);}}
    // @func VOID | DBG_RETURN |
    //
    // Use this macro to report exit from a function with a result.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_RETURN(DbgInfo, Result);

#   define DBG_ERROR(A,S)   {if ((A) && ((A)->DbgFlags & DBG_ERROR_ON))   \
                                {DbgPrint("%s:ERROR:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S; \
                                 if ((A)->DbgFlags & DBG_BREAK_ON) \
                                    {TRAPFAULT;}}}
    // @func VOID | DBG_ERROR |
    //
    // Use this macro to report any unexpected error conditions.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_ERROR(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_WARNING(A,S) {if ((A) && ((A)->DbgFlags & DBG_WARNING_ON)) \
                                {DbgPrint("%s:WARNING:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_WARNING |
    //
    // Use this macro to report any unusual run-time conditions.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_WARNING(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_NOTICE(A,S)  {if ((A) && ((A)->DbgFlags & DBG_NOTICE_ON))  \
                                {DbgPrint("%s:NOTICE:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_NOTICE |
    //
    // Use this macro to report any verbose debug information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_NOTICE(DbgInfo, ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_REQUEST(A,S)  {if ((A) && ((A)->DbgFlags & DBG_REQUEST_ON))  \
                                {DbgPrint("%s:REQUEST:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_REQUEST |
    //
    // Use this macro to report NDIS Set/Query request information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_REQUEST(DbgInfo, ("Oid #0x%08X - %s\n", Oid, DbgGetOidString(Oid)));

#   define DBG_PARAMS(A,S)  {if ((A) && ((A)->DbgFlags & DBG_PARAMS_ON))  \
                                {DbgPrint("%s:PARAMS:%s ",(A)->DbgID,__FUNC__);\
                                 DbgPrint S;}}
    // @func VOID | DBG_PARAMS |
    //
    // Use this macro to report NDIS Set/Query request information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @ex <tab> | DBG_PARAMS(DbgInfo, ("\n\tNum=0x%X\n\tStr='%s'\n", Num, Str));

#   define DBG_TX(A,I,N,B)  {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Tx%d:%03X:\n",(A)->DbgID,I,N); \
                                if (((A)->DbgFlags & DBG_TXRX_VERBOSE_ON))  \
                                    DbgPrintData((unsigned char *)B, (unsigned int)N, 0); \
                                else if (((A)->DbgFlags & DBG_TXRX_HEADERS_ON))  \
                                    DbgPrintData((unsigned char *)B, 0x10, 0); \
                                }\
                             if ((A) && ((A)->DbgFlags & DBG_TXRX_LOG_ON)) \
                                DbgQueueData((unsigned char *)B, (unsigned int)N, \
                                              (USHORT)((I<< 8) + 0x4000)); \
                            }
    // @func VOID | DBG_TX |
    //
    // Use this macro to report outgoing packet information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @parm IN UINT | NumBytes | Number of bytes being transmitted.
    //
    // @parm IN PUCHAR | Buffer | Pointer to data buffer being transmitted.
    //
    // @ex <tab> | DBG_TX(DbgInfo, BChannelIndex, BytesToSend, CurrentBuffer);

#   define DBG_TXC(A,I)     {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Tc%d\n",(A)->DbgID,I); \
                                }}
    // @func VOID | DBG_TXC |
    //
    // Use this macro to report outgoing packet completion.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @ex <tab> | DBG_TXC(DbgInfo, BChannelIndex);

#   define DBG_RX(A,I,N,B)  {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Rx%d:%03X:\n",(A)->DbgID,I,N); \
                                if (((A)->DbgFlags & DBG_TXRX_VERBOSE_ON))  \
                                    DbgPrintData((unsigned char *)B, (unsigned int)N, 0); \
                                else if (((A)->DbgFlags & DBG_TXRX_HEADERS_ON))  \
                                    DbgPrintData((unsigned char *)B, 0x10, 0); \
                                }\
                             if ((A) && ((A)->DbgFlags & DBG_TXRX_LOG_ON)) \
                                DbgQueueData((unsigned char *)B, (unsigned int)N, \
                                              (USHORT)((I<< 8) + 0x8000)); \
                            }
    // @func VOID | DBG_RX |
    //
    // Use this macro to report incoming packet information.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @parm IN UINT | NumBytes | Number of bytes being received.
    //
    // @parm IN PUCHAR | Buffer | Pointer to data buffer being received.
    //
    // @ex <tab> | DBG_RX(DbgInfo, BChannelIndex, BytesReceived, ReceiveBuffer);

#   define DBG_RXC(A,I)     {if ((A) && ((A)->DbgFlags & (DBG_TXRX_ON | \
                                                          DBG_TXRX_VERBOSE_ON | \
                                                          DBG_TXRX_HEADERS_ON))) \
                                {DbgPrint("%s:Rc%d\n",(A)->DbgID,I); \
                                }}
    // @func VOID | DBG_RXC |
    //
    // Use this macro to report incoming packet completion.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN UINT | Index | Index used to identify channel or stream.
    //
    // @ex <tab> | DBG_RXC(DbgInfo, BChannelIndex);

#   define DBG_FILTER(A,M,S){if ((A) && ((A)->DbgFlags & (M)))            \
                                {DbgPrint("%s:%s: ",(A)->DbgID,__FUNC__); \
                                 DbgPrint S;}}
    // @func VOID | DBG_FILTER |
    //
    // Use this macro to filter for specific DbgFlag combinations.
    //
    // @parm IN DBG_SETTINGS | DbgInfo | Pointer to <t DBG_SETTINGS> structure.
    //
    // @parm IN DBG_FLAGS | DbgMask | OR'd mask of <t DBG_FLAGS>.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_FILTER(DbgInfo, DBG_FILTER1_ON | DBG_REQUEST_ON,
    //                 ("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_DISPLAY(S)   {DbgPrint("%s: ",__FUNC__); DbgPrint S;}
    // @func VOID | DBG_DISPLAY |
    //
    // Use this macro to unconditionally report a message.  This macro does
    // not take a pointer to the DBG_SETTINGS structure, so it can be used in
    // any module or function of the driver.  There is no way to disable the
    // display of these messages.  The funcion name precedes the output string.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_DISPLAY(("Expected %d - Actual %d\n", Expected, Actual));

#   define DBG_PRINT(S)     {DbgPrint S;}
    // @func VOID | DBG_PRINT |
    //
    // Use this macro to unconditionally report a message.  This macro does
    // not take a pointer to the DBG_SETTINGS structure, so it can be used in
    // any module or function of the driver.  There is no way to disable the
    // display of these messages.
    //
    // @parm PRINTF_ARGS | PrintfArgs | Parenthesized, printf format string,
    //                                  followed by parameters.
    //
    // @ex <tab> | DBG_PRINT(("What happened at line %d!\n",__LINE__));

//###############################################################################
#else // !DBG
//###############################################################################

#ifndef ASSERTS_ENABLED
#   define ASSERTS_ENABLED  0
#endif

#   define DBG_DEFAULTS (0)

/*
// When (DBG == 0) we disable all the debug macros.
*/

#   define STATIC           static
#   define DBG_STATIC       static
#   define TRAPFAULT        DbgBreakPoint()
#   define BREAKPOINT
#   define DBG_FUNC(F)
#   define DBG_BREAK(A)
#   define DBG_ENTER(A)
#   define DBG_TRACE(A)
#   define DBG_LEAVE(A)
#   define DBG_RETURN(A,S)
#   define DBG_ERROR(A,S)
#   define DBG_WARNING(A,S)
#   define DBG_NOTICE(A,S)
#   define DBG_REQUEST(A,S)
#   define DBG_PARAMS(A,S)
#   define DBG_TX(A,I,N,P)
#   define DBG_TXC(A,I)
#   define DBG_RX(A,I,N,P)
#   define DBG_RXC(A,I)
#   define DBG_FILTER(A,M,S)
#   define DBG_DISPLAY(S)
#   define DBG_PRINT(S)

//###############################################################################
#endif // DBG
//###############################################################################

#ifdef ASSERT
#   undef ASSERT
#endif
#ifdef assert
#   undef  assert
#endif

#if ASSERTS_ENABLED
#define ASSERT(C)   if (!(C)) { \
                        DbgPrint("ASSERT(%s) -- FILE:%s LINE:%d\n", \
                                 #C, __FILE__, __LINE__); \
                        TRAPFAULT; \
                    }
    // @func VOID | ASSERT |
    //
    // Use this macro to conditionally report a fatal error if the condition
    // specified is NOT true.
    //
    // @parm BOOLEAN_EXPRESSION | Expression | Any valid if (Expression).
    //
    // @ex <tab> | ASSERT(Actual == Expected);

#   define assert(C) ASSERT(C)
#else // !ASSERTS_ENABLED
#   define ASSERT(C)
#   define assert(C)
#endif // ASSERTS_ENABLED


#endif // _TPIDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\tpiparam.h ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1994 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the same terms
        outlined in the Microsoft Windows Device Driver Development Kit.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL TpiParam TpiParam_h

@module TpiParam.h |

    This module, along with <f TpiParam\.c>, implements a table driven parser
    for the NDIS registry parameters.  This file defines the parameter
    parsing structures and values used by the routine <f ParamParseRegistry>.
    You should #include this file into the driver module defining the
    configuration parameter table <t PARAM_TABLE>.

@comm

    See <f Keywords\.h> for details of how to add new parameters.

    This is a driver independent module which can be re-used, without
    change, by any NDIS3 driver.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | TpiParam_h

@end

*/

#ifndef _TPIPARAM_H
#define _TPIPARAM_H

#if !defined(NDIS_NT) && !defined(UNICODE_NULL)

/*
// These types were culled from the NT ndis.h file
// We should be compiling with the NT DDK's ndis.h to get these,
// but sometimes we need to compile with the 95 DDK ndis.h.
*/

#undef PUNICODE_STRING
typedef USHORT  WCHAR;
typedef WCHAR   *PWSTR;

typedef STRING  ANSI_STRING;
typedef PSTRING PANSI_STRING;

/*
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
*/

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;

typedef UNICODE_STRING *PUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

#endif // NDIS_NT

/* @doc INTERNAL TpiParam TpiParam_h PARAM_ENTRY


@func <t PARAM_TABLE> | PARAM_ENTRY |

    This macro is used to define an entry in the registry parameter table,
    one entry per parameter.  See <t PARAM_TABLE> for more details on the
    expected input values.

@parm struct | Strct | The structure type associated with <f Field>.

@parm type | Field | The name of the field within the structure <f Strct>.

@parm const char * | Name | The name of the registry parameter key.

@parm BOOL | Required | True if parameter is required.

@parm NDIS_PARAMETER_TYPE | Type | The kind of parameter value.

@parm UCHAR | Flags | How to return a string parameter value (ANSI, UNICODE).

@parm UINT | Default | The default value for an undefined integer parameter.

@parm UINT | Min | The minimum value for an integer parameter.

@parm UINT | Max | The minimum value for an integer parameter.

@comm
    Parameters that need to be stored in different data structures, need to
    be declared in separate parameter tables, and then parsed separately
    using mulitple calls to <f ParamParseRegistry>.

@iex
    PARAM_TABLE ParameterTable[] =
    {
        PARAM_ENTRY(MINIPORT_CONTEXT, DbgFlags, PARAM_DEBUGFLAGS_STRING,
                    FALSE, NdisParameterHexInteger, 0,
                    DBG_ERROR_ON|DBG_WARNING_ON, 0, 0xffffffff),
        // The last entry must be an empty string!
        { { 0 } }
    };

@normal
*/
#define PARAM_OFFSET(Strct, Field) ((ULONG)(ULONG_PTR)&(((Strct *)0)->Field))
#define PARAM_SIZEOF(Strct, Field) sizeof(((Strct *) 0)->Field)
#define PARAM_ENTRY(Strct, Field, Name, \
                    Required, Type, Flags, \
                    Default, Min, Max) \
    { NDIS_STRING_CONST(Name), \
      Required, \
      Type, \
      Flags, \
      PARAM_SIZEOF(Strct, Field), \
      PARAM_OFFSET(Strct, Field), \
      (PVOID) (Default), \
      Min, \
      Max }


/* @doc INTERNAL TpiParam TpiParam_h PARAM_TABLE


@struct PARAM_TABLE |
    This structure defines how a parameter is to be parsed from the Windows
    registry.  The driver declares an array of these parameter records and
    passes it to <f ParamParseRegistry> during initialization.  The values
    for each parameter are then read from the registry and can be used to
    configure the driver.
    <nl>
    <f Note>: Multiple parameter tables can be used to parse parameters that
    must be stored in different memory locations.
*/
typedef struct PARAM_TABLE
{
    NDIS_STRING     RegVarName; // @field
    // Parameter name string declared as an <t NDIS_STRING>.  The registry
    // parameter key must match this string.

    UCHAR           Mandantory; // @field
    // Set to FALSE, zero, if parameter value is optional; otherwise set to
    // TRUE, non-zero, if the parameter is required to exist in the registry.
    // If FALSE, and the parameter does not exist, the <y Default> value will
    // be returned.  If TRUE, and the parameter does not exist, an error code
    // is returned and no further parsing is done.

    UCHAR           Type;       // @field
    // This value determines how the parameter will be parsed from the
    // registry.  The value can be one of the following values defined
    // by <t NDIS_PARAMETER_TYPE>.
    // <nl>0=NdisParameterInteger - Decimal integer value.
    // <nl>1=NdisParameterHexInteger - Hexadecimal integer value.
    // <nl>2=NdisParameterString - Single UNICODE string value.
    // <nl>3=NdisParameterMultiString - Multiple UNICODE string values.
    // These are returned as a list of N strings, separated by NULL
    // terminators, the last string is followed by two NULL terminators.

    UCHAR           Flags;      // @field
    // This value determines how a string parameter will be translated before
    // it is returned to the caller.  <f Flags> can be one of the following
    // values:
    // <nl>0=PARAM_FLAGS_ANSISTRING - Return string value as an ANSI string.
    // <nl>0=PARAM_FLAGS_ANSISTRING - Return string value as a UNICODE string.
#   define          PARAM_FLAGS_ANSISTRING      0
#   define          PARAM_FLAGS_UNICODESTRING   1

    UCHAR           Size;       // @field
    // This value determines how an integer parameter will be translated
    // before it is returned to the caller.  <f Size> can be one of the
    // following values:
    // <nl>0=UINT   - unsigned integer (16 or 32 bits).
    // <nl>1=UCHAR  - unsigned char integer (8 bits).
    // <nl>2=USHORT - unsigned short integer (16 bits).
    // <nl>4=ULONG  - unsigned long integer (32 bits).
    // <f Note>: The most-significant bits will be truncated in the conversion.

    UINT            Offset;     // @field
    // This value indicates the offset, in bytes, from the <f BaseContext>
    // pointer passed into <f ParamParseRegistry>.  The return value for
    // the parameter will be saved at this offset from <f BaseContext>.
    // <nl>*(PUINT)((PUCHAR)BaseContext+Offset) = (UINT) Value;

    PVOID           Default;    // @field
    // This value is used as the default value for the parameter if it is
    // not found in the registry, and it is not mandatory.  This only applys
    // to integer parameters.  String parameters must provide support for
    // their own default values.

    UINT            Min;        // @field
    // If this value is non-zero, and the parameter is an integer type, the
    // registry value will be compared to make sure it is \>= <f Min>.
    // If the registry value is less, the returned value will be set to
    // <f Min> and no error is returned.

    UINT            Max;        // @field
    // If this value is non-zero, and the parameter is an integer type, the
    // registry value will be compared to make sure it is \<= <f Max>.
    // If the registry value is greater, the returned value will be set to
    // <f Max> and no error is returned.

    UINT            Reserved;   // @field
    // This field is not currently used, and it must be zero for future
    // compatability.

} PARAM_TABLE, *PPARAM_TABLE;

extern USHORT ustrlen(
    IN PUSHORT          string
    );

extern NDIS_STATUS ParamParseRegistry(
    IN NDIS_HANDLE      AdapterHandle,
    IN NDIS_HANDLE      RegistryConfigHandle,
    IN PUCHAR           BaseContext,
    IN PPARAM_TABLE     Parameters
    );

extern VOID ParamUnicodeStringToAnsiString(
    OUT PANSI_STRING out,
    IN PUNICODE_STRING in
    );

extern VOID ParamUnicodeCopyString(
    OUT PUNICODE_STRING out,
    IN PUNICODE_STRING in
    );

#endif // _TPIPARAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ndis\samples\isdnwan\transmit.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Transmit Transmit_c

@module Transmit.c |

    This module implements the Miniport packet Transmit routines. This module is
    very dependent on the hardware/firmware interface and should be looked at
    whenever changes to these interfaces occur.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Transmit_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 3.3 Sending Packets |

    <f MiniportWanSend> transmits a packet through the adapter
    onto the network.

    Ownership of both the packet descriptor and the packet data
    is transferred to the WAN NIC driver until this request is
    completed, either synchronously or asynchronously. If the
    WAN miniport returns NDIS_STATUS_PENDING, it must later
    indicate completion of the request by calling NdisMWanSendComplete.
    If the WAN miniport returns a status other than NDIS_STATUS_PENDING,
    the request is considered to be complete, and ownership of the packet
    immediately reverts to the caller.

    Unlike LAN miniports, the WAN driver cannot return a status of
    NDIS_STATUS_RESOURCES to indicate that it does not have enough
    resources currently available to process the transmit. Instead,
    the WAN miniport should queue the send internally for a later
    time and perhaps lower the SendWindow value on the line by
    making a line-up indication. The NDISWAN driver will insure
    that the WAN miniport driver never has more than SendWindow
    packets outstanding. If a WAN miniport makes a line-up indication
    for a particular line, and sets the SendWindow to zero, NDISWAN
    reverts to using the default value of the transmit window passed
    as the MaxTransmit value provided to an earlier OID_WAN_GET_INFO
    request.

    It is also an error for the WAN miniport NIC driver to
    call NdisMSendResourcesAvailable.

    The packet passed to <f MiniportWanSend> will contain simple HDLC
    PPP framing if PPP framing is set. For SLIP or RAS framing, the
    packet contains only the data portion with no framing whatsoever.
    Simple HDLC PPP framing is discussed later in more detail.

    A WAN NIC driver must not attempt to provide software loopback or
    promiscuous mode loopback. Both of these are fully supported in
    the NDISWAN driver.

    The MacReservedx members as well as the WanPacketQueue member of
    the <t NDIS_WAN_PACKET> is fully available for use by the WAN miniport.

    The available header padding is simply CurrentBuffer-StartBuffer.
    The available tail padding is EndBuffer-(CurrentBuffer+CurrentLength).
    The header and tail padding is guaranteed to be at least the amount
    requested, but it can be more.

    See <t NDIS_WAN_PACKET> in the Network Driver Reference for details of
    the WAN packet descriptor structure.

    A WAN miniport calls NdisMWanSendComplete to indicate that it has
    completed a previous transmit operation for which it returned
    NDIS_STATUS_PENDING. This does not necessarily imply that the
    packet has been transmitted, although, with the exception of
    intelligent adapters, it generally has. It does however, mean
    the miniport is ready to release ownership of the packet.

    When a WAN miniport calls NdisMWanSendComplete, it passes back
    the original packet to indicate which send operation was completed.
    If <f MiniportWanSend> returns a status other than NDIS_STATUS_PENDING,
    it does not call NdisMWanSendComplete for that packet.

@end
*/

#define  __FILEID__             TRANSMIT_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


/* @doc INTERNAL Transmit Transmit_c TransmitAddToQueue


@func

    <f TransmitAddToQueue> places the packet on the transmit queue.  If the
    queue was empty to begin with, TRUE is returned so the caller can kick
    start the transmiter.

@rdesc

    <f TransmitAddToQueue> returns TRUE if this is the only entry in the
    list, FALSE otherwise.

*/

DBG_STATIC BOOLEAN TransmitAddToQueue(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter,                   // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.

    IN PBCHANNEL_OBJECT         pBChannel,                  // @parm
    // A pointer to the <t BCHANNEL_OBJECT> returned by <f BChannelCreate>.

    IN PNDIS_WAN_PACKET         pWanPacket                  // @parm
    // A pointer to the associated NDIS packet structure <t NDIS_WAN_PACKET>.
    )
{
    DBG_FUNC("TransmitAddToQueue")

    /*
    // Note if the list is empty to begin with.
    */
    BOOLEAN     ListWasEmpty;

    DBG_ENTER(pAdapter);

    /*
    // Place the packet on the TransmitPendingList.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);
    ListWasEmpty = IsListEmpty(&pAdapter->TransmitPendingList);
    InsertTailList(&pAdapter->TransmitPendingList, &pWanPacket->WanPacketQueue);
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    DBG_RETURN(pAdapter, ListWasEmpty);
    return (ListWasEmpty);
}


/* @doc INTERNAL Transmit Transmit_c TransmitPacketHandler


@func

    <f TransmitPacketHandler> removes an entry from the TransmitPendingList
    and places the packet on the appropriate B-channel and starts the
    transmission.  The packet is then placed on the <t TransmitBusyList> to
    await a transmit complete event processed by <f TransmitCompleteHandler>.

@comm

    The packets go out in a FIFO order for the entire driver, independent of
    the channel on which it goes out.  This means that a slow link, or one
    that is backed up can hold up all other channels.  There is no good way
    to get around this because we must to deliver packets in the order they
    are given to the Miniport, regardless of the link they are on.

*/

DBG_STATIC VOID TransmitPacketHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("TransmitPacketHandler")

    PNDIS_WAN_PACKET            pWanPacket;
    // Holds the packet being transmitted.

    USHORT                      BytesToSend;
    // Tells us how many bytes are to be transmitted.

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);

    /*
    // MUTEX to protect against async EventHandler access at the same time.
    */
    NdisAcquireSpinLock(&pAdapter->TransmitLock);

#if DBG
    {   // Sanity check!
        PLIST_ENTRY pList = &pAdapter->TransmitPendingList;
        ASSERT(pList->Flink && pList->Flink->Blink == pList);
        ASSERT(pList->Blink && pList->Blink->Flink == pList);
    }
#endif // DBG

    /*
    // This might be called when no packets are queued!
    */
    while (!IsListEmpty(&pAdapter->TransmitPendingList))
    {
        /*
        // Remove the packet from the TransmitPendingList.
        */
        pWanPacket = (PNDIS_WAN_PACKET)RemoveHeadList(&pAdapter->TransmitPendingList);

        /*
        // Release MUTEX
        */
        NdisReleaseSpinLock(&pAdapter->TransmitLock);

        /*
        // Retrieve the information we saved in the packet reserved fields.
        */
        pBChannel = (PBCHANNEL_OBJECT) pWanPacket->MacReserved1;

        /*
        // Make sure the link is still up and can accept transmits.
        */
        if (pBChannel->CallState != LINECALLSTATE_CONNECTED)
        {
            /*
            // Indicate send complete failure to the NDIS wrapper.
            */
            DBG_WARNING(pAdapter,("Flushing send on link#%d (Packet=0x%X)\n",
                      pBChannel->BChannelIndex, pWanPacket));
            if (pBChannel->NdisLinkContext)
            {
                NdisMWanSendComplete(pAdapter->MiniportAdapterHandle,
                                     pWanPacket, NDIS_STATUS_FAILURE);
            }

            /*
            // Reacquire MUTEX
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
        }
        else
        {
            BytesToSend = (USHORT) pWanPacket->CurrentLength;
            pAdapter->TotalTxBytes += BytesToSend;
            pAdapter->TotalTxPackets++;

            /*
            // Attempt to place the packet on the NIC for transmission.
            */
            if (!CardTransmitPacket(pAdapter->pCard, pBChannel, pWanPacket))
            {
                /*
                // ReQueue the packet on the TransmitPendingList and leave.
                // Reacquire MUTEX
                */
                NdisAcquireSpinLock(&pAdapter->TransmitLock);
                InsertHeadList(&pAdapter->TransmitPendingList, &pWanPacket->WanPacketQueue);
                break;
            }
            DBG_TX(pAdapter, pBChannel->BChannelIndex,
                   BytesToSend, pWanPacket->CurrentBuffer);

            /*
            // Reacquire MUTEX
            */
            NdisAcquireSpinLock(&pAdapter->TransmitLock);
        }
    }
    /*
    // Release MUTEX
    */
    NdisReleaseSpinLock(&pAdapter->TransmitLock);

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Transmit Transmit_c TransmitCompleteHandler


@func

    <f TransmitCompleteHandler> is called by <f MiniportTimer> to handle a
    transmit complete event.  We walk the <t TransmitCompleteList> to find
    all the packets that have been sent out on the wire, and then tell the
    protocol stack that we're done with the packet, and it can be re-used.

*/

VOID TransmitCompleteHandler(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("TransmitCompleteHandler")

    PNDIS_WAN_PACKET            pWanPacket;
    // Holds the packet that's just been transmitted.

    PBCHANNEL_OBJECT            pBChannel;
    // A pointer to one of our <t BCHANNEL_OBJECT>'s.

    DBG_ENTER(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (++(pAdapter->NestedDataHandler) > 1)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d > 1\n",
                  pAdapter->NestedDataHandler));
    }

    /*
    // MUTEX to protect against async EventHandler access at the same time.
    */
    NdisDprAcquireSpinLock(&pAdapter->TransmitLock);

#if DBG
    {   // Sanity check!
        PLIST_ENTRY pList = &pAdapter->TransmitCompleteList;
        ASSERT(pList->Flink && pList->Flink->Blink == pList);
        ASSERT(pList->Blink && pList->Blink->Flink == pList);
    }
#endif // DBG

    while (!IsListEmpty(&pAdapter->TransmitCompleteList))
    {
        /*
        // Remove the packet from the TransmitCompleteList.
        */
        pWanPacket = (PNDIS_WAN_PACKET)RemoveHeadList(&pAdapter->TransmitCompleteList);

        /*
        // Release MUTEX
        */
        NdisDprReleaseSpinLock(&pAdapter->TransmitLock);

        /*
        // Retrieve the information we saved in the packet reserved fields.
        */
        pBChannel = (PBCHANNEL_OBJECT) pWanPacket->MacReserved1;

        /*
        // Indicate send complete to the NDIS wrapper.
        */
        DBG_TXC(pAdapter, pBChannel->BChannelIndex);
        NdisMWanSendComplete(pAdapter->MiniportAdapterHandle,
                             pWanPacket, NDIS_STATUS_SUCCESS);

        /*
        // Reacquire MUTEX
        */
        NdisDprAcquireSpinLock(&pAdapter->TransmitLock);
    }
    /*
    // Release MUTEX
    */
    NdisDprReleaseSpinLock(&pAdapter->TransmitLock);

    /*
    // Start any other pending transmits.
    */
    TransmitPacketHandler(pAdapter);

    /*
    // I find it useful to do this nest check, just so I can make sure
    // I handle it correctly when it happens.
    */
    if (--(pAdapter->NestedDataHandler) < 0)
    {
        DBG_ERROR(pAdapter,("NestedDataHandler=%d < 0\n",
                  pAdapter->NestedDataHandler));
    }

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Transmit Transmit_c MiniportWanSend


@func

    <f MiniportWanSend> instructs a WAN driver to transmit a packet through
    the adapter onto the medium.

@iex

    typedef struct _NDIS_WAN_PACKET
    {
        LIST_ENTRY          WanPacketQueue;
        PUCHAR              CurrentBuffer;
        ULONG               CurrentLength;
        PUCHAR              StartBuffer;
        PUCHAR              EndBuffer;
        PVOID               ProtocolReserved1;
        PVOID               ProtocolReserved2;
        PVOID               ProtocolReserved3;
        PVOID               ProtocolReserved4;
        PVOID               MacReserved1;       // pBChannel
        PVOID               MacReserved2;
        PVOID               MacReserved3;
        PVOID               MacReserved4;

    } NDIS_WAN_PACKET, *PNDIS_WAN_PACKET;

@comm

    When <f MiniportWanSend> is called, ownership of both the packet descriptor and
    the packet data is transferred to the driver until it completes the given
    packet, either synchronously or asynchronously. If <f MiniportWanSend>
    returns a status other than NDIS_STATUS_PENDING, the request is
    considered complete and ownership of the packet immediately reverts
    to the initiator of the send request. If MiniportWanSend returns
    NDIS_STATUS_PENDING, the miniport subsequently must call
    NdisMWanSendComplete with the packet to indicate completion
    of the transmit request.

    MiniportWanSend can use both the <t MacReservedX> and <t WanPacketQueue>
    areas within the <t NDIS_WAN_PACKET> structure. However, the miniport
    cannot access the ProtocolReservedx members.

    Any NDIS intermediate driver that binds itself to an underlying
    WAN miniport is responsible for providing a fresh <t NDIS_WAN_PACKET>
    structure to the underlying driver's <f MiniportWanSend> function. Before
    such an intermediate driver calls NdisSend, it must repackage the send
    packet given to its MiniportWanSend function so the underlying driver
    will have MacReservedx and WanPacketQueue areas of its own to use.

    The available header padding within a given packet can be calculated
    as (CurrentBuffer - StartBuffer), the available tail paddin