       
    }                                                           
    v += sizeof(D3DVALUE) * 4;                                  
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)                   
    {                                                           
        pp1.color   = *(DWORD*)v;                               
        v += sizeof(D3DVALUE);                                  
                                                                
    }                                                           
    if (pv->dwVIDOut & D3DFVF_SPECULAR)                  
    {                                                           
        pp1.specular= *(DWORD*)v;                               
        v += sizeof(DWORD);                                     
    }                                                           
    memcpy(pp1.tex, v, pv->dwTextureCoordSizeTotal);
    pp1.clip = clipFlag; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\clipfunc.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipfunc.h
 *  Content:    Clipper functions
 *
 ***************************************************************************/

#ifndef _CLIPFUNC_H_
#define _CLIPFUNC_H_

#include "clipper.h"
#include "ddibase.h"

DWORD D3DFE_GenClipFlags(D3DFE_PROCESSVERTICES *pv);

//---------------------------------------------------------------------
// This function is called by the clipper to draw unclipped part of a primitive
//
inline HRESULT DRAW_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType,
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    try
    {
        pv->pDDI->DrawPrim(pv);
    }
    catch( HRESULT hr )
    {
        return hr;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// This function is called by the clipper to draw clipped part of a primitive
//
inline HRESULT DRAW_CLIPPED_PRIM(D3DFE_PROCESSVERTICES *pv, 
                         D3DPRIMITIVETYPE primitiveType, 
                         LPVOID startVertex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpvOut = startVertex;                                    
    pv->primType = primitiveType;                                
    pv->dwNumVertices = vertexCount;                             
    pv->dwNumPrimitives = numPrim;
    try
    {
        pv->pDDI->DrawClippedPrim(pv);
    }
    catch( HRESULT hr )
    {
        return hr;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
// This function is called by the clipper to draw unclipped part of an 
// indexed primitive
//
inline HRESULT DRAW_INDEX_PRIM(D3DFE_PROCESSVERTICES *pv, 
                               D3DPRIMITIVETYPE primitiveType, 
                               LPWORD startIndex, DWORD vertexCount, DWORD numPrim)
{
    pv->lpwIndices = startIndex;                                     
    pv->primType = primitiveType;                                    
    pv->dwNumIndices = vertexCount;                                  
    pv->dwNumPrimitives = numPrim;                                   
    try
    {
        pv->pDDI->DrawIndexPrim(pv);
    }
    catch( HRESULT hr )
    {
        return hr;
    }
    return D3D_OK;
}
//----------------------------------------------------------------------
// Clip a triangle made by 3 vertices
// bCanModifyVertices is set to TRUE, if the function can modify the original 
// vertices
//
HRESULT Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2, ClipVertex *cv3);
HRESULT ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, ClipVertex *cv2);

#endif // _CLIPFUNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\clipprim.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip primitives
 *
 * The following symbol should be defined before included this file:
 * __PROCESS_LINE_NAME  - name for a function to clip triangles
 * __INDEX_PRIM         - name for a function to clip lines
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
#ifdef __INDEX_PRIM
#define __DRAW DRAW_INDEX_PRIM
#else
#define __DRAW DRAW_PRIM
#endif

//*********************************************************************
HRESULT D3DFE_PVFUNCSI::__PROCESS_TRI_LIST_NAME(D3DFE_PROCESSVERTICES *pv)
{
    int vertexSize3;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    DWORD       dwIndexSize = pv->dwIndexSize;
    DWORD       dwIndexSize3 = pv->dwIndexSize * 3;
    // Start indexed of the current in-screen triangle batch
    WORD*       startVertex = pv->lpwIndices;
    // Start index of the current triangle
    LPBYTE      index = (LPBYTE)pv->lpwIndices;
#else
    // Start vertex of the current in-screen triangle batch
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        

#ifdef __INDEX_PRIM
    // Update the address of the vertex array to handle the index base
    if (pv->dwIndexOffset != 0)
    {
        vertex -= pv->dwIndexOffset * vertexSize;
        clipCode -= pv->dwIndexOffset;
    }
#endif

    vertexSize3 = vertexSize*3;
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;   // Current triangle indices
        if (dwIndexSize == 2)
        {
            v1 = *(WORD*)index;
            v2 = *(WORD*)(index + 2);
            v3 = *(WORD*)(index + 4);
        }
        else
        {
            v1 = *(DWORD*)index;
            v2 = *(DWORD*)(index + 4);
            v3 = *(DWORD*)(index + 8);
        }
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {// This tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                DWORD vertexCount = primitiveCount*3;
                ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                             vertexCount, primitiveCount);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = (WORD*)(index + dwIndexSize3);
#else
            pv->pDDI->SkipVertices(3);
            startVertex = vertex + vertexSize3;
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped
            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                p1 = vertex + v1*vertexSize;
                p2 = vertex + v2*vertexSize;
                p3 = vertex + v3*vertexSize;
#else
                p1 = vertex;
                p2 = vertex + vertexSize;
                p3 = p2 + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed);

#ifdef __INDEX_PRIM
#endif
                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
            primitiveCount++;
#ifdef __INDEX_PRIM
        index += dwIndexSize3;
#else
        clipCode += 3;
        vertex += vertexSize3;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLELIST, startVertex, 
                     primitiveCount*3, primitiveCount);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::__PROCESS_TRI_STRIP_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD lastIndex;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    DWORD       dwIndexSize = pv->dwIndexSize;
    LPWORD      startVertex = pv->lpwIndices;                               
    LPBYTE      index = (LPBYTE)pv->lpwIndices;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int           primitiveCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    primitiveCount = 0;                                        

#ifdef __INDEX_PRIM
    // Update the address of the vertex array to handle the index base
    if (pv->dwIndexOffset != 0)
    {
        vertex -= pv->dwIndexOffset * vertexSize;
        clipCode -= pv->dwIndexOffset;
    }
#endif

    lastIndex = pv->dwNumPrimitives;
    for (i=0; i < lastIndex; i++) 
    {
        DWORD f1, f2, f3;     // vertex clip flags
#ifdef __INDEX_PRIM
        DWORD v1, v2, v3;
        if (dwIndexSize == 2)
        {
            v1 = *(WORD*)index;
            v2 = *(WORD*)(index + 2);
            v3 = *(WORD*)(index + 4);
        }
        else
        {
            v1 = *(DWORD*)index;
            v2 = *(DWORD*)(index + 4);
            v3 = *(DWORD*)(index + 8);
        }
        f1 = clipCode[v1];
        f2 = clipCode[v2];
        f3 = clipCode[v3];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
        f3 = clipCode[2];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (primitiveCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                             primitiveCount+2, primitiveCount);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                // We need to re-use the last vertex of the unclipped primitive
                // So we move the PrimitiveBase and startVertex back
                pv->pDDI->MovePrimitiveBase(-1);
                startVertex = vertex - vertexSize;
#endif
            }
            else
            {
#ifndef __INDEX_PRIM
                // Move PrimitiveBase and UsedVertexCount
                pv->pDDI->SkipVertices(1);
                startVertex = vertex + vertexSize;
#endif
            }
            // reset count and start ptr
            primitiveCount = 0;
#ifdef __INDEX_PRIM
            startVertex = (LPWORD)(index + dwIndexSize);
#endif
            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p1;
                BYTE *p2;
                BYTE *p3;
#ifdef __INDEX_PRIM
                if (i & 1)
                { // For odd triangles we have to change orientation
                  // First vertex should remain the first, because it defines
                  // the color in FLAT shade mode
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v3*vertexSize;
                    p3 = vertex + v2*vertexSize;
                }
                else
                {
                    p1 = vertex + v1*vertexSize;
                    p2 = vertex + v2*vertexSize;
                    p3 = vertex + v3*vertexSize;
                }

#else
                p1 = vertex;
                if (i & 1)
                { // For odd triangles we have to change orientation
                    DWORD tmp = f2;
                    f2 = f3;
                    f3 = tmp;
                    p3 = vertex + vertexSize;
                    p2 = p3 + vertexSize;
                }
                else
                {
                    p2 = vertex + vertexSize;
                    p3 = p2 + vertexSize;
                }
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[2], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
        {
            if (primitiveCount == 0 && i & 1)
            { // Triangle strip can not start from an odd triangle
              // Because we use triangle fan, first vertex in the strip
              // should be the second in the fan. 
              // This vertex defines the color in FLAT shading case.
                BYTE tmp[__MAX_VERTEX_SIZE*3];
                BYTE *p = tmp;
#ifdef __INDEX_PRIM
                BYTE *saveVer = (BYTE*)pv->lpvOut;   
                DWORD numVer = pv->dwNumVertices;  
                memcpy (p, vertex + v2*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v1*vertexSize, vertexSize);
                p += vertexSize;
                memcpy (p, vertex + v3*vertexSize, vertexSize);
#else
                memcpy(p, vertex + vertexSize, vertexSize);
                p += vertexSize;
                memcpy(p, vertex, vertexSize);
                p += vertexSize;
                memcpy(p, vertex + vertexSize + vertexSize, vertexSize);
#endif
                pv->dwFlags |= D3DPV_NONCLIPPED; 
                ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, tmp, 3, 1);
                pv->dwFlags &= ~D3DPV_NONCLIPPED;
                if (ret)
                    return ret;
                primitiveCount = 0;
#ifdef __INDEX_PRIM
                startVertex = (LPWORD)(index + dwIndexSize);
                pv->lpvOut = saveVer;
                pv->dwNumVertices = numVer;
#else
                pv->pDDI->SkipVertices(1);
                startVertex = vertex + vertexSize;
#endif
            }   
            else
                primitiveCount++;
        }
#ifdef __INDEX_PRIM
        index += dwIndexSize;
#else
        clipCode++;
        vertex += vertexSize;
#endif
    }
    // draw final batch, if any
    if (primitiveCount) 
    {
        ret = __DRAW(pv, D3DPT_TRIANGLESTRIP, startVertex, 
                     primitiveCount+2, primitiveCount);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//-----------------------------------------------------------------------------
// The same functions is used for line lists and line strips
//
HRESULT D3DFE_PVFUNCSI::__PROCESS_LINE_NAME(D3DFE_PROCESSVERTICES *pv)
{
    DWORD nextLineOffset;       // How many vertices to skip, when going to 
                                // next primitive (1 for strips, 2 for lists)
    DWORD nextLineOffsetIndex;  // Multiplied by the index size
    DWORD countAdd;             // Used to compute "real" number of vertices
                                // from the vertexCount
    D3DPRIMITIVETYPE primType;
    int numPrim = 0;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
#ifdef __INDEX_PRIM
    LPWORD       startVertex = pv->lpwIndices;                               
    LPBYTE      index = (LPBYTE)pv->lpwIndices;                               
    DWORD       dwIndexSize = pv->dwIndexSize;
#else
    BYTE       *startVertex = (BYTE*)pv->lpvOut;
#endif
    int         vertexCount;    // Primitive count for line strips, 
                                // vertex count for line lists
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                          
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

#ifdef __INDEX_PRIM
    // Update the address of the vertex array to handle the index base
    if (pv->dwIndexOffset != 0)
    {
        vertex -= pv->dwIndexOffset * vertexSize;
        clipCode -= pv->dwIndexOffset;
    }
#endif

    primType = pv->primType;
    if (primType == D3DPT_LINESTRIP)
    {
#ifdef __INDEX_PRIM
        nextLineOffset = 1;
        nextLineOffsetIndex = dwIndexSize;
#else
        nextLineOffset = 1;
#endif
        countAdd = 1;
    }
    else
    {
#ifdef __INDEX_PRIM
        nextLineOffset = 2;
        nextLineOffsetIndex = dwIndexSize * 2;
#else
        nextLineOffset = 2;
#endif
        countAdd = 0;
    }
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        WORD f1, f2;
#ifdef __INDEX_PRIM
        DWORD v1, v2;
        if (dwIndexSize == 2)
        {
            v1 = *(WORD*)index;
            v2 = *(WORD*)(index + 2);
        }
        else
        {
            v1 = *(DWORD*)index;
            v2 = *(DWORD*)(index + 4);
        }
        f1 = clipCode[v1];
        f2 = clipCode[v2];
#else
        f1 = clipCode[0];
        f2 = clipCode[1];
#endif
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2) 
            offFrustum = TRUE;
        else
        if ((f1 | f2) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {      // if this line does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
                if (ret)
                    return ret;
#ifndef __INDEX_PRIM
                // For line strips we have to go one vertex back
                pv->pDDI->MovePrimitiveBase(-(int)countAdd);
                // Now go to the next primitive
                pv->pDDI->MovePrimitiveBase(nextLineOffset);
                startVertex = vertex + nextLineOffset*vertexSize;
#endif
            }
            else
            {
#ifndef __INDEX_PRIM
                pv->pDDI->SkipVertices(nextLineOffset);
                startVertex = vertex + nextLineOffset*vertexSize;
#endif
            }
            // reset count and start ptr
            vertexCount = 0;
            numPrim = 0;
#ifdef __INDEX_PRIM
            startVertex = (LPWORD)(index + nextLineOffsetIndex);
#endif

            // now deal with the single clipped line
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
#ifdef __INDEX_PRIM
                BYTE *p1 = vertex + v1*vertexSize;
                BYTE *p2 = vertex + v2*vertexSize;
#else
                BYTE *p1 = vertex;
                BYTE *p2 = vertex + vertexSize;
#endif
                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p1, f1, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p2, f2, vertexTransformed);

                ret = ClipLine(pv, &cv[0], &cv[1]);
                if (ret != D3D_OK)
                    return ret;
            }
        } 
        else 
        {
            vertexCount += nextLineOffset;
            numPrim++;
        }
#ifdef __INDEX_PRIM
        index += nextLineOffsetIndex;
#else
        vertex += nextLineOffset*vertexSize;
        clipCode += nextLineOffset;
#endif
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        ret = __DRAW(pv, primType, startVertex, vertexCount+countAdd, numPrim);
        if (ret)
            return ret;
    }
    return D3D_OK;
}

#undef __DRAW
#undef __INDEX_PRIM
#undef __PROCESS_LINE_NAME
#undef __PROCESS_TRI_LIST_NAME
#undef __PROCESS_TRI_STRIP_NAME
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\clipper.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clipper.h
 *  Content:    Clipper definitions
 *
 ***************************************************************************/
#ifndef _CLIPPER_H_
#define _CLIPPER_H_

//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define D3DCS_LEFTBIT     1
#define D3DCS_RIGHTBIT    2
#define D3DCS_TOPBIT      3
#define D3DCS_BOTTOMBIT   4
#define D3DCS_FRONTBIT    5
#define D3DCS_BACKBIT     6
#define D3DCLIPGB_LEFTBIT   13
#define D3DCLIPGB_RIGHTBIT  14
#define D3DCLIPGB_TOPBIT    15
#define D3DCLIPGB_BOTTOMBIT 16

//---------------------------------------------------------------------
// Make clip vertex from D3D vertex
//
// device - CD3DHal *
// pp1    - clipVertex
// p1     - TL vertex
//
void MAKE_CLIP_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, ClipVertex& pp1, BYTE* p1,                   
                         DWORD clipFlag, BOOL transformed);
//---------------------------------------------------------------------
// Make TL vertex from clip vertex
//
// device - CD3DHal *
// in    - clipVertex
// out   - TL vertex
//
inline void 
MAKE_TL_VERTEX_FVF(D3DFE_PROCESSVERTICES *pv, BYTE* out, ClipVertex* in)
{
    *(D3DVECTORH*)out = *(D3DVECTORH*)&(in)->sx;
    if (pv->dwVIDOut & D3DFVF_DIFFUSE)
        *(DWORD*)&out[pv->diffuseOffsetOut]  =  (in)->color;               
    if (pv->dwVIDOut & D3DFVF_SPECULAR)
        *(DWORD*)&out[pv->specularOffsetOut] =  (in)->specular;               
    memcpy(&out[pv->texOffsetOut], in->tex, pv->dwTextureCoordSizeTotal);
}

#endif // _CLIPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\dpclip.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpclip.c
 *  Content:    DrawPrimitive clipper
 *
 ***************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, 
                            ClipVertex *cv2, 
                            ClipVertex *cv3)
{
    ClipTriangle newtri;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    newtri.v[0] = cv1;
    newtri.v[1] = cv2;
    newtri.v[2] = cv3;

    int count;
    ClipVertex** ver;

    cv1->clip |= CLIPPED_ENABLE;
    cv2->clip |= CLIPPED_ENABLE;
    cv3->clip |= CLIPPED_ENABLE;
    // For the  flat shading mode we have to use first vertex color as 
    // color for all vertices
    D3DCOLOR diffuse1;          // Original colors
    D3DCOLOR specular1;
    D3DCOLOR diffuse2;
    D3DCOLOR specular2;
    if (pv->lpdwRStates[D3DRS_SHADEMODE] == D3DSHADE_FLAT)
    {
        // It is easier to set all vertices to the same color here
        D3DCOLOR diffuse  = cv1->color;
        // Exclude fog factor
        D3DCOLOR specular = cv1->specular & 0x00FFFFFF;

        //Save original colors
        diffuse1  = cv2->color;
        specular1 = cv2->specular;
        diffuse2  = cv3->color;
        specular2 = cv3->specular;

        // Copy the same color to all vertices but preserve fog factor, because
        // fog factor should be interpolated
        cv2->color = diffuse;
        cv3->color = diffuse;
        cv2->specular = (cv2->specular & 0xFF000000) | specular;
        cv3->specular = (cv3->specular & 0xFF000000) | specular;
    }

    if (count = pv->pGeometryFuncs->ClipSingleTriangle(pv, &newtri, &ver))
    {
        int i;
        HRESULT ret;
        BYTE *pTLV = pv->ClipperState.clipBuf;
        BYTE *p = pTLV;

        for (i = 0; i < count; i++) 
        {
            MAKE_TL_VERTEX_FVF(pv, p, ver[i]);
            p += pv->dwOutputSize;
        }
        ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pTLV, count, count-2);
        if (ret)
            return ret;
    }
    // CLIPPED_ENABLE bit could be set in the ClipSingleTriangle.
    // If this bit is not cleared, clipping will be wrong. Because, clip 
    // vertices are re-used by next triangles.
    // This bit should be cleared *after* drawing command. Otherwise, edge flags 
    // will be incorrect
    cv1->clip &= ~CLIPPED_ENABLE;
    cv2->clip &= ~CLIPPED_ENABLE;
    cv3->clip &= ~CLIPPED_ENABLE;

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // Restore original colors
        cv2->color    = diffuse1;
        cv2->specular = specular1;
        cv3->color    = diffuse2;
        cv3->specular = specular2;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//----------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *v1, ClipVertex *v2)
{
    ClipTriangle newline;
    LPVOID saveVer = pv->lpvOut;          // For indexed primitive
    DWORD numVer = pv->dwNumVertices;     // For indexed primitive
    ClipVertex cv1 = *v1;
    ClipVertex cv2 = *v2;
    newline.v[0] = &cv1;
    newline.v[1] = &cv2;

    int count;
    ClipVertex** ver;

    if (pv->lpdwRStates[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_FLAT)
    {
        // Copy the same color to all vertices but preserve fog factor, because
        // fog factor should be interpolated
        cv2.color = cv1.color;
        cv2.specular = (cv2.specular & 0xFF000000)|(cv1.specular & 0x00FFFFFF);
    }

    if (ClipSingleLine(pv, &newline))
    {
        BYTE *pTLV = pv->ClipperState.clipBuf;
        BYTE *p = pTLV;
        MAKE_TL_VERTEX_FVF(pv, p, newline.v[0]);
        p += pv->dwOutputSize;
        MAKE_TL_VERTEX_FVF(pv, p, newline.v[1]);
        HRESULT ret = DRAW_CLIPPED_PRIM(pv, D3DPT_LINELIST, pTLV, 2, 1);
        if (ret)
            return ret;
    }
    pv->lpvOut = saveVer;
    pv->dwNumVertices = numVer;
    return D3D_OK;
}
//------------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::ProcessClippedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    BYTE   *p1;
    DWORD   f1;
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;                                        
    BYTE       *vertex;                                     
    BYTE       *startVertex;                                
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    BOOL        vertexTransformed;                         
                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;                      
    startVertex = (BYTE*)pv->lpvOut;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        

    f1 = clipCode[0];
    p1 = vertex;
    clipCode++;
    vertex += vertexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], p1, f1, vertexTransformed);
    for (i = pv->dwNumVertices-2; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        f2 = clipCode[0];
        f3 = clipCode[1];

        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                BYTE tmp[__MAX_VERTEX_SIZE];
                BYTE *pStart = startVertex;
                if (startVertex != p1)
                {
                    pStart -= vertexSize;
                    memcpy (tmp, pStart, vertexSize);
                    memcpy (pStart, p1, vertexSize);
                    // Mark this call as gen by clipper, but set non clipped bit
                    pv->dwFlags |= D3DPV_NONCLIPPED; 
                    ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                            vertexCount);
                    pv->dwFlags &= ~D3DPV_NONCLIPPED;
                }
                else
                {
                    ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
                }
                if (startVertex != p1)
                    memcpy (pStart, tmp, vertexSize);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            vertexCount = 0;
            startVertex = vertex + vertexSize;

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex;
                BYTE *p3 = vertex + vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } else 
            vertexCount++;
        clipCode++;
        vertex += vertexSize;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        BYTE tmp[__MAX_VERTEX_SIZE];
        BYTE *pStart = startVertex;
        if (startVertex == p1)
        {
            ret = DRAW_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
        }
        else
        {
            pStart -= vertexSize;
            memcpy(tmp, pStart, vertexSize);
            memcpy(pStart, p1, vertexSize);
            // Mark this call as gen by clipper
            pv->dwFlags |= D3DPV_NONCLIPPED; 
            ret = DRAW_CLIPPED_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, vertexCount);
            pv->dwFlags &= ~D3DPV_NONCLIPPED;
        }
        if (startVertex != p1)
            memcpy(pStart, tmp, vertexSize);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//------------------------------------------------------------------------------
HRESULT 
D3DFE_PVFUNCSI::ProcessClippedIndexedTriangleFan(D3DFE_PROCESSVERTICES *pv)
{
    DWORD        f1;    // Clip code for the first vertex
    D3DFE_CLIPCODE *clipCode;                               
    DWORD       i;                                          
    HRESULT     ret;     
    // Vertex array
    BYTE       *vertex;  
    // Start indexed of the current in-screen triangle batch
    LPBYTE      startIndex;                               
    // Pointer to second index of the current triangle
    LPBYTE      index = (LPBYTE)pv->lpwIndices;
    int         vertexCount;                                
    DWORD       vertexSize;                                 
    ClipVertex  cv[3];                                      
    DWORD       dwIndexSize = pv->dwIndexSize;
    DWORD       dwFirstIndex;           // First index of the primitive
    BOOL        vertexTransformed; 
    // If there was a off-screen or clipped triangle we copy the first primitive
    // index to the start of the next in-screen triangle batch
    BOOL        bWasClipping = FALSE;

                                                            
    vertexTransformed = pv->dwFlags & D3DPV_TLVCLIP;
    clipCode = pv->lpClipFlags;                      
    vertex = (BYTE*)pv->lpvOut;
    startIndex = (LPBYTE)pv->lpwIndices;                 
    vertexSize = pv->dwOutputSize;                   
    vertexCount = 0;                                        
    // Update the address of the vertex array to handle the index base
    if (pv->dwIndexOffset != 0)
    {
        vertex -= pv->dwIndexOffset * vertexSize;
        clipCode -= pv->dwIndexOffset;
    }

    if (dwIndexSize == 2)
        dwFirstIndex = *(WORD*)index;
    else
        dwFirstIndex = *(DWORD*)index;
    f1 = clipCode[dwFirstIndex];
    LPBYTE ver;     // First vertex
    ver = vertex + dwFirstIndex * vertexSize;
    index += dwIndexSize;
    // In the clipper color from the first vertex is propagated to all
    // vertices for FLAT shade mode. In triangle fans the second vertex defines
    // the color in FLAT shade mode. So we will make the vertex order: 1, 2, 0
    MAKE_CLIP_VERTEX_FVF(pv, cv[2], ver, f1, vertexTransformed);
    for (i = pv->dwNumPrimitives; i; i--) 
    {
        DWORD f2, f3;     // vertex clip flags
        DWORD  v1, v2;
        if (dwIndexSize == 2)
        {
            v1 = *(WORD*)index;
            v2 = *(WORD*)(index + 2);
        }
        else
        {
            v1 = *(DWORD*)index;
            v2 = *(DWORD*)(index + 4);
        }
        f2 = clipCode[v1];
        f3 = clipCode[v2];
        BOOL needClip = FALSE;
        BOOL offFrustum = FALSE;
        if (f1 & f2 & f3) 
            offFrustum = TRUE;
        else
        if ((f1 | f2 | f3) & pv->dwClipMaskOffScreen)
            needClip = TRUE;

        if (offFrustum || needClip)
        {     // if this tri does need clipping
            if (vertexCount) 
            {   // first draw the ones that didn't need clipping
                WORD* pStart = (WORD*)startIndex;
                DWORD tmp;
                if (bWasClipping)
                {
                    // Save old value of the index before the current start 
                    // index and copy the first primitive index there. This 
                    // will the start of the current unclipped batch
                    if (dwIndexSize == 2)
                    {
                        pStart--;
                        tmp = *pStart;
                        *pStart = (WORD)dwFirstIndex;
                    }
                    else
                    {
                        pStart -= 2;
                        tmp = *(DWORD*)pStart;
                        *(DWORD*)pStart = dwFirstIndex;
                    }
                }
                ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                                      vertexCount);
                if (bWasClipping)
                { // Restore old value
                    if (dwIndexSize == 2)
                        *pStart = (WORD)tmp;  
                    else
                        *(DWORD*)pStart = tmp;  
                }
                if (ret)
                    return ret;

            }
            bWasClipping = TRUE;
            // reset count and start ptr
            vertexCount = 0;
            startIndex = index + dwIndexSize;

            // now deal with the single clipped triangle
            // first check if it should just be tossed or if it should be clipped

            if (!offFrustum) 
            {
                BYTE *p2 = vertex + v1*vertexSize;
                BYTE *p3 = vertex + v2*vertexSize;

                MAKE_CLIP_VERTEX_FVF(pv, cv[0], p2, f2, vertexTransformed);
                MAKE_CLIP_VERTEX_FVF(pv, cv[1], p3, f3, vertexTransformed);

                ret = Clip(pv, &cv[0], &cv[1], &cv[2]);
                if (ret) return ret;
            }
        } 
        else 
            vertexCount++;
        index += dwIndexSize;
    }
    // draw final batch, if any
    if (vertexCount) 
    {
        WORD* pStart = (WORD*)startIndex;
        DWORD tmp;
        if (bWasClipping)
        {
            // Save old value of the index before the current start 
            // index and copy the first primitive index there. This 
            // will the start of the current unclipped batch
            if (dwIndexSize == 2)
            {
                pStart--;
                tmp = *pStart;
                *pStart = (WORD)dwFirstIndex;
            }
            else
            {
                pStart -= 2;
                tmp = *(DWORD*)pStart;
                *(DWORD*)pStart = dwFirstIndex;
            }
        }
        ret = DRAW_INDEX_PRIM(pv, D3DPT_TRIANGLEFAN, pStart, vertexCount+2, 
                             vertexCount);
        if (bWasClipping)
        { // Restore old value
            if (dwIndexSize == 2)
                *pStart = (WORD)tmp;  
            else
                *(DWORD*)pStart = tmp;  
        }
        if (ret)
            return ret;

    }
    return D3D_OK;
} 

#define __PROCESS_LINE_NAME ProcessClippedLine
#define __PROCESS_TRI_LIST_NAME ProcessClippedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedTriangleStrip
#include "clipprim.h"

#define __INDEX_PRIM
#define __PROCESS_TRI_LIST_NAME ProcessClippedIndexedTriangleList
#define __PROCESS_TRI_STRIP_NAME ProcessClippedIndexedTriangleStrip
#define __PROCESS_LINE_NAME ProcessClippedIndexedLine
#include "clipprim.h"

//---------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::ProcessClippedPoints(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartVertex;
    BYTE           *lpCurVertex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nVertices = pv->dwNumVertices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartVertex = lpCurVertex = (BYTE*)pv->lpvOut;
    for (i=0; i < nVertices; i++) 
    {
        if (clipCode[i]) 
        {       // if this point is clipped
            if (count) 
            {    // first draw the ones that didn't need clipping
                ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurVertex += pv->dwOutputSize;
            lpStartVertex = lpCurVertex;
            pv->pDDI->SkipVertices(1);
        } 
        else 
        {
            count++;
            lpCurVertex += pv->dwOutputSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//---------------------------------------------------------------------
// We do not throw away point sprites which centers are off screeen.
// We detect this case and compute screen coordinates for those sprites
//
HRESULT ProcessClippedPointSprites(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartVertex;
    BYTE           *lpCurVertex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nVertices = pv->dwNumVertices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartVertex = lpCurVertex = (BYTE*)pv->lpvOut;
    for (i=0; i < nVertices; i++) 
    {
        // If a point is outside screen or guard band, the sprite could still
        // be visible (when the guard band is small enough
        if (clipCode[i] & ~(D3DCS_LEFT | D3DCS_RIGHT | 
                            D3DCS_TOP | D3DCS_BOTTOM | 
                            __D3DCLIPGB_ALL))
        {
            // This point is off viewing frustum
            if (count) 
            { // first draw the ones that didn't need clipping
                ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurVertex += pv->dwOutputSize;
            lpStartVertex = lpCurVertex;
            if (!(pv->dwDeviceFlags & D3DDEV_DOPOINTSPRITEEMULATION))
                pv->pDDI->SkipVertices(1);
        } 
        else 
        {
            if (clipCode[i])
            {
                // When we are here, the point sprite center is off-screen, but
                // could be visible

                // Non zero when the point is outside guard band
                DWORD gbBits = clipCode[i] & __D3DCLIPGB_ALL;   

                // Screen coordinates were not computed for the point if there is 
                // no guard band or the point is outside the guard band
                if (!(pv->dwDeviceFlags & D3DDEV_GUARDBAND) ||
                    (pv->dwDeviceFlags & D3DDEV_GUARDBAND) && gbBits)
                {
                    D3DVECTORH* p = (D3DVECTORH*)lpCurVertex;
                    float w = 1.0f/p->w;
                    p->x = p->x * w * pv->vcache.scaleX + pv->vcache.offsetX;
                    p->y = p->y * w * pv->vcache.scaleY + pv->vcache.offsetY;
                    p->z = p->z * w * pv->vcache.scaleZ + pv->vcache.offsetZ;
                    p->w  = w;
                }
            }
            count++;
            lpCurVertex += pv->dwOutputSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        ret = DRAW_PRIM(pv, D3DPT_POINTLIST, lpStartVertex, count, count);
        if (ret)
            return ret;
    }
    return D3D_OK;
} 
//---------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::ProcessClippedIndexedPoints(D3DFE_PROCESSVERTICES *pv)
{
    DWORD           i;
    WORD            count;
    BYTE           *lpStartIndex;
    BYTE           *lpCurIndex;
    HRESULT         ret;
    D3DFE_CLIPCODE *clipCode;
    const DWORD     nIndices = pv->dwNumIndices;
    DWORD           dwIndexSize = pv->dwIndexSize;
    LPBYTE          pIndices = (LPBYTE)pv->lpwIndices;

    clipCode = pv->lpClipFlags;                      
    count = 0;
    lpStartIndex = lpCurIndex = (BYTE*)pv->lpwIndices;
    // Update the address of the vertex array to handle the index base
    clipCode -= pv->dwIndexOffset;

    for (i=0; i < nIndices; i++) 
    {
        DWORD  index;
        if (dwIndexSize == 2)
            index = *(WORD*)pIndices;
        else
            index = *(DWORD*)pIndices;
        pIndices += dwIndexSize;
        if (clipCode[index]) 
        {       // if this point is clipped
            if (count) 
            {    // first draw the ones that didn't need clipping
                ret = DRAW_INDEX_PRIM(pv, D3DPT_POINTLIST, (WORD*)lpStartIndex, 
                                      count, count);
                if (ret)
                    return ret;
            }
            // reset count and start ptr
            count = 0;
            lpCurIndex += pv->dwIndexSize;
            lpStartIndex = lpCurIndex;
        } 
        else 
        {
            count++;
            lpCurIndex += pv->dwIndexSize;
        }
    }
    // draw final batch, if any
    if (count) 
    {
        ret = DRAW_INDEX_PRIM(pv, D3DPT_POINTLIST, (WORD*)lpStartIndex, count, 
                              count);
        if (ret)
            return ret;
    }
    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\dpf.c ===
#undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR       "DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT       "DirectDraw"
    #endif

    #define END_STR             "\r\n"

    HWND                hWndListBox;
    LONG                lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
            if( hWndListBox != NULL )
            {
                if( !IsWindow( hWndListBox ) )
                {
                    hWndListBox = NULL;
                }
            }
            if( hWndListBox != NULL )
            {
                UINT    sel;
                int     len;
                len = strlen( str );
                if( len > 0 )
                {
                    if( str[len-1] == '\r' || str[len-1] == '\n' )
                    {
                        str[len-1] = 0;
                    }
                    if( len > 1 )
                    {
                        if( str[len-2] == '\r' || str[len-2] == '\n' )
                        {
                            str[len-2] = 0;
                        }
                    }
                }
                SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
                sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
                if( sel != LB_ERR )
                {
                    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
                }
            }
        #endif

    } /* dumpStr */

    /*
     * DXdprintf
     */
    void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

        va_end(ap);
    } /* DXdprintf */


    static void cdecl D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;

        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            wsprintf( (LPSTR) str+lstrlen( str ), msgType );
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

    } /* D3Dprintf */

    void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap, szFormat);

        D3Dprintf(lvl, "(INFO) :", szFormat, ap);

        va_end(ap);
    }

    void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(lvl, "(WARN) :", szFormat, ap);
        va_end(ap);
    }

    void cdecl D3DErrorPrintf( LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(0, "(ERROR) :", szFormat, ap);
        va_end(ap);
    }

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        DXdprintf( ASSERT_MESSAGE_LEVEL, buffer );
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
            /*
             * Into the debugger we go...
             */
            DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef WINNT
        #undef DEBUG
        #ifdef DBG
            #define DEBUG
        #endif
    #endif

    extern void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DErrorPrintf( LPSTR szFormat, ...);

    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPF_DECLARE(szName) char * __pszDpfName=#szName":"
        #define DPFINIT()   DPFInit()
        #define DPF         DXdprintf
        #define DPF_ERR(a)  DXdprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && !defined(WINNT)
            #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
            #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT

        // New for D3D
        #define D3D_ERR       D3DErrorPrintf
        #define D3D_WARN      D3DWarnPrintf
        #define D3D_INFO      D3DInfoPrintf
    #else
        #pragma warning(disable:4002)
        #define DPF_DECLARE(szName)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()

        #define D3D_ERR(a)
        #define D3D_WARN()
        #define D3D_INFO()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD perf_clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= perf_clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += perf_clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\light.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       light.h
 *  Content:    Direct3D lighting include file
 *
 ***************************************************************************/

#ifndef __LIGHT_H__
#define __LIGHT_H__

struct BATCHBUFFER;

extern "C"
{
void Directional7(LPD3DFE_PROCESSVERTICES pv, 
                  D3DI_LIGHT *light, 
                  D3DVERTEX *pInpCoord, 
                  D3DVALUE* pWeights,
                  BYTE* pMatrixIndices,
                  D3DVECTOR *pInpNormal,
                  D3DLIGHTINGELEMENT *pEyeSpaceData);
void Directional7Model(LPD3DFE_PROCESSVERTICES pv, 
                       D3DI_LIGHT *light, 
                       D3DVERTEX *pInpCoord, 
                       D3DVALUE* pWeights,
                       BYTE* pMatrixIndices,
                       D3DVECTOR *pInpNormal,
                       D3DLIGHTINGELEMENT *pEyeSpaceData);
void PointSpot7(LPD3DFE_PROCESSVERTICES pv, 
                D3DI_LIGHT *light, 
                D3DVERTEX *pInpCoord, 
                D3DVALUE* pWeights,
                BYTE* pMatrixIndices,
                D3DVECTOR *pInpNormal,
                D3DLIGHTINGELEMENT *pEyeSpaceData);
void PointSpot7Model(LPD3DFE_PROCESSVERTICES pv, 
                     D3DI_LIGHT *light, 
                     D3DVERTEX *pInpCoord, 
                     D3DVALUE* pWeights,
                     BYTE* pMatrixIndices,
                     D3DVECTOR *pInpNormal,
                     D3DLIGHTINGELEMENT *pEyeSpaceData);
void DirectionalFirst(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalNext(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotFirst(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotNext(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalFirstModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void DirectionalNextModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotFirstModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
void PointSpotNextModel(LPD3DFE_PROCESSVERTICES pv, 
                      DWORD dwVerCount,
                      BATCHBUFFER *pBatchBuffer,
                      D3DI_LIGHT *light, 
                      D3DVERTEX *in,
                      D3DVALUE* pWeights,
                      BYTE* pMatrixIndices,
                      D3DVECTOR *pNormal,
                      DWORD *pDiffuse,
                      DWORD *pSpecular);
}

#endif  /* __LIGHT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\fe.h ===
#ifndef __MSPSGP_H_
#define __MSPSGP_H_
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mspsgp.h
 *  Content:    Defines for Microsoft's PSPG implementation
 *
 ***************************************************************************/

#include "vvm.h"

// DEBUG_PIPELINE is defined to check performance and to allow to choose
// diifferent paths in the geometry pipeline
// Undefine DEBUG_PIPELINE for final

//#define DEBUG_PIPELINE

#ifdef DEBUG_PIPELINE
const DWORD __DEBUG_NORENDERING = 1;    // Disable writing drawing command to the command buffer
const DWORD __DEBUG_ONEPASS = 2;        // Disable clip and light in one pass
const DWORD __DEBUG_MODELSPACE = 4;     // Disable lighting in model space
#endif

//---------------------------------------------------------------------
// Returns TRUE if cipping is needed
//
inline BOOL CheckIfNeedClipping(LPD3DFE_PROCESSVERTICES pv)
{
    if (pv->dwDeviceFlags & D3DDEV_GUARDBAND)
    {
        if (pv->dwClipUnion & ~__D3DCS_INGUARDBAND)
            return  TRUE;
    }
    else
        if (pv->dwClipUnion)
            return  TRUE;
    return FALSE;
}
//-----------------------------------------------------------------------------
// Direct3D default implementation of PVFUNCS
//
class D3DFE_PVFUNCSI : public ID3DFE_PVFUNCS
{
public:
    DWORD ProcessVertices(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessPrimitive(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessIndexedPrimitive(LPD3DFE_PROCESSVERTICES);
    int ClipSingleTriangle(D3DFE_PROCESSVERTICES *pv,
                           ClipTriangle *tri,
                           ClipVertex ***clipVertexPointer);
    HRESULT DoDrawIndexedPrimitive(LPD3DFE_PROCESSVERTICES pv);
    HRESULT DoDrawPrimitive(LPD3DFE_PROCESSVERTICES pv);
    HRESULT ProcessLineList(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessLineStrip(D3DFE_PROCESSVERTICES *pv);
    DWORD   ProcessVerticesVVM(LPD3DFE_PROCESSVERTICES pv);
    HRESULT CreateShader(CVElement* pElements, DWORD dwNumElements,
                                     DWORD* pdwShaderCode, DWORD dwOutputFVF, 
                                     CPSGPShader** ppPSGPShader);
    HRESULT SetActiveShader(CPSGPShader* pPSGPShader);
    HRESULT LoadShaderConstants(DWORD start, DWORD count, LPVOID buffer);
    HRESULT GetShaderConstants(DWORD start, DWORD count, LPVOID buffer);
    HRESULT SetOutputFVF(DWORD dwFVF) {return D3D_OK;}

    HRESULT ProcessTriangleList(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessTriangleFan(LPD3DFE_PROCESSVERTICES);
    HRESULT ProcessTriangleStrip(LPD3DFE_PROCESSVERTICES);

    HRESULT Clip(D3DFE_PROCESSVERTICES *pv, ClipVertex *cv1, 
                 ClipVertex *cv2, 
                 ClipVertex *cv3);
    int ClipSingleLine(D3DFE_PROCESSVERTICES *pv, ClipTriangle *line);
    HRESULT ProcessClippedTriangleFan(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedTriangleFan(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedLine(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedTriangleList(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedTriangleList(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedTriangleStrip(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedLine(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedPoints(D3DFE_PROCESSVERTICES *pv);
    HRESULT ProcessClippedIndexedPoints(D3DFE_PROCESSVERTICES *pv);
    HRESULT ClipLine(D3DFE_PROCESSVERTICES *pv, ClipVertex *v1, ClipVertex *v2);

    CVertexVM m_VertexVM;
    
};
//-----------------------------------------------------------------------------
// Does projected texture emulation
// Parameters:
//      pOut            - output texture coordinates
//      pIn             - input texture coordinates
//      dwOutTexSize    - size of output texture coordinates in bytes
// Assumes that input texture coordinates have one float more than the output
//
inline void DoTextureProjection(float* pIn, float* pOut, DWORD dwOutTexSize)
{
    UINT n = dwOutTexSize >> 2;     // Number of output floats
    float w = 1.0f/pIn[n];
    for (UINT i=0; i < n; i++)
    {
        pOut[i] = pIn[i] * w;
    }
}
//-----------------------------------------------------------------------------
inline void
DoBlending(float blendFactor, D3DVECTOR* v1, D3DVECTOR* v2, D3DVECTOR* out)
{
    out->x = v1->x + (v2->x - v1->x) * blendFactor;
    out->y = v1->y + (v2->y - v1->y) * blendFactor;
    out->z = v1->z + (v2->z - v1->z) * blendFactor;
}
//-----------------------------------------------------------------------------
// Returns TRUE if we can do one pass transformation-lighting-clipping for 
// non-indexed primitives
//
inline BOOL DoOnePassPrimProcessing(D3DFE_PROCESSVERTICES* pv)
{
    return ((pv->dwDeviceFlags & (D3DDEV_DONOTCLIP | D3DDEV_VERTEXSHADERS)) |
            (pv->dwFlags & (D3DPV_POSITION_TWEENING | D3DPV_NORMAL_TWEENING))) == 0;
}
//-----------------------------------------------------------------------------
// Returns TRUE if we never read from the internal TL buffer
//
inline BOOL NeverReadFromTLBuffer(D3DFE_PROCESSVERTICES* pv)
{
    return (pv->dwDeviceFlags & D3DDEV_DONOTCLIP) | DoOnePassPrimProcessing(pv);
}

#endif // __MSPSGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\pch.cpp ===
#include "ddraw.h"
#include "d3d8p.h"
#include <math.h>
#include "dpf.h"
#include "d3dflt.h"
#include "d3dutil.h"
#include "d3dfe.hpp"
#include "vvm.h"
#include "pipeln.h"
#include "clipper.h"
#include "clipfunc.h"
#include "light.h"
#include "pvvid.h"
#include "fe.h"
#include "ddibase.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#
.SUFFIXES: .mh .mcp

GENTGT = $(_OBJ_DIR)\$(TARGET_DIRECTORY)

# Create a .h file from a .mh file.
{..}.mh{$(GENTGT)}.h:
    m4 -I.. $< > $*.h

# Create a .cpp file from a .mcp file.
{..}.mcp{$(GENTGT)}.cpp:
    m4 -I.. $< > $(GENTGT)\$(<B).cpp

..\pvvid.mcp: ..\pvvid.mh
..\pvone.mcp: ..\pvvid.mh
..\loops.mcp: ..\pvvid.mh

$(GENTGT)\pvvid.cpp: ..\pvvid.mcp
$(GENTGT)\pvone.cpp: ..\pvone.mcp
$(GENTGT)\loops.cpp: ..\loops.mcp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\psgp.cpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   x3d.cpp
 *
 ***************************************************************************/


#include "pch.cpp"
#pragma hdrstop

#include "fe.h"
#include "d3dexcept.hpp"

//-----------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::CreateShader(CVElement* pElements, DWORD dwNumElements,
                                     DWORD* pdwShaderCode, DWORD dwOutputFVF,
                                     CPSGPShader** ppPSGPShader)
{
    *ppPSGPShader = NULL;
    try
    {
//        *ppPSGPShader = m_VertexVM.CreateShader(pdwShaderCode);
    }
    D3D_CATCH;
    return S_OK;
}
//-----------------------------------------------------------------------------
HRESULT D3DFE_PVFUNCSI::SetActiveShader(CPSGPShader* pPSGPShader)
{
    return m_VertexVM.SetActiveShader((CVShaderCode*)pPSGPShader);
}
//-----------------------------------------------------------------------------
// Load vertex shader constants
HRESULT D3DFE_PVFUNCSI::LoadShaderConstants(DWORD start, DWORD count, 
                                            LPVOID buffer)
{
    return m_VertexVM.SetData(D3DSPR_CONST, start, count, buffer);
}
//-----------------------------------------------------------------------------
HRESULT D3DAPI
FEContextCreate(DWORD dwFlags, LPD3DFE_PVFUNCS *lpLeafFuncs)
{
    *lpLeafFuncs = new D3DFE_PVFUNCSI;
    return D3D_OK;
}
//-----------------------------------------------------------------------------

HRESULT D3DFE_PVFUNCSI::GetShaderConstants(DWORD start, DWORD count, LPVOID buffer)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\sources.inc ===
TARGETPATH=obj
TARGETNAME=d3dtnl

TARGETTYPE=LIBRARY
SYNCHRONIZE_DRAIN = 1

INCLUDES=..;  \
         $(_OBJ_DIR)\$(TARGET_DIRECTORY);  \
         $(DXGROOT)\d3d8\inc; \
         $(DXGROOT)\inc; \
         $(DXGROOT)\d3d8\util

C_DEFINES = $(C_DEFINES)

ASM_DEFINES = -DNT=1 -DMICROSOFT_NT -DSTACK_CALL  -DD3D -DOTHER_SEG=0 -DWANT_DLL

NTTARGETFILE0= \
             $O\pvvid.cpp \
             $O\pvone.cpp \
             $O\loops.cpp

SOURCES= \
    ..\clipper.cpp   \
    ..\dpclip.cpp    \
    ..\vvm.cpp       \
    $O\pvvid.cpp     \
    $O\pvone.cpp     \
    $O\loops.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\pvvid.h ===
/*============================  ==============================================;
 *
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pvvid.h
 *  Content:    Common defines for the geometry inner loop
 *
 ***************************************************************************/
#ifndef _PVVID_H
#define _PVVID_H

#include "clipper.h"
// This function should be called every time FVF ID is changed
// All pv flags, input and output FVF id should be set before calling the
// function.
extern void UpdateGeometryLoopData(LPD3DFE_PROCESSVERTICES pv);
// Set stride pointers for non-strided case
extern void SetupStrides(D3DFE_PROCESSVERTICES* pv, UINT stride);
// We use power of 2 because it preserves the mantissa when we multiply
const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;

//--------------------------------------------------------------------------
#define D3DFE_SET_ALPHA(color, a) ((char*)&color)[3] = (unsigned char)a;
//--------------------------------------------------------------------------
inline void ComputeFogFactor(LPD3DFE_PROCESSVERTICES pv, D3DVALUE dist, DWORD *pOutput)
{
    if (pv->lighting.fog_mode == D3DFOG_LINEAR)
    {
        if (dist < pv->lighting.fog_start)
            D3DFE_SET_ALPHA((*pOutput), 255)
        else
        if (dist >= pv->lighting.fog_end)
            D3DFE_SET_ALPHA((*pOutput), 0)
        else
        {
            D3DVALUE v = (pv->lighting.fog_end - dist) * pv->lighting.fog_factor;
            int f = FTOI(v);
            D3DFE_SET_ALPHA((*pOutput), f)
        }
    }
    else
    {
        D3DVALUE tmp = dist*pv->lighting.fog_density;
        if (pv->lighting.fog_mode == D3DFOG_EXP2)
        {
            tmp *= tmp;
        }
        tmp = (D3DVALUE)exp(-tmp) * 255.0f;
        int f = FTOI(tmp);
        D3DFE_SET_ALPHA((*pOutput), f)
    }
}
//--------------------------------------------------------------------------
// Input:
//      v        - input vertex in the model space
//      pCoord   - vertex, transformed to the camera space
//      pWeights - pointer to the vertex weights
// Output:
//      Alpha component of pv->lighting.outSpecular is set
//
void ComputeFog(LPD3DFE_PROCESSVERTICES pv, D3DVECTOR &v, D3DVECTOR* pCoord,
                D3DVALUE* pWeights, BYTE* pMatrixIndices);
//---------------------------------------------------------------------
typedef void (*PFN_TEXTURETRANSFORM)(D3DVALUE *pIn, D3DVALUE *pOut, D3DMATRIXI *m);
typedef void (*PFN_TEXTURETRANSFORMLOOP)(D3DVALUE *pIn, D3DVALUE *pOut, D3DMATRIXI *m, 
                                        DWORD dwCount, DWORD dwInpStride, DWORD dwOutStride);

extern PFN_TEXTURETRANSFORM g_pfnTextureTransform[16];
extern PFN_TEXTURETRANSFORMLOOP g_pfnTextureTransformLoop[16];
//---------------------------------------------------------------------
inline void ComputeReflectionVector(D3DVECTOR *vertexPosition, D3DVECTOR *normal, D3DVECTOR *reflectionVector)
{
    D3DVECTOR vertex = *vertexPosition;
    VecNormalizeFast(vertex);
    D3DVALUE dot = 2*(vertex.x * normal->x + vertex.y * normal->y + vertex.z * normal->z); 
    reflectionVector->x = vertex.x - dot*normal->x;
    reflectionVector->y = vertex.y - dot*normal->y;
    reflectionVector->z = vertex.z - dot*normal->z;
}
//---------------------------------------------------------------------
inline void ComputeReflectionVectorInfiniteViewer(D3DVECTOR *normal, D3DVECTOR *reflectionVector)
{
    D3DVALUE dot = 2*normal->z; 
    reflectionVector->x = - dot*normal->x;
    reflectionVector->y = - dot*normal->y;
    reflectionVector->z = 1.0f - dot*normal->z;
}
#endif // _PVVID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\i386\macros.asm ===
; $Id: macros.asm,v 1.4 1995/09/27 09:26:54 james Exp $
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994
; Version 1.0beta2
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
;
;the 8086 macros...
;the general purpose macros just so you can write code more easily

	ifdef INTEL
func	macro	name
	public	name
name:
	endm
	else
func	macro	name
	public	_&name
name:			;lay down both labels so I have one I know will
_&name:			;always be available for asm to call.
	endm
	endif

push_all	macro
	irp	z,<edi,esi,edx,ecx,ebx,eax>
	push	z
	endm
	endm

pop_all		macro
	irp	z,<eax,ebx,ecx,edx,esi,edi>
	pop	z
	endm
	endm

push_m	macro	list
	irp	z,<list>
	push	z
	endm
	endm
	
pop_m	macro	list
	irp	z,<list>
	pop	z
	endm
	endm

byte_eax	equ	al
byte_ebx	equ	bl
byte_ecx	equ	cl
byte_edx	equ	dl

word_eax	equ	ax
word_ebx	equ	bx
word_ecx	equ	cx
word_edx	equ	dx
word_edi	equ	di
word_esi	equ	si
word_ebp	equ	bp

; Divide eax by divisor, an 8 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div8	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 017H
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 018h
	shl	eax, 008h
	idiv	divisor
nodivide:
	endm

; Divide eax by divisor, an 16 bit precision fixed point number.
; Divisor must be positive.
; result in eax, edx is trashed.
Div16	macro	divisor
	local	divide, nodivide
	cdq
	xor	edx, eax
	sar	edx, 0fH
	cmp	divisor, edx
	jg	divide
	sar	eax, 1fH
	xor	eax, 7fffffffH
	jmp	nodivide
divide:
	mov	edx, eax
	sar	edx, 010h
	shl	eax, 010h
	idiv	divisor
nodivide:
	endm

ES_PREFIX	macro
    ifndef	NT
	db	26h
    endif
	endm

beginargs macro
	align	4
stack	=	4	;return address
vars	=	0	;no vars yet
args	=	0	;no args yet
	endm

endargs	macro
	sub	esp, vars
	endm

savereg	macro	arg
	push	arg
stack	=	stack + 4
	endm

saveregs macro	arglist
	irp	z,<arglist>
	savereg	z
	endm
	endm

defvar  macro	name
name	=	vars
vars	=	vars + 4
stack	=	stack + 4
	endm

defvars	macro	arglist
	irp	z,<arglist>
	defvar	z
	endm
	endm

defarg	macro	name
name	=	stack + args
args	=	args + 4
	endm

defargs	macro	arglist
	irp	z,<arglist>
	defarg	z
	endm
	endm

regarg	macro	name
	ifdef	STACK_CALL
	defarg	name
	else
	defvar	name
	endif
	endm

regargs	macro	arglist
	irp	z,<arglist>
	regarg	z
	endm
	endm

return	macro
	ifdef	STACK_CALL
	ret
	else
	ret	args
	endif
	endm

    ifdef	BCC		;{

beginproc macro	prefix,GF,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	if DEPTH eq 0
prefix&name	equ	_&prefix&GF&Tr&Te&name
	else
	  if DEPTH eq 8
prefix&name	equ	_&prefix&8&GF&Tr&Te&name
	  else
prefix&name	equ	_&prefix&16&GF&Tr&Te&name
	  endif
	endif
	public	prefix&name
prefix&name proc
	endm			;}

    else			;} ifndef BCC {

beginproc macro	prefix,GF,Z,Te,Tr,name	;{
	align	4
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the beginproc macro"
	endif
	ifdef	STACK_CALL	;{
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Z&Tr&Te&name
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8_&GF&Z&Tr&Te&name
	    else
prefix&name	equ	prefix&16_&GF&Z&Tr&Te&name
	    endif
	endif
	else			;} else {
	if DEPTH eq 0
prefix&name	equ	prefix&GF&Tr&Te&name&_
	else
	    if DEPTH eq 8
prefix&name	equ	prefix&8&GF&Tr&Te&name&_
	    else
prefix&name	equ	prefix&16&GF&Tr&Te&name&_
	    endif
	endif
	endif			;}
	public	prefix&name
prefix&name proc
	endm			;}
    endif		;}

    ifdef	BCC	;{
endproc	macro prefix,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	if	DEPTH eq 8
_&prefix&name endp
	else
_&prefix&name endp
	endif
	endm			;}

    else		;} ifndef BCC {

endproc	macro prefix,GF,Z,Te,Tr,name	;{
	ifndef	DEPTH
	display	"DEPTH must be defined for modules using the endproc macro"
	endif
	ifdef	STACK_CALL
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name endp
	    else
	    if	DEPTH eq 8
prefix&8_&GF&Z&Tr&Te&name endp
	    else
prefix&16_&GF&Z&Tr&Te&name endp
	    endif
	    endif
	else
	    if	DEPTH eq 0
prefix&GF&Tr&Te&name&_ endp
	    else
	    if	DEPTH eq 8
prefix&8&GF&Tr&Te&name&_ endp
	    else
prefix&16&GF&Tr&Te&name&_ endp
	    endif
	    endif
	endif
	endm			;}

    endif		;}

; ************************************************************************
itoval	macro	reg
	shl	reg,10h
	endm

FDUP	macro
	fld	st(0)
	endm

FDROP	macro
	fstp	st(0)
	endm

FRECIPROCAL	macro
	fld1
	fdivrp	st(1),st
	endm

; MASM 6.11d used in NT has native support for fcomi so this macro can't be
; called fcomi

MACRO_FCOMI macro v
	fcom	v
	fnstsw	ax
	sahf
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\i386\_ftransa.asm ===
GEN_XFRM = 0
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\i386\_ftransg.asm ===
GEN_XFRM = 1
include ftrans.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\i386\ftrans.asm ===
; $Id: ftrans.asm,v 1.3 1995/10/20 15:14:41 james Exp $
;
; Up to 165K from 143K
;
; Copyright (c) RenderMorphics Ltd. 1993, 1994, 1995
; Version 1.0
;
; All rights reserved.
;
; This file contains private, unpublished information and may not be
; copied in part or in whole without express permission of
; RenderMorphics Ltd.
;
; NOTE: Need to set integer pop precision...
;
OPTION NOM510
.386p
;.radix  16
                NAME    transform

                include macros.asm
                include offsets.asm

procstart	macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		proc
	    else
&prefix&xfrm_class		proc
	    endif
	    else
&prefix&xfrm_class&_		proc
	    endif
		endm

procend		macro	prefix, xfrm_class

	    ifdef STACK_CALL
	    ifdef NT
_&prefix&xfrm_class		endp
	    else
&prefix&xfrm_class		endp
	    endif
	    else
&prefix&xfrm_class&_		endp
	    endif
		endm
		
if GEN_XFRM eq 1
xfrmName	equ	General
else
xfrmName	equ	Affine
endif


;ifndef WINNT
;DGROUP          GROUP   _DATA
;endif

_DATA           SEGMENT PARA PUBLIC USE32 'DATA'

; These two are in the same cache line
tx              dq	0
ty		dq	0

_DATA           ENDS

_TEXT           SEGMENT DWORD PUBLIC USE32 'CODE'
;ifdef WINNT
                ASSUME  CS:_TEXT ,DS:_DATA,SS:_DATA
;else
;               ASSUME  CS:_TEXT ,DS:DGROUP,SS:DGROUP
;endif

FDROP   macro
        fstp    st(0)
        endm

fmat	macro	op,row,col
	op	dword ptr [ebp + 4 * ((4 * row) + col)]
	endm

column	macro	i,depth
	fld	dword ptr [esi + D3DVERTEX_x]	; [1]	x

	fmat	fmul,0,i			; [2]	x

	fld	dword ptr [esi + D3DVERTEX_y]	; [3]	y	x

	fmat	fmul,1,i			; [4]	y	x

	fld	dword ptr [esi + D3DVERTEX_z]	; [5]	z	y	x

	fmat	fmul,2,i			; [6]	z	y	x
	fxch	st(2)				; 	x	y	z

	fmat	fadd,3,i			; [7]	x	y	z
	endm
		
	procstart	RLDDITransformUnclippedLoop,%xfrmName

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, m, in_size, out_size, z_scale, z_offset>
	defargs	<minx, maxx, miny, maxy>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        endif

	mov     ebx,[esp + count]
	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov     edi,[esp + vout]

	mov	ebp,[esp + m]

	;	eax	ebx	ecx	edx
	;	minx	maxx	miny	maxy

	; Need to do first loop iteration
	column	0,0
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z' x y z
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; tx
	
	column	1,1		;	x'	y'	z'	x
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			;	x'+y'	z'	tx
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx
	
if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count + 8],1
	je	dontscan
	mov	eax,[esi + 32]
	mov	ebx,[edi + 32]
dontscan:
	pop	ebx
	pop	eax

	fxch	st(3)		; tx tz ty 1/tz

	fmul	st,st(3)	; tx/w tz ty 1/tz
	fxch	st(2)		; ty tz tx/w 1/tz

	fmul	st,st(3)	; ty/w tz tx/w 1/tz
	fxch	st(2)		; tx/w tz ty/w 1/tz

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tz
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tz
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tz
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif
	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz

	fmul	st,st(1)
	fxch	st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]

	fstp	dword ptr [edi + D3DTLVERTEX_sz]

	add	edi,32
	add	esi,32

	dec	dword ptr [esp + count]
	jnz	transloop

	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fld	[tx]
	fld	[ty]			;	c	a
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	a	c
	fsub	[_g_dSnap + (16 * 8)]
	fxch	st(1)			;	c	a
	; XXX fp slot
	fstp	dword ptr [esi]		;	a
	fstp	dword ptr [edi]		;

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformUnclippedLoop,%xfrmName


cpick	macro	dst,c0,c1			; NO CARRY	CARRY
	sbb	dst,dst				; 0		~0
	and	dst,c0 xor c1			; 0		c0^c1
	xor	dst,c0				; c0		c1
	endm

;************************************************************************

		
	procstart	RLDDITransformClippedLoop,%xfrmName
		

;
; Set up equates for arguments and automatic storage
;
        beginargs
        saveregs <ebp,esi,edi,ebx,ecx>
        regargs <x_offset, y_offset, count, vout>
	defargs	<vin, hout, m, in_size, out_size, z_scale, z_offset>
	defargs	<x_bound, y_bound, r_scale_x, r_scale_y>
	defargs	<minx, maxx, miny, maxy>
	defargs	<clip_intersection, clip_union>
        endargs

; Ensure arguments are accessible from the stack, to free the registers

        ifndef      STACK_CALL
		mov     [esp + x_offset], eax
		mov     [esp + y_offset], edx
		mov     [esp + count], ebx
		mov     [esp + vout], ecx
        else
		mov     ebx,[esp + count]
		mov     ecx,[esp + vout]
        endif

	fldpi

	test	ebx,ebx
	je	alldone

	;{ Pick up old extents

	mov	esi,[esp + minx]
	mov	edi,[esp + miny]

	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]
	fadd	[_g_dSnap + (16 * 8)]

	mov	esi,[esp + maxx]
	mov	edi,[esp + maxy]
	fld	dword ptr [esi]
	fadd	[_g_dSnap + (16 * 8)]
	fld	dword ptr [edi]		; maxy maxx miny minx
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(3)				; minx maxx miny maxy

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	eax,dword ptr [tx]
	mov	ebx,dword ptr [ty]

	fstp	qword ptr [tx]
	fstp	qword ptr [ty]

	mov	ecx,dword ptr [tx]
	mov	edx,dword ptr [ty]
	;}

	mov	esi,[esp + vin]
	mov	ebp,[esp + m]
	mov	edi,[esp + vout]

	; Need to do first loop iteration

	column	0,0		; 2 cycle wait here
	fadd			; x'+y' z' x y z
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	fadd			; x'+y' z' tx x y z
	jmp	smaxy

transloop:
	column	0,0		; 2 cycle wait here
	 cmp	eax,dword ptr [tx]
	 jg	setminx
	
sminx:	fadd			; x'+y' z'
	 cmp	ebx,dword ptr [tx]
	 jl	setmaxx
	
smaxx:	fadd			; x'+y'+z'
	
	column	1,1		; 2 cycle wait here
	 cmp	ecx,dword ptr [ty]
	 jg	setminy
	
sminy:	fadd			; x'+y' z'
	 cmp	edx,dword ptr [ty]
	 jl	setmaxy
	
smaxy:	fadd			; ty tx

	column	2,2
	 push	eax
	 push	ebx
	 mov	eax,[esi + D3DLVERTEX_color]
	 mov	ebx,[esi + D3DLVERTEX_specular]
	fadd
	 mov	[edi + D3DTLVERTEX_color],eax
	 mov	[edi + D3DTLVERTEX_specular],ebx
	 mov	eax,[esi + D3DVERTEX_tu]
	 mov	ebx,[esi + D3DVERTEX_tv]
	fadd			; tz ty tx
	 mov	[edi + D3DTLVERTEX_tu],eax
	 mov	[edi + D3DTLVERTEX_tv],ebx
	
if GEN_XFRM
	column	3,3
	fadd
	fadd			; tw tz ty tx
endif

	; Now set up the clip flags in ebp
	xor	ebp,ebp
	fld	dword ptr [esp + 8 + x_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(3+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	x1		; Skip this if (tmp > tx)
	or	ebp,D3DCS_RIGHT
x1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(3+GEN_XFRM)	; (tw) tz ty tx
	fnstsw	ax
	sahf
	jbe	xpasses		; Skip this if (-tmp <= tx)
	or	ebp,D3DCS_LEFT
xpasses:
	fld	dword ptr [esp + 8 + y_bound]
	fmul	st,st(1)	; tmp (tw) tz ty tx
	fcom	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	ja	y1		; Skip this if (tmp > ty)
	or	ebp,D3DCS_TOP
y1:	fchs			; -tmp (tw) tz ty tx
	fcomp	st(2+GEN_XFRM)
	fnstsw	ax
	sahf
	jbe	ypasses		; Skip this if (-tmp <= ty)
	or	ebp,D3DCS_BOTTOM
ypasses:
	fst	[ty]		; ty will hold tw for a while...
	
	; if GEN_XFRM eq 0 then tw == tz
	; if GEN_XFRM eq 1 then tw != tz in general, so we
	; calculate a true 1/tw and then drop the extra tw
	; off the FP stack

	fld	[_g_fOne]
	fdiv	st,st(1)	; 1/tw (tw) tz ty tx

if GEN_XFRM
	fxch	st(1)
	FDROP
endif

	; Do the cache read here, plus anything else?
	cmp	dword ptr [esp + count],1
	je	dontscan
	mov	eax,[esp + in_size + 8]
	mov	ebx,[esp + out_size + 8]
	mov	eax,[esi + eax]
	mov	ebx,[edi + ebx]
dontscan:
	pop	ebx
	pop	eax

	mov	[esp + vout],edi		
	mov	edi,[esp + hout]
				; 1/tw tz ty tx
	fxch	st(3)		; tx tz ty 1/tw

	fld	dword ptr [esp + r_scale_x]
	fmul	st,st(1)	; hx tx tz ty 1/tw
	fld	dword ptr [esp + r_scale_y]
	fmul	st,st(4)	; hy hx tx tz ty 1/tw
	fxch	st(1)		; hx hy tx tz ty 1/tw

	fstp	dword ptr [edi + D3DHVERTEX_hx]
	fstp	dword ptr [edi + D3DHVERTEX_hy]

	fmul	st,st(3)	; tx/w tz ty 1/tw
	fxch	st(2)		; ty tz tx/w 1/tw

	fmul	st,st(3)	; ty/w tz tx/w 1/tw
	fxch	st(2)		; tx/w tz ty/w 1/tw

	fadd	dword ptr [esp + x_offset]
	fxch	st(1)		; tz sx ty/w 1/tw
	
if GEN_XFRM eq 0
	fmul	dword ptr [esp + z_scale]
endif
	fxch	st(2)		; ty/w sx tz 1/tw
	fsubr	dword ptr [esp + y_offset]
	fxch	st(2)		; tz sx sy 1/tw
if GEN_XFRM eq 0
	fadd	dword ptr [esp + z_offset]
endif

	; Last clipping flags
	fst	dword ptr [edi + D3DHVERTEX_hz]
	test	byte ptr [edi + D3DHVERTEX_hz + 3],80h
	jz	nofront
	or	ebp,D3DCS_FRONT
nofront:
	fcom	[ty]
	push	eax		;[
	fnstsw	ax
	sahf
	pop	eax		;]
	jb	noback
	or	ebp,D3DCS_BACK
noback:
	mov	[edi + D3DHVERTEX_dwFlags],ebp
	mov	edi,[esp + clip_intersection]
	and	[edi],ebp
	mov	edi,[esp + clip_union]
	or	[edi],ebp

	test	ebp,ebp
	jnz	outofplay

	mov	edi,[esp + vout]

	fxch	st(2)		; sy sx sz 1/tz

	fst	dword ptr [edi + D3DTLVERTEX_sy]

	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)
	fst	dword ptr [edi + D3DTLVERTEX_sx]
	fadd	[_g_dSnap + (16 * 8)]
	fxch	st(1)

	fstp	qword ptr [ty]
	fstp	qword ptr [tx]	; sz 1/tz y

	fmul	st,st(1)

	fstp	dword ptr [edi + D3DTLVERTEX_sz]
				; 1/tz y

	fstp	dword ptr [edi + D3DTLVERTEX_rhw]
				; y

	add	esi,[esp + in_size]

	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp
	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jnz	transloop
	jmp	cleanup

outofplay:				; tz sx sy 1/tz
	FDROP				; sx sy 1/tz
	FDROP				; sy 1/tz y
	FDROP				; 1/tz y
	mov	edi,[esp + vout]
	fstp	dword ptr [edi + D3DTLVERTEX_rhw]	

	add	esi,[esp + in_size]
	add	edi,[esp + out_size]
	mov	ebp,[esp + hout]
	add	ebp,D3DHVERTEX_size
	mov	[esp + hout],ebp

	mov	ebp,[esp + m]

	dec	dword ptr [esp + count]
	jz	calcminmax

	column	0,0		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	fadd			; x'+y'+z' x y z
	
	column	1,1		; 2 cycle wait here
	
	fadd			; x'+y' z' x y z
	
	jmp	smaxy


cleanup:
	cmp	eax,dword ptr [tx]
	jl	e1
	mov	eax,dword ptr [tx]
e1:	cmp	ebx,dword ptr [tx]
	jg	e2
	mov	ebx,dword ptr [tx]
e2:	cmp	ecx,dword ptr [ty]
	jl	e3
	mov	ecx,dword ptr [ty]
e3:	cmp	edx,dword ptr [ty]
	jg	e4
	mov	edx,dword ptr [ty]
e4:

calcminmax:
	mov	dword ptr [tx],eax
	mov	dword ptr [ty],ecx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + minx]
	mov	esi,[esp + miny]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

	mov	dword ptr [tx],ebx
	mov	dword ptr [ty],edx
	fild	dword ptr [tx]
	fmul	dword ptr [_g_fOoTwoPow16]
	fild	dword ptr [ty]
	fmul	dword ptr [_g_fOoTwoPow16]
	fxch	st(1)				; x y
	mov	edi,[esp + maxx]
	mov	esi,[esp + maxy]
	fstp	dword ptr [edi]
	fstp	dword ptr [esi]

alldone:
	add     esp, vars
	pop	ecx
	pop	ebx
	pop     edi
	pop     esi
	pop     ebp

	FDROP

        return

setminx:
	mov	eax,dword ptr [tx]
	jmp	sminx
setmaxx:
	mov	ebx,dword ptr [tx]
	jmp	smaxx
setminy:
	mov	ecx,dword ptr [ty]
	jmp	sminy
setmaxy:
	mov	edx,dword ptr [ty]
	jmp	smaxy
	
	procend	RLDDITransformClippedLoop,%xfrmName

		
if GEN_XFRM
_Rdtsc	proc
	db	0fh,31h
	shrd	eax,edx,10
	ret
	
_Rdtsc	endp
endif

_TEXT           ENDS

        extrn	_g_fOne:dword
        extrn	_g_fOoTwoPow16:dword
	extrn	_g_dSnap:qword

                END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\daytona\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\dll\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#
!include ..\makefile.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\i386\light.asm ===
.486p

.model flat

include offsets.asm

.data

one DWORD   3f800000h

a1      dd 0.47                 ; Constants to compute inverse square root
a2      dd 1.47
v255    dd 65280.0              ; 255*256
v1_256  dd 0.00390625           ; 1/255
.code

PUBLIC  _Directional2P5S        ; Pentium optimized, specular, unit scale
PUBLIC  _Directional2P5         ; Pentium optimized, no specular, unit scale
;-------------------------------------------------------------------------
; Jim Blinn's method is used to compute inverse square root s = 1/sqrt(x):
;   ONE_AS_INTEGER = 0x3F800000
;   float y;
;   int tmp = ((ONE_AS_INTEGER << 1 + ONE_AS_INTEGER)  - *(long*)&x) >> 1;   
;   y = *(float*)&tmp;  
;   s = y*(1.47f - 0.47f*x*y*y);
; Input:
;   st(0)   = vector length
;   y, len  = should be defined as DWORD PTR
;   a1, a2  = 0.27 and 1.47
; Output:
;   st(0)   = 1/sqrt(vector length)
;
COMPUTE_ISQRT MACRO
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     len                         ; Vector length (x = len)
    sub     eax, len
    sar     eax, 1
    mov     y, eax                      ; y
    fmul    a1                          ; len*0.47  x y z
    fld     y                           ; y len*0.47 x y z
    fld     st(0)                       ; y y len*0.47 x y z
    fmul    st(0), st(1)                ; y*y y len*0.47 x y z
    fld     a2                          ; 1.47 y*y y len*0.47 x y z
    fxch    st(3)                       ; len*0.47 y*y y 1.47 x y z
    fmulp   st(1), st(0)                ; len*0.47*y*y y 1.47 x y z
    fsubp   st(2), st(0)                ; y aaa x y z
    fmulp   st(1), st(0)                ; 1/sqrt(len) x y z
ENDM
;-------------------------------------------------------------------------
; Exit from the function
;
EXIT_FUNC   MACRO
    pop     edx
    pop     ebx
    pop     ecx
    mov     esp, ebp
    pop     ebp
    ret
ENDM
;-------------------------------------------------------------------------
; void Directional2P5S(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Specular is always computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse and pv.lighting.specular are updated
;   pv.lighting.specularComputed is set to 1, if there is specular component
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5S PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit1

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

; if (light->flags & D3DLIGHTI_COMPUTE_SPECULAR)

;    test    DWORD PTR [ecx + D3DI_LIGHT_flags], D3DLIGHTI_COMPUTE_SPECULAR
;    jz      exit

; VecSub(in->dvPosition, light->model_eye, eye);

    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _X_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _X_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Y_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Y_]
    fld     DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvPosition + _Z_]
    fsub    DWORD PTR [ecx + D3DI_LIGHT_model_eye + _Z_]    ; z y x
    fxch    st(2)                                           ; x y z

; VecNormalizeFast(eye);
;

; Compute vector length. Leave vector on the FPU stack, because we will use it
;
    fld     st(1)                       ; x x y z
    fmul    st(0), st(0)                ; x*x x y z
    fld     st(2)
    fmul    st(0), st(0)                ; y*y x*x x y z
    fld     st(4)
    fmul    st(0), st(0)                ; z*z y*y x*x x y z
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len x y z

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

; Start normalizing the eye vector
    fmul    st(1), st(0)
    fmul    st(2), st(0)
    fmulp   st(3), st(0)                ; x y z  Normalized "eye" vector

; Calc halfway vector
; VecSub(light->model_direction, eye, h);
;
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fxch    st(1)                       ; y x z
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fxch    st(2)                       ; z x y 
    fsubr   DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fxch    st(1)                       ; x z y 

; dot = VecDot(h, in->dvNormal);

    fld     st(0)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     st(3)
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     st(3)                       ; z*Nz y*Ny x*Nx x z y
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_]
    fxch    st(2)
    faddp   st(1), st(0)
    faddp   st(1), st(0)                ; dot x z y
    fstp    dot                         ; x z y

; if (FLOAT_GTZ(dot)) 

    cmp     dot, 0
    jle     exit2

; dot *= ISQRTF(VecLenSq(h));
;
    fmul    st(0), st(0)                ; x*x y z
    fxch    st(1)                       ; y x*x z
    fmul    st(0), st(0)                ; y*y x*x z
    fxch    st(2)
    fmul    st(0), st(0)                ; z*z y*y x*x
    fxch    st(2)			            ; 
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len

    COMPUTE_ISQRT                       ; st(0) will be 1/sqrt(len)

    fmul    dot                         ; dot
    mov     eax, [edx + PV_LIGHT_specThreshold]
    fst     dot

; if (FLOAT_CMP_POS(dot, >=, ldrv.specThreshold))

    cmp     dot, eax
    jle     exit1

; power = COMPUTE_DOT_POW(&ldrv, dot);
;    int     indx;                
;    float   v;
;    dot *= 255.0f;
;    indx = (int)dot;
;    dot -= indx;                                            
;    ldrv->specularComputed = TRUE;                          
;    v = ldrv->currentSpecTable[indx];
;    return v + (ldrv->currentSpecTable[indx+1] - v)*dot;
;
    fmul    v255            ; dot*255*256
    push    ebx
    fistp   dot             ; indx << 8. 8 bits used to compute dot fraction
    mov     ebx, dot        ; 
    and     dot, 0FFh       ; fractional part of dot
    shr     ebx, 8          ; Table index
    mov     eax, [edx + PV_LIGHT_currentSpecTable]
    lea     eax, [eax + ebx*4]
    fild    dot             ; fractional part of dot
    fmul    v1_256          ; dot*1/256 -> integer fraction to floating point
    fld     DWORD PTR [eax + 4]     ; currentSpecTable[indx+1]
    fsub    DWORD PTR [eax]         ; currentSpecTable[indx]
    fmulp   st(1), st(0)            ; dot*(v2-v1)
    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
    pop     ebx
    fadd    DWORD PTR [eax]

; power = COMPUTE_DOT_POW(&ldrv, dot);
; This is an alternative method to compute x power y.
; Jim Blinn's method is used:
; int tmp = (int)(power*(*(long*)&dot - ONE_AS_INTEGER)) + ONE_AS_INTEGER;
; dot ^ power = *(float*)&tmp;                                           
;
;    sub     dot, 03F800000h
;    fstp    st(0)                       ; Remove dot
;    fld     DWORD PTR [edx + PV_LIGHT_material_power]
;    fimul   dot
;    fistp   dot
;    mov     DWORD PTR [edx + PV_LIGHT_specularComputed], 1
;    add     dot, 03F800000h
;    fld     dot

; ldrv.specular.r += light->local_specR * power;
; ldrv.specular.g += light->local_specG * power;
; ldrv.specular.b += light->local_specB * power;
;
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_specB]
    fmulp   st(3), st(0)                ; g r b
    fxch    st(1)                       ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fxch    st(1)                       ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(2)                       ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_specular + _G_]
    fxch    st(1)                       ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_specular + _G_]
exit:
    EXIT_FUNC
exit1:
    fstp    st(0)
    EXIT_FUNC
exit2:
    fstp    st(0)
    fstp    st(0)
    fstp    st(0)
    EXIT_FUNC

_Directional2P5S ENDP
;-------------------------------------------------------------------------
; void Directional2P5(LPD3DFE_PROCESSVERTICES pv, 
;                   D3DI_LIGHT *light, 
;                   D3DLIGHTINGELEMENT *vertex)
; Limitations:
;   Transformation matrix should not have a scale
;   Only diffuse component is computed
;   Optimized for Pentium
;
; Input:
;   [esp + 4]   - pv
;   [esp + 8]   - light    
;   [esp + 12]  - vertex
; Output:
;   pv.lighting.diffuse is updated
;
pv      equ DWORD PTR [ebp + 8]
light   equ DWORD PTR [ebp + 12]
vertex  equ DWORD PTR [ebp + 16]

dot     equ DWORD PTR [ebp - 4]
y       equ DWORD PTR [ebp - 8]     ; temporary variable to compute 
                                    ; inverse square root
len     equ DWORD PTR [ebp - 12]    ; vector length

_Directional2P5 PROC NEAR

    push    ebp
    mov     ebp, esp
    sub     esp, 12

    push    ecx
    mov     ecx, light
    push    ebx
    mov     ebx, vertex

; dot = VecDot(light->model_direction, in->dvNormal)

    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _X_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _X_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Y_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Y_]
    fld     DWORD PTR [ecx + D3DI_LIGHT_model_direction + _Z_]
    fmul    DWORD PTR [ebx + D3DLIGHTINGELEMENT_dvNormal + _Z_] ; z y x
    fxch    st(2)       ; x y z
    faddp   st(1), st   ; x+y z
    push    edx
    faddp   st(1), st   ; dot
    mov     edx, pv
    fst     dot
    cmp     dot, 0
    jle     exit3

; ldrv.diffuse.r += light->local_diffR * dot;
; ldrv.diffuse.g += light->local_diffG * dot;
; ldrv.diffuse.b += light->local_diffB * dot;

    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffR]
    fmul    st(0), st(1)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffG]
    fmul    st(0), st(2)
    fld     DWORD PTR [ecx + D3DI_LIGHT_local_diffB]
    fmulp   st(3), st(0)                    ; g r b
    fxch    st(1)                           ; r g b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fxch    st(1)                           ; g r b
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]
    fxch    st(2)                           ; b r g
    fadd    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fxch    st(1)                           ; r b g
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _R_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _B_]
    fstp    DWORD PTR [edx + PV_LIGHT_diffuse + _G_]

    EXIT_FUNC
exit3:
    fstp    st(0)
    EXIT_FUNC

_Directional2P5 ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\vvm.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vvm.cpp
 *  Content:    Virtual Vertex Machine implementation
 *
 *  History:
 *      6/16/00 
 *          Added LOGP, EXPP, NM3
 *          RCP, RSQ, LOG, LOGP, EXP, EXPP take input value from W instead of X
 *      7/11/00 
 *          Removed NM3 macro
 *
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

#include <stdio.h>
#include "vvm.h"
#include "d3dexcept.hpp"
#include "float.h"

const DWORD __MAX_CODE_SIZE = 4096;
//-----------------------------------------------------------------------------
HRESULT ComputeShaderCodeSize(
    CONST DWORD* pCode,
    DWORD* pdwCodeOnlySize,
    DWORD* pdwCodeAndCommentSize,
    DWORD* pdwNumConstDefs)
{
    // set this now for error return
    *pdwCodeOnlySize = 0;
    *pdwCodeAndCommentSize = 0;
    DWORD dwNumConstDefs = 0;
    DWORD dwCodeOnlySize = 0;
    DWORD dwCodeAndCommentSize = 0;
    CONST DWORD* pToken = pCode;

    DWORD Version = *pToken++; dwCodeOnlySize++; dwCodeAndCommentSize++;
    if ( (((Version >> 16) != 0xFFFF) && (Version >> 16) != 0xFFFE) ||
         ((Version & 0xFFFF) == 0x0))
    {
        D3D_ERR("invalid version token");
        return D3DERR_INVALIDCALL;
    }

    // very basic parse to find number of instructions
    while ( ((*pToken) != 0x0000FFFF) && (dwCodeOnlySize <= __MAX_CODE_SIZE) )
    {
        if (IsInstructionToken(*pToken))
        {
            DWORD opCode = (*pToken) & D3DSI_OPCODE_MASK;
            if ( opCode == D3DSIO_COMMENT )
            {
                UINT DWordSize = ((*pToken)&D3DSI_COMMENTSIZE_MASK)>>D3DSI_COMMENTSIZE_SHIFT;
                dwCodeAndCommentSize += (1+DWordSize); // instruction token + comment
                pToken += (1+DWordSize);
            }
            else if (opCode == D3DSIO_DEF )
            {
                pToken += 6;
                dwCodeOnlySize += 6;
                dwCodeAndCommentSize += 6;
                dwNumConstDefs++;
            }
            else
            {
                pToken++; dwCodeOnlySize++; dwCodeAndCommentSize++;
            }
        }
        else
        {
            pToken++; dwCodeOnlySize++; dwCodeAndCommentSize++;
        }
    }
    dwCodeOnlySize++; dwCodeAndCommentSize++; // for END token
    if (dwCodeOnlySize > __MAX_CODE_SIZE)
    {
        D3D_ERR("Shader code size is too big. Possibly, missing D3DVS_END()");
        return D3DERR_INVALIDCALL;
    }
    *pdwCodeOnlySize        = 4*dwCodeOnlySize;
    *pdwCodeAndCommentSize  = 4*dwCodeAndCommentSize;
    if( pdwNumConstDefs )
        *pdwNumConstDefs = dwNumConstDefs;

    return S_OK;
}
//-----------------------------------------------------------------------------
float MINUS_INFINITY()
{
    return -FLT_MAX;
}

float PLUS_INFINITY()
{
    return FLT_MAX;
}
//-----------------------------------------------------------------------------
// Returns instruction size, based on the op-code
//
UINT CVertexVM::GetNumSrcOperands(UINT opcode)
{
    // returns number of source operands + opcode + destination
    switch (opcode)
    {
    case D3DSIO_MOV : return 1;
    case D3DSIO_ADD : return 2;
    case D3DSIO_MAD : return 3;
    case D3DSIO_MUL : return 2;
    case D3DSIO_RCP : return 1;
    case D3DSIO_RSQ : return 1;
    case D3DSIO_DP3 : return 2;
    case D3DSIO_DP4 : return 2;
    case D3DSIO_MIN : return 2;
    case D3DSIO_MAX : return 2;
    case D3DSIO_SLT : return 2;
    case D3DSIO_SGE : return 2;
    case D3DSIO_EXP : return 1;
    case D3DSIO_LOG : return 1;
    case D3DSIO_EXPP: return 1;
    case D3DSIO_LOGP: return 1;
    case D3DSIO_LIT : return 1;
    case D3DSIO_DST : return 2;
    case D3DSIO_FRC : return 1;
    case D3DSIO_M4x4: return 2;
    case D3DSIO_M4x3: return 2;
    case D3DSIO_M3x4: return 2;
    case D3DSIO_M3x3: return 2;
    case D3DSIO_M3x2: return 2;
    case D3DSIO_NOP:  return 0;
    default:
        PrintInstCount();
        D3D_THROW_FAIL("Illegal instruction");
    }
    return 0;
}
//-----------------------------------------------------------------------------
// Returns a bit field to say which source register components are used to 
// produce the output components. 
// 4 bits are used per each output component:
//     0-3   output component X
//     4-7   output component Y
//     8-11  output component Z
//     12-15 output component W
// Each of the four bits is used to say if this source component is used to 
// produce the output component:
//     bit 0 - X, bit 1 - Y, bit 2 - Z, bit 3 - W.
//
// SourceIndex - sequential index of the source operand
//
UINT CVertexVM::GetRegisterUsage(UINT opcode, UINT SourceIndex)
{
    switch (opcode)
    {
    case D3DSIO_MOV : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_ADD : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_MAD : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_MUL : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_RCP : return 8 | (8 << 4) | (8 << 8) | (8 << 12);
    case D3DSIO_RSQ : return 8 | (8 << 4) | (8 << 8) | (8 << 12);
    case D3DSIO_DP3 : return 7 | (7 << 4) | (7 << 8) | (7 << 12);
    case D3DSIO_DP4 : return 0xF | (0xF << 4) | (0xF << 8) | (0xF << 12);
    case D3DSIO_MIN : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_MAX : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_SLT : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_SGE : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_EXP : return 8 | (8 << 4) | (8 << 8) | (8 << 12);
    case D3DSIO_LOG : return 8 | (8 << 4) | (8 << 8) | (8 << 12);
    case D3DSIO_EXPP: return 8 | (8 << 4) | (8 << 8);
    case D3DSIO_LOGP: return 8 | (8 << 4) | (8 << 8);
    case D3DSIO_LIT : return (1 << 4) | ((1 | 2 | 8) << 8);
    case D3DSIO_DST : 
        if (SourceIndex == 0)
            return (2 << 4) | (4 << 8);
        else
            return (2 << 4) | (8 << 12);
    case D3DSIO_FRC : return 1 | (2 << 4) | (4 << 8) | (8 << 12);
    case D3DSIO_M4x4: return 0xF | (0xF << 4) | (0xF << 8) | (0xF << 12);
    case D3DSIO_M4x3: return 0xF | (0xF << 4) | (0xF << 8);
    case D3DSIO_M3x4: return 7 | (7 << 4) | (7 << 8) | (7 << 12);
    case D3DSIO_M3x3: return 7 | (7 << 4) | (7 << 8);
    case D3DSIO_M3x2: return 7 | (7 << 4);
    case D3DSIO_NOP:  return 0;
    default:
        PrintInstCount();
        D3D_THROW_FAIL("Illegal instruction");
    }
    return 0;
}
//-----------------------------------------------------------------------------
// Returns instruction size in DWORDs, based on the op-code
//
UINT CVertexVM::GetInstructionLength(DWORD inst)
{
    // returns number of source operands + opcode + destination
    DWORD opcode = D3DSI_GETOPCODE(inst);
    if (opcode == D3DSIO_NOP)
        return 1;
    else if (opcode == D3DSIO_COMMENT)
        return ((inst & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT) + 1;
    else
        return GetNumSrcOperands(opcode) + 2;
}
#if DBG
//-----------------------------------------------------------------------------
// VertexShaderInstDisAsm - Generates human-readable character string for a
// single vertex shader instruction.  String interface is similar to _snprintf.
//-----------------------------------------------------------------------------
static int VertexShaderInstDisAsm(
    char* pStrRet, int StrSizeRet, DWORD* pShader, DWORD Flags )
{
    DWORD*  pToken = pShader;

    // stage in local string, then copy
    char pStr[256] = "";
#define _ADDSTR( _Str ) { _snprintf( pStr, 256, "%s" _Str , pStr ); }
#define _ADDSTRP( _Str, _Param ) { _snprintf( pStr, 256, "%s" _Str , pStr, _Param ); }

    DWORD Inst = *pToken++;
    DWORD Opcode = (Inst & D3DSI_OPCODE_MASK);
    switch (Opcode)
    {
    case D3DSIO_NOP: _ADDSTR("NOP"); break;
    case D3DSIO_MOV: _ADDSTR("MOV"); break;
    case D3DSIO_ADD: _ADDSTR("ADD"); break;
    case D3DSIO_MAD: _ADDSTR("MAD"); break;
    case D3DSIO_MUL: _ADDSTR("MUL"); break;
    case D3DSIO_RCP: _ADDSTR("RCP"); break;
    case D3DSIO_RSQ: _ADDSTR("RSQ"); break;
    case D3DSIO_DP3: _ADDSTR("DP3"); break;
    case D3DSIO_DP4: _ADDSTR("DP4"); break;
    case D3DSIO_MIN: _ADDSTR("MIN"); break;
    case D3DSIO_MAX: _ADDSTR("MAX"); break;
    case D3DSIO_SLT: _ADDSTR("SLT"); break;
    case D3DSIO_SGE: _ADDSTR("SGE"); break;
    case D3DSIO_EXP: _ADDSTR("EXP"); break;
    case D3DSIO_LOG: _ADDSTR("LOG"); break;
    case D3DSIO_EXPP:_ADDSTR("EXPP"); break;
    case D3DSIO_LOGP:_ADDSTR("LOGP"); break;
    case D3DSIO_LIT: _ADDSTR("LIT"); break;
    case D3DSIO_DST: _ADDSTR("DST"); break;
    case D3DSIO_COMMENT: _ADDSTR("COMMENT"); break;
    default        : _ADDSTR("???"); break;
    }
    if (*pToken & (1L<<31))
    {
        DWORD DstParam = *pToken++;
        switch (DstParam & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP     : _ADDSTRP(" T%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_ADDR     : _ADDSTR(" Addr"); break;
        case D3DSPR_RASTOUT  : _ADDSTRP(" R%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_ATTROUT  : _ADDSTRP(" A%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_TEXCRDOUT: _ADDSTRP(" T%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        }
        if (*pToken & (1L<<31)) _ADDSTR(" ");
        while (*pToken & (1L<<31))
        {
            DWORD SrcParam = *pToken++;
            switch (SrcParam & D3DSP_REGTYPE_MASK)
            {
            case D3DSPR_TEMP     : _ADDSTRP(" T%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            case D3DSPR_INPUT    : _ADDSTRP(" I%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            case D3DSPR_CONST    : _ADDSTRP(" C%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            }
            if (*pToken & (1L<<31)) _ADDSTR(",");
        }
    }
    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}
//-----------------------------------------------------------------------------
typedef struct _VShaderInst
{
    DWORD   m_Tokens[32];
    char    m_String[128];
    DWORD*  m_pComment;
    DWORD   m_cdwComment;
} VShaderInst;
#endif // DBG
//-----------------------------------------------------------------------------
class CVShaderCodeI: public CVShaderCode
{
public:
    CVShaderCodeI()
    {
        m_pdwCode = NULL;
        m_InstCount = 0;
#if DBG
        m_pInst = NULL;
#endif
    }
    ~CVShaderCodeI()
    {
        delete m_pdwCode;
#if DBG
        if (m_pInst) delete m_pInst;
#endif
    }
    DWORD*          m_pdwCode;  // Pointer to the original code
    DWORD           m_dwSize;   // Size of the code in DWORDs

    DWORD           m_InstCount;
#if DBG
    VShaderInst*    m_pInst;
#endif

    DWORD  InstCount( void ) { return m_InstCount; }
    DWORD* InstTokens( DWORD Inst );
    char*  InstDisasm( DWORD Inst );
    DWORD* InstComment( DWORD Inst );
    DWORD  InstCommentSize( DWORD Inst );
};
//-----------------------------------------------------------------------------
DWORD* CVShaderCodeI::InstTokens( DWORD Inst )
{
#if DBG
    if ( Inst >= m_InstCount ) return NULL;
    return m_pInst[Inst].m_Tokens;
#else
    return NULL;
#endif
}
//-----------------------------------------------------------------------------
char* CVShaderCodeI::InstDisasm( DWORD Inst )
{
#if DBG
    if ( Inst >= m_InstCount ) return NULL;
    return m_pInst[Inst].m_String;
#else
    return NULL;
#endif
}
//-----------------------------------------------------------------------------
DWORD* CVShaderCodeI::InstComment( DWORD Inst )
{
#if DBG
    if ( Inst >= m_InstCount ) return NULL;
    return m_pInst[Inst].m_pComment;
#else
    return NULL;
#endif
}
//-----------------------------------------------------------------------------
DWORD CVShaderCodeI::InstCommentSize( DWORD Inst )
{
#if DBG
    if ( Inst >= m_InstCount ) return NULL;
    return m_pInst[Inst].m_cdwComment;
#else
    return NULL;
#endif
}
//-----------------------------------------------------------------------------
// Vertex Virtual Machine object implementation
//
//-----------------------------------------------------------------------------
CVertexVM::CVertexVM()
{
    m_pCurrentShader = NULL;
    m_CurInstIndex = 0;
#if DBG
    for (UINT i=0; i < D3DVS_CONSTREG_MAX_V1_1; i++)
        m_c_initialized[i] = FALSE;
#endif
}
//-----------------------------------------------------------------------------
CVertexVM::~CVertexVM()
{
}
//-----------------------------------------------------------------------------
void CVertexVM::Init(UINT MaxVertexShaderConst)
{
    m_MaxVertexShaderConst = max(MaxVertexShaderConst, D3DVS_CONSTREG_MAX_V1_1);
    m_reg.m_c = new VVM_WORD[m_MaxVertexShaderConst];
    if (m_reg.m_c == NULL)
        D3D_THROW_FAIL("Not enough memory to allocate vertex shader constant array");
}
//-----------------------------------------------------------------------------
// Returns addres of the first vertex of the element
//
VVM_WORD * CVertexVM::GetDataAddr(DWORD dwRegType, DWORD dwElementIndex)
{
    switch (dwRegType)
    {
    case D3DSPR_TEMP      : return &m_reg.m_r[dwElementIndex][0];
    case D3DSPR_INPUT     : return &m_reg.m_v[dwElementIndex][0];
    case D3DSPR_CONST     : return &m_reg.m_c[dwElementIndex];
    case D3DSPR_ADDR      : return &m_reg.m_a[dwElementIndex][0];
    case D3DSPR_RASTOUT   : return &m_reg.m_output[dwElementIndex][0];
    case D3DSPR_ATTROUT   : return &m_reg.m_color[dwElementIndex][0];
    case D3DSPR_TEXCRDOUT : return &m_reg.m_texture[dwElementIndex][0];
    default:
        D3D_THROW(D3DERR_INVALIDCALL, "Invalid register type");
    }
    return NULL;
}
//-----------------------------------------------------------------------------
// Sets data of the first vertex pf the register
//
HRESULT CVertexVM::SetData(DWORD dwMemType, DWORD dwStart, DWORD dwCount,
                           LPVOID pBuffer)
{
    try
    {
        VVM_WORD* p = this->GetDataAddr(dwMemType, dwStart);
        if (dwMemType == D3DSPR_CONST)
        {
#if DBG
            if ((dwStart + dwCount) > m_MaxVertexShaderConst)
            {
                D3D_THROW_FAIL("Attemt to write outside constant register array");
            }
            // We only can set initialized flag for software constant registers
            if (dwStart < D3DVS_CONSTREG_MAX_V1_1)
            {
                BOOL* p = &m_c_initialized[dwStart];
                UINT count = dwCount;
                if ((dwStart + dwCount) >= D3DVS_CONSTREG_MAX_V1_1)
                {
                    count = D3DVS_CONSTREG_MAX_V1_1 - dwStart;
                }
                for (UINT i = 0; i < count; i++)
                {
                    p[i] = TRUE;
                }
            }
#endif
            UINT size = dwCount * sizeof(VVM_WORD);
            memcpy(p, pBuffer, size);
        }
        else
        {
            // Set only the first element of the register batch
            for (UINT i=0; i < dwCount; i++)
            {
                p[i * VVMVERTEXBATCH] = ((VVM_WORD*)pBuffer)[i];
            }
        }
    }
    D3D_CATCH;

    return D3D_OK;
}
//-----------------------------------------------------------------------------
HRESULT CVertexVM::GetData(DWORD dwMemType, DWORD dwStart, DWORD dwCount,
                           LPVOID pBuffer)
{
    try
    {
        VVM_WORD* p = this->GetDataAddr(dwMemType, dwStart);
        if (dwMemType == D3DSPR_CONST)
        {
            memcpy(pBuffer, p, dwCount * sizeof(VVM_WORD));
        }
        else
        {
            // Set only the first element of the register batch
            for (UINT i=0; i < dwCount; i++)
            {
                ((VVM_WORD*)pBuffer)[i] = p[i * VVMVERTEXBATCH];
            }
        }
    }
    D3D_CATCH;

    return D3D_OK;
}
//-----------------------------------------------------------------------------
// - allocates memory for the shader
// - validates shader code
// - computes output FVF and vertex elements offsets
//
void CVertexVM::ValidateShader(CVShaderCodeI* shader, DWORD* orgShader)
{
    // shader will be already stripped of comments upon reaching here if stripping
    // is necessary, so always use CodeAndComment size
    DWORD dwCodeOnlySize;
    DWORD dwCodeAndCommentSize;
    HRESULT hr = ComputeShaderCodeSize(orgShader, &dwCodeOnlySize, 
                                        &dwCodeAndCommentSize, NULL);
    if (hr != S_OK)
        D3D_THROW(hr, "");
    // Initialize shader header and allocate memory for the shader code

    shader->m_dwSize = dwCodeAndCommentSize >> 2; // Size in DWORDs
    shader->m_pdwCode = new DWORD[shader->m_dwSize];
    if (shader->m_pdwCode == NULL)
    {
        D3D_THROW_FAIL("Cannot allocate memory for shader code");
    }
    memcpy(shader->m_pdwCode, orgShader, dwCodeAndCommentSize);

    // Based on the what output registers are modified, we compute the
    // corresponding FVF id. The id will be used for memory allocation
    // of the output buffer and will be passed to the rasterizer
    DWORD   dwOutFVF = 0;
    DWORD nTexCoord = 0;        // Number of output texture coordinates
    // For each texture register stores the combined write mask.
    // Used to find how many floats are written to each texture coordinates
    DWORD TextureWritten[8];
    memset(TextureWritten, 0, sizeof(TextureWritten));

    m_pdwCurToken = shader->m_pdwCode;
    DWORD* pEnd = shader->m_pdwCode + shader->m_dwSize;

    shader->m_dwOutRegs = 0;
    shader->m_InstCount = 0;
    m_CurInstIndex = 0;

    if ((*m_pdwCurToken != D3DVS_VERSION(1, 1)) &&
        (*m_pdwCurToken != D3DVS_VERSION(1, 0)) )
    {
        D3D_THROW_FAIL("Invalid vertex shader code version");
    }
    m_pdwCurToken++;
    while (m_pdwCurToken < pEnd && *m_pdwCurToken != D3DVS_END())
    {
        DWORD * pdwNextToken = m_pdwCurToken;
        DWORD dwInst = *m_pdwCurToken;
        if (!IsInstructionToken(dwInst))
        {
            PrintInstCount();
            D3D_THROW_FAIL("Intruction token has 31 bit set");
        }
        DWORD dwOpCode = D3DSI_GETOPCODE(dwInst);
        m_pdwCurToken++;

        switch (dwOpCode)
        {
        case D3DSIO_COMMENT:
        case D3DSIO_NOP  : ; break;
        case D3DSIO_MOV  :
        case D3DSIO_ADD  :
        case D3DSIO_MAD  :
        case D3DSIO_MUL  :
        case D3DSIO_RCP  :
        case D3DSIO_RSQ  :
        case D3DSIO_DP3  :
        case D3DSIO_DP4  :
        case D3DSIO_MIN  :
        case D3DSIO_MAX  :
        case D3DSIO_SLT  :
        case D3DSIO_SGE  :
        case D3DSIO_EXP  :
        case D3DSIO_LOG  :
        case D3DSIO_EXPP :
        case D3DSIO_LOGP :
        case D3DSIO_LIT  :
        case D3DSIO_DST  :
        case D3DSIO_FRC  :
        case D3DSIO_M4x4 :
        case D3DSIO_M4x3 :
        case D3DSIO_M3x4 :
        case D3DSIO_M3x3 :
        case D3DSIO_M3x2 :
            {
                // Find out if output register are modified by the command and
                // update the output FVF
                DWORD dwOffset;
                EvalDestination();
                VVM_WORD*   m_pOutRegister = NULL;
                if ((m_pDest - m_dwOffset * VVMVERTEXBATCH) != m_reg.m_r[0])
                {
                    dwOffset = m_dwOffset;
                    m_pOutRegister = m_pDest - m_dwOffset * VVMVERTEXBATCH;

                    if (m_pOutRegister == m_reg.m_output[0])
                    {
                        if (dwOffset == D3DSRO_POSITION)
                        {
                            dwOutFVF |= D3DFVF_XYZRHW;
                            shader->m_dwOutRegs |= CPSGPShader_POSITION;
                        }
                        else
                        if (dwOffset == D3DSRO_FOG)
                        {
                            dwOutFVF |= D3DFVF_FOG;
                            shader->m_dwOutRegs |= CPSGPShader_FOG;
                        }
                        else
                        if (dwOffset == D3DSRO_POINT_SIZE)
                        {
                            dwOutFVF |= D3DFVF_PSIZE;
                            shader->m_dwOutRegs |= CPSGPShader_PSIZE;
                        }
                    }
                    else
                    if (m_pOutRegister == m_reg.m_color[0])
                        if (dwOffset == 0)
                        {
                            dwOutFVF |= D3DFVF_DIFFUSE;
                            shader->m_dwOutRegs |= CPSGPShader_DIFFUSE;
                        }
                        else
                        {
                            dwOutFVF |= D3DFVF_SPECULAR;
                            shader->m_dwOutRegs |= CPSGPShader_SPECULAR;
                        }
                    else
                    if (m_pOutRegister == m_reg.m_texture[0])
                    {
                        if (TextureWritten[dwOffset] == 0)
                        {
                            nTexCoord++;
                        }
                        TextureWritten[dwOffset] |= m_WriteMask;
                    }
                    else
                    if (m_pOutRegister == m_reg.m_a[0])
                    {
                    }
                    else
                    {
                        PrintInstCount();
                        D3D_THROW_FAIL("Invalid output register offset");
                    }
                }
            }
            break;
        default:
            {
                PrintInstCount();
                D3D_THROW_FAIL("Invalid shader opcode");
            }
        }
        m_pdwCurToken = pdwNextToken + GetInstructionLength(dwInst);
        shader->m_InstCount++;
        if (dwOpCode != D3DSIO_COMMENT)
        {
            m_CurInstIndex++;
            if (m_CurInstIndex > D3DVS_MAXINSTRUCTIONCOUNT_V1_1)
            {
                D3D_THROW_FAIL("Too many instructions in the shader");
            }
        }
    }


#ifdef DBG
    // compute per-instruction stuff for shader
    if (shader->m_InstCount)
    {
        shader->m_pInst = new VShaderInst[shader->m_InstCount];
        if (shader->m_pInst == NULL)
        {
            D3D_THROW_FAIL("Cannot allocate memory for shader instructions");
        }
        memset( shader->m_pInst, 0, sizeof(VShaderInst)*shader->m_InstCount );

        DWORD dwCurInst = 0;
        // Remove version
        m_pdwCurToken = shader->m_pdwCode + 1;
        pEnd = shader->m_pdwCode + shader->m_dwSize;
        while( m_pdwCurToken < pEnd && *m_pdwCurToken != D3DVS_END())
        {
            UINT ilength = GetInstructionLength(*m_pdwCurToken);
            DWORD dwOpCode = D3DSI_GETOPCODE(*m_pdwCurToken);
            if (dwOpCode == D3DSIO_COMMENT)
            {
                shader->m_pInst[dwCurInst].m_Tokens[0] = *m_pdwCurToken;
                shader->m_pInst[dwCurInst].m_pComment = (m_pdwCurToken+1);
                shader->m_pInst[dwCurInst].m_cdwComment = ilength - 1;
            }
            else
            {
                memcpy( shader->m_pInst[dwCurInst].m_Tokens, m_pdwCurToken,
                    4*ilength );
                VertexShaderInstDisAsm( shader->m_pInst[dwCurInst].m_String,
                    sizeof( shader->m_pInst[dwCurInst].m_String ) /
                        sizeof( shader->m_pInst[dwCurInst].m_String[ 0 ] ),
                    shader->m_pInst[dwCurInst].m_Tokens, 0x0 );
            }
            m_pdwCurToken += ilength;
            dwCurInst++;
        }

    }
#endif

    dwOutFVF |= nTexCoord << D3DFVF_TEXCOUNT_SHIFT;

    // Compute output vertex offsets and size

    shader->m_dwOutVerSize = 4 * sizeof(float); // X, Y, Z, RHW
    shader->m_nOutTexCoord = nTexCoord;
    DWORD dwOffset = 4 * sizeof(float); // Current offset in the output vertex

    if ((dwOutFVF & D3DFVF_XYZRHW) == 0)
    {
        D3D_THROW_FAIL("Position is not written by shader");
    }

    shader->m_dwPointSizeOffset = dwOffset;
    if (dwOutFVF & D3DFVF_PSIZE)
    {
        dwOffset += 4;
        shader->m_dwOutVerSize += 4;
    }
     shader->m_dwDiffuseOffset = dwOffset;
    if (dwOutFVF & D3DFVF_DIFFUSE)
    {
        shader->m_dwOutVerSize += 4;
        dwOffset += 4;
    }
    shader->m_dwSpecularOffset = dwOffset;
    if (dwOutFVF & D3DFVF_SPECULAR)
    {
        dwOffset += 4;
        shader->m_dwOutVerSize += 4;
    }
    shader->m_dwFogOffset = dwOffset;
    if (dwOutFVF & D3DFVF_FOG)
    {
        dwOffset += 4;
        shader->m_dwOutVerSize += 4;
    }
    // Initialize texture coordinates
    shader->m_dwTextureOffset = dwOffset;
    if (nTexCoord)
    {
        for (DWORD i = 0; i < nTexCoord; i++)
        {
            DWORD n;    // Size of texture coordinates
            if (TextureWritten[i] == 0)
            {
                D3D_THROW_FAIL("Texture coordinates are not continuous");
            }
            switch (TextureWritten[i])
            {
            case D3DSP_WRITEMASK_ALL:
                dwOutFVF |= D3DFVF_TEXCOORDSIZE4(i);
                n = 4 * sizeof(float);
                break;
            case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2:
                dwOutFVF |= D3DFVF_TEXCOORDSIZE3(i);
                n = 3 * sizeof(float);
                break;
            case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1:
                dwOutFVF |= D3DFVF_TEXCOORDSIZE2(i);
                n = 2 * sizeof(float);
                break;
            case D3DSP_WRITEMASK_0:
                dwOutFVF |= D3DFVF_TEXCOORDSIZE1(i);
                n = 1 * sizeof(float);
                break;
            default:
                D3D_THROW_FAIL("Invalid write mask for texture register");
            }
            shader->m_dwOutVerSize += n;
            shader->m_dwOutTexCoordSize[i] = n;
            dwOffset += n;
        }
    }
    shader->m_dwOutFVF = dwOutFVF;
}
//-----------------------------------------------------------------------------
CVShaderCode* CVertexVM::CreateShader(CVElement* pElements, DWORD dwNumElements,
                                      DWORD* pCode)
{
    CVShaderCodeI* pShaderCode = NULL;
    try
    {
        pShaderCode = new CVShaderCodeI();
        if (pShaderCode == NULL)
        {
            D3D_THROW(E_OUTOFMEMORY, "Cannot allocate memory");
        }

        ValidateShader(pShaderCode, pCode);
        return pShaderCode;
    }
    catch (HRESULT e)
    {
        delete pShaderCode;
        D3D_ERR("Error in shader code creation");
        return NULL;
    }
}
//-----------------------------------------------------------------------------
HRESULT CVertexVM::SetActiveShader(CVShaderCode* pCode)
{
    m_pCurrentShader = (CVShaderCodeI*)pCode;
    return D3D_OK;
}
//-----------------------------------------------------------------------------
// - parses destination token
// - computes m_pDest, m_WrideMask, m_dwOffset for the destination
// - current token pointer is andvanced to the next token
//
void CVertexVM::EvalDestination()
{
    DWORD dwCurToken = *m_pdwCurToken;
    DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    m_dwOffset = D3DSI_GETREGNUM(dwCurToken);
    m_WriteMask = D3DSI_GETWRITEMASK(dwCurToken);
    switch (dwRegType)
    {
    case D3DSPR_TEMP:
        m_pDest = m_reg.m_r[0];
        break;
    case D3DSPR_RASTOUT:
        m_pDest = m_reg.m_output[0];
        break;
    case D3DSPR_ATTROUT:
        m_pDest = m_reg.m_color[0];
        break;
    case D3DSPR_TEXCRDOUT:
        m_pDest = m_reg.m_texture[0];
        break;
    case D3DSPR_ADDR:
        m_pDest = m_reg.m_a[0];
        break;
    default:
        PrintInstCount();
        D3D_THROW_FAIL("Invalid register for destination");
    }
    m_pdwCurToken++;
    m_pDest += m_dwOffset * VVMVERTEXBATCH;
}
//---------------------------------------------------------------------
void CVertexVM::PrintInstCount()
{
    D3D_ERR("Error in instruction number: %d", m_CurInstIndex + 1);
}
//---------------------------------------------------------------------
// Computes m_Source[index] and advances m_pdwCurToken
//
void CVertexVM::EvalSource(DWORD index)
{
    const DWORD dwCurToken = *m_pdwCurToken;
    const DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    const DWORD dwOffset = D3DSI_GETREGNUM(dwCurToken);
    DWORD swizzle = D3DVS_GETSWIZZLE(dwCurToken);
    VVM_WORD *src;
    VVM_WORD *outsrc = m_Source[index];

    if (dwRegType == D3DSPR_CONST)
    {
        D3DVS_ADDRESSMODE_TYPE am;
        am = (D3DVS_ADDRESSMODE_TYPE)D3DVS_GETADDRESSMODE(dwCurToken);
        int offset = (int)dwOffset;
        if (am == D3DVS_ADDRMODE_RELATIVE)
        {
            for (UINT i=0; i < m_count; i++)
            {
                int relOffset = *(int*)&m_reg.m_a[0][i].x;
                offset = (int)dwOffset + relOffset;
#if DBG
                if (offset < 0 || offset >= D3DVS_CONSTREG_MAX_V1_1)
                {
                    PrintInstCount();
                    D3D_THROW_FAIL("Constant register index is out of bounds");
                }
                if (!m_c_initialized[offset])
                {
                    PrintInstCount();
                    D3D_ERR("Attempt to read from uninitialized constant register %d", offset);
                    D3D_THROW_FAIL("");
                }
#endif
                src = &m_reg.m_c[offset];
                if (swizzle == D3DVS_NOSWIZZLE)
                    *outsrc = *src;
                else
                {
                    // Where to take X
                    const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
                    // Where to take Y
                    const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
                    // Where to take Z
                    const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
                    // Where to take W
                    const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
                    outsrc->x = ((float*)src)[dwSrcX];
                    outsrc->y = ((float*)src)[dwSrcY];
                    outsrc->z = ((float*)src)[dwSrcZ];
                    outsrc->w = ((float*)src)[dwSrcW];
                }
                outsrc++;
            }
        }
        else
        {
#if DBG
            if (!m_c_initialized[offset])
            {
                PrintInstCount();
                D3D_ERR("Attempt to read from uninitialized constant register %d", offset);
                D3D_THROW_FAIL("");
            }
#endif
            src = &m_reg.m_c[offset];
            if (swizzle == D3DVS_NOSWIZZLE)
            {
                for (UINT i=0; i < m_count; i++)
                {
                    outsrc[i] = *src;
                }
            }
            else
            {
                // Where to take X
                const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
                // Where to take Y
                const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
                // Where to take Z
                const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
                // Where to take W
                const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
                VVM_WORD v;
                v.x = ((float*)src)[dwSrcX];
                v.y = ((float*)src)[dwSrcY];
                v.z = ((float*)src)[dwSrcZ];
                v.w = ((float*)src)[dwSrcW];
                for (UINT i=0; i < m_count; i++)
                {
                    outsrc[i] = v;
                }
            }
        }
    }
    else
    {
        src = this->GetDataAddr(dwRegType, dwOffset);

        if (swizzle == D3DVS_NOSWIZZLE)
            memcpy(outsrc, src, m_count * sizeof(VVM_WORD));
        else
        {
            // Where to take X
            const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
            // Where to take Y
            const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
            // Where to take Z
            const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
            // Where to take W
            const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
            for (UINT i=0; i < m_count; i++)
            {
                outsrc->x = ((float*)src)[dwSrcX];
                outsrc->y = ((float*)src)[dwSrcY];
                outsrc->z = ((float*)src)[dwSrcZ];
                outsrc->w = ((float*)src)[dwSrcW];
                outsrc++;
                src++;
            }
        }
    }

    if (D3DVS_GETSRCMODIFIER(dwCurToken) == D3DSPSM_NEG)
    {
        VVM_WORD *outsrc = m_Source[index];
        for (UINT i=0; i < m_count; i++)
        {
            outsrc->x = -outsrc->x;
            outsrc->y = -outsrc->y;
            outsrc->z = -outsrc->z;
            outsrc->w = -outsrc->w;
            outsrc++;
        }
    }
    m_pdwCurToken++;
}
//---------------------------------------------------------------------
// Computes source operands and advances m_pdwCurToken
//
// Parameters:
//      index    - index of the first source operand
//      count    - number of source operands
//
void CVertexVM::EvalSource(DWORD index, DWORD count)
{
    const DWORD dwCurToken = *m_pdwCurToken;
    const DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    const DWORD dwOffset = D3DSI_GETREGNUM(dwCurToken);
    DWORD swizzle = D3DVS_GETSWIZZLE(dwCurToken);

    VVM_WORD *src;
    VVM_WORD *outsrc = m_Source[index];

    if (dwRegType == D3DSPR_CONST)
    {
        D3DVS_ADDRESSMODE_TYPE am;
        am = (D3DVS_ADDRESSMODE_TYPE)D3DVS_GETADDRESSMODE(dwCurToken);
        int offset = (int)dwOffset;
        if (am == D3DVS_ADDRMODE_RELATIVE)
        {
            for (UINT j=0; j < count; j++)
            {
                VVM_WORD *outsrc = m_Source[index + j];
                for (UINT i=0; i < m_count; i++)
                {
                    int relOffset = *(int*)&m_reg.m_a[0][i].x;
                    offset = (int)dwOffset + relOffset;
#if DBG
                    if (offset < 0 || offset >= D3DVS_CONSTREG_MAX_V1_1)
                    {
                        PrintInstCount();
                        D3D_THROW_FAIL("Constant register index is out of bounds");
                    }
                    if (!m_c_initialized[offset])
                    {
                        PrintInstCount();
                        D3D_ERR("Attempt to read from uninitialized constant register %d", offset);
                        D3D_THROW_FAIL("");
                    }
#endif // DBG
                    src = &m_reg.m_c[offset] + j;
                    *outsrc = *src;
                    outsrc++;
                }
            }
        }
        else
        {
#if DBG
            for (UINT i = 0; i < count; i++)
            {
                if (!m_c_initialized[offset + i])
                {
                    PrintInstCount();
                    D3D_ERR("Attempt to read from uninitialized constant register %d", i);
                    D3D_THROW_FAIL("");
                }
            }
#endif
            src = &m_reg.m_c[offset];
            for (UINT j=0; j < count; j++)
            {
                for (UINT i=0; i < m_count; i++)
                {
                    outsrc[i] = *src;
                }
                src++;
                outsrc += VVMVERTEXBATCH;
            }
        }
    }
    else
    {
        src = this->GetDataAddr(dwRegType, dwOffset);
        UINT size = m_count * sizeof(VVM_WORD);
        for (UINT i=0; i < count; i++)
        {
            memcpy(outsrc, src, size);
            outsrc += VVMVERTEXBATCH;
            src += VVMVERTEXBATCH;
        }
    }
    m_pdwCurToken++;
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMov()
{
    EvalDestination();
    EvalSource(0);

    if (m_pDest == m_reg.m_a[0])
    {
        for (UINT i=0; i < m_count; i++)
        {
            float p = (float)floor(m_Source[0][i].x);
            *(int*)&m_pDest[i].x = FTOI(p);
        }
    }
    else
    {
        if (m_WriteMask == D3DSP_WRITEMASK_ALL)
        {
            memcpy(m_pDest,  m_Source[0], m_BatchSize);
        }
        else
        {
            for (UINT i=0; i < m_count; i++)
            {
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = m_Source[0][i].x;
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y = m_Source[0][i].y;
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = m_Source[0][i].z;
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = m_Source[0][i].w;
            }
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstAdd()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = m_Source[0][i].x + m_Source[1][i].x;
            m_pDest[i].y = m_Source[0][i].y + m_Source[1][i].y;
            m_pDest[i].z = m_Source[0][i].z + m_Source[1][i].z;
            m_pDest[i].w = m_Source[0][i].w + m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = m_Source[0][i].x + m_Source[1][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y + m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z + m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].w + m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMad()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);
    EvalSource(2);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = m_Source[0][i].x * m_Source[1][i].x + m_Source[2][i].x;
            m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y + m_Source[2][i].y;
            m_pDest[i].z = m_Source[0][i].z * m_Source[1][i].z + m_Source[2][i].z;
            m_pDest[i].w = m_Source[0][i].w * m_Source[1][i].w + m_Source[2][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = m_Source[0][i].x * m_Source[1][i].x + m_Source[2][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y + m_Source[2][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z * m_Source[1][i].z + m_Source[2][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].w * m_Source[1][i].w + m_Source[2][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMul()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = m_Source[0][i].x * m_Source[1][i].x;
            m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y;
            m_pDest[i].z = m_Source[0][i].z * m_Source[1][i].z;
            m_pDest[i].w = m_Source[0][i].w * m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = m_Source[0][i].x * m_Source[1][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z * m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].w * m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstDP3()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =
            m_pDest[i].y =
            m_pDest[i].z =
            m_pDest[i].w = m_Source[0][i].x * m_Source[1][i].x +
                           m_Source[0][i].y * m_Source[1][i].y +
                           m_Source[0][i].z * m_Source[1][i].z;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = m_Source[0][i].x * m_Source[1][i].x +
                      m_Source[0][i].y * m_Source[1][i].y +
                      m_Source[0][i].z * m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstDP4()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =
            m_pDest[i].y =
            m_pDest[i].z =
            m_pDest[i].w = m_Source[0][i].x * m_Source[1][i].x +
                           m_Source[0][i].y * m_Source[1][i].y +
                           m_Source[0][i].z * m_Source[1][i].z +
                           m_Source[0][i].w * m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = m_Source[0][i].x * m_Source[1][i].x +
                      m_Source[0][i].y * m_Source[1][i].y +
                      m_Source[0][i].z * m_Source[1][i].z +
                      m_Source[0][i].w * m_Source[1][i].w;
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstRcp()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = m_Source[0][i].w;
            if (v == 1.0f)
            {
                // Must be exactly 1.0
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = 1.0f;
            }
            else
            if (v == 0)
            {
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = PLUS_INFINITY();
            }
            else
            {
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = 1.0f/v;
            }
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = m_Source[0][i].w;
            if (FLOAT_EQZ(v))
                v = PLUS_INFINITY();
            else
            if (v != 1.0f)
                v = 1.0f/v;

            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstRsq()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v == 1.0f)
            {
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = 1.0f;
            }
            else
            if (v == 0)
            {
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = PLUS_INFINITY();
            }
            else
            {
                v = (float)(1.0f / sqrt(v));
                m_pDest[i].x =
                m_pDest[i].y =
                m_pDest[i].z =
                m_pDest[i].w = v;
            }
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (FLOAT_EQZ(v))
                v = PLUS_INFINITY();
            else
            if (FLOAT_CMP_PONE(v, !=))
                v = (float)(1.0f / sqrt(v));

            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstSlt()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = (m_Source[0][i].x < m_Source[1][i].x) ? 1.0f : 0.0f;
            m_pDest[i].y = (m_Source[0][i].y < m_Source[1][i].y) ? 1.0f : 0.0f;
            m_pDest[i].z = (m_Source[0][i].z < m_Source[1][i].z) ? 1.0f : 0.0f;
            m_pDest[i].w = (m_Source[0][i].w < m_Source[1][i].w) ? 1.0f : 0.0f;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = (m_Source[0][i].x < m_Source[1][i].x) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = (m_Source[0][i].y < m_Source[1][i].y) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = (m_Source[0][i].z < m_Source[1][i].z) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = (m_Source[0][i].w < m_Source[1][i].w) ? 1.0f : 0.0f;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstSge()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = (m_Source[0][i].x >= m_Source[1][i].x) ? 1.0f : 0.0f;
            m_pDest[i].y = (m_Source[0][i].y >= m_Source[1][i].y) ? 1.0f : 0.0f;
            m_pDest[i].z = (m_Source[0][i].z >= m_Source[1][i].z) ? 1.0f : 0.0f;
            m_pDest[i].w = (m_Source[0][i].w >= m_Source[1][i].w) ? 1.0f : 0.0f;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = (m_Source[0][i].x >= m_Source[1][i].x) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = (m_Source[0][i].y >= m_Source[1][i].y) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = (m_Source[0][i].z >= m_Source[1][i].z) ? 1.0f : 0.0f;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = (m_Source[0][i].w >= m_Source[1][i].w) ? 1.0f : 0.0f;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMin()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x=(m_Source[0][i].x < m_Source[1][i].x) ? m_Source[0][i].x : m_Source[1][i].x;
            m_pDest[i].y=(m_Source[0][i].y < m_Source[1][i].y) ? m_Source[0][i].y : m_Source[1][i].y;
            m_pDest[i].z=(m_Source[0][i].z < m_Source[1][i].z) ? m_Source[0][i].z : m_Source[1][i].z;
            m_pDest[i].w=(m_Source[0][i].w < m_Source[1][i].w) ? m_Source[0][i].w : m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x=(m_Source[0][i].x < m_Source[1][i].x) ? m_Source[0][i].x : m_Source[1][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y=(m_Source[0][i].y < m_Source[1][i].y) ? m_Source[0][i].y : m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z=(m_Source[0][i].z < m_Source[1][i].z) ? m_Source[0][i].z : m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w=(m_Source[0][i].w < m_Source[1][i].w) ? m_Source[0][i].w : m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstMax()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x=(m_Source[0][i].x >= m_Source[1][i].x) ? m_Source[0][i].x : m_Source[1][i].x;
            m_pDest[i].y=(m_Source[0][i].y >= m_Source[1][i].y) ? m_Source[0][i].y : m_Source[1][i].y;
            m_pDest[i].z=(m_Source[0][i].z >= m_Source[1][i].z) ? m_Source[0][i].z : m_Source[1][i].z;
            m_pDest[i].w=(m_Source[0][i].w >= m_Source[1][i].w) ? m_Source[0][i].w : m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x=(m_Source[0][i].x >= m_Source[1][i].x) ? m_Source[0][i].x : m_Source[1][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y=(m_Source[0][i].y >= m_Source[1][i].y) ? m_Source[0][i].y : m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z=(m_Source[0][i].z >= m_Source[1][i].z) ? m_Source[0][i].z : m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w=(m_Source[0][i].w >= m_Source[1][i].w) ? m_Source[0][i].w : m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
// Approximation 2**x
//
float ExpApprox(float x)
{
    float tmp = (float)pow(2, x);
    // Artificially reduce precision
    DWORD tmpd = *(DWORD*)&tmp & 0xFFFFFF00;
    return *(float*)&tmpd;
}
//-----------------------------------------------------------------------------
// Approximation Log2(x)
//
const float LOG2 = (float)(1.0f/log(2));

float LogApprox(float x)
{
    float tmp = (float)(log(x) * LOG2);
    // Artificially reduce precision
    DWORD tmpd = *(DWORD*)&tmp & 0xFFFFFF00;
    return *(float*)&tmpd;
}
//-----------------------------------------------------------------------------
// Full precision EXP
//
void CVertexVM::InstExp()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = (float)pow(2, m_Source[0][i].w);
            m_pDest[i].x = v;
            m_pDest[i].y = v;
            m_pDest[i].z = v;
            m_pDest[i].w = v;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = (float)pow(2, m_Source[0][i].w);

            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = v;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = v;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = v;
        }
    }
}
//-----------------------------------------------------------------------------
// Low precision EXP
//
void CVertexVM::InstExpP()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float w = m_Source[0][i].w; // Input value
            float v = (float)floor(w);

            m_pDest[i].x = (float)pow(2, v);
            m_pDest[i].y = w - v;
            m_pDest[i].z = ExpApprox(w);
            m_pDest[i].w = 1;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float w = m_Source[0][i].w; // Input value
            float v = (float)floor(w);

            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = (float)pow(2, v);
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = w - v;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = ExpApprox(w);
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = 1;
        }
    }
}
//-----------------------------------------------------------------------------
// Full precision LOG
//
void CVertexVM::InstLog()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v != 0)
            {
                m_pDest[i].x = 
                m_pDest[i].y = 
                m_pDest[i].z = 
                m_pDest[i].w = (float)(log(v) * LOG2);
            }
            else
            {
                m_pDest[i].x = 
                m_pDest[i].y = 
                m_pDest[i].z = 
                m_pDest[i].w = MINUS_INFINITY();
            }
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v != 0)
            {
                v = (float)(log(v) * LOG2);
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = v;
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y =  v;
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = v;
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = v;
            }
            else
            {
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = MINUS_INFINITY();
            }
        }
    }
}
//-----------------------------------------------------------------------------
// Low precision LOG
//
void CVertexVM::InstLogP()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v != 0)
            {
                // -128.0 <= exponent < 127.0
                int p = (int)(*(DWORD*)&v >> 23) - 127;
                m_pDest[i].x = (float)p;                  
                // 1.0 <= mantissa < 2.0
                p = (*(DWORD*)&v & 0x7FFFFF) | 0x3F800000;
                m_pDest[i].y =  *(float*)&p;              
                m_pDest[i].z = LogApprox(v);
                m_pDest[i].w = 1.0f;
            }
            else
            {
                m_pDest[i].x = MINUS_INFINITY();
                m_pDest[i].y = 1.0f;
                m_pDest[i].z = MINUS_INFINITY();
                m_pDest[i].w = 1.0f;
            }
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            float v = ABSF(m_Source[0][i].w);
            if (v != 0)
            {
                // -128.0 <= exponent < 127.0
                int p = (int)(*(DWORD*)&v >> 23) - 127;
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = (float)p;                  
                // 1.0 <= mantissa < 2.0
                p = (*(DWORD*)&v & 0x7FFFFF) | 0x3F800000;
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y =  *(float*)&p;              
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = LogApprox(v);
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = 1.0f;
            }
            else
            {
                if (m_WriteMask & D3DSP_WRITEMASK_0)
                    m_pDest[i].x = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_1)
                    m_pDest[i].y = 1.0f;
                if (m_WriteMask & D3DSP_WRITEMASK_2)
                    m_pDest[i].z = MINUS_INFINITY();
                if (m_WriteMask & D3DSP_WRITEMASK_3)
                    m_pDest[i].w = 1.0f;
            }
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstFrc()
{
    EvalDestination();
    EvalSource(0);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = m_Source[0][i].x - (float)floor(m_Source[0][i].x);
            m_pDest[i].y = m_Source[0][i].y - (float)floor(m_Source[0][i].y);
            m_pDest[i].z = m_Source[0][i].z - (float)floor(m_Source[0][i].z);
            m_pDest[i].w = m_Source[0][i].w - (float)floor(m_Source[0][i].w);
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = m_Source[0][i].x - (float)floor(m_Source[0][i].x);
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y - (float)floor(m_Source[0][i].y);
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z - (float)floor(m_Source[0][i].z);
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].w - (float)floor(m_Source[0][i].w);
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstLit()
{
    EvalDestination();
    EvalSource(0);

    for (UINT i=0; i < m_count; i++)
    {
        if (m_WriteMask & D3DSP_WRITEMASK_0)
           m_pDest[i].x = 1;
        if (m_WriteMask & D3DSP_WRITEMASK_1)
            m_pDest[i].y = 0;
        if (m_WriteMask & D3DSP_WRITEMASK_2)
            m_pDest[i].z = 0;
        if (m_WriteMask & D3DSP_WRITEMASK_3)
            m_pDest[i].w = 1;
        float power = m_Source[0][i].w;
        const float MAXPOWER = 127.9961f;
        if (power < -MAXPOWER)
            power = -MAXPOWER;          // Fits into 8.8 fixed point format
        else
        if (power > MAXPOWER)
            power = MAXPOWER;          // Fits into 8.8 fixed point format

        if (m_Source[0][i].x > 0)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].x;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                if (m_Source[0][i].y > 0)
                {
                    // Allowed approximation is EXP(power * LOG(m_Source[0].y))
                    m_pDest[i].z = (float)(pow(m_Source[0][i].y, power));
                }
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstDst()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x = 1;
            m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y;
            m_pDest[i].z = m_Source[0][i].z;
            m_pDest[i].w = m_Source[1][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x = 1;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].y * m_Source[1][i].y;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z = m_Source[0][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[1][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM4x4()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 4);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z +
                            m_Source[0][i].w * m_Source[1][i].w;
            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z +
                            m_Source[0][i].w * m_Source[2][i].w;
            m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                            m_Source[0][i].y * m_Source[3][i].y +
                            m_Source[0][i].z * m_Source[3][i].z +
                            m_Source[0][i].w * m_Source[3][i].w;
            m_pDest[i].w =  m_Source[0][i].x * m_Source[4][i].x +
                            m_Source[0][i].y * m_Source[4][i].y +
                            m_Source[0][i].z * m_Source[4][i].z +
                            m_Source[0][i].w * m_Source[4][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z +
                                m_Source[0][i].w * m_Source[1][i].w;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z +
                                m_Source[0][i].w * m_Source[2][i].w;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                                m_Source[0][i].y * m_Source[3][i].y +
                                m_Source[0][i].z * m_Source[3][i].z +
                                m_Source[0][i].w * m_Source[3][i].w;
            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w = m_Source[0][i].x * m_Source[4][i].x +
                                m_Source[0][i].y * m_Source[4][i].y +
                                m_Source[0][i].z * m_Source[4][i].z +
                                m_Source[0][i].w * m_Source[4][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM4x3()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 3);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z +
                            m_Source[0][i].w * m_Source[1][i].w;

            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z +
                            m_Source[0][i].w * m_Source[2][i].w;

            m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                            m_Source[0][i].y * m_Source[3][i].y +
                            m_Source[0][i].z * m_Source[3][i].z +
                            m_Source[0][i].w * m_Source[3][i].w;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z +
                                m_Source[0][i].w * m_Source[1][i].w;

            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y = m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z +
                                m_Source[0][i].w * m_Source[2][i].w;

            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                                m_Source[0][i].y * m_Source[3][i].y +
                                m_Source[0][i].z * m_Source[3][i].z +
                                m_Source[0][i].w * m_Source[3][i].w;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM3x4()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 4);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z;

            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z;

            m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                            m_Source[0][i].y * m_Source[3][i].y +
                            m_Source[0][i].z * m_Source[3][i].z;

            m_pDest[i].w =  m_Source[0][i].x * m_Source[4][i].x +
                            m_Source[0][i].y * m_Source[4][i].y +
                            m_Source[0][i].z * m_Source[4][i].z;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z;

            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z;

            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                                m_Source[0][i].y * m_Source[3][i].y +
                                m_Source[0][i].z * m_Source[3][i].z;

            if (m_WriteMask & D3DSP_WRITEMASK_3)
                m_pDest[i].w =  m_Source[0][i].x * m_Source[4][i].x +
                                m_Source[0][i].y * m_Source[4][i].y +
                                m_Source[0][i].z * m_Source[4][i].z;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM3x3()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 3);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z;
            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z;
            m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                            m_Source[0][i].y * m_Source[3][i].y +
                            m_Source[0][i].z * m_Source[3][i].z;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_2)
                m_pDest[i].z =  m_Source[0][i].x * m_Source[3][i].x +
                                m_Source[0][i].y * m_Source[3][i].y +
                                m_Source[0][i].z * m_Source[3][i].z;
        }
    }
}
//-----------------------------------------------------------------------------
void CVertexVM::InstM3x2()
{
    EvalDestination();
    EvalSource(0);
    EvalSource(1, 2);

    if (m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        for (UINT i=0; i < m_count; i++)
        {
            m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                            m_Source[0][i].y * m_Source[1][i].y +
                            m_Source[0][i].z * m_Source[1][i].z;
            m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                            m_Source[0][i].y * m_Source[2][i].y +
                            m_Source[0][i].z * m_Source[2][i].z;
        }
    }
    else
    {
        for (UINT i=0; i < m_count; i++)
        {
            if (m_WriteMask & D3DSP_WRITEMASK_0)
                m_pDest[i].x =  m_Source[0][i].x * m_Source[1][i].x +
                                m_Source[0][i].y * m_Source[1][i].y +
                                m_Source[0][i].z * m_Source[1][i].z;
            if (m_WriteMask & D3DSP_WRITEMASK_1)
                m_pDest[i].y =  m_Source[0][i].x * m_Source[2][i].x +
                                m_Source[0][i].y * m_Source[2][i].y +
                                m_Source[0][i].z * m_Source[2][i].z;
        }
    }
}
//-----------------------------------------------------------------------------
HRESULT CVertexVM::ExecuteShader(LPD3DFE_PROCESSVERTICES pv, UINT vertexCount)
{
    if (m_pCurrentShader == NULL)
    {
        D3D_ERR("No current shader set in the Virtual Shader Machine");
        return D3DERR_INVALIDCALL;
    }
    try
    {
        m_count = vertexCount;
        m_BatchSize = vertexCount * sizeof(VVM_WORD);
        // Skip version
        m_pdwCurToken = m_pCurrentShader->m_pdwCode + 1;

        DWORD* pEnd = m_pCurrentShader->m_pdwCode + m_pCurrentShader->m_dwSize;
        pEnd -= 1;
        m_CurInstIndex = 0;

        // Initialize position register
        for (UINT i=0; i < m_count; i++)
        {
            m_reg.m_output[0][i].x = 0;
            m_reg.m_output[0][i].y = 0;
            m_reg.m_output[0][i].z = 0;
            m_reg.m_output[0][i].w = 1;
        }
        while (m_pdwCurToken < pEnd)
        {
            DWORD dwInst = *m_pdwCurToken;
            DWORD dwOpCode = D3DSI_GETOPCODE(dwInst);
            m_pdwCurToken++;
            switch (dwOpCode)
            {
            case D3DSIO_COMMENT: m_pdwCurToken += ((GetInstructionLength(dwInst))-1); break;
            case D3DSIO_NOP  : ; break;
            case D3DSIO_MOV  : InstMov(); break;
            case D3DSIO_ADD  : InstAdd(); break;
            case D3DSIO_MAD  : InstMad(); break;
            case D3DSIO_MUL  : InstMul(); break;
            case D3DSIO_RCP  : InstRcp(); break;
            case D3DSIO_RSQ  : InstRsq(); break;
            case D3DSIO_DP3  : InstDP3(); break;
            case D3DSIO_DP4  : InstDP4(); break;
            case D3DSIO_MIN  : InstMin(); break;
            case D3DSIO_MAX  : InstMax(); break;
            case D3DSIO_SLT  : InstSlt(); break;
            case D3DSIO_SGE  : InstSge(); break;
            case D3DSIO_EXP  : InstExp(); break;
            case D3DSIO_LOG  : InstLog(); break;
            case D3DSIO_EXPP : InstExpP(); break;
            case D3DSIO_LOGP : InstLogP(); break;
            case D3DSIO_LIT  : InstLit(); break;
            case D3DSIO_DST  : InstDst(); break;
            case D3DSIO_FRC  : InstFrc(); break;
            case D3DSIO_M4x4 : InstM4x4(); break;
            case D3DSIO_M4x3 : InstM4x3(); break;
            case D3DSIO_M3x4 : InstM3x4(); break;
            case D3DSIO_M3x3 : InstM3x3(); break;
            case D3DSIO_M3x2 : InstM3x2(); break;
            default:
                {
                    PrintInstCount();
                    D3D_THROW_FAIL("Invalid shader opcode");
                }
            }
            if (dwOpCode != D3DSIO_COMMENT)
                m_CurInstIndex++;
        }
        m_CurInstIndex = 0;
    }
    D3D_CATCH;

    return D3D_OK;
}
//-----------------------------------------------------------------------------
HRESULT CVertexVM::GetDataPointer(DWORD dwMemType, VVM_WORD ** pData)
{
    try
    {
        *pData = this->GetDataAddr(dwMemType, 0);
    }
    catch (HRESULT e)
    {
        *pData = NULL;
        return D3DERR_INVALIDCALL;
    }
    return D3D_OK;
}
//---------------------------------------------------------------------
VVM_REGISTERS* CVertexVM::GetRegisters()
{
    return &m_reg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\i386\tclipp5.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul5

_matmul5  PROC    

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;


        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;


; notation in comments on stack gives the progress on the element.
; x, y, z mean input x y z
; x1-4 means x*_11, x*_11+y*_21, x*_11+y*_21+z*_31, x*_11+y*_21+z*_31+_41
; Some intermediate results x*_11+_41 and y*_21+z*_31 are denoted as x2

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31 y*_24 y*_21 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fxch    st(2)                           ; y*_21 y*_24 z*_31 w1 x1
        faddp   st(4),st                        ; y*_24 z*_31 w1 x2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34 y*_24 z*_31 w1 x2
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fxch    st(1)                           ; y*_24 z*_34 z*_31 w1 x2
        faddp   st(3),st                        ; z*_34 z*_31 w2 x2
        fxch    st(1)                           ; z*_31 z*_34 w2 x2
        faddp   st(3),st                        ; z*_34 w2 x3
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 z*_34 w2 x3
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fxch    st(1)                           ; z*_34 y1 w2 x3
        faddp   st(2),st                        ; y1 w3 x3
        fxch    st(2)                           ; x3 w3 y1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x4 w3 y1
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23 y*_22 z1 x4 w3 y1
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;
        fxch    st(4)                           ; w3 y*_22 z1 x4 y*_23 y1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w4 y*_22 z1 x4 y*_23 y1
        fxch    st(3)                           ; x4 y*_22 z1 w4 y*_23 y1
        fst     dword ptr [ebp]                 ;
        fxch    st(1)                           ; y*_22 x4 z1 w4 y*_23 y1
        faddp   st(5),st                        ; x4 z1 w4 y*_23 y2
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33 z*_32 x4 z1 w4 y*_23 y2
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;
        fxch    st(6)                           ; y2 z*_32 x4 z1 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y3 z*_32 x4 z1 w4 y*_23 z*_33
        fxch    st(3)                           ; z1 z*_32 x4 y3 w4 y*_23 z*_33
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 z*_32 x4 y3 w4 y*_23 z*_33
        fxch    st(5)                           ; y*_23 z*_32 x4 y3 w4 z2 z*_33
        faddp   st(6),st                        ; z*_32 x4 y3 w4 z2 z2
        faddp   st(2),st                        ; x4 y4 w4 z2 z2

;;
        fsubr   st,st(2)                        ; xx y4 w4 z2 z2
        fxch    st(4)                           ; z2 y4 w4 z2 xx
        faddp   st(3),st                        ; y4 w4 z4 xx
        fld     st                              ; y4 y4 w4 z4 xx
        fsubr   st,st(2)                        ; yy y4 w4 z4 xx
        fxch    st(1)                           ; y4 yy w4 z4 xx
        fstp    dword ptr [ebp+4]               ; yy w4 z4 xx
        fxch    st(3)                           ; xx w4 z4 yy
        fstp    tempxx                          ; w4 z4 yy
        fxch    st(1)                           ; z4 w4 yy
        fst     dword ptr [ebp+8]               ;
        fsubr   st,st(1)                        ; zz w4 yy
        fxch    st(2)                           ; yy w4 zz
        fstp    tempyy                          ; w4 zz
        fxch    st(1)                           ; zz w4
        fstp    tempzz                          ;

        fld1                                    ; 1 w4
        fdiv	st,st(1)                        ; 1/w w

;; Now compute the clipcodes.


;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCS_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCS_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCS_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCS_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCS_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCS_BACK

        mov     eax,dword ptr [ebp]     ; Get x
        mov     ebx,dword ptr [ebp+4]   ; Get y

        and     eax,esi                 ;
        and     ebx,esi                 ;

        shr     eax,32-1                ; D3DCS_LEFT
        mov     ecx,dword ptr [ebp+8]   ; Get z

        shr     ebx,32-4		; D3DCS_BOTTOM
        mov     edx,tempxx		;

        or      eax,ebx			; OR together clip flags
        and     ecx,esi			;

        shr     ecx,32-5		; D3DCS_FRONT
        and     edx,esi                 ;

        shr     edx,32-2                ; D3DCS_RIGHT
        mov     ebx,tempyy		;

        or      eax,ecx                 ;
        and     ebx,esi                 ;

        shr     ebx,32-3                ; D3DCS_TOP
        or      eax,edx                 ;

        mov     edx,tempzz
        or      eax,ebx                 ;

        and     edx,esi                 ;

        shr     edx,32-6                ; D3DCS_BACK
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv

        or      eax,edx                 ; Finish clip flag generation
        mov     ebx,pmat                ;

        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;

        test    eax,eax                 ; Bail if clip!=0
        jnz     ClipNonzero             ;

        push    eax                     ; Save clip flags
                                        ; ax gets trashed by fstsw in min/max calcs

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx


        fxch    st(1)                   ; we w
        fstp    st                      ;
                                        ; w
        fld     dword ptr [ebp]         ; x w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fld     dword ptr [ebp+4]       ; y x*scaleX w
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(1)                   ; x*scaleX y*scaleY w
        fmul    st,st(2)                ; x*w*scaleX y*scaleY w
        fxch    st(1)                   ; y*scaleY x*w*scaleX w
        fmul    st,st(2)                ; y*w*scaleY x*w*scaleX w
        fxch    st(1)                   ; x*w*scaleX y*w*scaleY w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(1)                   ; y x w
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fld     dword ptr [ebp+8]       ; z y x w
        fmul    st,st(3)                ; z y x w
        fxch    st(2)                   ; x y z w

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; x y z w
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
@@:     fxch    st(1)
        fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fstsw   ax
        sahf
        ja      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
@@:     fcom    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fstsw   ax
        sahf
        jb      @f
        fst     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
@@:     fxch    st(1)
NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]

        pop     eax         ; Get clip flags back
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    st          ; Get rid of 1/w
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw] ; store we
        jmp     short Return

_matmul5  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\i386\tclipp6.asm ===
.486p

.model flat

include offsets.asm
include pentium2.inc

.data

gD3DCS_LEFT   dd  01h
gD3DCS_RIGHT  dd  02h
gD3DCS_TOP    dd  04h
gD3DCS_BOTTOM dd  08h
gD3DCS_FRONT  dd  10h
gD3DCS_BACK   dd  20h

.code

if 0
D3DVERTEX_x	equ	0
D3DVERTEX_y	equ	4
D3DVERTEX_z	equ	8

D3DTLVERTEX_sx  equ 0
D3DTLVERTEX_sy  equ 4
D3DTLVERTEX_sz  equ 8
D3DTLVERTEX_rhw equ 12
D3DTLVERTEX_color   equ 16
D3DTLVERTEX_specular    equ 20
D3DTLVERTEX_tu  equ 24
D3DTLVERTEX_tv  equ 28

D3DFE_PROCESSVERTICES_rExtents equ 16*4
D3DFE_PROCESSVERTICES_vcache equ 20*4
D3DFE_PROCESSVERTICES_dwFlags equ 24*4

D3DFE_VIEWPORTCACHE_scaleX equ 0
D3DFE_VIEWPORTCACHE_scaleY equ 4
D3DFE_VIEWPORTCACHE_offsetX equ 8
D3DFE_VIEWPORTCACHE_offsetY equ 12

D3DDP_DONOTUPDATEEXTENTS equ 1

D3DMATRIXI__11 equ 0
D3DMATRIXI__12 equ 4
D3DMATRIXI__13 equ 8
D3DMATRIXI__14 equ 12
D3DMATRIXI__21 equ 16
D3DMATRIXI__22 equ 20
D3DMATRIXI__23 equ 24
D3DMATRIXI__24 equ 28
D3DMATRIXI__31 equ 32
D3DMATRIXI__32 equ 36
D3DMATRIXI__33 equ 40
D3DMATRIXI__34 equ 44
D3DMATRIXI__41 equ 48
D3DMATRIXI__42 equ 52
D3DMATRIXI__43 equ 56
D3DMATRIXI__44 equ 60
endif

PUBLIC  _matmul6

_matmul6  PROC

    pout    equ     dword ptr [esp+44]
    pin     equ     dword ptr [esp+48]
    pmat    equ     dword ptr [esp+52]
    hout    equ     dword ptr [esp+56]

    tempxx  equ     dword ptr [esp+16]
    tempyy  equ     dword ptr [esp+20]
    tempzz  equ     dword ptr [esp+24]
    tempx   equ     dword ptr [esp+28]
    tempy   equ     dword ptr [esp+32]
    tempz   equ     dword ptr [esp+36]

        sub     esp,24          ; Make room for locals

        push    ebx             ; Save regs
        push    esi             ;
        push    edi             ;
        push    ebp             ;

        mov     eax,pin         ; Get in ptr
        mov     ecx,pmat        ; Get mat ptr
        mov     ebp,pout        ; Get out ptr
        mov     esi,80000000h   ; Ready to compute clip codes

; float x, y, z, w, we;
; x = in->x*pv->mCTM._11 + in->y*pv-mCTM._21 + in->z*pv->mCTM._31 + pv->mCTM._41;
; y = in->x*pv->mCTM._12 + in->y*pv->mCTM._22 + in->z*pv->mCTM._32 + pv->mCTM._42;
; z = in->x*pv->mCTM._13 + in->y*pv->mCTM._23 + in->z*pv->mCTM._33 + pv->mCTM._43;
; we= in->x*pv->mCTM._14 + in->y*pv->mCTM._24 + in->z*pv->mCTM._34 + pv->mCTM._44;

        fld     dword ptr [eax+D3DVERTEX_x]     ; x1
        fmul    dword ptr [ecx+D3DMATRIXI__11]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__14]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__12]  ;
        fld     dword ptr [eax+D3DVERTEX_x]     ; z1 y1 w1 x1
        fmul    dword ptr [ecx+D3DMATRIXI__13]  ;

        fxch    st(3)                           ; x1 y1 w1 z1
        fadd    dword ptr [ecx+D3DMATRIXI__41]  ; x2 y1 w1 z1
        fxch    st(2)                           ; w1 y1 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__44]  ; w2 y1 x2 z1
        fxch    st(1)                           ; y1 w2 x2 z1
        fadd    dword ptr [ecx+D3DMATRIXI__42]  ; y2 w2 x2 z1
        fxch    st(3)                           ; z1 w2 x2 y2
        fadd    dword ptr [ecx+D3DMATRIXI__43]  ; z2 w2 x2 y2

        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_21
        fmul    dword ptr [ecx+D3DMATRIXI__21]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_24
        fmul    dword ptr [ecx+D3DMATRIXI__24]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_22
        fmul    dword ptr [ecx+D3DMATRIXI__22]  ;
        fld     dword ptr [eax+D3DVERTEX_y]     ; y*_23
        fmul    dword ptr [ecx+D3DMATRIXI__23]  ;

        fxch    st(3)       ; y*_21 y*_22 y*_24 y*_23 z2 w2 x2 y2
        faddp   st(6),st    ; y*_22 y*_24 y*_23 z2 w2 x3 y2
        fxch    st(1)       ; y*_24 y*_22 y*_23 z2 w2 x3 y2
        faddp   st(4),st    ; y*_22 y*_23 z2 w3 x3 y2
        faddp   st(5),st    ; y*_23 z2 w3 x3 y3
        faddp   st(1),st    ; z3 w3 x3 y3

        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_31
        fmul    dword ptr [ecx+D3DMATRIXI__31]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_34
        fmul    dword ptr [ecx+D3DMATRIXI__34]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_32
        fmul    dword ptr [ecx+D3DMATRIXI__32]  ;
        fld     dword ptr [eax+D3DVERTEX_z]     ; z*_33
        fmul    dword ptr [ecx+D3DMATRIXI__33]  ;

        fxch    st(3)       ; z*_31 z*_32 z*_34 z*_33 z3 w3 x3 y3
        faddp   st(6),st    ; z*_32 z*_34 z*_33 z3 w3 x4 y3
        fxch    st(1)       ; z*_34 z*_32 z*_33 z3 w3 x4 y3
        faddp   st(4),st    ; z*_32 z*_33 z3 w4 x4 y3
        faddp   st(5),st    ; z*_33 z3 w4 x4 y4
        faddp   st(1),st    ; z4 w4 x4 y4

        fldz                ; 0 z4 w4 x4 y4
        fxch    st(4)       ; y4 z4 w4 x4 0
        fxch    st(3)       ; x4 z4 w4 y4 0
        xor     eax,eax     ;
        xor     ebx,ebx     ;
        xor     ecx,ecx     ;
        xor     edx,edx     ;
        fcomi   st,st(4)    ;
        cmovb   eax,gD3DCS_LEFT
        fcomi   st,st(2)    ;
        cmovnb  ebx,gD3DCS_RIGHT
        fxch    st(3)       ; y4 z4 w4 x4 0
        or      eax,ebx
        xor     ebx,ebx
        fcomi   st,st(4)    ;
        cmovb   ecx,gD3DCS_BOTTOM
        fcomi   st,st(2)    ;
        cmovnb  edx,gD3DCS_TOP
        or      eax,ecx
        xor     ecx,ecx
        fxch    st(1)       ; z4 y4 w4 x4 0
        fcomi   st,st(4)    ;
        or      edx,edx
        cmovb   ebx,gD3DCS_FRONT
        fcomi   st,st(2)    ;
        cmovnb  ecx,gD3DCS_BACK
        or      eax,ebx
        mov     esi,hout                ; Propagate diffuse, specular, tu, tv
        or      eax,ecx
        mov     ebx,pmat                ;
        mov     word ptr [esi],ax       ; Output clip flags
        mov     esi,pin                 ;
        fxch    st(4)   ; 0 y4 w4 x4 z4
        fstp    st      ; y4 w4 x4 z4

;; Now compute the clipcodes.

;           D3DVALUE xx = we - x;
;           D3DVALUE yy = we - y;
;           D3DVALUE zz = we - z;
;           clip = ((ASINT32(x)  & 0x80000000) >> (32-1)) | // D3DCS_LEFT
;                  ((ASINT32(y)  & 0x80000000) >> (32-4)) | // D3DCS_BOTTOM
;                  ((ASINT32(z)  & 0x80000000) >> (32-5)) | // D3DCS_FRONT 
;                  ((ASINT32(xx) & 0x80000000) >> (32-2)) | // D3DCS_RIGHT
;                  ((ASINT32(yy) & 0x80000000) >> (32-3)) | // D3DCS_TOP   
;                  ((ASINT32(zz) & 0x80000000) >> (32-6));  // D3DCS_BACK

;; actually the flags have not been touched since the final OR so we don't 
;; need to test this explicitly
;;      test    eax,eax
        jnz     ClipNonzero             ; jump if clip flags nonzero

        fld1                ; 1 y w x z
        fdivrp  st(2),st    ; y w x z

        mov     ecx,[esi+D3DTLVERTEX_color]
        mov     edx,[esi+D3DTLVERTEX_specular]

        mov     [ebp+D3DTLVERTEX_color],ecx
        mov     [ebp+D3DTLVERTEX_specular],edx

        mov     ecx,[esi+D3DTLVERTEX_tu]
        mov     edx,[esi+D3DTLVERTEX_tv]

        mov     [ebp+D3DTLVERTEX_tu],ecx
        mov     [ebp+D3DTLVERTEX_tv],edx

        ; y w x z
        fabs
        fxch    st(2)
        fabs
        fxch    st(2)

        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleY]
        fxch    st(2)   ;
        fmul    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_scaleX]
        fxch    st(2)   ; y w x z
        fmul    st,st(1)
        fxch    st(2)   ; x w y z
        fmul    st,st(1) ;
        fxch    st(2)   ; y w x z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetY]
        fxch    st(2)   ; x w y z
        fadd    dword ptr [ebx+D3DFE_PROCESSVERTICES_vcache+D3DFE_VIEWPORTCACHE_offsetX]
        fxch    st(3)   ; z w y x
        fmul    st,st(1)
        fxch    st(3)   ; x w y z

        test    dword ptr [ebx+D3DFE_PROCESSVERTICES_dwFlags], D3DDP_DONOTUPDATEEXTENTS
        jnz     NoExtents

;; update extents rect in PV structure

    ; minx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]
        fcomi   st,st(1)
        fcmovnb st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+0]

    ; maxx x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]
        fcomi   st,st(1)
        fcmovb  st,st(1)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+8]

    ; miny x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]
        fcomi   st,st(3)
        fcmovnb st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+4]

    ; maxy x w y z
        fld     dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]
        fcomi   st,st(3)
        fcmovb  st,st(3)
        fstp    dword ptr [ebx+D3DFE_PROCESSVERTICES_rExtents+12]

NoExtents:
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
Return:
        pop     ebp         ; Restore registers
        pop     edi         ;
        pop     esi         ;
        pop     ebx         ;
        add     esp,24      ; Locals

        ret                 ; Return

ClipNonZero:
        fstp    dword ptr [ebp+D3DTLVERTEX_sy]
        fstp    dword ptr [ebp+D3DTLVERTEX_rhw]
        fstp    dword ptr [ebp+D3DTLVERTEX_sx]
        fstp    dword ptr [ebp+D3DTLVERTEX_sz]
        jmp     short Return

_matmul6  ENDP

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\tnl\win9x\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\cppdbg.cpp ===
//----------------------------------------------------------------------------
//
// cppdbg.cpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

#ifdef _ALPHA_
// On Alpha va_list is a structure so it's not compatible with NULL.
static va_list NULLVA;
#else
#define NULLVA NULL
#endif

static DebugModuleFlags g_FailureFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_FAILURE, BREAK),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, OUTPUT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, PROMPT),
    DBG_DECLARE_MODFLAG(DBG_FAILURE, FILENAME_ONLY),
    0, NULL,
};

static DebugModuleFlags g_OutputFlags[] =
{
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, SUPPRESS),
    DBG_DECLARE_MODFLAG(DBG_OUTPUT, ALL_MATCH),
    0, NULL,
};

static char *g_pFlagNames[] =
{
    "AssertFlags",
    "HrFlags",
    "OutputFlags",
    "OutputMask",
    "UserFlags"
};

//----------------------------------------------------------------------------
//
// DebugModule::DebugModule
//
//----------------------------------------------------------------------------

DebugModule::DebugModule(char *pModule, char *pPrefix,
                         DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                         DebugModuleFlags *pUserFlags, UINT uUserFlags)
{
    m_pModule = pModule;
    m_iModuleStartCol = strlen(m_pModule) + 2;
    m_pPrefix = pPrefix;

    m_pModFlags[DBG_ASSERT_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_HR_FLAGS] = g_FailureFlags;
    m_pModFlags[DBG_OUTPUT_FLAGS] = g_OutputFlags;
    m_pModFlags[DBG_OUTPUT_MASK] = pOutputMasks;
    m_pModFlags[DBG_USER_FLAGS] = pUserFlags;

    m_uFlags[DBG_ASSERT_FLAGS] = DBG_FAILURE_OUTPUT | DBG_FAILURE_BREAK |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_HR_FLAGS] = DBG_FAILURE_OUTPUT |
        DBG_FAILURE_FILENAME_ONLY;
    m_uFlags[DBG_OUTPUT_FLAGS] = 0;
    m_uFlags[DBG_OUTPUT_MASK] = uOutputMask;
    m_uFlags[DBG_USER_FLAGS] = uUserFlags;

    ReadReg();
}

//----------------------------------------------------------------------------
//
// DebugModule::OutVa
//
// Base debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::OutVa(UINT uMask, char *pFmt, va_list Args)
{
    if (m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_SUPPRESS)
    {
        return;
    }

    if ((uMask & DBG_MASK_NO_PREFIX) == 0)
    {
        OutputDebugStringA(m_pModule);
        OutputDebugStringA(": ");
    }

    char chMsg[1024];

    _vsnprintf(chMsg, sizeof(chMsg), pFmt, Args);
    OutputDebugStringA(chMsg);
}

//----------------------------------------------------------------------------
//
// DebugModule::Out
//
// Always-output debug output method.
//
//----------------------------------------------------------------------------

void DebugModule::Out(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    OutVa(0, pFmt, Args);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedVa
//
// Handles assertion failure output and interface.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine)
{
    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        if (OutPathFile("Assertion failed", m_uFlags[DBG_ASSERT_FLAGS]))
        {
            OutVa(DBG_MASK_NO_PREFIX, ":\n    ", NULLVA);
        }
        else
        {
            OutVa(DBG_MASK_NO_PREFIX, ": ", NULLVA);
        }

        OutVa(DBG_MASK_NO_PREFIX, pFmt, Args);
        if (bNewLine)
        {
            OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        }
    }

    if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_BREAK)
    {
        DebugBreak();
    }
    else if (m_uFlags[DBG_ASSERT_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailed
//
// Handles simple expression assertion failures.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailed(char *pExp)
{
    AssertFailedVa(pExp, NULLVA, TRUE);
}

//----------------------------------------------------------------------------
//
// DebugModule::AssertFailedMsg
//
// Handles assertion failures with arbitrary debug output.
//
//----------------------------------------------------------------------------

void DebugModule::AssertFailedMsg(char *pFmt, ...)
{
    va_list Args;

    va_start(Args, pFmt);
    AssertFailedVa(pFmt, Args, FALSE);
    va_end(Args);
}

//----------------------------------------------------------------------------
//
// DebugModule::HrFailure
//
// Handles HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrFailure(HRESULT hr, char *pPrefix)
{
    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_OUTPUT)
    {
        OutPathFile(pPrefix, m_uFlags[DBG_HR_FLAGS]);
        OutMask(DBG_MASK_FORCE_CONT, ": %s\n", HrString(hr));
    }

    if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_BREAK)
    {
        DebugBreak();
    }
    else if (m_uFlags[DBG_HR_FLAGS] & DBG_FAILURE_PROMPT)
    {
        Prompt(NULL);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::HrStmtFailed
//
// Handles statement-style HRESULT failures.
//
//----------------------------------------------------------------------------

void DebugModule::HrStmtFailed(HRESULT hr)
{
    HrFailure(hr, "HR test fail");
}

//----------------------------------------------------------------------------
//
// DebugModule::ReturnHr
//
// Handles expression-style HRESULT failures.
//
//----------------------------------------------------------------------------

HRESULT DebugModule::HrExpFailed(HRESULT hr)
{
    HrFailure(hr, "HR expr fail");
    return hr;
}

//----------------------------------------------------------------------------
//
// DebugModule::Prompt
//
// Allows control over debug options via interactive input.
//
//----------------------------------------------------------------------------

void DebugModule::Prompt(char *pFmt, ...)
{
    va_list Args;

    if (pFmt != NULL)
    {
        va_start(Args, pFmt);
        OutVa(0, pFmt, Args);
        va_end(Args);
    }

#if 0   // ndef WIN95
    // This is DEADCODE, that is can be potentially used on NT ONLY to
    // bring up a debugging prompt. It requires linking with NTDLL.LIB
    char szInput[512];
    char *pIdx;
    int iIdx;
    static char szFlagCommands[] = "ahomu";

    for (;;)
    {
        ULONG uLen;

        uLen = DbgPrompt("[bgaAFhHmMoOrRuU] ", szInput, sizeof(szInput) - 1);
        if (uLen < 2)
        {
            Out("DbgPrompt failed\n");
            DebugBreak();
            return;
        }

        // ATTENTION - Currently DbgPrompt returns a length that is two
        // greater than the actual number of characters.  Presumably this
        // is an artifact of the Unicode/ANSI conversion and should
        // really only be one greater, so attempt to handle both.

        uLen -= 2;
        if (szInput[uLen] != 0)
        {
            uLen++;
            szInput[uLen] = 0;
        }

        if (uLen < 1)
        {
            Out("Empty command ignored\n");
            continue;
        }

        switch(szInput[0])
        {
        case 'b':
            DebugBreak();
            break;
        case 'g':
            return;

        case 'r':
            WriteReg();
            break;
        case 'R':
            ReadReg();
            break;

        case 'a':
        case 'A':
        case 'h':
        case 'H':
        case 'm':
        case 'M':
        case 'o':
        case 'O':
        case 'u':
        case 'U':
            char chLower;

            if (szInput[0] >= 'A' && szInput[0] <= 'Z')
            {
                chLower = szInput[0] - 'A' + 'a';
            }
            else
            {
                chLower = szInput[0];
            }

            pIdx = strchr(szFlagCommands, chLower);
            if (pIdx == NULL)
            {
                // Should never happen.
                break;
            }

            iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
            if (szInput[0] == chLower)
            {
                // Set.
                m_uFlags[iIdx] = ParseUint(szInput + 1, m_pModFlags[iIdx]);
            }

            // Set or Get.
            OutUint(g_pFlagNames[iIdx], m_pModFlags[iIdx], m_uFlags[iIdx]);
            break;

        case 'F':
            if (uLen < 2)
            {
                Out("'F' must be followed by a flag group specifier\n");
                break;
            }

            pIdx = strchr(szFlagCommands, szInput[1]);
            if (pIdx == NULL)
            {
                Out("Unknown flag group '%c'\n", szInput[1]);
            }
            else
            {
                iIdx = (int)((ULONG_PTR)(pIdx - szFlagCommands));
                ShowFlags(g_pFlagNames[iIdx], m_pModFlags[iIdx]);
            }
            break;

        default:
            Out("Unknown command '%c'\n", szInput[0]);
            break;
        }
    }
#else
    OutUint("OutputMask", m_pModFlags[DBG_OUTPUT_MASK],
            m_uFlags[DBG_OUTPUT_MASK]);
    Out("Prompt not available\n");
    DebugBreak();
#endif
}

//----------------------------------------------------------------------------
//
// DebugModule::OpenDebugKey
//
// Opens the Direct3D\Debug\m_pModule key.
//
//----------------------------------------------------------------------------

HKEY DebugModule::OpenDebugKey(void)
{
    HKEY hKey;
    char szKeyName[128];

    strcpy(szKeyName, "Software\\Microsoft\\Direct3D\\Debug\\");
    strcat(szKeyName, m_pModule);
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_ALL_ACCESS,
                      &hKey) != ERROR_SUCCESS)
    {
        return NULL;
    }
    else
    {
        return hKey;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::GetRegUint
//
// Gets a UINT value from the given key.
//
//----------------------------------------------------------------------------

UINT DebugModule::GetRegUint(HKEY hKey, char *pValue, UINT uDefault)
{
    DWORD dwType, dwSize;
    DWORD dwVal;

    dwSize = sizeof(dwVal);
    if (RegQueryValueExA(hKey, pValue, NULL, &dwType, (BYTE *)&dwVal,
                         &dwSize) != ERROR_SUCCESS ||
        dwType != REG_DWORD)
    {
        return uDefault;
    }
    else
    {
        return (UINT)dwVal;
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::SetRegUint
//
// Sets a UINT value for the given key.
//
//----------------------------------------------------------------------------

BOOL DebugModule::SetRegUint(HKEY hKey, char *pValue, UINT uValue)
{
    return RegSetValueExA(hKey, pValue, NULL, REG_DWORD, (BYTE *)&uValue,
                          sizeof(uValue)) == ERROR_SUCCESS;
}

//----------------------------------------------------------------------------
//
// DebugModule::ReadReg
//
// Reads settings from the registry.
//
//----------------------------------------------------------------------------

void DebugModule::ReadReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            m_uFlags[iIdx] = GetRegUint(hKey, g_pFlagNames[iIdx],
                                        m_uFlags[iIdx]);
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::WriteReg
//
// Writes values to the registry.
//
//----------------------------------------------------------------------------

void DebugModule::WriteReg(void)
{
    HKEY hKey;

    hKey = OpenDebugKey();
    if (hKey != NULL)
    {
        int iIdx;

        for (iIdx = 0; iIdx < DBG_FLAGS_COUNT; iIdx++)
        {
            if (!SetRegUint(hKey, g_pFlagNames[iIdx], m_uFlags[iIdx]))
            {
                OutputDebugStringA("Error writing registry information\n");
            }
        }
        RegCloseKey(hKey);
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ParseUint
//
// Parses a string for a numeric value or a set of flag strings.
//
//----------------------------------------------------------------------------

UINT DebugModule::ParseUint(char *pString, DebugModuleFlags *pFlags)
{
    UINT uVal;

    uVal = 0;

    for (;;)
    {
        while (*pString != 0 &&
               (*pString == ' ' || *pString == '\t'))
        {
            pString++;
        }

        if (*pString == 0)
        {
            break;
        }

        char *pEnd;
        int iStepAfter;

        pEnd = pString;
        while (*pEnd != 0 && *pEnd != ' ' && *pEnd != '\t')
        {
            pEnd++;
        }
        iStepAfter = *pEnd != 0 ? 1 : 0;
        *pEnd = 0;

        if (*pString >= '0' && *pString <= '9')
        {
            uVal |= strtoul(pString, &pString, 0);
            if (*pString != 0 && *pString != ' ' && *pString != '\t')
            {
                Out("Unrecognized characters '%s' after number\n", pString);
            }
        }
        else if (pFlags != NULL)
        {
            DebugModuleFlags *pFlag;

            for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
            {
                if (!_stricmp(pString, pFlag->pName))
                {
                    break;
                }
            }

            if (pFlag->uFlag == 0)
            {
                Out("Unrecognized flag string '%s'\n", pString);
            }
            else
            {
                uVal |= pFlag->uFlag;
            }
        }
        else
        {
            Out("No flag definitions, unable to convert '%s'\n", pString);
        }

        pString = pEnd + iStepAfter;
    }

    return uVal;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutUint
//
// Displays a UINT as a set of flag strings.
//
//----------------------------------------------------------------------------

void DebugModule::OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue)
{
    if (pFlags == NULL || uValue == 0)
    {
        Out("%s: 0x%08X\n", pName, uValue);
        return;
    }

    Out("%s:", pName);
    m_iStartCol = m_iModuleStartCol + strlen(pName) + 1;
    m_iCol = m_iStartCol;

    while (uValue != 0)
    {
        DebugModuleFlags *pFlag;

        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            if ((pFlag->uFlag & uValue) == pFlag->uFlag)
            {
                AdvanceCols(strlen(pFlag->pName) + 1);
                OutMask(DBG_MASK_FORCE_CONT, " %s", pFlag->pName);
                uValue &= ~pFlag->uFlag;
                break;
            }
        }

        if (pFlag->uFlag == 0)
        {
            AdvanceCols(11);
            OutMask(DBG_MASK_FORCE_CONT, " 0x%X", uValue);
            uValue = 0;
        }
    }

    OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
}

//----------------------------------------------------------------------------
//
// DebugModule::AdvanceCols
//
// Determines if there's enough space on the current line for
// the given number of columns.  If not, a new line is started.
//
//----------------------------------------------------------------------------

void DebugModule::AdvanceCols(int iCols)
{
    static char szSpaces[] = "                                ";

    m_iCol += iCols;
    if (m_iCol >= 79)
    {
        int iSpace;

        OutVa(DBG_MASK_NO_PREFIX, "\n", NULLVA);
        // Force a prefix to be printed to start the line.
        Out("");

        m_iCol = m_iModuleStartCol;
        while (m_iCol < m_iStartCol)
        {
            iSpace = (int)min(sizeof(szSpaces) - 1, m_iStartCol - m_iCol);
            OutMask(DBG_MASK_FORCE_CONT, "%.*s", iSpace, szSpaces);
            m_iCol += iSpace;
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::ShowFlags
//
// Shows the given flag set.
//
//----------------------------------------------------------------------------

void DebugModule::ShowFlags(char *pName, DebugModuleFlags *pFlags)
{
    DebugModuleFlags *pFlag;

    Out("%s:\n", pName);
    if (pFlags == NULL)
    {
        Out("    None defined\n");
    }
    else
    {
        for (pFlag = pFlags; pFlag->uFlag != 0; pFlag++)
        {
            Out("    0x%08X - %s\n", pFlag->uFlag, pFlag->pName);
        }
    }
}

//----------------------------------------------------------------------------
//
// DebugModule::PathFile
//
// Returns the trailing filename component or NULL if the path is
// only a filename.
//
//----------------------------------------------------------------------------

char *DebugModule::PathFile(char *pPath)
{
    char *pFile, *pSlash, *pBack, *pColon;

    pBack = strrchr(pPath, '\\');
    pSlash = strrchr(pPath, '/');
    pColon = strrchr(pPath, ':');

    pFile = pBack;
    if (pSlash > pFile)
    {
        pFile = pSlash;
    }
    if (pColon > pFile)
    {
        pFile = pColon;
    }

    return pFile != NULL ? pFile + 1 : NULL;
}

//----------------------------------------------------------------------------
//
// DebugModule::OutPathFile
//
// Outputs the given string plus a path and filename.
// Returns whether the full path was output or not.
//
//----------------------------------------------------------------------------

BOOL DebugModule::OutPathFile(char *pPrefix, UINT uFailureFlags)
{
    char *pFile;

    if (uFailureFlags & DBG_FAILURE_FILENAME_ONLY)
    {
        pFile = PathFile(m_pFile);
    }
    else
    {
        pFile = NULL;
    }

    if (pFile == NULL)
    {
        Out("%s %s(%d)", pPrefix, m_pFile, m_iLine);
        return TRUE;
    }
    else
    {
        Out("%s <>\\%s(%d)", pPrefix, pFile, m_iLine);
        return FALSE;
    }
}

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_ONCE(Global, G, NULL, 0, NULL, 0);

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\d3dexcept.hpp ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dexcept.h
 *  Content:    Exception support
 *
 ***************************************************************************/
#ifndef __D3DEXCEPT_H__
#define __D3DEXCEPT_H__

#include <string.h>

#if DBG
#define D3D_THROW( hResult, string )                                        \
    {                                                                       \
        char s[_MAX_PATH];                                                  \
        _snprintf(s, _MAX_PATH, "*** Exception in %s Line: %d", __FILE__,   \
                  __LINE__);                                                \
        D3D_ERR(s);                                                         \
        if (strcmp(string,"") != 0)                                         \
        {                                                                   \
            D3D_ERR(string);                                                \
        }                                                                   \
        throw hResult;                                                      \
    }
#define D3D_THROW_LINE( hResult, string, line, file)                        \
    {                                                                       \
        char s[_MAX_PATH];                                                  \
        _snprintf(s, _MAX_PATH, "*** Exception in %s Line: %d", file,       \
                  line);                                                    \
        D3D_ERR(s);                                                         \
        D3D_ERR(string);                                                    \
        throw hResult;                                                      \
    }
#else
#define D3D_THROW( hResult, string )                                        \
    {                                                                       \
        throw hResult;                                                      \
    }
#define D3D_THROW_LINE( hResult, string, line, file)                        \
    {                                                                       \
        throw hResult;                                                      \
    }
#endif

#define D3D_THROW_FAIL(string) D3D_THROW(D3DERR_INVALIDCALL, string)
#define D3D_CATCH   catch( HRESULT e ) { return e; }
#define D3D_TRY     try

class CD3DException
{
public:
    CD3DException(HRESULT res, char *msg, int LineNumber, char* file) 
    {
        error = res; 
        strcpy(message, msg); 
        strcpy(this->file, file); 
        line = LineNumber;
    }
    char message[128];
    char file[_MAX_PATH];
    HRESULT error;
    int line;
    
    void DebugString();
    void Popup();
};

#endif // __D3DEXCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\cppdbg.hpp ===
//----------------------------------------------------------------------------
//
// cppdbg.hpp
//
// C++-only debugging support.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _CPPDBG_HPP_
#define _CPPDBG_HPP_

#if DBG

#include <stdarg.h>

typedef unsigned int UINT;
        
//
// Mask bits common to all modules.
//

#define DBG_MASK_NO_PREFIX              0x80000000
#define DBG_MASK_FORCE                  0x40000000

// Mask bits checked against output mask.
#define DBG_MASK_CHECK                  (~(DBG_MASK_NO_PREFIX | \
                                           DBG_MASK_FORCE))

// Forced continuation mask.
#define DBG_MASK_FORCE_CONT             (DBG_MASK_NO_PREFIX | DBG_MASK_FORCE)

//
// Failure control bits for assert and HRESULT failures.
//

#define DBG_FAILURE_BREAK               0x00000001
#define DBG_FAILURE_OUTPUT              0x00000002
#define DBG_FAILURE_PROMPT              0x00000004
#define DBG_FAILURE_FILENAME_ONLY       0x00000008

//
// Overall output control bits.
//

#define DBG_OUTPUT_SUPPRESS             0x00000001
#define DBG_OUTPUT_ALL_MATCH            0x00000002

//----------------------------------------------------------------------------
//
// DebugModule
//
//----------------------------------------------------------------------------

struct DebugModuleFlags
{
    UINT uFlag;
    char *pName;
};

// Declares a DebugModuleFlags entry.
#define DBG_DECLARE_MODFLAG(Group, Name) \
    Group ## _ ## Name, #Name

enum
{
    DBG_ASSERT_FLAGS,
    DBG_HR_FLAGS,
    DBG_OUTPUT_FLAGS,
    DBG_OUTPUT_MASK,
    DBG_USER_FLAGS,
    DBG_FLAGS_COUNT
};

class DebugModule
{
public:
    DebugModule(char *pModule, char *pPrefix,
                DebugModuleFlags *pOutputMasks, UINT uOutputMask,
                DebugModuleFlags *pUserFlags, UINT uUserFlags);

    void Out(char *pFmt, ...);

    void OutMask(UINT uMask, char *pFmt, ...)
    {
        if ((uMask & DBG_MASK_FORCE) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) == uMask) ||
            ((m_uFlags[DBG_OUTPUT_FLAGS] & DBG_OUTPUT_ALL_MATCH) == 0 &&
             (uMask & m_uFlags[DBG_OUTPUT_MASK] & DBG_MASK_CHECK) != 0))
        {
            va_list Args;

            va_start(Args, pFmt);
            OutVa(uMask, pFmt, Args);
            va_end(Args);
        }
    }
    
    void AssertFailed(char *pExp);
    void AssertFailedMsg(char *pFmt, ...);

    void HrStmtFailed(HRESULT hr);
    HRESULT HrExpFailed(HRESULT hr);
    
    void SetFileLine(char *pFile, int iLine)
    {
        m_pFile = pFile;
        m_iLine = iLine;
    }

    void Prompt(char *pFmt, ...);

    UINT GetFlags(int iIdx)
    {
        return m_uFlags[iIdx];
    }
    void SetFlags(int iIdx, UINT uValue)
    {
        m_uFlags[iIdx] = uValue;
    }

private:
    void OutVa(UINT uMask, char *pFmt, va_list Args);
    void AssertFailedVa(char *pFmt, va_list Args, BOOL bNewLine);

    HKEY OpenDebugKey(void);
    UINT GetRegUint(HKEY hKey, char *pValue, UINT uDefault);
    BOOL SetRegUint(HKEY hKey, char *pValue, UINT uValue);
    void ReadReg(void);
    void WriteReg(void);

    UINT ParseUint(char *pString, DebugModuleFlags *pFlags);
    void OutUint(char *pName, DebugModuleFlags *pFlags, UINT uValue);

    void AdvanceCols(int iCols);

    void ShowFlags(char *pName, DebugModuleFlags *pFlags);

    char *PathFile(char *pPath);
    BOOL OutPathFile(char *pPrefix, UINT uFailureFlags);

    void HrFailure(HRESULT hr, char *pPrefix);
    char *HrString(HRESULT hr);
    
    // Module information given.
    char *m_pModule;
    char *m_pPrefix;
    
    // Flag descriptions and values.
    DebugModuleFlags *m_pModFlags[DBG_FLAGS_COUNT];
    UINT m_uFlags[DBG_FLAGS_COUNT];

    // Temporary file and line number storage.
    char *m_pFile;
    int m_iLine;

    // Output column during multiline display.
    int m_iModuleStartCol;
    int m_iCol;
    int m_iStartCol;
};

//----------------------------------------------------------------------------
//
// Support macros.
//
//----------------------------------------------------------------------------

#define DBG_MODULE(Prefix) Prefix ## _Debug

// Put this in one source file.
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags) \
    DebugModule DBG_MODULE(Prefix)(#Module, #Prefix, \
                                   pOutputMasks, uOutputMask, \
                                   pUserFlags, uUserFlags)

// Put this in your derived debugging header.
#define DBG_DECLARE_HEADER(Prefix) \
    extern DebugModule DBG_MODULE(Prefix)

// Put this in every file.
#define DBG_DECLARE_FILE() \
    static char *g_pStaticDebugFile = __FILE__

#define DBG_DECLARE_DPF(Prefix, Args) \
    DBG_MODULE(Prefix).Out Args
#define DBG_DECLARE_DPFM(Prefix, Args) \
    DBG_MODULE(Prefix).OutMask Args

#define DBG_DECLARE_ASSERT(Prefix, Exp) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailed(#Exp); } \
    else 0
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args) \
    if (!(Exp)) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).AssertFailedMsg Args ; } \
    else 0
#define DBG_DECLARE_VERIFY(Prefix, Exp) \
    DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args)\
    DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)

#define DBG_DECLARE_PROMPT(Prefix, Args) \
    DBG_MODULE(Prefix).Prompt Args

#define DBG_DECLARE_GETFLAGS(Prefix, Idx) \
    DBG_MODULE(Prefix).GetFlags(Idx)
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value) \
    DBG_MODULE(Prefix).SetFlags(Idx, Value)

//
// These macros assume a variable 'hr' exists.
//

// HRESULT test in expression form.
#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    ((hr = (Exp)) != S_OK ? \
      (DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__), \
       DBG_MODULE(Prefix).HrExpFailed(hr)) : hr)

// HRESULT test in if/then form.
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) \
    { DBG_MODULE(Prefix).SetFileLine(g_pStaticDebugFile, __LINE__); \
      DBG_MODULE(Prefix).HrStmtFailed(hr); \
      DoFail; } \
    else hr

#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#else // #if DBG

//
// Empty macros for free builds.
//

#define DBG_MODULE(Prefix) 0
#define DBG_DECLARE_ONCE(Module, Prefix, pOutputMasks, uOutputMask, \
                         pUserFlags, uUserFlags)
#define DBG_DECLARE_HEADER(Prefix)
#define DBG_DECLARE_FILE()

#define DBG_DECLARE_DPF(Prefix, Args)
#define DBG_DECLARE_DPFM(Prefix, Args)
#define DBG_DECLARE_ASSERT(Prefix, Exp)
#define DBG_DECLARE_ASSERTMSG(Prefix, Exp, Args)
#define DBG_DECLARE_PROMPT(Prefix, Args)
#define DBG_DECLARE_GETFLAGS(Prefix, Idx) 0
#define DBG_DECLARE_SETFLAGS(Prefix, Idx, Value)

//
// Macros which evaluate to code on free builds.
//

#define DBG_DECLARE_VERIFY(Prefix, Exp) (Exp)
#define DBG_DECLARE_VERIFYMSG(Prefix, Exp, Args) (Exp)

#define DBG_DECLARE_HRCHK(Prefix, Exp) \
    (hr = (Exp))
#define DBGI_DECLARE_HRIF(Prefix, Exp, DoFail) \
    if ((hr = (Exp)) != S_OK) DoFail; else hr
#define DBG_DECLARE_HRGO(Prefix, Exp, Label) \
    DBGI_DECLARE_HRIF(Prefix, Exp, goto Label)
#define DBG_DECLARE_HRERR(Prefix, Exp) \
    DBG_DECLARE_HRGO(Prefix, Exp, HR_Err)
#define DBG_DECLARE_HRRET(Prefix, Exp) \
    DBGI_DECLARE_HRIF(Prefix, Exp, return hr)

#endif // #if DBG

//----------------------------------------------------------------------------
//
// Global debug module.
//
//----------------------------------------------------------------------------

DBG_DECLARE_HEADER(G);

#define GDPF(Args)              DBG_DECLARE_DPF(G, Args)
#define GDPFM(Args)             DBG_DECLARE_DPFM(G, Args)
#define GASSERT(Exp)            DBG_DECLARE_ASSERT(G, Exp)
#define GASSERTMSG(Exp, Args)   DBG_DECLARE_ASSERTMSG(G, Exp, Args)
#define GVERIFY(Exp)            DBG_DECLARE_VERIFY(G, Exp)
#define GVERIFYMSG(Exp)         DBG_DECLARE_VERIFYMSG(G, Exp, Args)
#define GPROMPT(Args)           DBG_DECLARE_PROMPT(G, Args)
#define GGETFLAGS(Idx)          DBG_DECLARE_GETFLAGS(G, Idx)
#define GSETFLAGS(Idx, Value)   DBG_DECLARE_SETFLAGS(G, Idx, Value)
#define GHRCHK(Exp)             DBG_DECLARE_HRCHK(G, Exp)
#define GHRGO(Exp, Label)       DBG_DECLARE_HRGO(G, Exp, Label)
#define GHRERR(Exp)             DBG_DECLARE_HRERR(G, Exp)
#define GHRRET(Exp)             DBG_DECLARE_HRRET(G, Exp)

#endif // #ifndef _CPPDBG_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IFDEF ICAP_PROLOGUE

?WP_REGSAVE = 1
INCLUDE icprof.inc

PROF_ENTRY MACRO
        ENDM
        
ELSE
        
IFDEF PROFILE
EXTRN __penter:NEAR

PROF_ENTRY MACRO
        pushad
        call __penter
        popad
        ENDM
ELSE
PROF_ENTRY MACRO
        ENDM
ENDIF

ENDIF
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\d3dutil.cpp ===
//----------------------------------------------------------------------------
//
// d3dutil.cpp
//
// Miscellanous utility functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include <span.h>
#include "cppdbg.hpp"

DBG_DECLARE_FILE();

// Declare TextureDiff as an out-of-line function.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

//----------------------------------------------------------------------------
//
// DebugBreakFn
//
// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
//
//----------------------------------------------------------------------------

void FASTCALL
DebugBreakFn(void)
{
    GDPF(("!! DebugBreakFn called.  Leaving this function may destroy\n"));
    GDPF(("   the stack frame. !!\n"));
    DebugBreak();
}

//----------------------------------------------------------------------------
//
// OctagonNorm
//
// Returns a good approximation to sqrt(fX*fX + fY*fY)
//
//----------------------------------------------------------------------------

FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY)
{
    fX = ABSF(fX);
    fY = ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

//----------------------------------------------------------------------------
//
// ComputeLOD
//
// Computes mipmap level for the given W by deriving U and V and
// then computing LOD from the dU and dV gradients.
//
//----------------------------------------------------------------------------

INT FASTCALL
ComputeLOD(PCD3DI_RASTCTX pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY)
{
    // Compute coverage gradients.
    FLOAT fDUDX = ABSF(fW * (fDUoWDX - fU * fDOoWDX));
    FLOAT fDUDY = ABSF(fW * (fDUoWDY - fU * fDOoWDY));
    FLOAT fDVDX = ABSF(fW * (fDVoWDX - fV * fDOoWDX));
    FLOAT fDVDY = ABSF(fW * (fDVoWDY - fV * fDOoWDY));

    // Scale gradients to texture LOD 0 size.
    fDUDX *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDUDY *= (FLOAT)pCtx->pTexture[0]->iSizeU;
    fDVDX *= (FLOAT)pCtx->pTexture[0]->iSizeV;
    fDVDY *= (FLOAT)pCtx->pTexture[0]->iSizeV;

    // Determine pixel coverage value to use.
    FLOAT fCoverage;

// too fuzzy
#ifdef COVERAGE_MAXGRAD
    fCoverage = max(fDUDX, fDUDY);
    fCoverage = max(fCoverage, fDVDX);
    fCoverage = max(fCoverage, fDVDY);
#endif
// too sharp, in particular, for aligned cases, fCoverage is always 0
// which leads to iLOD of LOD_MIN regardless of orientation
#ifdef COVERAGE_MINGRAD
    fCoverage = min(fDUDX, fDUDY);
    fCoverage = min(fCoverage, fDVDX);
    fCoverage = min(fCoverage, fDVDY);
#endif
#ifdef COVERAGE_AVERAGE
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and arithmetically average those to
    // get the coverage.
    fCoverage = (OctagonNorm(fDUDX, fDVDX) + OctagonNorm(fDUDY, fDVDY))/2.0f;
#endif
#define MAX_LEN 1
#ifdef MAX_LEN
    // use OctagonNorm to approximate each length of parallelogram
    // approximating texture coverage, and take the max of each length
    // like classic OpenGL and the current RefRast implementation
    fCoverage = max(OctagonNorm(fDUDX, fDVDX), OctagonNorm(fDUDY, fDVDY));
#endif


    // Compute approximate log2 of coverage.
    FLOAT fLOD = APPXLG2F(fCoverage);

    // Apply LOD bias.
    fLOD += pCtx->pTexture[0]->fLODBias;

    INT iLOD = FTOI(fLOD * LOD_SCALE);

    // Clamp to available levels.  Not clamped to zero so that the span
    // code can check for magnification cases with a sign check.
    iLOD = min(iLOD, pCtx->pTexture[0]->iMaxScaledLOD);
    return max(LOD_MIN, iLOD);
}

//----------------------------------------------------------------------------
//
// ComputeTableFog
//
// Computes table fog values based on render state and the given Z.
// ATTENTION - Brute force for non-linear modes.  Should be optimized
// to use a table-based approximation.
//
//----------------------------------------------------------------------------

UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState,
                FLOAT fZ)
{
    double dPow;

    switch(pdwRenderState[D3DRENDERSTATE_FOGTABLEMODE])
    {
    case D3DFOG_LINEAR:
        {
            FLOAT fFogStart = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGSTART]);
            FLOAT fFogEnd = ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGEND]);
            if (fZ >= fFogEnd)
            {
                return 0;
            }
            if (fZ <= fFogStart)
            {
                return FTOI(FOG_ONE_SCALE-1.0F);
            }
            return FTOI(((fFogEnd - fZ) / (fFogEnd - fFogStart)) * (FOG_ONE_SCALE-1.0F));
        }

    case D3DFOG_EXP:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        dPow = exp(-dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));

    case D3DFOG_EXP2:
        dPow = (double)
            (ASFLOAT(pdwRenderState[D3DRENDERSTATE_FOGDENSITY]) * fZ);
        dPow = exp(-dPow * dPow);
        return FTOI((FLOAT)dPow * (FOG_ONE_SCALE-1.0F));
    }

    GASSERTMSG(FALSE, ("ComputeTableFog unreachable\n"));
    return 0;
}

//----------------------------------------------------------------------------
//
// pVecNormalize2
//
// Normalizes the given D3DVECTOR.  Supports in-place operation.
//
//----------------------------------------------------------------------------

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes)
{
    FLOAT fLen;

    fLen = pVecLenSq(pVec);
    if (FLOAT_CMP_POS(fLen, <=, g_fNearZero))
    {
        pVecSet(pRes, 0.0f, 0.0f, 0.0f);
        return;
    }
    fLen = ISQRTF(fLen);
    pVecScale(pVec, fLen, pRes);
}

//-----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//-----------------------------------------------------------------------------
UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3, D3DVECTORH *plane)
{
    D3DVECTOR a;
    D3DVECTOR b;

    pVecSub(v2, v1, &a);
    pVecSub(v3, v1, &b);

    plane->x = a.y*b.z - a.z*b.y;
    plane->y = a.z*b.x - a.x*b.z;
    plane->z = a.x*b.y - a.y*b.x;
    plane->w = - pVecDot(v1, plane);

    double tmp = pVecDot(plane, plane);
    if (tmp <= 0)
        return -1;
    tmp = 1.0/sqrt(tmp);

    plane->x = (D3DVALUE)(plane->x * tmp);
    plane->y = (D3DVALUE)(plane->y * tmp);
    plane->z = (D3DVALUE)(plane->z * tmp);
    plane->w = (D3DVALUE)(plane->w * tmp);
    return 0;
}
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}
//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *result = res;
}
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}
//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride)
{
    if (NULL == pdwStride)
    {
        return DDERR_INVALIDPARAMS;
    }
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    DWORD dwStride;
    if (dwFVF != D3DFVF_TLVERTEX)
    {   // New (non TL)FVF vertex
        // XYZ
        dwStride = sizeof(D3DVALUE) * 3;

        if (dwFVF & D3DFVF_XYZRHW)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_PSIZE)
        {
            dwStride += sizeof(D3DVALUE);
        }
        if (dwFVF & D3DFVF_DIFFUSE)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        if (dwFVF & D3DFVF_SPECULAR)
        {
            dwStride += sizeof(D3DCOLOR);
        }
        INT iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
        for (INT i = 0; i < iTexCount; i++)
        {
            switch (D3DFVF_GETTEXCOORDSIZE(dwFVF, i))
            {
            case D3DFVF_TEXTUREFORMAT2: dwStride += sizeof(D3DVALUE) * 2; break;
            case D3DFVF_TEXTUREFORMAT1: dwStride += sizeof(D3DVALUE) * 1; break;
            case D3DFVF_TEXTUREFORMAT3: dwStride += sizeof(D3DVALUE) * 3; break;
            case D3DFVF_TEXTUREFORMAT4: dwStride += sizeof(D3DVALUE) * 4; break;
            }
        }
    }
    else
    {   // (Legacy) TL vertex
        dwStride = sizeof(D3DTLVERTEX);
    }

    *pdwStride = dwStride;
    return D3D_OK;
}

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\d3dflt.cpp ===
//----------------------------------------------------------------------------
//
// d3dflt.cpp
//
// Supporting data and routines for general FP header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#ifdef _X86_

FLOAT g_fE =                    FLOAT_E;
FLOAT g_fZero =                 0.0f;
FLOAT g_fNearZero =             FLOAT_NEARZERO;
FLOAT g_fHalf =                 0.5f;
FLOAT g_fp95 =                  0.95f;
FLOAT g_fOne =                  1.0f;
FLOAT g_fOneMinusEps =          1.0f - FLT_EPSILON;
FLOAT g_fExpScale =             FLOAT_EXPSCALE;
FLOAT g_fOoExpScale =           (FLOAT)(1.0 / (double)FLOAT_EXPSCALE);
FLOAT g_f255oTwoPow15 =         (FLOAT)(255.0 / (double)CONST_TWOPOW15);
FLOAT g_fOo255 =                (FLOAT)(1.0 / 255.0);
FLOAT g_fOo256 =                (FLOAT)(1.0 / 256.0);
FLOAT g_fTwoPow7 =              FLOAT_TWOPOW7;
FLOAT g_fTwoPow8 =              FLOAT_TWOPOW8;
FLOAT g_fTwoPow11 =             FLOAT_TWOPOW11;
FLOAT g_fTwoPow15 =             FLOAT_TWOPOW15;
FLOAT g_fOoTwoPow15 =           (FLOAT)(1.0 / (double)CONST_TWOPOW15);
FLOAT g_fTwoPow16 =             FLOAT_TWOPOW16;
FLOAT g_fOoTwoPow16 =           (FLOAT)(1.0 / (double)CONST_TWOPOW16);
FLOAT g_fTwoPow20 =             FLOAT_TWOPOW20;
FLOAT g_fOoTwoPow20 =           (FLOAT)(1.0 / (double)CONST_TWOPOW20);
FLOAT g_fTwoPow27 =             FLOAT_TWOPOW27;
FLOAT g_fOoTwoPow27 =           (FLOAT)(1.0 / (double)CONST_TWOPOW27);
FLOAT g_fTwoPow30 =             FLOAT_TWOPOW30;
FLOAT g_fTwoPow31 =             FLOAT_TWOPOW31;
FLOAT g_fNearTwoPow31 =         FLOAT_NEARTWOPOW31;
FLOAT g_fOoTwoPow31 =           (FLOAT)(1.0 / (double)CONST_TWOPOW31);
FLOAT g_fOoNearTwoPow31 =       (FLOAT)(1.0 / (double)FLOAT_NEARTWOPOW31);
FLOAT g_fTwoPow32 =             FLOAT_TWOPOW32;
FLOAT g_fNearTwoPow32 =         FLOAT_NEARTWOPOW32;
FLOAT g_fTwoPow39 =             FLOAT_TWOPOW39;
FLOAT g_fTwoPow47 =             FLOAT_TWOPOW47;

#endif // _X86_

FLOAT g_fUInt8ToFloat[257] =
{
    0.0f,
    (FLOAT)(1.0 / 255.0),
    (FLOAT)(2.0 / 255.0),
    (FLOAT)(3.0 / 255.0),
    (FLOAT)(4.0 / 255.0),
    (FLOAT)(5.0 / 255.0),
    (FLOAT)(6.0 / 255.0),
    (FLOAT)(7.0 / 255.0),
    (FLOAT)(8.0 / 255.0),
    (FLOAT)(9.0 / 255.0),
    (FLOAT)(10.0 / 255.0),
    (FLOAT)(11.0 / 255.0),
    (FLOAT)(12.0 / 255.0),
    (FLOAT)(13.0 / 255.0),
    (FLOAT)(14.0 / 255.0),
    (FLOAT)(15.0 / 255.0),
    (FLOAT)(16.0 / 255.0),
    (FLOAT)(17.0 / 255.0),
    (FLOAT)(18.0 / 255.0),
    (FLOAT)(19.0 / 255.0),
    (FLOAT)(20.0 / 255.0),
    (FLOAT)(21.0 / 255.0),
    (FLOAT)(22.0 / 255.0),
    (FLOAT)(23.0 / 255.0),
    (FLOAT)(24.0 / 255.0),
    (FLOAT)(25.0 / 255.0),
    (FLOAT)(26.0 / 255.0),
    (FLOAT)(27.0 / 255.0),
    (FLOAT)(28.0 / 255.0),
    (FLOAT)(29.0 / 255.0),
    (FLOAT)(30.0 / 255.0),
    (FLOAT)(31.0 / 255.0),
    (FLOAT)(32.0 / 255.0),
    (FLOAT)(33.0 / 255.0),
    (FLOAT)(34.0 / 255.0),
    (FLOAT)(35.0 / 255.0),
    (FLOAT)(36.0 / 255.0),
    (FLOAT)(37.0 / 255.0),
    (FLOAT)(38.0 / 255.0),
    (FLOAT)(39.0 / 255.0),
    (FLOAT)(40.0 / 255.0),
    (FLOAT)(41.0 / 255.0),
    (FLOAT)(42.0 / 255.0),
    (FLOAT)(43.0 / 255.0),
    (FLOAT)(44.0 / 255.0),
    (FLOAT)(45.0 / 255.0),
    (FLOAT)(46.0 / 255.0),
    (FLOAT)(47.0 / 255.0),
    (FLOAT)(48.0 / 255.0),
    (FLOAT)(49.0 / 255.0),
    (FLOAT)(50.0 / 255.0),
    (FLOAT)(51.0 / 255.0),
    (FLOAT)(52.0 / 255.0),
    (FLOAT)(53.0 / 255.0),
    (FLOAT)(54.0 / 255.0),
    (FLOAT)(55.0 / 255.0),
    (FLOAT)(56.0 / 255.0),
    (FLOAT)(57.0 / 255.0),
    (FLOAT)(58.0 / 255.0),
    (FLOAT)(59.0 / 255.0),
    (FLOAT)(60.0 / 255.0),
    (FLOAT)(61.0 / 255.0),
    (FLOAT)(62.0 / 255.0),
    (FLOAT)(63.0 / 255.0),
    (FLOAT)(64.0 / 255.0),
    (FLOAT)(65.0 / 255.0),
    (FLOAT)(66.0 / 255.0),
    (FLOAT)(67.0 / 255.0),
    (FLOAT)(68.0 / 255.0),
    (FLOAT)(69.0 / 255.0),
    (FLOAT)(70.0 / 255.0),
    (FLOAT)(71.0 / 255.0),
    (FLOAT)(72.0 / 255.0),
    (FLOAT)(73.0 / 255.0),
    (FLOAT)(74.0 / 255.0),
    (FLOAT)(75.0 / 255.0),
    (FLOAT)(76.0 / 255.0),
    (FLOAT)(77.0 / 255.0),
    (FLOAT)(78.0 / 255.0),
    (FLOAT)(79.0 / 255.0),
    (FLOAT)(80.0 / 255.0),
    (FLOAT)(81.0 / 255.0),
    (FLOAT)(82.0 / 255.0),
    (FLOAT)(83.0 / 255.0),
    (FLOAT)(84.0 / 255.0),
    (FLOAT)(85.0 / 255.0),
    (FLOAT)(86.0 / 255.0),
    (FLOAT)(87.0 / 255.0),
    (FLOAT)(88.0 / 255.0),
    (FLOAT)(89.0 / 255.0),
    (FLOAT)(90.0 / 255.0),
    (FLOAT)(91.0 / 255.0),
    (FLOAT)(92.0 / 255.0),
    (FLOAT)(93.0 / 255.0),
    (FLOAT)(94.0 / 255.0),
    (FLOAT)(95.0 / 255.0),
    (FLOAT)(96.0 / 255.0),
    (FLOAT)(97.0 / 255.0),
    (FLOAT)(98.0 / 255.0),
    (FLOAT)(99.0 / 255.0),
    (FLOAT)(100.0 / 255.0),
    (FLOAT)(101.0 / 255.0),
    (FLOAT)(102.0 / 255.0),
    (FLOAT)(103.0 / 255.0),
    (FLOAT)(104.0 / 255.0),
    (FLOAT)(105.0 / 255.0),
    (FLOAT)(106.0 / 255.0),
    (FLOAT)(107.0 / 255.0),
    (FLOAT)(108.0 / 255.0),
    (FLOAT)(109.0 / 255.0),
    (FLOAT)(110.0 / 255.0),
    (FLOAT)(111.0 / 255.0),
    (FLOAT)(112.0 / 255.0),
    (FLOAT)(113.0 / 255.0),
    (FLOAT)(114.0 / 255.0),
    (FLOAT)(115.0 / 255.0),
    (FLOAT)(116.0 / 255.0),
    (FLOAT)(117.0 / 255.0),
    (FLOAT)(118.0 / 255.0),
    (FLOAT)(119.0 / 255.0),
    (FLOAT)(120.0 / 255.0),
    (FLOAT)(121.0 / 255.0),
    (FLOAT)(122.0 / 255.0),
    (FLOAT)(123.0 / 255.0),
    (FLOAT)(124.0 / 255.0),
    (FLOAT)(125.0 / 255.0),
    (FLOAT)(126.0 / 255.0),
    (FLOAT)(127.0 / 255.0),
    (FLOAT)(128.0 / 255.0),
    (FLOAT)(129.0 / 255.0),
    (FLOAT)(130.0 / 255.0),
    (FLOAT)(131.0 / 255.0),
    (FLOAT)(132.0 / 255.0),
    (FLOAT)(133.0 / 255.0),
    (FLOAT)(134.0 / 255.0),
    (FLOAT)(135.0 / 255.0),
    (FLOAT)(136.0 / 255.0),
    (FLOAT)(137.0 / 255.0),
    (FLOAT)(138.0 / 255.0),
    (FLOAT)(139.0 / 255.0),
    (FLOAT)(140.0 / 255.0),
    (FLOAT)(141.0 / 255.0),
    (FLOAT)(142.0 / 255.0),
    (FLOAT)(143.0 / 255.0),
    (FLOAT)(144.0 / 255.0),
    (FLOAT)(145.0 / 255.0),
    (FLOAT)(146.0 / 255.0),
    (FLOAT)(147.0 / 255.0),
    (FLOAT)(148.0 / 255.0),
    (FLOAT)(149.0 / 255.0),
    (FLOAT)(150.0 / 255.0),
    (FLOAT)(151.0 / 255.0),
    (FLOAT)(152.0 / 255.0),
    (FLOAT)(153.0 / 255.0),
    (FLOAT)(154.0 / 255.0),
    (FLOAT)(155.0 / 255.0),
    (FLOAT)(156.0 / 255.0),
    (FLOAT)(157.0 / 255.0),
    (FLOAT)(158.0 / 255.0),
    (FLOAT)(159.0 / 255.0),
    (FLOAT)(160.0 / 255.0),
    (FLOAT)(161.0 / 255.0),
    (FLOAT)(162.0 / 255.0),
    (FLOAT)(163.0 / 255.0),
    (FLOAT)(164.0 / 255.0),
    (FLOAT)(165.0 / 255.0),
    (FLOAT)(166.0 / 255.0),
    (FLOAT)(167.0 / 255.0),
    (FLOAT)(168.0 / 255.0),
    (FLOAT)(169.0 / 255.0),
    (FLOAT)(170.0 / 255.0),
    (FLOAT)(171.0 / 255.0),
    (FLOAT)(172.0 / 255.0),
    (FLOAT)(173.0 / 255.0),
    (FLOAT)(174.0 / 255.0),
    (FLOAT)(175.0 / 255.0),
    (FLOAT)(176.0 / 255.0),
    (FLOAT)(177.0 / 255.0),
    (FLOAT)(178.0 / 255.0),
    (FLOAT)(179.0 / 255.0),
    (FLOAT)(180.0 / 255.0),
    (FLOAT)(181.0 / 255.0),
    (FLOAT)(182.0 / 255.0),
    (FLOAT)(183.0 / 255.0),
    (FLOAT)(184.0 / 255.0),
    (FLOAT)(185.0 / 255.0),
    (FLOAT)(186.0 / 255.0),
    (FLOAT)(187.0 / 255.0),
    (FLOAT)(188.0 / 255.0),
    (FLOAT)(189.0 / 255.0),
    (FLOAT)(190.0 / 255.0),
    (FLOAT)(191.0 / 255.0),
    (FLOAT)(192.0 / 255.0),
    (FLOAT)(193.0 / 255.0),
    (FLOAT)(194.0 / 255.0),
    (FLOAT)(195.0 / 255.0),
    (FLOAT)(196.0 / 255.0),
    (FLOAT)(197.0 / 255.0),
    (FLOAT)(198.0 / 255.0),
    (FLOAT)(199.0 / 255.0),
    (FLOAT)(200.0 / 255.0),
    (FLOAT)(201.0 / 255.0),
    (FLOAT)(202.0 / 255.0),
    (FLOAT)(203.0 / 255.0),
    (FLOAT)(204.0 / 255.0),
    (FLOAT)(205.0 / 255.0),
    (FLOAT)(206.0 / 255.0),
    (FLOAT)(207.0 / 255.0),
    (FLOAT)(208.0 / 255.0),
    (FLOAT)(209.0 / 255.0),
    (FLOAT)(210.0 / 255.0),
    (FLOAT)(211.0 / 255.0),
    (FLOAT)(212.0 / 255.0),
    (FLOAT)(213.0 / 255.0),
    (FLOAT)(214.0 / 255.0),
    (FLOAT)(215.0 / 255.0),
    (FLOAT)(216.0 / 255.0),
    (FLOAT)(217.0 / 255.0),
    (FLOAT)(218.0 / 255.0),
    (FLOAT)(219.0 / 255.0),
    (FLOAT)(220.0 / 255.0),
    (FLOAT)(221.0 / 255.0),
    (FLOAT)(222.0 / 255.0),
    (FLOAT)(223.0 / 255.0),
    (FLOAT)(224.0 / 255.0),
    (FLOAT)(225.0 / 255.0),
    (FLOAT)(226.0 / 255.0),
    (FLOAT)(227.0 / 255.0),
    (FLOAT)(228.0 / 255.0),
    (FLOAT)(229.0 / 255.0),
    (FLOAT)(230.0 / 255.0),
    (FLOAT)(231.0 / 255.0),
    (FLOAT)(232.0 / 255.0),
    (FLOAT)(233.0 / 255.0),
    (FLOAT)(234.0 / 255.0),
    (FLOAT)(235.0 / 255.0),
    (FLOAT)(236.0 / 255.0),
    (FLOAT)(237.0 / 255.0),
    (FLOAT)(238.0 / 255.0),
    (FLOAT)(239.0 / 255.0),
    (FLOAT)(240.0 / 255.0),
    (FLOAT)(241.0 / 255.0),
    (FLOAT)(242.0 / 255.0),
    (FLOAT)(243.0 / 255.0),
    (FLOAT)(244.0 / 255.0),
    (FLOAT)(245.0 / 255.0),
    (FLOAT)(246.0 / 255.0),
    (FLOAT)(247.0 / 255.0),
    (FLOAT)(248.0 / 255.0),
    (FLOAT)(249.0 / 255.0),
    (FLOAT)(250.0 / 255.0),
    (FLOAT)(251.0 / 255.0),
    (FLOAT)(252.0 / 255.0),
    (FLOAT)(253.0 / 255.0),
    (FLOAT)(254.0 / 255.0),
    1.0f,
    // Extra entry to allow for overflow.
    1.0f,
};

DOUBLE g_dSnap[33] =
{
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW52,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW51,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW50,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW49,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW48,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW47,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW46,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW45,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW44,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW43,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW42,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW41,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW40,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW39,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW38,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW37,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW36,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW35,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW34,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW33,
    (DOUBLE)CONST_TWOPOW32 + (DOUBLE)CONST_TWOPOW31,
    (DOUBLE)CONST_TWOPOW31 + (DOUBLE)CONST_TWOPOW30,
    (DOUBLE)CONST_TWOPOW30 + (DOUBLE)CONST_TWOPOW29,
    (DOUBLE)CONST_TWOPOW29 + (DOUBLE)CONST_TWOPOW28,
    (DOUBLE)CONST_TWOPOW28 + (DOUBLE)CONST_TWOPOW27,
    (DOUBLE)CONST_TWOPOW27 + (DOUBLE)CONST_TWOPOW26,
    (DOUBLE)CONST_TWOPOW26 + (DOUBLE)CONST_TWOPOW25,
    (DOUBLE)CONST_TWOPOW25 + (DOUBLE)CONST_TWOPOW24,
    (DOUBLE)CONST_TWOPOW24 + (DOUBLE)CONST_TWOPOW23,
    (DOUBLE)CONST_TWOPOW23 + (DOUBLE)CONST_TWOPOW22,
    (DOUBLE)CONST_TWOPOW22 + (DOUBLE)CONST_TWOPOW21,
    (DOUBLE)CONST_TWOPOW21 + (DOUBLE)CONST_TWOPOW20,
    (DOUBLE)CONST_TWOPOW20 + (DOUBLE)CONST_TWOPOW19,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\hrstr.cpp ===
//----------------------------------------------------------------------------
//
// hrstr.cpp
//
// HRESULT-to-string mapper.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#if DBG

#include "cppdbg.hpp"

struct HrStringDef
{
    HRESULT hr;
    char *pString;
};

#define HRDEF(Name) \
    Name, #Name

static HrStringDef g_HrStringDefs[] =
{
    // Put specific codes before generic codes so that specific codes
    // are returned in the cases where the HRESULT is the same.
    HRDEF(DDERR_ALREADYINITIALIZED),
    HRDEF(DDERR_BLTFASTCANTCLIP),
    HRDEF(DDERR_CANNOTATTACHSURFACE),
    HRDEF(DDERR_CANNOTDETACHSURFACE),
    HRDEF(DDERR_CANTCREATEDC),
    HRDEF(DDERR_CANTDUPLICATE),
    HRDEF(DDERR_CLIPPERISUSINGHWND),
    HRDEF(DDERR_COLORKEYNOTSET),
    HRDEF(DDERR_CURRENTLYNOTAVAIL),
    HRDEF(DDERR_DIRECTDRAWALREADYCREATED),
    HRDEF(DDERR_EXCEPTION),
    HRDEF(DDERR_EXCLUSIVEMODEALREADYSET),
    HRDEF(DDERR_GENERIC),
    HRDEF(DDERR_HEIGHTALIGN),
    HRDEF(DDERR_HWNDALREADYSET),
    HRDEF(DDERR_HWNDSUBCLASSED),
    HRDEF(DDERR_IMPLICITLYCREATED),
    HRDEF(DDERR_INCOMPATIBLEPRIMARY),
    HRDEF(DDERR_INVALIDCAPS),
    HRDEF(DDERR_INVALIDCLIPLIST),
    HRDEF(DDERR_INVALIDDIRECTDRAWGUID),
    HRDEF(DDERR_INVALIDMODE),
    HRDEF(DDERR_INVALIDOBJECT),
    HRDEF(DDERR_INVALIDPARAMS),
    HRDEF(DDERR_INVALIDPIXELFORMAT),
    HRDEF(DDERR_INVALIDPOSITION),
    HRDEF(DDERR_INVALIDRECT),
    HRDEF(DDERR_LOCKEDSURFACES),
    HRDEF(DDERR_NO3D),
    HRDEF(DDERR_NOALPHAHW),
    HRDEF(DDERR_NOBLTHW),
    HRDEF(DDERR_NOCLIPLIST),
    HRDEF(DDERR_NOCLIPPERATTACHED),
    HRDEF(DDERR_NOCOLORCONVHW),
    HRDEF(DDERR_NOCOLORKEY),
    HRDEF(DDERR_NOCOLORKEYHW),
    HRDEF(DDERR_NOCOOPERATIVELEVELSET),
    HRDEF(DDERR_NODC),
    HRDEF(DDERR_NODDROPSHW),
    HRDEF(DDERR_NODIRECTDRAWHW),
    HRDEF(DDERR_NOEMULATION),
    HRDEF(DDERR_NOEXCLUSIVEMODE),
    HRDEF(DDERR_NOFLIPHW),
    HRDEF(DDERR_NOGDI),
    HRDEF(DDERR_NOHWND),
    HRDEF(DDERR_NOMIRRORHW),
    HRDEF(DDERR_NOOVERLAYDEST),
    HRDEF(DDERR_NOOVERLAYHW),
    HRDEF(DDERR_NOPALETTEATTACHED),
    HRDEF(DDERR_NOPALETTEHW),
    HRDEF(DDERR_NORASTEROPHW),
    HRDEF(DDERR_NOROTATIONHW),
    HRDEF(DDERR_NOSTRETCHHW),
    HRDEF(DDERR_NOT4BITCOLOR),
    HRDEF(DDERR_NOT4BITCOLORINDEX),
    HRDEF(DDERR_NOT8BITCOLOR),
    HRDEF(DDERR_NOTAOVERLAYSURFACE),
    HRDEF(DDERR_NOTEXTUREHW),
    HRDEF(DDERR_NOTFLIPPABLE),
    HRDEF(DDERR_NOTFOUND),
    HRDEF(DDERR_NOTLOCKED),
    HRDEF(DDERR_NOTPALETTIZED),
    HRDEF(DDERR_NOVSYNCHW),
    HRDEF(DDERR_NOZBUFFERHW),
    HRDEF(DDERR_NOZOVERLAYHW),
    HRDEF(DDERR_OUTOFCAPS),
    HRDEF(DDERR_OUTOFMEMORY),
    HRDEF(DDERR_OUTOFVIDEOMEMORY),
    HRDEF(DDERR_OVERLAYCANTCLIP),
    HRDEF(DDERR_OVERLAYCOLORKEYONLYONEACTIVE),
    HRDEF(DDERR_OVERLAYNOTVISIBLE),
    HRDEF(DDERR_PALETTEBUSY),
    HRDEF(DDERR_PRIMARYSURFACEALREADYEXISTS),
    HRDEF(DDERR_REGIONTOOSMALL),
    HRDEF(DDERR_SURFACEALREADYATTACHED),
    HRDEF(DDERR_SURFACEALREADYDEPENDENT),
    HRDEF(DDERR_SURFACEBUSY),
    HRDEF(DDERR_SURFACEISOBSCURED),
    HRDEF(DDERR_SURFACELOST),
    HRDEF(DDERR_SURFACENOTATTACHED),
    HRDEF(DDERR_TOOBIGHEIGHT),
    HRDEF(DDERR_TOOBIGSIZE),
    HRDEF(DDERR_TOOBIGWIDTH),
    HRDEF(DDERR_UNSUPPORTED),
    HRDEF(DDERR_UNSUPPORTEDFORMAT),
    HRDEF(DDERR_UNSUPPORTEDMASK),
    HRDEF(DDERR_VERTICALBLANKINPROGRESS),
    HRDEF(DDERR_WASSTILLDRAWING),
    HRDEF(DDERR_WRONGMODE),
    HRDEF(DDERR_XALIGN),
    HRDEF(E_OUTOFMEMORY),
    HRDEF(E_INVALIDARG),
    HRDEF(E_FAIL),
    HRDEF(S_FALSE),
    HRDEF(S_OK),
    HRDEF(D3DERR_WRONGTEXTUREFORMAT),
    HRDEF(D3DERR_UNSUPPORTEDCOLOROPERATION),
    HRDEF(D3DERR_UNSUPPORTEDCOLORARG),
    HRDEF(D3DERR_UNSUPPORTEDALPHAOPERATION),
    HRDEF(D3DERR_UNSUPPORTEDALPHAARG),
    HRDEF(D3DERR_TOOMANYOPERATIONS),
    HRDEF(D3DERR_CONFLICTINGTEXTUREFILTER),
    HRDEF(D3DERR_UNSUPPORTEDFACTORVALUE),
    HRDEF(D3DERR_CONFLICTINGRENDERSTATE),
    HRDEF(D3DERR_UNSUPPORTEDTEXTUREFILTER),
    HRDEF(D3DERR_CONFLICTINGTEXTUREPALETTE),
    HRDEF(D3DERR_DRIVERINTERNALERROR),
    HRDEF(D3DERR_NOTFOUND),
    HRDEF(D3DERR_MOREDATA),
    HRDEF(D3DERR_DEVICENOTRESET),
    HRDEF(D3DERR_DEVICELOST),
    HRDEF(D3DERR_NOTAVAILABLE),
    HRDEF(D3DERR_INVALIDDEVICE),
    HRDEF(D3DERR_INVALIDCALL),
    0, NULL,
};

//----------------------------------------------------------------------------
//
// DebugModule::HrString
//
// Attempts to produce a descriptive string for the given HRESULT.
//
//----------------------------------------------------------------------------

char *DebugModule::HrString(HRESULT hr)
{
    HrStringDef *pHrDef;

    // Look for a defined string.
    for (pHrDef = g_HrStringDefs; pHrDef->pString != NULL; pHrDef++)
    {
        if (pHrDef->hr == hr)
        {
            return pHrDef->pString;
        }
    }

    // It's not a defined string so return the numeric value
    // as a string.  Use a circular buffer of strings so that
    // this routine can be used more than once in a particular output
    // message.
    
#define STATIC_BUFFER 256
#define MAX_STRING 16
    
    static char chBuffer[STATIC_BUFFER];
    static char *pBuf = chBuffer;
    char *pString;

    if (pBuf - chBuffer + MAX_STRING > STATIC_BUFFER)
    {
        pBuf = chBuffer;
    }

    sprintf(pBuf, "0x%08X", hr);

    pString = pBuf;
    pBuf += MAX_STRING;

    return pString;
}

//----------------------------------------------------------------------------
//
// HrString
//
// Attempts to produce a descriptive string for the given HRESULT.
//
//----------------------------------------------------------------------------

char *HrToStr(HRESULT hr)
{
    HrStringDef *pHrDef;

    // Look for a defined string.
    for (pHrDef = g_HrStringDefs; pHrDef->pString != NULL; pHrDef++)
    {
        if (pHrDef->hr == hr)
        {
            return pHrDef->pString;
        }
    }

    // It's not a defined string so return the numeric value
    // as a string.  Use a circular buffer of strings so that
    // this routine can be used more than once in a particular output
    // message.
    
#define STATIC_BUFFER 256
#define MAX_STRING 16
    
    static char chBuffer[STATIC_BUFFER];
    static char *pBuf = chBuffer;
    char *pString;

    if (pBuf - chBuffer + MAX_STRING > STATIC_BUFFER)
    {
        pBuf = chBuffer;
    }

    sprintf(pBuf, "0x%08X", hr);

    pString = pBuf;
    pBuf += MAX_STRING;

    return pString;
}

#endif // #if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\d3dutil.h ===
//----------------------------------------------------------------------------
//
// d3dutil.h
//
// Miscellaneous utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _D3DUTIL_H_
#define _D3DUTIL_H_

#include <d3d8typesp.h>
#include <d3dflt.h>
#include <d3ditype.h>

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#ifdef __cplusplus
extern "C" {
#endif

typedef D3DVECTOR* LPD3DVECTOR;

// Stub function that should never be called.  Prints a warning and
// DebugBreaks.  Can be inserted in any function table, although it
// will destroy the stack frame with callconv or argument mismatch.
// That's OK since if it's called something has gone wrong.
void FASTCALL
DebugBreakFn(void);

// Texture coordinate difference.
FLOAT FASTCALL
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode);

// Inline texture coordinate difference.
__inline FLOAT
InlTextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
#include <texdiff.h>

// Returns a good approximation to sqrt(fX*fX + fY*fY)
FLOAT FASTCALL
OctagonNorm(FLOAT fX, FLOAT fY);

// LOD computation.
INT FASTCALL
ComputeLOD(CONST struct tagD3DI_RASTCTX *pCtx,
           FLOAT fU, FLOAT fV, FLOAT fW,
           FLOAT fDUoWDX, FLOAT fDVoWDX, FLOAT fDOoWDX,
           FLOAT fDUoWDY, FLOAT fDVoWDY, FLOAT fDOoWDY);

// Table fog value computation.
UINT FASTCALL
ComputeTableFog(PDWORD pdwRenderState, FLOAT fZ);

// Compute integer log2 for exact powers of 2.
UINT32 FASTCALL
IntLog2(UINT32 x);

//
// D3DVECTOR operations.
//

#define pVecLenSq(pVec)                                                       \
    pVecDot(pVec, pVec)
#define pVecLen(pVec)                                                         \
    SQRTF(pVecLenSq(pVec))

void FASTCALL
pVecNormalize2(LPD3DVECTOR pVec, LPD3DVECTOR pRes);

#define pVecNormalize(pVec)             pVecNormalize2(pVec, pVec)
#define VecNormalize(Vec)               pVecNormalize(&(Vec))
#define VecNormalize2(Vec, Res)         pVecNormalize2(&(Vec), &(Res))

#define pVecDot(pVec1, pVec2)                                                 \
    ((pVec1)->x * (pVec2)->x + (pVec1)->y * (pVec2)->y +                      \
     (pVec1)->z * (pVec2)->z)

#define pVecAdd(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x + (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y + (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z + (pVec2)->z)

#define pVecSub(pVec1, pVec2, pRes)                                           \
    ((pRes)->x = (pVec1)->x - (pVec2)->x,                                     \
     (pRes)->y = (pVec1)->y - (pVec2)->y,                                     \
     (pRes)->z = (pVec1)->z - (pVec2)->z)

#define pVecScale(pVec, fScale, pRes)                                         \
    ((pRes)->x = (pVec)->x * (fScale),                                        \
     (pRes)->y = (pVec)->y * (fScale),                                        \
     (pRes)->z = (pVec)->z * (fScale))

#define pVecNeg(pVec, pRes)                                                   \
    ((pRes)->x = NEGF((pVec)->x),                                             \
     (pRes)->y = NEGF((pVec)->y),                                             \
     (pRes)->z = NEGF((pVec)->z))

#define pVecSet(pVec, fX, fY, fZ)                                             \
    ((pVec)->x = (fX), (pVec)->y = (fY), (pVec)->z = (fZ))

#define VecLenSq(Vec)                   pVecLenSq(&(Vec))
#define VecLen(Vec)                     pVecLen(&(Vec))

#ifdef _X86_

// Vector normalize through a table
void  FASTCALL TableVecNormalize(float *result, float *normal);
// Vector normalize using Jim Blinn's floating point trick
void  FASTCALL JBVecNormalize(float *result, float *normal);

#define VecNormalizeFast(Vec)          TableVecNormalize((float*)&(Vec), (float*)&(Vec))
#define VecNormalizeFast2(Vec, Res)    TableVecNormalize((float*)&(Res), (float*)&(Vec))
#define pVecNormalizeFast(Vec)         TableVecNormalize((float*)pVec, (float*)pVec)
#define pVecNormalizeFast2(pVec, pRes) TableVecNormalize((float*)pRes, (float*)pVec)

#else

#define VecNormalizeFast(Vec)               pVecNormalize((LPD3DVECTOR)&(Vec))
#define VecNormalizeFast2(Vec, Res)         pVecNormalize2((LPD3DVECTOR)&(Vec), &(Res))
#define pVecNormalizeFast(pVec)             pVecNormalize((LPD3DVECTOR)(pVec))
#define pVecNormalizeFast2(pVec, pRes)      pVecNormalize2((LPD3DVECTOR)(pVec), pRes)

#endif // _X86_

#define VecDot(Vec1, Vec2)              pVecDot(&(Vec1), &(Vec2))
#define VecAdd(Vec1, Vec2, Res)         pVecAdd(&(Vec1), &(Vec2), &(Res))
#define VecSub(Vec1, Vec2, Res)         pVecSub(&(Vec1), &(Vec2), &(Res))
#define VecScale(Vec1, fScale, Res)     pVecScale(&(Vec1), fScale, &(Res))
#define VecNeg(Vec, Res)                pVecNeg(&(Vec), &(Res))
#define VecSet(Vec, fX, fY, fZ)         pVecSet(&(Vec), fX, fY, fZ)

//---------------------------------------------------------------------
// Convert homogeneous vector to 3D vector
//
// Returns:
//      0   - if success
//     -1   - v.w == 0
//
__inline int Vector4to3D(D3DVECTORH *v)
{
    if (v->w == 0)
        return -1;
    D3DVALUE k = 1.0f/v->w;
    v->x *= k;
    v->y *= k;
    v->z *= k;
    v->w = 1;
    return 0;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4(D3DVECTOR *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by transposed 4x4 matrix, producing a
// homogeneous vector
//
// res and v should not be the same
//
__inline void VecMatMul4HT(D3DVECTORH *v, D3DMATRIX *m, D3DVECTORH *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//
__inline void VecMatMul3(D3DVECTOR *v, D3DMATRIX *m, D3DVECTOR *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}
//---------------------------------------------------------------------
// Builds normalized plane equations going through 3 points
//
// Returns:
//      0   - if success
//      -1  - if can not build plane
//
int MakePlane(D3DVECTOR *v1, D3DVECTOR *v2, D3DVECTOR *v3,
                     D3DVECTORH *plane);
//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);

//---------------------------------------------------------------------
//  4 by 4 matrix product
//
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b);

//---------------------------------------------------------------------
// Checks the FVF flags for errors and returns the stride in bytes between
// vertices.
//
// Returns:
//      HRESULT and stride in bytes between vertices
//
//---------------------------------------------------------------------
HRESULT FASTCALL
FVFCheckAndStride(DWORD dwFVF, DWORD* pdwStride);

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//
BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);

#ifdef __cplusplus
}
#endif

#endif // #ifndef _D3DUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\d3dflt.h ===
//----------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// d3dflt.h
//
// Floating-point constants and operations on FP values.
//
//----------------------------------------------------------------------------

#ifndef _D3DFLT_H_
#define _D3DFLT_H_

#include <math.h>
#include <float.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef union tagFLOATINT32
{
    FLOAT f;
    INT32 i;
    UINT32 u;
} FLOATINT32, *PFLOATINT32;

//
// Type-forcing macros to access FP as integer and vice-versa.
// ATTENTION - VC5's optimizer turns these macros into ftol sometimes,
// completely breaking them.
// Using FLOATINT32 works around the problem but is not as flexible,
// so the old code is kept around for the time when the compiler is fixed.
// Note that pointer casting with FLOATINT32 fails just as the direct
// pointer casting does, so it's not a remedy.
//
// Use these macros with extreme care.
//

#define ASFLOAT(i) (*(FLOAT *)&(i))
#define ASINT32(f) (*(INT32 *)&(f))
#define ASUINT32(f) (*(UINT32 *)&(f))

//
// FP constants.
//

// Powers of two for snap values.  These should not be used in code.
#define CONST_TWOPOW0   1
#define CONST_TWOPOW1   2
#define CONST_TWOPOW2   4
#define CONST_TWOPOW3   8
#define CONST_TWOPOW4   16
#define CONST_TWOPOW5   32
#define CONST_TWOPOW6   64
#define CONST_TWOPOW7   128
#define CONST_TWOPOW8   256
#define CONST_TWOPOW9   512
#define CONST_TWOPOW10  1024
#define CONST_TWOPOW11  2048
#define CONST_TWOPOW12  4096
#define CONST_TWOPOW13  8192
#define CONST_TWOPOW14  16384
#define CONST_TWOPOW15  32768
#define CONST_TWOPOW16  65536
#define CONST_TWOPOW17  131072
#define CONST_TWOPOW18  262144
#define CONST_TWOPOW19  524288
#define CONST_TWOPOW20  1048576
#define CONST_TWOPOW21  2097152
#define CONST_TWOPOW22  4194304
#define CONST_TWOPOW23  8388608
#define CONST_TWOPOW24  16777216
#define CONST_TWOPOW25  33554432
#define CONST_TWOPOW26  67108864
#define CONST_TWOPOW27  134217728
#define CONST_TWOPOW28  268435456
#define CONST_TWOPOW29  536870912
#define CONST_TWOPOW30  1073741824
#define CONST_TWOPOW31  2147483648
#define CONST_TWOPOW32  4294967296
#define CONST_TWOPOW33  8589934592
#define CONST_TWOPOW34  17179869184
#define CONST_TWOPOW35  34359738368
#define CONST_TWOPOW36  68719476736
#define CONST_TWOPOW37  137438953472
#define CONST_TWOPOW38  274877906944
#define CONST_TWOPOW39  549755813888
#define CONST_TWOPOW40  1099511627776
#define CONST_TWOPOW41  2199023255552
#define CONST_TWOPOW42  4398046511104
#define CONST_TWOPOW43  8796093022208
#define CONST_TWOPOW44  17592186044416
#define CONST_TWOPOW45  35184372088832
#define CONST_TWOPOW46  70368744177664
#define CONST_TWOPOW47  140737488355328
#define CONST_TWOPOW48  281474976710656
#define CONST_TWOPOW49  562949953421312
#define CONST_TWOPOW50  1125899906842624
#define CONST_TWOPOW51  2251799813685248
#define CONST_TWOPOW52  4503599627370496

#define FLOAT_TWOPOW0   ((FLOAT)(CONST_TWOPOW0))
#define FLOAT_TWOPOW1   ((FLOAT)(CONST_TWOPOW1))
#define FLOAT_TWOPOW2   ((FLOAT)(CONST_TWOPOW2))
#define FLOAT_TWOPOW3   ((FLOAT)(CONST_TWOPOW3))
#define FLOAT_TWOPOW4   ((FLOAT)(CONST_TWOPOW4))
#define FLOAT_TWOPOW5   ((FLOAT)(CONST_TWOPOW5))
#define FLOAT_TWOPOW6   ((FLOAT)(CONST_TWOPOW6))
#define FLOAT_TWOPOW7   ((FLOAT)(CONST_TWOPOW7))
#define FLOAT_TWOPOW8   ((FLOAT)(CONST_TWOPOW8))
#define FLOAT_TWOPOW9   ((FLOAT)(CONST_TWOPOW9))
#define FLOAT_TWOPOW10  ((FLOAT)(CONST_TWOPOW10))
#define FLOAT_TWOPOW11  ((FLOAT)(CONST_TWOPOW11))
#define FLOAT_TWOPOW12  ((FLOAT)(CONST_TWOPOW12))
#define FLOAT_TWOPOW13  ((FLOAT)(CONST_TWOPOW13))
#define FLOAT_TWOPOW14  ((FLOAT)(CONST_TWOPOW14))
#define FLOAT_TWOPOW15  ((FLOAT)(CONST_TWOPOW15))
#define FLOAT_TWOPOW16  ((FLOAT)(CONST_TWOPOW16))
#define FLOAT_TWOPOW17  ((FLOAT)(CONST_TWOPOW17))
#define FLOAT_TWOPOW18  ((FLOAT)(CONST_TWOPOW18))
#define FLOAT_TWOPOW19  ((FLOAT)(CONST_TWOPOW19))
#define FLOAT_TWOPOW20  ((FLOAT)(CONST_TWOPOW20))
#define FLOAT_TWOPOW21  ((FLOAT)(CONST_TWOPOW21))
#define FLOAT_TWOPOW22  ((FLOAT)(CONST_TWOPOW22))
#define FLOAT_TWOPOW23  ((FLOAT)(CONST_TWOPOW23))
#define FLOAT_TWOPOW24  ((FLOAT)(CONST_TWOPOW24))
#define FLOAT_TWOPOW25  ((FLOAT)(CONST_TWOPOW25))
#define FLOAT_TWOPOW26  ((FLOAT)(CONST_TWOPOW26))
#define FLOAT_TWOPOW27  ((FLOAT)(CONST_TWOPOW27))
#define FLOAT_TWOPOW28  ((FLOAT)(CONST_TWOPOW28))
#define FLOAT_TWOPOW29  ((FLOAT)(CONST_TWOPOW29))
#define FLOAT_TWOPOW30  ((FLOAT)(CONST_TWOPOW30))
#define FLOAT_TWOPOW31  ((FLOAT)(CONST_TWOPOW31))
#define FLOAT_TWOPOW32  ((FLOAT)(CONST_TWOPOW32))
#define FLOAT_TWOPOW33  ((FLOAT)(CONST_TWOPOW33))
#define FLOAT_TWOPOW34  ((FLOAT)(CONST_TWOPOW34))
#define FLOAT_TWOPOW35  ((FLOAT)(CONST_TWOPOW35))
#define FLOAT_TWOPOW36  ((FLOAT)(CONST_TWOPOW36))
#define FLOAT_TWOPOW37  ((FLOAT)(CONST_TWOPOW37))
#define FLOAT_TWOPOW38  ((FLOAT)(CONST_TWOPOW38))
#define FLOAT_TWOPOW39  ((FLOAT)(CONST_TWOPOW39))
#define FLOAT_TWOPOW40  ((FLOAT)(CONST_TWOPOW40))
#define FLOAT_TWOPOW41  ((FLOAT)(CONST_TWOPOW41))
#define FLOAT_TWOPOW42  ((FLOAT)(CONST_TWOPOW42))
#define FLOAT_TWOPOW43  ((FLOAT)(CONST_TWOPOW43))
#define FLOAT_TWOPOW44  ((FLOAT)(CONST_TWOPOW44))
#define FLOAT_TWOPOW45  ((FLOAT)(CONST_TWOPOW45))
#define FLOAT_TWOPOW46  ((FLOAT)(CONST_TWOPOW46))
#define FLOAT_TWOPOW47  ((FLOAT)(CONST_TWOPOW47))
#define FLOAT_TWOPOW48  ((FLOAT)(CONST_TWOPOW48))
#define FLOAT_TWOPOW49  ((FLOAT)(CONST_TWOPOW49))
#define FLOAT_TWOPOW50  ((FLOAT)(CONST_TWOPOW50))
#define FLOAT_TWOPOW51  ((FLOAT)(CONST_TWOPOW51))
#define FLOAT_TWOPOW52  ((FLOAT)(CONST_TWOPOW52))

// Values that are smaller than the named value by the smallest
// representable amount.  Since this depends on the type used
// there is no CONST form.
#define FLOAT_NEARTWOPOW31      ((FLOAT)2147483583)
#define FLOAT_NEARTWOPOW32      ((FLOAT)4294967167)

// Value close enough to zero to consider zero.  This can't be too small
// but it can't be too large.  In other words, it's picked by guessing.
#define FLOAT_NEARZERO          (1e-5f)

// General FP constants.
#define FLOAT_E                 ((FLOAT)2.7182818284590452354)

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
    
// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

#ifdef _X86_

// All FP values are loaded from memory so declare them all as global
// variables.

extern FLOAT g_fE;
extern FLOAT g_fZero;
extern FLOAT g_fNearZero;
extern FLOAT g_fHalf;
extern FLOAT g_fp95;
extern FLOAT g_fOne;
extern FLOAT g_fOneMinusEps;
extern FLOAT g_fExpScale;
extern FLOAT g_fOoExpScale;
extern FLOAT g_f255oTwoPow15;
extern FLOAT g_fOo255;
extern FLOAT g_fOo256;
extern FLOAT g_fTwoPow7;
extern FLOAT g_fTwoPow8;
extern FLOAT g_fTwoPow11;
extern FLOAT g_fTwoPow15;
extern FLOAT g_fOoTwoPow15;
extern FLOAT g_fTwoPow16;
extern FLOAT g_fOoTwoPow16;
extern FLOAT g_fTwoPow20;
extern FLOAT g_fOoTwoPow20;
extern FLOAT g_fTwoPow27;
extern FLOAT g_fOoTwoPow27;
extern FLOAT g_fTwoPow30;
extern FLOAT g_fTwoPow31;
extern FLOAT g_fNearTwoPow31;
extern FLOAT g_fOoTwoPow31;
extern FLOAT g_fOoNearTwoPow31;
extern FLOAT g_fTwoPow32;
extern FLOAT g_fNearTwoPow32;
extern FLOAT g_fTwoPow39;
extern FLOAT g_fTwoPow47;

#else

// Leave FP values as constants.

#define g_fE                    FLOAT_E
#define g_fNearZero             FLOAT_NEARZERO
#define g_fZero                 (0.0f)
#define g_fHalf                 (0.5f)
#define g_fp95                  (0.95f)
#define g_fOne                  (1.0f)
#define g_fOneMinusEps          (1.0f - FLT_EPSILON)
#define g_fExpScale             FLOAT_EXPSCALE
#define g_fOoExpScale           ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))
#define g_f255oTwoPow15         ((FLOAT)(255.0 / (double)CONST_TWOPOW15))
#define g_fOo255                ((FLOAT)(1.0 / 255.0))
#define g_fOo256                ((FLOAT)(1.0 / 256.0))
#define g_fTwoPow7              FLOAT_TWOPOW7
#define g_fTwoPow8              FLOAT_TWOPOW8
#define g_fTwoPow11             FLOAT_TWOPOW11
#define g_fTwoPow15             FLOAT_TWOPOW15
#define g_fOoTwoPow15           ((FLOAT)(1.0 / (double)CONST_TWOPOW15))
#define g_fTwoPow16             FLOAT_TWOPOW16
#define g_fOoTwoPow16           ((FLOAT)(1.0 / (double)CONST_TWOPOW16))
#define g_fTwoPow20             FLOAT_TWOPOW20
#define g_fOoTwoPow20           ((FLOAT)(1.0 / (double)CONST_TWOPOW20))
#define g_fTwoPow27             FLOAT_TWOPOW27
#define g_fOoTwoPow27           ((FLOAT)(1.0 / (double)CONST_TWOPOW27))
#define g_fTwoPow30             FLOAT_TWOPOW30
#define g_fTwoPow31             FLOAT_TWOPOW31
#define g_fNearTwoPow31         FLOAT_NEARTWOPOW31
#define g_fOoTwoPow31           ((FLOAT)(1.0 / (double)CONST_TWOPOW31))
#define g_fOoNearTwoPow31       ((FLOAT)(1.0 / ((double)FLOAT_NEARTWOPOW31)))
#define g_fTwoPow32             FLOAT_TWOPOW32
#define g_fNearTwoPow32         FLOAT_NEARTWOPOW32
#define g_fTwoPow39             FLOAT_TWOPOW39
#define g_fTwoPow47             FLOAT_TWOPOW47

#endif // _X86_

//
// Conversion tables.
//

// Takes an unsigned byte to a float in [0.0, 1.0].  257'th entry is
// also one to allow overflow.
extern FLOAT g_fUInt8ToFloat[257];

// Floating-point pinning values for float-int conversion.
extern double g_dSnap[33];

//
// x86 FP control for optimized FTOI and single-precision divides.
//

#ifdef _X86_

#define FPU_GET_MODE(uMode) \
    __asm fnstcw WORD PTR uMode
#define FPU_SET_MODE(uMode) \
    __asm fldcw WORD PTR uMode
#define FPU_SAFE_SET_MODE(uMode) \
    __asm fnclex \
    __asm fldcw WORD PTR uMode

#define FPU_MODE_CHOP_ROUND(uMode) \
    ((uMode) | 0xc00)
#define FPU_MODE_LOW_PRECISION(uMode) \
    ((uMode) & 0xfcff)
#define FPU_MODE_MASK_EXCEPTIONS(uMode) \
    ((uMode) | 0x3f)

#if DBG

#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm fnstcw cw             \
        DDASSERT((cw & 0xc00) == 0xc00); \
    }

#else

#define ASSERT_CHOP_ROUND()

#endif // DBG

#else

// Initialize with zero to avoid use-before-set errors.
#define FPU_GET_MODE(uMode) \
    ((uMode) = 0)
#define FPU_SET_MODE(uMode)
#define FPU_SAFE_SET_MODE(uMode)

#define FPU_MODE_CHOP_ROUND(uMode) 0
#define FPU_MODE_LOW_PRECISION(uMode) 0
#define FPU_MODE_MASK_EXCEPTIONS(uMode) 0

#define ASSERT_CHOP_ROUND()

#endif // _X86_

//
// Single-precision FP functions.
// May produce invalid results for exceptional or denormal values.
// ATTENTION - Alpha exposes float math routines and they may be a small win.
//

#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

// Approximate log and power functions using Jim Blinn's CG&A technique.
// Only work for positive values.

#ifdef POINTER_CASTING

__inline FLOAT
APPXLG2F(FLOAT f)
{
    return (FLOAT)(ASINT32(f) - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    INT32 i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    INT32 i = (INT32_FLOAT_ONE << 1) - ASINT32(f);
    return ASFLOAT(i);
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    INT32 i = (ASINT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    INT32 i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (ASINT32(f) >> 1);
    return ASFLOAT(i);
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    INT32 i = (INT32)(exp * (ASINT32(f) - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return ASFLOAT(i);
}

#else

__inline FLOAT
APPXLG2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (FLOAT)(fi.i - INT32_FLOAT_ONE) * g_fOoExpScale;
}

__inline FLOAT
APPXPOW2F(FLOAT f)
{
    FLOATINT32 fi;
    fi.i = (INT32)(f * g_fExpScale) + INT32_FLOAT_ONE;
    return fi.f;
}

__inline FLOAT
APPXINVF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32_FLOAT_ONE << 1) - fi.i;
    return fi.f;
}

__inline FLOAT
APPXSQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (fi.i >> 1) + (INT32_FLOAT_ONE >> 1);
    return fi.f;
}

__inline FLOAT
APPXISQRTF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = INT32_FLOAT_ONE + (INT32_FLOAT_ONE >> 1) - (fi.i >> 1);
    return fi.f;
}

__inline FLOAT
APPXPOWF(FLOAT f, FLOAT exp)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.i = (INT32)(exp * (fi.i - INT32_FLOAT_ONE)) + INT32_FLOAT_ONE;
    return fi.f;
}

#endif

#ifdef _X86_

// Uses a table
float __fastcall TableInvSqrt(float value);
// Uses Jim Blinn's floating point trick
float __fastcall JBInvSqrt(float value);

#define ISQRTF(fV)      TableInvSqrt(fV);

#ifdef POINTER_CASTING

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    UINT32 i = ASUINT32(f) & 0x7fffffff;
    return ASFLOAT(i);
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    UINT32 i = ASUINT32(f) ^ 0x80000000;
    return ASFLOAT(i);
}

#else

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Toggle sign bit in integer.
__inline FLOAT
NEGF(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    fi.u ^= 0x80000000;
    return fi.f;
}

#endif // POINTER_CASTING

// Requires chop rounding.
__inline INT32
SCALED_FRACTION(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fmul g_fTwoPow31
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

// Requires chop rounding.
#define ICEILF(f)       (FLOAT_LEZ(f) ? FTOI(f) : FTOI((f) + g_fOneMinusEps))
#define CEILF(f)        ((FLOAT)ICEILF(f))
#define IFLOORF(f)      (FLOAT_LTZ(f) ? FTOI((f) - g_fOneMinusEps) : FTOI(f))
#define FLOORF(f)       ((FLOAT)IFLOORF(f))

#else // _X86_

#define ISQRTF(fV)              (1.0f / (FLOAT)sqrt((double)(fV)))
#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define NEGF(f)                 (-(f))
#define SCALED_FRACTION(f)      ((INT32)((f) * g_fTwoPow31))
#define FTOI(f)                 ((INT)(f))
#define CEILF(f)                ((FLOAT)ceil((double)(f)))
#define ICEILF(f)               ((INT)CEILF(f))
#define FLOORF(f)               ((FLOAT)floor((double)(f)))
#define IFLOORF(f)              ((INT)FLOORF(f))

#endif // _X86_

//
// Overlapped divide support.
//

#ifdef _X86_

// Starts a divide directly from memory.  Result field is provided for
// compatibility with non-x86 code that does the divide immediately.
#define FLD_BEGIN_DIVIDE(Num, Den, Res) { __asm fld Num __asm fdiv Den }
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) { __asm fld Num __asm fidiv Den }
// Store a divide result directly to memory.
#define FSTP_END_DIVIDE(Res)            { __asm fstp Res }

#else // _X86_

#define FLD_BEGIN_DIVIDE(Num, Den, Res) ((Res) = (Num) / (Den))
#define FLD_BEGIN_IDIVIDE(Num, Den, Res) ((Res) = (Num) / (FLOAT)(Den))
#define FSTP_END_DIVIDE(Res)

#endif // _X86_

//
// Specialized FP comparison functions.
//
// On the x86, it's faster to do compares with an integer cast
// than it is to do the fcom.
//
// The zero operations work for all normalized FP numbers, -0 included.
//

#ifdef _X86_

#define FLOAT_CMP_POS(fa, op, fb)       (ASINT32(fa) op ASINT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (ASINT32(flt) op INT32_FLOAT_ONE)

#ifdef POINTER_CASTING

#define FLOAT_GTZ(flt)                  (ASINT32(flt) > 0)
#define FLOAT_LTZ(flt)                  (ASUINT32(flt) > 0x80000000)
#define FLOAT_GEZ(flt)                  (ASUINT32(flt) <= 0x80000000)
#define FLOAT_LEZ(flt)                  (ASINT32(flt) <= 0)
#define FLOAT_EQZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) == 0)
#define FLOAT_NEZ(flt)                  ((ASUINT32(flt) & 0x7fffffff) != 0)

#else

__inline int FLOAT_GTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    FLOATINT32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

#endif // POINTER_CASTING

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#endif // _X86_

#ifdef __cplusplus
}
#endif
    
#endif // #ifndef _D3DFLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\_dpf.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define PROF_SECT "Direct3D"
#define START_STR "Direct3D7: "
#include "..\..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\texdiff.inc ===
;----------------------------------------------------------------------------
;
; texdiff.inc
;
; Assembly macro for TextureDiff.
;
; Copyright (C) Microsoft Corporation, 1997.
;
;----------------------------------------------------------------------------

IFNDEF __TEXDIFF_INC__
__TEXDIFF_INC__ EQU 1

;----------------------------------------------------------------------------
;
; TEXTURE_DIFF
;
; Computes difference of two texture coordinates and returns it on
; the top of the FP stack.
;
; Destroys eax and ecx.
;
;----------------------------------------------------------------------------
        
TEXTURE_DIFF MACRO fTb, fTa, iMode, fTmp
        LOCAL L_Exit, L_Ltz, L_Gtz, L_Zero, L_Straight

        ; Start initial fTb - fTa computation.
        fld fTb
        fsub fTa

        ; Check for wrapping.
        cmp iMode, 0
        jz L_Exit

        ; Compute smaller of straight or wrapped difference.
        fst fTmp
        fld st(0)

        ; Adjust straight difference according to sign to compute
        ; wrapped difference.
        mov eax, fTmp
        cmp eax, 080000000h
        ja L_Ltz
        cmp eax, 0
        je L_Zero

        ; Gtz
        fsub _g_fOne
        jmp L_Gtz
        
L_Ltz:
        fadd _g_fOne

L_Zero:
        and eax, 07fffffffh
L_Gtz:
        fst fTmp
        mov ecx, fTmp
        and ecx, 07fffffffh

        ; Pick smaller based on absolute values of differences.
        cmp eax, ecx
        jle L_Straight

        ; Discard straight difference so wrapped difference is
        ; returned.
        fxch st(1)

L_Straight:
        ; Discard wrapped difference so straight difference is
        ; returned.
        fstp st(0)
        
L_Exit:
        ENDM
        
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\texdiff.h ===
//----------------------------------------------------------------------------
//
// texdiff.h
//
// TextureDiff base code for inclusion as an inline function or
// regular function from common code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// TextureDiff
//
// Computes the difference between two texture coordinates according
// to the given texture wrap mode.
//
//----------------------------------------------------------------------------

{
    FLOAT fDiff1 = fTb - fTa;

    if (iMode == 0)
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if (FLOAT_LTZ(fDiff1))
        {
            fDiff2 += g_fOne;
        }
        else if (FLOAT_GTZ(fDiff1))
        {
            fDiff2 -= g_fOne;
        }
        if (ABSF(fDiff1) < ABSF(fDiff2))
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef WINNT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>
#include "ddraw.h"
#include <cppdbg.hpp>
#include "d3d8p.h"
#include "d3dtypesp.h"
#include "d3ditype.h"
#include "d3dflt.h"
#include "d3dutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\sources.inc ===
TARGETPATH=obj
TARGETNAME = d3dutil

TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);$(D3DDX8)\tnl

SOURCES = \
        ..\cppdbg.cpp\
        ..\d3dflt.cpp\
        ..\d3dutil.cpp\
        ..\hrstr.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\icprof.inc ===
pushcontext listing
.nolist
;
;	(C) Copyright Microsoft Corporation 1992, 1995

;	This file is used to create the same sets of prologue and epilogue
;	sequences which the Microsoft C 6.00 compiler will produce.  This
;	file would be used for writing windows programs and to provide
;	such features as stack checking in the assembler portions of
;	a C based project.


;	The following global variables will affect the prolog/epilog
;	sequences produced
;
;	PROFILE - If 1 then __penter calls will be inserted in all prologs
;	?WP_DEBUG - If 1 then prolog/epilog sequences will be forced
;	?WP_CHECKSTACK - If 1 then a check stack will be forced on all
;			procedures
;	?WP_INCBP - If 1 then the inc bp sequence will be generated on
;		all far procedures
;	?WP_LOADDS - If 1 then the load ds sequence will be generated on
;		all far procedures
;
ifndef ?WP_DEBUG
?WP_DEBUG = 0
endif
ifndef ?WP_CHECKSTACK
?WP_CHECKSTACK = 0
endif
ifndef ?WP_INCBP
?WP_INCBP = 0
endif
ifndef ?WP_LOADDS
?WP_LOADDS = 0
endif
ifndef PROFILE
PROFILE = 0
endif
ifndef ?WP_REGSAVE
?WP_REGSAVE = 0
endif

;
;	Complain if we are in a segment as this will affect how the
;	externdefs are done and therefore the fixups and code
;	created on the checkstack calls
;
% ifnb	 <@CurSeg>
echo	Include should not be contained in a segment
endif

externdef C	_aNchkstk:near		; Extern the symbols
externdef C	_aFchkstk:far		; for later reference
externdef C	_penter:near

;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP
;	PROFILE

option prologue:cPrologue

cPrologue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
	LOCAL	?cbLocals
	LOCAL	?doProfile
        LOCAL   ?doRegSave
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0
	?cbLocals = cbLocals
	?doProfile = 0
        ?doRegSave = 0

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default if far
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default if far
 if flags AND 020h
  ?loadds = 1
 endif
endif

if	PROFILE NE 0		    ;; profiling wanted
 ?doProfile  = 1			;; turn on profiling
endif

if      ?WP_REGSAVE NE 0
 ?doRegSave = 1
endif
        
;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>		 ;; Is it IncBP
   if flags AND 020h		;;	and far?
    ?incbp = 1			;;	Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

  ifidni <p>, <PROFILE>
   ?doProfile = 1
  endif

  ifidni <p>, <NOPROFILE>
   ?doProfile = 0
  endif

  ifidni <p>, <REGSAVE>
   ?doRegSave = 1
  endif
        
  ifidni <p>, <NOREGSAVE>
   ?doRegSave = 0
  endif
        
 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (?cbLocals NE 0) OR (cbParams NE 0)

if	?doProfile EQ 1 	;; generate profiling call
if      ?doRegSave EQ 1
        pushad
endif
	call	_penter
if      ?doRegSave EQ 1
        popad
endif
endif

if	?doPrologue EQ 0	;; No prolog needed -- so get out of here
;	popcontext listing
	exitm<0>
endif

if	?loadds EQ 1		;; Create the loadds code -- force in
	push	ds		;;	Put DS into AX -- we will place
	pop	ax	     ;;      back in DS later.	This sequence
	nop			;;	is altered by the OS if needed
endif

if	?incbp EQ 1		;; Mark as a far procedure for stack
	inc	bp	     ;;      walking
endif

if @WordSize eq 4
	push	ebp
	mov	ebp, esp
else
	push	bp	     ;; Create the frame
	mov	bp,sp
endif

if	?loadds EQ 1		;; Load up DS with the value in AX
	push	ds		;;
	mov	ds,ax	     ;;
	?cbLocals = ?cbLocals + 2
endif

if	?checkstack EQ 1	;; Now	allocate space for locals
	mov	ax,cbLocals  ;;      # of bytes of locals (unadjusted)
% ifidni <@CurSeg>, <_TEXT>
	call	_aNchkstk	;;	Call run time routine to allocate
 else
	call	_aFchkstk
 endif
else	; ?checkstack NE 1
  if	cbLocals NE 0
    if @WordSize eq 4
	sub	esp, cbLocals
    else
	sub	sp,cbLocals   ;;      make space on the stack for locals
    endif
  endif
endif

ifnb	rgRegs			;; There are registers to be saved.  do so
	for r,rgRegs
		push	r
	endm
endif
;	popcontext listing
	exitm <?cbLocals>

endm



;
;	This macro will produce the same output as will the
;	C6 compiler for the given switches.
;
;	The following may be placed in the MacroArgs field of the
;		proc defintion:
;
;	CHECKSTACK
;	NOCHECKSTACK
;	LOADDS
;	NOLOADDS
;	FORCEFRAME
;	INCBP
;	NOINCBP

option epilogue:cEpilogue

cEpilogue macro szProcName, flags, cbParams, cbLocals, rgRegs, rgUserParams
	LOCAL	?doPrologue
	LOCAL	?loadds
	LOCAL	?checkstack
	LOCAL	?incbp
;	pushcontext	listing
;	.nolistmacro
;	.listmacroall

	?doPrologue = 0
	?loadds = 0
	?checkstack = 0
	?incbp = 0

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;	Set the defaults based on the global values specified
;;
if	?WP_DEBUG NE 0			;; Force frames by default
 ?doPrologue = 1
endif

if	?WP_CHECKSTACK NE 0		;; Force checkstack by default
 ?checkstack = 1
endif

if	?WP_INCBP NE 0			;; Force incbp by default
 if flags AND 020h
  ?incbp = 1
 endif
endif

if	?WP_LOADDS NE 0 		;; Force loadds by default
 if flags AND 020h
  ?loadds = 1
 endif
endif

;;
;;	Get all of the user parameters parsed
;;

ifnb	<rgUserParams>		;;	Parse user params if exsisting
 for p,<rgUserParams>		;;	For every user param

  ifidni <p>, <CHECKSTACK>	 ;;	 Is it checkstack?
   ?checkstack = 1		;;		Yes -- do checkstack
  endif

  ifidni <p>, <NOCHECKSTACK>	 ;;	 Don't do checkstack?
   ?checkstack = 0		;;		Yes -- clear checkstack
  endif

  ifidni <p>, <LOADDS>	 ;;	 Is it LoadDS
   ?loadds = 1			;;		Yes -- do loadds sequence
  endif

  ifidni <p>, <NOLOADDS> ;;	 Don't do LoadDS?
   ?loadds = 0			;;		Yes -- clear loadds flag
  endif

  ifidni <p>, <INCBP>	 ;;	 Is it IncBP
   if flags AND 020h
    ?incbp = 1			;;		Yes -- do IncBP sequence
   endif
  endif

  ifidni <p>, <NOINCBP>  ;;	 Is it NoIncBP
   ?incbp = 0			;;		Yes -- Clear the incbp flag
  endif

  ifidni <p>, <FORCEFRAME>	 ;;	 Is it ForceFrame?
   ?doPrologue = 1			;;		Yes -- force out a frame
  endif

 endm			;; End of user parameter parsing loop
endif

;;  Turn off options that don't make sense in USE32 segment

if @WordSize eq 4
  ?checkstack = 0
  ?loadds = 0
  ?incbp = 0
endif

;;  Frames are generated iff
;;	1. cbLocals + cbParams != 0
;;	2. FORCEFRAME is set
;;	3. INCBP is set and proc is far
;;	4. LOADDS is set
;;
;; Force a prolog?

?doPrologue = ?doPrologue OR ?incbp OR ?loadds OR ?checkstack OR (cbLocals NE 0) OR (cbParams NE 0)

if	?doPrologue EQ 0	;; No epilog needed -- so get out of here
	ret
	exitm
endif

ifnb	rgRegs			;; Pop off the registers -- they are in
	for r,rgRegs		;; inverse order from the prologue call
		pop	r
	endm
endif

if	?loadds 		;;
	dec	bp
	dec	bp
	mov	sp,bp
	pop	ds
	pop	bp
else

  if @WordSize eq 4
	mov	esp, ebp
	pop	ebp
  else
	mov	sp,bp
	pop	bp
  endif
endif

if	?incbp			;; Remove the increment of BP if necessary
	dec	bp
endif

if	flags AND 010h		;; Caller pops stack arguments
	ret
else				;; Callee pops args
 if	cbParams NE 0		;; Put out the correct form of return
	ret	cbParams
 else
	ret
 endif
endif
endm

popcontext	listing
.listmacro
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw.inc ===
UMTYPE = windows

C_DEFINES = $(C_DEFINES) /DIS_32 /DMSBUILD /DDIRECT3D_VERSION=0x800

386_STDCALL = 0

!if "$(DXROOT)" == ""
DXROOT=$(BASEDIR)\private\ntos\w32\ntgdi\direct
!endif

INCLUDES =  \
    ..;                         \
    $(DXROOT)\inc;              \
    $(DXROOT)\dxg\dd\ddraw\inc; \
    $(DXROOT)\dxg\inc;          \
    $(DXROOT)\dxg\misc;         \
    $(DXROOT)\dxg\d3d8\inc;     \
    $(BASEDIR)\public\oak\inc;  \
    $(DDK_INC_PATH);  \
    $(INCLUDES);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\assert4d.cxx ===
#include "precomp.hxx"

#include "util4d.h"
#include "assert4d.h"

#ifdef	__cplusplus
extern "C" {
#endif
/****************************************************************************

	FUNCTION:   _assert

	PURPOSE:    Override system _assert function.

	RETURNS:    void

****************************************************************************/
void __stdcall _assert4d( LPTSTR condition, LPTSTR file, unsigned line)
{
	TCHAR szAssertText[512];

	//Build line, show assertion and exit program
	wsprintf(szAssertText,
			 TEXT("Assertion failed. - Line:%u, File:%s, Condition:%s"),
			 line, file, condition);

	switch (MessageBox(NULL, szAssertText, TEXT("ASSERTION FAILURE"),
					   MB_OKCANCEL | MB_ICONHAND | MB_TASKMODAL))
	{
		case IDCANCEL:
			// Cause a breakpoint so the debugger is activated.
			// I would call DebugBreak() here but the IDE gives a bogus
			// callstack if I do that.
			__asm int 3
			break;
	}
}

#ifdef	__cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\_memalloc.c ===
#include "..\..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\win9x.inc ===
PLAT_DIR           = win9x
ALT_PROJECT_TARGET = win9x

!include ddraw.inc

# DO NOT USE MSVCRT FOR DDRAW DLL
#
# Some legacy apps have their own copy in their own
# directories.
#
# USE_CRTDLL = 1
#


USE_MAPSYM = 1

ASM_DEFINES  = $(ASM_DEFINES) /Zp4
C_DEFINES    = $(C_DEFINES) /DWIN95 /D__DD_OPT_SURFACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\daytona.inc ===
PLAT_DIR           = daytona

!include ddraw.inc

USE_CRTDLL = 1

C_DEFINES = $(C_DEFINES) /DNT /DWINNT /D_NOCSECT_TYPE /D_NO_ENUM

INCLUDES = \
    $(INCLUDES);                          \
    $(BASEDIR)\public\internal\windows\inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\d3d8\util\i386\math.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: math.asm
;
; Fast math routines.
;
; Created: 11/1/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .list

; float __fastcall TableInvSqrt(float value);
;
; void  __fastcall TableVecNormalize(float *resultNormal, floar *normal);
;
;           resultNormal and normal could have the same address
;

;
;
; We're trying to solve:
;
;	1/sqrt(x)
;	
; which in IEEE float is:
;
;	1/sqrt(M * 2^[E-127])
;
;	To simplify, substitute e = [E-127]
;
; We can simplify this by pulling a large portion of the exponent out
; by using only that portion of the exponent divisible by two (so we can
; pull it out of the sqrt term):
;
;	1/sqrt(M * 2^(2*[e div 2]) * 2^[e MOD 2])
;	
; which is:
;	
;	1/ (2^[e div 2] * sqrt(M * 2^[e MOD 2]))
;
; or
;
;	(2^[e div 2])^(-1) * 1/sqrt(M * 2^[e MOD 2])
;
; =
;	2^-[e div 2] * 1/sqrt(M * 2^[e MOD 2])
;
; substitute back for e = [E-127]:
;
;	2^-[(E - 127) div 2] * 1/sqrt(M * 2^[(E - 127) MOD 2])
;
; =
;	2^-[(E div 2) - 63] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; =
;	2^[63 - (E div 2)] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; As a floating-point number, 2^[63 - (E div 2)] is just the exponent value:
;
;	[63 - (E div 2)] + 127
;
; or
;	[(127+63) - (E div 2)]
;
; Remembering to account for the implicit '1' im the mantissa of IEEE floating-
; point numbers, the range of (M * 2^[(E - 1) MOD 2]) is 0.800000 to
; 0.ffffff*2, which is the interval [0.5, 2.0).  We can use the fact that this
; is a relatively small range, and therefore can use a table lookup near the
; actual value.  The table will contain values for the piece-wise approximation
; to the curve 1/sqrt(M * 2^[(E - 1) MOD 2]) using an acceptable interval.
; These values can then be used to approximate the desired inverse square root 
; value.  At this point, all that remains is to apply the correct exponent 
; for the number, which is simply [(127+63) - (E div 2)] from the above 
; equations.
;
; To do the piecewise-linear approximation, we can store a table of values at
; the appropriate intervals, and the deltas between them.  However, this
; will require calculating the difference between the interval value and
; x.  We can do a bit better by using slope-intercept (y = mx + b)m so the
; table will store (m, b).
;
; With a 512-entry table, we will get at least 16 bits of precision.  This
; result was obtined using simulations.

.data

; The following 'C' code generates the table below:

;#define SQRT_TAB_SIZE_LOG2	9       // 512-entry table
;
;#define MANTISSA_SIZE          24
;#define SQRT_TAB_SIZE          (1 << SQRT_TAB_SIZE_LOG2)
;#define SQRT_INC               (1 << (MANTISSA_SIZE - SQRT_TAB_SIZE_LOG2))
;#define CASTFIX(a)             (*((LONG *)&(a)))
;
;void genTable()
;{
;    int i;
;    float x;
;    float xNext;
;    float y;
;    float yNext;
;    float xInterval;
;
;    // We will start our table with the case where the exponent is even.
;
;    CASTFIX(x) = 0x3f000000;
;
;    // We will use the current and next values to generate the piece-wise
;    // data for the curve.  The interval between 'current' and 'next' is
;    // based on the smallest change possible in the floating-point value
;    // that also represents a difference of one table-lookup entry.
;
;    // When we switch to the odd-exponent case (at 1.0), we have to adjust
;    // for the fact that effective interval between successive values
;    /  is doubled.
;
;    CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;    y = (float)1.0 / sqrt((double)x);
;
;    // Calculate 1.0 / (piece-wise approximation interval).
;
;    xInterval = xNext - x;
;
;    xInterval = (float)1.0 / xInterval;
;
;    // Now, generate the table:
;
;    for (i = 0; i < SQRT_TAB_SIZE; i++) {
;        float m;
;        float b;
;
;        // We increment our floating-point values using integer operations
;        // to ensure accuracy:
;
;        CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;
;        // Find next point on curve:
;
;        yNext = (float)1.0 / sqrt((double)xNext);
;
;        // Test for odd-exponent case:
;
;        if (CASTFIX(x) == 0x3f800000)
;            xInterval *= (float)0.5;
;
;        m = (yNext - y) * xInterval;
;        b = y - (m * x);
;
;        printf("\t\tdd\t0%8xh, 0%8xh\n", CASTFIX(m), CASTFIX(b));
;
;        y = yNext;
;        x = xNext;
;    }
;}


invSqrtTab	dd	0bfb47e00h, 04007a1fah
		dd	0bfb37000h, 040075e36h
		dd	0bfb26600h, 040071b31h
		dd	0bfb16000h, 04006d8ech
		dd	0bfb05800h, 0400695e4h
		dd	0bfaf5800h, 0400654a4h
		dd	0bfae5600h, 0400612a2h
		dd	0bfad5800h, 04005d165h
		dd	0bfac5e00h, 0400590f1h
		dd	0bfab6400h, 04005503eh
		dd	0bfaa6e00h, 040051058h
		dd	0bfa97800h, 04004d033h
		dd	0bfa88800h, 040049163h
		dd	0bfa79600h, 0400451d0h
		dd	0bfa6aa00h, 040041396h
		dd	0bfa5be00h, 04003d522h
		dd	0bfa4d400h, 0400396fah
		dd	0bfa3ee00h, 0400359a8h
		dd	0bfa30800h, 040031c1dh
		dd	0bfa22400h, 04002dee2h
		dd	0bfa14400h, 04002a282h
		dd	0bfa06600h, 040026674h
		dd	0bf9f8800h, 040022a30h
		dd	0bf9eae00h, 04001eecah
		dd	0bf9dd400h, 04001b32eh
		dd	0bf9cfc00h, 0400177e8h
		dd	0bf9c2800h, 040013d86h
		dd	0bf9b5400h, 0400102efh
		dd	0bf9a8400h, 04000c93fh
		dd	0bf99b400h, 040008f5bh
		dd	0bf98e600h, 0400055d2h
		dd	0bf981800h, 040001c16h
		dd	0bf975000h, 03fffc7abh
		dd	0bf968600h, 03fff55a6h
		dd	0bf95c000h, 03ffee580h
		dd	0bf94fc00h, 03ffe761ah
		dd	0bf943800h, 03ffe0652h
		dd	0bf937400h, 03ffd9628h
		dd	0bf92b600h, 03ffd290eh
		dd	0bf91f800h, 03ffcbb95h
		dd	0bf913a00h, 03ffc4dbdh
		dd	0bf907e00h, 03ffbe0afh
		dd	0bf8fc600h, 03ffb7597h
		dd	0bf8f0c00h, 03ffb08f8h
		dd	0bf8e5800h, 03ffa9f80h
		dd	0bf8da000h, 03ffa3354h
		dd	0bf8cee00h, 03ff9ca56h
		dd	0bf8c3c00h, 03ff960ffh
		dd	0bf8b8a00h, 03ff8f74fh
		dd	0bf8adc00h, 03ff88fa8h
		dd	0bf8a2e00h, 03ff827aah
		dd	0bf898000h, 03ff7bf55h
		dd	0bf88d600h, 03ff75911h
		dd	0bf882e00h, 03ff6f3adh
		dd	0bf878400h, 03ff68cbfh
		dd	0bf86de00h, 03ff627eah
		dd	0bf863600h, 03ff5c18ah
		dd	0bf859400h, 03ff55e81h
		dd	0bf84f000h, 03ff4f9edh
		dd	0bf845000h, 03ff4977dh
		dd	0bf83ae00h, 03ff43381h
		dd	0bf831000h, 03ff3d1aeh
		dd	0bf827200h, 03ff36f8ch
		dd	0bf81d400h, 03ff30d1bh
		dd	0bf813a00h, 03ff2acdbh
		dd	0bf809e00h, 03ff24b0dh
		dd	0bf800600h, 03ff1eb75h
		dd	0bf7edc00h, 03ff18b91h
		dd	0bf7db000h, 03ff12ca5h
		dd	0bf7c8400h, 03ff0cd6eh
		dd	0bf7b5c00h, 03ff06f32h
		dd	0bf7a3400h, 03ff010ach
		dd	0bf791000h, 03fefb324h
		dd	0bf77f000h, 03fef569ch
		dd	0bf76d000h, 03feef9cch
		dd	0bf75b000h, 03fee9cb4h
		dd	0bf749400h, 03fee40a0h
		dd	0bf737c00h, 03fede592h
		dd	0bf726800h, 03fed8b8ch
		dd	0bf714c00h, 03fed2ea3h
		dd	0bf704000h, 03fecd6b3h
		dd	0bf6f2800h, 03fec7a8dh
		dd	0bf6e1c00h, 03fec2217h
		dd	0bf6d1000h, 03febc95eh
		dd	0bf6c0400h, 03feb7062h
		dd	0bf6afc00h, 03feb1878h
		dd	0bf69f400h, 03feac04ch
		dd	0bf68ec00h, 03fea67deh
		dd	0bf67ec00h, 03fea11deh
		dd	0bf66e800h, 03fe9ba45h
		dd	0bf65e800h, 03fe963c5h
		dd	0bf64ec00h, 03fe90e60h
		dd	0bf63f000h, 03fe8b8bch
		dd	0bf62f400h, 03fe862d9h
		dd	0bf620000h, 03fe80f73h
		dd	0bf610400h, 03fe7b912h
		dd	0bf601000h, 03fe76532h
		dd	0bf5f2000h, 03fe71276h
		dd	0bf5e2c00h, 03fe6be1ch
		dd	0bf5d3c00h, 03fe66ae8h
		dd	0bf5c5000h, 03fe618dch
		dd	0bf5b6000h, 03fe5c530h
		dd	0bf5a7800h, 03fe57414h
		dd	0bf598c00h, 03fe52157h
		dd	0bf58a800h, 03fe4d12fh
		dd	0bf57c000h, 03fe47f65h
		dd	0bf56dc00h, 03fe42ecbh
		dd	0bf55f800h, 03fe3ddf8h
		dd	0bf551800h, 03fe38e58h
		dd	0bf543800h, 03fe33e80h
		dd	0bf535c00h, 03fe2efdeh
		dd	0bf527c00h, 03fe29f96h
		dd	0bf51a000h, 03fe25086h
		dd	0bf50c800h, 03fe202b0h
		dd	0bf4ff000h, 03fe1b4a4h
		dd	0bf4f1c00h, 03fe167d5h
		dd	0bf4e4400h, 03fe1195dh
		dd	0bf4d7000h, 03fe0cc24h
		dd	0bf4c9c00h, 03fe07eb6h
		dd	0bf4bcc00h, 03fe0328ah
		dd	0bf4afc00h, 03fdfe62ah
		dd	0bf4a3000h, 03fdf9b0fh
		dd	0bf496000h, 03fdf4e47h
		dd	0bf489800h, 03fdf0441h
		dd	0bf47c800h, 03fdeb711h
		dd	0bf470400h, 03fde6e24h
		dd	0bf463c00h, 03fde2388h
		dd	0bf457400h, 03fddd8bah
		dd	0bf44b000h, 03fdd8f3ah
		dd	0bf43ec00h, 03fdd4589h
		dd	0bf432800h, 03fdcfba7h
		dd	0bf426800h, 03fdcb317h
		dd	0bf41a800h, 03fdc6a57h
		dd	0bf40e800h, 03fdc2167h
		dd	0bf402c00h, 03fdbd9cdh
		dd	0bf3f6c00h, 03fdb907dh
		dd	0bf3eb400h, 03fdb4a0dh
		dd	0bf3dfc00h, 03fdb036fh
		dd	0bf3d4000h, 03fdabb19h
		dd	0bf3c8800h, 03fda741fh
		dd	0bf3bd400h, 03fda2e83h
		dd	0bf3b2000h, 03fd9e8bah
		dd	0bf3a6800h, 03fd9a136h
		dd	0bf39b400h, 03fd95b13h
		dd	0bf390800h, 03fd917e3h
		dd	0bf385000h, 03fd8cfd5h
		dd	0bf37a400h, 03fd88c4fh
		dd	0bf36f800h, 03fd8489eh
		dd	0bf364400h, 03fd8019ah
		dd	0bf359c00h, 03fd7bf28h
		dd	0bf34f000h, 03fd77af6h
		dd	0bf344400h, 03fd73699h
		dd	0bf339c00h, 03fd6f3a9h
		dd	0bf32f400h, 03fd6b08fh
		dd	0bf324c00h, 03fd66d4bh
		dd	0bf31a800h, 03fd62b78h
		dd	0bf310000h, 03fd5e7e0h
		dd	0bf305c00h, 03fd5a5bbh
		dd	0bf2fb800h, 03fd5636dh
		dd	0bf2f1800h, 03fd52295h
		dd	0bf2e7400h, 03fd4dff5h
		dd	0bf2dd800h, 03fd4a06eh
		dd	0bf2d3400h, 03fd45d7ch
		dd	0bf2c9800h, 03fd41da7h
		dd	0bf2bf800h, 03fd3dc07h
		dd	0bf2b6000h, 03fd39d89h
		dd	0bf2ac000h, 03fd35b99h
		dd	0bf2a2800h, 03fd31ccfh
		dd	0bf298c00h, 03fd2dc37h
		dd	0bf28f400h, 03fd29d21h
		dd	0bf285c00h, 03fd25de5h
		dd	0bf27c400h, 03fd21e83h
		dd	0bf273000h, 03fd1e0a7h
		dd	0bf269800h, 03fd1a0f9h
		dd	0bf260400h, 03fd162d3h
		dd	0bf257000h, 03fd12488h
		dd	0bf24e000h, 03fd0e7c8h
		dd	0bf244c00h, 03fd0a933h
		dd	0bf23bc00h, 03fd06c2bh
		dd	0bf232800h, 03fd02d4ch
		dd	0bf229c00h, 03fcff1b0h
		dd	0bf220c00h, 03fcfb43ch
		dd	0bf218000h, 03fcf785ah
		dd	0bf20f400h, 03fcf3c55h
		dd	0bf206400h, 03fcefe75h
		dd	0bf1fdc00h, 03fcec3e3h
		dd	0bf1f4c00h, 03fce85bbh
		dd	0bf1ec800h, 03fce4ca0h
		dd	0bf1e3c00h, 03fce0fech
		dd	0bf1db400h, 03fcdd4d2h
		dd	0bf1d2c00h, 03fcd9996h
		dd	0bf1ca800h, 03fcd5ff7h
		dd	0bf1c2000h, 03fcd2477h
		dd	0bf1b9800h, 03fcce8d5h
		dd	0bf1b1800h, 03fccb095h
		dd	0bf1a9400h, 03fcc7672h
		dd	0bf1a0c00h, 03fcc3a6ah
		dd	0bf199000h, 03fcc038fh
		dd	0bf190800h, 03fcbc743h
		dd	0bf188c00h, 03fcb902ah
		dd	0bf180800h, 03fcb5562h
		dd	0bf178c00h, 03fcb1e0bh
		dd	0bf170c00h, 03fcae4cbh
		dd	0bf168c00h, 03fcaab6bh
		dd	0bf161000h, 03fca73b7h
		dd	0bf159400h, 03fca3be4h
		dd	0bf151800h, 03fca03f2h
		dd	0bf149800h, 03fc9ca12h
		dd	0bf142400h, 03fc99582h
		dd	0bf13a400h, 03fc95b62h
		dd	0bf133000h, 03fc92698h
		dd	0bf12b400h, 03fc8ee0bh
		dd	0bf123c00h, 03fc8b733h
		dd	0bf11c400h, 03fc8803dh
		dd	0bf114c00h, 03fc84929h
		dd	0bf10d800h, 03fc813ceh
		dd	0bf106400h, 03fc7de56h
		dd	0bf0fec00h, 03fc7a6e8h
		dd	0bf0f7800h, 03fc77136h
		dd	0bf0f0400h, 03fc73b67h
		dd	0bf0e9000h, 03fc7057bh
		dd	0bf0e2000h, 03fc6d14fh
		dd	0bf0dac00h, 03fc69b29h
		dd	0bf0d3c00h, 03fc666c5h
		dd	0bf0ccc00h, 03fc63245h
		dd	0bf0c5800h, 03fc5fbc8h
		dd	0bf0bec00h, 03fc5c8f2h
		dd	0bf0b7c00h, 03fc5941eh
		dd	0bf0b0c00h, 03fc55f2eh
		dd	0bf0aa000h, 03fc52c07h
		dd	0bf0a3000h, 03fc4f6dfh
		dd	0bf09c400h, 03fc4c382h
		dd	0bf095c00h, 03fc491f2h
		dd	0bf08ec00h, 03fc45c76h
		dd	0bf088000h, 03fc428c8h
		dd	0bf081800h, 03fc3f6eah
		dd	0bf07b000h, 03fc3c4f2h
		dd	0bf074000h, 03fc38f06h
		dd	0bf06dc00h, 03fc35ec8h
		dd	0bf067400h, 03fc32c82h
		dd	0bf060800h, 03fc2f832h
		dd	0bf05a400h, 03fc2c7a9h
		dd	0bf053c00h, 03fc29515h
		dd	0bf04d800h, 03fc2645ah
		dd	0bf047000h, 03fc23192h
		dd	0bf040800h, 03fc1feb0h
		dd	0bf03a800h, 03fc1cfa0h
		dd	0bf034000h, 03fc19c8ah
		dd	0bf02dc00h, 03fc16b52h
		dd	0bf027c00h, 03fc13bfah
		dd	0bf021800h, 03fc10a90h
		dd	0bf01b400h, 03fc0d90dh
		dd	0bf015000h, 03fc0a771h
		dd	0bf00f400h, 03fc079b6h
		dd	0bf009000h, 03fc047e8h
		dd	0bf003000h, 03fc01800h
		dd	0beff4000h, 03fbfd000h
		dd	0befdc400h, 03fbf70a1h
		dd	0befc4c00h, 03fbf11e5h
		dd	0befad800h, 03fbeb3ceh
		dd	0bef96400h, 03fbe555ah
		dd	0bef7f800h, 03fbdf893h
		dd	0bef68e00h, 03fbd9bf4h
		dd	0bef52600h, 03fbd3f7eh
		dd	0bef3c200h, 03fbce3b6h
		dd	0bef26200h, 03fbc889eh
		dd	0bef10600h, 03fbc2e38h
		dd	0beefac00h, 03fbbd400h
		dd	0beee5400h, 03fbb79f8h
		dd	0beed0200h, 03fbb212eh
		dd	0beebb200h, 03fbac896h
		dd	0beea6600h, 03fba70b9h
		dd	0bee91a00h, 03fba1889h
		dd	0bee7d400h, 03fb9c1a0h
		dd	0bee69000h, 03fb96aeeh
		dd	0bee54e00h, 03fb91474h
		dd	0bee41200h, 03fb8bf48h
		dd	0bee2d400h, 03fb86942h
		dd	0bee19e00h, 03fb8151ah
		dd	0bee06600h, 03fb7c018h
		dd	0bedf3400h, 03fb76c6ch
		dd	0bede0400h, 03fb71900h
		dd	0bedcd600h, 03fb6c5d4h
		dd	0bedbac00h, 03fb67379h
		dd	0beda8400h, 03fb62161h
		dd	0bed95e00h, 03fb5cf8eh
		dd	0bed83a00h, 03fb57e00h
		dd	0bed71a00h, 03fb52d48h
		dd	0bed5fc00h, 03fb4dcd8h
		dd	0bed4e000h, 03fb48cb0h
		dd	0bed3c800h, 03fb43d64h
		dd	0bed2b000h, 03fb3edd2h
		dd	0bed19c00h, 03fb39f1eh
		dd	0bed08a00h, 03fb350b8h
		dd	0becf7c00h, 03fb30333h
		dd	0bece6c00h, 03fb2b4d7h
		dd	0becd6200h, 03fb267f3h
		dd	0becc5a00h, 03fb21b61h
		dd	0becb5200h, 03fb1ce8dh
		dd	0beca4e00h, 03fb182a2h
		dd	0bec94c00h, 03fb1370ch
		dd	0bec84a00h, 03fb0eb36h
		dd	0bec74e00h, 03fb0a0e4h
		dd	0bec65200h, 03fb05652h
		dd	0bec55800h, 03fb00c1ah
		dd	0bec45e00h, 03fafc1a4h
		dd	0bec36a00h, 03faf78bah
		dd	0bec27600h, 03faf2f93h
		dd	0bec18400h, 03faee6c9h
		dd	0bec09600h, 03fae9ef8h
		dd	0bebfa600h, 03fae5650h
		dd	0bebeba00h, 03fae0ea2h
		dd	0bebdd000h, 03fadc756h
		dd	0bebce800h, 03fad806ch
		dd	0bebc0000h, 03fad3948h
		dd	0bebb1e00h, 03facf3c3h
		dd	0beba3a00h, 03facad67h
		dd	0beb95800h, 03fac6770h
		dd	0beb87a00h, 03fac2280h
		dd	0beb79c00h, 03fabdd57h
		dd	0beb6c000h, 03fab9897h
		dd	0beb5e600h, 03fab5440h
		dd	0beb50e00h, 03fab1054h
		dd	0beb43600h, 03faacc32h
		dd	0beb36200h, 03faa891eh
		dd	0beb28e00h, 03faa45d6h
		dd	0beb1bc00h, 03faa02fah
		dd	0beb0ec00h, 03fa9c08eh
		dd	0beb01e00h, 03fa97e92h
		dd	0beaf5000h, 03fa93c63h
		dd	0beae8600h, 03fa8fb4ah
		dd	0beadba00h, 03fa8b959h
		dd	0beacf400h, 03fa87927h
		dd	0beac2a00h, 03fa83776h
		dd	0beab6600h, 03fa7f788h
		dd	0beaaa200h, 03fa7b76ah
		dd	0bea9e000h, 03fa777c2h
		dd	0bea91e00h, 03fa737e9h
		dd	0bea85e00h, 03fa6f889h
		dd	0bea7a000h, 03fa6b9a2h
		dd	0bea6e400h, 03fa67b36h
		dd	0bea62800h, 03fa63c9ch
		dd	0bea56e00h, 03fa5fe7ch
		dd	0bea4b400h, 03fa5c02fh
		dd	0bea3fe00h, 03fa5830bh
		dd	0bea34600h, 03fa5450dh
		dd	0bea29400h, 03fa508e8h
		dd	0bea1de00h, 03fa4cb3ch
		dd	0bea12c00h, 03fa48ebeh
		dd	0bea07c00h, 03fa452c2h
		dd	0be9fcc00h, 03fa4169ah
		dd	0be9f1e00h, 03fa3daf5h
		dd	0be9e7000h, 03fa39f25h
		dd	0be9dc400h, 03fa363dah
		dd	0be9d1a00h, 03fa32915h
		dd	0be9c7000h, 03fa2ee26h
		dd	0be9bc800h, 03fa2b3beh
		dd	0be9b2000h, 03fa2792ch
		dd	0be9a7a00h, 03fa23f22h
		dd	0be99d600h, 03fa205a4h
		dd	0be993200h, 03fa1cbfch
		dd	0be989000h, 03fa192dfh
		dd	0be97ec00h, 03fa158e5h
		dd	0be974e00h, 03fa120e2h
		dd	0be96ae00h, 03fa0e802h
		dd	0be961000h, 03fa0afb1h
		dd	0be957200h, 03fa07738h
		dd	0be94d800h, 03fa04006h
		dd	0be943a00h, 03fa0073eh
		dd	0be93a200h, 03f9fd078h
		dd	0be930a00h, 03f9f998ch
		dd	0be927000h, 03f9f61c1h
		dd	0be91da00h, 03f9f2b43h
		dd	0be914400h, 03f9ef4a0h
		dd	0be90b000h, 03f9ebe92h
		dd	0be901a00h, 03f9e87a3h
		dd	0be8f8a00h, 03f9e52c3h
		dd	0be8ef600h, 03f9e1c46h
		dd	0be8e6600h, 03f9de71eh
		dd	0be8dd600h, 03f9db1d2h
		dd	0be8d4600h, 03f9d7c62h
		dd	0be8cb800h, 03f9d478ch
		dd	0be8c2c00h, 03f9d1352h
		dd	0be8b9e00h, 03f9cde36h
		dd	0be8b1400h, 03f9caa76h
		dd	0be8a8a00h, 03f9c7694h
		dd	0be8a0000h, 03f9c428eh
		dd	0be897600h, 03f9c0e67h
		dd	0be88f000h, 03f9bdba1h
		dd	0be886800h, 03f9ba7f7h
		dd	0be87e200h, 03f9b74eeh
		dd	0be875e00h, 03f9b4287h
		dd	0be86d800h, 03f9b0f3bh
		dd	0be865600h, 03f9add56h
		dd	0be85d200h, 03f9aaa8ch
		dd	0be855200h, 03f9a792ch
		dd	0be84d000h, 03f9a46e6h
		dd	0be844e00h, 03f9a1480h
		dd	0be83d000h, 03f99e387h
		dd	0be835200h, 03f99b26eh
		dd	0be82d400h, 03f998136h
		dd	0be825600h, 03f994fdfh
		dd	0be81da00h, 03f991f31h
		dd	0be816000h, 03f98ef2eh
		dd	0be80e400h, 03f98be42h
		dd	0be806a00h, 03f988e01h
		dd	0be7fe000h, 03f985da2h
		dd	0be7ef400h, 03f982ebch
		dd	0be7e0000h, 03f97fe20h
		dd	0be7d1400h, 03f97cefeh
		dd	0be7c2400h, 03f979ef2h
		dd	0be7b3c00h, 03f977063h
		dd	0be7a5400h, 03f9741b7h
		dd	0be796800h, 03f971220h
		dd	0be788400h, 03f96e408h
		dd	0be779c00h, 03f96b506h
		dd	0be76b800h, 03f9686b6h
		dd	0be75d800h, 03f96591ah
		dd	0be74f400h, 03f962a90h
		dd	0be741400h, 03f95fcbch
		dd	0be733400h, 03f95cecch
		dd	0be725800h, 03f95a193h
		dd	0be717c00h, 03f95743eh
		dd	0be70a400h, 03f9547a1h
		dd	0be6fc800h, 03f951a15h
		dd	0be6ef000h, 03f94ed42h
		dd	0be6e1800h, 03f94c054h
		dd	0be6d4000h, 03f94934bh
		dd	0be6c7000h, 03f9467d3h
		dd	0be6b9c00h, 03f943b6ah
		dd	0be6ac800h, 03f940ee8h
		dd	0be69f800h, 03f93e322h
		dd	0be692800h, 03f93b742h
		dd	0be685c00h, 03f938c20h
		dd	0be678c00h, 03f93600ch
		dd	0be66c000h, 03f9334b8h
		dd	0be65f800h, 03f930a24h
		dd	0be652c00h, 03f92de9ch
		dd	0be646400h, 03f92b3d6h
		dd	0be639c00h, 03f9288f7h
		dd	0be62d400h, 03f925dffh
		dd	0be621000h, 03f9233cah
		dd	0be615000h, 03f920a5ah
		dd	0be608800h, 03f91df18h
		dd	0be5fc800h, 03f91b578h
		dd	0be5f0800h, 03f918bc0h
		dd	0be5e4800h, 03f9161f0h
		dd	0be5d8800h, 03f913808h
		dd	0be5ccc00h, 03f910ee8h
		dd	0be5c0c00h, 03f90e4d0h
		dd	0be5b5400h, 03f90bc62h
		dd	0be5a9800h, 03f9092fbh
		dd	0be59e000h, 03f906a5fh
		dd	0be592800h, 03f9041ach
		dd	0be587000h, 03f9018e2h
		dd	0be57b800h, 03f8ff001h
		dd	0be570400h, 03f8fc7edh
		dd	0be565000h, 03f8f9fc2h
		dd	0be559c00h, 03f8f7782h
		dd	0be54e800h, 03f8f4f2ah
		dd	0be543800h, 03f8f27a2h
		dd	0be538800h, 03f8f0004h
		dd	0be52d800h, 03f8ed850h
		dd	0be522c00h, 03f8eb16eh
		dd	0be517c00h, 03f8e898eh
		dd	0be50d000h, 03f8e6280h
		dd	0be502400h, 03f8e3b5dh
		dd	0be4f7800h, 03f8e1424h
		dd	0be4ecc00h, 03f8decd6h
		dd	0be4e2800h, 03f8dc748h
		dd	0be4d7c00h, 03f8d9fcfh
		dd	0be4cd800h, 03f8d7a18h
		dd	0be4c3000h, 03f8d5360h
		dd	0be4b8800h, 03f8d2c92h
		dd	0be4ae800h, 03f8d078ah
		dd	0be4a4000h, 03f8ce094h
		dd	0be49a000h, 03f8cbb64h
		dd	0be48fc00h, 03f8c9531h
		dd	0be485c00h, 03f8c6fd9h
		dd	0be47bc00h, 03f8c4a6dh
		dd	0be471c00h, 03f8c24edh
		dd	0be467c00h, 03f8bff59h
		dd	0be45e000h, 03f8bdaa2h
		dd	0be454000h, 03f8bb4e6h
		dd	0be44a800h, 03f8b90fah
		dd	0be440800h, 03f8b6b16h
		dd	0be437000h, 03f8b4704h
		dd	0be42d800h, 03f8b22dfh
		dd	0be423c00h, 03f8afdb3h
		dd	0be41a400h, 03f8ad968h
		dd	0be410c00h, 03f8ab50ah
		dd	0be407800h, 03f8a918eh
		dd	0be3fe000h, 03f8a6d0ah
		dd	0be3f4c00h, 03f8a496ah
		dd	0be3eb400h, 03f8a24c0h
		dd	0be3e2400h, 03f8a01f2h
		dd	0be3d9000h, 03f89de1ah
		dd	0be3d0000h, 03f89bb28h
		dd	0be3c6c00h, 03f89972bh
		dd	0be3bd800h, 03f89731ch
		dd	0be3b4c00h, 03f8950eeh
		dd	0be3abc00h, 03f892db4h
		dd	0be3a3000h, 03f890b62h
		dd	0be399c00h, 03f88e709h
		dd	0be391400h, 03f88c591h
		dd	0be388400h, 03f88a20fh
		dd	0be37fc00h, 03f888075h
		dd	0be377000h, 03f885dcch
		dd	0be36e400h, 03f883b12h
		dd	0be365800h, 03f881847h
		dd	0be35d400h, 03f87f768h
		dd	0be354800h, 03f87d47ah

a1  dd 0.47
a2  dd 1.47

.code

SQRT_TAB_LOG2       equ     9           ;; log2 of the lookup-table
MANTISSA_SIZE       equ     24          ;; number if mantissa bits in fp value
                                        ;; number of represented mantissa bits
                                        ;; (one less than total due to hidden
                                        ;; leading one).
MANTISSA_BITS       equ     (MANTISSA_SIZE - 1)
ELEMENT_SIZE_LOG2   equ     3           ;; log2 of each table entry (8 bytes)
                                        ;; shift required to get bits in value
                                        ;; in the correct place to use as an
                                        ;; index for the table lookup
EXPONENT_SHIFT      equ     (MANTISSA_BITS - (SQRT_TAB_LOG2 - 1)\
                             - ELEMENT_SIZE_LOG2)
                                        ;; mask value for clamping to [.5..2)
CLAMP_MASK          equ     ((1 SHL (MANTISSA_BITS+1)) - 1)
                                        ;; mask for sign/exponent bits
MANTISSA_MASK        equ     ((1 SHL MANTISSA_BITS) - 1)
                                        ;; mask for sign/exponent bits
EXPONENT_MASK       equ     (-1 AND (NOT MANTISSA_MASK))
                                        ;; mask for table lookup
TABLE_MASK          equ     ((1 SHL (SQRT_TAB_LOG2 + ELEMENT_SIZE_LOG2)) - 1) \
                            AND (NOT((1 SHL ELEMENT_SIZE_LOG2) - 1))
                                        ;; bias used to represent clamped value
EXPONENT_BIAS_EVEN  equ     3f000000h
                                        ;; bias value used for final exponent
                                        ;; computation
LARGE_EXPONENT_BIAS equ     (((127 + 127/2) SHL (MANTISSA_BITS+1)) OR CLAMP_MASK)


__FLOAT_ONE equ 03F800000h

;----------------------------------------------------------------------
;
; float __fastcall JBInvSqrt(float x);
;
; Input:
;   esp + 4 = x
; Output:
;   result is on the floating point stack
; Algorithm:
;   The floating point trick, described in IEEE Computer Graphics and 
;   Applications v.17 number 4 in Jim Blinn's article, is used.
;
;   ONE_AS_INTEGER = 0x3F800000;
;   int   tmp = (ONE_AS_INTEGER << 1 + ONE_AS_INTEGER - *(long*)&x) >> 1;   
;   float y = *(float*)&tmp;                                             
;   result = y*(1.47f - 0.47f*x*y*y);
;
@JBInvSqrt@4 PROC NEAR
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    sub     eax, [esp+4]
    sub     esp, 4                      ; place for temporary variable "y"
    sar     eax, 1
    mov     [esp], eax                  ; y
    fld     a1
    fmul    DWORD PTR [esp+8]           ; x*0.47
    fld     DWORD PTR [esp]
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y 1.47-x*0.47*y*y
    fmulp   st(1), st(0)                ; result
    add     esp, 4
    ret     4
@JBInvSqrt@4 endp
;----------------------------------------------------------------------
; void __fastcall JBInvSqrt(float *result, float *nomal);
;
; Input:
;   ecx = address of the result
;   edx = address of the normal
;
;
@JBVecNormalize@8 PROC NEAR
    fld     DWORD PTR [edx]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 4]
    fmul    st(0), st(0)
    fld     DWORD PTR [edx + 8]
    fmul    st(0), st(0)                ; z y x
    fxch    st(2)			            ; x y z
    faddp   st(1), st                   ; x + y, z
    faddp   st(1), st                   ; len
    sub     esp, 4                      ; Place for temporary variable "y"
    mov     eax, 07F000000h+03F800000h  ; (ONE_AS_INTEGER<<1) + ONE_AS_INTEGER
    fst     DWORD PTR [esp]             ; Vector length
    sub     eax, [esp]
    sar     eax, 1
    mov     [esp], eax                  ; y
    fmul    a1                          ; x*0.47
    fld     DWORD PTR [esp]             ; y x*0.47
    fld     st(0)                       ; y y x*0.47
    fmul    st(0), st(1)                ; y*y y x*0.47
    fld     a2                          ; 1.47 y*y y x*0.47
    fxch    st(3)                       ; x*0.47 y*y y 1.47
    fmulp   st(1), st(0)                ; x*0.47*y*y y 1.47
    fsubp   st(2), st(0)                ; y aaa       
    fmulp   st(1), st(0)                ; 1/sqrt(len)
    fld     DWORD PTR [edx]             ; Start normalizing the normal
    fmul    st, st(1)
    fld     DWORD PTR [edx + 4]
    fmul    st, st(2)
    fld     DWORD PTR [edx + 8]
    fmulp   st(3), st(0)                ; y x z
    fxch    st(1)
    add     esp, 4
    fstp    DWORD PTR [ecx]
    fstp    DWORD PTR [ecx + 4]
    fstp    DWORD PTR [ecx + 8]
	ret	
@JBVecNormalize@8 endp
;----------------------------------------------------------------------
; Input:
;     [esp+4] = x
;
;
x 	    equ DWORD PTR [esp + 12]
num 	equ DWORD PTR [esp]

@TableInvSqrt@4 PROC NEAR
    mov     eax, [esp + 4]          ; x
    push    ecx
    mov     ecx, eax
	sub	    esp, 4                  ; Place for num
    shr     ecx, EXPONENT_SHIFT     ;; ecx is table index (8 frac. bits)
    and     eax, CLAMP_MASK		    ;; clamp number to [0.5, 2.0]
    and     ecx, TABLE_MASK		    ;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+ecx]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, x                  ;; divide exponent by 2
    fadd    [invSqrtTab+ecx+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent
    add     esp, 4
    pop     ecx
	ret     4
@TableInvSqrt@4 endp
;----------------------------------------------------------------------
;
len 	equ DWORD PTR -4[ebp]
num 	equ DWORD PTR -8[ebp]

@TableVecNormalize@8 PROC NEAR
	push	ebp
	mov	    ebp, esp
	sub	    esp, 8
	fld	    DWORD PTR [edx]
	fmul	DWORD PTR [edx]		;; x
	fld	    DWORD PTR [edx+4]
	fmul	DWORD PTR [edx+4]	;; y x
	fld	    DWORD PTR [edx+8]
	fmul	DWORD PTR [edx+8]	;; z y x
	fxch	ST(2)			;; x y z
	faddp	ST(1), ST		;; xy z
	faddp	ST(1), ST		;; xyz
	fstp	len
	mov	eax, len
	test	eax, eax
	jne	notZeroLen

	mov	[ecx], eax
	mov	[ecx+4], eax
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notZeroLen:

	cmp	eax, __FLOAT_ONE
	jne	notOneLen
	cmp	ecx, edx
	je	normExit
	mov	eax, [edx]
	mov	[ecx], eax
	mov	eax, [edx+4]
	mov	[ecx+4], eax
	mov	eax, [edx+8]
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notOneLen:

	;; eax already has length

	push	edi
    mov     edi, eax
    shr     edi, EXPONENT_SHIFT     ;; edi is table index (8 frac. bits)
    and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
    and     edi, TABLE_MASK		;; (8 bytes)/(table entry)
    or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
    mov     num, eax
    fld     num
    fmul    [invSqrtTab+edi]        ;; find mx
    mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
    sub     eax, len                ;; divide exponent by 2
    fadd    [invSqrtTab+edi+4]      ;; get mx + b
    shr     eax, 1
    and     eax, EXPONENT_MASK     	;; mask exponent
    mov     num, eax
    fmul    num                     ;; now adjust for exponent

	fld	    DWORD PTR [edx]		;; 1/sqrt(len) on stack
	fmul	ST, ST(1)
	fld	    DWORD PTR [edx+4]
	fmul	ST, ST(2)
	fld	    DWORD PTR [edx+8]
	fmul	ST, ST(3)		;; z y x len
	fxch	ST(2)			;; x y z len
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+8]
	fstp	ST(0)			;; pop len
	
        pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0

normExit:

	mov	esp, ebp
	pop	ebp
	ret     0

@TableVecNormalize@8 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\assert4d.h ===
/**************************************************************************
	Prototype COM animation system
	Debug assertion support

	1/20/94  JonBl  Created

	Copyright (c)1994 Microsoft Corporation. All Rights Reserved.
 **************************************************************************/

#ifndef _ASSERT4D_H_
#define _ASSERT4D_H_

#include "util4d.h"

#undef  assert

// debug are assertion conditions that will stay in final Release.
// If false assert Opens a fatal error message Box and Stops program

#ifdef _DEBUG

	#ifdef __cplusplus
		extern "C" {
	#endif 
	void __stdcall _assert4d(LPTSTR, LPTSTR, unsigned);
	#ifdef __cplusplus
		}
	#endif 
	
	#define assert(exp) ( (exp) ? (void) 0 : _assert4d(TEXT(#exp), TEXT(__FILE__), __LINE__) )
	#define debug(condition) assert(condition)
#else
	#define assert(exp) ((void)0)
	#define debug(condition) condition
#endif 

#endif // _ASSERT4D_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\bitblt.cxx ===
///////////////////////////////////////////////////////////////////////
//
//  BitBlt.CXX - Contains the BitBlt Library functions
//
//	Copyright (c) 1994 Microsoft Corporation
//
//	Notes:
//		Conditional Compiliation Definitions:
//				DESKTOP = Penguin platform emulation on the Desktop 
//						  platform (32 bit).
//				PENGUIN = Penguin H/W platform support.
//				PULSAR  = Pulsar platform support.
//              DDRAW   = DirectDraw support
//
//	History:
//		10/18/94 - Scott Leatham Created it w/8BPP support only
//		10/26/94 - Olivier Garamfalvi Rewrote blitting code
//					                  Added SRCINVERT ROP support
//		10/30/94 - Olivier Garamfalvi Added 24 to 24 bit blitting
//		05/08/95 - Myron Thomas Added 8+Alpha to 24 bit blitting
//								Added 24+Alpha to 24 bit blitting
//		07/19/95 - Myron Thomas Ripped out SRCINVERT ROP support
//		09/05/95 - Myron Thomas Added 24P to 8 bit blitting
//              01/15/96 - Michael McDaniel changed conditional compilation
//                                      for DirectDraw
//              04/16/96 - Michael McDaniel removed FillRect's test for
//                             CLR_INVALID so Z-Buffer filling will work.
//
//
///////////////////////////////////////////////////////////////////////

#include "precomp.hxx"

#include "bltos.h"
#include "blt0101.hxx"
#include "blt0108.hxx"
#include "blt0124.hxx"
#include "blt0801.hxx"
#include "blt0808.hxx"
#include "blt0824.hxx"
#include "blt0824p.hxx"
#include "blt08a24.hxx"
#include "blt8a24p.hxx"
#include "blt1616.hxx"
#include "blt1624.hxx"
#include "blt1624p.hxx"
#include "blt2401.hxx"
#include "blt24p01.hxx"
#include "blt24p08.hxx"
#include "blt2408.hxx"
#include "blt2424.hxx"
#include "blt2424p.hxx"
#include "blt24a24.hxx"
#include "bt24a24p.hxx"
#include "bt24p24p.hxx"

#if 0
#if defined( WIN95 ) || defined(WINNT)
#define DDRAW
#endif // WIN95

#ifdef DDRAW
#if defined ( WIN95 ) && !defined( NT_BUILD_ENVIRONMENT )
    #include "..\ddraw\ddrawp.h"
#else
    /*
     * This is parsed if NT build or win95 build under NT environment
     */
    #include "..\..\ddraw\ddrawp.h"
#endif
#ifdef __cplusplus
extern "C" {
#endif // c++
#include "dpf.h"
#ifdef __cplusplus
}
#endif // c++
#endif // DDRAW
#endif

///////////////////////////////////////////////////////////////////////
//
//	Local Declarations
//
///////////////////////////////////////////////////////////////////////
void FlipRectHorizontal (RECT *rc)
{
    int			temp;

    temp = rc->right;
    rc->right = rc->left;
    rc->left = temp;
}


void FlipRectVertical (RECT *rc)
{
    int			temp;

    temp = rc->bottom;
    rc->bottom = rc->top;
    rc->top = temp;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt01to01 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt01to01(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iBytesPerSrcScanLine,
	iSrcBitOffset,
	iNumDstRows,
	iNumDstCols,
	iBytesPerDstScanLine,
	iDstBitOffset,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine;

    // alpha blending not currently supported in the 1 to 1 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iBytesPerSrcScanLine
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left / 8);
    iSrcBitOffset = prcSrc->left % 8;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iBytesPerDstScanLine
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left / 8);
    iDstBitOffset = prcDst->left % 8;

    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
#if 0	// OGaramfa - bug workaround for now, Hcopy versions seem to
		//            have a problem with the last few pixels of each
		//            scanline
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt01to01_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  pbDstScanLine,iDstBitOffset,iBytesPerDstScanLine,
							  iNumDstCols,iNumDstRows);
		} else {
		    Blt01to01_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							    iNumSrcRows,pbDstScanLine,iDstBitOffset,
							    iBytesPerDstScanLine * iVertMirror,
							    iNumDstCols,iNumDstRows);
		}
#else
		Blt01to01_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
						  iNumSrcCols,iNumSrcRows,
						  pbDstScanLine,iDstBitOffset,iBytesPerDstScanLine * iVertMirror,
						  iNumDstCols,iNumDstRows,iHorizMirror);
#endif
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt01to01_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
						  iNumSrcCols,iNumSrcRows,
						  pbDstScanLine,iDstBitOffset,iBytesPerDstScanLine * iVertMirror,
						  iNumDstCols,iNumDstRows,iHorizMirror);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } else {

	BYTE bTransparentIndex = (BYTE)crTransparent;

	// check what ROP we'll be performing
	if (dwRop == SRCCOPY) {
	    Blt01to01_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
					    iNumSrcCols,iNumSrcRows,
					    pbDstScanLine,iDstBitOffset,iBytesPerDstScanLine * iVertMirror,
					    iNumDstCols,iNumDstRows,iHorizMirror,
					    bTransparentIndex);
	} else sc |= E_UNEXPECTED;		// !!!! we need better error codes

    }

    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt01to08 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt01to08(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iBytesPerSrcScanLine,
	iSrcBitOffset,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine,
	bOnColorIndex,
	bOffColorIndex;

    // alpha blending not currently supported in the 1 to 8 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // get background and foreground palette indices out of src bitmap's header
    // !!!! this is a total hack and must be fixed!
    bOffColorIndex = BlitLib_PalIndexFromRGB(
	*((COLORREF*)(pDibInfoSrc->bmiColors)),
	(COLORREF*) pDibInfoDst->bmiColors,256);
    bOnColorIndex  = BlitLib_PalIndexFromRGB(
	*((COLORREF*) (pDibInfoSrc->bmiColors) + 1),
	(COLORREF*) pDibInfoDst->bmiColors,256);

    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iBytesPerSrcScanLine
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left / 8);
    iSrcBitOffset = prcSrc->left % 8;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iDstScanLength =
							 DibWidthBytes(pDibInfoDst)) + prcDst->left;
		
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt01to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  pbDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows,
							  bOffColorIndex,bOnColorIndex);
		} else {
		    Blt01to08_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							    iNumSrcRows,pbDstScanLine,
							    iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,
							    bOffColorIndex,bOnColorIndex);
		}
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt01to08_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
						  iNumSrcCols,iNumSrcRows,
						  pbDstScanLine,iDstScanLength * iVertMirror,
						  iNumDstCols,iNumDstRows,iHorizMirror,
						  bOffColorIndex,bOnColorIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } else {
	BYTE bTransparentIndex = (BYTE)crTransparent;

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt01to08_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
					      iNumSrcRows,pbDstScanLine,
					      iDstScanLength * iVertMirror,
					      iNumDstCols,iNumDstRows,
					      bTransparentIndex,
					      bOffColorIndex,bOnColorIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt01to08_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
						iNumSrcCols,iNumSrcRows,
						pbDstScanLine,iDstScanLength * iVertMirror,
						iNumDstCols,iNumDstRows,iHorizMirror,
						bTransparentIndex,
						bOffColorIndex,bOnColorIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt01to24 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt01to24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE		sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iBytesPerSrcScanLine,
	iSrcBitOffset,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    DWORD		*pdDstScanLine;
    COLORREF	crOnColor,
	crOffColor;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // get background and foreground colors out of src bitmap's header
    crOffColor = *((COLORREF*) &(pDibInfoSrc->bmiColors[0]));
    crOnColor  = *((COLORREF*) &(pDibInfoSrc->bmiColors[1]));

    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iBytesPerSrcScanLine
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left / 8);
    iSrcBitOffset = prcSrc->left % 8;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength =
							  DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;
	
    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {
		
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {

	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
	
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt01to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,
								      crOffColor,crOnColor);
		    } else {
			Blt01to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
									iNumSrcRows,pdDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows,
									crOffColor,crOnColor);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,
							      crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  bTransparentIndex,
							  crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    bTransparentIndex,
							    crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}

    } else {	// doing alpha blending

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {

	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha,crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha,crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							iNumSrcRows,pdDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							bTransparentIndex,
							arAlpha,crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt01to24_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcBitOffset,iBytesPerSrcScanLine,
							  iNumSrcCols,iNumSrcRows,
							  pdDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  bTransparentIndex,
							  arAlpha,crOffColor,crOnColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to01 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to01(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iBytesPerDstScanLine,
	iHorizMirror = 1,
	iVertMirror = 1,
	iDstBitOffset;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine,
	bFillVal;

    // alpha blending not currently supported in the 8 to 1 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // the only ROPs supported are BLACKNESS and WHITENESS
    if (dwRop == BLACKNESS) {
	bFillVal = 0;
    } else if (dwRop == WHITENESS) {
	bFillVal = 0xFF;
    } else {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength =
							 DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iBytesPerDstScanLine
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left / 8);
    iDstBitOffset = prcDst->left % 8;
		
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// no transparency plus a constant ROP equals a rectangle fill!
	// first we have to normalize destination rectangle orientation - 
	// FillRect01() expects it
	if (BLITLIB_RECTWIDTH(prcDst) < 0) {
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}
	if (BLITLIB_RECTHEIGHT(prcDst) < 0) {
	    prcDst->top--;
	    prcDst->bottom--;
	    FlipRectVertical(prcDst);
	}
	sc |= BlitLib_FillRect01(pDibInfoDst,pDibBitsDst,prcDst->left,prcDst->top,
				 iNumDstCols,iNumDstRows,bFillVal);

    } else {
	BYTE bTransparentIndex = (BYTE)crTransparent;

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	    Blt08to01_Trans_Hcopy_ConstRop(pbSrcScanLine,iSrcScanLength,iNumSrcRows,
					   pbDstScanLine,iDstBitOffset,
					   iBytesPerDstScanLine * iVertMirror,
					   iNumDstCols,iNumDstRows,bTransparentIndex,
					   bFillVal);
	} else {
	    Blt08to01_Trans_NoHcopy_ConstRop(pbSrcScanLine,iSrcScanLength,iNumSrcCols,
					     iNumSrcRows,pbDstScanLine,iDstBitOffset,
					     iBytesPerDstScanLine * iVertMirror,
					     iNumDstCols,iNumDstRows,iHorizMirror,
					     bTransparentIndex,bFillVal);
	}
    }

    return sc;
}
#endif // DDRAW

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to08 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to08(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine;

    // alpha blending not currently supported in the 8 to 8 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }


    // If the bitmaps overlap, we need to use overlapping code
    if(BlitLib_Detect_Intersection(pDibBitsDst, prcDst, pDibBitsSrc, prcSrc))
	return BlitLib_BitBlt08to08_Intersect(pDibInfoDst, pDibBitsDst,	prcDst,
					      pDibInfoSrc, pDibBitsSrc, prcSrc, crTransparent, dwRop);


    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
							   = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
							   = DibWidthBytes(pDibInfoDst)) + prcDst->left;

    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
							  pbDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows);
		} else {
		    Blt08to08_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
							    iNumSrcRows,pbDstScanLine,
							    iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows);
		}
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08to08_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
						  iNumSrcCols,iNumSrcRows,
						  pbDstScanLine,iDstScanLength * iVertMirror,
						  iNumDstCols,iNumDstRows,iHorizMirror);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } else {
	// myronth -- changed for DDraw Transparent colors (always a palette index)
	BYTE bTransparentIndex = (BYTE)crTransparent;

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08to08_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
					      iNumSrcRows,pbDstScanLine,
					      iDstScanLength * iVertMirror,
					      iNumDstCols,iNumDstRows,
					      bTransparentIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08to08_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
						iNumSrcCols,iNumSrcRows,
						pbDstScanLine,iDstScanLength * iVertMirror,
						iNumDstCols,iNumDstRows,iHorizMirror,
						bTransparentIndex);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to08_Intersect - 
//		BitBlit from source bitmap to destination bitmap (and these
//		bitmaps overlap each other) with optional transparency and/or
//		alpha blending using the specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to08_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
				     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
				     COLORREF crTransparent, DWORD dwRop)
{
    SCODE       sc = NOERROR;
    int         iNumSrcRows,
    iNumSrcCols,
    iSrcScanLength,
    iNumDstRows,
    iNumDstCols,
    iDstScanLength,
    iHorizMirror = 1,
    iVertMirror  = 1;
    BYTE	*pbSrcScanLine,
    *pbDstScanLine,
    *pbTempScanLine,
    bTransparentIndex;
    PDIBBITS	pDibBitsTemp;


    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // We aren't currently support any ROP's besides SRCCOPY
    if(dwRop != SRCCOPY)
	return E_UNEXPECTED;


    //
    // Here are all the stretching and mirroring blits for overlapping rects
    //
	
    // REVIEW!!! -- The following code could be optimized for the caching
    // cases.  Currently, it allocates a second bitmap that is the same
    // size as the original destination, and then uses the original blit
    // rectangle to do the caching.  To save space, this blit should 
    // eventually be changed to only allocate the size of the overlapped
    // rectangle, and the blit rects should be adjusted accordingly.

    // Check if we are stretching (horiz or vert), or if we are mirroring --
    // In all of these cases, we must create a cache bitmap and double blit
    if((iNumDstCols != iNumSrcCols) || (iNumDstRows != iNumSrcRows) ||
       (iHorizMirror != 1) || (iVertMirror != 1))
    {
		
	// Allocate memory for the cache bitmap -- We will blit into this
	// temporary bitmap and then re-blit back to the original source
	pDibBitsTemp = (PDIBBITS)osMemAlloc(DibSizeImage((LPBITMAPINFOHEADER)pDibInfoDst));

        if (pDibBitsTemp == NULL)
            return E_UNEXPECTED;

	// compute pointers to the starting rows in the src and temp bitmaps
	pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
							       = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	pbTempScanLine = (BYTE*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	// check if we can do a straight copy from src row to dst row
	if((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)){

	    // check if we can do a straight copy vertically, 
	    // or if we have to stretch, shrink, or mirror
	    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
						      pbTempScanLine,iDstScanLength,
						      iNumDstCols,iNumDstRows);
	    } else {
		Blt08to08_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
							iNumSrcRows,pbTempScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows);
	    }
	}
	else
	{

	    Blt08to08_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
					      iNumSrcCols,iNumSrcRows,
					      pbTempScanLine,iDstScanLength * iVertMirror,
					      iNumDstCols,iNumDstRows,iHorizMirror);
		
        }
		
	// Recalculate the scan line pointers for the second blit

	if(BLITLIB_RECTWIDTH(prcDst) < 0){
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}

	if(BLITLIB_RECTHEIGHT(prcDst) < 0){
	    prcDst->top++;
	    prcDst->bottom++;
	    FlipRectVertical(prcDst);
	}

	// compute pointers to the starting rows in the temp and dest bitmaps
	pbTempScanLine = (BYTE*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst)) + prcDst->left;
	pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
							       = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	// Now blit from the temporary bitmap back to the original source,
	// checking for transparency if necessary
	if(crTransparent == CLR_INVALID){
	    Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbTempScanLine,iDstScanLength,
						  pbDstScanLine,iDstScanLength,
						  iNumDstCols,iNumDstRows);
	}
	else{
	    bTransparentIndex = (BYTE)crTransparent;
	    Blt08to08_Trans_Hcopy_SRCCOPY(pbTempScanLine,iDstScanLength,
					  iNumDstRows,pbDstScanLine,
					  iDstScanLength, iNumDstCols,
					  iNumDstRows, bTransparentIndex);
        }
		
	// Free the memory from the temporary bitmap
	if(pDibBitsTemp)
	    osMemFree(pDibBitsTemp);		
		
	return sc;
    }
 	
    //
    // Here are all the non-stretching and non-mirroring blits for overlapping rects
    //

    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// Simplest case, they are the same rectangles
	if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	   (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
	    return sc;

	// Next case, the destination rectangle is vertically greater in
	// magnitude than the source rectangle
	else if(prcDst->top > prcSrc->top){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to decrement the bottom rect edge since we are
	    // going from bottom to top
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									  = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									  = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	    //  Call the appropriate blit
	    Blt08to08_LeftToRight_BottomToTop_SRCCOPY(pbSrcScanLine,
						      iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols,
						      iNumDstRows);
	}

	// Next case, the destination rectangle is horizontally less than
	// or equal in magnitude to the source rectangle
	else if(prcDst->left <= prcSrc->left){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	    //  Call the appropriate blit
	    Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
						  pbDstScanLine,iDstScanLength,
						  iNumDstCols,iNumDstRows);
	}

	// Last case, the destination rectangle is horizontally greater
	// in magnitude than the source rectangle
	else{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to decrement the right rect edge since we are
	    // going from right to left
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc)) + (prcSrc->right - 1);
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)) + (prcDst->right - 1);

	    //  Call the appropriate blit
	    Blt08to08_RightToLeft_TopToBottom_SRCCOPY(pbSrcScanLine,
						      iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols,
						      iNumDstRows);
	}
    }
    else{
	bTransparentIndex = (BYTE)crTransparent;
		
	// Simplest case, they are the same rectangles
	if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	   (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
	    return sc;

	// Next case, the destination rectangle is vertically greater in
	// magnitude than the source rectangle
	else if(prcDst->top > prcSrc->top){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to decrement the bottom rect edge since we are
	    // going from bottom to top
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									  = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									  = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	    //  Call the appropriate blit
	    Blt08to08_LeftToRight_BottomToTop_Trans_SRCCOPY(pbSrcScanLine,
							    iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
							    iNumDstRows, bTransparentIndex);
	}

	// Next case, the destination rectangle is horizontally less than
	// or equal in magnitude to the source rectangle
	else if(prcDst->left <= prcSrc->left){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)) + prcDst->left;

	    //  Call the appropriate blit
	    Blt08to08_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
					  iNumSrcRows, pbDstScanLine,
					  iDstScanLength, iNumDstCols,
					  iNumDstRows, bTransparentIndex);
	}

	// Last case, the destination rectangle is horizontally greater
	// in magnitude than the source rectangle
	else{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to decrement the right rect edge since we are
	    // going from right to left
	    pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc)) + (prcSrc->right - 1);
	    pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)) + (prcDst->right - 1);

	    //  Call the appropriate blit
	    Blt08to08_RightToLeft_TopToBottom_Trans_SRCCOPY(pbSrcScanLine,
							    iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
							    iNumDstRows, bTransparentIndex);
	}
    }

    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    DWORD		*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength =
							 DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength =
							  DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt08to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    } else {
			Blt08to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									iNumSrcRows,pdDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {	// we have to stretch or shrink horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {		// we need to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							iNumSrcRows,pdDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pdDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08to24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08to24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine,
	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE *) pDibBitsSrc + prcSrc->top * (iSrcScanLength =
							  DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength =
							  DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt08to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    } else {
			Blt08to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {	// we have to stretch or shrink horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {		// we need to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							 iNumSrcRows,pdDstScanLine,
							 iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,
							 bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08to24P_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pdDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror,
							   bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08Ato24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08Ato24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    DWORD		*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt08Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    } else {
			Blt08Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {	// we have to stretch or shrink horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired
// REVIEW!!!! -- This is a temporary hack based on the following premises:
//
//	1) In theory, per-pixel alpha should be overridable by per-surface alpha
//	2) In practice, Burma does not allow per-surface alpha to override a per-
//		pixel bitmap.
//	3) The following code for all the per-surface alpha blending bliting is
//		temporarily commented out so that we can verify DirectDraw NEVER EVER
//		calls BlitLib with both a per-pixel bitmap and a per-surface alpha
//		value other than ALPHA_INVALID.
//
//		Therefore, we are currently return E_UNEXPECTED if this condition occurs.
//
//		Although the following commented code is contrary to the Burma hardware,
//		we are not going to change BlitLib to Burma's implementation because we
//		believe it's implementation is a bug.
//
	return E_UNEXPECTED;

/*		// if alpha value is zero, we do no work since the source bitmap 
		// contributes nothing to the destination bitmap
		if (!(arAlpha & ALPHA_MASK)) {
		return sc;
		}			

	 	// check to see if we need to worry about transparency
		if (crTransparent == CLR_INVALID) {
			
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
		} else {		// we need to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		}
		} else { 
		BYTE bTransparentIndex = (BYTE)crTransparent;
	
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		} else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		}
		}*/
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08Ato24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08Ato24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    BYTE		*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + prcSrc->left;
    pdDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iDstScanLength
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt08Ato24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
									pdDstScanLine,iDstScanLength,
									iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    } else {
			Blt08Ato24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									  iNumSrcRows,pdDstScanLine,
									  iDstScanLength * iVertMirror,
									  iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoSrc->bmiColors);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {	// we have to stretch or shrink horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
								iNumSrcCols,iNumSrcRows,
								pdDstScanLine,iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	    BYTE bTransparentIndex = (BYTE)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24P_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							    iNumSrcRows,pdDstScanLine,
							    iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,
							    bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt08Ato24P_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,
							      bTransparentIndex,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired
// REVIEW!!!! -- This is a temporary hack based on the following premises:
//
//	1) In theory, per-pixel alpha should be overridable by per-surface alpha
//	2) In practice, Burma does not allow per-surface alpha to override a per-
//		pixel bitmap.
//	3) The following code for all the per-surface alpha blending bliting is
//		temporarily commented out so that we can verify DirectDraw NEVER EVER
//		calls BlitLib with both a per-pixel bitmap and a per-surface alpha
//		value other than ALPHA_INVALID.
//
//		Therefore, we are currently return E_UNEXPECTED if this condition occurs.
//
//		Although the following commented code is contrary to the Burma hardware,
//		we are not going to change BlitLib to Burma's implementation because we
//		believe it's implementation is a bug.
//
	return E_UNEXPECTED;

/*		// if alpha value is zero, we do no work since the source bitmap 
		// contributes nothing to the destination bitmap
		if (!(arAlpha & ALPHA_MASK)) {
		return sc;
		}			

	 	// check to see if we need to worry about transparency
		if (crTransparent == CLR_INVALID) {
			
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24P_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
		} else {		// we need to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24P_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		}
		} else { 
		BYTE bTransparentIndex = (BYTE)crTransparent;
	
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24P_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		} else {		// we have to shrink or stretch horizontally
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt08Ato24P_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		bTransparentIndex,arAlpha,(COLORREF*) pDibInfoSrc->bmiColors);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		}
		}*/
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt08Ato08A - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency using the
//		specified raster operation.
//
//		This blit is special because it uses the 16to16 blits for
//		all of it's non-transparent color blits.  This can be
//		accomplished because we are ignoring the 8-bit alpha channel
//		and just copying 16 bits to the destination.  For the blits
//		with a transparent color, new functions are called which check
//		for only a transparent color palette index (8 bits) and then
//		copies 16 bits where the color doesn't match. This is a COPY
//		ONLY blit, thus, it does NOT do any alpha blending.
//
//		Note: The 08Ato08A routines are located with the other 16to16
//		blits because it is just an extension of them.  (These currently
//		reside in blt1616.cxx).
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt08Ato08A(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine,
	*pwDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pwSrcScanLine = (WORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
    pwDstScanLine = (WORD*) pDibBitsDst + prcDst->top *	(iDstScanLength
							 = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

    // Make sure we are not doing any blending. This is ONLY a copy blit!
    if (arAlpha != ALPHA_INVALID)
	return E_INVALIDARG;
			
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {
		
	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
		
	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
								  pwDstScanLine,iDstScanLength,
								  iNumDstCols,iNumDstRows);
		} else {
		    Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
								    iNumSrcRows,pwDstScanLine,
								    iDstScanLength * iVertMirror,
								    iNumDstCols,iNumDstRows);
		}
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt16to16_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pwDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } 
    else {	// transparency desired
		
	BYTE bTransparentColor = (BYTE)crTransparent;

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08Ato08A_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							iNumSrcRows,pwDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							bTransparentColor);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt08Ato08A_NoBlend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pwDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  bTransparentColor);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    }
    return sc;
}
#endif // DDRAW

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt16to16 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt16to16(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine,
	*pwDstScanLine;


    // If the bitmaps overlap, we need to use overlapping code
    if(BlitLib_Detect_Intersection(pDibBitsDst, prcDst, pDibBitsSrc, prcSrc))
	return BlitLib_BitBlt16to16_Intersect(pDibInfoDst, pDibBitsDst,	prcDst,
					      pDibInfoSrc, pDibBitsSrc, prcSrc, crTransparent, dwRop);

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pwSrcScanLine = (WORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
    pwDstScanLine = (WORD*) pDibBitsDst + prcDst->top *	(iDstScanLength
							 = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
								      pwDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows);
		    } else {
			Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
									iNumSrcRows,pwDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pwDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {	// transparency desired
			
	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt16to16_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pwDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  wTransparentColor);
		} 
                else 
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_NoBlend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pwDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    }
#ifndef DDRAW
#ifndef WIN95
    else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
                   
		    Blt16to16_Blend_NoTrans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pwDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_Blend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pwDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 	// transparency desired

	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_Blend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							iNumSrcRows,pwDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to16_Blend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pwDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }
#endif
#endif
    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt16to16_Intersect - 
//		BitBlit from source bitmap to destination bitmap (and these
//		bitmaps overlap each other) with optional transparency
//		using the specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt16to16_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
				     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
				     COLORREF crTransparent, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine,
	*pwDstScanLine,
	*pwTempScanLine,
	wTransparentIndex;
    PDIBBITS	pDibBitsTemp;


    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) 
    {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) 
    {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) 
    {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) 
    {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // We aren't currently support any ROP's besides SRCCOPY
    if(dwRop != SRCCOPY)
	return E_UNEXPECTED;


    //
    // Here are all the stretching and mirroring blits for overlapping rects
    //
	
    // REVIEW!!! -- The following code could be optimized for the caching
    // cases.  Currently, it allocates a second bitmap that is the same
    // size as the original destination, and then uses the original blit
    // rectangle to do the caching.  To save space, this blit should 
    // eventually be changed to only allocate the size of the overlapped
    // rectangle, and the blit rects should be adjusted accordingly.
	
    // Check if we are stretching (horiz or vert), or if we are mirroring --
    // In all of these cases, we must create a cache bitmap and double blit
    if((iNumDstCols != iNumSrcCols) || (iNumDstRows != iNumSrcRows) ||
       (iHorizMirror != 1) || (iVertMirror != 1))
    {
		
	// Allocate memory for the cache bitmap -- We will blit into this
	// temporary bitmap and then re-blit back to the original source
	pDibBitsTemp = (PDIBBITS)osMemAlloc(DibSizeImage((LPBITMAPINFOHEADER)pDibInfoDst));

        if (pDibBitsTemp == NULL)
            return E_UNEXPECTED;

	// compute pointers to the starting rows in the src and temp bitmaps
	pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
							       = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	pwTempScanLine = (WORD*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	// check if we can do a straight copy from src row to dst row
	if((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1))
	{

	    // check if we can do a straight copy vertically, 
	    // or if we have to stretch, shrink, or mirror
	    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
	    {
		Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
							      pwTempScanLine,iDstScanLength,
							      iNumDstCols,iNumDstRows);
	    } 
	    else 
	    {
		Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
								iNumSrcRows,pwTempScanLine,
								iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows);
	    }
	}
        else
        {
	    Blt16to16_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
						      iNumSrcCols,iNumSrcRows,
		    	                              pwTempScanLine,iDstScanLength * iVertMirror,
						      iNumDstCols,iNumDstRows,iHorizMirror);
	}
		

	// Recalculate the scan line pointers for the second blit

	if(BLITLIB_RECTWIDTH(prcDst) < 0)
	{
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}

	if(BLITLIB_RECTHEIGHT(prcDst) < 0)
	{
	    prcDst->top++;
	    prcDst->bottom++;
	    FlipRectVertical(prcDst);
	}

	// compute pointers to the starting rows in the temp and dest bitmaps
	pwTempScanLine = (WORD*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;
	pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
							       = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	// Now blit from the temporary bitmap back to the original source,
	// checking for transparency if necessary
	if(crTransparent == CLR_INVALID)
	{
	    Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwTempScanLine,iDstScanLength,
							  pwDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows);
	}
	else
	{
	    wTransparentIndex = (WORD)crTransparent;

	    Blt16to16_NoBlend_Trans_Hcopy_SRCCOPY(pwTempScanLine,iDstScanLength,
						  iNumDstRows,pwDstScanLine,
						  iDstScanLength, iNumDstCols,
						  iNumDstRows, wTransparentIndex);
	}
		
	// Free the memory from the temporary bitmap
	if(pDibBitsTemp)
	    osMemFree(pDibBitsTemp);		
		
	return sc;
    }
 	
    //
    // Here are all the non-stretching and non-mirroring blits for overlapping rects
    //

    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// Simplest case, they are the same rectangles
	if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	   (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
        {
	    return sc;
        }

	// Next case, the destination rectangle is vertically greater in
	// magnitude than the source rectangle
	else if(prcDst->top > prcSrc->top)
	{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									  = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									  = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	    //  Call the appropriate blit
	    Blt16to16_LeftToRight_BottomToTop_SRCCOPY(pwSrcScanLine,
						      iSrcScanLength,	pwDstScanLine, iDstScanLength, iNumDstCols,
						      iNumDstRows);
	}

	// Next case, the destination rectangle is horizontally less than
	// or equal in magnitude to the source rectangle
	else if(prcDst->left <= prcSrc->left){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	    //  Call the appropriate blit
	    Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
							  pwDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows);
	}

	// Last case, the destination rectangle is horizontally greater
	// in magnitude than the source rectangle
	else{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc) / 2) + (prcSrc->right - 1);
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst) / 2) + (prcDst->right - 1);

	    //  Call the appropriate blit
	    Blt16to16_RightToLeft_TopToBottom_SRCCOPY(pwSrcScanLine,
						      iSrcScanLength,	pwDstScanLine, iDstScanLength, iNumDstCols,
						      iNumDstRows);
	}
    }
    else{
	wTransparentIndex = (WORD)crTransparent;
		
	// Simplest case, they are the same rectangles
	if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	   (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
	    return sc;

	// Next case, the destination rectangle is vertically greater in
	// magnitude than the source rectangle
	else if(prcDst->top > prcSrc->top){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									  = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									  = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	    //  Call the appropriate blit
	    Blt16to16_LeftToRight_BottomToTop_Trans_SRCCOPY(pwSrcScanLine,
							    iSrcScanLength, pwDstScanLine, iDstScanLength, iNumDstCols,
							    iNumDstRows, wTransparentIndex);
	}

	// Next case, the destination rectangle is horizontally less than
	// or equal in magnitude to the source rectangle
	else if(prcDst->left <= prcSrc->left){
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst) / 2) + prcDst->left;

	    //  Call the appropriate blit
	    Blt16to16_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
						  iNumSrcRows,pwDstScanLine,
						  iDstScanLength, iNumDstCols,iNumDstRows,
						  wTransparentIndex);
	}

	// Last case, the destination rectangle is horizontally greater
	// in magnitude than the source rectangle
	else{
	    // compute pointers to the starting rows in the src and dst bitmaps
	    // taking care to invert y values, since DIBs are upside-down
	    pwSrcScanLine = (WORD*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								   = DibWidthBytes(pDibInfoSrc) / 2) + (prcSrc->right - 1);
	    pwDstScanLine = (WORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst) / 2) + (prcDst->right - 1);

	    //  Call the appropriate blit
	    Blt16to16_RightToLeft_TopToBottom_Trans_SRCCOPY(pwSrcScanLine,
							    iSrcScanLength, pwDstScanLine, iDstScanLength, iNumDstCols,
							    iNumDstRows, wTransparentIndex);
	}
    }

    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt16to24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt16to24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine;
    DWORD	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pwSrcScanLine = (WORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt16to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows);
		    } else {
			Blt16to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
									iNumSrcRows,pdDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {	// transparency desired
			
	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_NoBlend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_Blend_NoTrans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_Blend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 	// transparency desired

	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_Blend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							iNumSrcRows,pdDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24_Blend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pdDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt16to24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt16to24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    WORD	*pwSrcScanLine;
    BYTE	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pwSrcScanLine = (WORD *) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 2) + prcSrc->left;
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt16to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pwSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows);
		    } else {
			Blt16to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pwSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {	// transparency desired
			
	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_NoBlend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_NoBlend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     wTransparentColor);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_Blend_NoTrans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_Blend_NoTrans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 	// transparency desired

	    WORD wTransparentColor = (WORD)crTransparent;
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_Blend_Trans_Hcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							 iNumSrcRows,pdDstScanLine,
							 iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,
							 wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt16to24P_Blend_Trans_NoHcopy_SRCCOPY(pwSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pdDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror,
							   wTransparentColor,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24to01 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24to01(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iBytesPerDstScanLine,
	iHorizMirror = 1,
	iVertMirror = 1,
	iDstBitOffset;
    DWORD	*pdSrcScanLine;
    BYTE	*pbDstScanLine,
	bFillVal;

    // alpha blending not currently supported in the 24 to 1 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // the only ROPs supported are BLACKNESS and WHITENESS
    if (dwRop == BLACKNESS) {
	bFillVal = 0;
    } else if (dwRop == WHITENESS) {
	bFillVal = 0xFF;
    } else {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iBytesPerDstScanLine
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left / 8);
    iDstBitOffset = prcDst->left % 8;
		
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// no transparency plus a constant ROP equals a rectangle fill!
	// first we have to normalize dst rect orientation
	// - FillRect01() expects it
	if (BLITLIB_RECTWIDTH(prcDst) < 0) {
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}
	if (BLITLIB_RECTHEIGHT(prcDst) < 0) {
	    prcDst->top--;
	    prcDst->bottom--;
	    FlipRectVertical(prcDst);
	}
	sc |= BlitLib_FillRect01(pDibInfoDst,pDibBitsDst,prcDst->left,prcDst->top,
				 iNumDstCols,iNumDstRows,bFillVal);

    } else {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	    Blt24to01_Trans_Hcopy_ConstRop(pdSrcScanLine,iSrcScanLength,iNumSrcRows,
					   pbDstScanLine,iDstBitOffset,
					   iBytesPerDstScanLine * iVertMirror,
					   iNumDstCols,iNumDstRows,crTransparent,
					   bFillVal);
	} else {
	    Blt24to01_Trans_NoHcopy_ConstRop(pdSrcScanLine,iSrcScanLength,iNumSrcCols,
					     iNumSrcRows,pbDstScanLine,iDstBitOffset,
					     iBytesPerDstScanLine * iVertMirror,
					     iNumDstCols,iNumDstRows,iHorizMirror,
					     crTransparent,bFillVal);
	}
    }

    return sc;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Pto01 - 
//		BitBlit from source bitmap to destination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Pto01(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iBytesPerDstScanLine,
	iHorizMirror = 1,
	iVertMirror = 1,
	iDstBitOffset;
    BYTE	*pdSrcScanLine;
    BYTE	*pbDstScanLine,
	bFillVal;

    // alpha blending not currently supported in the 24 to 1 bpp blits
    if (arAlpha != ALPHA_INVALID) {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // the only ROPs supported are BLACKNESS and WHITENESS
    if (dwRop == BLACKNESS) {
	bFillVal = 0;
    } else if (dwRop == WHITENESS) {
	bFillVal = 0xFF;
    } else {
	return E_UNEXPECTED;		// !!!! need better error codes
    }

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iBytesPerDstScanLine
							 = DibWidthBytes(pDibInfoDst)) + (prcDst->left / 8);
    iDstBitOffset = prcDst->left % 8;
		
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {

	// no transparency plus a constant ROP equals a rectangle fill!
	// first we have to normalize dst rect orientation
	// - FillRect01() expects it
	if (BLITLIB_RECTWIDTH(prcDst) < 0) {
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}
	if (BLITLIB_RECTHEIGHT(prcDst) < 0) {
	    prcDst->top--;
	    prcDst->bottom--;
	    FlipRectVertical(prcDst);
	}
	sc |= BlitLib_FillRect01(pDibInfoDst,pDibBitsDst,prcDst->left,prcDst->top,
				 iNumDstCols,iNumDstRows,bFillVal);

    } else {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	    Blt24Pto01_Trans_Hcopy_ConstRop(pdSrcScanLine,iSrcScanLength,iNumSrcRows,
					    pbDstScanLine,iDstBitOffset,
					    iBytesPerDstScanLine * iVertMirror,
					    iNumDstCols,iNumDstRows,crTransparent,
					    bFillVal);
	} else {
	    Blt24Pto01_Trans_NoHcopy_ConstRop(pdSrcScanLine,iSrcScanLength,iNumSrcCols,
					      iNumSrcRows,pbDstScanLine,iDstBitOffset,
					      iBytesPerDstScanLine * iVertMirror,
					      iNumDstCols,iNumDstRows,iHorizMirror,
					      crTransparent,bFillVal);
	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24to08 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24to08(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE		sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD		*pdSrcScanLine;
    BYTE		*pbDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iDstScanLength
							 = DibWidthBytes(pDibInfoDst)) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24to08_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								      pbDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		    } else {
			Blt24to08_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									iNumSrcRows,pbDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pbDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pbDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  crTransparent,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pbDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    crTransparent,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pbDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pbDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							iNumSrcRows,pbDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							crTransparent,arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to08_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pbDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  crTransparent,arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Pto08 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Pto08(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE		sc = NOERROR;
    int			iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE		*pbSrcScanLine;
    BYTE		*pbDstScanLine;

    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pbSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
    pbDstScanLine = (BYTE*) pDibBitsDst + prcDst->top * (iDstScanLength
							 = DibWidthBytes(pDibInfoDst)) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24Pto08_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
								       pbDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		    } else {
			Blt24Pto08_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pbDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pbDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_NoBlend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pbDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   crTransparent,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_NoBlend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pbDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     crTransparent,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_Blend_NoTrans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pbDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_Blend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pbDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_Blend_Trans_Hcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							 iNumSrcRows,pbDstScanLine,
							 iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,
							 crTransparent,arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Pto08_Blend_Trans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pbDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror,
							   crTransparent,arAlpha,(COLORREF*) pDibInfoDst->bmiColors,DibNumColors(&(pDibInfoDst->bmiHeader)));
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}
#endif // DDRAW


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24to24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24to24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			   PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			   PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine,
	*pdDstScanLine,
	*pdTempScanLine;
    PDIBBITS pDibBitsTemp;

    if(dwRop != SRCCOPY)
        return DDERR_INVALIDPARAMS;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) 
    {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) 
    {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) 
    {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) 
    {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }

    // Handle intersecting blits in a completely unintelegent manner.
    if(BlitLib_Detect_Intersection(pDibBitsDst, prcDst, pDibBitsSrc, prcSrc))
    {
	// Allocate memory for the cache bitmap -- We will blit into this
	// temporary bitmap and then re-blit back to the original source
	pDibBitsTemp = (PDIBBITS)osMemAlloc(DibSizeImage((LPBITMAPINFOHEADER)pDibInfoDst));
	if(pDibBitsTemp == NULL)
	    return DDERR_OUTOFMEMORY;

	// compute pointers to the starting rows in the src and temp bitmaps
	pdSrcScanLine = (DWORD *) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								 = DibWidthBytes(pDibInfoSrc)/4) + prcSrc->left;
	pdTempScanLine = (DWORD *) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								   = DibWidthBytes(pDibInfoDst)/4) + prcDst->left;
	    
	// check if we can do a straight copy from src row to dst row
	if((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1))
	{
		
	    // check if we can do a straight copy vertically, 
	    // or if we have to stretch, shrink, or mirror
	    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
	    {
		Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
							      pdTempScanLine,iDstScanLength,
							      iNumDstCols,iNumDstRows);
	    } 
	    else 
	    {
		Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
								iNumSrcRows,pdTempScanLine,
								iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows);
	    }
	}
	else
	{
	    Blt24to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
						      iNumSrcCols,iNumSrcRows,
						      pdTempScanLine,iDstScanLength * iVertMirror,
						      iNumDstCols,iNumDstRows,iHorizMirror);
	}
	    
	    
	// Recalculate the scan line pointers for the second blit
	    
	if(BLITLIB_RECTWIDTH(prcDst) < 0)
	{
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}
	    
	if(BLITLIB_RECTHEIGHT(prcDst) < 0)
	{
	    prcDst->top++;
	    prcDst->bottom++;
	    FlipRectVertical(prcDst);
	}
	    
	// compute pointers to the starting rows in the temp and dest bitmaps
	pdTempScanLine = (DWORD*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								  = DibWidthBytes(pDibInfoDst)/4) + prcDst->left;
	pdDstScanLine = (DWORD*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								= DibWidthBytes(pDibInfoDst)/4) + prcDst->left;
	    
	// Now blit from the temporary bitmap back to the original source,
	// checking for transparency if necessary
	if(crTransparent == CLR_INVALID)
	{
	    Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdTempScanLine,iDstScanLength,
							  pdDstScanLine,iDstScanLength,
							  iNumDstCols,iNumDstRows);
	}
	else
	{
	    Blt24to24_NoBlend_Trans_Hcopy_SRCCOPY(pdTempScanLine,iDstScanLength,
						  iNumDstRows,pdDstScanLine,
						  iDstScanLength,
						  iNumDstCols,iNumDstRows,
						  crTransparent);
	}
	    
	// Free the memory from the temporary bitmap
	if(pDibBitsTemp)
	{
	    osMemFree(pDibBitsTemp);
	}
	pDibBitsTemp = NULL;
	return sc;
    }
	
    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;
	
    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) 
    {		// no blending desired
	    
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
	{
		
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
	    {
		    
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
		{
			
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
		    {
			Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows);
		    } 
		    else // must stretch/mirror vertically
		    {
			Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									iNumSrcRows,pdDstScanLine,
									iDstScanLength * iVertMirror,
									iNumDstCols,iNumDstRows);
		    }
		} 
		else // not SRCCOPY
		    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    
	    } 
	    else // must stretch/mirror horizontally
	    {
		    
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
		{
		    Blt24to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror);
		} 
		else // not SRCCOPY
		    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    
	    }
	} 
	else // transparent blit
	{
		
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
	    {
		    
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
		{
		    Blt24to24_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  crTransparent);
		} 
		else // not SRCCOPY
		    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    
	    } 
	    else // must stretch/mirror horizontally
	    {
		    
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    crTransparent);
		} 
		else // not srccopy
		    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    
	    }
	}
    } 
    else // blending desired
    {		
#ifdef DDRAW
	return E_UNEXPECTED;
#else
	    
	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) 
        {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcRows,pdDstScanLine,
							  iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,
							  arAlpha);
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } 
            else // must mirror/stretch horizontally
            {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcCols,iNumSrcRows,
							    pdDstScanLine,iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,iHorizMirror,
							    arAlpha);
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} 
        else // transparent blit
        { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							iNumSrcRows,pdDstScanLine,
							iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,
							crTransparent,arAlpha);
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } 
            else // must stretch/mirror horizontally
            {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24to24_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							  iNumSrcCols,iNumSrcRows,
							  pdDstScanLine,iDstScanLength * iVertMirror,
							  iNumDstCols,iNumDstRows,iHorizMirror,
							  crTransparent,arAlpha);
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
#endif /* !DDRAW */
    }

    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24to24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24to24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine;
    BYTE	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows);
		    } else {
			Blt24to24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							 iNumSrcRows,pdDstScanLine,
							 iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,
							 crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24to24P_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pdDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror,
							   crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
    }

    return sc;
}
#endif // DDRAW

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Pto24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Pto24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pdSrcScanLine;
    BYTE	*pdDstScanLine;


    // If the bitmaps overlap, we need to use overlapping code
    if(BlitLib_Detect_Intersection(pDibBitsDst, prcDst, pDibBitsSrc, prcSrc))
	return BlitLib_BitBlt24Pto24P_Intersect(pDibInfoDst, pDibBitsDst, prcDst,
						pDibInfoSrc, pDibBitsSrc, prcSrc, crTransparent, arAlpha, dwRop);

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) 
    {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) 
    {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) 
    {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) 
    {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (BYTE*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							 = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) 
    {		// no blending desired
		
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
                    {
			// This is the 8->8 blit with 3 times as many columns
			Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
							      pdDstScanLine,iDstScanLength,
							      iNumDstCols * 3,iNumDstRows);
		    } 
                    else // must stretch/mirror vertically
                    {
			Blt24Pto24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									  iNumSrcRows,pdDstScanLine,
									  iDstScanLength * iVertMirror,
									  iNumDstCols,iNumDstRows);

		    }
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// non-SRCCOPY unsupported!!!! we need better error codes
		
	    } 
            else // must stretch/mirror horizontally (and maybe vertically)
            {
		if (dwRop == SRCCOPY) 
                {
		    Blt24Pto24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
								iNumSrcCols,iNumSrcRows,
								pdDstScanLine,iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows,iHorizMirror);
		} 
                else 
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	} 
        else // Transparent blt
        { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
                    {
			Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY_VCopy(pdSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,
								      crTransparent);
		    } 
                    else // must stretch/mirror vertically
                    {
			Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
								iNumSrcRows,
								pdDstScanLine,iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows,
								crTransparent);
                    }
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } 
            else // must stretch/mirror horizontally and maybe vertically
            {
                // check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    Blt24Pto24P_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,
							      crTransparent);

                }
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes

            }
	}
    } 
    else // blending desired
    {		
#ifdef DDRAW
	return E_UNEXPECTED;
#else
	// if alpha value is zero, we do no work since the source bitmap 
	// contributes nothing to the destination bitmap
	if (!(arAlpha & ALPHA_MASK)) 
        {
	    return sc;
	}			

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
                    {
			Blt24Pto24P_Blend_NoTrans_Hcopy_SRCCOPY_VCopy(pdSrcScanLine,iSrcScanLength,
								      pdDstScanLine,iDstScanLength,
								      iNumDstCols,iNumDstRows,
								      arAlpha);
		    } 
                    else // must stretch/mirror vertically
                    {
			sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    }
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } 
            else // must mirror/stretch horizontally
            {
	
		sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} 
        else // transparent blit
        { 
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) 
            {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) 
                {
		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
                    {
			Blt24Pto24P_Blend_Trans_Hcopy_SRCCOPY_VCopy(pdSrcScanLine,iSrcScanLength,
								    pdDstScanLine,iDstScanLength,
								    iNumDstCols,iNumDstRows,
								    crTransparent,arAlpha);
		    } 
                    else // must stretch/mirror vertically
                    {
			sc |= E_UNEXPECTED;		// !!!! we need better error codes
		    }
		} 
                else // not SRCCOPY
                    sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } 
            else // must stretch/mirror horizontally
            {
                sc |= E_UNEXPECTED;		// !!!! we need better error codes
	    }
	}
#endif
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Pto24P_Intersect - 
//		BitBlit from source bitmap to destination bitmap (and these
//		bitmaps overlap each other) with optional transparency and/or
//		alpha blending using the specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Pto24P_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
				       PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
				       COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    BYTE	*pbSrcScanLine,
	*pbDstScanLine,
	*pbTempScanLine;
    PDIBBITS	pDibBitsTemp;


    // normalize orientation of source and destination rectangles, and
    // compute sizes and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) 
    {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) 
    {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) 
    {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) 
    {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // We aren't currently support any ROP's besides SRCCOPY
    if(dwRop != SRCCOPY)
	return E_UNEXPECTED;

	
    //
    // Here are all the stretching and mirroring blits for overlapping rects
    //
	
    // REVIEW!!! -- The following code could be optimized for the caching
    // cases.  Currently, it allocates a second bitmap that is the same
    // size as the original destination, and then uses the original blit
    // rectangle to do the caching.  To save space, this blit should 
    // eventually be changed to only allocate the size of the overlapped
    // rectangle, and the blit rects should be adjusted accordingly.
	
    // Check if we are stretching (horiz or vert), or if we are mirroring --
    // In all of these cases, we must create a cache bitmap and double blit
    if((iNumDstCols != iNumSrcCols) || (iNumDstRows != iNumSrcRows) ||
       (iHorizMirror != 1) || (iVertMirror != 1))
    {
		
	// Allocate memory for the cache bitmap -- We will blit into this
	// temporary bitmap and then re-blit back to the original source
	pDibBitsTemp = (PDIBBITS)osMemAlloc(DibSizeImage((LPBITMAPINFOHEADER)pDibInfoDst));
        if(pDibBitsTemp == NULL)
            return DDERR_OUTOFMEMORY;
	// compute pointers to the starting rows in the src and temp bitmaps
	pbSrcScanLine = (BYTE *) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								= DibWidthBytes(pDibInfoSrc)) + prcSrc->left*3;
	pbTempScanLine = (BYTE *) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								  = DibWidthBytes(pDibInfoDst)) + prcDst->left*3;

	// check if we can do a straight copy from src row to dst row
	if((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1))
	{

	    // check if we can do a straight copy vertically, 
	    // or if we have to stretch, shrink, or mirror
	    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) 
	    {
		Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
						      pbTempScanLine,iDstScanLength,
						      iNumDstCols*3,iNumDstRows);
	    } 
	    else 
	    {
		Blt24Pto24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pbSrcScanLine,iSrcScanLength,
								  iNumSrcRows,pbTempScanLine,
								  iDstScanLength * iVertMirror,
								  iNumDstCols,iNumDstRows);
	    }
	}
        else
        {
	    Blt24Pto24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pbSrcScanLine,iSrcScanLength,
							iNumSrcCols,iNumSrcRows,
							pbTempScanLine,iDstScanLength * iVertMirror,
							iNumDstCols,iNumDstRows,iHorizMirror);	
        }
		

	// Recalculate the scan line pointers for the second blit

	if(BLITLIB_RECTWIDTH(prcDst) < 0)
	{
	    prcDst->left++;
	    prcDst->right++;
	    FlipRectHorizontal(prcDst);
	}

	if(BLITLIB_RECTHEIGHT(prcDst) < 0)
	{
	    prcDst->top++;
	    prcDst->bottom++;
	    FlipRectVertical(prcDst);
	}

	// compute pointers to the starting rows in the temp and dest bitmaps
	pbTempScanLine = (BYTE*) pDibBitsTemp + (prcDst->top) * (iDstScanLength
								 = DibWidthBytes(pDibInfoDst)) + prcDst->left*3;
	pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
							       = DibWidthBytes(pDibInfoDst)) + prcDst->left*3;

	// Now blit from the temporary bitmap back to the original source,
	// checking for transparency if necessary
	if(crTransparent == CLR_INVALID)
	{
	    Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbTempScanLine,iDstScanLength,
						  pbDstScanLine,iDstScanLength,
						  3*iNumDstCols,iNumDstRows);
	}
	else
	{
	    Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY(pbTempScanLine,iDstScanLength,
						    iNumDstRows,pbDstScanLine,
						    iDstScanLength, iNumDstCols,
						    iNumDstRows, crTransparent);
	}
		
	// Free the memory from the temporary bitmap
	if(pDibBitsTemp)
        {
	    osMemFree(pDibBitsTemp);
        }
        pDibBitsTemp = NULL;
		
	return sc;
    }

    //
    // Here are all the non-stretching and non-mirroring blits for overlapping rects
    //

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) 
    {		// no blending desired

	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {
	    // Simplest case, they are the same rectangles
	    if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	       (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
		return sc;

	    // Next case, the destination rectangle is vertically greater in
	    // magnitude than the source rectangle
	    else if(prcDst->top > prcSrc->top)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the bottom rect edge since we are
		// going from bottom to top
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									      = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									      = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt08to08_LeftToRight_BottomToTop_SRCCOPY(pbSrcScanLine,
							  iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols * 3,
							  iNumDstRows);
	    }

	    // Next case, the destination rectangle is horizontally less than
	    // or equal in magnitude to the source rectangle
	    else if(prcDst->left <= prcSrc->left)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(pbSrcScanLine,iSrcScanLength,
						      pbDstScanLine,iDstScanLength,
						      iNumDstCols * 3,iNumDstRows);
	    }

	    // Last case, the destination rectangle is horizontally greater
	    // in magnitude than the source rectangle
	    else
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the right rect edge since we are
		// going from right to left
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (((prcSrc->right - 1) * 3) + 2);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (((prcDst->right - 1) * 3) + 2);

		//  Call the appropriate blit
		Blt08to08_RightToLeft_TopToBottom_SRCCOPY(pbSrcScanLine,
							  iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols * 3,
							  iNumDstRows);
	    }
	}
	else // transparent blt
        {
	    // Simplest case, they are the same rectangles
	    if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	       (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
		return sc;

	    // Next case, the destination rectangle is vertically greater in
	    // magnitude than the source rectangle
	    else if(prcDst->top > prcSrc->top)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the bottom rect edge since we are
		// going from bottom to top
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									      = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									      = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_LeftToRight_BottomToTop_Trans_SRCCOPY(pbSrcScanLine,
								  iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
								  iNumDstRows, crTransparent);
	    }

	    // Next case, the destination rectangle is horizontally less than
	    // or equal in magnitude to the source rectangle
	    else if(prcDst->left <= prcSrc->left)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY_VCopy(pbSrcScanLine,iSrcScanLength,
							      pbDstScanLine,
							      iDstScanLength, iNumDstCols,
							      iNumDstRows, crTransparent);
	    }

	    // Last case, the destination rectangle is horizontally greater
	    // in magnitude than the source rectangle
	    else
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the right rect edge since we are
		// going from right to left
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + ((prcSrc->right - 1) * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + ((prcDst->right - 1) * 3);

		//  Call the appropriate blit
		Blt24Pto24P_RightToLeft_TopToBottom_Trans_SRCCOPY(pbSrcScanLine,
								  iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
								  iNumDstRows, crTransparent);
	    }
	}
    }
    else
    {	// We're doing alpha blending
#ifdef DDRAW
	return E_UNEXPECTED;
#else
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) 
        {

	    // Simplest case, they are the same rectangles
	    if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	       (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
		return sc;

	    // Next case, the destination rectangle is vertically greater in
	    // magnitude than the source rectangle
	    else if(prcDst->top > prcSrc->top)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the bottom rect edge since we are
		// going from bottom to top
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									      = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									      = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_LeftToRight_BottomToTop_Alpha_SRCCOPY(pbSrcScanLine,
								  iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols,
								  iNumDstRows, arAlpha);
	    }

	    // Next case, the destination rectangle is horizontally less than
	    // or equal in magnitude to the source rectangle
	    else if(prcDst->left <= prcSrc->left)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_Blend_NoTrans_Hcopy_SRCCOPY_VCopy(pbSrcScanLine,iSrcScanLength,
							      pbDstScanLine,iDstScanLength,
							      iNumDstCols,iNumDstRows,arAlpha);
	    }

	    // Last case, the destination rectangle is horizontally greater
	    // in magnitude than the source rectangle
	    else
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the right rect edge since we are
		// going from right to left
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + ((prcSrc->right - 1) * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + ((prcDst->right - 1) * 3);

		//  Call the appropriate blit
		Blt24Pto24P_RightToLeft_TopToBottom_Alpha_SRCCOPY(pbSrcScanLine,
								  iSrcScanLength,	pbDstScanLine, iDstScanLength, iNumDstCols,
								  iNumDstRows, arAlpha);
	    }
	}
	else
        {
	    // Simplest case, they are the same rectangles
	    if((prcDst->left == prcSrc->left) && (prcDst->top == prcSrc->top) &&
	       (prcDst->right == prcSrc->right) && (prcDst->bottom == prcSrc->bottom))
		return sc;

	    // Next case, the destination rectangle is vertically greater in
	    // magnitude than the source rectangle
	    else if(prcDst->top > prcSrc->top)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the bottom rect edge since we are
		// going from bottom to top
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->bottom - 1) * (iSrcScanLength
									      = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->bottom - 1) * (iDstScanLength
									      = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_LeftToRight_BottomToTop_Trans_Alpha_SRCCOPY(pbSrcScanLine,
									iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
									iNumDstRows, crTransparent, arAlpha);
	    }

	    // Next case, the destination rectangle is horizontally less than
	    // or equal in magnitude to the source rectangle
	    else if(prcDst->left <= prcSrc->left)
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + (prcSrc->left * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

		//  Call the appropriate blit
		Blt24Pto24P_Blend_Trans_Hcopy_SRCCOPY_VCopy(pbSrcScanLine,iSrcScanLength,
							    pbDstScanLine,
							    iDstScanLength, iNumDstCols,
							    iNumDstRows, crTransparent, arAlpha);
	    }

	    // Last case, the destination rectangle is horizontally greater
	    // in magnitude than the source rectangle
	    else
            {
		// compute pointers to the starting rows in the src and dst bitmaps
		// taking care to decrement the right rect edge since we are
		// going from right to left
		pbSrcScanLine = (BYTE*) pDibBitsSrc + (prcSrc->top) * (iSrcScanLength
								       = DibWidthBytes(pDibInfoSrc)) + ((prcSrc->right - 1) * 3);
		pbDstScanLine = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstScanLength
								       = DibWidthBytes(pDibInfoDst)) + ((prcDst->right - 1) * 3);

		//  Call the appropriate blit
		Blt24Pto24P_RightToLeft_TopToBottom_Trans_Alpha_SRCCOPY(pbSrcScanLine,
									iSrcScanLength, pbDstScanLine, iDstScanLength, iNumDstCols,
									iNumDstRows, crTransparent, arAlpha);
	    }
	}
#endif /* !DDRAW */
    }
    return sc;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Ato24 - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Ato24(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			    PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			    PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine,
	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								       pdDstScanLine,iDstScanLength,
								       iNumDstCols,iNumDstRows);
		    } else {
			Blt24Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									 iNumSrcRows,pdDstScanLine,
									 iDstScanLength * iVertMirror,
									 iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							       iNumSrcCols,iNumSrcRows,
							       pdDstScanLine,iDstScanLength * iVertMirror,
							       iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcRows,pdDstScanLine,
							   iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,
							   crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							     iNumSrcCols,iNumSrcRows,
							     pdDstScanLine,iDstScanLength * iVertMirror,
							     iNumDstCols,iNumDstRows,iHorizMirror,
							     crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

// REVIEW!!!! -- This is a temporary hack based on the following premises:
//
//	1) In theory, per-pixel alpha should be overridable by per-surface alpha
//	2) In practice, Burma does not allow per-surface alpha to override a per-
//		pixel bitmap.
//	3) The following code for all the per-surface alpha blending bliting is
//		temporarily commented out so that we can verify DirectDraw NEVER EVER
//		calls BlitLib with both a per-pixel bitmap and a per-surface alpha
//		value other than ALPHA_INVALID.
//
//		Therefore, we are currently return E_UNEXPECTED if this condition occurs.
//
//		Although the following commented code is contrary to the Burma hardware,
//		we are not going to change BlitLib to Burma's implementation because we
//		believe it's implementation is a bug.
//
	return E_UNEXPECTED;

/*		// if alpha value is zero, we do no work since the source bitmap 
		// contributes nothing to the destination bitmap
		if (!(arAlpha & ALPHA_MASK)) {
		return sc;
		}			

	 	// check to see if we need to worry about transparency
		if (crTransparent == CLR_INVALID) {
			
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
		} else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		}
		} else { 
	
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		} else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		}
		}*/
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Ato24P - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Ato24P(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine;
    BYTE	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (BYTE *) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst)) + (prcDst->left * 3);

    // check if we're doing blending
    if (arAlpha == ALPHA_INVALID) {		// no blending desired
			
	// check to see if we need to worry about transparency
	if (crTransparent == CLR_INVALID) {
			
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {

		    // check if we can do a straight copy vertically, 
		    // or if we have to stretch, shrink, or mirror
		    if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
			Blt24Ato24P_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
									pdDstScanLine,iDstScanLength,
									iNumDstCols,iNumDstRows);
		    } else {
			Blt24Ato24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
									  iNumSrcRows,pdDstScanLine,
									  iDstScanLength * iVertMirror,
									  iNumDstCols,iNumDstRows);
		    }
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
								iNumSrcCols,iNumSrcRows,
								pdDstScanLine,iDstScanLength * iVertMirror,
								iNumDstCols,iNumDstRows,iHorizMirror);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	} else {
	
	    // check if we can do a straight copy from src row to dst row
	    if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24P_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							    iNumSrcRows,pdDstScanLine,
							    iDstScanLength * iVertMirror,
							    iNumDstCols,iNumDstRows,
							    crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    } else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		    Blt24Ato24P_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							      iNumSrcCols,iNumSrcRows,
							      pdDstScanLine,iDstScanLength * iVertMirror,
							      iNumDstCols,iNumDstRows,iHorizMirror,
							      crTransparent);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	    }
	}
    } else {		// blending desired

// REVIEW!!!! -- This is a temporary hack based on the following premises:
//
//	1) In theory, per-pixel alpha should be overridable by per-surface alpha
//	2) In practice, Burma does not allow per-surface alpha to override a per-
//		pixel bitmap.
//	3) The following code for all the per-surface alpha blending bliting is
//		temporarily commented out so that we can verify DirectDraw NEVER EVER
//		calls BlitLib with both a per-pixel bitmap and a per-surface alpha
//		value other than ALPHA_INVALID.
//
//		Therefore, we are currently return E_UNEXPECTED if this condition occurs.
//
//		Although the following commented code is contrary to the Burma hardware,
//		we are not going to change BlitLib to Burma's implementation because we
//		believe it's implementation is a bug.
//
	return E_UNEXPECTED;

/*		// if alpha value is zero, we do no work since the source bitmap 
		// contributes nothing to the destination bitmap
		if (!(arAlpha & ALPHA_MASK)) {
		return sc;
		}			

	 	// check to see if we need to worry about transparency
		if (crTransparent == CLR_INVALID) {
			
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
			
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24P_Blend_NoTrans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		
		} else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24P_Blend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		}
		} else { 
	
		// check if we can do a straight copy from src row to dst row
		if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24P_Blend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcRows,pdDstScanLine,
		iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,
		crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
		} else {
	
		// check what ROP we'll be performing
		if (dwRop == SRCCOPY) {
		Blt24Ato24P_Blend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
		iNumSrcCols,iNumSrcRows,
		pdDstScanLine,iDstScanLength * iVertMirror,
		iNumDstCols,iNumDstRows,iHorizMirror,
		crTransparent,arAlpha);
		} else sc |= E_UNEXPECTED;		// !!!! we need better error codes
		}
		}*/
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt24Ato24A - 
//		BitBlit from source bitmap to Dstination bitmap
//		with optional transparency and/or alpha blending using the
//		specified raster operation.
//
//		This blit is special because it uses the regular 24to24 blits
//		to do all of its work.  This blit is a COPY ONLY blit, thus,
//		it does NOT do any alpha blending.  However, it does copy the
//		alpha channel value for each pixel to the destination.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_BitBlt24Ato24A(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
			     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE sc = NOERROR;
    int		iNumSrcRows,
	iNumSrcCols,
	iSrcScanLength,
	iNumDstRows,
	iNumDstCols,
	iDstScanLength,
	iHorizMirror = 1,
	iVertMirror = 1;
    DWORD	*pdSrcScanLine,
	*pdDstScanLine;

    // normalize orientation of source and destination rectangles, and compute sizes 
    // and relative orientations of source and destination rects
    if ((iNumSrcCols = BLITLIB_RECTWIDTH(prcSrc)) < 0) {
	iNumSrcCols = -iNumSrcCols;
	FlipRectHorizontal(prcSrc);
	FlipRectHorizontal(prcDst);
    }
    if ((iNumSrcRows = BLITLIB_RECTHEIGHT(prcSrc)) < 0) {
	iNumSrcRows = -iNumSrcRows;
	FlipRectVertical(prcSrc);
	FlipRectVertical(prcDst);
    }
    if ((iNumDstCols = BLITLIB_RECTWIDTH(prcDst)) < 0) {
	prcDst->left--;
	prcDst->right--;
	iNumDstCols = -iNumDstCols;
	iHorizMirror = -1;
    }
    if ((iNumDstRows = BLITLIB_RECTHEIGHT(prcDst)) < 0) {
	prcDst->top--;
	prcDst->bottom--;
	iNumDstRows = -iNumDstRows;
	iVertMirror = -1;
    }


    // compute pointers to the starting rows in the src and dst bitmaps
    // taking care to invert y values, since DIBs are upside-down
    pdSrcScanLine = (DWORD*) pDibBitsSrc + prcSrc->top * (iSrcScanLength
							  = DibWidthBytes(pDibInfoSrc) / 4) + prcSrc->left;
    pdDstScanLine = (DWORD*) pDibBitsDst + prcDst->top * (iDstScanLength
							  = DibWidthBytes(pDibInfoDst) / 4) + prcDst->left;

    // Make sure we are not trying to alpha blend.  This is a COPY ONLY blit
    if (arAlpha != ALPHA_INVALID)
	return E_INVALIDARG;
			
    // check to see if we need to worry about transparency
    if (crTransparent == CLR_INVALID) {
		
	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {
		
	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {

		// check if we can do a straight copy vertically, 
		// or if we have to stretch, shrink, or mirror
		if ((iNumSrcRows == iNumDstRows) && (iVertMirror == 1)) {
		    Blt24Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(pdSrcScanLine,iSrcScanLength,
								   pdDstScanLine,iDstScanLength,
								   iNumDstCols,iNumDstRows);
		} else {
		    Blt24Ato24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(pdSrcScanLine,iSrcScanLength,
								     iNumSrcRows,pdDstScanLine,
								     iDstScanLength * iVertMirror,
								     iNumDstCols,iNumDstRows);
		}
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes
	
	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt24Ato24_NoBlend_NoTrans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							   iNumSrcCols,iNumSrcRows,
							   pdDstScanLine,iDstScanLength * iVertMirror,
							   iNumDstCols,iNumDstRows,iHorizMirror);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    } else {

	// check if we can do a straight copy from src row to dst row
	if ((iNumSrcCols == iNumDstCols) && (iHorizMirror == 1)) {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt24Ato24_NoBlend_Trans_Hcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
						       iNumSrcRows,pdDstScanLine,
						       iDstScanLength * iVertMirror,
						       iNumDstCols,iNumDstRows,
						       crTransparent);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	} else {

	    // check what ROP we'll be performing
	    if (dwRop == SRCCOPY) {
		Blt24Ato24_NoBlend_Trans_NoHcopy_SRCCOPY(pdSrcScanLine,iSrcScanLength,
							 iNumSrcCols,iNumSrcRows,
							 pdDstScanLine,iDstScanLength * iVertMirror,
							 iNumDstCols,iNumDstRows,iHorizMirror,
							 crTransparent);
	    } else sc |= E_UNEXPECTED;		// !!!! we need better error codes

	}
    }

    return sc;
}
#endif // DDRAW


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect01 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	BYTE crValue	- Color index
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
static const BYTE bTopMask[8]    = {0x00, 0x80, 0xC0, 0xE0, 
                                    0xF0, 0xF8, 0xFC, 0xFE}; 
static const BYTE bBottomMask[8] = {0xFF, 0x7F, 0x3F, 0x1F, 
                                    0x0F, 0x07, 0x03, 0x01};

SCODE BlitLib_FillRect01(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, BYTE crValue)
{
    SCODE 	sc = NOERROR;
    long	DstDeltaScan,
	WidthBytes;
    int		y,
	iPixelOffset,
	iStartPixels,
	iFullBytes,
	iEndPixels;
    BYTE	*pbDst,
	*pbEndDst,
	*pbDstScanline = (BYTE*) 0,
	bFillVal;

    // Calculate the delta scan amount
    DstDeltaScan = DibWidthBytes(pbiDst);
    WidthBytes = DstDeltaScan;

    // Calculate the starting pixel address
    pbDstScanline = (BYTE*) pDst + XDst / 8 + YDst * WidthBytes;
    iPixelOffset = XDst % 8;

    // set up memory fill value
    if (crValue) {
	bFillVal = 0xFF;
    } else {
	bFillVal = 0;
    }

    // calculate how many bits of first byte we have to set, how many
    // full bytes to set, and how many bits of last byte to set on
    // each scanline
    if (iPixelOffset) {
	iStartPixels = 8 - iPixelOffset;
	iFullBytes = (nWidthDst - iStartPixels) / 8;
	iEndPixels = (nWidthDst - iStartPixels) % 8;
    } else {
	iStartPixels = 0;
	iFullBytes = nWidthDst / 8;
	iEndPixels = nWidthDst % 8;
    }		

    // loop to fill one scanline at a time
    for (y = 0; y < nHeightDst; y++) {

	// set pointer to beginning of scanline
	pbDst = pbDstScanline;

	// take care of pixels lying on a byte not entirely
	// in the scanline
	if (iStartPixels) {
	    if (nWidthDst >= iStartPixels) {
		if (bFillVal) {
		    *pbDst++ |= bBottomMask[iPixelOffset];
		} else {
		    *pbDst++ &= bTopMask[iPixelOffset];
		}
	    } else {
		if (bFillVal) {
		    *pbDst++ |= (bBottomMask[iPixelOffset] & 
				 bTopMask[iPixelOffset + nWidthDst]);
		} else {
		    *pbDst++ &= (bTopMask[iPixelOffset] | 
				 bBottomMask[iPixelOffset + nWidthDst]);
		}
	    }
	}

	// fill bytes filled entirely with pixels to be set
	pbEndDst = pbDst + iFullBytes;
	for (; pbDst != pbEndDst; pbDst++) {
	    *pbDst = bFillVal;
	}

	// take care of pixels hanging off other end into byte
	// not entirely on scanline
	if (iEndPixels) {
	    if (bFillVal) {
		*pbDst |= bTopMask[iEndPixels];
	    } else {
		*pbDst &= bBottomMask[iEndPixels];
	    }
	}
				
	pbDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect08 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	BYTE crValue	- Color index
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_FillRect08(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, BYTE crValue)
{
    DWORD	*pBigDstPixel,
	*pBigEndDstPixel;
    BYTE	*pDstScanline,
	*pDstPixel = (BYTE *)pDst,
	*pAlignedDstPixel;
    int		iNumDwordsPerLine = nWidthDst / 4,
	iNumBytesLeftDst = nWidthDst % 4,
	iNumUnalignedDstBytes = 0,
	i,j,
	iDstDeltaScan;
    register DWORD	dwValue = (DWORD)(crValue | (crValue << 8) | (crValue << 16) | (crValue <<24));


    // Calculate the delta scan amount
    iDstDeltaScan = (long)(pbiDst->bmiHeader.biWidth) * 8;
    iDstDeltaScan = ((iDstDeltaScan + 31) & (~31)) / 8;

    // Calculate the starting pixel address
    pDstScanline = (BYTE *)pDst + XDst + YDst * iDstDeltaScan;

    // If the num dwords per line is less than 0, then we will just
    // do a byte wise fill for the < 4 bytes
    if(iNumDwordsPerLine){
	// Find out if the src and dest pointers are dword aligned
	pAlignedDstPixel = (BYTE *)((((ULONG_PTR)pDstScanline) + 3) & (~3));
	iNumUnalignedDstBytes = (int)(pAlignedDstPixel - pDstScanline);

	// Now decrement the number of dwords per line and the
	// number of bytes left over as appropriate
	if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
	    iNumBytesLeftDst -= iNumUnalignedDstBytes;
	else{
	    iNumBytesLeftDst = sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
	    if(iNumBytesLeftDst != sizeof(DWORD))
		iNumDwordsPerLine--;
	}
    }

    // Do the fill
    for (i = 0; i < nHeightDst; i++) {
	// Set up the first pointer
	pDstPixel = pDstScanline;
	
	// First we need to copy the bytes to get to an aligned dword
	for(j=0; j<iNumUnalignedDstBytes; j++)
	    *pDstPixel++ = crValue;

	// set up pointers to the first 4-pixel chunks
	// on src and dst scanlines, and last chunk on
	// dst scanline
	pBigDstPixel = (DWORD*) pDstPixel;
	pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

	// copy scanline one 4-pixel chunk at a time
	while (pBigDstPixel != pBigEndDstPixel) {
	    *pBigDstPixel++ = dwValue;
	}

	// take care of remaining pixels on scanline
	if (iNumBytesLeftDst) {
	    pDstPixel = (BYTE*) pBigDstPixel;
	    for(j=0; j<iNumBytesLeftDst; j++){
		*pDstPixel++ = crValue;
	    }
	}

	// advance to next scanline
	pDstScanline += iDstDeltaScan;
    }

    return NO_ERROR;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect16 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	WORD crValue - ColorRef value (RGB 5-6-5)
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_FillRect16(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, WORD crValue)
{
    DWORD	*pBigDstPixel,
	*pBigEndDstPixel;
    WORD	*pDstScanline,
	*pDstPixel = (WORD *)pDst,
	*pAlignedDstPixel;
    int		iNumDwordsPerLine = nWidthDst / 2,
	iNumWordsLeftDst = nWidthDst % 2,
	iNumUnalignedDstWords = 0,
	i,j,
	iDstDeltaScan;
    register DWORD	dwValue = (DWORD)(crValue | (crValue << 16));


    // Calculate the delta scan amount
    iDstDeltaScan = (long)(pbiDst->bmiHeader.biWidth) * 16;
    iDstDeltaScan = ((iDstDeltaScan + 31) & (~31)) / 16;

    // Calculate the starting pixel address
    pDstScanline = (WORD *)pDst + XDst + YDst * iDstDeltaScan;

    // If the num dwords per line is less than 0, then we will just
    // do a word wise fill for the single pixel
    if(iNumDwordsPerLine){
	// Find out if the dest pointer is dword aligned
	pAlignedDstPixel = (WORD *)((((ULONG_PTR)pDstScanline) + 3) & (~3));
	iNumUnalignedDstWords = (int)(pAlignedDstPixel - pDstScanline);


	// Now decrement the number of dwords per line and the
	// number of bytes left over as appropriate
	if(iNumUnalignedDstWords <= iNumWordsLeftDst)
	    iNumWordsLeftDst -= iNumUnalignedDstWords;
	else{
	    iNumWordsLeftDst = (sizeof(DWORD)/2) - iNumUnalignedDstWords;
	    if(iNumWordsLeftDst != (sizeof(DWORD)/2))
		iNumDwordsPerLine--;
	}
    }


    // Do the fill
    for (i = 0; i < nHeightDst; i++) {
	// Set up the first pointer
	pDstPixel = pDstScanline;
	
	// First we need to copy the bytes to get to an aligned dword
	for(j=0; j<iNumUnalignedDstWords; j++)
	    *pDstPixel++ = crValue;

	// set up pointers to the first 4-pixel chunks
	// on src and dst scanlines, and last chunk on
	// dst scanline
	pBigDstPixel = (DWORD*) pDstPixel;
	pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

	// copy scanline one 4-pixel chunk at a time
	while (pBigDstPixel != pBigEndDstPixel) {
	    *pBigDstPixel++ = dwValue;
	}

	// take care of remaining pixels on scanline
	if (iNumWordsLeftDst) {
	    pDstPixel = (WORD *) pBigDstPixel;
	    for(j=0; j<iNumWordsLeftDst; j++){
		*pDstPixel++ = crValue;
	    }
	}

	// advance to next scanline
	pDstScanline += iDstDeltaScan;
    }

    return NO_ERROR;
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect24 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	RGBTRIPLE rgb	- RGBTRIPLE representing the fill color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_FillRect24(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, DWORD rgb)
{
    SCODE sc = NOERROR;
    long DstDeltaScan;
    char *pDstScanline = NULL;
    int x = 0;
    int y = 0;
    RGBTRIPLE *pDstPixel;
    RGBTRIPLE *pEndPixel;
    RGBTRIPLE rgbt;
    DWORD d1,d2,d3;

    // Set up rgbt (ignore the color names - they are meaningless)
    rgbt.rgbtBlue = (BYTE)(rgb & 0x0000ff); 
    rgbt.rgbtGreen = (BYTE)((rgb & 0x00ff00) >> 8);
    rgbt.rgbtRed = (BYTE)((rgb & 0xff0000) >> 16);

    // Calculate the number of pixels per scan line
    DstDeltaScan = DibWidthBytes(pbiDst);
	

    // Calculate the starting pixel address
    pDstScanline = ((char*)pDst) + (XDst*sizeof(RGBTRIPLE) + YDst * DstDeltaScan);

    // Set up aligned stores
    d1 = rgb | (rgb << 24);
    d2 = (rgb << 16) | (rgb >> 8);
    d3 = (rgb << 8) | (rgb >> 16);

    // Do the fill
    while (y < nHeightDst)
    {
	pDstPixel = (RGBTRIPLE*)pDstScanline;
	pEndPixel = pDstPixel + nWidthDst;

    while ( ((ULONG_PTR)pDstPixel & 0x03) && (pDstPixel < pEndPixel) )
	{
	    ((BYTE*)pDstPixel)[0] = ((BYTE*)&rgbt)[0];
	    ((BYTE*)pDstPixel)[1] = ((BYTE*)&rgbt)[1];
	    ((BYTE*)pDstPixel)[2] = ((BYTE*)&rgbt)[2];
	    pDstPixel++;
	}

	while (((ULONG_PTR)pDstPixel) <= (((ULONG_PTR)(pEndPixel-4)) & ~0x03))
	{
	    *(((DWORD*)pDstPixel)) = d1;
	    *(((DWORD*)pDstPixel)+1) = d2;
	    *(((DWORD*)pDstPixel)+2) = d3;
	    pDstPixel +=4;
	}

	while (pDstPixel < pEndPixel)
	{
	    ((BYTE*)pDstPixel)[0] = ((BYTE*)&rgbt)[0];
	    ((BYTE*)pDstPixel)[1] = ((BYTE*)&rgbt)[1];
	    ((BYTE*)pDstPixel)[2] = ((BYTE*)&rgbt)[2];
	    pDstPixel++;
	}

	++y;
	pDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect32 - 
//		Fill a rectangle in the specified DIB with the desired color.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_FillRect32(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, DWORD crValue)
{
    SCODE sc = NOERROR;
    long DstDeltaScan;
    long WidthDWords;
    DWORD *pDstScanline = (DWORD *) 0;
    int y = 0;
    DWORD *pDstPixel;
    DWORD *pEndPixel;

    // Calculate the delta scan amount
    DstDeltaScan = DibWidthBytes(pbiDst) >> 2; // don't trust the compile to deal with "/4"
    WidthDWords = DstDeltaScan;

    // Calculate the starting pixel address
    pDstScanline = (DWORD *)pDst + XDst + YDst * WidthDWords;

    // Do the fill
    while (y < nHeightDst)
    {
	pDstPixel = pDstScanline;
	pEndPixel = pDstPixel + nWidthDst;

	while (pDstPixel < pEndPixel)
	{
	    *pDstPixel = crValue;
	    pDstPixel++;
	}

	++y;
	pDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_WriteMaskFillRect32 - 
//   Fill a rectangle in the specified DIB with the desired color using a writemask
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//      dwWriteMask - write only those pixel bits that are turned on
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_WriteMaskFillRect32(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, DWORD crValue,DWORD dwWriteMask)
{
    SCODE sc = NOERROR;
    long DstDeltaScan;
    long WidthDWords;
    DWORD *pDstScanline = (DWORD *) 0;
    int y = 0;
    DWORD *pDstPixel;
    DWORD *pEndPixel;
    DWORD dwInvWriteMask;

    // Calculate the delta scan amount
    DstDeltaScan = DibWidthBytes(pbiDst) >> 2; // don't trust the compiler to deal with "/4"
    WidthDWords = DstDeltaScan;

    // Calculate the starting pixel address
    pDstScanline = (DWORD *)pDst + XDst + YDst * WidthDWords;

    crValue&=dwWriteMask;  // turn off bits in fill value that wont be used
    dwInvWriteMask= ~dwWriteMask;  // will turn off bits to be overwritten in DstPixel 

    // Do the fill
    while (y < nHeightDst)
    {
	pDstPixel = pDstScanline;
	pEndPixel = pDstPixel + nWidthDst;

	while (pDstPixel < pEndPixel)
	{
	    *pDstPixel = (*pDstPixel & dwInvWriteMask) | crValue;
	    pDstPixel++;
	}

	++y;
	pDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_WriteMaskFillRect16 - 
//   Fill a rectangle in the specified DIB with the desired color using a writemask
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//      wWriteMask - write only those pixel bits that are turned on
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete / UNTESTED!!!!
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_WriteMaskFillRect16(PDIBINFO pbiDst, PDIBBITS pDst, int XDst, int YDst,
			 int nWidthDst, int nHeightDst, WORD crValue,WORD wWriteMask)
{
    SCODE sc = NOERROR;
    long DstDeltaScan;
    long WidthDWords;
    WORD *pDstScanline = (WORD *) 0;
    int y = 0;
    WORD *pDstPixel;
    WORD *pEndPixel;
    WORD wInvWriteMask;

    // Calculate the delta scan amount
    DstDeltaScan = DibWidthBytes(pbiDst) >> 1; // don't trust the compiler to deal with "/2"
    WidthDWords = DstDeltaScan;

    // Calculate the starting pixel address
    pDstScanline = (WORD *)pDst + XDst + YDst * WidthDWords;

    crValue &= wWriteMask;  // turn off bits in fill value that wont be used
    wInvWriteMask= ~wWriteMask;  // will turn off bits to be overwritten in DstPixel 

    // Do the fill
    while (y < nHeightDst)
    {
	pDstPixel = pDstScanline;
	pEndPixel = pDstPixel + nWidthDst;

	while (pDstPixel < pEndPixel)
	{
	    *pDstPixel = (*pDstPixel & wInvWriteMask) | crValue;
	    pDstPixel++;
	}

	++y;
	pDstScanline += DstDeltaScan;
    }

    return sc;
}

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BitBlt - 
//		Select the correct BitBlit and call it.
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	crTransparent		Tranparent color value
//	arAlpha				Per-surface Alpha value
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
DWORD gdwUnusedBitsMask;

SCODE BlitLib_BitBlt(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		     PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		     PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop)
{
    SCODE	sc = NOERROR;
    DWORD	dwBltConvType;
    RECT	rcSrc = *prcSrc,
	rcDst = *prcDst;
    
    // Make sure that destination rect is at least one pixel wide and tall.
    // Important!  Without this check we're vulnerable to divide by zero
    // errors in the blit routines.
    if ((BLITLIB_RECTWIDTH(&rcDst) == 0) || 
	(BLITLIB_RECTHEIGHT(&rcDst) == 0)) {
	return sc;
    }

    /*
     * Set unused pixel mask to default for all non RGBA blts"
     */
    gdwUnusedBitsMask = 0xffffff;
    if (((LPBITMAPINFO)pDibInfoSrc)->bmiHeader.biCompression==BI_BITFIELDS &&
        ((LPBITMAPINFO)pDibInfoSrc)->bmiHeader.biBitCount==32)
    {
        gdwUnusedBitsMask =
            *(DWORD*)&((LPBITMAPINFO)pDibInfoSrc)->bmiColors[0] |
            *(DWORD*)&((LPBITMAPINFO)pDibInfoSrc)->bmiColors[1] |
            *(DWORD*)&((LPBITMAPINFO)pDibInfoSrc)->bmiColors[2];
    }

    
    // Figure out the Blt Conversion type
    dwBltConvType = MAKELONG(GetImageFormatSpecifier(DibCompression(pDibInfoDst),
						     DibBitCount(pDibInfoDst)),
			     GetImageFormatSpecifier(DibCompression(pDibInfoSrc),
						     DibBitCount(pDibInfoSrc)));
    switch (dwBltConvType) {
    case BLT_01TO01:
	sc |= BlitLib_BitBlt01to01(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #ifndef DDRAW
    case BLT_01TO08:
	sc |= BlitLib_BitBlt01to08(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_01TO24:
	sc |= BlitLib_BitBlt01to24(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_08TO01:
	sc |= BlitLib_BitBlt08to01(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #endif // DDRAW
    case BLT_08TO08:
	sc |= BlitLib_BitBlt08to08(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #ifndef DDRAW
    case BLT_08TO24:
	sc |= BlitLib_BitBlt08to24(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_08TO24P:
	sc |= BlitLib_BitBlt08to24P(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_08ATO08A:
	sc |= BlitLib_BitBlt08Ato08A(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    case BLT_08ATO24:
	sc |= BlitLib_BitBlt08Ato24(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_08ATO24P:
	sc |= BlitLib_BitBlt08Ato24P(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    #endif // DDRAW
    case BLT_16TO16:
	sc |= BlitLib_BitBlt16to16(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #ifndef DDRAW
    case BLT_16TO24:
	sc |= BlitLib_BitBlt16to24(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_16TO24P:
	sc |= BlitLib_BitBlt16to24P(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_24TO01:
	sc |= BlitLib_BitBlt24to01(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_24PTO01:
	sc |= BlitLib_BitBlt24Pto01(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_24TO08:
	sc |= BlitLib_BitBlt24to08(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    case BLT_24PTO08:
	sc |= BlitLib_BitBlt24Pto08(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    #endif // DDRAW
    case BLT_24TO24:
	sc |= BlitLib_BitBlt24to24(pDibInfoDst,pDibBitsDst,&rcDst,
				   pDibInfoSrc,pDibBitsSrc,&rcSrc,
				   crTransparent,arAlpha,dwRop);
	break;
    #ifndef DDRAW
    case BLT_24TO24P:
	sc |= BlitLib_BitBlt24to24P(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_24ATO24:
	sc |= BlitLib_BitBlt24Ato24(pDibInfoDst,pDibBitsDst,&rcDst,
				    pDibInfoSrc,pDibBitsSrc,&rcSrc,
				    crTransparent,arAlpha,dwRop);
	break;
    case BLT_24ATO24P:
	sc |= BlitLib_BitBlt24Ato24P(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    case BLT_24ATO24A:
	sc |= BlitLib_BitBlt24Ato24A(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    #endif // DDRAW
    case BLT_24PTO24P:
	sc |= BlitLib_BitBlt24Pto24P(pDibInfoDst,pDibBitsDst,&rcDst,
				     pDibInfoSrc,pDibBitsSrc,&rcSrc,
				     crTransparent,arAlpha,dwRop);
	break;
    default:
	sc |= E_UNEXPECTED;	// !!!! Need better error codes!
    } 
    
    return sc;
}

#define DPF_MODNAME BlitLib_WriteMaskFillRect
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_WriteMaskFillRect - 
//		Select the correct WriteMaskFillRect and call it.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//      DWORD - dwWriteMask: 1's indicate bits that can be overwritten in pixel
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete 
//
///////////////////////////////////////////////////////////////////////

SCODE BlitLib_WriteMaskFillRect(PDIBINFO pbiDst, PDIBBITS pDst,
		       RECT * pRect, COLORREF crColor, DWORD dwWriteMask)
{
    SCODE	sc = NOERROR;
    int		nWidthDst, nHeightDst;
    
    if (!pbiDst || !pDst || !pRect) {
	sc |= E_UNEXPECTED;
	goto ERROR_EXIT;
    }
    
    nWidthDst = BLITLIB_RECTWIDTH(pRect);
    nHeightDst = BLITLIB_RECTHEIGHT(pRect);
    
    switch (GetImageFormatSpecifier(DibCompression(pbiDst),
				    DibBitCount(pbiDst)))
    {	
    
    case BPP_24_RGB:
	sc |= BlitLib_WriteMaskFillRect32(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crColor,dwWriteMask);
	break;

    case BPP_16_RGB:
	sc |= BlitLib_WriteMaskFillRect16(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, (WORD) crColor, (WORD) dwWriteMask);
        break;
    case BPP_8_PALETTEIDX:
    case BPP_24_RGBPACKED:  // dont need these now because only stencil fmt is 32-bit (24-8)
        return E_NOTIMPL;

    case BPP_1_MONOCHROME:
    case BPP_16_8WALPHA:
    case BPP_32_24WALPHA:
    case BPP_16_YCRCB:
    case BPP_INVALID:
    default:
	sc |= E_UNEXPECTED;	
    } 
    // fall through
ERROR_EXIT:
    return sc;
}
#undef DPF_MODNAME

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_FillRect - 
//		Select the correct FillRect and call it.
//
// Parameters:
//	PDIBINFO pbiDst - Pointer to DIB header
//	PDIBBITS pDst   - Pointer to DIB Bits
//	int XDst		- X Destination Start Position
//	int YDst		- Y Destination Start Position
//	int nWidthDst	- Width
//	int nHeightDst	- Height
//	COLORREF crValue - ColorRef value (RGB Quad)
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Complete 
// NOTES: Put in a call to Gunter's super fast fill code instead!
//
///////////////////////////////////////////////////////////////////////

SCODE BlitLib_FillRect(PDIBINFO pbiDst, PDIBBITS pDst,
		       RECT * pRect, COLORREF crColor)
{
    SCODE	sc = NOERROR;
    int		nWidthDst, nHeightDst;
    
    if (!pbiDst || !pDst || !pRect) {
	sc |= E_UNEXPECTED;
	goto ERROR_EXIT;
    }
    
    nWidthDst = BLITLIB_RECTWIDTH(pRect);
    nHeightDst = BLITLIB_RECTHEIGHT(pRect);
    
    switch (GetImageFormatSpecifier(DibCompression(pbiDst),
				    DibBitCount(pbiDst)))
    {	
    case BPP_1_MONOCHROME:
    {
	BYTE crValue = (BYTE)crColor;
	sc |= BlitLib_FillRect01(pbiDst, pDst, pRect->left,
				 pRect->top,	nWidthDst,nHeightDst, crValue);
    }
    break;
    
    case BPP_8_PALETTEIDX:
    {
	BYTE crValue = (BYTE)crColor;
	
	sc |= BlitLib_FillRect08(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crValue);
    }
    break;
    
    case BPP_16_RGB:
    {
	WORD	crValue = (WORD)crColor;
	
	sc |= BlitLib_FillRect16(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crValue);
    }
    break;
    
    case BPP_24_RGBPACKED:
	sc |= BlitLib_FillRect24(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crColor);
	break;
	
    case BPP_24_RGB:
	sc |= BlitLib_FillRect32(pbiDst, pDst, pRect->left,
				 pRect->top, nWidthDst, nHeightDst, crColor);
	break;
	
    case BPP_16_8WALPHA:
    case BPP_32_24WALPHA:
    case BPP_16_YCRCB:
    case BPP_INVALID:
    default:
	sc |= E_UNEXPECTED;	
    } 
    // fall through
ERROR_EXIT:
    return sc;
}



///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_PatBlt - 
//		Fill an entire destination rectangle by tiling a given bitmap
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	prcSrc				Pointer to the Source rectangle
//	dwRop				Raster Operation for the blit
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////

    SCODE BlitLib_PatBlt(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
			 PRECT prcDst, PDIBINFO pDibInfoPat, PDIBBITS pDibBitsPat,
			 PRECT prcPat, COLORREF crTransparent, ALPHAREF arAlpha,
			 DWORD dwRop)
	{
	    SCODE	sc = NOERROR;
	    long	iPatWidth;
	    long	iPatHeight;
	    long	iCurXPos;
	    long	iCurYPos;
	    long	iBlitWidth;
	    long	iBlitHeight;
	    long	iWidthLeft;
	    long	iHeightLeft;
	    RECT	rcPat = {0,0,0,0};
	    RECT	rcDst = {0,0,0,0};

	
	    // Check for invalid rectangles -- PatBlt only works for rects that
	    // are both (src and dest) right-side up (positive height and width).
	    // Also set our bounding rectangle sizes in the process
	    if(((iPatWidth = BLITLIB_RECTWIDTH(prcPat)) < 0)
	       || ((iPatHeight = BLITLIB_RECTHEIGHT(prcPat)) < 0)
	       || (BLITLIB_RECTWIDTH(prcDst) < 0)
	       || (BLITLIB_RECTHEIGHT(prcDst) < 0))
		return E_INVALIDARG;
	
	    // Reset the Y postion to the top edge of the dest
	    iCurYPos = prcDst->top;

	    // Tile the pattern into the destination rectangle
	    while (iCurYPos < prcDst->bottom){
		// Set up the source rectangle heights
		rcPat.top = iCurYPos % iPatHeight;
		iHeightLeft = (prcDst->bottom - iCurYPos);

		// Calculate the height we are actually going to blit
		iBlitHeight = min(iHeightLeft, (iPatHeight - rcPat.top));

		rcPat.bottom = rcPat.top + iBlitHeight;

		// Set up the destination rectangle heights
		rcDst.top = iCurYPos;
		rcDst.bottom = iCurYPos + iBlitHeight;

		// Reset the current X position to the left edge of the dest
		iCurXPos = prcDst->left;

		// Tile the pattern into the destination rectangle
		while (iCurXPos < prcDst->right){
		    // Set up the source rectangle width
		    rcPat.left = iCurXPos % iPatWidth;
		    iWidthLeft = (prcDst->right - iCurXPos);

		    // Calculate the width we are actually going to blit
		    iBlitWidth = min(iWidthLeft, (iPatWidth - rcPat.left));

		    rcPat.right = rcPat.left + iBlitWidth;

		    // Set up the destination rectangle heights
		    rcDst.left = iCurXPos;
		    rcDst.right = iCurXPos + iBlitWidth;

		    // REVIEW!!!! -- Do we want to check sc after each blit and return on an error?
		    sc = BlitLib_BitBlt(pDibInfoDst, pDibBitsDst, &rcDst, pDibInfoPat,
					pDibBitsPat, &rcPat, crTransparent, arAlpha,
					dwRop);

		    // Increment the current index value
		    iCurXPos += iBlitWidth;
		} 

		// Increment the current index value
		iCurYPos += iBlitHeight;
	    } 
	

	    return sc;
	}



///////////////////////////////////////////////////////////////////////
//
// Private GetImageFormatSpecifier - 
//		Select the correct bitmap format based on the compression and
//		bit count.
//
// Parameters:
//	dwDibComp		- The DIB's compression
//	wdBitCount		- The DIB's bit count
//
// Return Value:
//  BPP_INVALID or a valid bitmap format
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
WORD GetImageFormatSpecifier(DWORD dwDibComp, WORD wdBitCount)
{
    // Bit count could have Penguin codes in the high byte, mask them 
    // out for a correct comparison.
    wdBitCount &= 0x00ff;

    switch (dwDibComp)
    {
    case BI_RGB:
	switch (wdBitCount)
	{
	case 1:
	    return BPP_1_MONOCHROME;
	case 8:
	    return BPP_8_PALETTEIDX;
	case 16:
	    return BPP_16_RGB;
	case 24:
	    return BPP_24_RGBPACKED;
	case 32:
	    return BPP_24_RGB;
	default:
	    return BPP_INVALID;
	}
    case BI_RGBA:
	switch (wdBitCount)
	{
	case 16:
	    return BPP_16_8WALPHA;
	case 32:
	    return BPP_32_24WALPHA;
	default:
	    return BPP_INVALID;
	}
    case BI_BITFIELDS:
	switch (wdBitCount)
	{
	case 16:
	    return BPP_16_RGB;	// BlitLib assumes 5-6-5 RGB
	case 32:
	    return BPP_24_RGB;
	default:
	    return BPP_INVALID;
	}
    case BI_YCRCB:
	return BPP_16_YCRCB;

    default:
	switch (wdBitCount)
	{
	case 1:
	    return BPP_1_MONOCHROME;
	default:
	    return BPP_INVALID;
	}
    }

    return BPP_INVALID;
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_PalIndexFromRGB - 
//		Calculates the closest entry in an array of COLORREF's to a
//		given COLORREF
//
// Parameters:
//	crColor			- Color to match
//	rgcrPal			- Array of colors to match to
//	iNumPalColors	- Number of colors in the array
//
// Return Value:
//  Palette index of the nearest color
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
BYTE BlitLib_PalIndexFromRGB(COLORREF crColor,COLORREF* rgcrPal,
			     unsigned int iNumPalColors)
{
    BYTE 	bIndex = 0;
    int		iRed = crColor & RED_MASK,
	iRedError,
	iGreen = (crColor & GREEN_MASK) >> 8,
	iGreenError,
	iBlue = (crColor & BLUE_MASK) >> 16,
	iBlueError,
	iError,
	iLeastError = MAX_POS_INT;

    for (unsigned int i = 0; i < iNumPalColors; i++) {
	iRedError = iRed - (rgcrPal[i] & RED_MASK);
	iGreenError = iGreen - ((rgcrPal[i] & GREEN_MASK) >> 8);
	iBlueError = iBlue - ((rgcrPal[i] & BLUE_MASK) >> 16);
	iError = iRedError * iRedError + iGreenError * iGreenError +
	    iBlueError * iBlueError;
	if (iError < iLeastError) {
	    iLeastError = iError;
	    bIndex = (BYTE) i;
	}
    }

    return bIndex;
}
#endif // DDRAW

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_BLIT_BLEND24 - 
//		Performs alpha blending on 24bpp(packed) blits.
//
// Parameters:
//	ptSrc			- Pointer to the Source RGBTRIPLE
//	ptDst			- Pointer to the Destination RGBTRIPLE
//	alpha			- Alpha value (Range: 1 - 256)
//	alphacomp		- Alpha complement (256 - alpha)
//
// Return Value:
//  None
// 
///////////////////////////////////////////////////////////////////////
void BlitLib_BLIT_BLEND24(COLORREF crSrc, RGBTRIPLE * ptDst,
			  UINT alpha, UINT alphacomp)
{
    BYTE *	pbSrc = (BYTE *)&crSrc;
    BYTE *	pbDst = (BYTE *)ptDst;
    DWORD 	dwSrc;
    DWORD 	dwDst;
    UINT	i;

    for(i=0; i<sizeof(RGBTRIPLE); i++){
	dwSrc = (DWORD)*pbSrc++;
	dwDst = (DWORD)*pbDst;

	dwDst = ((dwSrc * alpha + dwDst * alphacomp) >> 8);
	*pbDst++ = (BYTE)dwDst;
    }
}

#endif

///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_Detect_Intersection - 
//		Detects if both the source and destination bitmaps overlap
//
// Parameters:
//	pdibbitsDst		- Pointer to the Destination Bits
//	prcDst			- Pointer to the Destination Rectangle
//	pdibbitsSrc		- Pointer to the Source Bits
//	prcSrc			- Pointer to the Source Rectangle
//	
//
// Return Value:
//  TRUE if the bitmaps overlap, FALSE if they do not
// 
///////////////////////////////////////////////////////////////////////
BOOL BlitLib_Detect_Intersection (PDIBBITS pdibbitsDst, PRECT prcDst,
				  PDIBBITS pdibbitsSrc, PRECT prcSrc)
{
    RECT	rc,
	rcSrc,
	rcDst;
	
    // First check to see if the pdibbits pointers point to the same bitmap
    if(pdibbitsDst != pdibbitsSrc)
	return FALSE;

    // REVIEW!!! - This is just a hack because IntersectRect expects
    // bitmaps to be oriented correctly, but I can't afford to do
    // it to my original prects yet
    rcSrc.left = prcSrc->left;
    rcSrc.top = prcSrc->top;
    rcSrc.right = prcSrc->right;
    rcSrc.bottom = prcSrc->bottom;

    rcDst.left = prcDst->left;
    rcDst.top = prcDst->top;
    rcDst.right = prcDst->right;
    rcDst.bottom = prcDst->bottom;

    if (BLITLIB_RECTWIDTH(&rcSrc) < 0)
	FlipRectHorizontal(&rcSrc);
    if (BLITLIB_RECTHEIGHT(&rcSrc) < 0)
	FlipRectVertical(&rcSrc);
    if (BLITLIB_RECTWIDTH(&rcDst) < 0)
	FlipRectHorizontal(&rcDst);
    if (BLITLIB_RECTHEIGHT(&rcDst) < 0)
	FlipRectVertical(&rcDst);
	
    // Now check for rectangle intersection
    return IntersectRect(&rc, &rcDst, &rcSrc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\bitblt.h ===
///////////////////////////////////////////////////////////////////////
//
//  BitBlt.H - Contains the BitBlt prototypes
//
//	Copyright (c) 1994 Microsoft Corporation
//
//	History:
//		10/18/94 - Scott Leatham Created it w/8BPP support only
//		10/19/94 - Olivier Garamfalvi Chopped out unneeded stuff
//		05/30/95 - Myron Thomas Code clean up
//
///////////////////////////////////////////////////////////////////////

#ifdef NT_BUILD_ENVIRONMENT
    typedef ULONG SCODE;
    typedef long HRESULT;
#endif

#ifdef MMOSA
//#include <pshpack1.h>
typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE;
//#include <poppack.h>
#endif

// Bits Per Pixel Formats
// 	  HIBYTE=Penguin Image Format specifier, FF = not supported by Penguin
// 	  LOBYTE=PhysicalBitsPerPixel, FF = not support by bitblt
#define BPP_MSK_BITCOUNT	0x00ff	// Get the bitcount from a BPP_ constant
#define BPP_MSK_IMAGECODE	0xff00	// Get the Penguin IMage code from a BPP_ constant
#define BPP_INVALID			0xffff	// LO = 256 & HI = 256 =  Bad format
#define BPP_1_MONOCHROME	0xff01	// LO = 256 bpp, HI = 1 bit monochrome not supported on Penguin
#define BPP_2_4GRAYSCALE	0xff02	// LO = 256 bpp, HI = 2 bits 4 shades of gray not supported on Penguin
#define BPP_4_16GRAYSCALE	0xff04	// LO = 256 bpp, HI = 4 bits 16 shades of gray not supported on Penguin
#define BPP_8_PALETTEIDX	0x0008	// LO = 8  bpp, HI = Penguin H/W code 000 = 8 bits 256 colors palette indexed
#define BPP_16_FILLSPAN		0x01FF	// LO = 256bpp, HI = Penguin H/W code 001 (SrcAdr of span desc. if used as an RGB value
#define BPP_16_8WALPHA		0x0510	// LO = 16 bpp, HI = Penguin H/W code 101 = 8 bits 256 colors palette indexed, 8 bits alpha
#define BPP_16_RGB			0x0610	// LO = 16 bpp, HI = Penguin H/W code 110 = 16 bits used for RGB in 5-6-5 format
#define BPP_16_YCRCB		0x0710	// LO = 16 bpp, HI = Penguin H/W code 111 = 16 bits Cr Cb Sample and subsample 2 bytes at a time
#define BPP_24_RGBPACKED	0xff18	// LO = 256 bpp, HI = 24 bit RGB not supported by Penguin
#define BPP_24_RGB			0x0220	// LO = 32 bpp, HI = Penguin H/W code 010 = 24 bits used for RGB color and 8 empty bits
#define BPP_32_24WALPHA		0x0320	// LO = 32 bpp, HI = Penguin H/W code 011 = 24 bits used for RGB color and 8 bit alpha byte
// New Bit Compression Values:
#define BI_RGBA				4L
#define BI_YCRCB			5L

#ifdef __cplusplus
extern "C" {
#endif 
	
SCODE BlitLib_BitBlt(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha,
		DWORD dwRop);

SCODE BlitLib_FillRect(PDIBINFO pbiDst, PDIBBITS pDst,
		RECT * pRect, COLORREF crValue);

SCODE BlitLib_WriteMaskFillRect(PDIBINFO pbiDst, PDIBBITS pDst,
		RECT * pRect, COLORREF crValue, DWORD dwWritemask);

SCODE BlitLib_Chunk32_BitBlt08to08(PDIBINFO pDibInfoDst,
		PDIBBITS pDibBitsDst, PRECT prcDst, PDIBINFO pDibInfoSrc,
		PDIBBITS pDibBitsSrc);

SCODE BlitLib_Chunk32_BitBlt08to08_Trans(PDIBINFO pDibInfoDst,
		PDIBBITS pDibBitsDst, PRECT prcDst, PDIBINFO pDibInfoSrc,
		PDIBBITS pDibBitsSrc, COLORREF crTransparent);

SCODE BlitLib_PatBlt(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoPat, PDIBBITS pDibBitsPat,
		PRECT prcPat, COLORREF crTransparent, ALPHAREF arAlpha,
		DWORD dwRop);


#ifdef __cplusplus
	}
#endif 

SCODE BlitLib_BitBlt01to01(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt01to08(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt01to24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08to01(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08to08(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08to24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08to24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08Ato24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08Ato24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt08Ato08A(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt16to16(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt16to24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt16to24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24to01(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Pto01(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24to08(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Pto08(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24to24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24to24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Ato24(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Ato24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Ato24A(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_BitBlt24Pto24P(PDIBINFO pDibInfoDest, PDIBBITS pDibBitsDest,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc,
		PRECT prcSrc, COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

SCODE BlitLib_FillRect01(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		BYTE crValue);

SCODE BlitLib_FillRect08(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		BYTE crValue);

SCODE BlitLib_FillRect16(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		WORD crValue);

SCODE BlitLib_FillRect24(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		DWORD rgb);

SCODE BlitLib_FillRect32(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		DWORD crValue);

SCODE BlitLib_WriteMaskFillRect32(PDIBINFO pbiDst, PDIBBITS pDst,
		int XDst, int YDst, int nWidthDst, int nHeightDst,
		DWORD crValue, DWORD dwWriteMask);

BOOL BlitLib_Detect_Intersection (PDIBBITS pdibbitsDst, PRECT prcDst,
								PDIBBITS pdibbitsSrc, PRECT prcSrc);

SCODE BlitLib_BitBlt08to08_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
		COLORREF crTransparent, DWORD dwRop);

SCODE BlitLib_BitBlt16to16_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
		COLORREF crTransparent, DWORD dwRop);

SCODE BlitLib_BitBlt24Pto24P_Intersect(PDIBINFO pDibInfoDst, PDIBBITS pDibBitsDst,
		PRECT prcDst, PDIBINFO pDibInfoSrc, PDIBBITS pDibBitsSrc, PRECT prcSrc,
		COLORREF crTransparent, ALPHAREF arAlpha, DWORD dwRop);

// function used to calculate the closest entry in an array of
// COLORREFs to a given COLORREF
BYTE BlitLib_PalIndexFromRGB(COLORREF crColor,COLORREF* rgcrPal,
		unsigned int iNumPalColors);

// Based on Dib Compression type and Bit Count find a matching BPP_*
WORD GetImageFormatSpecifier(DWORD dwDibComp, WORD wdBitCount);

#ifndef DDRAW
// BLIT_BLEND_24 -- used to alpha blend to 24bpp(packed) destinations
void BlitLib_BLIT_BLEND24(COLORREF crSrc, RGBTRIPLE * ptDst,
							UINT alpha, UINT alphacomp);
#endif

// similar macros are defined in idib.hxx, be careful in changing these
#define BLITLIB_RECTWIDTH(prc)  ((prc)->right  - (prc)->left)
#define BLITLIB_RECTHEIGHT(prc) ((prc)->bottom - (prc)->top )
#define BLITLIB_RECTORIGINX(prc) ((prc)->left)
#define BLITLIB_RECTORIGINY(prc) ((prc)->top)
#define BLITLIB_RECTORIGINPT(prc) ((POINT *)(prc))

// masks that define what's stored in a DWORD-sized pixel
#define RED_MASK		0x000000FF
#define GREEN_MASK		0x0000FF00
#define BLUE_MASK		0x00FF0000
#define ALPHA_MASK		0x000000FF
#define NOALPHA_MASK	0xFFFFFF00
#define PERPIX_ALPHA_MASK	0xFF000000

/*
 * PROBLEM for RGBA surfaces:
 * The way it used to be:
        #define UNUSED_MASK		0x00FFFFFF
 */
#define UNUSED_MASK		gdwUnusedBitsMask
extern DWORD gdwUnusedBitsMask;


// masks that define what's inside a WORD-sized pixel
#define RED_MASK16		0x001F
#define GREEN_MASK16	0x07E0
#define BLUE_MASK16		0xF800

// scottle 1bbp is not a Penguin supported format, ff must be specified in the high bytes of
//		both the hi & lo words.
#define BLT_01TO01	0xff01ff01	// Src (hiword) = 1 Dst (loword) = 1
#define BLT_01TO08	0xff010008	// Src (hiword) = 1 Dst (loword) = 8
#define BLT_01TO24	0xff010220	// Src (hiword) = 1 Dst (loword) = 32 (20hex)
#define BLT_08TO01	0x0008ff01	// Src (hiword) = 8 Dst (loword) = 1
// andyco 24 bit dibs are actually 32 bits (888 rgb, + 8 unused). Penguin is the 0x2 preface.
#define BLT_08TO08  0x00080008	// Src (hiword) = 8 Dst (loword) = 8
#define BLT_08TO24	0x00080220	// Src (hiword) = 8 Dst (loword) = 32 (20hex)
#define BLT_08TO24P	0x0008ff18	// Src (hiword) = 8 Dst (loword) = 24 (18hex)
#define BLT_08ATO08A 0x05100510	// Src (hiword) = 16 (10hex) Dst (loword) = 16 (10hex)
#define BLT_08ATO24	0x05100220	// Src (hiword) = 16 (10hex) Dst (loword) = 32 (20hex)
#define BLT_08ATO24P 0x0510ff18	// Src (hiword) = 16 (10hex) Dst (loword) = 24 (18hex)
#define BLT_16TO16	0x06100610	// Src (hiword) = 16 (10hex) Dst (loword) = 16 (10hex)
#define BLT_16TO24	0x06100220	// Src (hiword) = 16 (10hex) Dst (loword) = 32 (20hex)
#define BLT_16TO24P	0x0610ff18	// Src (hiword) = 16 (10hex) Dst (loword) = 24 (18hex)
#define BLT_24TO01	0x0220ff01	// Src (hiword) = 32 (20hex) Dst (loword) = 1
#define BLT_24PTO01	0xff18ff01	// Src (hiword) = 24 (18hex) Dst (loword) = 1
#define BLT_24TO08	0x02200008	// Src (hiword) = 32 (20hex) Dst (loword) = 8
#define BLT_24PTO08	0xff180008	// Src (hiword) = 32 (20hex) Dst (loword) = 8
#define BLT_24TO24	0x02200220	// Src (hiword) = 32 (20hex) Dst (loword) = 32 (20hex)
#define BLT_24TO24P	0x0220ff18	// Src (hiword) = 32 (20hex) Dst (loword) = 24 (18hex)
#define BLT_24ATO24	0x03200220	// Src (hiword) = 32 (20hex) Dst (loword) = 32 (20hex)
#define BLT_24ATO24P 0x0320ff18	// Src (hiword) = 32 (20hex) Dst (loword) = 24 (18hex)
#define BLT_24ATO24A 0x03200320	// Src (hiword) = 32 (20hex) Dst (loword) = 32 (20hex)
#define BLT_24PTO24P 0xff18ff18	// Src (hiword) = 24 (18hex) Dst (loword) = 24 (18hex)

// macro used to blend src and dst together.  "alpha" should range 1...256
// alphacomp = 256 - alpha.	Used for 24bpp
#define BLIT_BLEND(src,dst,alpha,alphacomp) \
	(((((src) & BLUE_MASK)  * (alpha) + ((dst) & BLUE_MASK) \
		* (alphacomp)) >> 8) & BLUE_MASK) | \
	(((((src) & GREEN_MASK) * (alpha) + ((dst) & GREEN_MASK) \
		* (alphacomp)) >> 8) & GREEN_MASK) | \
	(((((src) & RED_MASK)   * (alpha) + ((dst) & RED_MASK) \
		* (alphacomp)) >> 8) & RED_MASK) 
#ifndef DDRAW
// macro used to blend src and dst together.  "alpha" should range 1...256
// alphacomp = 256 - alpha. Used for 16bpp
#define BLIT_BLEND16(src,dst,alpha,alphacomp) \
	((WORD) ((((((DWORD) (src) & BLUE_MASK16)  * (alpha) + \
        ((DWORD) (dst) & BLUE_MASK16)  * (alphacomp)) >> 8) & BLUE_MASK16) | \
     (((((DWORD) (src) & GREEN_MASK16) * (alpha) + \
        ((DWORD) (dst) & GREEN_MASK16) * (alphacomp)) >> 8) & GREEN_MASK16) | \
     (((((DWORD) (src) & RED_MASK16)   * (alpha) + \
        ((DWORD) (dst) & RED_MASK16)   * (alphacomp)) >> 8) & RED_MASK16)))
#endif

#define BLIT_COLOR16_FROM_COLORREF(cr) \
	((WORD) ((((cr) >> 8) & BLUE_MASK16) | (((cr) >> 5) & \
		GREEN_MASK16) | (((cr) >> 3) & RED_MASK16)))

#define BLIT_COLORREF_FROM_COLOR16(w) \
	((DWORD) ((((w) & BLUE_MASK16) << 8) | (((w) & GREEN_MASK16) << 5) | \
		(((w) & RED_MASK16) << 3)))

#define MAX_POS_INT		0x7FFFFFFF

#define ALPHAFROMDWORD(a) ((a & ALPHA_MASK) + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\blt2424.cxx ===
#include "precomp.hxx"



void Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									DWORD* pdDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel,
			*pdEndDstPixel,
			*pdEndDstScanLine;

	// set up pointer to next dst scanline beyond last
	pdEndDstScanLine = pdDstScanLine + iNumDstRows * iDstScanStride;

	while (pdDstScanLine != pdEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		pdEndDstPixel = pdDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pdDstPixel != pdEndDstPixel) {
			*pdDstPixel++ = *pdSrcPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanStride;
		pdDstScanLine += iDstScanStride;
	}
}

void Blt24to24_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									DWORD* pdDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel,
			*pdEndDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to first pixels on src and dst
		// scanlines, and next pixel after last on dst
	 	pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		pdEndDstPixel = pdDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pdDstPixel != pdEndDstPixel) {
			*pdDstPixel++ = *pdSrcPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_NoBlend_NoTrans_NoHcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
									DWORD* pdDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									int iHorizMirror)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
			*pdDstPixel = *pdSrcPixel;

			// advance to next pixel
			pdSrcPixel += iSrcPixelAdvance;
			pdDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pdSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_NoBlend_Trans_Hcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									DWORD* pdDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									COLORREF crTransparent)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if ((*pdSrcPixel ^ (DWORD) crTransparent) & UNUSED_MASK) {
				*pdDstPixel = *pdSrcPixel;
			}
			pdSrcPixel++;
			pdDstPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_NoBlend_Trans_NoHcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    COLORREF crTransparent)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if ((*pdSrcPixel ^ (DWORD) crTransparent) & UNUSED_MASK) {
				*pdDstPixel = *pdSrcPixel;
			}

			// advance to next pixel
			pdSrcPixel += iSrcPixelAdvance;
			pdDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pdSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
#ifndef DDRAW 
void Blt24to24_Blend_NoTrans_Hcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
                                    int iSrcScanStride,
									int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
									ALPHAREF arAlpha)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel,
			*pdEndDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to first pixels on src and dst
		// scanlines, and next pixel after last on dst
	 	pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		pdEndDstPixel = pdDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pdDstPixel != pdEndDstPixel) {
			*pdDstPixel++ = BLIT_BLEND(*pdSrcPixel,*pdDstPixel,
										uiAlpha,uiAlphaComp);
			pdSrcPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_Blend_NoTrans_NoHcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
									ALPHAREF arAlpha)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
 			*pdDstPixel = BLIT_BLEND(*pdSrcPixel,*pdDstPixel,
 										uiAlpha,uiAlphaComp);

			// advance to next pixel
			pdSrcPixel += iSrcPixelAdvance;
			pdDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pdSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_Blend_Trans_Hcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
                                    int iSrcScanStride,
								    int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    COLORREF crTransparent,
									ALPHAREF arAlpha)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if ((*pdSrcPixel ^ (DWORD) crTransparent) & UNUSED_MASK){
				*pdDstPixel = BLIT_BLEND(*pdSrcPixel,*pdDstPixel,
											uiAlpha,uiAlphaComp);
			}
			pdSrcPixel++;
			pdDstPixel++;
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt24to24_Blend_Trans_NoHcopy_SRCCOPY(
									DWORD* pdSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    DWORD* pdDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    COLORREF crTransparent,
									ALPHAREF arAlpha)
{
	DWORD	*pdSrcPixel,
			*pdDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pdSrcPixel = pdSrcScanLine;
		pdDstPixel = pdDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if ((*pdSrcPixel ^ (DWORD) crTransparent) & UNUSED_MASK) {
				*pdDstPixel = BLIT_BLEND(*pdSrcPixel,*pdDstPixel,
											uiAlpha,uiAlphaComp);
			}

			// advance to next pixel
			pdSrcPixel += iSrcPixelAdvance;
			pdDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pdSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pdSrcScanLine += iSrcScanAdvance;
		pdDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pdSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\blt0808.cxx ===
#include "precomp.hxx"
#ifdef __cplusplus
extern "C" {
#endif
#include "dpf.h"
#ifdef __cplusplus
}
#endif


//#define BLT0808_FAST_TRANSPARENCY	1	// set to 1 if one wants a faster, less legal
										// transparency comparison, set to 0 for a 
										// perfect safe but slower transparency
										// comparison

void Blt08to08_NoTrans_Hcopy_SRCCOPY_Vcopy(BYTE* pSrcScanLine,
                                                  int iSrcScanStride,
                                                  BYTE* pDstScanLine,
												  int iDstScanStride,
                                                  int iNumDstCols,
                                                  int iNumDstRows)
{
	DWORD	*pBigSrcPixel,
			*pBigDstPixel,
			*pBigEndDstPixel;
	BYTE	*pSrcPixel,
			*pDstPixel,
			*pAlignedSrcPixel,
			*pAlignedDstPixel;
	int		iNumDwordsPerLine = iNumDstCols / 4,
			iNumBytesLeftDst = iNumDstCols % 4,
			iNumUnalignedSrcBytes,
			iNumUnalignedDstBytes,
			iNumUnalignByteDiff,
			i,j;
	DWORD	dwSrc1, dwSrc2;

	
	// If the total number of bytes per scan is less than 4, we are
	// just going to do a regular byte-wise copy, so skip all this
	// alignment junk.....
	if(!iNumDwordsPerLine){
		iNumUnalignedSrcBytes = iNumUnalignedDstBytes = 0;
		}
	else{
		// Find out if the src and dest pointers are dword aligned
		pAlignedDstPixel = (BYTE *)((((ULONG_PTR)pDstScanLine) + 3) & (~3));
		iNumUnalignedDstBytes = (int)(pAlignedDstPixel - pDstScanLine);

		pAlignedSrcPixel = (BYTE *)((((ULONG_PTR)pSrcScanLine) + 3) & (~3));
		iNumUnalignedSrcBytes = (int)(pAlignedSrcPixel - pSrcScanLine);

		// Now decrement the number of dwords per line and the
		// number of bytes left over as appropriate
		if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
			iNumBytesLeftDst -= iNumUnalignedDstBytes;
		else{
			iNumBytesLeftDst = sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
			if(iNumBytesLeftDst != sizeof(DWORD))
				iNumDwordsPerLine--;
			}
		}

	if(iNumUnalignedDstBytes == iNumUnalignedSrcBytes){
		// Do the fast dword copy since the alignments match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedSrcBytes; j++)
				*pDstPixel++ = *pSrcPixel++;
	
			// set up pointers to the first 4-pixel chunks
			// on src and dst scanlines, and last chunk on
			// dst scanline
			pBigSrcPixel = (DWORD*) pSrcPixel;
			pBigDstPixel = (DWORD*) pDstPixel;
			pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

			// copy scanline one 4-pixel chunk at a time
			while (pBigDstPixel != pBigEndDstPixel) {
				*pBigDstPixel++ = *pBigSrcPixel++;
			}

			// take care of remaining pixels on scanline
			if (iNumBytesLeftDst) {
				pSrcPixel = (BYTE*) pBigSrcPixel;
				pDstPixel = (BYTE*) pBigDstPixel;
				for(j=0; j<iNumBytesLeftDst; j++){
					*pDstPixel++ = *pSrcPixel++;
				}
			}

			// advance to next scanline
			pSrcScanLine += iSrcScanStride;
			pDstScanLine += iDstScanStride;
			}
		}
	else{
		// Find out the difference between the source and dest unalign offsets
		// If the unaligned dest offset is less than the unaligned src offset,
		// we need to decrement pSrcScanLine so that we can dword-align the first
		// source bytes (the extra bytes added to the beginning of the dword
		// will end up getting masked off anyway).
		if(iNumUnalignedDstBytes > iNumUnalignedSrcBytes)
			iNumUnalignByteDiff = iNumUnalignedDstBytes - iNumUnalignedSrcBytes;
		else
			iNumUnalignByteDiff = sizeof(DWORD) - (iNumUnalignedSrcBytes -
										iNumUnalignedDstBytes);

		// Do the trickier copy since the alignments don't match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedDstBytes; j++)
				*pDstPixel++ = *pSrcPixel++;

			// set up Dst pointer to the first 4-pixel chunk (dword)
			pBigDstPixel = (DWORD *) pDstPixel;
			pBigSrcPixel = (DWORD *) (((ULONG_PTR)pSrcPixel) & (~3));
		
			// Set up the temporary dword vars		
			dwSrc1 = *pBigSrcPixel++;

			switch(iNumUnalignByteDiff){
				case 1:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 8) | (dwSrc2 << 24);
						dwSrc1 = dwSrc2;
						}
					break;
				case 2:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 16) | (dwSrc2 << 16);
						dwSrc1 = dwSrc2;
						}
					break;
				case 3:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 24) | (dwSrc2 << 8);
						dwSrc1 = dwSrc2;
						}
					break;
				}

			// Take care of the bytes left over
			pDstPixel = (BYTE *)pBigDstPixel;
			pSrcPixel = ((BYTE *)(pBigSrcPixel)) - (sizeof(DWORD) - iNumUnalignByteDiff);

			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumBytesLeftDst; j++)
				*pDstPixel++ = *pSrcPixel++;

			// advance to next scanline
			pSrcScanLine += iSrcScanStride;
			pDstScanLine += iDstScanStride;
			}
		}


}


void Blt08to08_NoTrans_Hcopy_SRCCOPY_NoVcopy(BYTE* pSrcScanLine,
                                                  int iSrcScanStride,
												  int iNumSrcRows,
                                                  BYTE* pDstScanLine,
												  int iDstScanStride,
                                                  int iNumDstCols,
                                                  int iNumDstRows)
{
	DWORD	*pBigSrcPixel,
			*pBigDstPixel,
			*pBigEndDstPixel;
	BYTE	*pSrcPixel,
			*pDstPixel,
			*pAlignedSrcPixel,
			*pAlignedDstPixel;
	int		iNumDwordsPerLine = iNumDstCols / 4,
			iNumBytesLeftDst = iNumDstCols % 4,
			iNumUnalignedSrcBytes,
			iNumUnalignedDstBytes,
			iNumUnalignByteDiff,
			iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			i,j;
	DWORD	dwSrc1, dwSrc2;

	
	// If the total number of bytes per scan is less than 4, we are
	// just going to do a regular byte-wise copy, so skip all this
	// alignment junk.....
	if(!iNumDwordsPerLine){
		iNumUnalignedSrcBytes = iNumUnalignedDstBytes = 0;
		}
	else{
		// Find out if the src and dest pointers are dword aligned
		pAlignedDstPixel = (BYTE *)((((ULONG_PTR)pDstScanLine) + 3) & (~3));
		iNumUnalignedDstBytes = (int)(pAlignedDstPixel - pDstScanLine);

		pAlignedSrcPixel = (BYTE *)((((ULONG_PTR)pSrcScanLine) + 3) & (~3));
		iNumUnalignedSrcBytes = (int)(pAlignedSrcPixel - pSrcScanLine);

		// Now decrement the number of dwords per line and the
		// number of bytes left over as appropriate
		if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
			iNumBytesLeftDst -= iNumUnalignedDstBytes;
		else{
			iNumBytesLeftDst = sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
			if(iNumBytesLeftDst != sizeof(DWORD))
				iNumDwordsPerLine--;
			}
		}


	if(iNumUnalignedDstBytes == iNumUnalignedSrcBytes){
		// compute advance and error terms for stepping
		// vertically through the src bitmap
		if (iNumSrcRows < iNumDstRows) {
			iSrcScanAdvance = 0;
			iVertAdvanceError = iNumSrcRows;
			}
		else{
			iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
			iVertAdvanceError = iNumSrcRows % iNumDstRows;
			}

		// Do the fast dword copy since the alignments match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedSrcBytes; j++)
				*pDstPixel++ = *pSrcPixel++;
	
			// set up pointers to the first 4-pixel chunks
			// on src and dst scanlines, and last chunk on
			// dst scanline
			pBigSrcPixel = (DWORD*) pSrcPixel;
			pBigDstPixel = (DWORD*) pDstPixel;
			pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

			// copy scanline one 4-pixel chunk at a time
			while (pBigDstPixel != pBigEndDstPixel) {
				*pBigDstPixel++ = *pBigSrcPixel++;
				}

			// take care of remaining pixels on scanline
			if (iNumBytesLeftDst) {
				pSrcPixel = (BYTE*) pBigSrcPixel;
				pDstPixel = (BYTE*) pBigDstPixel;
				for(j=0; j<iNumBytesLeftDst; j++){
					*pDstPixel++ = *pSrcPixel++;
					}
				}

			// advance to next scanline
			pSrcScanLine += iSrcScanAdvance;
			pDstScanLine += iDstScanStride;

			// update and check vertical stepping error,
			// adjust src scanline pointer if necessary
			iVertError += iVertAdvanceError;
			if (iVertError >= iNumDstRows) {
				pSrcScanLine += iSrcScanStride;
				iVertError -= iNumDstRows;
				}
			}
		}
	else{
		// Find out the difference between the source and dest unalign offsets
		// If the unaligned dest offset is less than the unaligned src offset,
		// we need to decrement pSrcScanLine so that we can dword-align the first
		// source bytes (the extra bytes added to the beginning of the dword
		// will end up getting masked off anyway).
		if(iNumUnalignedDstBytes > iNumUnalignedSrcBytes)
			iNumUnalignByteDiff = iNumUnalignedDstBytes - iNumUnalignedSrcBytes;
		else
			iNumUnalignByteDiff = sizeof(DWORD) - (iNumUnalignedSrcBytes -
										iNumUnalignedDstBytes);

		// compute advance and error terms for stepping
		// vertically through the src bitmap
		if (iNumSrcRows < iNumDstRows) {
			iSrcScanAdvance = 0;
			iVertAdvanceError = iNumSrcRows;
			}
		else{
			iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
			iVertAdvanceError = iNumSrcRows % iNumDstRows;
			}

		// Do the trickier copy since the alignments don't match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedDstBytes; j++)
				*pDstPixel++ = *pSrcPixel++;

			// set up Dst pointer to the first 4-pixel chunk (dword)
			pBigDstPixel = (DWORD *) pDstPixel;
			pBigSrcPixel = (DWORD *) (((ULONG_PTR)pSrcPixel) & (~3));
		
			// Set up the temporary dword vars		
			dwSrc1 = *pBigSrcPixel++;

			switch(iNumUnalignByteDiff){
				case 1:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 8) | (dwSrc2 << 24);
						dwSrc1 = dwSrc2;
						}
					break;
				case 2:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 16) | (dwSrc2 << 16);
						dwSrc1 = dwSrc2;
						}
					break;
				case 3:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 24) | (dwSrc2 << 8);
						dwSrc1 = dwSrc2;
						}
					break;
				}

			// Take care of the bytes left over
			pDstPixel = (BYTE *)pBigDstPixel;
			pSrcPixel = ((BYTE *)(pBigSrcPixel)) - (sizeof(DWORD) - iNumUnalignByteDiff);

			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumBytesLeftDst; j++)
				*pDstPixel++ = *pSrcPixel++;

			// advance to next scanline
			pSrcScanLine += iSrcScanAdvance;
			pDstScanLine += iDstScanStride;

			// update and check vertical stepping error,
			// adjust src scanline pointer if necessary
			iVertError += iVertAdvanceError;
			if (iVertError >= iNumDstRows) {
				pSrcScanLine += iSrcScanStride;
				iVertError -= iNumDstRows;
				}
			}
		}

}


void	Blt08to08_NoTrans_NoHcopy_SRCCOPY(BYTE* pSrcScanLine,
											  int iSrcScanStride,
											  int iNumSrcCols,
											  int iNumSrcRows,
                                              BYTE* pDstScanLine,
                                              int iDstScanStride,
                                              int iNumDstCols,
                                              int iNumDstRows,
                                              int iHorizMirror)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
			*pDstPixel = *pSrcPixel;

			// advance to next pixel
			pSrcPixel += iSrcPixelAdvance;
			pDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanAdvance;
		pDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt08to08_Trans_Hcopy_SRCCOPY(BYTE* pSrcScanLine,
                                          int iSrcScanStride,
										  int iNumSrcRows,
                                          BYTE* pDstScanLine,
                                          int iDstScanStride,
                                          int iNumDstCols,
                                          int iNumDstRows,
                                          BYTE bTransparentIndex)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	 
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
#if BLT0808_FAST_TRANSPARENCY
			*pDstPixel ^= (*pDstPixel ^ *pSrcPixel) * 
			              (BYTE) !(*pSrcPixel == bTransparentIndex);
#else
			if (*pSrcPixel != bTransparentIndex) 
			{
				*pDstPixel = *pSrcPixel;
			}
#endif
			pSrcPixel++;
			pDstPixel++;
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanAdvance;
		pDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	

}

void	Blt08to08_Trans_NoHcopy_SRCCOPY(BYTE* pSrcScanLine,
											int iSrcScanStride,
											int iNumSrcCols,
											int iNumSrcRows,
                                            BYTE* pDstScanLine,
                                            int iDstScanStride,
                                            int iNumDstCols,
                                            int iNumDstRows,
                                            int iHorizMirror,
                                            BYTE bTransparentIndex)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
#if BLT0808_FAST_TRANSPARENCY
			*pDstPixel ^= (*pDstPixel ^ *pSrcPixel) *
			              (BYTE) !(*pSrcPixel == bTransparentIndex);
#else
			if (*pSrcPixel != bTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
#endif

			// advance to next pixel
			pSrcPixel += iSrcPixelAdvance;
			pDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanAdvance;
		pDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_Chunk32_BitBlt08to08 - 
//		BitBlit from source bitmap to destination bitmap in 32 x 32
//		bit chunks
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif 

SCODE BlitLib_Chunk32_BitBlt08to08(PDIBINFO pDibInfoDst,
		PDIBBITS pDibBitsDst, PRECT prcDst, PDIBINFO pDibInfoSrc,
		PDIBBITS pDibBitsSrc)
{

	DWORD *pbDst,*pbSrc,*pend;
	int j;
	int iDstStride=DibWidthBytes(pDibInfoDst);


	// calc pbsrc and pbdst
	pbDst = (DWORD *) ((BYTE *) pDibBitsDst + (prcDst->top) * (iDstStride)
	 + prcDst->left);
	pbSrc=(DWORD *)pDibBitsSrc;
      
	iDstStride-=32;
	// convert stride to dwords
      iDstStride/=4;
	

	// copy a scanline
	// counting down to 0 faster
	for (j=32;j>0 ;j-- )
	{	
		pend=(DWORD *)pbSrc+8;
		for (; pbSrc < pend; pbSrc++ )
		{
			*pbDst++=*pbSrc;
		}  
		pbDst+=iDstStride;
 	}
     
	return(S_OK);
	
}


///////////////////////////////////////////////////////////////////////
//
// Private BlitLib_Chunk32_BitBlt08to08_Trans - 
//		BitBlit from source bitmap to destination bitmap in 32 x 32
//		bit chunks with optional transparency
//
// Parameters:
//	pDibInfoDst			Pointer to the bitmapinfo for the Destination DIB
//	pDibBitsDst			Pointer to the bits for the Destination DIB
//	prcDst				Pointer to the Destination rectangle
//	pDibInfoSrc			Pointer to the bitmapinfo for the Source DIB
//	pDibBitsSrc			Pointer to the bits for the Source DIB
//	crTransparent		Tranparent color value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
// Status: Incomplete
//
///////////////////////////////////////////////////////////////////////
SCODE BlitLib_Chunk32_BitBlt08to08_Trans(PDIBINFO pDibInfoDst,
		PDIBBITS pDibBitsDst, PRECT prcDst, PDIBINFO pDibInfoSrc,
		PDIBBITS pDibBitsSrc, COLORREF crTransparent)
{

	BYTE * pbDst,*pend;
	int j;
	int iDstStride=DibWidthBytes(pDibInfoDst);	   


	
	// calc pbsrc and pbdst
	pbDst = (BYTE*) pDibBitsDst + (prcDst->top) * (iDstStride)
	 + prcDst->left;

	iDstStride-=32;

	// copy a scanline
	// counting down to 0 faster
	for (j=32;j>0 ;j-- )
	{	
		pend=pDibBitsSrc+32;
		for (;pDibBitsSrc<pend;pDibBitsSrc++ )
		{
			if (*pDibBitsSrc != (BYTE)crTransparent)
				*pbDst=*pDibBitsSrc;
		
		pbDst++;
		}  
		pbDst+=iDstStride;
 	}
     
	return(S_OK);
	
}

#ifdef __cplusplus
	}
#endif 
#endif

///////////////////////////////////////////////////////////////////////
//
// Private Blt08to08_LeftToRight_BottomToTop_SRCOPY - 
//		BitBlit from source bitmap to destination bitmap (where these
//		bitmaps overlap) by walking both the source and destination
//		from left to right and bottom to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt08to08_LeftToRight_BottomToTop_SRCCOPY(BYTE* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows)
{
	DWORD	*pBigSrcPixel,
			*pBigDstPixel,
			*pBigEndDstPixel;
	BYTE	*pSrcPixel,
			*pDstPixel,
			*pAlignedSrcPixel,
			*pAlignedDstPixel;
	int		iNumDwordsPerLine = iNumDstCols / 4,
			iNumBytesLeftDst = iNumDstCols % 4,
			iNumUnalignedSrcBytes,
			iNumUnalignedDstBytes,
			iNumUnalignByteDiff,
			i,j;
	DWORD	dwSrc1, dwSrc2;


	// If the total number of bytes per scan is less than 4, we are
	// just going to do a regular byte-wise copy, so skip all this
	// alignment junk.....
	if(!iNumDwordsPerLine){
		iNumUnalignedSrcBytes = iNumUnalignedDstBytes = 0;
		}
	else{
		// Find out if the source and dest pointers are dword aligned
		pAlignedSrcPixel = (BYTE *)((((ULONG_PTR)pSrcScanLine) + 3) & (~3));
		iNumUnalignedSrcBytes = (int)(pAlignedSrcPixel - pSrcScanLine);

		pAlignedDstPixel = (BYTE *)((((ULONG_PTR)pDstScanLine) + 3) & (~3));
		iNumUnalignedDstBytes = (int)(pAlignedDstPixel - pDstScanLine);
	
		// Now decrement the number of dwords per line and the
		// number of bytes left over as appropriate
		if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
			iNumBytesLeftDst -= iNumUnalignedDstBytes;
		else{
			iNumBytesLeftDst = sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
			if(iNumBytesLeftDst != sizeof(DWORD))
				iNumDwordsPerLine--;
			}
		}


	if(iNumUnalignedDstBytes == iNumUnalignedSrcBytes){
		// Do the fast dword copy since the alignments match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedSrcBytes; j++)
				*pDstPixel++ = *pSrcPixel++;
	
			// set up pointers to the first 4-pixel chunks
			// on src and dst scanlines, and last chunk on
			// dst scanline
			pBigSrcPixel = (DWORD*) pSrcPixel;
			pBigDstPixel = (DWORD*) pDstPixel;
			pBigEndDstPixel = pBigDstPixel + iNumDwordsPerLine;

			// copy scanline one 4-pixel chunk at a time
			while (pBigDstPixel != pBigEndDstPixel) {
				*pBigDstPixel++ = *pBigSrcPixel++;
			}

			// take care of remaining pixels on scanline
			if (iNumBytesLeftDst) {
				pSrcPixel = (BYTE*) pBigSrcPixel;
				pDstPixel = (BYTE*) pBigDstPixel;
				for(j=0; j<iNumBytesLeftDst; j++){
					*pDstPixel++ = *pSrcPixel++;
				}
			}

			// advance to next scanline
			pSrcScanLine -= iSrcScanStride;
			pDstScanLine -= iDstScanStride;
			}
		}
	else{
		// Find out the difference between the source and dest unalign offsets
		// If the unaligned dest offset is less than the unaligned src offset,
		// we need to decrement pSrcScanLine so that we can dword-align the first
		// source bytes (the extra bytes added to the beginning of the dword
		// will end up getting masked off anyway).
		if(iNumUnalignedDstBytes > iNumUnalignedSrcBytes)
			iNumUnalignByteDiff = iNumUnalignedDstBytes - iNumUnalignedSrcBytes;
		else
			iNumUnalignByteDiff = sizeof(DWORD) - (iNumUnalignedSrcBytes -
										iNumUnalignedDstBytes);

		// Do the trickier copy since the alignments don't match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedDstBytes; j++)
				*pDstPixel++ = *pSrcPixel++;

			// set up Dst pointer to the first 4-pixel chunk (dword)
			pBigDstPixel = (DWORD *) pDstPixel;
			pBigSrcPixel = (DWORD *) (((ULONG_PTR)pSrcPixel) & (~3));
		
			// Set up the temporary dword vars		
			dwSrc1 = *pBigSrcPixel++;

			switch(iNumUnalignByteDiff){
				case 1:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 8) | (dwSrc2 << 24);
						dwSrc1 = dwSrc2;
						}
					break;
				case 2:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 16) | (dwSrc2 << 16);
						dwSrc1 = dwSrc2;
						}
					break;
				case 3:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc2 = *pBigSrcPixel++;
						*pBigDstPixel++ = (dwSrc1 >> 24) | (dwSrc2 << 8);
						dwSrc1 = dwSrc2;
						}
					break;
				}

			// Take care of the bytes left over
			pDstPixel = (BYTE *)pBigDstPixel;
			pSrcPixel = ((BYTE *)(pBigSrcPixel)) - (sizeof(DWORD) - iNumUnalignByteDiff);

			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumBytesLeftDst; j++)
				*pDstPixel++ = *pSrcPixel++;

			// advance to next scanline
			pSrcScanLine -= iSrcScanStride;
			pDstScanLine -= iDstScanStride;
			}
		}
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt08to08_RightToLeft_TopToBottom_SRCOPY - 
//		BitBlit from source bitmap to destination bitmap (where these
//		bitmaps overlap) by walking both the source and destination
//		from right to left and top to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt08to08_RightToLeft_TopToBottom_SRCCOPY(BYTE* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows)
{
	DWORD	*pBigSrcPixel,
			*pBigDstPixel,
			*pBigEndDstPixel;
	BYTE	*pSrcPixel,
			*pDstPixel,
			*pAlignedSrcPixel,
			*pAlignedDstPixel;
	int		iNumDwordsPerLine = iNumDstCols / 4,
			iNumBytesLeftDst = iNumDstCols % 4,
			iNumUnalignedSrcBytes,
			iNumUnalignedDstBytes,
			iNumUnalignByteDiff,
			i,j;
	DWORD	dwSrc1, dwSrc2;

	// If the total number of bytes per scan is less than 4, we are
	// just going to do a regular byte-wise copy, so skip all this
	// alignment junk.....
	if(!iNumDwordsPerLine){
		iNumUnalignedSrcBytes = iNumUnalignedDstBytes = 0;
		}
	else{
		// Find out if the source and dest pointers are dword aligned
		pAlignedSrcPixel = (BYTE *)(((ULONG_PTR)pSrcScanLine) & (~3));
		iNumUnalignedSrcBytes = (int)(pSrcScanLine - pAlignedSrcPixel) + 1;

		pAlignedDstPixel = (BYTE *)(((ULONG_PTR)pDstScanLine) & (~3));
		iNumUnalignedDstBytes = (int)(pDstScanLine - pAlignedDstPixel) + 1;
	
		// Now decrement the number of dwords per line and the
		// number of bytes left over as appropriate
		if(iNumUnalignedDstBytes == sizeof(DWORD))
			iNumUnalignedDstBytes = 0;
		if(iNumUnalignedSrcBytes == sizeof(DWORD))
			iNumUnalignedSrcBytes = 0;
		else if(iNumUnalignedDstBytes <= iNumBytesLeftDst)
			iNumBytesLeftDst -= iNumUnalignedDstBytes;
		else{
			iNumBytesLeftDst =  sizeof(DWORD) - iNumUnalignedDstBytes + iNumBytesLeftDst;
			iNumDwordsPerLine--;
			}
		}


	if(iNumUnalignedDstBytes == iNumUnalignedSrcBytes){
		// Do the fast dword copy since the alignments match
		for (int i = 0; i < iNumDstRows; i++) {

			// First set up the pointer to take care of unaligned DWORD bytes
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedSrcBytes; j++)
				*pDstPixel-- = *pSrcPixel--;
		
			// set up pointers to the first 4-pixel chunks
			// on src and dst scanlines, and last chunk on
			// dst scanline
			pBigSrcPixel = (DWORD*) (pSrcPixel - 3);
			pBigDstPixel = (DWORD*) (pDstPixel - 3);
			pBigEndDstPixel = pBigDstPixel - iNumDwordsPerLine;

			// copy scanline one 4-pixel chunk at a time
			while (pBigDstPixel != pBigEndDstPixel) {
				*pBigDstPixel-- = *pBigSrcPixel--;
			}

			if(iNumBytesLeftDst)
				pSrcPixel = ((BYTE *)pBigSrcPixel) + 3;
				pDstPixel = ((BYTE *)pBigDstPixel) + 3;
				for (j = 0; j < iNumBytesLeftDst; j++)
					*pDstPixel-- = *pSrcPixel--;

			// advance to next scanline
			pSrcScanLine += iSrcScanStride;
			pDstScanLine += iDstScanStride;
			}
		}
	else{
		// Find out the difference between the source and dest unalign offsets
		// If the unaligned dest offset is less than the unaligned src offset,
		// we need to decrement pSrcScanLine so that we can dword-align the first
		// source bytes (the extra bytes added to the beginning of the dword
		// will end up getting masked off anyway).
		if(iNumUnalignedDstBytes < iNumUnalignedSrcBytes)
			iNumUnalignByteDiff = iNumUnalignedSrcBytes - iNumUnalignedDstBytes;
		else
			iNumUnalignByteDiff = sizeof(DWORD) - (iNumUnalignedDstBytes -
										iNumUnalignedSrcBytes);

		// Do the trickier copy since the alignments don't match
		for (i = 0; i < iNumDstRows; i++) {

			// Set up the first pointers
			pSrcPixel = pSrcScanLine;
			pDstPixel = pDstScanLine;
		
			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumUnalignedDstBytes; j++)
				*pDstPixel-- = *pSrcPixel--;

			// set up Dst pointer to the first 4-pixel chunk (dword)
			pBigDstPixel = (DWORD *) (pDstPixel - 3);
			pBigSrcPixel = (DWORD *) (((ULONG_PTR)pSrcPixel) & (~3));
		
			// Set up the temporary dword vars		
			dwSrc2 = *pBigSrcPixel--;

			switch(iNumUnalignByteDiff){
				case 1:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc1 = *pBigSrcPixel--;
						*pBigDstPixel-- = (dwSrc1 >> 8) | (dwSrc2 << 24);
						dwSrc2 = dwSrc1;
						}
					break;
				case 2:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc1 = *pBigSrcPixel--;
						*pBigDstPixel-- = (dwSrc1 >> 16) | (dwSrc2 << 16);
						dwSrc2 = dwSrc1;
						}
					break;
				case 3:
					for(j=0; j<iNumDwordsPerLine; j++){
						dwSrc1 = *pBigSrcPixel--;
						*pBigDstPixel-- = (dwSrc1 >> 24) | (dwSrc2 << 8);
						dwSrc2 = dwSrc1;
						}
					break;
				}

			// Take care of the bytes left over
			pDstPixel = ((BYTE *)pBigDstPixel + 3);
			pSrcPixel = (((BYTE *)(pBigSrcPixel)) + 4 + 
								(iNumUnalignByteDiff - 1));

			// First we need to copy the bytes to get to an aligned dword
			for(j=0; j<iNumBytesLeftDst; j++)
				*pDstPixel-- = *pSrcPixel--;

			// advance to next scanline
			pSrcScanLine += iSrcScanStride;
			pDstScanLine += iDstScanStride;
			}
		}

}


///////////////////////////////////////////////////////////////////////
//
// Private Blt08to08_LeftToRight_BottomToTop_Trans_SRCCOPY - 
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	bTransparentIndex	Palette Index of the transparent color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt08to08_LeftToRight_BottomToTop_Trans_SRCCOPY(BYTE* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              BYTE bTransparentIndex)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pSrcPixel != bTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
			pSrcPixel++;
			pDstPixel++;
		}

		// advance to next scanline
		pSrcScanLine -= iSrcScanStride;
		pDstScanLine -= iDstScanStride;

	}	
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt08to08_RightToLeft_TopToBottom_Trans_SRCOPY - 
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	bTransparentIndex	Palette Index of the transparent color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt08to08_RightToLeft_TopToBottom_Trans_SRCCOPY(BYTE* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              BYTE bTransparentIndex)
{
	BYTE	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pSrcPixel != bTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
			pSrcPixel--;
			pDstPixel--;
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanStride;
		pDstScanLine += iDstScanStride;

	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\blt0101.cxx ===
#include "precomp.hxx"


static const BYTE bTopMask[8]    = {0x00, 0x80, 0xC0, 0xE0, 
                                    0xF0, 0xF8, 0xFC, 0xFE}; 
static const BYTE bBottomMask[8] = {0xFF, 0x7F, 0x3F, 0x1F, 
                                    0x0F, 0x07, 0x03, 0x01};
static const BYTE bSelectMask[8] = {0x80, 0x40, 0x20, 0x10,
                                    0x08, 0x04, 0x02, 0x01};


void Blt01to01_NoTrans_Hcopy_SRCCOPY_Vcopy(
								BYTE* pbSrcScanLine,
								int iSrcBitOffset,
								int iSrcScanStride,
								BYTE* pbDstScanLine,
								int iDstBitOffset,
								int iDstScanStride,
								int iNumDstCols,
								int iNumDstRows)
{
	BYTE	*pbSrc,
			*pbDst,
			*pbEndDst;
	int		iDstStartPixels,
			iDstFullBytes,
			iDstEndPixels,
			iRelBitOffset,
			iCompRelBitOffset;

	// compute how many pixels in the dst scanline are hanging off into a 
	// byte that's not completely on the dst scanline, how many full bytes
	// are on the dst scanline, and how many pixels hang off the other end
	if (iDstBitOffset == 0) {
		iDstStartPixels = 0;
		iDstFullBytes = iNumDstCols / 8;
		iDstEndPixels = iNumDstCols % 8;
	} else {
		iDstStartPixels = 8 - iDstBitOffset;
		iDstFullBytes = (iNumDstCols - iDstStartPixels) / 8;
		iDstEndPixels = (iNumDstCols - iDstStartPixels) % 8;
	}

	iRelBitOffset = abs(iSrcBitOffset - iDstBitOffset);
	iCompRelBitOffset = 8 - iRelBitOffset;

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to first bytes on src and dst scanlines
		pbSrc = pbSrcScanLine;
		pbDst = pbDstScanLine;
		
		// take care of first few dst pixels that are hanging off in a byte
		// that's not completely on the scanline
		if (iDstStartPixels) {
			if (iNumDstCols >= iDstStartPixels) {
				if (iSrcBitOffset > iDstBitOffset) {
					*pbDst++ = (((*pbSrc << iRelBitOffset) |
					             (*(pbSrc + 1) >> iCompRelBitOffset)) &
					            bBottomMask[iDstBitOffset]) | 
					           (*pbDst & ~bBottomMask[iDstBitOffset]);
					pbSrc++;
				} else {
					*pbDst++ = ((*pbSrc >> iRelBitOffset) &
					            bBottomMask[iDstBitOffset]) |
					           (*pbDst & ~bBottomMask[iDstBitOffset]);
				}	
			} else {
				if (iSrcBitOffset > iDstBitOffset) {
					*pbDst++ = (((*pbSrc << iRelBitOffset) |
					             (*(pbSrc + 1) >> iCompRelBitOffset)) &
					            bBottomMask[iDstBitOffset] &
					            bTopMask[iSrcBitOffset + iNumDstCols]) | 
					           (*pbDst & ~(bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]));
					pbSrc++;
				} else {
					*pbDst++ = ((*pbSrc >> iRelBitOffset) &
					           bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]) |
					           (*pbDst & ~(bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]));
				}	
			}
		}

		// take care of pixels that fall on bytes that are entirely
		// within the dst scanline
		pbEndDst = pbDst + iDstFullBytes;
		for (; pbDst != pbEndDst; pbDst++) {
			*pbDst = (*pbSrc << iRelBitOffset) | 
			         (*(pbSrc + 1) >> iCompRelBitOffset);
			pbSrc++;
		}

		// take care of pixels hanging off the end into a byte not
		// entirely in the scanline
		*pbDst = ((*pbSrc << iRelBitOffset) & bTopMask[iDstEndPixels]) |
		         (*pbDst & ~bTopMask[iDstEndPixels]);

		// advance to next scanline

		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

void Blt01to01_NoTrans_Hcopy_SRCCOPY_NoVcopy(
								BYTE* pbSrcScanLine,
								int iSrcBitOffset,
								int iSrcScanStride,
								int iNumSrcRows,
								BYTE* pbDstScanLine,	
								int iDstBitOffset,
								int iDstScanStride,
								int iNumDstCols,
								int iNumDstRows)
{
	BYTE	*pbSrc,
			*pbDst,
			*pbEndDst;
	int		iDstStartPixels,
			iDstFullBytes,
			iDstEndPixels,
			iRelBitOffset,
			iCompRelBitOffset,
			iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute how many pixels in the dst scanline are hanging off into a 
	// byte that's not completely on the dst scanline, how many full bytes
	// are on the dst scanline, and how many pixels hang off the other end
	if (iDstBitOffset == 0) {
		iDstStartPixels = 0;
		iDstFullBytes = iNumDstCols / 8;
		iDstEndPixels = iNumDstCols % 8;
	} else {
		iDstStartPixels = 8 - iDstBitOffset;
		iDstFullBytes = (iNumDstCols - iDstStartPixels) / 8;
		iDstEndPixels = (iNumDstCols - iDstStartPixels) % 8;
	}

	iRelBitOffset = abs(iSrcBitOffset - iDstBitOffset);
	iCompRelBitOffset = 8 - iRelBitOffset;

	for (int i = 0; i < iNumDstRows; i++) {

 		pbSrc = pbSrcScanLine;
		pbDst = pbDstScanLine;
		
		// take care of first few dst pixels that are hanging off in a byte
		// that's not completely on the scanline
		if (iDstStartPixels) {
			if (iNumDstCols >= iDstStartPixels) {
				if (iSrcBitOffset > iDstBitOffset) {
					*pbDst++ = (((*pbSrc << iRelBitOffset) |
					             (*(pbSrc + 1) >> iCompRelBitOffset)) &
					            bBottomMask[iDstBitOffset]) | 
					           (*pbDst & ~bBottomMask[iDstBitOffset]);
					pbSrc++;
				} else {
					*pbDst++ = ((*pbSrc >> iRelBitOffset) &
					            bBottomMask[iDstBitOffset]) |
					           (*pbDst & ~bBottomMask[iDstBitOffset]);
				}	
			} else {
				if (iSrcBitOffset > iDstBitOffset) {
					*pbDst++ = (((*pbSrc << iRelBitOffset) |
					             (*(pbSrc + 1) >> iCompRelBitOffset)) &
					            bBottomMask[iDstBitOffset] &
					            bTopMask[iSrcBitOffset + iNumDstCols]) | 
					           (*pbDst & ~(bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]));
					pbSrc++;
				} else {
					*pbDst++ = ((*pbSrc >> iRelBitOffset) &
					           bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]) |
					           (*pbDst & ~(bBottomMask[iDstBitOffset] &
					           bTopMask[iSrcBitOffset + iNumDstCols]));
				}	
			}
		}

		// take care of pixels that fall on bytes that are entirely
		// within the dst scanline
		pbEndDst = pbDst + iDstFullBytes;
		for (; pbDst != pbEndDst; pbDst++) {
			*pbDst = (*pbSrc << iRelBitOffset) | 
			         (*(pbSrc + 1) >> iCompRelBitOffset);
			pbSrc++;
		}

		// take care of pixels hanging off the end into a byte not
		// entirely in the scanline
		*pbDst = ((*pbSrc << iRelBitOffset) & bTopMask[iDstEndPixels]) |
		         (*pbDst & ~bTopMask[iDstEndPixels]);

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt01to01_NoTrans_NoHcopy_SRCCOPY(
								BYTE* pbSrcScanLine,	
								int iSrcBitOffset,
								int iSrcScanStride,
								int iNumSrcCols,
								int iNumSrcRows,
								BYTE* pbDstScanLine,
								int iDstBitOffset,
								int iDstScanStride,
 								int iNumDstCols,
								int iNumDstRows,
								int iHorizMirror)
{
	BYTE	*pbSrc,
			*pbDst,
			bDstVal;
	int		iSrcPixel,
			iDstPixel,
			iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcByteAdvance,
			iSrcBitAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcByteAdvance = 0;
		iSrcBitAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcByteAdvance = (iNumSrcCols / iNumDstCols) / 8;
		iSrcBitAdvance = (iNumSrcCols / iNumDstCols) % 8;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pbSrc = pbSrcScanLine;
		iSrcPixel = iSrcBitOffset;
		pbDst = pbDstScanLine;
		iDstPixel = iDstBitOffset;
		iHorizError = 0;
		bDstVal = *pbDst;

		for (int j = 0; j < iNumDstCols; j++) {

			// get value of src pixel, put it in dst byte
			if (*pbSrc & bSelectMask[iSrcPixel]) {
				bDstVal |= bSelectMask[iDstPixel];
			} else {
				bDstVal &= ~bSelectMask[iDstPixel];
			}

			// advance to next src pixel
			pbSrc += iSrcByteAdvance;
			iSrcPixel += iSrcBitAdvance;
			if (iSrcPixel > 7) {
				pbSrc++;
				iSrcPixel -= 8;
			}

			// advance to next dst pixel
			// if we hit byte boundary, write
			// full one and get new one
			iDstPixel += iHorizMirror;
			if (iDstPixel < 0) {
				*pbDst-- = bDstVal;
				bDstVal = *pbDst;
				iDstPixel = 7;
			} else if (iDstPixel > 7) {
				*pbDst++ = bDstVal;
				bDstVal = *pbDst;
				iDstPixel = 0;
			}

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				if (++iSrcPixel > 7) {
					pbSrc++;
					iSrcPixel = 0;
				}
				iHorizError -= iNumDstCols;
			}
		}

		// write last byte to dst scanline
		*pbDst = bDstVal;

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt01to01_Trans_NoHcopy_SRCCOPY(
								BYTE* pbSrcScanLine,
								int iSrcBitOffset,
								int iSrcScanStride,
								int iNumSrcCols,
								int iNumSrcRows,
								BYTE* pbDstScanLine,
								int iDstBitOffset,
								int iDstScanStride,
								int iNumDstCols,
								int iNumDstRows,
								int iHorizMirror,
								BYTE bTransparentIndex)
{
	BYTE	*pbSrc,
			*pbDst,
			bDstVal,
			bTransparentTest;
	int		iSrcPixel,
			iDstPixel,
			iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcByteAdvance,
			iSrcBitAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcByteAdvance = 0;
		iSrcBitAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcByteAdvance = (iNumSrcCols / iNumDstCols) / 8;
		iSrcBitAdvance = (iNumSrcCols / iNumDstCols) % 8;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	// create transparent color testing mask
	if (bTransparentIndex) {
		bTransparentTest = 0xFF;
	} else {
		bTransparentTest = 0;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pbSrc = pbSrcScanLine;
		iSrcPixel = iSrcBitOffset;
		pbDst = pbDstScanLine;
		iDstPixel = iDstBitOffset;
		iHorizError = 0;
		bDstVal = *pbDst;

		for (int j = 0; j < iNumDstCols; j++) {

			// get value of src pixel, put it in dst byte
			if ((*pbSrc ^ bTransparentTest) & bSelectMask[iSrcPixel]) {
				if (*pbSrc & bSelectMask[iSrcPixel]) {
					bDstVal |= bSelectMask[iDstPixel];
				} else {
					bDstVal &= ~bSelectMask[iDstPixel];
				}
			}

			// advance to next src pixel
			pbSrc += iSrcByteAdvance;
			iSrcPixel += iSrcBitAdvance;
			if (iSrcPixel > 7) {
				pbSrc++;
				iSrcPixel -= 8;
			}

			// advance to next dst pixel
			// if we hit byte boundary, write
			// full one and get new one
			iDstPixel += iHorizMirror;
			if (iDstPixel < 0) {
				*pbDst-- = bDstVal;
				bDstVal = *pbDst;
				iDstPixel = 7;
			} else if (iDstPixel > 7) {
				*pbDst++ = bDstVal;
				bDstVal = *pbDst;
				iDstPixel = 0;
			}

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				if (++iSrcPixel > 7) {
					pbSrc++;
					iSrcPixel = 0;
				}
				iHorizError -= iNumDstCols;
			}
		}

		// write last byte to dst scanline
		*pbDst = bDstVal;

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\bltos.h ===
/********************************************************
* bltos.h                               
*                                         
* os specific functionality for blitlib
*                                         
* history                                 
*       7/7/95   created it                     myronth
*
*  Copyright (c) Microsoft Corporation 1994-1995                                                                         
*                                        
*********************************************************/

// Currently, DDraw is the only Win95 app linking with BlitLib
// and it uses local memory allocation.

// The following #define enables all other NT BlitLib applications to
// link with it and get global memory allocation.

#if WIN95 | MMOSA 

#include "memalloc.h"
#define osMemAlloc MemAlloc
#define osMemFree MemFree
#define osMemReAlloc MemReAlloc

#else

#define osMemAlloc(size) LocalAlloc(LPTR,size)
#define osMemFree LocalFree
#define osMemReAlloc(ptr,size) LocalReAlloc((HLOCAL)ptr,size,LPTR)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\bt24p24p.cxx ===
#include "precomp.hxx"

extern "C"
{
#include <dpf.h>
}

#if 0
// This slightly faster bitblt code does it the hard way.  I'm not
// entirely sure about the going backwards and up case, but I'm
// confident otherwise.  We decided not to turn this on since it is a
// small performance gain in an obscure case and didn't justify the
// risk we would introduce at this late date.  The origional, slower
// implementation is below. -mdm 04/18/96
void Blt24Pto24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(
    BYTE* pbSrcScanLine,
    int iSrcScanStride,
    int iNumSrcRows,
    BYTE* pbDstScanLine,
    int iDstScanStride,
    int iNumDstCols,
    int iNumDstRows)
{   
    DWORD *pdSrcData, *pdDstData,*pdEndOfData;
    int iVertError=0,iVertAdvanceError,iSrcScanAdvance;
    int iAlign, iAlignSrc, iAlignDst,iAlignDstEnd;
    int iLeftSrcShift,iRightSrcShift;
    DWORD dLeftDstMask, dLeftSrcMask, dAlignMask,dRightDstMask;

    // compute advance and error terms for stepping
    // vertically through the src bitmap
    if (iNumSrcRows < iNumDstRows) 
    {
	iSrcScanAdvance = 0;
	iVertAdvanceError = iNumSrcRows;
    } 
    else 
    {
	iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
	iVertAdvanceError = iNumSrcRows % iNumDstRows;
    }

    // Calculate relative alignment ofthe data.  We'll have to shift
    // the data to the right by (dst-src) bits to do DWORD-aligned
    // stores.  In the general unaligned case, we'll be using data
    // from 2 src dwords to fill in the data for the dst.
    iAlignSrc = (((DWORD)pbSrcScanLine) & 0x03) * 8;
    iAlignDst = (((DWORD)pbDstScanLine) & 0x03) * 8;
    iAlignDstEnd = ((((DWORD)pbDstScanLine) + iNumDstCols * 3) & 0x03) * 8;
    iAlign = iAlignDst - iAlignSrc;

    // Calculate the masks in advance.  Yes, this gives me a headache,
    // too.  The idea is that we're going to break up the blt into a
    // left column, a center part, and a right column.  Since the left
    // and right columns will have DWORDS with data we won't be
    // touching, we'll need some masks to make sure we keep the data.
    dLeftDstMask = ((1 << (32 - iAlignDst)) - 1) << iAlignDst; // mask of bits we'll be replacing in leftmost dst dword
    dLeftSrcMask = ((1 << (32 - iAlignSrc)) - 1) << iAlignSrc; // mask of bits we'll be using form the leftmost src dword.
    if(iAlign < 0)
    {
	dAlignMask = ((1 << (-iAlign)) - 1); // mask of bits we'll be using from the second src dword
    }
    else
    {
	dAlignMask = (1 << (32 - iAlign)) - 1; // mask of bits we'll be using from the second src dword
    }
    dRightDstMask = (1 << iAlignDstEnd) - 1; // mask of bits we'll be replacing in the rightmost dst dword

    // calculate shift necessary to properly align data
    if(iAlign > 0)
    {
	pdSrcData--; // back up because we want our data in the right src dword (for consistency)
	iLeftSrcShift = 32 - iAlign;
	iRightSrcShift = iAlign;
    }
    else if(iAlign < 0)
    {
	iLeftSrcShift = -iAlign;
	iRightSrcShift = 32 - (-iAlign);
    }
    else // iAlign == 0
    {
	iLeftSrcShift = 0;
	iRightSrcShift = 31;
    }

// NOTE WATCH OUT FOR CASES WHERE WE ARE ACTUALLY GOING FROM RIGHT TO LEFT.  NOT HANDLED YET!
    for (int i = 0; i < iNumDstRows; i++) 
    {
	// set up pointers to the first DWORDS on src and dst
	// scanlines, and last DWORD on dst scanline
	pdSrcData = (DWORD*)(((DWORD)pbSrcScanLine) & ~0x03);
	pdDstData = (DWORD*)(((DWORD)pbDstScanLine) & ~0x03);
	pdEndOfData = (DWORD*)(((DWORD)pbDstScanLine + iNumDstCols * 3) & ~0x03);

	// Do the left column
	if(iAlignSrc || iAlignDst)
	{
	    if(iAlign)
	    {
		*pdDstData = ( (*pdDstData & ~dLeftDstMask) | // old data
			       (((pdSrcData[0] & dLeftSrcMask) >> iLeftSrcShift) | // data from first src dword
				(((pdSrcData[1] & dAlignMask) << iRightSrcShift )) & dLeftDstMask) );
	    }
	    else // iAlign == 0
	    {
		// No shift needed here, just watch out for the old data
		*pdDstData = (*pdDstData & ~dLeftDstMask) | (*pdSrcData & dLeftSrcMask);
	    }

	    pdSrcData++;
	    pdDstData++;
	}

	// Now do the center section
	if(iAlign)
	{
	    while(pdDstData < pdEndOfData)
	    {
		*pdDstData = (((pdSrcData[0] & ~dAlignMask) >> iLeftSrcShift) | // data from first src dword
			      ((pdSrcData[1] & dAlignMask) << iRightSrcShift));
		pdSrcData++;
		pdDstData++;
	    }
	}
	else // iAlign == 0
	{
	    while(pdDstData < pdEndOfData)
	    {
		*pdDstData++ = *pdSrcData++;
	    }
	}

	// Do the right column
	if(dRightDstMask)
	{
	    if(iAlign)
	    {
		*pdDstData = ( (*pdDstData & ~dRightDstMask) | // old data
			       ( (((pdSrcData[0] & ~dAlignMask) >> iLeftSrcShift) | // data from first src dword
				  ((pdSrcData[1] & dAlignMask) << iRightSrcShift)) & dRightDstMask) );
	    }
	    else // iAlign == 0
	    {
		*pdDstData =(*pdDstData & ~dRightDstMask) | (*pdSrcData & dRightDstMask);
	    }
	}

	// advance to next scanline
	pbSrcScanLine += iSrcScanAdvance;
	pbDstScanLine += iDstScanStride;
	
        // update and check vertical stepping error,
	// adjust src scanline pointer if necessary
	iVertError += iVertAdvanceError;
	if (iVertError >= iNumDstRows) 
	{
	    pbSrcScanLine += iSrcScanStride;
	    iVertError -= iNumDstRows;
	}
    }
}
#endif // 0

void Blt24Pto24P_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel,
				*ptEndDstPixel;
    int		    iVertError = 0,
			    iVertAdvanceError,
			    iSrcScanAdvance;

    // compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		ptEndDstPixel = ptDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (ptDstPixel != ptEndDstPixel)
		{
		    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
		    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
		    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
		    ptDstPixel++;
		    ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

        // update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}

	}
}

void Blt24Pto24P_NoBlend_NoTrans_NoHcopy_SRCCOPY(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									int iHorizMirror)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
    int		    iVertError = 0,
			    iVertAdvanceError,
			    iSrcScanAdvance,
			    iHorizError,
			    iHorizAdvanceError,
			    iSrcPixelAdvance;

    // compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {
		// set up pointers to the first pixels
		// on src and dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++)
		{
		    // copy a pixel
		    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
		    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
		    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
		
		    // advance to next pixel
		    ptSrcPixel += iSrcPixelAdvance;
		    ptDstPixel += iHorizMirror;
		
		    // update and check horizontal stepping error,
		    // adjust src pixel pointer if necessary
		    iHorizError += iHorizAdvanceError;
		    if (iHorizError >= iNumDstCols) {
			ptSrcPixel++;
			iHorizError -= iNumDstCols;
		    }
		}
		
		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;
		
		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
		    pbSrcScanLine += iSrcScanStride;
		    iVertError -= iNumDstRows;
		}
	}
}

void Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									COLORREF crTransparent)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;
	int		iVertError = 0,
			    iVertAdvanceError,
			    iSrcScanAdvance;


	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
			{
			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

        // update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}

	}
}

void Blt24Pto24P_NoBlend_Trans_NoHcopy_SRCCOPY(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									int iHorizMirror,
									COLORREF crTransparent)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;
	int		    iVertError = 0,
			    iVertAdvanceError,
			    iSrcScanAdvance,
			    iHorizError,
			    iHorizAdvanceError,
			    iSrcPixelAdvance;

	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
			{
			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}

            // advance to next pixel
			ptSrcPixel += iSrcPixelAdvance;
			ptDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				ptSrcPixel++;
				iHorizError -= iNumDstCols;
			}

		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanAdvance;
		pbDstScanLine += iDstScanStride;

       	// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows)
        {
			pbSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}

	}
}


void Blt24Pto24P_NoBlend_Trans_Hcopy_SRCCOPY_VCopy(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									COLORREF crTransparent)
{
	RGBTRIPLE    *ptSrcPixel;
	RGBTRIPLE    *ptDstPixel;
	RGBTRIPLE    *ptEndDstPixel;
	BYTE		*pbEndDstScanLine;
	DWORD		dwPixel;

	// set up pointer to next dst scanline beyond last
	pbEndDstScanLine = pbDstScanLine + iNumDstRows * iDstScanStride;

	while (pbDstScanLine != pbEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		ptEndDstPixel = ptDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (ptDstPixel != ptEndDstPixel) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
			{
			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

#ifndef DDRAW
void Blt24Pto24P_Blend_NoTrans_Hcopy_SRCCOPY_VCopy(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel,
				*ptEndDstPixel;
	BYTE		*pbEndDstScanLine;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;
	DWORD		dwSrcColor; 

	// set up pointer to next dst scanline beyond last
	pbEndDstScanLine = pbDstScanLine + iNumDstRows * iDstScanStride;

	while (pbDstScanLine != pbEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		ptEndDstPixel = ptDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (ptDstPixel != ptEndDstPixel) {
			dwSrcColor = (ptSrcPixel->rgbtRed << 16) | 
				     (ptSrcPixel->rgbtGreen << 8) | 
				     (ptSrcPixel->rgbtBlue);

			BlitLib_BLIT_BLEND24(dwSrcColor, ptDstPixel++, uiAlpha, uiAlphaComp);
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

void Blt24Pto24P_Blend_Trans_Hcopy_SRCCOPY_VCopy(
									BYTE* pbSrcScanLine,
									int iSrcScanStride,
									BYTE* pbDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									COLORREF crTransparent,
									ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel,
				*ptEndDstPixel;
	BYTE		*pbEndDstScanLine;
	DWORD		dwPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;

	// set up pointer to next dst scanline beyond last
	pbEndDstScanLine = pbDstScanLine + iNumDstRows * iDstScanStride;

	while (pbDstScanLine != pbEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;
		ptEndDstPixel = ptDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (ptDstPixel != ptEndDstPixel) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
				BlitLib_BLIT_BLEND24(dwPixel, ptDstPixel,
									uiAlpha, uiAlphaComp);
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}
#endif

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_LeftToRight_BottomToTop_Trans_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	crTransparent		Transparent color colorref
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_LeftToRight_BottomToTop_Trans_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              COLORREF crTransparent)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK){
			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine -= iSrcScanStride;
		pbDstScanLine -= iDstScanStride;
	}

}

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_RightToLeft_TopToBottom_Trans_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	crTransparent		Transparent color colorref
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_RightToLeft_TopToBottom_Trans_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              COLORREF crTransparent)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

			dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK){
    			    ((BYTE*)ptDstPixel)[0] = ((BYTE*)ptSrcPixel)[0];
			    ((BYTE*)ptDstPixel)[1] = ((BYTE*)ptSrcPixel)[1];
			    ((BYTE*)ptDstPixel)[2] = ((BYTE*)ptSrcPixel)[2];
			}
			ptDstPixel--;
			ptSrcPixel--;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

#ifndef DDRAW
///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_LeftToRight_BottomToTop_Alpha_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	arAlpha				Alpha value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_LeftToRight_BottomToTop_Alpha_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;
	DWORD		dwSrcColor;


	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {
		    	dwSrcColor = (ptSrcPixel->rgbtRed << 16) | 
				     (ptSrcPixel->rgbtGreen << 8) | 
				     (ptSrcPixel->rgbtBlue);

			BlitLib_BLIT_BLEND24(dwSrcColor, ptDstPixel++,
									uiAlpha, uiAlphaComp);
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine -= iSrcScanStride;
		pbDstScanLine -= iDstScanStride;
	}

}

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_RightToLeft_TopToBottom_Alpha_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	arAlpha				Alpha value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_RightToLeft_TopToBottom_Alpha_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;
	DWORD		dwSrcColor;


	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {
		    	dwSrcColor = (ptSrcPixel->rgbtRed << 16) | 
				     (ptSrcPixel->rgbtGreen << 8) | 
				     (ptSrcPixel->rgbtBlue);
			BlitLib_BLIT_BLEND24(dwSrcColor, ptDstPixel--,
									uiAlpha, uiAlphaComp);
			ptSrcPixel--;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_LeftToRight_BottomToTop_Trans_Alpha_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	crTransparent		Transparent color colorref
//	arAlpha				Alpha value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_LeftToRight_BottomToTop_Trans_Alpha_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              COLORREF crTransparent,
	                                              ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

		    	dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
				BlitLib_BLIT_BLEND24(dwPixel, ptDstPixel,
									uiAlpha, uiAlphaComp);
			ptDstPixel++;
			ptSrcPixel++;
		}

		// advance to next scanline
		pbSrcScanLine -= iSrcScanStride;
		pbDstScanLine -= iDstScanStride;
	}

}

///////////////////////////////////////////////////////////////////////
//
// Private Blt24Pto24P_RightToLeft_TopToBottom_Trans_Alpha_SRCCOPY -
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	crTransparent		Transparent color colorref
//	arAlpha				Alpha value
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
//
///////////////////////////////////////////////////////////////////////
void Blt24Pto24P_RightToLeft_TopToBottom_Trans_Alpha_SRCCOPY(BYTE* pbSrcScanLine,
	                                              int iSrcScanStride,
	                                              BYTE* pbDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              COLORREF crTransparent,
	                                              ALPHAREF arAlpha)
{
	RGBTRIPLE	*ptSrcPixel,
				*ptDstPixel;
	DWORD		dwPixel;
	UINT		uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
				uiAlphaComp = 256 - uiAlpha;


	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		ptSrcPixel = (RGBTRIPLE *)pbSrcScanLine;
		ptDstPixel = (RGBTRIPLE *)pbDstScanLine;

		// copy scanline one pixel at a time
		for (int j = 0; j < iNumDstCols; j++) {

		    	dwPixel = (ptSrcPixel->rgbtRed << 16) | 
				  (ptSrcPixel->rgbtGreen << 8) | 
				  (ptSrcPixel->rgbtBlue);

			// only copy pixel if it's not transparent
			if ((dwPixel ^ (DWORD) crTransparent) & UNUSED_MASK)
				BlitLib_BLIT_BLEND24(dwPixel, ptDstPixel,
									uiAlpha, uiAlphaComp);
			ptDstPixel--;
			ptSrcPixel--;
		}

		// advance to next scanline
		pbSrcScanLine += iSrcScanStride;
		pbDstScanLine += iDstScanStride;
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\blt1616.cxx ===
#include "precomp.hxx"



void Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_Vcopy(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	WORD	*pwSrcPixel,
			*pwDstPixel,
			*pwEndDstPixel,
			*pwEndDstScanLine;

	// set up pointer to next dst scanline beyond last
	pwEndDstScanLine = pwDstScanLine + iNumDstRows * iDstScanStride;

	while (pwDstScanLine != pwEndDstScanLine) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		pwEndDstPixel = pwDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pwDstPixel != pwEndDstPixel) {
			*pwDstPixel++ = *pwSrcPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanStride;
		pwDstScanLine += iDstScanStride;
	}
}

void Blt16to16_NoBlend_NoTrans_Hcopy_SRCCOPY_NoVcopy(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows)
{
	WORD	*pwSrcPixel,
			*pwDstPixel,
			*pwEndDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to first pixels on src and dst
		// scanlines, and next pixel after last on dst
	 	pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		pwEndDstPixel = pwDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pwDstPixel != pwEndDstPixel) {
			*pwDstPixel++ = *pwSrcPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_NoBlend_NoTrans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									int iHorizMirror)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
			*pwDstPixel = *pwSrcPixel;

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_NoBlend_Trans_Hcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									WORD wTransparentColor)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pwSrcPixel != wTransparentColor) {
				*pwDstPixel = *pwSrcPixel;
			}
			pwSrcPixel++;
			pwDstPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_NoBlend_Trans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    WORD wTransparentColor)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if (*pwSrcPixel != wTransparentColor) {
				*pwDstPixel = *pwSrcPixel;
			}

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
#ifndef DDRAW
void Blt16to16_Blend_NoTrans_Hcopy_SRCCOPY(
									WORD* pwSrcScanLine,
                                    int iSrcScanStride,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
									ALPHAREF arAlpha)
{
	WORD	*pwSrcPixel,
			*pwDstPixel,
			*pwEndDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to first pixels on src and dst
		// scanlines, and next pixel after last on dst
	 	pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		pwEndDstPixel = pwDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pwDstPixel != pwEndDstPixel) {
			*pwDstPixel++ = BLIT_BLEND16(*pwSrcPixel,*pwDstPixel,
								uiAlpha,uiAlphaComp);
			pwSrcPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_Blend_NoTrans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
									ALPHAREF arAlpha)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// copy a pixel
 			*pwDstPixel = BLIT_BLEND16(*pwSrcPixel,*pwDstPixel,
 										uiAlpha,uiAlphaComp);

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_Blend_Trans_Hcopy_SRCCOPY(
									WORD* pwSrcScanLine,
                                    int iSrcScanStride,
								    int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    WORD wTransparentColor,
									ALPHAREF arAlpha)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pwSrcPixel != wTransparentColor) {
				*pwDstPixel = BLIT_BLEND16(*pwSrcPixel,*pwDstPixel,
											uiAlpha,uiAlphaComp);
			}
			pwSrcPixel++;
			pwDstPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}

void Blt16to16_Blend_Trans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    WORD wTransparentColor,
									ALPHAREF arAlpha)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	UINT	uiAlpha = (UINT)ALPHAFROMDWORD(arAlpha),
			uiAlphaComp = 256 - uiAlpha;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if (*pwSrcPixel != wTransparentColor) {
				*pwDstPixel = BLIT_BLEND16(*pwSrcPixel,*pwDstPixel,
											uiAlpha,uiAlphaComp);
			}

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}
#endif
// 
// The following blits are included with the 16bpp blits because they are
// entensions of them.  The only difference between these blits and the
// regular 16bpp blits is that these blits only use an 8bpp palette index
// for the transparent color.  The rest of the blit is exactly the same.
//
void Blt08Ato08A_NoBlend_Trans_Hcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcRows,
									WORD* pwDstScanLine,
									int iDstScanStride,
									int iNumDstCols,
									int iNumDstRows,
									BYTE bTransparentColor)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if ((BYTE)*pwSrcPixel != bTransparentColor) {
				*pwDstPixel = *pwSrcPixel;
			}
			pwSrcPixel++;
			pwDstPixel++;
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}


void Blt08Ato08A_NoBlend_Trans_NoHcopy_SRCCOPY(
									WORD* pwSrcScanLine,
									int iSrcScanStride,
									int iNumSrcCols,
									int iNumSrcRows,
                                    WORD* pwDstScanLine,
                                    int iDstScanStride,
                                    int iNumDstCols,
                                    int iNumDstRows,
                                    int iHorizMirror,
                                    BYTE bTransparentColor)
{
	WORD	*pwSrcPixel,
			*pwDstPixel;
	int		iVertError = 0,
			iVertAdvanceError,
			iSrcScanAdvance,
			iHorizError,
			iHorizAdvanceError,
			iSrcPixelAdvance;
	
	// compute advance and error terms for stepping
	// vertically through the src bitmap
	if (iNumSrcRows < iNumDstRows) {
		iSrcScanAdvance = 0;
		iVertAdvanceError = iNumSrcRows;
	} else {
		iSrcScanAdvance = iSrcScanStride * (iNumSrcRows / iNumDstRows);
		iVertAdvanceError = iNumSrcRows % iNumDstRows;
	}

	// compute advance and error terms for stepping
	// horizontally through src bitmap
	if (iNumSrcCols < iNumDstCols) {
		iSrcPixelAdvance = 0;
		iHorizAdvanceError = iNumSrcCols;
	} else {
		iSrcPixelAdvance = iNumSrcCols / iNumDstCols;
		iHorizAdvanceError = iNumSrcCols % iNumDstCols;
	}

	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to the beginning of src and dst scanlines,
		// clear horizontal stepping error accumulator
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		iHorizError = 0;

		for (int j = 0; j < iNumDstCols; j++) {

			// only copy pixel if it's not transparent
			if ((BYTE)*pwSrcPixel != bTransparentColor) {
				*pwDstPixel = *pwSrcPixel;
			}

			// advance to next pixel
			pwSrcPixel += iSrcPixelAdvance;
			pwDstPixel += iHorizMirror;

			// update and check horizontal stepping error,
			// adjust src pixel pointer if necessary
			iHorizError += iHorizAdvanceError;
			if (iHorizError >= iNumDstCols) {
				pwSrcPixel++;
				iHorizError -= iNumDstCols;
			}
		}

		// advance to next scanline
		pwSrcScanLine += iSrcScanAdvance;
		pwDstScanLine += iDstScanStride;

		// update and check vertical stepping error,
		// adjust src scanline pointer if necessary
		iVertError += iVertAdvanceError;
		if (iVertError >= iNumDstRows) {
			pwSrcScanLine += iSrcScanStride;
			iVertError -= iNumDstRows;
		}
	}	
}


///////////////////////////////////////////////////////////////////////
//
// Private Blt16to16_LeftToRight_BottomToTop_SRCOPY - 
//		BitBlit from source bitmap to destination bitmap (where these
//		bitmaps overlap) by walking both the source and destination
//		from left to right and bottom to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt16to16_LeftToRight_BottomToTop_SRCCOPY(WORD* pwSrcScanLine,
	                                              int iSrcScanStride,
	                                              WORD* pwDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows)
{
	WORD	*pwSrcPixel,
			*pwDstPixel,
			*pwEndDstPixel;

	for (int i = 0; i < iNumDstRows; i++) {

		// set up pointers to the first pixels
		// on src and dst scanlines, and next
		// pixel after last on dst scanline
		pwSrcPixel = pwSrcScanLine;
		pwDstPixel = pwDstScanLine;
		pwEndDstPixel = pwDstPixel + iNumDstCols;

		// copy scanline one pixel at a time
		while (pwDstPixel != pwEndDstPixel) {
			*pwDstPixel++ = *pwSrcPixel++;
		}

		// advance to next scanline
		pwSrcScanLine -= iSrcScanStride;
		pwDstScanLine -= iDstScanStride;
	}
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt16to16_RightToLeft_TopToBottom_SRCOPY - 
//		BitBlit from source bitmap to destination bitmap (where these
//		bitmaps overlap) by walking both the source and destination
//		from right to left and top to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt16to16_RightToLeft_TopToBottom_SRCCOPY(WORD* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              WORD* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows)
{
	WORD	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++)
			*pDstPixel-- = *pSrcPixel--;

		// advance to next scanline
		pSrcScanLine += iSrcScanStride;
		pDstScanLine += iDstScanStride;

	}	
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt16to16_LeftToRight_BottomToTop_Trans_SRCCOPY - 
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from left to right and bottom
//		to top
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	bTransparentIndex	Palette Index of the transparent color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt16to16_LeftToRight_BottomToTop_Trans_SRCCOPY(WORD* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              WORD* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              WORD wTransparentIndex)
{
	WORD	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pSrcPixel != wTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
			pSrcPixel++;
			pDstPixel++;
		}

		// advance to next scanline
		pSrcScanLine -= iSrcScanStride;
		pDstScanLine -= iDstScanStride;

	}	
}

///////////////////////////////////////////////////////////////////////
//
// Private Blt16to16_RightToLeft_TopToBottom_Trans_SRCOPY - 
//		BitBlit using a transparent color index from source bitmap to
//		destination bitmap (where these bitmaps overlap) by walking
//		both the source and destination from right to left and top
//		to bottom
//
// Parameters:
//	pSrcScanLine		Pointer to the first Source scan line
//	iSrcScanStride		The Source scan stride
//	pDstScanLine		Pointer to the first Destination scan line
//	iDstScanStride		The Destination scan stride
//	iNumDstCols			Number of destination columns
//	iNumDstRows			Number of destination rows
//	bTransparentIndex	Palette Index of the transparent color
//
// Return Value:
//  NO_ERROR or E_* value as specified in the .H file.
// 
///////////////////////////////////////////////////////////////////////
void Blt16to16_RightToLeft_TopToBottom_Trans_SRCCOPY(WORD* pSrcScanLine,
	                                              int iSrcScanStride,
	                                              WORD* pDstScanLine,
												  int iDstScanStride,
	                                              int iNumDstCols,
	                                              int iNumDstRows,
	                                              WORD wTransparentIndex)
{
	WORD	*pSrcPixel,
			*pDstPixel;
	
	for (int i = 0; i < iNumDstRows; i++) {

		// set pointers to beginning of src and dest scanlines
		pSrcPixel = pSrcScanLine;
		pDstPixel = pDstScanLine;

		for (int j = 0; j < iNumDstCols; j++) {
			
			// only copy pixel if it's not transparent
			if (*pSrcPixel != wTransparentIndex) {
				*pDstPixel = *pSrcPixel;
			}
			pSrcPixel--;
			pDstPixel--;
		}

		// advance to next scanline
		pSrcScanLine += iSrcScanStride;
		pDstScanLine += iDstScanStride;

	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\gfxtypes.h ===
typedef DWORD ALPHAREF;
typedef ALPHAREF *LPALPHAREF;

#define ALPHA_INVALID 0xffffffff
typedef BYTE *PDIBBITS;
typedef LPBITMAPINFO PDIBINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\dibfx.h ===
/*-----------------------------------------------------------------------------*\
|   Routines for dealing with Device independent bitmaps                       	|
|									       										|
|   History:                                                                    |
|       06/23/89 toddla     Created 											|
|		04/25/94 michaele	Using in sprite library, removed all dib.c funcs	|
|							only using the MACRO stuff.                        	|
|                                                                              	|
\*-----------------------------------------------------------------------------*/

#ifndef _INC_DIB_
#define _INC_DIB_

#ifdef __cplusplus
extern "C" {
#endif

typedef     LPBITMAPINFOHEADER 	PDIB;
typedef     HANDLE             	HDIB;

#ifdef WIN32
#define 	HFILE   			HANDLE
#endif

PDIB        DibOpenFile(LPTSTR szFile);
BOOL        DibWriteFile(PDIB pdib, LPTSTR szFile);
PDIB        DibReadBitmapInfo(HFILE fh);
HPALETTE    DibCreatePalette(PDIB pdib);
BOOL        DibSetUsage(PDIB pdib, HPALETTE hpal,UINT wUsage);
BOOL        DibDraw(HDC hdc, int x, int y, int dx, int dy, PDIB pdib,
				int x0, int y0,	int dx0, int dy0, LONG rop, UINT wUsage);
PDIB        DibCreate(int bits, int dx, int dy);
PDIB        DibCopy(PDIB pdib);
void        DibMapToPalette(PDIB pdib, HPALETTE hpal);
PDIB 	    DibConvert(PDIB pdib, int BitCount, DWORD biCompression);
PDIB		DibHalftoneDIB(PDIB pdib);

PDIB        DibFromBitmap(HBITMAP hbm, DWORD biStyle, UINT biBits,
							HPALETTE hpal, UINT wUsage);
HBITMAP     BitmapFromDib(PDIB pdib, HPALETTE hpal, UINT wUsage);

void        MakeIdentityPalette(HPALETTE hpal);
HPALETTE    CopyPalette(HPALETTE hpal);

/****************************************************************************
 DIB macros.
 ***************************************************************************/

#ifdef  WIN32
    #define HandleFromDib(lpbi) GlobalHandle(lpbi)
#else
    #define HandleFromDib(lpbi) (HANDLE)GlobalHandle(SELECTOROF(lpbi))
#endif

#define DibFromHandle(h)        (PDIB)GlobalLock(h)

#define DibFree(pdib)           GlobalFreePtr(pdib)

#define WIDTHBYTES(i)	((unsigned)((i+31)&(~31))/8)  /* ULONG aligned ! */

#define DibWidth(lpbi)			(UINT)(((LPBITMAPINFOHEADER)(lpbi))->biWidth)
#define DibHeight(lpbi)         (((LPBITMAPINFOHEADER)(lpbi))->biHeight)
#define DibBitCount(lpbi)       (UINT)(((LPBITMAPINFOHEADER)(lpbi))->biBitCount)
#define DibCompression(lpbi)    (DWORD)(((LPBITMAPINFOHEADER)(lpbi))->biCompression)

#define DibWidthBytesN(lpbi, n) (UINT)WIDTHBYTES((UINT)(lpbi)->biWidth * (UINT)(n))
#define DibWidthBytes(lpbi)     DibWidthBytesN(((LPBITMAPINFOHEADER)lpbi), \
								((LPBITMAPINFOHEADER)lpbi)->biBitCount)

#define DibSizeImage(lpbi)		((lpbi)->biSizeImage == 0 \
	                            ? ((DWORD)(UINT)DibWidthBytes(lpbi) * \
	                            (DWORD)(UINT)(lpbi)->biHeight) \
	                            : (lpbi)->biSizeImage)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + \
								(int)(lpbi)->biClrUsed * sizeof(RGBQUAD))
#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))

#define DibFlipY(lpbi, y)       ((int)(lpbi)->biHeight-1-(y))

//HACK for NT BI_BITFIELDS DIBs
#ifdef WIN32
    #define DibPtr(lpbi)		((lpbi)->biCompression == BI_BITFIELDS \
                               	? (LPVOID)(DibColors(lpbi) + 3) \
                               	: (LPVOID)(DibColors(lpbi) + \
                               	(UINT)(lpbi)->biClrUsed))
#else
    #define DibPtr(lpbi)        (LPVOID)(DibColors(lpbi) + \
    							(UINT)(lpbi)->biClrUsed)
#endif

#define DibColors(lpbi)         ((RGBQUAD FAR *)((LPBYTE)(lpbi) + \
								(int)(lpbi)->biSize))

#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && \
								(lpbi)->biBitCount <= 8 \
                                ? (int)(1 << (int)(lpbi)->biBitCount) \
                                : (int)(lpbi)->biClrUsed)

#define DibXYN(lpbi,pb,x,y,n)   (LPVOID)( \
                                (BYTE *)(pb) + \
                                (UINT)((UINT)(x) * (UINT)(n) / 8u) + \
                                ((DWORD)DibWidthBytesN(lpbi,n) * \
                                (DWORD)(UINT)(y)))

#define DibXY(lpbi,x,y)		DibXYN(lpbi,DibPtr(lpbi),x,y,(lpbi)->biBitCount)

#define FixBitmapInfo(lpbi)     if ((lpbi)->biSizeImage == 0)                 \
                                    (lpbi)->biSizeImage = DibSizeImage(lpbi); \
                                if ((lpbi)->biClrUsed == 0)                   \
                                    (lpbi)->biClrUsed = DibNumColors(lpbi);   \
                                if ((lpbi)->biCompression == BI_BITFIELDS &&  \
                                	(lpbi)->biClrUsed == 0) \
                                    ; // (lpbi)->biClrUsed = 3;

#define DibInfo(pDIB)			((BITMAPINFO FAR *)(pDIB))

/****************************************************************************
 ***************************************************************************/

#ifndef BI_BITFIELDS
	#define BI_BITFIELDS 3
#endif

#ifndef HALFTONE
	#define HALFTONE COLORONCOLOR
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DIB_

/*************************************************************************
	dibfx.h

	Header file for various DIB-to-DIB effects

	02/08/94	Compiled by Jonbl
*/

#ifndef _INC_DIBFX_
#define _INC_DIBFX_

#ifdef WIN95
	#ifndef _INC_WINDOWS
	#include <windows.h>
	#include <windowsx.h>
	#endif
#endif //WIN95

#ifdef __cplusplus
extern "C" {
#endif

/*************************************************************************
	Many of the DIBFX functions use fixed point calculations internally.

	These functions are defined in fixed32.asm
*/

typedef long Fixed;

Fixed __stdcall FixedMultiply( Fixed Multiplicand, Fixed Multiplier );

Fixed __stdcall FixedDivide( Fixed Dividend, Fixed Divisor );

#define IntToFixed(i) (Fixed)( ((long)(i)) << 16 )
#define FixedToShort(f) (short)( ((long)f) >> 16 )

/*
 *	DibClear
 *	Fills a DIB's memory with a given value, effectively clearing
 *	an 8-bit, 4-bit or 1-bit DIB.
 *
 *	Does not do what you would expect on 16, 24, or 32-bit DIBs,
 *	but it will work.
 *
 *	Source is in clear.c and clear32.asm
 */

BOOL FAR PASCAL DibClear(LPBITMAPINFO lpbiDst, LPVOID lpDst, BYTE value);



#ifdef __cplusplus
}
#endif

#endif // _INC_DIBFX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\ntblt.h ===
#include <stddef.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#ifdef NT_KERNEL
    #include <ntos.h>
    #include <zwapi.h>
    #include <wingdip.h>
#endif
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>

#ifndef NT_KERNEL
    #include <winnt.h>
    #include <winbase.h>
    #include <winuser.h>
#endif
typedef ULONG SCODE;
typedef long HRESULT;

//#include "ntkmode.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\util4d.h ===
#ifndef _UTIL4D_H_
#define _UTIL4D_H_

#define	ULONG_MAX	0xffffffff

#ifdef _4DEXPORTING
#define	DLLDECL	dllexport
#else
#define	DLLDECL	dllimport
#endif

#define	STD4DDLL		__declspec(DLLDECL) __stdcall
#define	STD4DDLL_(type)	__declspec(DLLDECL) type __stdcall

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\blitlib\sources.inc ===
TARGETNAME = blitlib
TARGETPATH = obj
TARGETTYPE = LIBRARY

SOURCES = \
    ..\bitblt.cxx   \
    ..\blt1616.cxx  \
    ..\blt2424.cxx  \
    ..\blt0101.cxx  \
    ..\bt24p24p.cxx \
    ..\blt0808.cxx

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\precomp.hxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\pch.c ===
#ifdef DBG
#undef DEBUG
#define DEBUG
#endif

#include <windows.h>
#include <mmsystem.h>
#include "ddhelp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\ddhelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddhelp.c
 *  Content: 	helper app to cleanup after dead processes
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   29-mar-95	craige	initial implementation
 *   09-may-95	craige	call fn in dll
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   29-nov-95  angusm  added DDHELPREQ_CREATEDSFOCUSTHREAD
 *   18-jul-96	andyco	added dplayhelp_xxx functions to allow > 1 dplay app to
 *			host a game on a single machine.
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *			it in dphelps receive thread before forwarding requests
 *   05-oct-96  colinmc fixed build breaker with CRITICAL SECTION stuff
 *   12-oct-96  colinmc new service to load the DirectX VXD into DDHELP
 *                      (necessary for the Win16 lock stuff)
 *   18-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#ifndef __DDHELP_INCLUDED__
#define __DDHELP_INCLUDED__

/*
 * globals
 */
#ifndef NO_D3D
extern CRITICAL_SECTION    	cs; 	// the crit section we take in winmain
					// this is a global so dphelp can take it before
					// forwarding enum requests that come in on its
					// receive thread (manbugs 3907)
#endif

/*
 * named objects
 */
#define DDHELP_EVENT_NAME		"__DDHelpEvent__"
#define DDHELP_ACK_EVENT_NAME		"__DDHelpAckEvent__"
#define DDHELP_STARTUP_EVENT_NAME	"__DDHelpStartupEvent__"
#define DDHELP_SHARED_NAME		"__DDHelpShared__"
#define DDHELP_MUTEX_NAME		"__DDHelpMutex__"
#define DDHELP_MODESET_EVENT_NAME	"__DDHelpModeSetEvent%d__"
#define DDHELP_DOSBOX_EVENT_NAME	"__DDHelpDOSBoxSetEvent%d__"
#define DDHELP_APMSUSPEND_EVENT_NAME    "__DDHelpApmSuspendEvent__"
#define DDHELP_APMRESUME_EVENT_NAME     "__DDHelpApmResumeEvent__"

/*
 * requests
 */
#define DDHELPREQ_NEWPID		1
#define DDHELPREQ_NEWDC			2
#define DDHELPREQ_FREEDCLIST		3
#define DDHELPREQ_RETURNHELPERPID	4
#define DDHELPREQ_LOADDLL		5
#define DDHELPREQ_FREEDLL		6
#define DDHELPREQ_SUICIDE		7
#define DDHELPREQ_KILLATTACHED		8
#define DDHELPREQ_WAVEOPEN		9
#define DDHELPREQ_WAVECLOSE		10
#define DDHELPREQ_CREATETIMER		11
#define DDHELPREQ_KILLTIMER		12
#define DDHELPREQ_CREATEHELPERTHREAD	13
#define DDHELPREQ_CREATEMODESETTHREAD	14
#define DDHELPREQ_KILLMODESETTHREAD	15
#define DDHELPREQ_CREATEDSMIXERTHREAD	16
#define DDHELPREQ_CALLDSCLEANUP         17
#define DDHELPREQ_CREATEDSFOCUSTHREAD	18
#define DDHELPREQ_DPLAYADDSERVER	19
#define DDHELPREQ_DPLAYDELETESERVER	20
#ifdef WIN95
    #define DDHELPREQ_GETDSVXDHANDLE        21
#endif /* WIN95 */
#define DDHELPREQ_NOTIFYONDISPLAYCHANGE	22
#ifdef WIN95
    #define DDHELPREQ_CREATEDOSBOXTHREAD    23
    #define DDHELPREQ_KILLDOSBOXTHREAD      24
#endif /* WIN95 */
#define DDHELPREQ_LOADLIBRARY           25
#define DDHELPREQ_FREELIBRARY           26
#define DDHELPREQ_STOPWATCHPID          27
#define DDHELPREQ_ADDDEVICECHANGENOTIFY 28
#define DDHELPREQ_DELDEVICECHANGENOTIFY 29
#ifdef WIN95
    #define DDHELPREQ_GETDDVXDHANDLE        30
#endif /* WIN95 */

/*
 * callback routine
 */
typedef BOOL	(FAR PASCAL *LPHELPNOTIFYPROC)(struct DDHELPDATA *);
typedef BOOL	(FAR PASCAL *LPHELPMODESETNOTIFYPROC)( LPVOID lpDD );
typedef void    (FAR PASCAL *LPDSCLEANUP)(LPVOID pds);
typedef BOOL    (FAR PASCAL *LPDEVICECHANGENOTIFYPROC)(UINT, DWORD);

/*
 * communication data
 */
typedef struct DDHELPDATA
{
    int			req;
    HANDLE		req_id;
    DWORD		pid;
    BOOL		isdisp;
    union
    {
	LPHELPNOTIFYPROC	lpNotify;
	LPHELPMODESETNOTIFYPROC	lpModeSetNotify;
    };
    DWORD		context;
    char		fname[260];
    char		func[64];
    ULONG_PTR	        dwData1;
    ULONG_PTR	        dwData2;
    LPVOID		pData1;
    LPVOID		pData2;
    ULONG_PTR	        dwReturn;
} DDHELPDATA, *LPDDHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\ddhelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddhelp.c
 *  Content: 	helper app to cleanup after dead processes
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   29-mar-95	craige	initial implementation
 *   05-apr-95	craige	re-worked
 *   11-apr-95	craige	fixed messed up freeing of DC list
 *   12-apr-95	craige	only allocate each DC once
 *   09-may-95	craige	call fn in dll
 *   24-jun-95	craige	track pids; slay all attached if asked
 *   19-jul-95	craige	free DC list at DDRAW request
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset;
 *			memory allocation bugs
 *   15-aug-95	craige	bug 538: 1 thread/process being watched
 *   02-sep-95	craige	bug 795: prevent callbacks at WM_ENDSESSION
 *   16-sep-95	craige	bug 1117: don't leave view of file mapped always
 *   16-sep-95	craige	bug 1117: also close thread handles when done!
 *   20-sep-95	craige	bug 1172: turn off callbacks instead of killing self
 *   22-sep-95	craige	bug 1117: also don't alloc dll structs unboundedly
 *   29-nov-95  angusm  added case for creating a sound focus thread
 *   12-jul-96	kylej	Change ExitProcess to TerminateProcess on exception
 *   18-jul-96	andyco	added dplayhelp_xxx functions to allow > 1 dplay app to
 *			host a game on a single machine.
 *   25-jul-96  andyco	watchnewpid - broke code out of winmain so dplayhelp_addserver
 *			could call it.
 *   2-oct-96	andyco	propagated from \orange\ddhelp.2 to \mustard\ddhelp
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *			it in dphelps receive thread before forwarding requests
 *   12-oct-96  colinmc new service to load the DirectX VXD into DDHELP
 *                      (necessary for the Win16 lock stuff)
 *   15-oct-96  toddla  multimonitor support (call CreateDC with device name)
 *   22-jan-97  kipo	return an error code from DPlayHelp_AddServer
 *   23-jan-97  dereks  added APM notification events
 *   27-jan-97  colinmc vxd handling stuff is no longer Win16 specific
 *   29-jan-97  colinmc 
 *   24-feb-97	ketand	Add a callback for WM_DISPLAYCHANGE
 *   19-mar-97  twillie Exorcized the DPlay Demon from DDHelp
 *
 ***************************************************************************/

#include "pch.c"

#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN

#ifdef WIN95
#ifdef _WIN32
#define WINMMDEVICECHANGEMSGSTRINGA "winmm_devicechange"
#define WINMMDEVICECHANGEMSGSTRINGW L"winmm_devicechange"
#ifdef UNICODE
#define WINMMDEVICECHANGEMSGSTRING WINMMDEVICECHANGEMSGSTRINGW
#else
#define WINMMDEVICECHANGEMSGSTRING WINMMDEVICECHANGEMSGSTRINGA
#endif
#else
#define WINMMDEVICECHANGEMSGSTRING "winmm_devicechange"
#endif

#define FILE_FLAG_GLOBAL_HANDLE	0x00800000
WINBASEAPI
DWORD
WINAPI
RegisterServiceProcess(
    DWORD dwProcessId,
    DWORD dwServiceType
    );

#define RSP_UNREGISTER_SERVICE  0x00000000
#define RSP_SIMPLE_SERVICE      0x00000001
#endif

#ifndef WIN95
    #ifdef DBG
        #undef DEBUG
        #define DEBUG
    #endif
#endif

//#include <windows.h>
//#include <mmsystem.h>
#include <mmreg.h>
#undef PBT_APMRESUMEAUTOMATIC
#include <pbt.h>
#include <dbt.h>

//#include "ddhelp.h"
#include "ddrawi.h"
#include "dpf.h"
#define  NOSHARED
#include "memalloc.h"

#ifdef NEED_WIN16LOCK
    extern void _stdcall	GetpWin16Lock( LPVOID FAR *);
    extern void _stdcall	_EnterSysLevel( LPVOID );
    extern void _stdcall	_LeaveSysLevel( LPVOID );
    LPVOID			lpWin16Lock;
#endif

HANDLE 			hInstApp;
extern BOOL		bIsActive;
BOOL			bHasModeSetThread;
BOOL			bNoCallbacks;
extern void 		HelperThreadProc( LPVOID *pdata );
CRITICAL_SECTION    	cs; 	// the crit section we take in winmain
				// this is a global so dphelp can take it before
				// forwarding enum requests that come in on its
				// receive thread (manbugs 3907)
HANDLE                  hApmSuspendEvent;   // Event set when we enter an APM suspension state
HANDLE                  hApmResumeEvent;    // Event set when we leave the above state

#ifdef WIN95
    UINT                    gumsgWinmmDeviceChange = 0; // window message for
                                                        // winmm device changes

    /*
     * Handle to the DirectSound VXD. DDHELP needs its own handle as, on mode
     * switches and cleanups DDHELP can invoked DDRAW code that needs to talk
     * to the VXD. The VXD is opened on the first request from a client (currently
     * only DDRAW) and closed only when DDHELP shuts down.
     */
    HANDLE		    hDSVxd = INVALID_HANDLE_VALUE;
    HANDLE                  hDDVxd = INVALID_HANDLE_VALUE;

    typedef struct _DEVICECHANGENOTIFYLIST
    {
        struct _DEVICECHANGENOTIFYLIST *link;
        LPDEVICECHANGENOTIFYPROC        lpNotify;
    } DEVICECHANGENOTIFYLIST, *LPDEVICECHANGENOTIFYLIST;

    LPDEVICECHANGENOTIFYLIST lpDeviceChangeNotifyList;
#endif /* WIN95 */

typedef struct HDCLIST
{
    struct HDCLIST	*link;
    HDC			hdc;
    HANDLE		req_id;
    char		isdisp;
    char		fname[1];
} HDCLIST, *LPHDCLIST;

static LPHDCLIST	lpHDCList;

typedef struct HDLLLIST
{
    struct HDLLLIST	*link;
    HANDLE		hdll;
    DWORD		dwRefCnt;
    char		fname[1];
} HDLLLIST, *LPHDLLLIST;

static LPHDLLLIST	lpHDLLList;

/*
 * 8 callbacks: we can use up to 3 currently: ddraw, dsound
 */
#define MAX_CALLBACKS	8

typedef struct _PROCESSDATA
{
    struct _PROCESSDATA		*link;
    DWORD			pid;
    struct
    {
	LPHELPNOTIFYPROC	lpNotify;
	HANDLE			req_id;
    } pdata[MAX_CALLBACKS];
} PROCESSDATA, *LPPROCESSDATA;

LPPROCESSDATA		lpProcessList;
CRITICAL_SECTION	pdCSect;


typedef struct THREADLIST
{
    struct THREADLIST	*link;
    ULONG_PTR	        hInstance;
    HANDLE		hEvent;
} THREADLIST, *LPTHREADLIST;

typedef struct
{
    LPVOID			lpDD;
    LPHELPMODESETNOTIFYPROC	lpProc;
    HANDLE			hEvent;
} MODESETTHREADDATA, *LPMODESETTHREADDATA;

LPTHREADLIST	lpThreadList;
THREADLIST	DOSBoxThread;

// Who to call when a display change message is sent to the
// DDHELPER's window. This variable is reserved by DDraw.
// This works because DDraw itself is loaded into DDHelper's
// process and so the function will remain valid.
VOID (*g_pfnOnDisplayChange)(void) = NULL;

/*
 * freeDCList
 *
 * Free all DC's that an requestor allocated.
 */
void freeDCList( HANDLE req_id )
{
    LPHDCLIST	pdcl;
    LPHDCLIST	last;
    LPHDCLIST	next;

    DPF( 4, "Freeing DCList" );
    pdcl = lpHDCList;
    last = NULL;
    while( pdcl != NULL )
    {
	next = pdcl->link;
	if( (pdcl->req_id == req_id) || req_id == (HANDLE) -1 )
	{
	    if( last == NULL )
	    {
		lpHDCList = lpHDCList->link;
	    }
	    else
	    {
		last->link = pdcl->link;
	    }
	    if( pdcl->isdisp )
	    {
		DPF( 5, "    ReleaseDC( NULL, %08lx)", pdcl->hdc );
//		ReleaseDC( NULL, pdcl->hdc );
		DeleteDC( pdcl->hdc );
		DPF( 5, "    Back from Release" );
	    }
	    else
	    {
		DPF( 5, "    DeleteDC( %08lx)", pdcl->hdc );
		DeleteDC( pdcl->hdc );
		DPF( 5, "    Back from DeleteDC" );
	    }
	    MemFree( pdcl );
	}
	else
	{
	    last = pdcl;
	}
	pdcl = next;
    }
    if ( req_id == (HANDLE) -1 )
    {
        DDASSERT (lpHDCList == NULL);
    }
    DPF( 4, "DCList FREE" );

} /* freeDCList */

/*
 * addDC
 */
void addDC( char *fname, BOOL isdisp, HANDLE req_id )
{
    LPHDCLIST	pdcl;
    HDC		hdc;
    UINT	u;

    pdcl = lpHDCList;
    while( pdcl != NULL )
    {
	if( !_stricmp( fname, pdcl->fname ) )
	{
	    DPF( 4, "DC for %s already obtained (%08lx)", fname, pdcl->hdc );
	    return;
	}
	pdcl = pdcl->link;
    }

    if( isdisp )
    {
	hdc = CreateDC( "display", NULL, NULL, NULL);
	DPF( 4, "CreateDC( \"display\" ) = %08lx", hdc );
    }
    else
    {
	DPF( 4, "About to CreateDC( \"%s\" )", fname );
        //
        //  if fname is a device name of the form "\\.\XXXXXX"
        //  we need to call CreateDC differently
        //
        u = SetErrorMode( SEM_NOOPENFILEERRORBOX );
        if (fname && fname[0] == '\\' && fname[1] == '\\' && fname[2] == '.')
            hdc = CreateDC( NULL, fname, NULL, NULL);
        else
            hdc = CreateDC( fname, NULL, NULL, NULL);
	SetErrorMode( u );
    }

    pdcl = MemAlloc( sizeof( HDCLIST ) + lstrlen( fname ) );
    if( pdcl != NULL )
    {
	pdcl->hdc = hdc;
	pdcl->link = lpHDCList;
	pdcl->isdisp = (CHAR)isdisp;
	pdcl->req_id = req_id;
	lstrcpy( pdcl->fname, fname );
	lpHDCList = pdcl;
    }

} /* addDC */

/*
 * loadDLL
 */
DWORD loadDLL( LPSTR fname, LPSTR func, DWORD context )
{
    HANDLE	hdll;
    LPHDLLLIST  pdll;
    DWORD       rc = 0;

    /*
     * load the dll
     */
    hdll = LoadLibrary( fname );
    DPF( 5, "%s: hdll = %08lx", fname, hdll );
    if( hdll == NULL )
    {
	DPF( 1, "Could not load library %s",fname );
	return 0;
    }

    /*
     * invoke specified function
     */

    if( func[0] != 0 )
    {
	LPDD32BITDRIVERINIT	pfunc;
	pfunc = (LPVOID) GetProcAddress( hdll, func );
	if( pfunc != NULL )
	{
            rc = pfunc( context );
	}
	else
	{
            DPF( 1, "Could not find procedure %s", func );
	}
    }
    else
    {
        rc = 1;
    }

    /*
     * see if we have recorded this DLL loading already
     */
    pdll = lpHDLLList;
    while( pdll != NULL )
    {
	if( !lstrcmpi( pdll->fname, fname ) )
	{
	    DPF( 3, "DLL '%s' already loaded", fname );
	    break;
	}
	pdll = pdll->link;
    }
    if( pdll == NULL )
    {
	pdll = MemAlloc( sizeof( HDLLLIST ) + lstrlen( fname ) );
	if( pdll != NULL )
	{
	    pdll->hdll = hdll;
	    pdll->link = lpHDLLList;
	    lstrcpy( pdll->fname, fname );
	    lpHDLLList = pdll;
	}
    }
    if( pdll != NULL )
    {
	pdll->dwRefCnt++;
    }
    return rc;

} /* loadDLL */

/*
 * freeDLL
 */
HANDLE freeDLL( LPSTR fname )
{
    LPHDLLLIST	pdll;
    LPHDLLLIST	last;
    HANDLE	hdll;

    pdll = lpHDLLList;
    last = NULL;
    while( pdll != NULL )
    {
	if( !lstrcmpi( pdll->fname, fname ) )
	{
	    DPF( 4, "Want to free DLL %s (%08lx)", fname, pdll->hdll );
	    hdll = pdll->hdll;
	    if( last == NULL )
	    {
		lpHDLLList = lpHDLLList->link;
	    }
	    else
	    {
		last->link = pdll->link;
	    }
	    MemFree( pdll );
	    return hdll;
	}
	last = pdll;
	pdll = pdll->link;
    }
    return NULL;

} /* freeDLL */

#ifdef WIN95
    /*
     * return a handle to the DirectSound VXD
     */
    DWORD getDSVxdHandle( void )
    {
        if( INVALID_HANDLE_VALUE == hDSVxd )
	{
	    hDSVxd = CreateFile( "\\\\.\\DSOUND.VXD",
				 GENERIC_WRITE,
				 FILE_SHARE_WRITE,
				 NULL,
				 OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
				 NULL );
	    #ifdef DEBUG
		if( INVALID_HANDLE_VALUE == hDSVxd )
		    DPF( 0, "Could not load the DirectSound VXD" );
	    #endif /* DEBUG */
	}
	return (DWORD) hDSVxd;
    } /* getDSVxdHandle */

    /*
     * return a handle to the DirectDraw VXD
     */
    DWORD getDDVxdHandle( void )
    {
        if( INVALID_HANDLE_VALUE == hDDVxd )
	{
            hDDVxd = CreateFile( "\\\\.\\DDRAW.VXD",
				 GENERIC_WRITE,
				 FILE_SHARE_WRITE,
				 NULL,
				 OPEN_EXISTING,
				 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
				 NULL );
	    #ifdef DEBUG
                if( INVALID_HANDLE_VALUE == hDDVxd )
                    DPF( 0, "Could not load the DirectDraw VXD" );
	    #endif /* DEBUG */
	}
        return (DWORD) hDDVxd;
    } /* getDDVxdHandle */

/*
 * addDeviceChangeNotify
 */
void addDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    LPDEVICECHANGENOTIFYLIST    pNode;

    pNode = (LPDEVICECHANGENOTIFYLIST)MemAlloc(sizeof(DEVICECHANGENOTIFYLIST));

    if(pNode)
    {
        pNode->link = lpDeviceChangeNotifyList;
        pNode->lpNotify = lpNotify;

        lpDeviceChangeNotifyList = pNode;
    }

} /* addDeviceChangeNotify */

/*
 * delDeviceChangeNotify
 */
void delDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    LPDEVICECHANGENOTIFYLIST    pNode;
    LPDEVICECHANGENOTIFYLIST    pPrev;

    for(pNode = lpDeviceChangeNotifyList, pPrev = NULL; pNode; pPrev = pNode, pNode = pNode->link)
    {
        if(lpNotify == pNode->lpNotify)
        {
            break;
        }
    }

    if(pNode)
    {
        if(pPrev)
        {
            pPrev->link = pNode->link;
        }

        MemFree(pNode);
    }

} /* delDeviceChangeNotify */

/*
 * onDeviceChangeNotify
 */
BOOL onDeviceChangeNotify(UINT Event, DWORD Data)
{
    BOOL                        fAllow  = TRUE;
    LPDEVICECHANGENOTIFYLIST    pNode;

    __try
    {
        for(pNode = lpDeviceChangeNotifyList; pNode; pNode = pNode->link)
        {
            if(TRUE != pNode->lpNotify(Event, Data))
            {
                fAllow = BROADCAST_QUERY_DENY;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF(0, "*********************************************************");
        DPF(0, "******** exception during device change notify **********");
        DPF(0, "*********************************************************");
    }

    return fAllow;

} /* delDeviceChangeNotify */

/*
 * freeDeviceChangeNotifyList
 */
void freeDeviceChangeNotifyList(void)
{
    LPDEVICECHANGENOTIFYLIST    pNext;
    
    while(lpDeviceChangeNotifyList)
    {
        pNext = lpDeviceChangeNotifyList->link;
        MemFree(lpDeviceChangeNotifyList);
        lpDeviceChangeNotifyList = pNext;
    }

} /* freeDeviceChangeNotifyList */
#endif /* WIN95 */

/*
 * freeAllResources
 */
void freeAllResources( void )
{
    LPHDLLLIST	pdll;
    LPHDLLLIST	next;

    freeDCList( (HANDLE) -1 );
    pdll = lpHDLLList;
    while( pdll != NULL )
    {
	while( pdll->dwRefCnt >  0 )
	{
	    FreeLibrary( pdll->hdll );
	    pdll->dwRefCnt--;
	}
	next = pdll->link;
	MemFree( pdll );
	pdll = next;
    }

#ifdef WIN95
    freeDeviceChangeNotifyList();
#endif
} /* freeAllResources */

/*
 * ThreadProc
 *
 * Open a process and wait for it to terminate
 */
VOID ThreadProc( LPVOID *pdata )
{
    HANDLE		hproc;
    DWORD		rc;
    LPPROCESSDATA	ppd;
    LPPROCESSDATA	curr;
    LPPROCESSDATA	prev;
    DDHELPDATA		hd;
    int			i;
    PROCESSDATA		pd;

    ppd = (LPPROCESSDATA) pdata;

    /*
     * get a handle to the process that attached to DDRAW
     */
    DPF( 3, "Watchdog thread started for pid %08lx", ppd->pid );

    hproc = OpenProcess( PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
			    FALSE, ppd->pid );
    if( hproc == NULL )
    {
	DPF( 1, "OpenProcess for %08lx failed!", ppd->pid );
	ExitThread( 0 );
    }

    /*
     * wait for process to die
     */
    rc = WaitForSingleObject( hproc, INFINITE );
    if( rc == WAIT_FAILED )
    {
	DPF( 1, "Wait for process %08lx failed", ppd->pid );
	CloseHandle( hproc );
	ExitThread( 0 );
    }

    /*
     * remove process from the list of watched processes
     */
    EnterCriticalSection( &pdCSect );
    pd = *ppd;
    curr = lpProcessList;
    prev = NULL;
    while( curr != NULL )
    {
	if( curr == ppd )
	{
	    if( prev == NULL )
	    {
		lpProcessList = curr->link;
	    }
	    else
	    {
		prev->link = curr->link;
	    }
	    DPF( 4, "PID %08lx removed from list", ppd->pid );
	    MemFree( curr );
	    break;
	}
	prev = curr;
	curr = curr->link;
    }

    if( bNoCallbacks )
    {
	DPF( 1, "No callbacks allowed: leaving thread early" );
	LeaveCriticalSection( &pdCSect );
	CloseHandle( hproc );
	ExitThread( 0 );
    }

    LeaveCriticalSection( &pdCSect );

    /*
     * tell original caller that process is dead
     *
     * Make a copy to of the process data, and then use that copy.
     * We do this because we will deadlock if we just try to hold it while
     * we call the various apps.
     */
    for( i=0;i<MAX_CALLBACKS;i++ )
    {
	if( pd.pdata[i].lpNotify != NULL )
	{
	    DPF( 3, "Notifying %08lx about process %08lx terminating",
				pd.pdata[i].lpNotify, pd.pid );
            hd.pid = pd.pid;

            try
            {
                rc = pd.pdata[i].lpNotify( &hd );
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                DPF(0, "*********************************************");
                DPF(0, "******** exception during shutdown **********");
                DPF(0, "******** DDHELP is going to exit   **********");
                DPF(0, "*********************************************");
                TerminateProcess(GetCurrentProcess(), 5);
            }

	    /*
	     * did it ask us to free our DC list?
	     */
	    if( rc )
	    {
		freeDCList( pd.pdata[i].req_id );
	    }
	}
    }
    CloseHandle( hproc );

    ExitThread( 0 );

} /* ThreadProc */

static BOOL	bKillNow;
static BOOL	bKillDOSBoxNow;

/*
 * ModeSetThreadProc
 */
void ModeSetThreadProc( LPVOID pdata )
{
    DWORD			rc;
    MODESETTHREADDATA		mstd;

#ifdef WIN95
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL );
#endif

    mstd = *((LPMODESETTHREADDATA)pdata);

    DPF( 5, "Modeset thread started, proc=%08lx, pdrv=%08lx, hEvent=%08lx",
    			mstd.lpProc, mstd.lpDD, mstd.hEvent );
    DPF( 5, "ModeSetThreadProc: hevent = %08lx", mstd.hEvent );

    /*
     * wait for process to die
     */
    while( 1 )
    {
	rc = WaitForSingleObject( mstd.hEvent, INFINITE );
	if( rc == WAIT_FAILED )
	{
	    DPF( 2, "WAIT_FAILED, Modeset thread terminated" );
	    ExitThread( 0 );
	}
	if( bKillNow )
	{
	    bKillNow = 0;
	    CloseHandle( mstd.hEvent );
	    DPF( 4, "Modeset thread now terminated" );
	    ExitThread( 0 );
	}
	DPF( 3, "Notifying DirectDraw of modeset!" );
	mstd.lpProc( mstd.lpDD );
    }

} /* ModeSetThreadProc */

/*
 * DOSBoxThreadProc
 */
void DOSBoxThreadProc( LPVOID pdata )
{
    DWORD			rc;
    MODESETTHREADDATA		mstd;

    mstd = *((LPMODESETTHREADDATA)pdata);

    DPF( 5, "DOS box thread started, proc=%08lx, pdrv=%08lx, hEvent=%08lx",
    			mstd.lpProc, mstd.lpDD, mstd.hEvent );
    DPF( 5, "DOSBoxThreadProc: hevent = %08lx", mstd.hEvent );

    /*
     * wait for process to die
     */
    while( 1 )
    {
	rc = WaitForSingleObject( mstd.hEvent, INFINITE );
	if( rc == WAIT_FAILED )
	{
	    DPF( 2, "WAIT_FAILED, DOS Box thread terminated" );
	    ExitThread( 0 );
	}
	if( bKillDOSBoxNow )
	{
	    bKillDOSBoxNow = 0;
	    CloseHandle( mstd.hEvent );
	    DPF( 4, "DOS box thread now terminated" );
	    ExitThread( 0 );
	}
	DPF( 3, "Notifying DirectDraw of DOS box!" );
	mstd.lpProc( mstd.lpDD );
    }

} /* DOSBoxThreadProc */

/*
 * MainWndProc
 */
LRESULT __stdcall MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
#ifdef WIN95
    BOOL                    f;

    // If we got a message for a WinMM device change, let's convert it
    // into a WM_DEVICECHANGE message with DBT_DEVNODES_CHANGED
    if (message == gumsgWinmmDeviceChange) {
        message = WM_DEVICECHANGE;
        wParam = DBT_DEVNODES_CHANGED;
    }
#endif
    
    switch(message)
    {
        case WM_ENDSESSION:
            /*
             * shoot ourselves in the head
             */
	    if( lParam == FALSE )
	    {
	        DPF( 4, "WM_ENDSESSION" );
	        EnterCriticalSection( &pdCSect );
	        DPF( 4, "Setting NO CALLBACKS" );
	        bNoCallbacks = TRUE;
	        LeaveCriticalSection( &pdCSect );
	    }
	    else
	    {
	        DPF( 4, "User logging off" );
	    }

            break;

        case WM_POWERBROADCAST:
            switch(wParam)
            {
                case PBT_APMSUSPEND:
                    DPF(3, "Entering APM suspend mode...");
                    SetEvent(hApmSuspendEvent);
                    ResetEvent(hApmResumeEvent);
                    break;

                case PBT_APMRESUMESUSPEND:
                case PBT_APMRESUMEAUTOMATIC:
                case PBT_APMRESUMECRITICAL:
                    DPF(3, "Leaving APM suspend mode...");
                    SetEvent(hApmResumeEvent);
                    ResetEvent(hApmSuspendEvent);
                    break;
            }

            break;

	case WM_DISPLAYCHANGE:
	    DPF( 4, "WM_DISPLAYCHANGE" );
	    if( g_pfnOnDisplayChange )
		(*g_pfnOnDisplayChange)();
	    break;

#ifdef WIN95
    case WM_DEVICECHANGE:
        DPF(4, "WM_DEVICECHANGE");

        EnterCriticalSection(&cs);
        f = onDeviceChangeNotify(wParam, lParam);
        LeaveCriticalSection(&cs);

        if (f != TRUE)
        {
            return f;
        }

        break;
#endif
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
} /* MainWndProc */

/*
 * WindowThreadProc
 */
void WindowThreadProc( LPVOID pdata )
{
    static char szClassName[] = "DDHelpWndClass";
    WNDCLASS 	cls;
    MSG		msg;
    HWND	hwnd;

    /*
     * turn down the heat a little
     */
#ifdef WIN95
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_IDLE );

    if (!gumsgWinmmDeviceChange) {
        gumsgWinmmDeviceChange = RegisterWindowMessage(WINMMDEVICECHANGEMSGSTRING);
    }
#endif
    
    /*
     * build class and create window
     */
    cls.lpszClassName  = szClassName;
    cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
    cls.hInstance      = hInstApp;
    cls.hIcon          = NULL;
    cls.hCursor        = NULL;
    cls.lpszMenuName   = NULL;
    cls.style          = 0;
    cls.lpfnWndProc    = MainWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if( !RegisterClass( &cls ) )
    {
	DPF( 1, "RegisterClass FAILED!" );
	ExitThread( 0 );
    }

    hwnd = CreateWindow( szClassName, szClassName,
	    WS_POPUP, 0, 0, 0, 0, NULL, NULL, hInstApp, NULL);

    if( hwnd == NULL )
    {
	DPF( 1, "No monitor window!" );
	ExitThread( 0 );
    }

    /*
     * pump the messages
     */
    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
	TranslateMessage( &msg );
	DispatchMessage( &msg );
    }
    DPF( 4, "Exiting WindowThreadProc" );
    ExitThread( 1 );

} /* WindowThreadProc */

//
// called by WinMain in response to a DDHELPREQ_NEWPID request.
//
void WatchNewPid(LPDDHELPDATA phd)
{
    LPPROCESSDATA	ppd;
    BOOL		found;
    int			i;
    DWORD		tid;

    DPF( 4, "DDHELPREQ_NEWPID" );

    EnterCriticalSection( &pdCSect );
    ppd = lpProcessList;
    found = FALSE;
    while( ppd != NULL )
    {
	if( ppd->pid == phd->pid )
	{
	    DPF( 4, "Have thread for process %08lx already", phd->pid );
	    /*
	     * look if we already have this callback for this process
	     */
	    for( i=0;i<MAX_CALLBACKS;i++ )
	    {
		if( ppd->pdata[i].lpNotify == phd->lpNotify )
		{
		    DPF( 5, "Notification rtn %08lx already set for pid %08lx",
		    			phd->lpNotify, phd->pid );
		    found = TRUE;
		    break;
		}
	    }
	    if( found )
	    {
		break;
	    }

	    /*
	     * we have a new callback for this process
	     */
	    for( i=0;i<MAX_CALLBACKS;i++ )
	    {
		if( ppd->pdata[i].lpNotify == NULL )
		{
		    DPF( 5, "Setting notification rtn %08lx for pid %08lx",
		    			phd->lpNotify, phd->pid );
	    	    ppd->pdata[i].lpNotify = phd->lpNotify;
		    ppd->pdata[i].req_id = phd->req_id;
		    found = TRUE;
		    break;
		}
	    }
	    if( !found )
	    {
		#ifdef DEBUG
		    /*
		     * this should not happen!
		     */
		    DPF( 0, "OUT OF NOTIFICATION ROOM!" );
		    DebugBreak(); //_asm int 3;
		#endif
	    }
	    break;
	}
	ppd = ppd->link;
    }

    /*
     * couldn't find anyone waiting on this process, so create
     * a brand spanking new thread
     */
    if( !found )
    {
	DPF( 3, "Allocating new thread for process %08lx" );
	ppd = MemAlloc( sizeof( PROCESSDATA ) );
	if( ppd != NULL )
	{
	    HANDLE	h;

	    ppd->link = lpProcessList;
	    lpProcessList = ppd;
	    ppd->pid = phd->pid;
	    ppd->pdata[0].lpNotify = phd->lpNotify;
	    ppd->pdata[0].req_id = phd->req_id;
	    h = CreateThread(NULL,
			 0,
			 (LPTHREAD_START_ROUTINE) ThreadProc,
			 (LPVOID)ppd,
			 0,
			 (LPDWORD)&tid);
	    if( h != NULL )
	    {
		DPF( 5, "Thread %08lx created, initial callback=%08lx",
			    tid, phd->lpNotify );
		CloseHandle( h );
	    }
	    else
	    {
		#ifdef DEBUG
		    DPF( 0, "COULD NOT CREATE HELPER THREAD FOR PID %08lx", phd->pid );
		#endif
	    }
	}
	else
	{
	    #ifdef DEBUG
		DPF( 0, "OUT OF MEMORY CREATING HELPER THREAD FOR PID %08lx", phd->pid );
	    #endif
	}
    }
    LeaveCriticalSection( &pdCSect );
} // WatchNewPid

//
// called by WinMain in response to a DDHELPREQ_STOPWATCHPID request.
//
void StopWatchPid(LPDDHELPDATA phd)
{
    LPPROCESSDATA	ppd;
    BOOL		found;
    int			i;

    DPF( 4, "DDHELPREQ_STOPWATCHPID" );

    EnterCriticalSection( &pdCSect );
    ppd = lpProcessList;
    found = FALSE;
    while( ppd != NULL )
    {
	if( ppd->pid == phd->pid )
	{
	    /*
	     * look if we already have this callback for this process
	     */
	    for( i=0;i<MAX_CALLBACKS;i++ )
	    {
		if( ppd->pdata[i].lpNotify == phd->lpNotify )
		{
		    DPF( 5, "Remove notification rtn %08lx for pid %08lx", phd->lpNotify, phd->pid );
                    ppd->pdata[i].lpNotify = NULL;
		    found = TRUE;
		    break;
		}
	    }
	    if( found )
	    {
		break;
	    }
	}
	ppd = ppd->link;
    }

    LeaveCriticalSection( &pdCSect );
} // StopWatchPid

/*
 * WinMain
 */
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
			LPSTR lpCmdLine, int nCmdShow)
{
    DWORD		tid;
    DWORD		rc;
    HANDLE		hstartevent;
    HANDLE		hstartupevent;
    HANDLE		hmutex;
    HANDLE		hackevent;
    LPDDHELPDATA	phd;
    HANDLE		hsharedmem;
    HANDLE		h;
    char		szSystemDir[1024];

    /*
     * Set our working directory to the system directory.
     * This prevents us from holding network connections open
     * forever if the first DirectDraw app that we run is across
     * a network connection.
     */
    GetSystemDirectory(szSystemDir, sizeof(szSystemDir));
    SetCurrentDirectory(szSystemDir);

    /*
     * when we gotta run, we gotta run baby
     */
#ifdef WIN95
    SetPriorityClass( GetCurrentProcess(), REALTIME_PRIORITY_CLASS );
#endif

#ifdef WIN95
    /*
     * when we gotta run, we gotta and not let the user see us in
     * the task list.
     */
    RegisterServiceProcess( 0, RSP_SIMPLE_SERVICE );
#else
    /*
     * We must guarantee that ddhelp unloads after the last ddraw app,
     * since ctrl-alt-del may have happened while an app held the ddraw
     * lock, and ddhelp needs to clean up orphaned cheap ddraw mutex
     * locks.
     */
    if ( ! SetProcessShutdownParameters(0x100,SHUTDOWN_NORETRY) )
    {
        DPF(0,"DDHELP.EXE could not set itself to shutdown last!");
    }

#endif


    #if NEED_WIN16LOCK
	GetpWin16Lock( &lpWin16Lock );
    #endif

    hInstApp = hInstance;

    /*
     * create startup event
     */
    hstartupevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );

    DPFINIT();
    DPF( 5, "*** DDHELP STARTED, PID=%08lx ***", GetCurrentProcessId() );

    if( !MemInit() )
    {
	DPF( 1, "Could not init memory manager" );
	return 0;
    }

    /*
     * create shared memory area
     */
    hsharedmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    if( hsharedmem == NULL )
    {
	DPF( 1, "Could not create file mapping!" );
	return 0;
    }

    /*
     * create mutex for people who want to use the shared memory area
     */
    hmutex = CreateMutex( NULL, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
	DPF( 1, "Could not create mutex " DDHELP_MUTEX_NAME );
	CloseHandle( hsharedmem );
	return 0;
    }

    /*
     * create events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
	DPF( 1, "Could not create event " DDHELP_EVENT_NAME );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	return 0;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
	DPF( 1, "Could not create event " DDHELP_ACK_EVENT_NAME );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	CloseHandle( hstartevent );
	return 0;
    }
    hApmSuspendEvent = CreateEvent( NULL, TRUE, FALSE, DDHELP_APMSUSPEND_EVENT_NAME );
    if( hApmSuspendEvent == NULL )
    {
	DPF( 1, "Could not create event " DDHELP_APMSUSPEND_EVENT_NAME );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	CloseHandle( hstartevent );
        CloseHandle( hackevent );
	return 0;
    }
    hApmResumeEvent = CreateEvent( NULL, TRUE, TRUE, DDHELP_APMRESUME_EVENT_NAME );
    if( hApmResumeEvent == NULL )
    {
	DPF( 1, "Could not create event " DDHELP_APMRESUME_EVENT_NAME );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	CloseHandle( hstartevent );
        CloseHandle( hackevent );
        CloseHandle( hApmSuspendEvent );
	return 0;
    }

    /*
     * Create window so we can get messages
     */
    h = CreateThread(NULL,
		 0,
		 (LPTHREAD_START_ROUTINE) WindowThreadProc,
		 NULL,
		 0,
		 (LPDWORD)&tid );
    if( h == NULL )
    {
	DPF( 1, "Create of WindowThreadProc FAILED!" );
	CloseHandle( hackevent );
	CloseHandle( hmutex );
	CloseHandle( hsharedmem );
	CloseHandle( hstartevent );
        CloseHandle( hApmSuspendEvent );
        CloseHandle( hApmResumeEvent );
	return 0;
    }
    CloseHandle( h );

    /*
     * serialize access to us
     */
    memset( &cs, 0, sizeof( cs ) );
    InitializeCriticalSection( &cs );

    /*
     * serialize access to process data
     */
    memset( &pdCSect, 0, sizeof( pdCSect ) );
    InitializeCriticalSection( &pdCSect );

    /*
     * let invoker and anyone else who comes along know we exist
     */
    SetEvent( hstartupevent );

    /*
     * loop forever, processing requests
     */
    while( 1 )
    {
	HANDLE	hdll;

	/*
	 * wait to be notified of a request
	 */
	hdll = NULL;
	DPF( 4, "Waiting for next request" );
	rc = WaitForSingleObject( hstartevent, INFINITE );
	if( rc == WAIT_FAILED )
	{
	    DPF( 1, "Wait FAILED!!!" );
	    continue;
	}

	EnterCriticalSection( &cs );
	phd = (LPDDHELPDATA) MapViewOfFile( hsharedmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
	if( phd == NULL )
	{
	    DPF( 1, "Could not create view of file!" );
	    LeaveCriticalSection( &cs );
	    continue;
	}

	/*
	 * find out what we need to do
	 */
	switch( phd->req )
	{
	case DDHELPREQ_NEWDC:
	    DPF( 4, "DDHELPREQ_NEWDC" );
	    addDC( phd->fname, phd->isdisp, phd->req_id );
	    break;
	case DDHELPREQ_FREEDCLIST:
	    DPF( 4, "DDHELPREQ_FREEDCLIST" );
	    freeDCList( phd->req_id );
	    break;
	case DDHELPREQ_CREATEMODESETTHREAD:
	{
	    MODESETTHREADDATA	mstd;
	    LPTHREADLIST	ptl;
	    char		str[64];
	    HANDLE		hevent;
	    HANDLE		h;

	    DPF( 4, "DDHELPREQ_CREATEMODESETTHREAD" );
	    mstd.lpProc = phd->lpModeSetNotify;
	    mstd.lpDD = phd->pData1;
	    wsprintf( str, DDHELP_MODESET_EVENT_NAME, phd->dwData1 );
	    DPF( 5, "Trying to Create event \"%s\"", str );
	    hevent = CreateEvent( NULL, FALSE, FALSE, str );
	    mstd.hEvent = hevent;
	    DPF( 5, "hevent = %08lx", hevent );

	    h = CreateThread(NULL,
			 0,
			 (LPTHREAD_START_ROUTINE) ModeSetThreadProc,
			 (LPVOID) &mstd,
			 0,
			 (LPDWORD)&tid );
	    if( h != NULL )
	    {
		DPF( 5, "CREATED MODE SET THREAD %ld", h );
		ptl = MemAlloc( sizeof( THREADLIST ) );
		if( ptl != NULL )
		{
		    ptl->hInstance = phd->dwData1;
		    ptl->hEvent = hevent;
		    ptl->link = lpThreadList;
		    lpThreadList = ptl;
		}
		CloseHandle( h );
	    }
	    break;
	}
	case DDHELPREQ_KILLMODESETTHREAD:
	{
	    LPTHREADLIST	ptl;
	    LPTHREADLIST	prev;

	    DPF( 4, "DDHELPREQ_KILLMODESETTHREAD" );
	    prev = NULL;
	    ptl = lpThreadList;
	    while( ptl != NULL )
	    {
		if( ptl->hInstance == phd->dwData1 )
		{
		    HANDLE	h;
		    if( prev == NULL )
		    {
			lpThreadList = ptl->link;
		    }
		    else
		    {
			prev->link = ptl->link;
		    }
		    h = ptl->hEvent;
		    MemFree( ptl );
		    bKillNow = TRUE;
		    SetEvent( h );
		    break;
		}
		prev = ptl;
		ptl = ptl->link;
	    }
	    break;
	}
	case DDHELPREQ_CREATEHELPERTHREAD:
#ifdef WIN95
	    if( !bIsActive )
	    {
		HANDLE	h;
		bIsActive = TRUE;
		h = CreateThread(NULL,
			     0,
			     (LPTHREAD_START_ROUTINE) HelperThreadProc,
			     NULL,
			     0,
			     (LPDWORD)&tid);
		if( h == NULL )
		{
		    bIsActive = FALSE;
		}
		else
		{
		    CloseHandle( h );
		}
	    }
#endif
	    break;
	case DDHELPREQ_NEWPID:
	    WatchNewPid(phd);
	    break;
        case DDHELPREQ_STOPWATCHPID:
            StopWatchPid(phd);
            break;
	case DDHELPREQ_RETURNHELPERPID:
	    DPF( 4, "DDHELPREQ_RETURNHELPERPID" );
	    phd->pid = GetCurrentProcessId();
	    break;
	case DDHELPREQ_LOADDLL:
	    DPF( 4, "DDHELPREQ_LOADDLL" );
            phd->dwReturn = loadDLL( phd->fname, phd->func, phd->context );
	    break;
	case DDHELPREQ_FREEDLL:
	    DPF( 4, "DDHELPREQ_FREEDDLL" );
	    hdll = freeDLL( phd->fname );
	    break;
	case DDHELPREQ_KILLATTACHED:
	{
	    LPPROCESSDATA	ppd;
	    HANDLE		hproc;
	    DPF( 4, "DDHELPREQ_KILLATTACHED" );

	    EnterCriticalSection( &pdCSect );
	    ppd = lpProcessList;
	    while( ppd != NULL )
	    {
		hproc = OpenProcess( PROCESS_ALL_ACCESS, FALSE, ppd->pid );
		DPF( 5, "Process %08lx: handle = %08lx", ppd->pid, hproc );
		if( hproc != NULL )
		{
		    DPF( 5, "Terminating %08lx", ppd->pid );
		    TerminateProcess( hproc, 0 );
		}
		ppd = ppd->link;
	    }
	    LeaveCriticalSection( &pdCSect );
	    break;
	}
	case DDHELPREQ_SUICIDE:
	    DPF( 4, "DDHELPREQ_SUICIDE" );
	    freeAllResources();
	    #ifdef WIN95
		if( INVALID_HANDLE_VALUE != hDSVxd )
		    CloseHandle( hDSVxd );
                if( INVALID_HANDLE_VALUE != hDDVxd )
                    CloseHandle( hDDVxd );
	    #endif /* WIN95 */
	    SetEvent( hackevent );
	    CloseHandle( hmutex );
	    UnmapViewOfFile( phd );
	    CloseHandle( hsharedmem );
	    CloseHandle( hstartevent );
            CloseHandle( hApmSuspendEvent );
            CloseHandle( hApmResumeEvent );
	    #ifdef DEBUG
	    	MemState();
	    #endif
	    DPF( 4, "Good Night Gracie" );
	    TerminateProcess( GetCurrentProcess(), 0 );
            break;

	case DDHELPREQ_WAVEOPEN:
	{
#ifdef WIN95
	    DWORD dwPriority;
#endif

	    DPF( 4, "DDHELPREQ_WAVEOPEN" );
	    // Due to a possible bug in Win95 mmsystem/mmtask, we can hang
	    // if we call waveOutOpen on a REALTIME thread while a sound
	    // event is playing.  So, we briefly lower our priority to
	    // NORMAL while we call this API
#ifdef WIN95
	    dwPriority = GetPriorityClass(GetCurrentProcess());
	    SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS);
#endif
	    phd->dwReturn = (DWORD)waveOutOpen(
			(LPHWAVEOUT)(phd->pData1),
			(UINT)(phd->dwData1),
			(LPWAVEFORMATEX)(phd->dwData2),
			0, 0, 0);
#ifdef WIN95
	    SetPriorityClass(GetCurrentProcess(), dwPriority);
#endif

	    // Some mmsystem wave drivers will program their wave mixer
	    // hardware only while the device is open.  By doing the
	    // following, we can get such drivers to program the hardware
	    if (MMSYSERR_NOERROR == phd->dwReturn) {
		MMRESULT mmr;
		DWORD dwVolume;

		mmr = waveOutGetVolume((HWAVEOUT)(*(LPHWAVEOUT)(phd->pData1)), &dwVolume);
		if (MMSYSERR_NOERROR == mmr) {
		    waveOutSetVolume((HWAVEOUT)(*(LPHWAVEOUT)(phd->pData1)), dwVolume);
		}
	    }
	    DPF( 5, "Wave Open returned %X", phd->dwReturn );
	    break;
	}
	case DDHELPREQ_WAVECLOSE:
	    DPF( 4, "DDHELPREQ_WAVECLOSE" );
	    phd->dwReturn = (DWORD)waveOutClose(
			(HWAVEOUT)(phd->dwData1) );
	    break;
	case DDHELPREQ_CREATETIMER:
	    DPF( 4, "DDHELPREQ_CREATETIMER proc %X", (phd->pData1) );
	    phd->dwReturn = (DWORD)timeSetEvent(
			(UINT)(phd->dwData1),   // Delay
			(UINT)(phd->dwData1)/2, // Resolution
			(phd->pData1),	  // Callback thread proc
			(UINT)(phd->dwData2),   // instance data
			TIME_PERIODIC );
	    DPF( 5, "Create Timer returned %X", phd->dwReturn );
	    break;
	case DDHELPREQ_KILLTIMER:
	    DPF( 4, "DDHELPREQ_KILLTIMER %X", phd->dwData1 );
	    phd->dwReturn = (DWORD)timeKillEvent( (UINT)phd->dwData1 );
	    DPF( 5, "Kill Timer returned %X", phd->dwReturn );
	    break;

	case DDHELPREQ_CREATEDSMIXERTHREAD:
	{
	    DWORD tid;
	    if (NULL == phd->pData2) phd->pData2 = &tid;
	    phd->dwReturn = (ULONG_PTR)CreateThread(NULL, 0, phd->pData1,
						(LPVOID)phd->dwData1,
						(UINT)phd->dwData2,
						(LPDWORD)phd->pData2);
            if (!phd->dwReturn) {
#ifdef DEBUG
                DPF(0, "pData1  %p (start addr)",  phd->pData1);
                DPF(0, "dwData1 %p (thread parm)", phd->dwData1);
                DPF(0, "dwData2 %p (fdwCreate)", phd->dwData2);
                DPF(0, "pData2  %p (lpThreadID)", phd->pData2);

                DPF(0, "DDHelp: Failed to create mixer thread %lu",
                   GetLastError());

                DebugBreak();
#endif
            }
	    break;
	}

	case DDHELPREQ_CREATEDSFOCUSTHREAD:
	{
	    DWORD tid;
	    if (NULL == phd->pData2) phd->pData2 = &tid;
	    phd->dwReturn = (ULONG_PTR)CreateThread(NULL, 0, phd->pData1,
						(LPVOID)phd->dwData1,
						(UINT)phd->dwData2,
						(LPDWORD)phd->pData2);
	      if (!phd->dwReturn) {
#ifdef DEBUG
                DPF(0, "pData1  %p (start addr)",  phd->pData1);
                DPF(0, "dwData1 %p (thread parm)", phd->dwData1);
                DPF(0, "dwData2 %p (fdwCreate)", phd->dwData2);
                DPF(0, "pData2  %p (lpThreadID)", phd->pData2);

                DPF(0, "DDHelp: Failed to create sound focus thread %lu",
		    GetLastError());

                DebugBreak();
#endif
	      }
	    }
	    break;

        case DDHELPREQ_CALLDSCLEANUP:
            try
            {
                ((LPDSCLEANUP)phd->pData1)(phd->pData2);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                DPF(0, "*********************************************");
                DPF(0, "**** DDHELPREQ_CALLDSCLEANUP blew up! *******");
                DPF(0, "*********************************************");
            }
            break;

	#ifdef WIN95
	    case DDHELPREQ_GETDSVXDHANDLE:
		phd->dwReturn = getDSVxdHandle();
		break;

            case DDHELPREQ_GETDDVXDHANDLE:
                phd->dwReturn = getDDVxdHandle();
		break;
	#endif /* WIN95 */

        case DDHELPREQ_NOTIFYONDISPLAYCHANGE:
	    DPF( 4, "DDHELPREQ_NOTIFYONDISPLAYCHANGE" );
	    (void *)g_pfnOnDisplayChange = (void *)phd->dwData1;
	    break;

#ifdef WIN95
	case DDHELPREQ_CREATEDOSBOXTHREAD:
	    {
	        MODESETTHREADDATA dbtd;
	        char		str[64];
	        HANDLE		hevent;
	        HANDLE		h;

	        DPF( 4, "DDHELPREQ_CREATEDOSBOXTHREAD" );
	        dbtd.lpProc = phd->lpModeSetNotify;
	        dbtd.lpDD = phd->pData1;
	        wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, phd->dwData1 );
	        DPF( 5, "Trying to Create event \"%s\"", str );
	        hevent = CreateEvent( NULL, FALSE, FALSE, str );
	        dbtd.hEvent = hevent;
	        DPF( 5, "hevent = %08lx", hevent );

	        h = CreateThread(NULL,
			 0,
			 (LPTHREAD_START_ROUTINE) DOSBoxThreadProc,
			 (LPVOID) &dbtd,
			 0,
			 (LPDWORD)&tid );
	        if( h != NULL )
	        {
		    DPF( 5, "CREATED DOS BOX THREAD %ld", h );
		    DOSBoxThread.hInstance = phd->dwData1;
		    DOSBoxThread.hEvent = hevent;
		    CloseHandle( h );
		}
	    }
	break;
	case DDHELPREQ_KILLDOSBOXTHREAD:
	    {
	        DPF( 4, "DDHELPREQ_KILLDOSBOXTHREAD" );
		if( DOSBoxThread.hInstance == phd->dwData1 )
		{
		    bKillDOSBoxNow = TRUE;
		    SetEvent( DOSBoxThread.hEvent );
		}
	    }
	break;
#endif

        case DDHELPREQ_LOADLIBRARY:
            phd->dwReturn = (ULONG_PTR)LoadLibraryA((LPCSTR)phd->dwData1);
            break;

        case DDHELPREQ_FREELIBRARY:
            phd->dwReturn = FreeLibrary((HINSTANCE)phd->dwData1);
            break;

#ifdef WIN95
        case DDHELPREQ_ADDDEVICECHANGENOTIFY:
            addDeviceChangeNotify(phd->pData1);
            break;

        case DDHELPREQ_DELDEVICECHANGENOTIFY:
            delDeviceChangeNotify(phd->pData1);
            break;
#endif

	default:
	    DPF( 1, "Unknown Request???" );
	    break;
	}

	/*
	 * let caller know we've got the news
	 */
	UnmapViewOfFile( phd );
	SetEvent( hackevent );
	LeaveCriticalSection( &cs );

	/*
	 * unload the DLL we were asked to
	 */
	if( hdll != NULL )
	{
	    DPF( 4, "Freeing DLL %08lx", hdll );
	    FreeLibrary( hdll );
        }
    }

#ifdef WIN95
    RegisterServiceProcess( 0, RSP_UNREGISTER_SERVICE );
#else
    #pragma message("RegisterServiceProcess needs to be taken care of under nt")
#endif

} /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\killhelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       killhelp.c
 *  Content:	kill DDHELP.EXE
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   24-jun-95	craige	kill all attached processes
 *
 ***************************************************************************/
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "ddhelp.h"

/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA	phd;
    HANDLE		hmem;
    HANDLE		hmutex;
    HANDLE		hackevent;
    HANDLE		hstartevent;
    BOOL		rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    printf( "hstartevent = %08lx\n", hstartevent );
    if( hstartevent == NULL )
    {
	return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    printf( "hackevent = %08lx\n", hackevent );
    if( hackevent == NULL )
    {
	CloseHandle( hstartevent );
	return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
    		PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
		DDHELP_SHARED_NAME );
    printf( "hmem = %08lx\n", hmem );
    if( hmem == NULL )
    {
	printf( "Could not create file mapping!\n" );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    printf( "phd = %08lx\n", phd );
    if( phd == NULL )
    {
	printf( "Could not create view of file!\n" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    printf( "hmutex = %08lx\n", hmutex );
    if( hmutex == NULL )
    {
	printf( "Could not create mutex!\n" );
	CloseHandle( hmem );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = 0;
    printf( "waking up DDHELP\n" );
    if( SetEvent( hstartevent ) )
    {
	printf( "Waiting for response\n" );
	WaitForSingleObject( hackevent, INFINITE );
	memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
	rc = TRUE;
	printf( "got response\n" );
    }
    else
    {
	printf( "Could not signal event to notify DDHELP\n" );
	rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    CloseHandle( hmutex );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * main
 */
main( int argc, char *argv[] )
{
    HANDLE	h;
    DDHELPDATA	hd;
    BOOL	kill;

    h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( h == NULL )
    {
	printf( "Helper not running\n" );
	return 0;
    }

    if( argc > 1 )
    {
	if( argv[1][0] == '-' && argv[1][1] == 'k' )
	{
	    kill = TRUE;
	}
	else
	{
	    kill = FALSE;
	}
    }
    else
    {
	printf( "\nKill attached processes?\n" );
	kill = (_getch() == 'y');
    }

    if( kill )
    {
	WaitForSingleObject( h, INFINITE );
	printf( "*** KILL ATTACHED ***\n" );
	hd.req = DDHELPREQ_KILLATTACHED;
	sendRequest( &hd );
	printf( "\n" );
    }
    printf( "*** SUICIDE ***\n" );
    hd.req = DDHELPREQ_SUICIDE;
    sendRequest( &hd );
    return 0;

} /* main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\sources.inc ===
MAJORCOMP  = windows
MINORCOMP  = ddhelp
UMTYPE     = windows
UMENTRY    = winmain
TARGETNAME = ddhelp
TARGETTYPE = PROGRAM
TARGETPATH = obj

TARGETLIBS = \
    $(BASEDIR)\public\sdk\lib\*\winmm.lib

SOURCES = \
    ..\ddhelp.c   \
    ..\_memallo.c \
    ..\_dpf.c     \
    ..\ddhelp.rc

C_DEFINES = $(C_DEFINES) /DNO_DPF_HWND

PRECOMPILED_INCLUDE = ..\pch.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:	debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-jan-95	craige	initial implementation
 *   03-mar-95	craige	added dprintf2
 *   31-mar-95	craige	add DPFInit to read WIN.INI for [DirectDraw] section;
 *			added dprintf3
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	made stand-alone
 *   18-jun-95	craige	use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96	kipo	added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "pch.c"

#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR	"DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT	"DirectDraw"
    #endif

    #define END_STR		"\r\n"

    HWND		hWndListBox;
    LONG		lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
	    if( hWndListBox != NULL )
	    {
	        if( !IsWindow( hWndListBox ) )
	        {
		    hWndListBox = NULL;
	        }
	    }
	    if( hWndListBox != NULL )
	    {
	        UINT	sel;
	        int	len;
	        len = strlen( str );
	        if( len > 0 )
	        {
		    if( str[len-1] == '\r' || str[len-1] == '\n' )
		    {
		        str[len-1] = 0;
		    }
		    if( len > 1 )
		    {
		        if( str[len-2] == '\r' || str[len-2] == '\n' )
		        {
			    str[len-2] = 0;
		        }
		    }
	        }
	        SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
	        sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
	        if( sel != LB_ERR )
	        {
		    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
	        }
	    }
        #endif

    } /* dumpStr */

    /*
     * dprintf
     */
    void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char 	str[256];
        //char 	str2[256];

        BOOL	allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
	    if(  (UINT) -lDebugLevel == lvl )
	    {
	        allow = TRUE;
	    }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
	    allow = TRUE;
        }

        if( allow )
        {
	    wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
	    wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

	    lstrcat( (LPSTR) str, END_STR );
	    dumpStr( str );
        }

        va_end(ap);
    } /* dprintf */

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        dprintf( ASSERT_MESSAGE_LEVEL, buffer );
        dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
	    /*
	     * Into the debugger we go...
	     */
	    DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\winproc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winproc.c
 *  Content: 	DDHELP window proc
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   21-sep-95	craige	initial implementation
 *
 ***************************************************************************/

#include "pch.c"

//#define WIN32_LEAN_AND_MEAN
//#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "dpf.h"

#define SCROLLTIME	25
#define WIN_WIDTH	320
#define WIN_HEIGHT	200
#define MAX_FONTS	10

#pragma pack( 1 )
typedef struct
{
    LPSTR	szStr;
    DWORD	dwFont;
    COLORREF	crForeground;
//    COLORREF	crBackground;
} LISTDATA, *LPLISTDATA;

extern LPLISTDATA	ListData[];
extern HANDLE		hInstApp;
extern VOID (*g_pfnOnDisplayChange)(void);

int	iCurrItem;
DWORD	dwPixelsLeft;
DWORD	dwPixelHeight;
DWORD	dwPixelWidth;
HFONT	hFont[MAX_FONTS];

/*
 * getStr
 */
void getStr( int index, char *result, int *plen )
{
    int		len;
    LPLISTDATA	pnd;
    int		i;

    pnd = ListData[ index ];
    len = pnd->szStr[0];
    for( i=0;i<len;i++ )
    {
	*result++ = pnd->szStr[i+1] ^ 0x42;
    }
    *result = 0;
    *plen = len;

} /* getStr */

/*
 * getTextDim
 */
void getTextDim( HDC hdc, int index, DWORD *pwidth, DWORD *pheight )
{
    LPLISTDATA	pnd;
    SIZE	size;
    HFONT	oldfont;
    char	name[256];
    int		len;

    pnd = ListData[ index ];
    if( HIWORD( (DWORD) pnd->szStr ) == 0 )
    {
	*pwidth = 0;
	*pheight = (DWORD) pnd->szStr;
	return;
    }
    oldfont = SelectObject( hdc, hFont[ ListData[ index ]->dwFont ] );
    getStr( index, name, &len );
    GetTextExtentPoint32( hdc, name, len, &size );
    *pwidth = size.cx;
    *pheight = size.cy+1;
    SelectObject( hdc, oldfont );

} /* getTextDim */

/*
 * MainWndProc2
 */
long __stdcall MainWndProc2( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    PAINTSTRUCT ps;
    HDC         hdc;
    RECT	r;
    RECT	cr;
    HFONT	oldfont;
    int		len;
    char	name[256];
    static BOOL	bActive;

    switch( message )
    {
    case WM_CREATE:
    	SetTimer( hWnd, 1, SCROLLTIME, NULL );
	iCurrItem = -1;
	dwPixelsLeft = 0;
    	break;
    case WM_TIMER:
    	if( !bActive )
	{
	    break;
	}
	hdc = GetDC( hWnd );

	GetClientRect( hWnd, &cr );

	/*
	 * are we on a new block yet?
	 */
	if( dwPixelsLeft == 0 )
	{
	    iCurrItem++;
	    if( ListData[ iCurrItem ] == NULL )
	    {
		iCurrItem = 0;
	    }
	    getTextDim( hdc, iCurrItem, &dwPixelWidth, &dwPixelHeight );
	    dwPixelsLeft = dwPixelHeight;
	}
	ScrollWindowEx( hWnd, 0, -1, NULL, NULL, NULL, NULL, 0 );
	if( HIWORD( (DWORD) ListData[iCurrItem]->szStr ) != 0 )
	{
	    oldfont = SelectObject( hdc, hFont[ ListData[ iCurrItem ]->dwFont ] );
	    SetTextColor( hdc, ListData[ iCurrItem ]->crForeground );
//	    SetBkColor( hdc, ListData[ iCurrItem ]->crBackground );
	    SetBkColor( hdc, RGB( 255, 255, 255 ) );
	    getStr( iCurrItem, name, &len );
	    r.left = 0;
	    r.right = cr.right;
	    r.top = cr.bottom-2;
	    r.bottom = r.top+1;
	    ExtTextOut( hdc,
		(cr.right-dwPixelWidth)/2,
		cr.bottom-(dwPixelHeight-dwPixelsLeft)-1,
		ETO_CLIPPED | ETO_OPAQUE,
		&r,
		name,
		len,
		NULL );
	    SelectObject( hdc, oldfont );
	}
	ReleaseDC( hWnd, hdc );
	dwPixelsLeft--;
	break;

    case WM_PAINT:
        hdc = BeginPaint( hWnd, &ps );
	EndPaint( hWnd, &ps );
	hdc = GetDC( hWnd );
	GetClientRect( hWnd, &cr );
	FillRect( hdc, &cr, GetStockObject(WHITE_BRUSH) );
	ReleaseDC( hWnd, hdc );
	iCurrItem = -1;
	dwPixelsLeft = 0;
	return 1;

    case WM_ACTIVATE:
    	bActive = wParam;
	break;

    case WM_DESTROY:
    	KillTimer( hWnd, 1 );
	PostQuitMessage( 0 );
	break;

    case WM_DISPLAYCHANGE:
	DPF( 4, "WM_DISPLAYCHANGE" );
	if( g_pfnOnDisplayChange )
	    (*g_pfnOnDisplayChange)();
	break;

    }
    return DefWindowProc(hWnd, message, wParam, lParam);

} /* MainWndProc2 */

/*
 * makeFonts
 */
static void makeFonts( void )
{

    hFont[0] = CreateFont(
        24,
        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[1] = CreateFont(
        24,
        0, 0, 0, FW_NORMAL, TRUE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[2] = CreateFont(
        48,
        0, 0, 0, FW_BOLD| FW_NORMAL, TRUE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[3] = CreateFont(
        18,
        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[4] = CreateFont(
        36,
        0, 0, 0, FW_NORMAL, TRUE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Arial" );

    hFont[5] = CreateFont(
        36,
        0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
        ANSI_CHARSET,
        OUT_DEFAULT_PRECIS,
        CLIP_DEFAULT_PRECIS,
        NONANTIALIASED_QUALITY, // DEFAULT_QUALITY,
        VARIABLE_PITCH,
        "Times New Roman" );

} /* makeFonts */

BOOL		bIsActive;

/*
 * HelperThreadProc
 */
void HelperThreadProc( LPVOID data )
{
    static char szClassName[] = "DDHelpWndClass2";
    static BOOL	bInit;
    int		i;
    WNDCLASS 	cls;
    MSG		msg;
    HWND	hwnd;
    int		x;
    int		y;

    /*
     * build class and create window
     */
    cls.lpszClassName  = szClassName;
    cls.hbrBackground  = (HBRUSH)GetStockObject(WHITE_BRUSH);
    cls.hInstance      = hInstApp;
    cls.hIcon          = NULL;
    cls.hCursor        = NULL;
    cls.lpszMenuName   = NULL;
    cls.style          = 0;
    cls.lpfnWndProc    = MainWndProc2;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if( !bInit )
    {
	if( !RegisterClass( &cls ) )
	{
	    DPF( 1, "RegisterClass FAILED!" );
	    ExitThread( 0 );
	}
	bInit = TRUE;
    }
    x = GetSystemMetrics( SM_CXSCREEN );
    y = GetSystemMetrics( SM_CYSCREEN );

    hwnd = CreateWindow( szClassName,
	    "DirectX(tm) For Microsoft\256 Windows\256",
	    WS_OVERLAPPEDWINDOW,
	    (x-WIN_WIDTH)/2, (y-WIN_HEIGHT)/2,
	    WIN_WIDTH, WIN_HEIGHT,
	    NULL, NULL, hInstApp, NULL);

    ShowWindow( hwnd, SW_NORMAL );
    UpdateWindow( hwnd );

    makeFonts();

    if( hwnd == NULL )
    {
	ExitThread( 0 );
    }

    /*
     * pump the messages
     */
    bIsActive = TRUE;
    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
	TranslateMessage( &msg );
	DispatchMessage( &msg );
    }
    for( i=0;i<MAX_FONTS;i++ )
    {
	if( hFont[i] != NULL )
	{
	    DeleteObject( hFont[i] );
	}
    }
    bIsActive = FALSE;
    ExitThread( 1 );

} /* HelperThreadProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\_memallo.c ===
#include "pch.c"

#include "..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw\daytona\makefile.inc ===
PRIVTARGET = $(O)
PUBTARGET = $(O)
PRIVLIB = $(PRIVTARGET)\ddrawp.lib

$(PRIVLIB) $(PRIVLIB:.lib = .exp): ddrawp.def $(LIBRARY_OBJS)
    -lib -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:ddrawp.def
$(LIBRARY_OBJS)
<<NOKEEP

C_DEFINES = $(C_DEFINES) /DPRIVATE= /D_$(ALT_PROJECT)_

ddrawp.def: ddraw_nt.def
    $(C_PREPROCESSOR) ddraw_nt.def > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\_dpf.c ===
#include "pch.c"

#include "..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddhelp\win9x\i386\list.asm ===
.386
.model FLAT,STDCALL
.code
item0 db 10,6,43,48,39,33,54,26,-37,98,117
item1 db 3,36,45,48
item2 db 17,21,43,44,38,45,53,49,98,123,119,109,123,122,106,17,7,107
item4 db 9,4,39,35,54,55,48,43,44,37
item6 db 8,6,43,48,39,33,54,113,6
item7 db 10,6,43,48,39,33,54,6,48,35,53
item8 db 11,6,43,48,39,33,54,17,45,55,44,38
item9 db 11,6,43,48,39,33,54,11,44,50,55,54
item10 db 10,6,43,48,39,33,54,18,46,35,59
item11 db 11,6,43,48,39,33,54,15,55,49,43,33
item13 db 33,50,39,48,36,39,33,54,43,44,37,98,54,42,39,98,18,1,98,37,35,47,39,98,39,58,50,39,48,43,39,44,33,39
item14 db 10,49,43,44,33,39,98,115,123,123,119
item15 db 36,106,43,54,101,49,98,54,35,41,43,44,37,98,46,45,44,37,39,48,98,54,42,35,44,98,53,39,98,54,42,45,55,37,42,54,107
item17 db 19,111,32,48,45,55,37,42,54,98,54,45,98,59,45,55,98,32,59,111
item18 db 16,22,42,39,98,6,43,48,39,33,54,26,98,22,39,35,47
item20 db 8,6,43,48,39,33,54,113,6
item21 db 9,1,42,35,49,98,0,45,59,38
item22 db 11,15,43,41,39,98,22,45,39,46,46,39
item23 db 12,3,44,55,40,98,5,45,49,35,46,43,35
item24 db 7,9,35,44,98,19,43,55
item25 db 17,3,44,35,44,54,42,35,98,9,35,44,33,42,39,48,46,35
item26 db 14,11,45,55,48,43,98,22,35,48,35,49,49,45,52
item27 db 11,17,35,47,39,39,48,98,12,39,44,39
item28 db 12,9,39,44,54,98,5,48,43,36,36,43,44
item29 db 12,26,55,39,50,43,44,37,98,6,39,44,37
item30 db 13,14,45,48,39,44,98,15,33,19,55,35,38,39
item31 db 11,16,43,33,42,98,6,35,46,54,45,44
item32 db 19,20,46,35,38,43,47,43,48,98,9,45,55,56,44,39,54,49,45,52
item33 db 10,1,46,43,36,36,98,13,53,39,44
item34 db 12,15,35,48,54,43,44,98,14,45,38,37,39
item35 db 10,22,45,38,38,98,4,48,45,49,54
item36 db 12,1,46,43,36,36,98,10,55,38,49,45,44
item37 db 13,3,35,48,45,44,98,7,38,47,45,44,38,49
item38 db 14,7,48,45,44,98,10,39,44,44,39,49,49,39,59
item40 db 10,6,43,48,39,33,54,6,48,35,53
item41 db 10,8,39,36,36,98,12,45,59,46,39
item42 db 12,22,45,44,59,98,0,35,48,41,35,44,49
item43 db 15,17,33,45,54,54,98,15,35,33,6,45,44,35,46,38
item44 db 13,8,45,42,44,98,17,54,39,50,42,39,44,49
item45 db 17,14,43,44,38,49,35,59,98,17,54,39,52,39,44,54,45,44
item46 db 11,9,39,54,35,44,98,6,35,46,35,46
item47 db 12,15,35,48,54,43,44,98,16,39,37,39,44
item48 db 11,8,39,36,36,98,12,45,48,48,43,49
item49 db 16,16,43,33,42,35,48,38,98,5,48,35,44,49,42,35,53
item50 db 11,13,46,35,44,98,10,35,44,46,39,59
item51 db 14,5,39,48,49,42,45,44,98,18,35,48,39,44,54
item52 db 14,3,44,38,48,39,53,98,14,55,50,50,44,45,53
item53 db 15,20,35,46,39,48,43,39,98,9,45,46,39,49,35,48
item55 db 11,6,43,48,39,33,54,17,45,55,44,38
item56 db 13,4,48,35,44,41,98,27,39,48,48,35,33,39
item57 db 13,0,48,43,35,44,98,17,33,42,47,43,38,54
item58 db 14,5,45,48,38,45,44,98,21,42,43,54,54,39,44
item59 db 11,6,39,48,39,41,98,17,47,43,54,42
item60 db 10,12,45,39,46,98,1,48,45,49,49
item61 db 10,8,45,42,44,44,59,98,14,39,39
item62 db 10,8,35,59,98,17,54,45,41,39,49
item63 db 11,8,35,49,45,44,98,23,50,54,45,44
item64 db 15,15,43,54,33,42,39,46,46,98,16,55,44,38,46,39
item65 db 12,3,46,50,39,48,98,17,39,46,33,55,41
item66 db 11,5,46,39,44,44,98,1,48,45,53,39
item67 db 14,0,48,39,54,54,98,10,55,47,50,42,48,39,59
item68 db 13,17,54,39,52,39,44,98,14,45,39,53,39,44
item69 db 10,10,39,48,47,35,44,98,15,35,44
item70 db 11,15,43,44,37,59,55,98,22,35,44,37
item71 db 18,1,42,48,43,49,54,45,50,42,39,48,98,10,35,48,50,39,48
item72 db 12,6,55,37,35,44,98,18,45,48,54,39,48
item74 db 11,6,43,48,39,33,54,11,44,50,55,54
item75 db 9,13,47,98,17,42,35,48,47,35
item76 db 14,15,35,48,33,55,49,98,3,44,38,48,39,53,49
item77 db 14,19,55,35,44,56,42,35,44,98,24,42,39,44,37
item78 db 12,17,54,39,52,39,98,18,45,53,39,48,49
item79 db 11,16,43,33,41,98,0,35,58,54,39,48
item80 db 11,15,35,54,54,98,6,45,54,49,45,44
item81 db 11,15,35,43,98,22,42,43,98,6,35,45
item82 db 13,8,45,42,44,98,22,42,45,48,44,54,45,44
item83 db 14,1,42,35,48,46,39,49,98,7,35,41,43,44,49
item84 db 12,8,39,49,49,98,16,45,32,39,48,54,49
item85 db 12,8,45,49,42,55,35,98,17,47,43,54,42
item86 db 13,17,33,45,54,98,3,44,38,39,48,49,45,44
item88 db 10,6,43,48,39,33,54,18,46,35,59
item89 db 10,3,35,48,45,44,98,13,37,55,49
item90 db 11,18,35,55,46,98,6,45,44,46,35,44
item91 db 9,8,45,42,44,98,9,35,44,39
item92 db 8,16,45,38,98,22,45,46,46
item93 db 11,18,35,55,46,98,12,39,53,49,45,44
item94 db 13,20,35,44,33,39,98,13,101,12,39,43,46,46
item95 db 11,10,39,48,47,35,44,98,15,35,44,44
item96 db 12,8,35,43,47,39,98,18,43,48,44,43,39
item97 db 7,9,39,44,98,13,48,39
item98 db 12,7,52,35,44,98,17,33,42,48,43,39,48
item99 db 15,15,43,33,42,35,39,46,98,12,35,48,35,59,35,44
item100 db 13,12,35,52,39,39,44,98,17,35,49,54,48,59
item101 db 13,8,35,47,43,39,98,13,49,32,45,48,44,39
item103 db 11,6,43,48,39,33,54,15,55,49,43,33
item104 db 9,22,45,38,45,48,98,4,35,59
item105 db 14,22,48,55,38,59,98,1,55,46,32,48,39,54,42
item106 db 13,6,35,52,43,38,98,27,35,33,41,46,39,59
item107 db 11,15,35,48,41,98,0,55,48,54,45,44
item108 db 15,3,44,44,39,54,54,39,98,1,48,45,53,46,39,59
item109 db 9,8,43,47,98,5,39,43,49,54
item110 db 12,8,35,47,39,49,98,6,45,45,46,39,59
item111 db 12,0,45,32,98,21,43,46,46,43,35,47,49
item112 db 10,8,39,36,36,98,4,48,43,39,38
item113 db 15,3,49,42,55,54,45,49,42,98,22,35,54,35,41,39
item114 db 13,9,42,35,46,39,38,98,3,37,48,35,47,35
item115 db 14,16,59,35,44,98,0,55,48,41,42,35,48,38,54
item116 db 11,6,35,52,43,38,98,9,46,43,44,39
item117 db 14,3,35,48,45,44,98,1,55,46,32,48,39,54,42
item118 db 12,0,48,43,35,44,98,22,42,45,47,35,49
item119 db 12,9,39,46,46,59,98,1,48,35,52,39,44
item120 db 13,14,45,55,98,14,55,33,35,48,39,46,46,43
item121 db 9,8,43,47,98,15,45,45,48,39
item122 db 13,22,48,39,52,45,48,98,5,55,46,43,33,41
item123 db 11,8,45,49,42,98,21,39,58,46,39,48
item124 db 14,1,42,35,48,46,39,49,98,7,35,41,43,44,49
item125 db 10,8,35,49,45,44,98,10,43,46,46
item126 db 16,1,42,48,43,49,54,43,35,44,98,1,35,48,48,45,46
item127 db 11,12,45,48,47,35,44,98,1,42,39,44
item129 db 14,6,43,48,39,33,54,26,98,36,45,48,98,20,0
item130 db 10,0,45,32,98,5,35,43,44,39,49
item131 db 14,3,44,38,48,39,53,98,9,39,48,54,39,49,56
item132 db 13,9,39,52,43,44,98,5,48,43,36,36,43,44
item133 db 16,6,45,47,43,44,43,33,98,16,43,33,33,39,54,54,43
item134 db 13,3,38,35,47,98,14,45,44,44,32,39,48,37
item135 db 10,15,35,48,41,98,6,35,52,43,49
item136 db 10,6,35,52,43,38,98,8,45,42,44
item137 db 13,14,45,55,98,14,55,33,35,48,39,46,46,43
item138 db 10,22,45,47,98,15,43,46,46,39,48
item140 db 15,17,6,9,98,35,44,38,98,17,35,47,50,46,39,49
item141 db 10,0,45,32,98,5,35,43,44,39,49
item142 db 16,15,43,33,42,35,39,46,98,3,44,38,39,48,49,45,44
item143 db 12,22,39,48,48,43,98,10,39,44,38,48,59
item144 db 14,3,44,38,48,39,53,98,9,39,48,54,39,49,56
item145 db 13,8,35,49,45,44,98,17,35,44,38,46,43,44
item146 db 12,17,55,49,35,44,98,22,39,47,50,46,39
item147 db 12,15,43,41,39,59,98,21,39,54,56,39,46
item149 db 13,6,45,33,55,47,39,44,54,35,54,43,45,44
item150 db 11,17,42,35,44,39,98,7,52,35,44,49
item151 db 8,8,45,42,44,98,14,43,47
item152 db 14,18,39,54,39,48,98,6,45,44,44,39,46,46,59
item153 db 15,17,108,98,15,45,48,48,43,49,98,0,48,45,53,44
item155 db 14,15,15,98,11,44,54,39,37,48,35,54,43,45,44
item156 db 22,7,48,43,33,98,101,15,35,38,8,35,33,41,101,98,0,45,48,49,39,54,42
item157 db 18,101,11,16,13,12,101,98,15,35,48,41,98,16,35,32,45,46,38
item158 db 21,9,35,48,46,98,101,9,55,54,46,35,49,49,101,98,4,46,45,48,39,49
item160 db 13,1,45,47,50,35,54,43,32,43,46,43,54,59
item161 db 15,16,39,32,39,33,33,35,98,0,55,49,33,42,39,48
item162 db 12,14,45,55,43,49,98,9,35,50,46,35,44
item163 db 14,12,43,33,41,98,9,48,43,54,49,39,46,43,49
item164 db 15,21,43,46,46,98,1,55,44,44,43,44,37,42,35,47
item165 db 12,17,42,35,44,35,98,1,45,48,38,45,44
item166 db 13,6,43,35,44,44,35,98,0,35,58,54,39,48
item167 db 12,17,33,45,54,54,98,1,35,54,54,45,44
item168 db 11,4,48,39,38,35,98,17,39,35,48,49
item169 db 12,15,35,48,41,98,6,35,44,43,39,46,49
item170 db 14,16,45,32,39,48,54,98,0,35,46,38,53,43,44
item171 db 11,22,45,38,38,98,15,43,46,46,39,48
item173 db 18,22,42,39,98,0,55,43,46,38,98,15,39,43,49,54,39,48,49
item174 db 13,14,46,45,59,38,98,8,45,42,44,49,45,44
item175 db 12,0,48,45,33,41,98,10,35,47,50,39,48
item177 db 13,6,43,48,39,33,54,26,98,17,39,54,55,50
item178 db 12,9,39,52,43,44,98,10,55,59,49,39,48
item179 db 12,3,47,59,98,12,39,55,32,35,55,39,48
item181 db 20,6,43,48,39,33,54,26,98,14,45,33,35,46,43,56,35,54,43,45,44
item182 db 16,27,55,41,43,44,45,48,43,98,11,44,35,37,35,53,35
item183 db 14,3,41,43,41,45,98,15,35,48,55,59,35,47,35
item184 db 15,8,39,36,36,48,39,59,98,21,45,45,38,39,46,46
item186 db 21,6,39,55,49,98,7,58,98,15,35,33,42,43,44,35,98,22,59,50,39,49
item187 db 10,6,48,39,53,98,0,46,43,49,49
item188 db 10,22,45,38,38,98,14,35,44,39,59
item189 db 12,16,35,59,47,45,44,38,98,1,42,39,44
item191 db 16,6,43,48,39,33,54,18,45,43,44,54,59,10,35,43,48
item192 db 11,8,35,59,98,22,45,48,32,45,48,37
item193 db 14,15,35,48,41,98,9,39,44,53,45,48,54,42,59
item194 db 11,13,54,54,45,98,0,39,48,41,39,49
item195 db 11,6,35,48,48,39,44,98,15,55,43,48
item196 db 11,8,39,36,36,98,12,45,48,48,43,49
item197 db 12,14,35,48,48,59,98,13,33,41,39,44,39
item198 db 9,8,43,47,98,20,39,48,39,49
item200 db 13,17,39,33,48,39,54,98,3,37,39,44,54,49
item201 db 15,1,45,46,43,44,98,15,33,1,35,48,54,44,39,59
item202 db 15,17,39,35,47,55,49,98,0,46,35,33,41,46,39,59
item203 db 14,15,43,33,42,39,46,39,98,0,45,46,35,44,38
item205 db 13,111,43,44,98,47,39,47,45,48,43,35,47,111
item206 db 40,111,35,44,38,98,49,45,47,39,54,43,47,39,49,98,53,39,98,49,54,43,46,46,98,42,35,52,39,98,46,55,44,33,42,98,53,43,54,42,111
item207 db 12,1,48,35,43,37,98,7,43,49,46,39,48
item208 db 13,7,48,43,33,98,7,44,37,49,54,48,45,47
item209 db 9,12,43,33,41,98,21,43,46,54
item210 db 17,8,45,49,39,50,42,98,1,45,55,52,43,46,46,43,45,44
list0   dd item0,5,255
list1   dd item1,0,255
list2   dd item2,5,255
list3 dd 36,0,0
list4   dd item4,4,255
list5 dd 36,0,0
list6   dd item6,1,32768
list7   dd item7,1,32768
list8   dd item8,1,32768
list9   dd item9,1,32768
list10   dd item10,1,32768
list11   dd item11,1,32768
list12 dd 36,0,0
list13   dd item13,3,0
list14   dd item14,3,0
list15   dd item15,3,0
list16 dd 36,0,0
list17   dd item17,3,0
list18   dd item18,1,32768
list19 dd 36,0,0
list20   dd item20,1,32768
list21   dd item21,3,0
list22   dd item22,3,0
list23   dd item23,3,0
list24   dd item24,3,0
list25   dd item25,3,0
list26   dd item26,3,0
list27   dd item27,3,0
list28   dd item28,3,0
list29   dd item29,3,0
list30   dd item30,3,0
list31   dd item31,3,0
list32   dd item32,3,0
list33   dd item33,3,0
list34   dd item34,3,0
list35   dd item35,3,0
list36   dd item36,3,0
list37   dd item37,3,0
list38   dd item38,3,0
list39 dd 36,0,0
list40   dd item40,1,32768
list41   dd item41,3,0
list42   dd item42,3,0
list43   dd item43,3,0
list44   dd item44,3,0
list45   dd item45,3,0
list46   dd item46,3,0
list47   dd item47,3,0
list48   dd item48,3,0
list49   dd item49,3,0
list50   dd item50,3,0
list51   dd item51,3,0
list52   dd item52,3,0
list53   dd item53,3,0
list54 dd 36,0,0
list55   dd item55,1,32768
list56   dd item56,3,0
list57   dd item57,3,0
list58   dd item58,3,0
list59   dd item59,3,0
list60   dd item60,3,0
list61   dd item61,3,0
list62   dd item62,3,0
list63   dd item63,3,0
list64   dd item64,3,0
list65   dd item65,3,0
list66   dd item66,3,0
list67   dd item67,3,0
list68   dd item68,3,0
list69   dd item69,3,0
list70   dd item70,3,0
list71   dd item71,3,0
list72   dd item72,3,0
list73 dd 36,0,0
list74   dd item74,1,32768
list75   dd item75,3,0
list76   dd item76,3,0
list77   dd item77,3,0
list78   dd item78,3,0
list79   dd item79,3,0
list80   dd item80,3,0
list81   dd item81,3,0
list82   dd item82,3,0
list83   dd item83,3,0
list84   dd item84,3,0
list85   dd item85,3,0
list86   dd item86,3,0
list87 dd 36,0,0
list88   dd item88,1,32768
list89   dd item89,3,0
list90   dd item90,3,0
list91   dd item91,3,0
list92   dd item92,3,0
list93   dd item93,3,0
list94   dd item94,3,0
list95   dd item95,3,0
list96   dd item96,3,0
list97   dd item97,3,0
list98   dd item98,3,0
list99   dd item99,3,0
list100   dd item100,3,0
list101   dd item101,3,0
list102 dd 36,0,0
list103   dd item103,1,32768
list104   dd item104,3,0
list105   dd item105,3,0
list106   dd item106,3,0
list107   dd item107,3,0
list108   dd item108,3,0
list109   dd item109,3,0
list110   dd item110,3,0
list111   dd item111,3,0
list112   dd item112,3,0
list113   dd item113,3,0
list114   dd item114,3,0
list115   dd item115,3,0
list116   dd item116,3,0
list117   dd item117,3,0
list118   dd item118,3,0
list119   dd item119,3,0
list120   dd item120,3,0
list121   dd item121,3,0
list122   dd item122,3,0
list123   dd item123,3,0
list124   dd item124,3,0
list125   dd item125,3,0
list126   dd item126,3,0
list127   dd item127,3,0
list128 dd 36,0,0
list129   dd item129,1,32768
list130   dd item130,3,0
list131   dd item131,3,0
list132   dd item132,3,0
list133   dd item133,3,0
list134   dd item134,3,0
list135   dd item135,3,0
list136   dd item136,3,0
list137   dd item137,3,0
list138   dd item138,3,0
list139 dd 36,0,0
list140   dd item140,1,32768
list141   dd item141,3,0
list142   dd item142,3,0
list143   dd item143,3,0
list144   dd item144,3,0
list145   dd item145,3,0
list146   dd item146,3,0
list147   dd item147,3,0
list148 dd 36,0,0
list149   dd item149,1,32768
list150   dd item150,3,0
list151   dd item151,3,0
list152   dd item152,3,0
list153   dd item153,3,0
list154 dd 36,0,0
list155   dd item155,1,32768
list156   dd item156,3,0
list157   dd item157,3,0
list158   dd item158,3,0
list159 dd 36,0,0
list160   dd item160,1,32768
list161   dd item161,3,0
list162   dd item162,3,0
list163   dd item163,3,0
list164   dd item164,3,0
list165   dd item165,3,0
list166   dd item166,3,0
list167   dd item167,3,0
list168   dd item168,3,0
list169   dd item169,3,0
list170   dd item170,3,0
list171   dd item171,3,0
list172 dd 36,0,0
list173   dd item173,1,32768
list174   dd item174,3,0
list175   dd item175,3,0
list176 dd 36,0,0
list177   dd item177,1,32768
list178   dd item178,3,0
list179   dd item179,3,0
list180 dd 36,0,0
list181   dd item181,1,32768
list182   dd item182,3,0
list183   dd item183,3,0
list184   dd item184,3,0
list185 dd 36,0,0
list186   dd item186,1,32768
list187   dd item187,3,0
list188   dd item188,3,0
list189   dd item189,3,0
list190 dd 36,0,0
list191   dd item191,1,32768
list192   dd item192,3,0
list193   dd item193,3,0
list194   dd item194,3,0
list195   dd item195,3,0
list196   dd item196,3,0
list197   dd item197,3,0
list198   dd item198,3,0
list199 dd 36,0,0
list200   dd item200,1,32768
list201   dd item201,3,0
list202   dd item202,3,0
list203   dd item203,3,0
list204 dd 36,0,0
list205   dd item205,1,32768
list206   dd item206,3,0
list207   dd item207,3,0
list208   dd item208,3,0
list209   dd item209,3,0
list210   dd item210,3,0
list211 dd 100,0,0
public ListData
ListData dd list0
 dd list1
 dd list2
 dd list3
 dd list4
 dd list5
 dd list6
 dd list7
 dd list8
 dd list9
 dd list10
 dd list11
 dd list12
 dd list13
 dd list14
 dd list15
 dd list16
 dd list17
 dd list18
 dd list19
 dd list20
 dd list21
 dd list22
 dd list23
 dd list24
 dd list25
 dd list26
 dd list27
 dd list28
 dd list29
 dd list30
 dd list31
 dd list32
 dd list33
 dd list34
 dd list35
 dd list36
 dd list37
 dd list38
 dd list39
 dd list40
 dd list41
 dd list42
 dd list43
 dd list44
 dd list45
 dd list46
 dd list47
 dd list48
 dd list49
 dd list50
 dd list51
 dd list52
 dd list53
 dd list54
 dd list55
 dd list56
 dd list57
 dd list58
 dd list59
 dd list60
 dd list61
 dd list62
 dd list63
 dd list64
 dd list65
 dd list66
 dd list67
 dd list68
 dd list69
 dd list70
 dd list71
 dd list72
 dd list73
 dd list74
 dd list75
 dd list76
 dd list77
 dd list78
 dd list79
 dd list80
 dd list81
 dd list82
 dd list83
 dd list84
 dd list85
 dd list86
 dd list87
 dd list88
 dd list89
 dd list90
 dd list91
 dd list92
 dd list93
 dd list94
 dd list95
 dd list96
 dd list97
 dd list98
 dd list99
 dd list100
 dd list101
 dd list102
 dd list103
 dd list104
 dd list105
 dd list106
 dd list107
 dd list108
 dd list109
 dd list110
 dd list111
 dd list112
 dd list113
 dd list114
 dd list115
 dd list116
 dd list117
 dd list118
 dd list119
 dd list120
 dd list121
 dd list122
 dd list123
 dd list124
 dd list125
 dd list126
 dd list127
 dd list128
 dd list129
 dd list130
 dd list131
 dd list132
 dd list133
 dd list134
 dd list135
 dd list136
 dd list137
 dd list138
 dd list139
 dd list140
 dd list141
 dd list142
 dd list143
 dd list144
 dd list145
 dd list146
 dd list147
 dd list148
 dd list149
 dd list150
 dd list151
 dd list152
 dd list153
 dd list154
 dd list155
 dd list156
 dd list157
 dd list158
 dd list159
 dd list160
 dd list161
 dd list162
 dd list163
 dd list164
 dd list165
 dd list166
 dd list167
 dd list168
 dd list169
 dd list170
 dd list171
 dd list172
 dd list173
 dd list174
 dd list175
 dd list176
 dd list177
 dd list178
 dd list179
 dd list180
 dd list181
 dd list182
 dd list183
 dd list184
 dd list185
 dd list186
 dd list187
 dd list188
 dd list189
 dd list190
 dd list191
 dd list192
 dd list193
 dd list194
 dd list195
 dd list196
 dd list197
 dd list198
 dd list199
 dd list200
 dd list201
 dd list202
 dd list203
 dd list204
 dd list205
 dd list206
 dd list207
 dd list208
 dd list209
 dd list210
 dd list211
 dd 0
 END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\16to32.inc ===
APILOGSL  macro   argName
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw\sources.inc ===
TARGETNAME = ddraw
TARGETPATH = obj
TARGETTYPE = DYNLINK

MAJORCOMP  = windows
MINORCOMP  = ddraw
UMTYPE     = windows

#
# 04/11/2000 - allows for addition of BoundsChecker, etc
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
    $(WINDOWS_LIB_PATH)\user32p.lib  \
    $(SDK_LIB_PATH)\dciman32.lib \
    $(SDK_LIB_PATH)\uuid.lib         \
    $(SDK_LIB_PATH)\advapi32.lib

SYNCHRONIZE_DRAIN = 1

DLLENTRY = _DllMainCRTStartup

LINKLIBS = \
    ..\..\ddhel\$(PLAT_DIR)\$(_OBJ_DIR)\*\ddhel.lib     \
    ..\..\blitlib\$(PLAT_DIR)\$(_OBJ_DIR)\*\blitlib.lib \
    ..\..\main\$(PLAT_DIR)\$(_OBJ_DIR)\*\main.lib

SOURCES = \
    ..\ddraw.rc

!ifndef  MAKEDLL
!if "$(__PRODUCT)" == "DX8"
MISCFILES=$(TARGET)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\dci.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dci.c
 *  Content:	16-bit DCI code
 *		This was cut from DCIMAN to provide basic DCI services when
 *		we don't have DirectDraw drivers
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-jun-95	craige	split out of DCIMAN.C, tweaked
 *   31-jul-95	craige	added DCIIsBanked
 *   13-may-96  colinmc Bug 21192: DCI HDC being freed erroneously due to
 *                      process termination
 *
 ***************************************************************************/
#define _INC_DCIDDI
#include "ddraw16.h"
#undef _INC_DCIDDI

UINT 	wFlatSel;
LPVOID  pWin16Lock;

#undef WINAPI
#define WINAPI FAR PASCAL _loadds

#include "dciman.h"

static char szDISPLAY[]	  = "display";

/*
 * define some types so we dont go insane, these structures are exactly the
 * same (dont need repacked) but it is nice to have different types
 * so we can read the code
 */
typedef LPDCISURFACEINFO    LPDCISURFACEINFO16;
typedef LPDCISURFACEINFO    LPDCISURFACEINFO32;

typedef LPDCIOFFSCREEN      LPDCIOFFSCREEN16;
typedef LPDCIOFFSCREEN      LPDCIOFFSCREEN32;

typedef LPDCIOVERLAY        LPDCIOVERLAY16;
typedef LPDCIOVERLAY        LPDCIOVERLAY32;

#define PDCI16(pdci32) (LPDCISURFACEINFO16)(((LPDCISURFACEINFO32)(pdci32))->dwReserved2)

extern HINSTANCE hInstApp;

/*
 * DCIOpenProvider
 *
 * only open the DISPLAY driver.
 */
HDC WINAPI DCIOpenProvider(void)
{
    HDC		hdc;
    UINT	u;

    u = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hdc = CreateDC( szDISPLAY, NULL, NULL, NULL );
    SetErrorMode(u);

    /*
     *	now check for the Escape
     */
    if (hdc)
    {
        u = DCICOMMAND;
        if( Escape(hdc, QUERYESCSUPPORT,sizeof(u),(LPCSTR)&u,NULL) == 0 )
        {
            /*
             * driver does not do escape, punt it.
             */
            DeleteDC(hdc);
            hdc = NULL;
        }
    }

    if (hdc)
    {
	/*
	 * Reparent it to prevent it going away when the app. dies.
	 */
        SetObjectOwner(hdc, hInstApp);
    }

    return hdc;

} /* DCIOpenProvider */

/*
 * DCICloseProvider
 */
void WINAPI DCICloseProvider(HDC hdc)
{
    if( hdc )
    {
	DeleteDC(hdc);
    }

} /* DCICloseProvider */

/*
 * dciSendCommand
 */
static int dciSendCommand(
		HDC hdc,
		VOID FAR *pcmd,
		int nSize,
		VOID FAR * FAR * lplpOut )
{
    if( lplpOut )
    {
	*lplpOut = NULL;
    }

    return Escape( hdc, DCICOMMAND, nSize, (LPCSTR)pcmd, lplpOut );

} /* dciSendCommand */

/*
 * DCICreatePrimary
 */
int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface)
{
    DCICREATEINPUT	ci;
    DCIRVAL 		err;
    HDC 		hdcScreen;

    ci.cmd.dwCommand	= (DWORD)DCICREATEPRIMARYSURFACE;
    ci.cmd.dwParam1	= 0;
    ci.cmd.dwParam2	= 0;
    ci.cmd.dwVersion	= (DWORD)DCI_VERSION;
    ci.cmd.dwReserved	= 0;
    ci.dwDCICaps	= DCI_PRIMARY | DCI_VISIBLE;

    DPF( 4, "DCICreatePrimary" );

    /*
     * for the primary surface we always use the display driver over
     * a external provider.
     */
    hdcScreen = GetDC( NULL );
    err = dciSendCommand(hdcScreen, &ci, sizeof(DCICREATEINPUT), lplpSurface);
    ReleaseDC( NULL, hdcScreen );

    if( err != DCI_OK || *lplpSurface == NULL )
    {
	err = dciSendCommand(hdc, &ci, sizeof(DCICREATEINPUT), lplpSurface);
    }

    return err;

} /* DCICreatePrimary */

/*
 * DCIDestroy
 */
void WINAPI DCIDestroy(LPDCISURFACEINFO pdci)
{
    if( (DWORD)pdci->DestroySurface == 0xFFFFFFFF )
    {
        pdci = PDCI16(pdci);
    }

    if( pdci->DestroySurface != NULL )
    {
        pdci->DestroySurface(pdci);
    }

} /* DCIDestroy */

/*
 * DCIEndAccess
 */
void WINAPI DCIEndAccess( LPDCISURFACEINFO pdci )
{
    if( (DWORD)pdci->DestroySurface == 0xFFFFFFFF)
    {
        pdci = PDCI16( pdci );
    }

    if( pdci->EndAccess != NULL )
    {
        pdci->EndAccess( pdci );
    }

    LeaveSysLevel( pWin16Lock );

} /* DCIEndAccess */

/*
 * dciSurface16to32
 *
 * convert a DCI16 bit structure to a 32bit structure
 */
static int dciSurface16to32(
		LPDCISURFACEINFO16 pdci16,
		LPDCISURFACEINFO32 pdci32 )
{
    DPF( 4, "dciSurface16to32" );
    if( pdci16 == NULL )
    {
	DPF( 1, "pdci16=NULL" );
        return DCI_FAIL_GENERIC;
    }

    if( pdci32 == NULL )
    {
	DPF( 1, "pdci32=NULL" );
        return DCI_FAIL_GENERIC;
    }

    if (pdci16->dwSize < sizeof(DCISURFACEINFO))
    {
        //
        // invalid DCISURCACEINFO.
        //
        pdci16->dwSize = sizeof(DCISURFACEINFO);
    }

    if (pdci16->dwSize > sizeof(DCIOFFSCREEN))
    {
        //
        // invalid DCISURCACEINFO.
        //
        return DCI_FAIL_GENERIC;
    }

    _fmemcpy(pdci32, pdci16, (UINT) pdci32->dwSize);     // copy the info.

    pdci32->dwReserved2 = (DWORD)(LPVOID)pdci16;

    if (pdci16->BeginAccess != NULL)
    {
        (DWORD)pdci32->BeginAccess = 0xFFFFFFFF;   // you cant call these, but they
        (DWORD)pdci32->EndAccess   = 0xFFFFFFFF;   // must be non-zero
    }

    (DWORD)pdci32->DestroySurface = 0xFFFFFFFF;   // must be non-zero

    /*
     *  now we need to convert the pointer to a 0:32 (ie flat pointer)
     *  we can only do this if the provider has *not* set the 1632_ACCESS bit.
     *
     *  if the 1632_ACCESS bit is set, call VFlatD to see if we can
     *  enable linear access mode.
     */
    if( pdci16->wSelSurface != 0 )
    {
        if( pdci16->dwDCICaps & DCI_1632_ACCESS )
        {
            if( pdci16->wSelSurface == VFDQuerySel())
            {
                if( (wFlatSel == 0) && VFDBeginLinearAccess() )
                {
                    wFlatSel = AllocSelector(SELECTOROF((LPVOID)&pdci16));
                    SetSelectorBase(wFlatSel, 0);
                    SetSelLimit(wFlatSel, 0xFFFFFFFF);
                }

                if (wFlatSel != 0)
                {
                    pdci32->dwOffSurface += VFDQueryBase();
                    pdci32->wSelSurface = wFlatSel; // 0;
                    pdci32->dwDCICaps &= ~DCI_1632_ACCESS;
                }
            }
        }
        else
        {
	    /*
	     *	convert the 16:32 pointer to a flat pointer.
	     */
            pdci32->dwOffSurface += GetSelectorBase(pdci16->wSelSurface);
	    pdci32->wSelSurface = 0;
	    pdci32->wReserved = 0;
        }
    }
    else
    {
        // selector is zero so the address is flat already
        // clear DCI_1632_ACCESS for broken providers?

	pdci32->dwDCICaps &= ~DCI_1632_ACCESS;	    // !!!needed?
    }

    return DCI_OK;

} /* dciSurface16to32 */

/*
 * DCIBeginAccess
 */
DCIRVAL WINAPI DCIBeginAccess(
		LPDCISURFACEINFO pdci,
		int x,
		int y,
		int dx,
		int dy )
{
    int		err;
    RECT	rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x+dx;
    rc.bottom = y+dy;

    if( (DWORD)pdci->DestroySurface == 0xFFFFFFFF )
    {
	LPDCISURFACEINFO16 pdci16 = PDCI16(pdci);

	if( pdci16->BeginAccess != NULL )
	{
	    err = pdci16->BeginAccess( pdci16, &rc );
	}
	else
	{
	    err = DCI_OK;
	}

	if( err > 0 )
	{
	    err = dciSurface16to32(pdci16, pdci);
	}
    }
    else
    {
	if( pdci->BeginAccess != NULL )
	{
	    err = pdci->BeginAccess(pdci, &rc);
	}
	else
	{
	    err = DCI_OK;
	}
    }

    if( err >= 0 )
    {
        EnterSysLevel( pWin16Lock );
    }
    return err;

} /* DCIBeginAccess */

/*
 * DCICreatePrimary
 */
int WINAPI DCICreatePrimary32(HDC hdc, LPDCISURFACEINFO32 pdci32)
{
    LPDCISURFACEINFO	pdci16;
    int			rc;

    DPF( 4, "DCICreatePrimary32" );

    rc = DCICreatePrimary(hdc, &pdci16);

    if( rc == DCI_OK )
    {
        rc = dciSurface16to32( pdci16, pdci32 );
    }

    return rc;

} /* DCICreatePrimary */

/*
 * DCIIsBanked
 */
BOOL DDAPI DCIIsBanked( HDC hdc )
{
    LPDCISURFACEINFO	pdci16;
    int			rc;

    rc = DCICreatePrimary(hdc, &pdci16);
    if( rc == DCI_OK )
    {
	if( !IsBadReadPtr( pdci16, sizeof( *pdci16 ) ) )
	{
	    if( pdci16->dwDCICaps & DCI_1632_ACCESS )
	    {
		rc = TRUE;
	    }
	    else
	    {
		rc = FALSE;
	    }
	    DCIDestroy( pdci16 );
	}
	else
	{
	    rc = FALSE;
	}
	return rc;
    }
    return FALSE;

} /* DCIIsBanked */

#pragma optimize("", off)
void SetSelLimit(UINT sel, DWORD limit)
{
    if( limit >= 1024*1024l )
    {
        limit = ((limit+4096) & ~4095) - 1;
    }

    _asm
    {
        mov     ax,0008h            ; DPMI set limit
        mov     bx,sel
        mov     dx,word ptr limit[0]
        mov     cx,word ptr limit[2]
        int     31h
    }
} /* SetSelLimit */
#pragma optimize("", on)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\edid.h ===
//
// This include file contains the format of the VESA EDID data structure as
// described in the VESA Display Data Channel (DDC) Specification.  It should
// be included in any assembly language program that requires knowledge of the
// EDID data structure.
//
typedef struct VESA_EDID {
        BYTE    veHeader[8];        // 0,FFH,FFH,FFH,FFH,FFH,FFH,0
        BYTE    veManufactID[2];    // in compressed format - see spec
        BYTE    veProductCode[2];   // vendor assigned code
        DWORD   veSerialNbr;        // 32 bit serial nbr (LSB first)
        BYTE    veWeekMade;         // week of manufacture (0-53)
        BYTE    veYearMade;         // year of manufacture - 1990
        BYTE    veEDIDVersion;      // version number of EDID
        BYTE    veEDIDRevision;     // revision number of EDID
        BYTE    veVidInputDef;      // video input definition
        BYTE    veMaxHorizSize;     // horizontal image size in cm
        BYTE    veMaxVertSize;      // vertical image size in cm
        BYTE    veGammaXFER;        // (gamma * 100) - 100 (1.00-3.55)
        BYTE    veDPMSFeatures;     // DPMS feature support
        BYTE    veRedGreenLow;      // Rx1Rx0Ry1Ry0Gx1Gx0Gy1Gy0
        BYTE    veBlueWhiteLow;     // Bx1Bx0By1By0Wx1Wx0Wy1Wy0
        BYTE    veRedx;             // red X bit 9 - 2
        BYTE    veRedy;             // red Y bit 9 - 2
        BYTE    veGreenx;           // green X bit 9 - 2
        BYTE    veGreeny;           // green Y bit 9 - 2
        BYTE    veBluex;            // blue X bit 9 - 2
        BYTE    veBluey;            // blue Y bit 9 - 2
        BYTE    veWhitex;           // white X bit 9 - 2
        BYTE    veWhitey;           // white Y bit 9 - 2
        BYTE    veEstTime1;         // established timings I
        BYTE    veEstTime2;         // established timings II
        BYTE    veEstTime3;         // established timings II
        WORD    veStdTimeID1;       //
        WORD    veStdTimeID2;       //
        WORD    veStdTimeID3;       //
        WORD    veStdTimeID4;       //
        WORD    veStdTimeID5;       //
        WORD    veStdTimeID6;       //
        WORD    veStdTimeID7;       //
        WORD    veStdTimeID8;       //
        BYTE    veDetailTime1[18];  //
        BYTE    veDetailTime2[18];  //
        BYTE    veDetailTime3[18];  //
        BYTE    veDetailTime4[18];  //
        BYTE    veExtensionFlag;    // nbr of 128 EDID extensions
        BYTE    veChecksum;         // sum of all bytes == 0
}       VESA_EDID;

/*ASM
.errnz  size VESA_EDID - 128                    ;must be 128 bytes long!
*/

//
// bit definitions for the veEstTime1 field
//
#define veEstTime1_720x400x70Hz     0x80   // 720x400x70Hz  VGA,IBM
#define veEstTime1_720x400x88Hz     0x40   // 720x400x88Hz  XGA2,IBM
#define veEstTime1_640x480x60Hz     0x20   // 640x480x60Hz  VGA,IBM
#define veEstTime1_640x480x67Hz     0x10   // 640x480x67Hz  MacII,Apple
#define veEstTime1_640x480x72Hz     0x08   // 640x480x72Hz  VESA
#define veEstTime1_640x480x75Hz     0x04   // 640x480x75Hz  VESA
#define veEstTime1_800x600x56Hz     0x02   // 800x600x56Hz  VESA
#define veEstTime1_800x600x60Hz     0x01   // 800x600x60Hz  VESA

//
// bit definitions for the veEstTime2 field
//
#define veEstTime2_800x600x72Hz     0x80   // 800x600x72Hz   VESA
#define veEstTime2_800x600x75Hz     0x40   // 800x600x75Hz   VESA
#define veEstTime2_832x624x75Hz     0x20   // 832x624x75Hz   MacII,Apple
#define veEstTime2_1024x768x87Hz    0x10   // 1024x768x87Hz  IBM
#define veEstTime2_1024x768x60Hz    0x08   // 1024x768x60Hz  VESA
#define veEstTime2_1024x768x70Hz    0x04   // 1024x768x70Hz  VESA
#define veEstTime2_1024x768x75Hz    0x02   // 1024x768x75Hz  VESA
#define veEstTime2_1280x1024x75Hz   0x01   // 1280x1024x75Hz VESA

//
// bit definitions for the veEstTime3 field (was veManTimes in DDC 1)
//
#define veEstTime3_1152x870x75Hz    0x80   // 800x600x72Hz   MacII,Apple
#define veEstTime3_640x480x85Hz     0x40   // 640x480x85Hz   VESA
#define veEstTime3_800x600x85Hz     0x20   // 800x600x85Hz   VESA
#define veEstTime3_1280x1024x85Hz   0x10   // 1280x1024x85Hz VESA
#define veEstTime3_1024x768x85Hz    0x08   // 1024x768x85Hz  VESA
#define veEstTime3_1600x1200x75Hz   0x04   // 1600x1200x75Hz VESA
#define veEstTime3_1600x1200x85Hz   0x02   // 1600x1200x85Hz VESA
#define veEstTime3_ManReservedTime  0x01   // manufacturer's reserved timings

//
// bit definitions for the veStdTime field
//
#define veStdTime_HorzResMask       0x00FF    // HorzRes = (X + 31) * 8
#define veStdTime_RefreshRateMask   0x1F00    // RefreshRate = X + 60Hz
#define veStdTime_AspectRatioMask   0xC000    //
#define veStdTime_AspectRatio1to1   0x0000    // 1:1
#define veStdTime_AspectRatio4to3   0x4000    // 4:3
#define veStdTime_AspectRatio5to4   0x8000    // 5:4
#define veStdTime_AspectRatio16to9  0xC000    // 16:9
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\dynares.c ===
/*
 * DynaRes
 *
 * replacment for ChangeDisplaySettings EnumDisplaySettings to allow
 * changing the bitdepth on the fly
 *
 * ToddLa
 *
 */
#ifdef IS_16
#define DIRECT_DRAW
#endif

#ifdef DIRECT_DRAW
#include "ddraw16.h"
#else
#include <windows.h>
#include <print.h>
#include "gdihelp.h"
#include "dibeng.inc"
#endif

#define BABYSIT     // if this is defined, work around bugs in the display driver
#define O95_HACK    // enable the Office95 (any app bar) hack to prevent icons from being squished
#define SPI_HACK    // enable the SPI_SETWORKAREA hack, when a app bar is up.

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
#undef Assert
#undef DPF
#ifdef DEBUG
static void CDECL DPF(char *sz, ...)
{
    char ach[128];
    lstrcpy(ach, "QuickRes: ");
    wvsprintf(ach+10, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(2, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}
static void NEAR PASCAL __Assert(char *exp, char *file, int line)
{
    DPF("Assert(%s) failed at %s line %d.", (LPSTR)exp, (LPSTR)file, line);
    DebugBreak();
}
#define Assert(exp)  ( (exp) ? (void)0 : __Assert(#exp,__FILE__,__LINE__) )
#else
#define Assert(f)
#define DPF ; / ## /
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

extern void FAR PASCAL SetMagicColors(HDC, DWORD, WORD);
extern UINT FAR PASCAL AllocCStoDSAlias(UINT);
extern void FAR PASCAL Death(HDC);
extern void FAR PASCAL Resurrection(HDC,LONG,LONG,LONG);

static char szClassName[] = "DynaResFullscreenWindow";
static char szDIBENG[]  = "DIBENG";
static char szDISPLAY[] = "DISPLAY";
static char szUSER[]    = "USER";
extern LONG FAR PASCAL DIBENG_Control(LPVOID,UINT,LPVOID,LPVOID);

extern HINSTANCE hInstApp;

#ifdef DIRECT_DRAW
extern bInOurSetMode;
#else
BOOL bInOurSetMode;
#endif

BOOL fNewDibEng;
BOOL fDirectDrawDriver;

BOOL InitDynaRes(void);
void PreStartMenuHack(DEVMODE FAR *);
void StartMenuHack(DEVMODE FAR *);
BOOL ForceSoftwareCursor(BOOL);
BOOL IsMatrox(void);

void PatchDisplay(int oem, BOOL patch);
void PatchControl(BOOL patch);
LONG FAR PASCAL _loadds Control(LPVOID lpDevice,UINT function,LPVOID lp_in_data,LPVOID lp_out_data);

#undef ChangeDisplaySettings

LONG WINAPI RealChangeDisplaySettings(LPDEVMODE pdm, DWORD flags)
{
    return ChangeDisplaySettings(pdm, flags & ~CDS_EXCLUSIVE);
}

#ifdef DIRECT_DRAW
LONG DDAPI DD16_ChangeDisplaySettings(LPDEVMODE pdm, DWORD flags)
#else
LONG WINAPI DynaChangeDisplaySettings(LPDEVMODE pdm, DWORD flags)
#endif
{
    LONG err;
    HDC hdc;
    int rc,bpp,w,h;
    int new_rc,new_bpp;
    HWND hwnd=NULL;

    bInOurSetMode = TRUE;

    flags &= ~CDS_EXCLUSIVE;

    if (!InitDynaRes())
    {
        err = ChangeDisplaySettings(pdm, flags);
        bInOurSetMode = FALSE;
        return err;
    }

    if (flags & CDS_TEST)
    {
        err = ChangeDisplaySettings(pdm, flags | CDS_EXCLUSIVE);
        bInOurSetMode = FALSE;
        return err;
    }

    if (flags & CDS_FULLSCREEN)
        PreStartMenuHack(pdm);

    //
    // try changing the mode normaly first
    // if it works, we are done.
    //
#ifdef BABYSIT
    bInOurSetMode = (BOOL)2;
    PatchControl(TRUE);
    err = ChangeDisplaySettings(pdm, flags);
    PatchControl(FALSE);
    bInOurSetMode = TRUE;
#else
    err = ChangeDisplaySettings(pdm, flags);
#endif

    if (err == DISP_CHANGE_SUCCESSFUL)
    {
        if (flags & CDS_FULLSCREEN)
            StartMenuHack(pdm);
        bInOurSetMode = FALSE;
        return err;
    }

    //
    // if the mode is not valid dont even try.
    //
    err = ChangeDisplaySettings(pdm, CDS_EXCLUSIVE | CDS_TEST);

    if (err != DISP_CHANGE_SUCCESSFUL)
    {
        bInOurSetMode = FALSE;
        return err;
    }

    //
    // get the current settings
    //
    hdc = GetDC(NULL);
    rc  = GetDeviceCaps(hdc, RASTERCAPS);
    bpp = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    w   = GetDeviceCaps(hdc, HORZRES);
    h   = GetDeviceCaps(hdc, VERTRES);
    ReleaseDC(NULL, hdc);

    //
    // dont try to do a invalid change
    //
    if (pdm && (pdm->dmFields & DM_BITSPERPEL))
    {
        if ((int)pdm->dmBitsPerPel == bpp)
        {
            bInOurSetMode = FALSE;
            return DISP_CHANGE_FAILED;
        }

        if (bpp <= 4 && (int)pdm->dmBitsPerPel != bpp)
        {
            bInOurSetMode = FALSE;
            return DISP_CHANGE_RESTART;
        }

        if (bpp > 4 && (int)pdm->dmBitsPerPel <= 4)
        {
            bInOurSetMode = FALSE;
            return DISP_CHANGE_RESTART;
        }
    }

#ifndef NOCREATEWINDOW
    //
    //  bring up a "cover" window to hide all the activity of the mode
    //  change from the user.  and brings up a wait cursor
    //
    //  NOTE this does a little more than just hide the mode change
    //  from the user, it also makes sure to set a MONO hourglass cursor
    //  some display drivers dont like a software cursor being active
    //  durring a mode set, so we give them a mono one.
    //
    if (TRUE || !(flags & CDS_FULLSCREEN))
    {
        #define OCR_WAIT_DEFAULT 102

        WNDCLASS cls;

        cls.lpszClassName  = szClassName;
        cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
        cls.hInstance      = hInstApp;
        cls.hIcon          = NULL;
        cls.hCursor        = (HCURSOR)LoadImage(NULL,MAKEINTRESOURCE(OCR_WAIT_DEFAULT),IMAGE_CURSOR,0,0,0);
        cls.lpszMenuName   = NULL;
        cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        cls.lpfnWndProc    = DefWindowProc;
        cls.cbWndExtra     = 0;
        cls.cbClsExtra     = 0;

        RegisterClass(&cls);

        hwnd = CreateWindowEx(WS_EX_TOPMOST|WS_EX_TOOLWINDOW,
            szClassName, szClassName,
            WS_POPUP|WS_VISIBLE, 0, 0, 10000, 10000,
            NULL, NULL, hInstApp, NULL);

        if (hwnd == NULL)
        {
            bInOurSetMode = FALSE;
            return DISP_CHANGE_FAILED;
        }

        SetForegroundWindow(hwnd);  // we want cursor focus
        SetCursor(cls.hCursor);     // set wait cursor.
    }
#endif

    //
    // no one gets to draw until we are done.
    //
    LockWindowUpdate(GetDesktopWindow());

    DPF("Begin mode change from %dx%dx%d....", w,h,bpp);

    //
    // first thing we have to do is convert all DDBs and Pattern brushs
    // to DIBSections so they will still work after the mode has changed.
    //
    ConvertObjects();

    //
    // convert all icons so they can be drawn correctly.
    //
    if (!fNewDibEng && !(flags & CDS_FULLSCREEN))
    {
        //ConvertIcons();
    }

#ifdef BABYSIT
    //
    // the matrox driver is broken
    // it has a global variable for bPaletized mode, and it only
    // reads it if the mode is 8bpp.
    //
    if (!fDirectDrawDriver && bpp == 8 && IsMatrox())
    {
        static char szSystemIni[] = "system.ini";
        static char szPalettized[] = "palettized";
        static char szZero[] = "0";
        static DEVMODE dm;
        dm.dmSize             = sizeof(DEVMODE);
        dm.dmFields           = DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT;
        dm.dmBitsPerPel       = 8;
        dm.dmPelsWidth        = 640;
        dm.dmPelsHeight       = 480;

        DPF("**BABYSIT** Fixing the broken Matrox driver....");
        WritePrivateProfileString(szDISPLAY,szPalettized,szZero,szSystemIni);
        err = ChangeDisplaySettings(&dm, CDS_RESET | CDS_FULLSCREEN);
        WritePrivateProfileString(szDISPLAY,szPalettized,NULL,szSystemIni);
    }
#endif

    //
    //  some drivers are total broken and we need to
    //  route some of its entry points to the DIBENG
    //
    //  WARNING this can break some remote control programs!
    //
#ifdef BABYSIT
    if (!fDirectDrawDriver)
    {
        DPF("**BABYSIT** turning off OEMOutput....");
        PatchDisplay(8, TRUE);      // route OEMOutput to the DIBENG

        DPF("**BABYSIT** turning off OEMDibBlt....");
        PatchDisplay(19, TRUE);     // route OEMDibBlt to the DIBENG
    }
#endif

    //
    // change the display settings.
    //
    PatchControl(TRUE);

    DPF("Calling ChangeDisplaySettings....");
    //
    // NOTE USER will Yield unless CDS_FULLSCREEN is specifed
    //
    err = ChangeDisplaySettings(pdm, flags | CDS_EXCLUSIVE);
    DPF("....ChangeDisplaySettings returns %d", err);

    // get the new settings
    //
    hdc = GetDC(NULL);
    new_rc  = GetDeviceCaps(hdc, RASTERCAPS);
    new_bpp = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL, hdc);

    //
    // make sure the driver has not messed up its rastercaps!
    // for example the QVision driver does not get this right.
    //
    if ((new_rc & RC_PALETTE) && new_bpp != 8)
    {
        DPF("**BABYSIT** drivers RC_PALETTE bit is messed up.");
        err = DISP_CHANGE_RESTART; // err = DISP_CHANGE_FAILED;
    }

    //
    // if the driver failed the mode set things could be real messed up
    // reset the current mode, to try to recover.
    //
#ifdef BABYSIT
    if (err != DISP_CHANGE_SUCCESSFUL)
    {
        static DEVMODE dm;
        dm.dmSize             = sizeof(DEVMODE);
        dm.dmFields           = DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT|DM_DISPLAYFLAGS;
        dm.dmBitsPerPel       = bpp;
        dm.dmPelsWidth        = w;
        dm.dmPelsHeight       = h;
        dm.dmDisplayFlags     = 0;

        DPF("**BABYSIT** mode set failed, going back to old mode.");
        ChangeDisplaySettings(&dm, CDS_RESET | CDS_EXCLUSIVE | CDS_FULLSCREEN);
    }
#endif

    PatchControl(FALSE);

    //
    // call Death/Resurection this will kick drivers in the head
    // about the mode change
    //
    if (!fDirectDrawDriver && err == 0 &&
        (pdm == NULL || (flags & CDS_UPDATEREGISTRY)))
    {
        hdc = GetDC(NULL);
        DPF("Calling Death/Resurection....");
        SetCursor(NULL);
        Death(hdc);
        Resurrection(hdc,NULL,NULL,NULL);
        ReleaseDC(NULL, hdc);
    }

    //
    // force a SW cursor, most drivers are broken and dont disable
    // the HW cursor when changing modes.
    //
#ifdef BABYSIT
    if (!fDirectDrawDriver)
    {
        if (pdm == NULL && (flags & CDS_FULLSCREEN))
        {
            DPF("**BABYSIT** restoring HW cursor (return from fullscreen mode)");
            ForceSoftwareCursor(FALSE);
        }
        else if (err == 0 && (new_bpp > 8 || GetSystemMetrics(SM_CXSCREEN) < 640))
        {
            DPF("**BABYSIT** Forcing a software cursor");
            ForceSoftwareCursor(TRUE);
        }
        else
        {
            DPF("**BABYSIT** restoring HW cursor");
            ForceSoftwareCursor(FALSE);
        }
    }
#endif

#if 0 /// moved to Control patch
    //
    // we should now convert any DIBSections that used to be DDBs back to DDBs
    // our code to find the right palette for a DDB is not too hot
    // so a lot of DDBs will have wrong colors.
    //
#if 1
    ConvertBitmapsBack(FALSE);
#else
    ConvertBitmapsBack(!(flags & CDS_FULLSCREEN));
#endif
#endif

    //
    // let other apps draw.
    //
    LockWindowUpdate(NULL);

    //
    // remove our "cover" window
    //
    if (hwnd)
    {
        DestroyWindow(hwnd);
        UnregisterClass(szClassName, hInstApp);
    }

    //
    // should we reload the wallpaper, because it got converted to
    // a DDB by ConvertBitmapsBack
    //
    if (!(flags & CDS_FULLSCREEN))
    {
        DPF("Reloading wallpaper...");
        SystemParametersInfo(SPI_SETDESKWALLPAPER, 0, NULL, 0);
    }

    //
    //  have all the apps deal with a color change
    //
    if (!(flags & CDS_FULLSCREEN))
    {
        //
        //
        //
        // if we just post the WM_SYSCOLORCHANGE message to all apps
        // a hidden office window will go back and forth Invalidating
        // other office apps and re-sending the WM_SYSCOLORCHANGE message
        // you either stack overflow, hang or XL just flashes for a few
        // minutes.
        //
        // the "fix" is to not post the WM_SYSCOLORCHANGE message to
        // this hidden window, we also have to make sure not to call
        // SystemParametersInfo(SPI_SETDESKPATTERN) later in the code.
        //

        HWND hwnd;
        HWND hwndX;

        if (hwndX = FindWindow("File Open Message Window", "File Open Message Window"))
        {

            for (hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
                hwnd;
                hwnd = GetWindow(hwnd, GW_HWNDNEXT))
            {
                if (hwnd != hwndX)
                    PostMessage(hwnd, WM_SYSCOLORCHANGE, 0, 0);
            }

            // dont reload desktop pattern.
            flags |= CDS_FULLSCREEN;
        }
        else
        {
            PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);
        }
    }

    //
    // reload the desktop pattern
    //
    if (!(flags & CDS_FULLSCREEN) || pdm == NULL)
    {
        DPF("Reloading wallpaper pattern...");
        SystemParametersInfo(SPI_SETDESKPATTERN, (UINT)-1, NULL, 0);
    }

    //
    // we dont want the StartMenu to rebuild when we change modes
    //
    if (err == DISP_CHANGE_SUCCESSFUL)
    {
        if (flags & CDS_FULLSCREEN)
            StartMenuHack(pdm);
    }

    bInOurSetMode = FALSE;
    DPF("Done...");
    return err;
}

#ifndef DCICOMMAND
#define DCICOMMAND		3075		// escape value
#endif

BOOL InitDynaRes()
{
    int v;
    HDC hdc;
    HBRUSH hbr1, hbr2;
    BOOL f=TRUE;
    OSVERSIONINFO ver = {sizeof(OSVERSIONINFO)};
    GetVersionEx(&ver);

    // must be Windows95 build 950 or higher

    if (LOWORD(GetVersion()) != 0x5F03)
    {
        DPF("Init: Windows version not 3.95.");
        f = FALSE;
    }

    if (ver.dwMajorVersion != 4 ||
        ver.dwMinorVersion != 0 ||
        LOWORD(ver.dwBuildNumber) < 950)
    {
        DPF("Init: Windows version less than 4.0.950");
        f = FALSE;
    }

    //
    // we assume create/delete/create will get the same handle
    //
    hbr1 = CreateSolidBrush(RGB(1,1,1));
    DeleteObject(hbr1);
    hbr2 = CreateSolidBrush(RGB(2,2,2));
    DeleteObject(hbr2);

    if (hbr1 != hbr2)
    {
        DPF("Init: cant use Destroy/Create brush trick");
        f = FALSE;
    }

    if (GetModuleHandle(szDIBENG) == 0)
    {
        DPF("Init: DIBENG not loaded");
        f = FALSE;
    }

    hdc = GetDC(NULL);

    // check the DIBENG version
    v = 0x5250;
    v = Escape(hdc, QUERYESCSUPPORT, sizeof(int), (LPVOID)&v, NULL);

    if (v == 0)
    {
        DPF("Init: we dont have a new DIBENG");
        fNewDibEng = FALSE;
    }
    else
    {
        DPF("Init: DIBENG version: %04X", v);
        fNewDibEng = TRUE;
    }

    //
    // see if the display supports DirectDraw
    //
    v = DCICOMMAND;
    v = Escape(hdc, QUERYESCSUPPORT, sizeof(int), (LPVOID)&v, NULL);

    if (v == 0 || v == 0x5250)
    {
        DPF("Init: display driver does not support DirectDraw");
        fDirectDrawDriver = FALSE;
    }
    else
    {
        if (LOBYTE(v) == 0xFF)
            v++;

        DPF("Init: display driver supports DirectDraw: %04X", v);
        fDirectDrawDriver = TRUE;
    }

    //
    // must be a windows 4.0 mini driver.
    //
    if (GetDeviceCaps(hdc, DRIVERVERSION) < 0x0400)
    {
        DPF("Init: not a 4.0 display driver");
        f = FALSE;
    }
    if (!(GetDeviceCaps(hdc, CAPS1) & C1_DIBENGINE))
    {
        DPF("Init: not a DIBENG display driver");
        f = FALSE;
    }
    if (!(GetDeviceCaps(hdc, CAPS1) & C1_REINIT_ABLE))
    {
        DPF("Init: does not support C1_REINIT_ABLE");
        f = FALSE;
    }
    ReleaseDC(NULL, hdc);

    return f;
}

//
// we hook the OEMControl entry point in the display driver while a
// mode change is happening.  GDI will issue a QUERYDIBSUPPORT escape
// right after the mode change happens so this is the first thing
// called after the mode changed worked.  USER also issues a
// MOUSETRAILS escape.
//
// we need this hook for two reasons...
//
// 1.   some display drivers are broken and dont set deFlags right
//      we fix up the deFlags, we fix up the flags for them.
//
// 2.   we rerealize all the gdi objects in this routine when
//      USER calls us, this way all the pen/brushs/text colors
//      are correct when user goes and rebuilds its bitmaps...
//
LONG FAR PASCAL _loadds Control(LPVOID lpDevice,UINT function,LPVOID lp_in_data,LPVOID lp_out_data)
{
    DIBENGINE FAR *pde = (DIBENGINE FAR *)lpDevice;
    LONG ret;

    Assert(bInOurSetMode);

#ifdef BABYSIT
    if (pde->deType == 0x5250)
    {
        if ((pde->deFlags & FIVE6FIVE) && pde->deBitsPixel != 16)
        {
            DPF("**BABYSIT** fixing FIVE6FIVE bit");
            pde->deFlags &= ~FIVE6FIVE;
        }

        if ((pde->deFlags & PALETTIZED) && pde->deBitsPixel != 8)
        {
            DPF("**BABYSIT** fixing PALETTIZED bit");
            pde->deFlags &= ~PALETTIZED;
        }

        if ((pde->deFlags & PALETTE_XLAT) && pde->deBitsPixel != 8)
        {
            DPF("**BABYSIT** fixing PALETTE_XLAT bit");
            pde->deFlags &= ~PALETTE_XLAT;
        }
    }
#endif

    //
    // this is USER calling from LW_OEMDependentInit()
    // force all GDI objects to be rerealized
    //
    if (function == MOUSETRAILS && bInOurSetMode != (BOOL)2)
    {
        //
        // fix up the magic colors before we rerealize the brushes
        // the "right" way to do this is to reset the UI colors
        // by calling SetSysColors() but we dont want to send
        // a sync WM_SYSCOLORCHANGE from here.
        //
        HDC hdc = GetDC(NULL);
        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            SetSystemPaletteUse(hdc, SYSPAL_STATIC);
            SetMagicColors(hdc, GetSysColor(COLOR_3DSHADOW) , 8);
            SetMagicColors(hdc, GetSysColor(COLOR_3DFACE)   , 9);
            SetMagicColors(hdc, GetSysColor(COLOR_3DHILIGHT), 246);
        }
        ReleaseDC(NULL, hdc);

        //
        //  re-realize all GDI objects for the new mode.
        //
        ReRealizeObjects();

        //
        // we should now convert any DIBSections that used to be DDBs back to DDBs
        // our code to find the right palette for a DDB is not too hot
        // so a lot of DDBs will have wrong colors.
        //
        ConvertBitmapsBack(FALSE);
    }

    PatchControl(FALSE);
    ret = DIBENG_Control(lpDevice,function,lp_in_data,lp_out_data);
    PatchControl(TRUE);

    return ret;
}

//
//  patch
//
void Patch(LPCSTR szMod, LPCSTR szProc, FARPROC PatchFunc, LPDWORD PatchSave, BOOL fPatch)
{
    LPDWORD pdw;
    FARPROC x;

    //
    //  ATM 2.5 has GetProcAddress patched to return some sort of
    //  thunk, that ends up totaly confusing us and we dont end up
    //  patching the DIBENG, we patch ATM's thunk.
    //
    //  so when we want to patch DIBENG!OEMControl we use the value we
    //  *linked* to, not the value GetProcAddress returns.
    //
    if (lstrcmpi(szMod, szDIBENG) == 0 && szProc == MAKEINTATOM(3))
        x = (FARPROC)DIBENG_Control;
    else
        x = GetProcAddress(GetModuleHandle(szMod), szProc);

    if (x == NULL || PatchFunc == NULL)
        return;

    GlobalReAlloc((HGLOBAL)SELECTOROF(x), 0, GMEM_MODIFY|GMEM_MOVEABLE);

    pdw = (LPDWORD)MAKELP(AllocCStoDSAlias(SELECTOROF(x)), OFFSETOF(x));

    if (fPatch)
    {
        DPF("Patching %s!%d %04X:%04X", szMod, OFFSETOF(szProc), SELECTOROF(x), OFFSETOF(x));
        if (PatchSave[0] == 0)
        {
            PatchSave[0] = pdw[0];
            PatchSave[1] = pdw[1];
        }
        *((LPBYTE)pdw)++ = 0xEA;   // JMP
        *pdw = (DWORD)PatchFunc;
    }
    else
    {
        DPF("UnPatching %s!%d %04X:%04X", szMod, OFFSETOF(szProc), SELECTOROF(x), OFFSETOF(x));
        if (PatchSave[0] != 0)
        {
            pdw[0] = PatchSave[0];
            pdw[1] = PatchSave[1];
            PatchSave[0] = 0;
            PatchSave[1] = 0;
        }
    }

    FreeSelector(SELECTOROF(pdw));
}

//
//  hook the DIBENGs OEMControl() entry point, to jump to our own code
//
void PatchControl(BOOL patch)
{
    static DWORD SaveBytes[2];
    Patch(szDIBENG, MAKEINTATOM(3), (FARPROC)Control, SaveBytes, patch);
}

//
//  patch a entry in the display driver to jump directly to the DIBENG
//
void PatchDisplay(int oem, BOOL patch)
{
    FARPROC p;

    #define MAX_DDI 35
    static DWORD PatchBytes[MAX_DDI*2];

    if (oem >= MAX_DDI)
        return;

    p = GetProcAddress(GetModuleHandle(szDIBENG), MAKEINTATOM(oem));

    Patch(szDISPLAY, MAKEINTATOM(oem), p, &PatchBytes[oem*2], patch);
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

#ifdef O95_HACK

static BOOL fOffice95Hack;
static char szDisplaySettings[] = "Display\\Settings";
static char szResolution[]      = "Resolution";
static char szDD[]              = "%d,%d";

//
// put back the right resolution into the registy key HKCC\Display\Settings
//
void Office95Hack()
{
    if (fOffice95Hack)
    {
        HKEY hkey;
        char ach[20];
        int  len;

        DPF("Office95 hack: restoring registry");

        if (RegOpenKey(HKEY_CURRENT_CONFIG, szDisplaySettings, &hkey) == 0)
        {
            len = wsprintf(ach, szDD, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
            RegSetValueEx(hkey, szResolution, NULL, REG_SZ, ach, len);
            RegCloseKey(hkey);
        }

        fOffice95Hack = FALSE;
    }
}

#endif

#ifdef SPI_HACK

BOOL FAR PASCAL _loadds SPI(UINT spi, UINT wParam, LPVOID lParam, UINT flags);

//
//  patch USERs SystemParametersInfo function
//
void PatchSPI(BOOL patch)
{
    static DWORD SaveBytes[2];
    Patch(szUSER, MAKEINTATOM(483), (FARPROC)SPI, SaveBytes, patch);
}

BOOL FAR PASCAL _loadds SPI(UINT spi, UINT wParam, LPVOID lParam, UINT flags)
{
    BOOL f;

    if (spi == SPI_SETWORKAREA)
    {
        if (lParam)
            DPF("Ignoring a SPI_SETWORKAREA [%d,%d,%d,%d] call", ((LPRECT)lParam)->left, ((LPRECT)lParam)->top, ((LPRECT)lParam)->right - ((LPRECT)lParam)->left, ((LPRECT)lParam)->bottom - ((LPRECT)lParam)->top);
        else
            DPF("Ignoring a SPI_SETWORKAREA lParam=NULL call");
        return 0;
    }

    PatchSPI(FALSE);
    f = SystemParametersInfo(spi, wParam, lParam, flags);
    PatchSPI(TRUE);
    return f;
}
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

//
// make the start menu not update in the background.
//
#define IDT_FAVOURITE  4
#define WNDCLASS_TRAYNOTIFY     "Shell_TrayWnd"

LRESULT CALLBACK _loadds TrayWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
#ifdef SPI_HACK
    PatchSPI(FALSE);
#endif
#ifdef O95_HACK
    Office95Hack();
#endif
    DPF("StartMenu hack: killing timer to refresh start menu");
    KillTimer(hwnd, IDT_FAVOURITE);
    return 0;
}

#ifdef SPI_HACK
RECT rcScreen;
RECT rcWork;
#endif

void PreStartMenuHack(DEVMODE FAR *pdm)
{
#ifdef SPI_HACK
    SetRect(&rcScreen, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    SystemParametersInfo(SPI_GETWORKAREA, 0, (LPVOID)&rcWork, 0);
#endif

#ifdef O95_HACK
    // make sure registry is put back
    Office95Hack();
#endif
}

void StartMenuHack(DEVMODE FAR *pdm)
{
    HWND hwndTray;
    BOOL fAppBar=FALSE;

    hwndTray = FindWindow(WNDCLASS_TRAYNOTIFY, NULL);

    if (hwndTray == NULL)
    {
        DPF("Cant find tray window");
        return;
    }

    // hack to get into the shells context, so we can clean up these hacks
    PostMessage(hwndTray, WM_TIMER, 0, (LONG)TrayWndProc);

#ifdef SPI_HACK
    {
        RECT rc;
        RECT rcTray;

        //
        //  see if there are any other app bars around.
        //
        GetWindowRect(hwndTray, &rcTray);
        SubtractRect(&rc, &rcScreen, &rcTray);

        DPF("rcScreen [%d,%d,%d,%d]", rcScreen.left, rcScreen.top, rcScreen.right-rcScreen.left,rcScreen.bottom-rcScreen.top);
        DPF("rcTray   [%d,%d,%d,%d]", rcTray.left, rcTray.top, rcTray.right-rcTray.left,rcTray.bottom-rcTray.top);
        DPF("rc       [%d,%d,%d,%d]", rc.left, rc.top, rc.right-rc.left,rc.bottom-rc.top);
        DPF("rcWork   [%d,%d,%d,%d]", rcWork.left, rcWork.top, rcWork.right-rcWork.left,rcWork.bottom-rcWork.top);

        if (!EqualRect(&rcScreen, &rcWork) && !EqualRect(&rc, &rcWork))
        {
            DPF("StartMenuHack: !!!!!there is a APP bar!!!!!!");
            fAppBar = TRUE;

            //
            // Patch the USER!SystemParameterInto function, so when the
            // shell does a SPI_SETWORKAREA call it will ignored
            // this prevents windows from being "sqished" to fit inside
            // the work area.
            //
            PatchSPI(TRUE);
        }
    }
#endif

#ifdef O95_HACK
    //
    //  the shell does the following...
    //
    //  read the HKEY_CURRENT_CONFIG\Display\Settings "Resloluton" key
    //  if this is LESS THAN the current display size, dont repark
    //  all the icons on the desktop because this is just a temporary
    //  mode set.
    //
    //  this sound right, except the bug happens when we are returning
    //  to the "normal" mode, the shell will repark the icons because
    //  it checks for LESS THEN, not LESS THAN OR EQUAL, normaly this
    //  is fine because the re-park does nothing.  when a app bar
    //  like Office95 is running it has not moved before the shell
    //  re-re-parks icons.
    //
    //  what this hack does it set the size stored in the registry
    //  to be real large so the shell does not park icons.
    //  later we will but the right values back.  we only need to
    //  do this if we are returning to the "normal" mode (ie pdm==NULL)
    //
    if (fAppBar && pdm == NULL)
    {
        HKEY hkey;
        char ach[20];
        int  len;

        fOffice95Hack = TRUE;

        if (RegOpenKey(HKEY_CURRENT_CONFIG, szDisplaySettings, &hkey) == 0)
        {
            len = wsprintf(ach, szDD, 30000, 30000);
            RegSetValueEx(hkey, szResolution, NULL, REG_SZ, ach, len);
            RegCloseKey(hkey);
        }
    }
    else
    {
        fOffice95Hack = FALSE;
    }
#endif
}

#ifdef BABYSIT

//
// force (or trick) the display driver into using a software cursor.
//
BOOL ForceSoftwareCursor(BOOL f)
{
    int n=0;

    //
    // get the mouse trails setting from USER
    //
    SystemParametersInfo(SPI_GETMOUSETRAILS, 0, (LPVOID)&n, 0);

    if (f)
    {
        //
        // enable mouse trails, this will cause the display driver to
        // turn off its hardware cursor
        //
        SystemParametersInfo(SPI_SETMOUSETRAILS, 2, NULL, 0);

        //
        // now tell the DIBENG to turn off mouse trails, the display driver
        // will think they are still on...
        //
        PatchDisplay(3, TRUE);          // route to DIBENG
        SystemParametersInfo(SPI_SETMOUSETRAILS, n, NULL, 0);
        PatchDisplay(3, FALSE);         // back to DISPLAY
    }
    else
    {
        SystemParametersInfo(SPI_SETMOUSETRAILS, n, NULL, 0);
    }

    return TRUE;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL IsMatrox()
{
    char ach[80];
    int len;

    GetModuleFileName(GetModuleHandle(szDISPLAY), ach, sizeof(ach));
    len = lstrlen(ach);
    return len >= 7 && lstrcmpi(ach+len-7, "mga.drv") == 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\ddraw16.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw16.h
 *  Content:	DirectDraw for Win95 16-bit header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   19-jun-95	craige	tweaks for DCI support
 *   03-jul-95	craige	stuff for bpp change
 *
 ***************************************************************************/

#ifndef __DDRAW16_INCLUDED__
#define __DDRAW16_INCLUDED__

#include <windows.h>
#include <print.h>
#include <toolhelp.h>
#include <string.h>
#include <stdlib.h>
#include "gdihelp.h"
#include "dibeng.inc"
#include "ver.h"

extern UINT 	wFlatSel;
extern LPVOID	pWin16Lock;

void SetSelLimit(UINT sel, DWORD limit);

extern LPVOID WINAPI GetWin16Lock(void);
extern void   WINAPI EnterSysLevel(LPVOID);
extern void   WINAPI LeaveSysLevel(LPVOID);

extern DWORD FAR PASCAL VFDQueryVersion( void );
extern  WORD FAR PASCAL VFDQuerySel( void );
extern DWORD FAR PASCAL VFDQuerySize( void );
extern DWORD FAR PASCAL VFDQueryBase( void );
extern DWORD FAR PASCAL VFDBeginLinearAccess( void );
extern DWORD FAR PASCAL VFDEndLinearAccess( void );
extern  void FAR PASCAL VFDReset( void );

extern LPVOID FAR PASCAL LocalAllocSecondary( WORD, WORD );
extern void FAR PASCAL LocalFreeSecondary( WORD );

#pragma warning( disable: 4704)

#define WIN95

typedef BOOL FAR *LPBOOL;
typedef struct _LARGE_INTEGER
{
    DWORD LowPart;
    LONG HighPart;
} LARGE_INTEGER;
typedef struct _ULARGE_INTEGER
{
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER;

#define NO_D3D
#define NO_DDHELP
#include "ddrawpr.h"
#include "modex.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\dibpatch.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dibpatch.c
 *  Content:	Code to patch the DIB engine to correct problems with using
 *              the VRAM bit to disable the video card's accelerator.
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   13-Sep-96	colinmc	initial implementation
 *   31-jan-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddraw16.h"

extern UINT FAR PASCAL AllocCStoDSAlias(UINT);

#define DIBENGMODULE          "DIBENG"
#define EXTTEXTOUTENTRYPOINT  "DIB_EXTTEXTOUTEXT"
#define EXTTEXTOUTPATCHOFFSET 136

char szExtTextOutMagic[] = "\x74\x0a\xf7\x86\x60\xff\x00\x80";
char szExtTextOutPatch[] = "\x90\x90\x90\x90\x90\x90\x90\x90";

LPVOID GetModifiableCodeAddress(LPCSTR lpszModuleName, LPCSTR lpszEntryPointName)
{
    HMODULE hModule;
    FARPROC fpEntryPoint;
    LPVOID  lpCodeAddress;

    hModule = GetModuleHandle(lpszModuleName);
    if (NULL == hModule)
    {
        DPF(0, "DIB Engine not loaded");
        return NULL;
    }

    fpEntryPoint = GetProcAddress(hModule, lpszEntryPointName);
    if (NULL == fpEntryPoint)
    {
        DPF(0, "Could not locate DIB engine's ExtTextOut entry point");
        return FALSE;
    }

    lpCodeAddress = (LPVOID)MAKELP(AllocCStoDSAlias(SELECTOROF(fpEntryPoint)), OFFSETOF(fpEntryPoint));
    if (NULL == lpCodeAddress)
    {
        DPF(0, "Could not allocate data segment alias for code segment");
        return FALSE;
    }

    return lpCodeAddress;
}

#define FREEMODIFIABLECODEADDRESS(lpCodeAddress) FreeSelector(SELECTOROF(lpCodeAddress))

BOOL ValidateDIBEngine(void)
{
    LPBYTE lpCodeAddress;
    LPBYTE lpMagicAddress;
    BOOL   fDIBEngineOK;

    /*
     * Get a pointer to the ExtTextOut code.
     */
    lpCodeAddress = (LPBYTE)GetModifiableCodeAddress(DIBENGMODULE, EXTTEXTOUTENTRYPOINT);
    if (NULL == lpCodeAddress)
        return FALSE;

    /*
     * Move to the patch address.
     */
    lpMagicAddress = lpCodeAddress + EXTTEXTOUTPATCHOFFSET;

    /*
     * Verify that the data at the patch address is the stuff we want to replace.
     */
    fDIBEngineOK = (!_fmemcmp(lpMagicAddress, szExtTextOutMagic, sizeof(szExtTextOutMagic) - 1));
    if (!fDIBEngineOK)
    {
	/*
	 * Couldn't find the signature bytes we are looking for. This might be because we
	 * already patched it. So check for the no-ops.
	 */
	fDIBEngineOK = (!_fmemcmp(lpMagicAddress, szExtTextOutPatch, sizeof(szExtTextOutPatch) - 1));
    }

    #ifdef DEBUG
        if (!fDIBEngineOK)
            DPF(2, "DIB Engine does not match magic or patch - different version?");
    #endif

    FREEMODIFIABLECODEADDRESS(lpMagicAddress);

    return fDIBEngineOK;
}

BOOL PatchDIBEngineExtTextOut(BOOL fPatch)
{
    LPBYTE lpCodeAddress;
    LPBYTE lpMagicAddress;

    /*
     * Get a pointer to the ExtTextOut code.
     */
    lpCodeAddress = (LPBYTE)GetModifiableCodeAddress(DIBENGMODULE, EXTTEXTOUTENTRYPOINT);
    if (NULL == lpCodeAddress)
        return FALSE;

    /*
     * Move to the patch address.
     */
    lpMagicAddress = lpCodeAddress + EXTTEXTOUTPATCHOFFSET;

    if (fPatch)
    {
	/*
	 * Don't do anything if its already patched.
	 */
	if (_fmemcmp(lpMagicAddress, szExtTextOutPatch, sizeof(szExtTextOutPatch) - 1))
	{
	    /*
	     * Be very sure we know we are dealing with a DIB engine we can handle.
	     */
	    if (_fmemcmp(lpMagicAddress, szExtTextOutMagic, sizeof(szExtTextOutMagic) - 1))
	    {
		DPF(1, "Unknown DIB Engine. not fixing up");
		FREEMODIFIABLECODEADDRESS(lpMagicAddress);
		return FALSE;
	    }

	    /*
	     * Replace the offending code with NOPs.
	     */
	    _fmemcpy(lpMagicAddress, szExtTextOutPatch, sizeof(szExtTextOutPatch) - 1);
	}
    }
    else
    {
	/*
	 * Don't do anything if its already unpatched.
	 */
	if (!_fmemcmp(lpMagicAddress, szExtTextOutMagic, sizeof(szExtTextOutMagic) - 1))
	{
	    /*
	     * Be very sure we know we are dealing with a DIB engine we can handle.
	     */
	    if (_fmemcmp(lpMagicAddress, szExtTextOutPatch, sizeof(szExtTextOutPatch) - 1))
	    {
		DPF(1, "Unknown DIB Engine. not fixing up");
		FREEMODIFIABLECODEADDRESS(lpMagicAddress);
		return FALSE;
	    }

	    /*
	     * Put the original code back.
	     */
	    _fmemcpy(lpMagicAddress, szExtTextOutMagic, sizeof(szExtTextOutMagic) - 1);
	}
    }

    FREEMODIFIABLECODEADDRESS(lpMagicAddress);

    return TRUE;
}

BOOL DDAPI DD16_FixupDIBEngine(void)
{
    /*
     * Is this Win 4.1 (or higher)
     */
    OSVERSIONINFO ver = {sizeof(OSVERSIONINFO)};
    GetVersionEx(&ver);

    if (ver.dwMajorVersion > 4 ||
        (ver.dwMajorVersion == 4 && ver.dwMinorVersion >= 10))
    {
        return TRUE;
    }

    /*
     * Is this a DIB engine version we can work with?
     */
    if( !ValidateDIBEngine() )
	return FALSE;

    /*
     * It is the correct version. So fix it up. Currently all this
     * involves is patching the ExtTextOut routine.
     */
    return PatchDIBEngineExtTextOut(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\ddraw16.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddraw16.c
 *  Content:	16-bit DirectDraw entry points
 *		This is only used for 16-bit display drivers on Win95
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   13-feb-95	craige	allow 32-bit callbacks
 *   14-may-95	craige	removed obsolete junk
 *   19-jun-95	craige	more cleanup; added DDHAL_StreamingNotify
 *   02-jul-95	craige	comment out streaming notify stuff
 *   07-jul-95	craige	validate pdevice
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   05-sep-95	craige	bug 814: added DD16_IsWin95MiniDriver
 *   02-mar-96  colinmc Repulsive hack to keep interim drivers working
 *   16-apr-96  colinmc Bug 17921: remove interim driver support
 *   06-oct-96  colinmc Bug 4207: Invalid LocalFree in video port stuff
 *   15-oct-96  colinmc Bug 4353: Failure to initialize VideoPort fields
 *                      in convert
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddraw16.h"

typedef struct DRIVERINFO
{
    struct DRIVERINFO		  FAR *link;
    DDHALINFO			  ddHalInfo;
    DDHAL_DDCALLBACKS		  tmpDDCallbacks;
    DDHAL_DDSURFACECALLBACKS	  tmpDDSurfaceCallbacks;
    DDHAL_DDPALETTECALLBACKS	  tmpDDPaletteCallbacks;
    DDHAL_DDVIDEOPORTCALLBACKS	  tmpDDVideoPortCallbacks;
    DDHAL_DDCOLORCONTROLCALLBACKS tmpDDColorControlCallbacks;
    DWORD			  dwEvent;
} DRIVERINFO, FAR *LPDRIVERINFO;

extern __cdecl SetWin32Event( DWORD );
void convertV1DDHALINFO( LPDDHALINFO_V1 lpddOld, LPDDHALINFO lpddNew );

BOOL		bInOurSetMode;
LPDRIVERINFO	lpDriverInfo;


/*
 * freeDriverInfo
 */
void freeDriverInfo( LPDRIVERINFO pgi )
{
    if( pgi->ddHalInfo.lpdwFourCC != NULL )
    {
	LocalFreeSecondary( OFFSETOF(pgi->ddHalInfo.lpdwFourCC ) );
	pgi->ddHalInfo.lpdwFourCC = NULL;
    }
    if( pgi->ddHalInfo.lpModeInfo != NULL )
    {
	LocalFreeSecondary( OFFSETOF( pgi->ddHalInfo.lpModeInfo ) );
	pgi->ddHalInfo.lpModeInfo = NULL;
    }
    if( pgi->ddHalInfo.vmiData.pvmList != NULL )
    {
	LocalFreeSecondary( OFFSETOF( pgi->ddHalInfo.vmiData.pvmList ) );
	pgi->ddHalInfo.vmiData.pvmList = NULL;
    }
} /* freeDriverInfo */

/*
 * DDHAL_SetInfo
 *
 * Create a Driver object.   Called by the display driver
 */
BOOL DDAPI DDHAL_SetInfo(
	LPDDHALINFO lpDrvDDHALInfo,
	BOOL reset )
{
    LPDDHAL_DDCALLBACKS		drvcb;
    LPDDHAL_DDSURFACECALLBACKS	surfcb;
    LPDDHAL_DDPALETTECALLBACKS	palcb;
    DWORD			bit;
    LPVOID			cbrtn;
    LPVOID			ptr;
    int				numcb;
    int				i;
    UINT			size;
    LPDRIVERINFO		pgi;
    static char			szPath[ MAX_PATH ];
    LPDDHALINFO			lpDDHALInfo;
    DDHALINFO			ddNew;

    if( !VALIDEX_DDHALINFO_PTR( lpDrvDDHALInfo ) )
    {
	#ifdef DEBUG
	    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid DDHALINFO provided" );
	    DPF( 0, "lpDDHalInfo = %08lx", lpDrvDDHALInfo );
	    if( !IsBadWritePtr( lpDrvDDHALInfo, 1 ) )
	    {
                DPF( 0, "lpDDHalInfo->dwSize = %ld (%ld expected)",
                                lpDrvDDHALInfo->dwSize, (DWORD)sizeof( DDHALINFO ) );
	    }
	#endif
	return FALSE;
    }

    DPF(5, "lpDrvDDHALInfo->dwSize = %ld", lpDrvDDHALInfo->dwSize);
    /*
     * Check to see if the driver gave us an old DDHALINFO
     */
    if( lpDrvDDHALInfo->dwSize == DDHALINFOSIZE_V1 )
    {
	/*
	 * We actually changed the ordering of some fields from V1
	 * to V2 so we need to do some conversion to get it into
	 * shape.
	 */
	convertV1DDHALINFO((LPDDHALINFO_V1)lpDrvDDHALInfo, &ddNew);
	// use the reformatted ddhalinfo
	lpDDHALInfo = &ddNew;
    }
    else if( lpDrvDDHALInfo->dwSize < sizeof(DDHALINFO) )
    {
	/*
	 * Its a newer version than V1 but not as new as this
	 * version of DirectDraw. No ordering changes have taken
	 * place but the HAL info is too small. We need to ensure
	 * that the all the new fields are zeroed.
	 *
	 * NOTE: Validation above should have taken care of the
	 * error case where the size is less than the size of the
	 * V1 HAL info.
	 */
	_fmemset(&ddNew, 0, sizeof(ddNew));
	_fmemcpy(&ddNew, lpDrvDDHALInfo, (size_t)lpDrvDDHALInfo->dwSize);
	lpDDHALInfo = &ddNew;
    }
    else
    {
	// the driver gave us a current ddhalinfo, use it.
	lpDDHALInfo = lpDrvDDHALInfo;
    }

    /*
     * check for hInstance
     */
    if( lpDDHALInfo->hInstance == 0 )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:lpDDHalInfo->hInstance is NULL " );
	return FALSE;
    }

    /*
     * validate 16-bit driver callbacks
     */
    drvcb = lpDDHALInfo->lpDDCallbacks;
    if( !VALIDEX_PTR_PTR( drvcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid driver callback ptr" );
	return FALSE;
    }
    DPF(5, "lpDDCallbacks->dwSize = %ld", drvcb->dwSize);
    if( !VALIDEX_DDCALLBACKSSIZE( drvcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid size field in lpDDCallbacks" );
	return FALSE;
    }
    numcb =(int) (drvcb->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID );
    bit = 1;
    for( i=0;i<numcb;i++ )
    {
	if( !(drvcb->dwFlags & bit) )
	{
	    cbrtn = (LPVOID) ((DWORD FAR *) &drvcb->DestroyDriver)[i];
	    if( cbrtn != NULL )
	    {
		if( !VALIDEX_CODE_PTR( cbrtn ) )
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid 16-bit callback in lpDDCallbacks" );
		    return FALSE;
		}
	    }
	}
	bit <<= 1;
    }

    /*
     * validate 16-bit surface callbacks
     */
    surfcb = lpDDHALInfo->lpDDSurfaceCallbacks;
    if( !VALIDEX_PTR_PTR( surfcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid surface callback ptr" );
	return FALSE;
    }
    DPF(5, "lpDDSurfaceCallbacks->dwSize = %ld", surfcb->dwSize);
    if( !VALIDEX_DDSURFACECALLBACKSSIZE( surfcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid size field in lpDDSurfaceCallbacks" );
	return FALSE;
    }
    numcb =(int)(surfcb->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID );
    bit = 1;
    for( i=0;i<numcb;i++ )
    {
	if( !(surfcb->dwFlags & bit) )
	{
	    cbrtn = (LPVOID) ((DWORD FAR *) &surfcb->DestroySurface)[i];
	    if( cbrtn != NULL )
	    {
		if( !VALIDEX_CODE_PTR( cbrtn ) )
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid 16-bit callback in lpSurfaceCallbacks" );
		    return FALSE;
		}
	    }
	}
	bit <<= 1;
    }

    /*
     * validate 16-bit palette callbacks
     */
    palcb = lpDDHALInfo->lpDDPaletteCallbacks;
    if( !VALIDEX_PTR_PTR( palcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid palette callback ptr" );
	return FALSE;
    }
    DPF(5, "lpDDPaletteCallbacks->dwSize = %ld", palcb->dwSize);
    if( !VALIDEX_DDPALETTECALLBACKSSIZE( palcb ) )
    {
	DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid size field in lpPaletteCallbacks" );
	return FALSE;
    }
    numcb =(int)(palcb->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID );
    bit = 1;
    for( i=0;i<numcb;i++ )
    {
	if( !(palcb->dwFlags & bit) )
	{
	    cbrtn = (LPVOID) ((DWORD FAR *) &palcb->DestroyPalette)[i];
	    if( cbrtn != NULL )
	    {
		if( !VALIDEX_CODE_PTR( cbrtn ) )
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid 16-bit callback in lpPaletteCallbacks" );
		    return FALSE;
		}
	    }
	}
	bit <<= 1;
    }
    /*
     * check pdevice
     */
    if( lpDDHALInfo->lpPDevice != NULL )
    {
	if( !VALIDEX_PTR( lpDDHALInfo->lpPDevice, sizeof( DIBENGINE ) ) )
	{
	    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid PDEVICE ptr" );
	    return FALSE;
	}
    }

    /*
     * see if we have a driver info struct already
     */
    pgi = lpDriverInfo;
    while( pgi != NULL )
    {
	if( pgi->ddHalInfo.hInstance == lpDDHALInfo->hInstance )
	{
	    break;
	}
	pgi = pgi->link;
    }

    if( pgi == NULL )
    {
	pgi = (LPVOID) (void NEAR *)LocalAlloc( LPTR, sizeof( DRIVERINFO ) );
	if( OFFSETOF( pgi ) == NULL )
	{
	    DPF( 0, "Out of memory!" );
	    return FALSE;
	}
	pgi->link = lpDriverInfo;
	lpDriverInfo = pgi;
    }

    DPF( 5, "hInstance = %08lx (%08lx)", pgi->ddHalInfo.hInstance, lpDDHALInfo->hInstance );

    /*
     * duplicate the hal info
     */
    freeDriverInfo( pgi );

    _fmemcpy( &pgi->ddHalInfo, lpDDHALInfo, sizeof( DDHALINFO ) );
    if( lpDDHALInfo->lpDDCallbacks != NULL )
    {
	_fmemcpy( &pgi->tmpDDCallbacks, lpDDHALInfo->lpDDCallbacks, sizeof( pgi->tmpDDCallbacks ) );
	pgi->ddHalInfo.lpDDCallbacks = &pgi->tmpDDCallbacks;
    }
    if( lpDDHALInfo->lpDDSurfaceCallbacks != NULL )
    {
	_fmemcpy( &pgi->tmpDDSurfaceCallbacks, lpDDHALInfo->lpDDSurfaceCallbacks, sizeof( pgi->tmpDDSurfaceCallbacks ) );
	pgi->ddHalInfo.lpDDSurfaceCallbacks = &pgi->tmpDDSurfaceCallbacks;
    }
    if( lpDDHALInfo->lpDDPaletteCallbacks != NULL )
    {
	_fmemcpy( &pgi->tmpDDPaletteCallbacks, lpDDHALInfo->lpDDPaletteCallbacks, sizeof( pgi->tmpDDPaletteCallbacks ) );
	pgi->ddHalInfo.lpDDPaletteCallbacks = &pgi->tmpDDPaletteCallbacks;
    }
    if( lpDDHALInfo->lpdwFourCC != NULL )
    {
	size = (UINT) lpDDHALInfo->ddCaps.dwNumFourCCCodes * sizeof( DWORD );
	if( size != 0 )
	{
	    ptr = (LPVOID) LocalAllocSecondary( LPTR, size );
	}
	else
	{
	    ptr = NULL;
	}
	pgi->ddHalInfo.lpdwFourCC = ptr;
	if( ptr != NULL )
	{
	    _fmemcpy( pgi->ddHalInfo.lpdwFourCC, lpDDHALInfo->lpdwFourCC, size );
	}
    }
    if( lpDDHALInfo->lpModeInfo != NULL )
    {
	size = (UINT) lpDDHALInfo->dwNumModes * sizeof( DDHALMODEINFO );
	if( size != 0 )
	{
	    ptr = (LPVOID) LocalAllocSecondary( LPTR, size );
	}
	else
	{
	    ptr = NULL;
	}
	pgi->ddHalInfo.lpModeInfo = ptr;
	if( ptr != NULL )
	{
	    _fmemcpy( pgi->ddHalInfo.lpModeInfo, lpDDHALInfo->lpModeInfo, size );
	}
    }
    if( lpDDHALInfo->vmiData.pvmList != NULL )
    {
	size = (UINT) lpDDHALInfo->vmiData.dwNumHeaps * sizeof( VIDMEM );
	if( size != 0 )
	{
	    ptr = (LPVOID) LocalAllocSecondary( LPTR, size );
	}
	else
	{
	    ptr = NULL;
	}
	pgi->ddHalInfo.vmiData.pvmList = ptr;
	if( ptr != NULL )
	{
	    _fmemcpy( pgi->ddHalInfo.vmiData.pvmList, lpDDHALInfo->vmiData.pvmList, size );
	}
    }

    /*
     * get the driver version info
     */
    pgi->ddHalInfo.ddCaps.dwReserved1 = 0;
    pgi->ddHalInfo.ddCaps.dwReserved2 = 0;
    if( GetModuleFileName( (HINSTANCE) lpDDHALInfo->hInstance, szPath, sizeof( szPath ) ) )
    {
	int	size;
	DWORD	dumbdword;
	size = (int) GetFileVersionInfoSize( szPath, (LPDWORD) &dumbdword );
	if( size != 0 )
	{
	    LPVOID	vinfo;

	    vinfo = (LPVOID) (void NEAR *) LocalAlloc( LPTR, size );
	    if( OFFSETOF( vinfo ) != NULL )
	    {
		if( GetFileVersionInfo( szPath, 0, size, vinfo ) )
		{
		    VS_FIXEDFILEINFO 	FAR *ver=NULL;
		    int			cb;

		    if( VerQueryValue(vinfo, "\\", &(LPVOID)ver, &cb) )
		    {
			if( ver != NULL )
			{
			    pgi->ddHalInfo.ddCaps.dwReserved1 = ver->dwFileVersionLS;
			    pgi->ddHalInfo.ddCaps.dwReserved2 = ver->dwFileVersionMS;
			}
		    }
		}
		LocalFree( OFFSETOF( vinfo ) );
	    }
	}
    }

    if( !bInOurSetMode && reset )
    {
	DPF( 4, "************************* EXTERNAL MODE SET ************************" );
	if( pgi->dwEvent != NULL )
	{
	    SetWin32Event( pgi->dwEvent );
	}
    }

    return TRUE;

} /* DDHAL_SetInfo */

/*
 * DDHAL_VidMemAlloc
 */
FLATPTR DDAPI DDHAL_VidMemAlloc(
		LPDDRAWI_DIRECTDRAW_GBL lpDD,
		int heap,
		DWORD dwWidth,
		DWORD dwHeight )
{
    extern FLATPTR DDAPI DDHAL32_VidMemAlloc( LPDDRAWI_DIRECTDRAW_GBL this, int heap, DWORD dwWidth, DWORD dwHeight );

    if( lpDD != NULL )
    {
	return DDHAL32_VidMemAlloc( lpDD, heap, dwWidth,dwHeight );
    }
    else
    {
	return 0;
    }

} /* DDHAL_VidMemAlloc */

/*
 * DDHAL_VidMemFree
 */
void DDAPI DDHAL_VidMemFree(
		LPDDRAWI_DIRECTDRAW_GBL lpDD,
		int heap,
		FLATPTR fpMem )
{
    extern void DDAPI DDHAL32_VidMemFree( LPDDRAWI_DIRECTDRAW_GBL this, int heap, FLATPTR ptr );
    if( lpDD != NULL )
    {
	DDHAL32_VidMemFree( lpDD, heap, fpMem );
    }

} /* DDHAL_VidMemFree */

/*
 * DD16_GetDriverFns
 */
void DDAPI DD16_GetDriverFns( LPDDHALDDRAWFNS pfns )
{
    pfns->dwSize = sizeof( DDHALDDRAWFNS );
    pfns->lpSetInfo = DDHAL_SetInfo;
    pfns->lpVidMemAlloc = DDHAL_VidMemAlloc;
    pfns->lpVidMemFree = DDHAL_VidMemFree;

} /* DD16_GetDriverFns */

/*
 * DD16_GetHALInfo
 */
void DDAPI DD16_GetHALInfo( LPDDHALINFO pddhi )
{
    LPDRIVERINFO		pgi;

    pgi = lpDriverInfo;
    while( pgi != NULL )
    {
	if( pgi->ddHalInfo.hInstance == pddhi->hInstance )
	{
	    break;
	}
	pgi = pgi->link;
    }
    if( pgi == NULL )
    {
	return;
    }
    DPF( 4, "GetHalInfo: lpHalInfo->GetDriverInfo = %lx", pgi->ddHalInfo.GetDriverInfo);

    DPF( 5, "GetHalInfo: lpHalInfo=%08lx", &pgi->ddHalInfo );
    DPF( 5, "GetHalInfo: pddhi=%08lx", pddhi );

    _fmemcpy( pddhi, &pgi->ddHalInfo, sizeof( DDHALINFO ) );

} /* DD16_GetHALInfo */

/*
 * DD16_DoneDriver
 */
void DDAPI DD16_DoneDriver( DWORD hInstance )
{
    LPDRIVERINFO	pgi;
    LPDRIVERINFO	prev;

    prev = NULL;
    pgi = lpDriverInfo;
    while( pgi != NULL )
    {
	if( pgi->ddHalInfo.hInstance == hInstance )
	{
	    break;
	}
        prev = pgi;
	pgi = pgi->link;
    }
    if( pgi == NULL )
    {
	DPF( 0, "COULD NOT FIND HINSTANCE=%08lx", hInstance );
	return;
    }
    if( prev == NULL )
    {
	lpDriverInfo = pgi->link;
    }
    else
    {
	prev->link = pgi->link;
    }
    DPF( 5, "Freeing %08lx, hInstance=%08lx", pgi, hInstance );
    freeDriverInfo( pgi );
    LocalFree( OFFSETOF( pgi ) );

} /* DD16_DoneDriver */

/*
 * DD16_SetEventHandle
 */
void DDAPI DD16_SetEventHandle( DWORD hInstance, DWORD dwEvent )
{
    LPDRIVERINFO	pgi;

    pgi = lpDriverInfo;
    while( pgi != NULL )
    {
	if( pgi->ddHalInfo.hInstance == hInstance )
	{
	    break;
	}
	pgi = pgi->link;
    }
    if( pgi == NULL )
    {
	DPF( 0, "COULD NOT FIND HINSTANCE=%08lx", hInstance );
	return;
    }
    pgi->dwEvent = dwEvent;
    DPF( 5, "Got event handle: %08lx\n", dwEvent );

} /* DD16_SetEventHandle */

/*
 * DD16_IsWin95MiniDriver
 */
BOOL DDAPI DD16_IsWin95MiniDriver( void )
{
    DIBENGINE 		FAR *pde;
    HDC			hdc;
    UINT		rc;

    hdc = GetDC(NULL);
    rc = GetDeviceCaps(hdc, CAPS1);
    pde = GetPDevice(hdc);
    ReleaseDC(NULL, hdc);

    if( !(rc & C1_DIBENGINE) || IsBadReadPtr(pde, 2) ||
    	pde->deType != 0x5250 )
    {
	#ifdef DEBUG
	    if( !(rc & C1_DIBENGINE) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Driver is not a DibEngine driver" );
	    }
	    if( IsBadReadPtr(pde, 2) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not obtain pdevice!" );
	    }
	    else if( pde->deType != 0x5250 )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Pdevice signature invalid" );
	    }
	#endif
	return FALSE;
    }
    return TRUE;

} /* DD16_IsWin95MiniDriver */

#ifdef STREAMING
/*
 * DDHAL_StreamingNotify
 */
void DDAPI DDHAL_StreamingNotify( DWORD dw )
{
    extern void DDAPI DD32_StreamingNotify( DWORD dw );
    DD32_StreamingNotify( dw );

} /* DDHAL_StreamingNotify */
#endif

/*
 * convertV1DDHALINFO
 *
 * Convert an obsolete DDHALINFO structure to the latest and greatest structure.
 */
void convertV1DDHALINFO( LPDDHALINFO_V1 lpddOld, LPDDHALINFO lpddNew )
{
    int		i;

    lpddNew->dwSize = sizeof( DDHALINFO );
    lpddNew->lpDDCallbacks = lpddOld->lpDDCallbacks;
    lpddNew->lpDDSurfaceCallbacks = lpddOld->lpDDSurfaceCallbacks;
    lpddNew->lpDDPaletteCallbacks = lpddOld->lpDDPaletteCallbacks;
    lpddNew->vmiData = lpddOld->vmiData;

    // ddCaps
    lpddNew->ddCaps.dwSize = lpddOld->ddCaps.dwSize;
    lpddNew->ddCaps.dwCaps = lpddOld->ddCaps.dwCaps;
    lpddNew->ddCaps.dwCaps2 = lpddOld->ddCaps.dwCaps2;
    lpddNew->ddCaps.dwCKeyCaps = lpddOld->ddCaps.dwCKeyCaps;
    lpddNew->ddCaps.dwFXCaps = lpddOld->ddCaps.dwFXCaps;
    lpddNew->ddCaps.dwFXAlphaCaps = lpddOld->ddCaps.dwFXAlphaCaps;
    lpddNew->ddCaps.dwPalCaps = lpddOld->ddCaps.dwPalCaps;
    lpddNew->ddCaps.dwSVCaps = lpddOld->ddCaps.dwSVCaps;
    lpddNew->ddCaps.dwAlphaBltConstBitDepths = lpddOld->ddCaps.dwAlphaBltConstBitDepths;
    lpddNew->ddCaps.dwAlphaBltPixelBitDepths = lpddOld->ddCaps.dwAlphaBltPixelBitDepths;
    lpddNew->ddCaps.dwAlphaBltSurfaceBitDepths = lpddOld->ddCaps.dwAlphaBltSurfaceBitDepths;
    lpddNew->ddCaps.dwAlphaOverlayConstBitDepths = lpddOld->ddCaps.dwAlphaOverlayConstBitDepths;
    lpddNew->ddCaps.dwAlphaOverlayPixelBitDepths = lpddOld->ddCaps.dwAlphaOverlayPixelBitDepths;
    lpddNew->ddCaps.dwAlphaOverlaySurfaceBitDepths = lpddOld->ddCaps.dwAlphaOverlaySurfaceBitDepths;
    lpddNew->ddCaps.dwZBufferBitDepths = lpddOld->ddCaps.dwZBufferBitDepths;
    lpddNew->ddCaps.dwVidMemTotal = lpddOld->ddCaps.dwVidMemTotal;
    lpddNew->ddCaps.dwVidMemFree = lpddOld->ddCaps.dwVidMemFree;
    lpddNew->ddCaps.dwMaxVisibleOverlays = lpddOld->ddCaps.dwMaxVisibleOverlays;
    lpddNew->ddCaps.dwCurrVisibleOverlays = lpddOld->ddCaps.dwCurrVisibleOverlays;
    lpddNew->ddCaps.dwNumFourCCCodes = lpddOld->ddCaps.dwNumFourCCCodes;
    lpddNew->ddCaps.dwAlignBoundarySrc = lpddOld->ddCaps.dwAlignBoundarySrc;
    lpddNew->ddCaps.dwAlignSizeSrc = lpddOld->ddCaps.dwAlignSizeSrc;
    lpddNew->ddCaps.dwAlignBoundaryDest = lpddOld->ddCaps.dwAlignBoundaryDest;
    lpddNew->ddCaps.dwAlignSizeDest = lpddOld->ddCaps.dwAlignSizeDest;
    lpddNew->ddCaps.dwAlignStrideAlign = lpddOld->ddCaps.dwAlignStrideAlign;
    lpddNew->ddCaps.ddsCaps = lpddOld->ddCaps.ddsCaps;
    lpddNew->ddCaps.dwMinOverlayStretch = lpddOld->ddCaps.dwMinOverlayStretch;
    lpddNew->ddCaps.dwMaxOverlayStretch = lpddOld->ddCaps.dwMaxOverlayStretch;
    lpddNew->ddCaps.dwMinLiveVideoStretch = lpddOld->ddCaps.dwMinLiveVideoStretch;
    lpddNew->ddCaps.dwMaxLiveVideoStretch = lpddOld->ddCaps.dwMaxLiveVideoStretch;
    lpddNew->ddCaps.dwMinHwCodecStretch = lpddOld->ddCaps.dwMinHwCodecStretch;
    lpddNew->ddCaps.dwMaxHwCodecStretch = lpddOld->ddCaps.dwMaxHwCodecStretch;
    lpddNew->ddCaps.dwSVBCaps = 0;
    lpddNew->ddCaps.dwSVBCKeyCaps = 0;
    lpddNew->ddCaps.dwSVBFXCaps = 0;
    lpddNew->ddCaps.dwVSBCaps = 0;
    lpddNew->ddCaps.dwVSBCKeyCaps = 0;
    lpddNew->ddCaps.dwVSBFXCaps = 0;
    lpddNew->ddCaps.dwSSBCaps = 0;
    lpddNew->ddCaps.dwSSBCKeyCaps = 0;
    lpddNew->ddCaps.dwSSBFXCaps = 0;
    lpddNew->ddCaps.dwReserved1 = lpddOld->ddCaps.dwReserved1;
    lpddNew->ddCaps.dwReserved2 = lpddOld->ddCaps.dwReserved2;
    lpddNew->ddCaps.dwReserved3 = lpddOld->ddCaps.dwReserved3;
    lpddNew->ddCaps.dwMaxVideoPorts = 0;
    lpddNew->ddCaps.dwCurrVideoPorts = 0;
    lpddNew->ddCaps.dwSVBCaps2 = 0;
    for(i=0; i<DD_ROP_SPACE; i++)
    {
	lpddNew->ddCaps.dwRops[i] = lpddOld->ddCaps.dwRops[i];
	lpddNew->ddCaps.dwSVBRops[i] = 0;
	lpddNew->ddCaps.dwVSBRops[i] = 0;
	lpddNew->ddCaps.dwSSBRops[i] = 0;
    }

    lpddNew->dwMonitorFrequency = lpddOld->dwMonitorFrequency;
    lpddNew->GetDriverInfo = NULL; // was unused hWndListBox in v1
    lpddNew->dwModeIndex = lpddOld->dwModeIndex;
    lpddNew->lpdwFourCC = lpddOld->lpdwFourCC;
    lpddNew->dwNumModes = lpddOld->dwNumModes;
    lpddNew->lpModeInfo = lpddOld->lpModeInfo;
    lpddNew->dwFlags = lpddOld->dwFlags;
    lpddNew->lpPDevice = lpddOld->lpPDevice;
    lpddNew->hInstance = lpddOld->hInstance;

    lpddNew->lpD3DGlobalDriverData = 0;
    lpddNew->lpD3DHALCallbacks = 0;
    lpddNew->lpDDExeBufCallbacks = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\gdihelp.c ===
/*----------------------------------------------------------------------------*\
 *  GDIHELP.C  - GDI TOOLHELP
 *
 *  a bunch of GDI utility functions that are usefull for walking
 *  all GDI objects and dinking with them.
 *
 *  ToddLa
 *
\*----------------------------------------------------------------------------*/

#ifdef IS_16
#define DIRECT_DRAW
#endif

#ifdef DIRECT_DRAW
#include "ddraw16.h"
#else
#include <windows.h>
#include "gdihelp.h"
#include "dibeng.inc"
#ifdef DEBUG
#include <toolhelp.h>
#endif
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
#undef DPF
#ifdef DEBUG
static void CDECL DPF(char *sz, ...)
{
    char ach[128];
    lstrcpy(ach,"QuickRes: ");
    wvsprintf(ach+10, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(2, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}
static void NEAR PASCAL __Assert(char *exp, char *file, int line)
{
    DPF("Assert(%s) failed at %s line %d.", (LPSTR)exp, (LPSTR)file, line);
    DebugBreak();
}
#define Assert(exp)  ( (exp) ? (void)0 : __Assert(#exp,__FILE__,__LINE__) )

#else
#define Assert(f)
#define DPF ; / ## /
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

extern     HMODULE WINAPI GetExePtr(HANDLE h);
extern     HANDLE  WINAPI SetObjectOwner(HGDIOBJ, HANDLE);
extern     BOOL    WINAPI MakeObjectPrivate(HANDLE hObj, BOOL bPrivate);
extern     int     WINAPI GDISelectPalette(HDC, HPALETTE, BOOL);

#define PresDC(hdc) GetSystemPaletteUse(hdc)

void SaveDCFix(HGDIOBJ h, LPARAM lParam);
void SaveDCReSelectObjects(HGDIOBJ h, LPARAM lParam);
void ReRealizeObject(HGDIOBJ h, LPARAM lParam);
void ReSelectObjects(HGDIOBJ h, LPARAM lParam);

typedef struct {
    BITMAPINFOHEADER bi;
    DWORD            ct[16];
}   DIB4;

typedef struct {
    BITMAPINFOHEADER bi;
    DWORD            ct[256];
}   DIB8;

typedef struct {
    HGDIOBJ h;
    UINT    type;
}   GDIOBJECT, NEAR *GDIOBJECTLIST;

GDIOBJECTLIST GdiObjectList;

WORD GetW(HGDIOBJ h, UINT off);
WORD SetW(HGDIOBJ h, UINT off, WORD w);

/*----------------------------------------------------------------------------*\
 * StockBitmap
 * return the stock 1x1x1 bitmap, windows should have a GetStockObject for
 * this but it does not.
\*----------------------------------------------------------------------------*/

HBITMAP StockBitmap()
{
    HBITMAP hbm = CreateBitmap(0,0,1,1,NULL);
    SetObjectOwner(hbm, 0);
    return hbm;
}

/*----------------------------------------------------------------------------*\
 * SafeSelectObject
 *
 * call SelectObject, but make sure USER does not RIP because we are using
 * a DC without calling GetDC.
\*----------------------------------------------------------------------------*/

HGDIOBJ SafeSelectObject(HDC hdc, HGDIOBJ h)
{
    UINT hf;

    // this prevents USER from RIPing because we are using
    // DCs in the cache without calling GetDC()
    hf = SetHookFlags(hdc, DCHF_VALIDATEVISRGN);
    h = SelectObject(hdc, h);
    SetHookFlags(hdc, hf);

    return h;
}

/*----------------------------------------------------------------------------*\
 * IsMemoryDC
 *
 * return TRUE if the passed DC is a memory DC.  we do this seeing if we
 * can select the stock bitmap into it.
\*----------------------------------------------------------------------------*/

BOOL IsMemoryDC(HDC hdc)
{
    HBITMAP hbm;

    if (hbm = (HBITMAP)SafeSelectObject(hdc, StockBitmap()))
        SafeSelectObject(hdc, hbm);

    return hbm != NULL;
}

/*----------------------------------------------------------------------------*\
 * IsScreenDC
 *
 * return TRUE for a non-memory DC
\*----------------------------------------------------------------------------*/

BOOL IsScreenDC(HDC hdc)
{
    return (!IsMemoryDC(hdc) && GetDeviceCaps(hdc, TECHNOLOGY) == DT_RASDISPLAY);
}

/*----------------------------------------------------------------------------*\
 * GetObjectOwner
 * return the owner of a GDI object
\*----------------------------------------------------------------------------*/

HANDLE GetObjectOwner(HGDIOBJ h)
{
    HANDLE owner;
    owner = SetObjectOwner(h, 0);
    SetObjectOwner(h, owner);
    return owner;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL IsObjectPrivate(HGDIOBJ h)
{
    BOOL IsPrivate;
    IsPrivate = MakeObjectPrivate(h, 0);
    MakeObjectPrivate(h, IsPrivate);
    return IsPrivate;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL IsObjectStock(HGDIOBJ h)
{
    int n;

    for (n=0; n<=17; n++)
        if (GetStockObject(n) == h)
            return TRUE;

    if (StockBitmap() == h)
        return TRUE;

    return FALSE;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
#pragma optimize("", off)
UINT GetGdiDS()
{
    UINT result;

    IsGDIObject((HGDIOBJ)1);
    _asm mov ax,es
    _asm mov result,ax
#ifdef DEBUG
    {
    SYSHEAPINFO shi = {sizeof(shi)};
    SystemHeapInfo(&shi);
    Assert((UINT)shi.hGDISegment == result);
    }
#endif
    return result;
}
#pragma optimize("", on)

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

GDIOBJECTLIST BuildGdiObjectList(void)
{
    int i;
    int count;
    GDIOBJECTLIST list;
    UINT type;
    UINT hgdi = GetGdiDS();

#ifdef DEBUG
    UINT ObjHist[OBJ_MAX+1];
    for (i=0; i<=OBJ_MAX; i++) ObjHist[i] = 0;
#endif

    DPF("BEGIN BuildGdiObjectList...");

    i=0;
    count=0;
    list=NULL;
again:
    {
        WORD FAR *pw;
        UINT cnt;
        HANDLE h;

        // get pointer to local heap info (stored at offset 6 in DGROUP)
        pw  = MAKELP(hgdi, 6);
        pw  = MAKELP(hgdi, *pw);

        // get pointer to first handle table (stored at offset 0x14 in HeapInfo)
        pw  = MAKELP(hgdi, pw[0x14/2]);

        //
        // a handle table starts with a WORD count of entries, followed
        // by the entries (each is a DWORD) last WORD is a pointer to
        // the next handle table or 0.
        //
        // each handle entry is a WORD ptr, followed by flags (WORD)
        // the HIBYTE of the flags is realy the lock count.
        // if the flags are 0xFFFF the handle is free.
        // for the GDI heap if 0x10 is set in the flags the
        // handle is a GDI object handle.
        //
        while (OFFSETOF(pw) != 0)
        {
            cnt = *pw++;        // get handle table count

            while (cnt-- > 0)
            {
                h = (HANDLE)OFFSETOF(pw);

                // is the handle free? yes skip
                if (pw[1] != 0xFFFF)
                {
                    // is the handle a GDI object?
                    if (pw[1] & 0x0010)
                    {
                        type = (UINT)IsGDIObject(h);

                        if (type)
                        {
                            if (list)
                            {
                                Assert(i >= 0 && i < count);
                                list[i].h    = (HGDIOBJ)h;
                                list[i].type = type;
                                i++;
                            }
                            else
                            {
                                count++;
#ifdef DEBUG
                                Assert(type > 0 && type <= OBJ_MAX);
                                ObjHist[type]++;
#endif
                            }
                        }
                    }
                    // not a gdi object, might be a SaveDC
                    else
                    {
                        if ((UINT)IsGDIObject(h) == OBJ_DC)
                        {
                            if (list)
                            {
                                Assert(i >= 0 && i < count);
                                list[i].h    = (HGDIOBJ)h;
                                list[i].type = OBJ_SAVEDC;
                                i++;
                            }
                            else
                            {
                                count++;
#ifdef DEBUG
                                ObjHist[OBJ_SAVEDC]++;
#endif
                            }
                        }
                    }
                }

                pw += 2;    // next handle
            }

            // get next handle table.
            pw = MAKELP(hgdi,*pw);
        }
    }

    if (list == NULL)
    {
        list = (GDIOBJECTLIST)LocalAlloc(LPTR, sizeof(GDIOBJECT) * (count+1));

        if (list == NULL)
        {
            Assert(0);
            return NULL;
        }

        goto again;
    }

    Assert(i == count);
    list[i].h    = NULL;   // NULL terminate list
    list[i].type = 0;      // NULL terminate list

    DPF("END BuildGdiObjectList %d objects.", count);
    DPF("    DC:     %d", ObjHist[OBJ_DC]);
    DPF("    SaveDC: %d", ObjHist[OBJ_SAVEDC]);
    DPF("    Bitmap: %d", ObjHist[OBJ_BITMAP]);
    DPF("    Pen:    %d", ObjHist[OBJ_PEN]);
    DPF("    Palette:%d", ObjHist[OBJ_PALETTE]);
    DPF("    Brush:  %d", ObjHist[OBJ_BRUSH]);
    DPF("    Total:  %d", count);

    return list;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

BOOL BeginGdiSnapshot(void)
{
    if (GdiObjectList != NULL)
        return TRUE;

    GdiObjectList = BuildGdiObjectList();

    return GdiObjectList != NULL;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

void EndGdiSnapshot(void)
{
    if (GdiObjectList != NULL)
    {
        LocalFree((HLOCAL)GdiObjectList);
        GdiObjectList = NULL;
    }
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

void EnumGdiObjects(UINT type, EnumGdiObjectsCallback callback, LPARAM lParam)
{
    int i;

    Assert(GdiObjectList != NULL);

    if (GdiObjectList == NULL)
        return;

    for (i=0; GdiObjectList[i].h; i++)
    {
        if (GdiObjectList[i].type == type)
        {
            (*callback)(GdiObjectList[i].h, lParam);
        }
    }
}

#ifdef DEBUG
/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

LPCSTR GetObjectOwnerName(HGDIOBJ hgdi)
{
    int i;
    HMODULE hModule;
    HANDLE h = GetObjectOwner(hgdi);
    static char ach[80];

    if (h == 0)
        return "System";
    else if (h == (HANDLE)1)
        return "Orphan";
    else if (hModule = (HMODULE)GetExePtr(h))
    {
        GetModuleFileName(hModule, ach, sizeof(ach));
        for (i=lstrlen(ach); i>0 && ach[i-1]!='\\'; i--)
            ;
        return ach+i;
    }
    else
    {
        wsprintf(ach, "#%04X", h);
        return ach;
    }
}
#endif

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HBITMAP CurrentBitmap(HDC hdc)
{
    HBITMAP hbm;
    if (hbm = SafeSelectObject(hdc, StockBitmap()))
        SafeSelectObject(hdc, hbm);
    return hbm;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HBRUSH CurrentBrush(HDC hdc)
{
    HBRUSH hbr;
    if (hbr = SafeSelectObject(hdc, GetStockObject(BLACK_BRUSH)))
        SafeSelectObject(hdc, hbr);
    return hbr;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HPEN CurrentPen(HDC hdc)
{
    HPEN pen;
    if (pen = SafeSelectObject(hdc, GetStockObject(BLACK_PEN)))
        SafeSelectObject(hdc, pen);
    return pen;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HPALETTE CurrentPalette(HDC hdc)
{
    HPALETTE hpal;
    if (hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE))
        SelectPalette(hdc, hpal, FALSE);
    return hpal;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

HDC GetBitmapDC(HBITMAP hbm)
{
    int i;
    HDC hdc;
    HBITMAP hbmT;

    Assert(GdiObjectList != NULL);

    hdc = CreateCompatibleDC(NULL);
    hbmT = SelectObject(hdc, hbm);
    DeleteDC(hdc);

    //
    // if we can select this bitmap into a memDC, it is not selected.
    // into any other DC
    //
    if (hbmT != NULL)
        return NULL;

    if (GdiObjectList == NULL)
        return NULL;

    for (i=0; GdiObjectList[i].h; i++)
    {
        if (GdiObjectList[i].type == OBJ_DC)
        {
            if (CurrentBitmap((HDC)GdiObjectList[i].h) == hbm)
                return GdiObjectList[i].h;
        }
    }

    return NULL;
}

/*----------------------------------------------------------------------------*\
 * GetObjectPalette
\*----------------------------------------------------------------------------*/

HPALETTE GetObjectPalette(HGDIOBJ h)
{
    HANDLE owner = GetObjectOwner(h);
    HPALETTE hpal;
    HPALETTE hpal20=NULL;
    HPALETTE hpal256=NULL;
    HPALETTE hpalDef = GetStockObject(DEFAULT_PALETTE);
    int i;
    int count20;
    int count256;

    Assert(GdiObjectList != NULL);

    //
    // look at all the palettes owned by the app
    // mabey if we are lucky there will only be one.
    //
    for (i=count20=count256=0; GdiObjectList[i].h; i++)
    {
        if (GdiObjectList[i].type == OBJ_PALETTE)
        {
            hpal=(HPALETTE)GdiObjectList[i].h;

            if (hpal == hpalDef)
                continue;

            if (GetObjectOwner(hpal) == owner)
            {
                int n = 0;
                GetObject(hpal, sizeof(n), &n);

                if (n > 20)
                {
                    count256++;
                    hpal256 = hpal;
                }
                else
                {
                    count20++;
                    hpal20 = hpal;
                }
            }
        }
    }

    if (count256 == 1)
    {
        DPF("got palette (%04X) because app (%s) only has one palette", hpal256, GetObjectOwnerName(h));
        return hpal256;
    }

    if (count256 == 2 && count20 == 0)
    {
        DPF("got palette (%04X) because app (%s) only has two palettes", hpal256, GetObjectOwnerName(h));
        return hpal256;
    }

    if (count20 == 1 && count256 == 0)
    {
        DPF("got palette (%04X) because app (%s) only has one palette", hpal20, GetObjectOwnerName(h));
        return hpal20;
    }

    if (count20 == 0 && count256 == 0)
    {
        DPF("no palette for (%04X) because app (%s) has none.", h, GetObjectOwnerName(h));
        return GetStockObject(DEFAULT_PALETTE);
    }

    DPF("**** cant find palette for (%04X) ****", h);
    return NULL;
}

/*----------------------------------------------------------------------------*\
 * GetBitmapPalette
 *
 * try to find out the palette that the given DDB uses, this is done be a series
 * of hacks and it only works some of the time.
 *
\*----------------------------------------------------------------------------*/

HPALETTE GetBitmapPalette(HBITMAP hbm)
{
    BITMAP      bm;
    DWORD       dw;
    HDC         hdc;
    HPALETTE    hpal;
    HPALETTE    hpalClip=NULL;
    HBITMAP     hbmClip=NULL;

    Assert(GdiObjectList != NULL);

    //
    // get the bitmap info, if it is not a bitmap palette is NULL
    //
    if (GetObject(hbm, sizeof(bm), &bm) == 0)
        return NULL;

    //
    // DIBSections dont have or need palettes
    //
    if (bm.bmBits != NULL)
        return NULL;

    //
    // 8 bit DDBs are the only bitmaps that care about palettes
    //
    if (bm.bmBitsPixel != 8 || bm.bmPlanes != 1)
        return NULL;

    //
    //  with a new DIBENG it will give us the palette
    //  in the bitmap dimension, what a hack
    //
    dw = GetBitmapDimension(hbm);

    if (dw && IsGDIObject((HGDIOBJ)HIWORD(dw)) == OBJ_PALETTE &&
        HIWORD(dw) != (UINT)GetStockObject(DEFAULT_PALETTE))
    {
        DPF("got palette (%04X) from the DIBENG", HIWORD(dw), hbm);
        return (HPALETTE)HIWORD(dw);
    }

    //
    // if the bitmap is on the clipboard we know what palette to use
    //
    if (IsClipboardFormatAvailable(CF_PALETTE))
    {
        if (OpenClipboard(NULL))
        {
            hpalClip = GetClipboardData(CF_PALETTE);
            hbmClip = GetClipboardData(CF_BITMAP);
            CloseClipboard();
	}

        if (hbm == hbmClip)
        {
            DPF("got palette (%04X) from the clipboard", hpalClip);
            return hpalClip;
        }
    }

    //
    // try to find a palette by looking at palettes owned by the app.
    //
    hpal = GetObjectPalette(hbm);

    //
    // we can figure out the palette of the app, return it
    //
    if (hpal)
    {
        if (hpal == GetStockObject(DEFAULT_PALETTE))
            return NULL;
        else
            return hpal;
    }

    //
    // if the bitmap is selected into a memoryDC check to see if
    // the memoryDC has a palette.
    //
    if ((hdc = GetBitmapDC(hbm)) && (hpal = CurrentPalette(hdc)))
    {
        if (hpal != GetStockObject(DEFAULT_PALETTE))
        {
            DPF("got palette (%04X) from memDC (%04X)", hpal, hdc);
            return hpal;
        }
    }

    DPF("**** cant find palette for bitmap (%04X) ****", hbm);
    return NULL;
}

/*----------------------------------------------------------------------------*\
 * ConvertDDBtoDS
 *
 * converts a DDB to a DIBSection
 * the conversion is done in place so the handle does not change.
\*----------------------------------------------------------------------------*/

HBITMAP ConvertDDBtoDS(HBITMAP hbm)
{
    BITMAP bm;
    HBITMAP hbmT;
    HDC hdc;
    HDC hdcSel;
    HPALETTE hpal;
    LPVOID lpBits;
    HANDLE owner;
    BOOL IsPrivate;
    int i;
    DWORD size;
    DIB8 dib;
    UINT SelCount;
    DWORD dw;

    if (GetObject(hbm, sizeof(bm), &bm) == 0)
        return NULL;

    if (bm.bmBits)
        return NULL;

    if (bm.bmPlanes == 1 && bm.bmBitsPixel == 1)
        return NULL;

    dw = GetBitmapDimension(hbm);

    owner = GetObjectOwner(hbm);

//  if (owner == 0)
//      return NULL;

    hpal = GetBitmapPalette(hbm);

    hdc = GetDC(NULL);

    if (hpal)
    {
        SelectPalette(hdc, hpal, TRUE);
        RealizePalette(hdc);
    }

    dib.bi.biSize = sizeof(BITMAPINFOHEADER);
    dib.bi.biBitCount = 0;
    GetDIBits(hdc, hbm, 0, 1, NULL, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS);
    GetDIBits(hdc, hbm, 0, 1, NULL, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS);

    dib.bi.biXPelsPerMeter = 0x42424242;    // special flag marking a DDB
    dib.bi.biHeight = -bm.bmHeight;         // top-down DIB

    if (hpal)
        SelectPalette(hdc, (HPALETTE)GetStockObject(DEFAULT_PALETTE), TRUE);

    // we dont have a palette, best guess is the system palette
    if (hpal == NULL && (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        DPF("Converting DDB(%04X) to DS for %s (using syspal)", hbm, GetObjectOwnerName(hbm));
        GetSystemPaletteEntries(hdc, 0, 256, (LPPALETTEENTRY)dib.ct);
        for (i=0; i<256; i++)
            dib.ct[i] = RGB(GetBValue(dib.ct[i]), GetGValue(dib.ct[i]), GetRValue(dib.ct[i]));
    }
    else if (hpal)
    {
        DPF("Converting DDB(%04X) to DS for %s, using palette (%04X)", hbm, GetObjectOwnerName(hbm), hpal);
    }
    else
    {
        DPF("Converting DDB(%04X) to DS for %s", hbm, GetObjectOwnerName(hbm));
    }

    ReleaseDC(NULL, hdc);

    size = (DWORD)bm.bmWidthBytes * bm.bmHeight;
    lpBits = GlobalAllocPtr(GHND, size);
    Assert(lpBits != NULL);

    if (lpBits == NULL)
        return NULL;

    GetBitmapBits(hbm, size, lpBits);

    IsPrivate = MakeObjectPrivate(hbm, FALSE);

    hdcSel = GetBitmapDC(hbm);

    if (hdcSel)
        SelectObject(hdcSel, StockBitmap());

    SelCount = GetW(hbm, 16);

    if (SelCount != 0)
    {
        DPF("***** bitmap %04X select count is %d, must be in a SaveDC block!", hbm, SelCount);
        SetW(hbm, 16, 0);
    }

    DeleteBitmap(hbm);

    if (IsGDIObject(hbm))
    {
        DPF("***** UNABLE TO DELETE bitmap %04X *****", hbm);
        Assert(0);
    }
    else
    {
        hbmT = CreateDIBSection(NULL, (LPBITMAPINFO)&dib.bi, DIB_RGB_COLORS, NULL, NULL, 0);
        Assert(hbmT == hbm);
        SetBitmapBits(hbm, size, lpBits);
    }
    GlobalFreePtr(lpBits);

    if (SelCount)
        SetW(hbm, 16, SelCount);

    SetObjectOwner(hbm, owner);
    MakeObjectPrivate(hbm, IsPrivate);

    if (hdcSel)
        SelectObject(hdcSel, hbm);

    SetBitmapDimension(hbm, LOWORD(dw), HIWORD(dw));

    return hbm;
}

/*----------------------------------------------------------------------------*\
 * Convert DStoDDB
 *
 * convert a DIBSection back to a DDB, we only do this if the DIBSection
 * came from a DDB (ConvertDDBtoDS puts a magic value in biXPelsPerMeter)
 * the conversion is done in place so the handle does not change.
\*----------------------------------------------------------------------------*/

HBITMAP ConvertDStoDDB(HBITMAP hbm, BOOL fForceConvert)
{
    struct {
        BITMAP bm;
        BITMAPINFOHEADER bi;
        DWORD ct[256];
    }   ds;
    HDC hdcSel;
    HDC hdc;
    HBITMAP hbmT;
    HANDLE owner;
    BOOL IsPrivate;
    LPVOID lpBits;
    DWORD size;
    int planes,bpp,rc;
    UINT SelCount;
    DWORD dw;

    hdc = GetDC(NULL);
    bpp = GetDeviceCaps(hdc, BITSPIXEL);
    planes = GetDeviceCaps(hdc, PLANES);
    rc = GetDeviceCaps(hdc, RASTERCAPS);
    ReleaseDC(NULL, hdc);

    if (GetObject(hbm, sizeof(ds), &ds) == 0)
        return NULL;

    if (ds.bm.bmBits == NULL)
        return NULL;

    if (ds.bm.bmBitsPixel == 1)
	return NULL;

    if (ds.bi.biXPelsPerMeter != 0x42424242)
        return NULL;

    if (ds.bi.biHeight >= 0)
        return NULL;

    //
    //	HACK we want to convert bitmaps that are exactly 8x8
    //	back to DDBs always. Win95 GDI does not support
    //	Creating a pattern brush from a DIBSection so
    //	we must do this.
    //
    if (ds.bm.bmWidth == 8 && ds.bm.bmHeight == 8)
    {
	DPF("Converting 8x8 DS(%04X) back to DDB for %s", hbm, GetObjectOwnerName(hbm));
	fForceConvert = TRUE;
    }

    //
    // unless force convert is TRUE we only want to be here in 8bpp mode.
    //
    if (!fForceConvert && !(rc & RC_PALETTE))
	return NULL;

    if (!fForceConvert && (ds.bm.bmPlanes != planes || ds.bm.bmBitsPixel != bpp))
	return NULL;

    dw = GetBitmapDimension(hbm);

    owner = GetObjectOwner(hbm);

//  if (owner == 0)
//      return NULL;

    DPF("Converting DS(%04X) %dx%dx%d to DDB for %s", hbm, ds.bm.bmWidth, ds.bm.bmHeight, ds.bm.bmBitsPixel, GetObjectOwnerName(hbm));

    hdcSel = GetBitmapDC(hbm);

    size = (DWORD)ds.bm.bmWidthBytes * ds.bm.bmHeight;
    lpBits = GlobalAllocPtr(GHND, size);
    Assert(lpBits != NULL);

    if (lpBits == NULL)
        return NULL;

    IsPrivate = MakeObjectPrivate(hbm, FALSE);

    if (hdcSel)
        SelectObject(hdcSel, StockBitmap());

    hdc = GetDC(NULL);

    if (ds.bm.bmPlanes == planes && ds.bm.bmBitsPixel == bpp)
        GetBitmapBits(hbm, size, lpBits);
    else
        GetDIBits(hdc, hbm, 0, ds.bm.bmHeight, lpBits, (LPBITMAPINFO)&ds.bi, DIB_RGB_COLORS);

    SelCount = GetW(hbm, 16);

    if (SelCount != 0)
    {
        DPF("bitmap %04X select count is %d, must be in a SaveDC block!", hbm, SelCount);
        SetW(hbm, 16, 0);
    }

    DeleteBitmap(hbm);
    if (IsGDIObject(hbm))
    {
        DPF("***** UNABLE TO DELETE bitmap %04X *****", hbm);
        Assert(0);
    }
    else
    {
        hbmT = CreateCompatibleBitmap(hdc,ds.bm.bmWidth,ds.bm.bmHeight);
        Assert(hbmT == hbm);

        if (ds.bm.bmPlanes == planes && ds.bm.bmBitsPixel == bpp)
            SetBitmapBits(hbm, size, lpBits);
        else
            SetDIBits(hdc, hbm, 0, ds.bm.bmHeight, lpBits, (LPBITMAPINFO)&ds.bi, DIB_RGB_COLORS);
    }
    ReleaseDC(NULL, hdc);

    GlobalFreePtr(lpBits);

    if (SelCount)
        SetW(hbm, 16, SelCount);

    SetObjectOwner(hbm, owner);
    MakeObjectPrivate(hbm, IsPrivate);

    if (hdcSel)
        SelectObject(hdcSel, hbm);

    SetBitmapDimension(hbm, LOWORD(dw), HIWORD(dw));

    return hbm;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void FlushGdiXlatCache()
{
    DIB8    dib;
    HDC     hdc;
    HBITMAP hbm;

    if (hbm = CreateBitmap(1,1,1,1,NULL))
    {
        if (hdc = CreateCompatibleDC(NULL))
        {
            SelectBitmap(hdc, hbm);

            dib.bi.biSize           = sizeof(BITMAPINFOHEADER);
            dib.bi.biWidth          = 1;
            dib.bi.biHeight         = 1;
            dib.bi.biPlanes         = 1;
            dib.bi.biCompression    = 0;
            dib.bi.biSizeImage      = 0;
            dib.bi.biXPelsPerMeter  = 0;
            dib.bi.biYPelsPerMeter  = 0;
            dib.bi.biClrUsed        = 2;
            dib.bi.biClrImportant   = 0;
            dib.ct[0]               = RGB(1,1,1);
            dib.ct[2]               = RGB(2,2,2);

            for (dib.bi.biBitCount  = 1;
                 dib.bi.biBitCount <= 8;
                 dib.bi.biBitCount  = (dib.bi.biBitCount + 4) & ~1)
            {
                SetDIBits(hdc, hbm, 0, 1, (LPVOID)&dib.bi,
                    (LPBITMAPINFO)&dib.bi, DIB_PAL_COLORS);
            }

            DeleteDC(hdc);
        }

        DeleteBitmap(hbm);
    }
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void ReSelectObjects(HGDIOBJ h, LPARAM lParam)
{
    COLORREF rgb;
    UINT hf;
    HDC hdc = (HDC)h;

////DPF("ReSelecting objects for DC %04X", h);

    // this prevents USER from RIPing because we are using
    // DCs in the cache without calling GetDC()
    hf = SetHookFlags(hdc, DCHF_VALIDATEVISRGN);

    SelectObject(hdc, SelectObject(hdc, GetStockObject(BLACK_BRUSH)));
    SelectObject(hdc, SelectObject(hdc, GetStockObject(BLACK_PEN)));
    GDISelectPalette(hdc, GDISelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE), TRUE);

    rgb = GetTextColor(hdc);
    SetTextColor(hdc, rgb ^ 0xFFFFFF);
    SetTextColor(hdc, rgb);

    rgb = GetBkColor(hdc);
    SetBkColor(hdc, rgb ^ 0xFFFFFF);
    SetBkColor(hdc, rgb);

    SetHookFlags(hdc, hf);
}

/////////////////////////////////////////////////////////////////////////////
//
// ReRealizeObjects
//
// calls ReRealizeObject for every pen/brush in the system, this makes sure
// all pens/brushs will be rerealized next time they are used.
//
// call ReSelectObjects() to make sure the current pen/brush/text colors
// are correct in all DCs
//
/////////////////////////////////////////////////////////////////////////////

void ReRealizeObjects()
{
    BeginGdiSnapshot();

    FlushGdiXlatCache();

    EnumGdiObjects(OBJ_BRUSH, ReRealizeObject, 0);
    EnumGdiObjects(OBJ_PEN,   ReRealizeObject, 0);
    EnumGdiObjects(OBJ_DC,    ReSelectObjects, 0);

    EnumGdiObjects(OBJ_SAVEDC,SaveDCFix, 0);
    EnumGdiObjects(OBJ_SAVEDC,SaveDCReSelectObjects, 0);

    EndGdiSnapshot();
}

/////////////////////////////////////////////////////////////////////////////
//
// ConvertObjects
//
// convert all DDBs to DIBSections
// convert all color pattern brush's to DIBPattern brushs
// convert all 8bpp icons to 4bpp icons.
//
/////////////////////////////////////////////////////////////////////////////

void ConvertBitmapCB(HGDIOBJ h, LPARAM lParam)
{
    ConvertDDBtoDS(h);
}

void ConvertBrushCB(HGDIOBJ h, LPARAM lParam)
{
    ConvertPatternBrush(h);
}

void ConvertObjects()
{
    BeginGdiSnapshot();
    EnumGdiObjects(OBJ_BITMAP, ConvertBitmapCB, 0);
    EnumGdiObjects(OBJ_BRUSH,  ConvertBrushCB, 0);
    EndGdiSnapshot();
}

/////////////////////////////////////////////////////////////////////////////
//
// ConvertBitmapsBack
//
// convert all DIBSections to DDBs
//
/////////////////////////////////////////////////////////////////////////////

void ConvertBitmapBackCB(HGDIOBJ h, LPARAM lParam)
{
    ConvertDStoDDB(h, (BOOL)lParam);
}

void ConvertBitmapsBack(BOOL fForceConvert)
{
    BeginGdiSnapshot();
    EnumGdiObjects(OBJ_BITMAP, ConvertBitmapBackCB, fForceConvert);
    EndGdiSnapshot();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// BEGIN EVIL
//
// the next few functions mess directly with GDI code/data
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

LPWORD LockObj(HGDIOBJ h, UINT off)
{
    WORD FAR *pw;
    UINT hGDI = GetGdiDS();

    pw = MAKELP(hGDI, h);

    if (IsBadReadPtr(pw, 2))
        return NULL;

    pw = MAKELP(hGDI, *pw + off);

    if (IsBadReadPtr(pw, 2))
        return NULL;

    return pw;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

WORD GetW(HGDIOBJ h, UINT off)
{
    WORD FAR *pw;

    if (pw = LockObj(h, off))
        return *pw;
    else
        return 0;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

WORD SetW(HGDIOBJ h, UINT off, WORD w)
{
    WORD FAR *pw;
    WORD ret = 0;

    if (pw = LockObj(h, off))
    {
        ret = *pw;
        *pw = w;
    }
    return ret;
}

/*----------------------------------------------------------------------------*\
 * ReRealizeObject
 *
 * delete all physical objects associated with the given GDI object
 * this will guarentee the next time the brush/pen is selected we will
 * have the device driver rerealize the object.
 *
 * there are a few ways to do this....
 *
 * method #1
 *     call SetSolidBrush()
 *     this only works for private/solid(not stock) brushes, not pens
 *     we need to save/restore the stock object bit.
 *     we need to save/restore the private bit.
 *
 * method #2
 *     delete the object and recreate it getting the same handle
 *     we need to patch the SelCount because we cant delete a selected obj
 *     we need to save/restore the stock object bit.
 *     we need to save/restore the private bit.
 *     we need to save/restore the owner.
 *
 * method #3
 *     create a temp object, move the physchain from the given object
 *     to the new object, delete the temp object.
 *     we need to patch phys chain of the objects.
 *
 * after deleting all the physical objects ReSelectObjects() should be
 * called to clean up all the objects currently selected in all DCs
 *
 * SaveDCs are a pain in the neck, ReSelectObjects() does not deal with
 * the SaveDC blocks floating around GDIs heap. we need to fix this
 * in the general case, the system savedc's just have the white_brush
 * and black_pen.
 *
 * currently using method #3
 *
\*----------------------------------------------------------------------------*/

void ReRealizeObject(HGDIOBJ h, LPARAM lParam)
{
    HGDIOBJ hTemp;
    UINT type;

    type = IsGDIObject(h);

    //
    // if the object does not have a physchain we have no work to do!
    //
    if (GetW(h, 0) == 0)
        return;

    //
    // create a temp pen/brush so we can delete it and trick
    // GDI into disposing all the phys objects.
    //

    if (type == OBJ_BRUSH)
        hTemp = CreateSolidBrush(RGB(1,1,1));
    else if (type == OBJ_PEN)
        hTemp = CreatePen(PS_SOLID, 0, RGB(1,1,1));
    else
        return;

    Assert(hTemp != NULL);
    Assert(GetW(hTemp, 0) == 0);

    if (type == OBJ_BRUSH)
        DPF("ReRealize Brush %04X for %s", h, GetObjectOwnerName(h));
    else
        DPF("ReRealize Pen %04X for %s", h, GetObjectOwnerName(h));

    //
    // copy the phys chain from the passed in object to the
    // temp object then call DeleteObject to free them.
    //
    SetW(hTemp, 0, GetW(h, 0));
    SetW(h, 0, 0);

    DeleteObject(hTemp);
    return;
}

/*----------------------------------------------------------------------------*\
 * ConvertPatternBrush
 *
 * convert a BS_PATTERN brush to a BS_DIBPATTERN brush.
 * we only convert non-mono pattern brushes
\*----------------------------------------------------------------------------*/

HBRUSH ConvertPatternBrush(HBRUSH hbr)
{
    LOGBRUSH lb;
    HBITMAP hbm;
    COLORREF c0, c1;
    HDC hdc;

    if (GetObject(hbr, sizeof(lb), &lb) == 0)
        return NULL;

    if (lb.lbStyle != BS_PATTERN)
        return NULL;

    hdc = GetDC(NULL);
    hbm = CreateCompatibleBitmap(hdc, 8, 8);
    ReleaseDC(NULL, hdc);

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);
    SelectObject(hdc, hbr);

    SetTextColor(hdc, 0x000000);
    SetBkColor(hdc, 0x000000);
    PatBlt(hdc, 0, 0, 8, 8, PATCOPY);
    c0 = GetPixel(hdc, 0, 0);

    SetTextColor(hdc, 0xFFFFFF);
    SetBkColor(hdc, 0xFFFFFF);
    PatBlt(hdc, 0, 0, 8, 8, PATCOPY);
    c1 = GetPixel(hdc, 0, 0);

    //
    // if the brush is a mono pattern brush dont convert it
    //
    if (c0 == c1)
    {
        HANDLE h;
        LPBITMAPINFOHEADER lpbi;
        HBRUSH hbrT;
        HANDLE owner;
        BOOL IsPrivate;
        WORD Flags;
        HPALETTE hpal=NULL;

        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            hpal = GetObjectPalette(hbr);

            if (hpal == GetStockObject(DEFAULT_PALETTE))
                hpal = NULL;
        }

        if (hpal)
        {
            SelectPalette(hdc, hpal, TRUE);
            RealizePalette(hdc);
            PatBlt(hdc, 0, 0, 8, 8, PATCOPY);

            DPF("Converting pattern brush %04X for %s (using hpal=%04X)", hbr, GetObjectOwnerName(hbr), hpal);
        }
        else
        {
            DPF("Converting pattern brush %04X for %s", hbr, GetObjectOwnerName(hbr));
        }

        h = GlobalAlloc(GHND, sizeof(BITMAPINFOHEADER) + 256*4 + 8*8*4);

        Assert(h != NULL);
        if (h == NULL)
            return hbr;

        lpbi = (LPBITMAPINFOHEADER)GlobalLock(h);

        lpbi->biSize = sizeof(BITMAPINFOHEADER);
        lpbi->biBitCount = 0;
        GetDIBits(hdc, hbm, 0, 1, NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

        if (lpbi->biClrUsed == 0 && lpbi->biCompression == BI_BITFIELDS)
            lpbi->biClrUsed = 3;

        if (lpbi->biClrUsed == 0 && lpbi->biBitCount <= 8)
            lpbi->biClrUsed = (1 << lpbi->biBitCount);

        GetDIBits(hdc, hbm, 0, (int)lpbi->biHeight,
            (LPBYTE)lpbi + lpbi->biSize + lpbi->biClrUsed*sizeof(RGBQUAD),
            (LPBITMAPINFO)lpbi, DIB_RGB_COLORS);

        owner = SetObjectOwner(hbr, 0);
        IsPrivate = MakeObjectPrivate(hbr, FALSE);
        Flags = SetW(hbr, 10, 0);

        DeleteObject(hbr);

        if (IsGDIObject(hbr))
        {
            DPF("***** UNABLE TO DELETE brush %04X *****", hbr);
            Assert(0);
        }
        else
        {
            hbrT = CreateDIBPatternBrush(h, DIB_RGB_COLORS);
            Assert(hbrT == hbr);
        }

        GlobalFree(h);

        SetW(hbr, 10, Flags);
        MakeObjectPrivate(hbr, IsPrivate);
        SetObjectOwner(hbr, owner);

        if (hpal)
        {
            SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), TRUE);
        }
    }

    DeleteDC(hdc);
    DeleteObject(hbm);
    return hbr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPVOID GetPDevice(HDC hdc)
{
    DWORD FAR *pdw;

    Assert(IsGDIObject(hdc) == OBJ_DC);

    if (IsGDIObject(hdc) != OBJ_DC)
        return NULL;

    PresDC(hdc);

    if (pdw = (DWORD FAR *)LockObj(hdc, 0x30))
        return (LPVOID)*pdw;
    else
        return NULL;

////return MAKELP(GetW(hdc, 0x32), GetW(hdc, 0x30));
}

/*----------------------------------------------------------------------------*\
 *
 * get the "internal" version of a GDI api
 * we need to do this so we can call GDI APIs like SelectObject and
 * SetTextColor on SaveDC blocks.
 *
 * we only need to do this on SaveDC blocks, not every DC
 *
 * the code must look like this or we fail:
 *
 * RealProc:
 *     .....
 *     JMP  ####   <== Internal version of RealProc
 *     mov  dh,80  (optinal)
 *     RETF NumParams
 * NextProc:
 *
\*----------------------------------------------------------------------------*/

FARPROC GetInternalProc(FARPROC RealProc, FARPROC NextProc, UINT NumParams)
{
    LPBYTE pb = (LPBYTE)NextProc;

    if ((DWORD)NextProc == 0 ||
        (DWORD)RealProc == 0 ||
        LOWORD(RealProc) <= 6 ||
        (DWORD)NextProc <= (DWORD)RealProc ||
        ((DWORD)NextProc - (DWORD)RealProc) > 80)
    {
        Assert(0);
        return RealProc;
    }

    if (pb[-6] == 0xE9 && pb[-3] == 0xCA && pb[-2] == NumParams && pb[-1] == 0x00)
    {
        return (FARPROC)MAKELP(SELECTOROF(pb), OFFSETOF(pb)-3+*(WORD FAR *)(pb-5));
    }

    if (pb[-8] == 0xE9 && pb[-5] == 0xB6 && pb[-4] == 0x80 &&
        pb[-3] == 0xCA && pb[-2] == NumParams && pb[-1] == 0x00)
    {
        return (FARPROC)MAKELP(SELECTOROF(pb), OFFSETOF(pb)-5+*(WORD FAR *)(pb-7));
    }

    Assert(0);
    return RealProc;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/

#define DCisMem         0x01    // DC is to a memory bitmap
#define DCisDisplay     0x02    // DC is to the screen device
#define DC_DIB          0x80
#define BITMAP_DIB      0x04
#define ChkDispPal      0x0200

BOOL IsValidSaveDC(HGDIOBJ h)
{
    HBITMAP         hbm;
    DIBENGINE FAR * pde;
    UINT            dcFlags;

    if (IsGDIObject(h) != OBJ_DC)
    {
        DPF("*** invalid SaveDC (%04X)", h);
        return FALSE;
    }

    dcFlags = GetW(h, 0x0E);

    if (!(dcFlags & DCisDisplay))
    {
        DPF("*** SaveDC (%04X) not a display DC", h);
        return FALSE;
    }

    hbm = (HBITMAP)GetW(h, 0x1E);

    if (IsGDIObject(hbm) != OBJ_BITMAP)
    {
        DPF("*** SaveDC (%04X) has invalid bitmap (%04X)", h, hbm);
        return FALSE;
    }

    pde = (DIBENGINE FAR *)MAKELP(GetW(h, 0x32), GetW(h, 0x30));

    if (IsBadReadPtr(pde, sizeof(DIBENGINE)))
    {
        DPF("*** SaveDC (%04X) has bad lpPDevice (%04X:%04X)", h, HIWORD(pde), LOWORD(pde));
        return FALSE;
    }

    if (pde->deType != TYPE_DIBENG)
    {
        DPF("*** SaveDC (%04X) not a DIBENG PDevice (%04X:%04X)", h, HIWORD(pde), LOWORD(pde));
        return FALSE;
    }

    return TRUE;
}

/*----------------------------------------------------------------------------*\
\*----------------------------------------------------------------------------*/
void SaveDCReSelectObjects(HGDIOBJ h, LPARAM lParam)
{
    COLORREF rgb;
    HDC hdc = (HDC)h;

    static HGDIOBJ  (WINAPI *ISelectObject)(HDC hdc, HGDIOBJ h);
    static COLORREF (WINAPI *ISetTextColor)(HDC hdc, COLORREF rgb);
    static COLORREF (WINAPI *ISetBkColor)(HDC hdc, COLORREF rgb);

    if (ISelectObject == NULL)
    {
        (FARPROC)ISelectObject = GetInternalProc((FARPROC)SelectObject, (FARPROC)SetTextColor, 4);
        (FARPROC)ISetTextColor = GetInternalProc((FARPROC)SetTextColor, (FARPROC)SetBkColor, 6);
        (FARPROC)ISetBkColor   = GetInternalProc((FARPROC)SetBkColor,   (FARPROC)SetBkMode, 6);
    }

    if (IsValidSaveDC(h))
    {
        DPF("ReSelecting objects for SaveDC %04X", h);

        ISelectObject(hdc, ISelectObject(hdc, GetStockObject(BLACK_BRUSH)));
        ISelectObject(hdc, ISelectObject(hdc, GetStockObject(BLACK_PEN)));

        rgb = ISetTextColor(hdc, 0x000000);
        ISetTextColor(hdc, 0xFFFFFF);
        ISetTextColor(hdc, rgb);

        rgb = ISetBkColor(hdc, 0x000000);
        ISetBkColor(hdc, 0xFFFFFF);
        ISetBkColor(hdc, rgb);
    }
}

/*----------------------------------------------------------------------------*\
 *
 *  SaveDCFix
 *
 *  make sure the dcPlanes and dcBitsPixel are patched right in SaveDC blocks.
 *
\*----------------------------------------------------------------------------*/

void SaveDCFix(HGDIOBJ h, LPARAM lParam)
{
    HBITMAP         hbm;
    DIBENGINE FAR * pde;
    UINT            dcFlags;
    UINT            dcPlanesBitsPixel;
    UINT            dePlanesBitsPixel;

    if (!IsValidSaveDC(h))
    {
        return;
    }

    dcPlanesBitsPixel = GetW(h, 0x9C);
    dcFlags = GetW(h, 0x0E);

    if (dcPlanesBitsPixel == 0x0101)
    {
        DPF("not Patching dcBitsPixel for SaveDC %04X (mono)", h);
        return;
    }

    if (LOBYTE(dcPlanesBitsPixel) != 1)
    {
        DPF("not Patching dcBitsPixel for SaveDC %04X (planes!=1)", h);
        Assert(0);
        return;
    }

    if (dcFlags & ChkDispPal)
    {
        DPF("clearing ChkDispPal flag for SaveDC %04X", h);
        SetW(h, 0x0E, dcFlags & ~ChkDispPal);
    }

    if ((dcFlags & DCisMem) && (hbm = (HBITMAP)GetW(h, 0x1E)) != StockBitmap())
    {
        HDC  hdcSel;
        HDC  hdc;

        hdcSel = GetBitmapDC(hbm);

        if (hdcSel)
        {
            DPF("*******************************************");
            DPF("*** SaveDC (%04X) has non-stock bitmap. ***", h);
            DPF("*******************************************");
            hdc = hdcSel;
        }
        else
        {
            DPF("**********************************************");
            DPF("*** SaveDC (%04X) has non-selected bitmap. ***", h);
            DPF("*** restoring bitmap to STOCK bitmap.      ***");
            DPF("**********************************************");
            hdc = CreateCompatibleDC(NULL);
        }

        //
        //  copy over the important stuff from the RealDC to the SaveDC
        //
        if (hdc)
        {
            PresDC(hdc);

            SetW(h, 0x0F, GetW(hdc, 0x0F));      // DCFlags2

            SetW(h, 0x26, GetW(hdc, 0x26));      // hPDeviceBlock
            SetW(h, 0x38, GetW(hdc, 0x38));      // pPDeviceBlock

            SetW(h, 0x22, GetW(hdc, 0x22));      // hLDevice
            SetW(h, 0x34, GetW(hdc, 0x34));      // pLDevice

            SetW(h, 0x16, GetW(hdc, 0x16));      // hPDevice
            SetW(h, 0x30, GetW(hdc, 0x30));      // lpPDevice.off
            SetW(h, 0x32, GetW(hdc, 0x32));      // lpPDevice.sel
            SetW(h, 0x36, GetW(hdc, 0x36));      // hBitBits

            SetW(h, 0x9C, GetW(hdc, 0x9C));      // dcPlanes + dcBitsPixel
        }

        if (hdc && hdcSel == NULL)
        {
            DeleteDC(hdc);
        }

        return;

#if 0 // broken code
        SetW(h, 0x30, 0);                       // lpPDevice.off
        SetW(h, 0x32, GetW(hbm, 0x0E));         // lpPDevice.sel
        SetW(h, 0x36, GetW(hbm, 0x0E));         // hBitBits

        w = GetW(h, 0x0F);                      // DCFlags2

        if (GetW(hbm, 0x1E) & BITMAP_DIB)       // bmFlags
            w |= DC_DIB;
        else
            w &= ~DC_DIB;

        SetW(h, 0x0F, w);                       // DCFlags2
#endif
    }

    pde = (DIBENGINE FAR *)MAKELP(GetW(h, 0x32), GetW(h, 0x30));
    Assert(!IsBadReadPtr(pde, sizeof(DIBENGINE)) && pde->deType == TYPE_DIBENG);

    dePlanesBitsPixel = *(WORD FAR *)&pde->dePlanes;

    if (dePlanesBitsPixel != dcPlanesBitsPixel)
    {
        DPF("Patching dcBitsPixel for SaveDC %04X %04X=>%04X", h, dcPlanesBitsPixel, dePlanesBitsPixel);
        SetW(h,0x9C,dePlanesBitsPixel);
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// END EVIL
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifdef DIRECT_DRAW
#undef DPF
#ifdef DEBUG
#define DPF DPF2

static void CDECL DPF2(char *sz, ...)
{
    char ach[128];
    wvsprintf(ach, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(2, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}

static void CDECL DPF5(char *sz, ...)
{
    char ach[128];
    wvsprintf(ach, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(5, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}

static void CDECL DPF7(char *sz, ...)
{
    char ach[128];
    wvsprintf(ach, sz, (LPVOID)(&sz+1));
#ifdef DIRECT_DRAW
    dprintf(7, ach);
#else
    lstrcat(ach, "\r\n");
    OutputDebugString(ach);
#endif
}

#else
#define DPF ; / ## /
#define DPF5 ; / ## /
#define DPF7 ; / ## /
#endif

// Utility for dumping information about ColorTables
#ifdef DEBUG_PAL
void DPF_PALETTE( BITMAPINFO *pbmi )
{
    DWORD i;
    DWORD *prgb = (DWORD *)(((BYTE *)pbmi)+pbmi->bmiHeader.biSize);
    DWORD cEntries = pbmi->bmiHeader.biClrUsed;

    if (pbmi->bmiHeader.biBitCount > 8)
	return;
    if (cEntries == 0)
	cEntries = 1 << (pbmi->bmiHeader.biBitCount);

    DPF7("Dumping Color table (0xFFRRGGBB) with %d entries", cEntries);
    for (i = 0; i < cEntries; i++)
    {
	DPF7("0x%lx", prgb[i]);
    }
}
#else
#define DPF_PALETTE(x)
#endif

// Utility for Dumping information about Bitmap Infos
#ifdef DEBUG_BMI
void DPF_PBMI( BITMAPINFO * pbmi )
{
    char *szT;
    DPF5("Dumping a BitmapInfo struct");
    DPF5("\t\tdeBitmapInfo->bmiHeader.biSize = %ld",pbmi->bmiHeader.biSize);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biWidth = %ld",pbmi->bmiHeader.biWidth);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biHeight = %ld",pbmi->bmiHeader.biHeight);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biPlanes = %d",pbmi->bmiHeader.biPlanes);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biBitCount = %d",pbmi->bmiHeader.biBitCount);
    szT = ((pbmi->bmiHeader.biCompression == BI_RGB) ? "BI_RGB" : "**UNKNOWN**");
    DPF5("\t\tdeBitmapInfo->bmiHeader.biCompression = 0x%lx(%s)",pbmi->bmiHeader.biCompression, szT);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biSizeImage = %ld",pbmi->bmiHeader.biSizeImage);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biXPelsPerMeter = 0x%lx",pbmi->bmiHeader.biXPelsPerMeter);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biYPelsPerMeter = 0x%lx",pbmi->bmiHeader.biYPelsPerMeter);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biClrUsed = %ld",pbmi->bmiHeader.biClrUsed);
    DPF5("\t\tdeBitmapInfo->bmiHeader.biClrImportant = %ld",pbmi->bmiHeader.biClrImportant);
    DPF_PALETTE(pbmi);
}
#else
#define DPF_PBMI(x)
#endif

// Utility for Dumping information about PDEs
#ifdef DEBUG_PDE
void DPF_PDE( DIBENGINE *pde )
{
    DPF5("Dumping a DIBENGINE struct.");
    DPF5("\tdeType = 0x%x(%s)",pde->deType,(pde->deType == TYPE_DIBENG ? "TYPE_DIBENG" : "**UNKNOWN**"));
    DPF5("\tdeWidth = %d",pde->deWidth);
    DPF5("\tdeHeight = %d",pde->deHeight);
    DPF5("\tdeWidthBytes = %d",pde->deWidthBytes);
    DPF5("\tdePlanes = %d",pde->dePlanes);
    DPF5("\tdeBitsPixel = %d",pde->deBitsPixel);
    DPF5("\tdeReserved1 = 0x%lx",pde->deReserved1);
    DPF5("\tdeDeltaScan = %ld",pde->deDeltaScan);
    DPF5("\tdelpPDevice = 0x%x",pde->delpPDevice);
    DPF5("\tdeBitsOffset = 0x%lx",pde->deBitsOffset);
    DPF5("\tdeBitsSelector = 0x%x",pde->deBitsSelector);
    DPF5("\tdeFlags = 0x%x(%s)",pde->deFlags,(pde->deFlags == SELECTEDDIB ? "SELECTEDDIB" : "**UNKNOWN**"));
    DPF5("\tdeVersion = %d(%s)",pde->deVersion,(pde->deVersion == VER_DIBENG ? "VER_DIBENG" : "**UNKNOWN**"));
    DPF5("\tdeBeginAccess = 0x%x",pde->deBeginAccess);
    DPF5("\tdeEndAccess = 0x%x",pde->deEndAccess);
    DPF5("\tdeDriverReserved = 0x%lx",pde->deDriverReserved);

    DPF_PBMI(pde->deBitmapInfo);
}
#else
#define DPF_PDE(x)
#endif



/////////////////////////////////////////////////////////////////////////////
//
//  DC stuff
//
/////////////////////////////////////////////////////////////////////////////
       DIBENGINE FAR *pdeDisplay;
       UINT FlatSel;
static HRGN hVisRgn;
static HDC hdcCache;
static BOOL bCache565;
static int in_use;
static int save_level;
static DWORD cacheBPP;

extern HINSTANCE hInstApp;

extern void FAR PASCAL SelectVisRgn(HDC, HRGN);
extern HDC  FAR PASCAL GetDCState(HDC);
extern void FAR PASCAL SetDCState(HDC,HDC);

BOOL DPMISetSelectorLimit(UINT selector, DWORD dwLimit);
extern DWORD PASCAL MapLS( LPVOID );	// flat -> 16:16
extern void PASCAL UnMapLS( DWORD ); // unmap 16:16

/////////////////////////////////////////////////////////////////////////////
//
//  SetDC
//	NOTE: all calls to SetDC must be matched with SetDC(hdc,0,0,0);
//
/////////////////////////////////////////////////////////////////////////////

BOOL NEAR PASCAL SetDC(HDC hdc, HDC hdcDevice, LPDDSURFACEDESC pddsd, LPPALETTEENTRY lpPalette)
{
    DIBENGINE FAR *pde;
    int  width;
    int  height;
    int  bpp;
    UINT flags;
    DWORD p16Surface;

    pde = GetPDevice(hdc);

    if (pde == NULL)
        return FALSE;

    Assert(pde->deType == 0x5250);
    Assert(pdeDisplay && pdeDisplay->deType == 0x5250);

    if (pddsd == 0)
    {
        pde->deFlags       |= BUSY;
        pde->deBitsOffset   = 0;
        pde->deBitsSelector = 0;


	if( pde->deBitmapInfo->bmiHeader.biXPelsPerMeter == 0 )
	{
	    DPF("SetDC NULL called on a DC that was never cooked by DDraw.");
	    Assert(0);
	    return TRUE;
	}

	// This code "should be done" but it causes
	// us to SelectVisRgn more often then necessary (and more
	// often than we did in DX1-4). This is safer.
	// pde->deBitmapInfo->bmiHeader.biWidth = 1;
	// pde->deBitmapInfo->bmiHeader.biHeight = -1;
	// pde->deBitmapInfo->bmiHeader.biSizeImage = 4;

	// We need to unmap the selector we allocated below
	Assert(pde->deReserved1 != 0);
	UnMapLS(pde->deReserved1);

	// Basically, we just want to restore the flags
	// to what they were when we got DC originally
	DPF5("Restore pde->deReserved1 to 0x%lx", pde->deBitmapInfo->bmiHeader.biXPelsPerMeter);
	pde->deReserved1 = pde->deBitmapInfo->bmiHeader.biXPelsPerMeter;
	pde->deBitmapInfo->bmiHeader.biXPelsPerMeter = 0;

	Assert(pde->deReserved1 != 0);
	pde->deBitsSelector = (WORD)((DWORD)pde->deReserved1 >> 16);

        return TRUE;
    }

    // Allocate a selector
    p16Surface = MapLS(pddsd->lpSurface);
    if( !p16Surface )
    {
	DPF("Couldn't allocate selector; Out of selectors.");
	return FALSE;
    }
    if( (WORD)p16Surface != 0 )
    {
	DPF("MapLS didn't return a 16:0 pointer!");
	Assert(0);
	return FALSE;
    }

    // Set the selector limit for this chunk of memory
    Assert(pddsd->dwHeight > 0);
    Assert(pddsd->lPitch > 0);
    if( !DPMISetSelectorLimit( (UINT)(p16Surface>>16), (pddsd->dwHeight*pddsd->lPitch) - 1 ) )
    {
	DPF("Couldn't update selector; Out of selectors.");
	UnMapLS(p16Surface);
	return FALSE;
    }

    DPF5("SetDC: Details of PDE from initial hdc.");
    DPF_PDE(pde);

    width =  (int)pddsd->dwWidth,
    height = (int)pddsd->dwHeight,
    bpp =    (int)pddsd->ddpfPixelFormat.dwRGBBitCount,
    flags =  (UINT)pddsd->ddpfPixelFormat.dwRBitMask == 0xf800 ? FIVE6FIVE : 0;

    pde->deFlags       &= ~BUSY;
    // Also, make sure we set all if any banked bits are set in the driver
    // to encourage the DIBENG to avoid screen to screen blts (which are apparently buggy).
    // Only do this for BankSwitched VRAM surfaces.
    // ATTENTION: MULTIMON pdeDisplay is the primary; we should check
    // the hdcDevice instead
    if ((pddsd->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
	(pdeDisplay->deFlags & (NON64KBANK|BANKEDVRAM|BANKEDSCAN)))
    {
	pde->deFlags |= (NON64KBANK|BANKEDVRAM|BANKEDSCAN);
    }
    else
    {
	pde->deFlags &= ~(NON64KBANK|BANKEDVRAM|BANKEDSCAN);
    }


    pde->deDeltaScan	= (DWORD)pddsd->lPitch;
    pde->deWidthBytes	= (WORD)pddsd->lPitch;

    // We use the selector we just allocated instead of the
    // flatsel + offset because it is a little safer if
    // something bad happens and someone goes off the end.
    pde->deBitsOffset	= 0;
    pde->deBitsSelector = (WORD)(p16Surface >> 16);

    pde->deBitmapInfo->bmiHeader.biXPelsPerMeter = pde->deReserved1;
    pde->deReserved1	= (DWORD)p16Surface;

    //
    // for a 8bit surface we want to color table to be the same as the
    // display (so it acts like a DDB not a DIB)
    //
    // For non-8bit surfaces; we don't need to do anything w.r.t. color table.
    //
    if (bpp == 8)
    {
        DWORD FAR *pdw;
	int i;
	RGBQUAD rgbT = {0,0,0,0};

	// Use our palette if it is explicitly set on the surface
	if (lpPalette)
	{
	    DPF( "Need a DC for an 8 bit surface with palette" );

	    Assert(pde->deBitmapInfo->bmiHeader.biBitCount == (DWORD)bpp);

	    // We use Pitch instead of Width because the "pitch" of
	    // dibsection is assumed to be the width rounded up to the next
	    // DWORD
            pde->deBitmapInfo->bmiHeader.biWidth = (DWORD)pddsd->lPitch;
	    pde->deBitmapInfo->bmiHeader.biHeight = -height; // negative height for top-down DIB
	    pde->deBitmapInfo->bmiHeader.biSizeImage = 0;
	    pde->deBitmapInfo->bmiHeader.biClrImportant = 256;

	    // We call this because it sets a magic number which
	    // has the effect of resetting any cached color translation
	    // tables that GDI may have set up for us.
	    SetDIBColorTable(hdc, 0, 1, &rgbT);

	    pdw = (DWORD FAR *)pde->deBitmapInfo;
	    pdw = (DWORD FAR *)((BYTE FAR *)pdw + pdw[0]);     // + biSize

	    for (i=0; i<256; i++)
		pdw[i] = RGB(lpPalette[i].peBlue,lpPalette[i].peGreen,lpPalette[i].peRed);
	}
	else
	{
	    DWORD FAR *pdwSrc;
	    DIBENGINE FAR *pdeDevice;
	    if (hdcDevice)
		pdeDevice = GetPDevice(hdcDevice);
	    else
		pdeDevice = pdeDisplay;

	    // This needs to be checked sooner.
	    Assert(pdeDevice && pdeDevice->deType == 0x5250);
	    Assert(pdeDevice->deBitsPixel == 8);
	    // In DX5, we will just modify our own bitmap info
	    // by copying the colors from the primary. In DX3, we
	    // pointed out bitmap info to the primary's; but that
	    // relies on the potentially bad assumption that our bitmap
	    // info will have a shorter life span to the primary's mode.
	    //
	    // It also doesn't work because the biWidth/biHeight fields
	    // of the device's primary don't match our own width/height
	    //

	    pdwSrc = (DWORD FAR *)(pdeDevice->deBitmapInfo);
	    pdwSrc = (DWORD FAR *)((BYTE FAR *)pdwSrc + pdwSrc[0]);	   // + biSize

	    pdw = (DWORD FAR *)pde->deBitmapInfo;
	    pdw = (DWORD FAR *)((BYTE FAR *)pdw + pdw[0]);	   // + biSize

	    // We call this because it sets a magic number which
	    // has the effect of resetting any cached color translation
	    // tables that GDI may have set up for us.
	    SetDIBColorTable(hdc, 0, 1, &rgbT);

	    // Copy all the colors to our color table
	    // We also clear all the special flags in our copy
	    for (i=0; i<256; i++)
		pdw[i] = (pdwSrc[i] & 0x00FFFFFF);

	    // Fixup the rest of the bitmapinfo

	    // We use Pitch instead of Width because the "pitch" of
	    // dibsection is assumed to be the width rounded up to the next
	    // DWORD
            pde->deBitmapInfo->bmiHeader.biWidth = (DWORD)pddsd->lPitch;
	    pde->deBitmapInfo->bmiHeader.biHeight = -height; // negative height for top-down DIB
	    pde->deBitmapInfo->bmiHeader.biSizeImage = 0;
	    pde->deBitmapInfo->bmiHeader.biClrImportant = 256;
	}
    }
    else
    {
	// We need to convert Pitch into the number of whole
	// pixels per scanline. There may be round-down errors
	// however, since GDI assumes that Pitches must be multiples
	// of 4; they round-up.
        DWORD pitch = (DWORD)pddsd->lPitch;
        if (bpp == 16)
            pitch = pitch / 2;
        else if (bpp == 24)
            pitch = pitch / 3;
        else if (bpp == 32)
            pitch = pitch / 4;
        else if (bpp == 4)
            pitch = pitch * 2;
        else if (bpp == 2)
            pitch = pitch * 4;
        else if (bpp == 1)
            pitch = pitch * 8;
        else
            Assert(0); // unexpected bpp

        pde->deBitmapInfo->bmiHeader.biWidth = pitch;
	pde->deBitmapInfo->bmiHeader.biHeight = -height; // negative height for top-down DIB
	pde->deBitmapInfo->bmiHeader.biSizeImage = 0;

	Assert(pde->deBitmapInfo->bmiHeader.biBitCount == (DWORD)bpp);
    }

    //
    // if the width/height of the dc has changed we need to set
    // a new vis region
    //
    if (width != (int)pde->deWidth || height != (int)pde->deHeight)
    {
        pde->deWidth  = width;
        pde->deHeight = height;

        SetRectRgn(hVisRgn, 0, 0, width, height);
        SelectVisRgn(hdc, hVisRgn);
    }

    //
    // when the bpp changes dont forget to fix up the deFlags
    // and ReSelect all the objects so they match the new bitdepth
    //
    if (pde->deBitsPixel != bpp || ((pde->deFlags ^ flags) & FIVE6FIVE))
    {
        if (flags & FIVE6FIVE)
            pde->deFlags |= FIVE6FIVE;
        else
            pde->deFlags &= ~FIVE6FIVE;

        pde->deBitsPixel = bpp;
        ReSelectObjects(hdc, 0);
    }

    DPF5("SetDC: Details of PDE returned.");
    DPF_PDE(pde);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//  AllocFlatSel
//
/////////////////////////////////////////////////////////////////////////////

#pragma optimize("", off)
UINT NEAR PASCAL AllocFlatSel()
{
    if (FlatSel != 0)
        return FlatSel;

    FlatSel = AllocSelector(SELECTOROF((LPVOID)&FlatSel));

    if (FlatSel == 0)
        return 0;

    SetSelectorBase(FlatSel, 0);

    // SetSelectorLimit(FlatSel, -1);
    _asm    mov     ax,0008h            ; DPMI set limit
    _asm    mov     bx,FlatSel
    _asm    mov     dx,-1
    _asm    mov     cx,-1
    _asm    int     31h

    return FlatSel;
}

BOOL DPMISetSelectorLimit(UINT selector, DWORD dwLimit)
{
    BOOL bRetVal=TRUE;

    // If the limit is >= 1MB, we need to make the limit a mulitple
    // of the page size or DPMISetSelectorLimit will fail.
    if( dwLimit >= 0x100000 )
        dwLimit |= 0x0FFF;

    __asm
    {
	mov  ax, 0008h
	mov  bx, selector
	mov  cx, word ptr [dwLimit+2]
	mov  dx, word ptr [dwLimit]
	int  31h
	jnc  success
	mov  bRetVal, FALSE
    success:
    }
    return bRetVal;
}
#pragma optimize("", on)

/////////////////////////////////////////////////////////////////////////////
//
//  InitDC
//
/////////////////////////////////////////////////////////////////////////////

BOOL NEAR PASCAL InitDC(void)
{
    HDC hdc;
    UINT rc;
    DIBENGINE FAR *pde;

    if (pdeDisplay != NULL)
    {
        return TRUE;
    }

    //
    // get the PDevice of the display we are going to need to copy
    // some info
    //
    if (pdeDisplay == NULL)
    {
        hdc = GetDC(NULL);
        rc = GetDeviceCaps(hdc, CAPS1);
        pde = GetPDevice(hdc);
        ReleaseDC(NULL, hdc);

        if (!(rc & C1_DIBENGINE) ||
            IsBadReadPtr(pde, 2) || pde->deType != 0x5250 ||
            GetProfileInt("DirectDraw", "DisableGetDC", 0))
        {
	    DPF("DD16_GetDC: GetDC is disabled");
            return FALSE;
        }

        pdeDisplay = pde;
    }

    if (FlatSel == 0)
    {
        AllocFlatSel();
    }

    if (hVisRgn == NULL)
    {
        hVisRgn = CreateRectRgn(0,0,0,0);
        SetObjectOwner(hVisRgn, hInstApp);
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//  MakeDC
//
/////////////////////////////////////////////////////////////////////////////

HDC NEAR PASCAL MakeDC(DWORD bpp, BOOL f565)
{
    HDC hdc;
    HBITMAP hbm;
    DIBENGINE FAR *pde;
    DIB8 BitmapInfo = {sizeof(BITMAPINFOHEADER), 1, -1, 1, 8, BI_RGB, 0, 0, 0, 0, 0};

    if (pdeDisplay == NULL)
	return NULL;

    hdc = GetDC(NULL);

    if (bpp == 8)
    {
	BitmapInfo.ct[0] = RGB(0,0,0);
	BitmapInfo.ct[255] = RGB(255, 255, 255);
    }
    else if (bpp == 16)
    {
        if (f565)
        {
            BitmapInfo.bi.biCompression = BI_BITFIELDS;
            BitmapInfo.ct[0] = 0xf800;
            BitmapInfo.ct[1] = 0x07e0;
            BitmapInfo.ct[2] = 0x001f;
        }
    }

    BitmapInfo.bi.biBitCount = (UINT)bpp;
    hbm = CreateDIBSection(hdc, (BITMAPINFO FAR *)&BitmapInfo, DIB_RGB_COLORS, NULL, NULL, 0);

    ReleaseDC(NULL, hdc);

    if (hbm == NULL)
        return NULL;

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);

    pde = GetPDevice(hdc);

    if (IsBadReadPtr(pde, 2) || pde->deType != 0x5250)
    {
        DeleteDC(hdc);
        DeleteObject(hbm);
        return NULL;
    }

    //
    //  ok we have the following:
    //
    //      pde        --> DIBSECTION (DIBENGINE)
    //      pdeDisplay --> DISPLAY PDevice (DIBENGINE)
    //
    //  make the  DIBSECTION be compatible with the display
    //  set the following fields from the DISPLAY PDevice:
    //
    //      deBitsPixel
    //      deFlags (FIVE6FIVE, PALETTIZED, MINIDRIVER, ...)
    //      deBitmapInfo
    //

    pde->deBeginAccess      = 0;
    pde->deEndAccess        = 0;
    // deDriverReserved has three states
    // 0 - Do Not Cache a translation table
    // 1 - Translation table is same as Screen
    // >1 - Unique ID indicating state of palette (to indicate when cached translation table is out of date)
    //
    // For 24 and 32bpp, it never makes sense to cache a translation table
    // because no translation table is built for our surface as the destination.
    // Win95 Gold DIBEngine has a bug which screws up when doing 8-to-24/32 blts
    // because it incorrectly tries to cache the table. So we set deDriverReserved
    // to 0 for 24/32 bpp.
    //
    // We have been setting deDriverReserved to 1; but we probably should not
    // be doing this anymore; we should be leaving it alone which means
    // that it gets the unique number given to each dibsection.
    //
    if (bpp == 16 || bpp == 24 || bpp == 32)
	pde->deDriverReserved = 0;
    else
	pde->deDriverReserved = 1; // ID for the screen
    pde->deBitsPixel        = 0; // set SetDC will see it has changed

//  pde->deFlags  = pdeDisplay->deFlags;
//  pde->deFlags &= ~(VRAM|NOT_FRAMEBUFFER|NON64KBANK|BANKEDVRAM|BANKEDSCAN|PALETTE_XLAT);
//  pde->deFlags |= OFFSCREEN;
//  pde->deFlags |= MINIDRIVER; need to clear SELECTEDDIB

    // if the main display is banked, make the DCs banked because they
    //may be used for video memory
    //
    // ATTENTION we should only do this for video memory
    // surfaces not memory surfaces. move this code to SetDC
    // Also, make sure we set all if any banked bits are set in the driver
    // to encourage the DIBENG to avoid screen to screen blts (which are apparently buggy).
    //
    if(pdeDisplay->deFlags & (NON64KBANK|BANKEDVRAM|BANKEDSCAN))
    {
	pde->deFlags |= (NON64KBANK|BANKEDVRAM|BANKEDSCAN);
    }

    // This bit should only ever be used in conjunction with VRAM
    // setting it can confuses drivers (such as the 765) into thinking that
    // the surface is in VRAM when it is not.
    //    pde->deFlags |= OFFSCREEN;
    pde->deFlags |= BUSY;

    SetObjectOwner(hdc, hInstApp);
    SetObjectOwner(hbm, hInstApp);

    return hdc;
}

/////////////////////////////////////////////////////////////////////////////
//
//  FreeDC
//
/////////////////////////////////////////////////////////////////////////////

BOOL NEAR PASCAL FreeDC(HDC hdc)
{
    if (hdc)
    {
        HBITMAP hbm;
        hbm = SelectObject(hdc, StockBitmap());
        DeleteDC(hdc);
        DeleteObject(hbm);
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_MakeObjectPrivate
//	This function makes sure that no DC that we need is
//  freed until we want it to be freed.
//
/////////////////////////////////////////////////////////////////////////////

WORD DDAPI DD16_MakeObjectPrivate(HDC hdc, BOOL fPrivate)
{
    BOOL fState;

    // Assert that parameter is good
    Assert(IsGDIObject(hdc) == OBJ_DC);

    fState = MakeObjectPrivate(hdc, fPrivate);

    if (fState)
    {
	return 1;
    }
    else
    {
	return 0;
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_GetDC
//
/////////////////////////////////////////////////////////////////////////////

HDC DDAPI DD16_GetDC(HDC hdcDevice, LPDDSURFACEDESC pddsd, LPPALETTEENTRY lpPalette)
{
    HDC hdc;
    BOOL f565;
    // Assert that parameter is good
    Assert(IsGDIObject(hdcDevice) == OBJ_DC);

    // must be a RGB format surface!
    //
    if (!(pddsd->ddpfPixelFormat.dwFlags & DDPF_RGB))
    {
        DPF("DD16_GetDC: must be a RGB surface");
        return NULL;
    }

    //
    // if the surface is 8bpp the display must also be 8bpp because we
    // share the color table. (Multi-mon: make sure we check the right display.)
    //
    // If a palette is explicitly passed in, then we won't need
    // the device's pde.
    //
    if( pddsd->ddpfPixelFormat.dwRGBBitCount == 8 && lpPalette == NULL )
    {
	DIBENGINE FAR *pdeDevice;
	if( hdcDevice )
	    pdeDevice = GetPDevice( hdcDevice );
	else
	    pdeDevice = pdeDisplay;

	// 3DFx isn't a real device DC
	if (pdeDevice->deType != 0x5250)
	{
	    DPF("Can't get DC on an 8bpp surface without a palette for this device");
	    return NULL;
	}

	if (pdeDevice->deBitsPixel != 8 )
	{
	    DPF("Can't get DC on an 8bpp surface without a palette when primary is not at 8bpp");
	    return NULL;
	}

    }

#ifdef DEBUG
    //
    // we assume the pixel format is not wacky
    //
    if (pddsd->ddpfPixelFormat.dwRGBBitCount == 8 )
    {
        /*
         * The Permedia driver actually reports bit masks for their 8bit palettized mode, so
         * we shouldn't assert here (as we used to) if any masks are non-zero.
         */
        if ( ( pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) ==0 )
        {
            DPF("Getting a DC on a non-palettized 8bit surface!");
            Assert(0);
        }
    }
    else if (   pddsd->ddpfPixelFormat.dwRGBBitCount == 4 ||
                pddsd->ddpfPixelFormat.dwRGBBitCount == 1)
    {
        /*
         * Assume these are OK
         */
    }
    else if (pddsd->ddpfPixelFormat.dwRGBBitCount == 16)
    {
        if (pddsd->ddpfPixelFormat.dwRBitMask == 0xf800 &&
            pddsd->ddpfPixelFormat.dwGBitMask == 0x07e0 &&
            pddsd->ddpfPixelFormat.dwBBitMask == 0x001f)
        {
            // 565
        }
        else if (
            pddsd->ddpfPixelFormat.dwRBitMask == 0x7c00 &&
            pddsd->ddpfPixelFormat.dwGBitMask == 0x03e0 &&
            pddsd->ddpfPixelFormat.dwBBitMask == 0x001f)
        {
            // 555
        }
        else
        {
            DPF("DD16_GetDC: not 555 or 565");
            Assert(0);
        }
    }
    else if (pddsd->ddpfPixelFormat.dwRGBBitCount == 24 )
    {
        if (pddsd->ddpfPixelFormat.dwBBitMask == 0x0000FF &&
            pddsd->ddpfPixelFormat.dwGBitMask == 0x00FF00 &&
            pddsd->ddpfPixelFormat.dwRBitMask == 0xFF0000)
        {
            // 888 BGR
        }
        else
        {
            DPF("DD16_GetDC: invalid bit masks");
            Assert(0);
        }
    }
    else if(pddsd->ddpfPixelFormat.dwRGBBitCount == 32)
    {
	if (pddsd->ddpfPixelFormat.dwRBitMask == 0xFF0000 &&
		 pddsd->ddpfPixelFormat.dwGBitMask == 0x00FF00 &&
		 pddsd->ddpfPixelFormat.dwBBitMask == 0x0000FF)

        {
	    // 888 RGB -- standard 32-bit format
	}
        else
        {
            DPF("DD16_GetDC: invalid bit masks");
            Assert(0);
        }
    }
    else
    {
        DPF("DD16_GetDC: invalid bit depth");
        Assert(0);

    }
#endif

    // is this a 565?
    f565 = FALSE;
    if (pddsd->ddpfPixelFormat.dwRGBBitCount == 16 &&
            pddsd->ddpfPixelFormat.dwRBitMask == 0xf800)
        f565 = TRUE;

    //
    // use the cacheDC if it is free, else make a new one.
    //

    if( in_use || ( pddsd->ddsCaps.dwCaps & DDSCAPS_OWNDC ) )
    {
        hdc = MakeDC( pddsd->ddpfPixelFormat.dwRGBBitCount, f565 );
    }
    else
    {
        if (cacheBPP != pddsd->ddpfPixelFormat.dwRGBBitCount || bCache565 != f565 )
	{
	    FreeDC(hdcCache);
            hdcCache = MakeDC(pddsd->ddpfPixelFormat.dwRGBBitCount, f565);
	    cacheBPP = pddsd->ddpfPixelFormat.dwRGBBitCount;
            bCache565 = f565;
	}

        hdc = hdcCache;
        in_use++;
    }

    //
    // now set the right bits pointer.
    //
    if (hdc)
    {
	BOOL fSuccess;
	// Set the DC with the right information based
	// on the surface. If a palette is passed in
	// then set that palette into the DC.
	fSuccess = SetDC(hdc, hdcDevice, pddsd, lpPalette);

	if( !fSuccess )
	{
	    DPF("SetDC Failed");

	    // We need to clean up; but we
	    // can't call ReleaseDC because our dc is only
	    // half-cooked.
	    if (hdc == hdcCache)
	    {
		Assert(in_use == 1);
		in_use = 0;
	    }
	    else
	    {
		FreeDC(hdc);
	    }
	    return NULL;
	}
    }

    if (hdc && hdc == hdcCache)
    {
        save_level = SaveDC(hdc);
    }

    return hdc;
}

/////////////////////////////////////////////////////////////////////////////
//
// DD16_ReleaseDC
//
/////////////////////////////////////////////////////////////////////////////

void DDAPI DD16_ReleaseDC(HDC hdc)
{
    if (hdc == NULL)
        return;

    if (hdc == hdcCache)
    {
        RestoreDC(hdc, save_level);
	SetDC(hdc, NULL, NULL, NULL);
        Assert(in_use == 1);
        in_use = 0;
    }
    else
    {
	SetDC(hdc, NULL, NULL, NULL);
        FreeDC(hdc);
    }
}

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_SafeMode
//
//  dynamic safe mode
//
/////////////////////////////////////////////////////////////////////////////

BOOL DDAPI DD16_SafeMode(HDC hdc, BOOL fSafeMode)
{
    extern void PatchDisplay(int oem, BOOL patch);   // dynares.c

    int i;

    for (i=0; i<35; i++)
    {
        PatchDisplay(i, fSafeMode);
    }

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_Exclude
//  DD16_Unexclude
//
//  call the exclude or unexclude callbacks in the display driver
//
/////////////////////////////////////////////////////////////////////////////

typedef void (FAR PASCAL *BEGINACCESSPROC)(LPVOID lpPDevice, int left, int top, int right, int bottom, WORD flags);
typedef void (FAR PASCAL *ENDACCESSPROC)(LPVOID lpPDevice, WORD flags);

void DDAPI DD16_Exclude(DWORD dwPDevice, RECTL FAR *prcl)
{
    DIBENGINE FAR *pde = (DIBENGINE FAR *)dwPDevice;

    Assert(pde && pde->deType == 0x5250);
    Assert(prcl != NULL);
    Assert(pde->deFlags & BUSY);

    if (pde->deBeginAccess)
    {
        BEGINACCESSPROC OEMBeginAccess = (BEGINACCESSPROC)pde->deBeginAccess;

        //
        //  when DirectDraw calls us it has already taken the BUSY bit
        //  but BUSY needs to be clear for the cursor to be excluded.
        //  so release the BUSY bit while we call the driver, this is
        //  a ok thing to do because we have the Win16Lock.
        //
        pde->deFlags &= ~BUSY;
        OEMBeginAccess(pde, (int)prcl->left, (int)prcl->top,
            (int)prcl->right, (int)prcl->bottom, CURSOREXCLUDE);
        pde->deFlags |= BUSY;
    }
}

void DDAPI DD16_Unexclude(DWORD dwPDevice)
{
    DIBENGINE FAR *pde = (DIBENGINE FAR *)dwPDevice;

    Assert(pde && pde->deType == 0x5250);

    if (pde->deEndAccess)
    {
        ENDACCESSPROC OEMEndAccess = (ENDACCESSPROC)pde->deEndAccess;
        OEMEndAccess(pde, CURSOREXCLUDE);
    }
}

/*
 * DD16_AttemptGamma
 *
 * Total HACK!  The GetDeviceGammaRamp call can attempt to call a NULL
 * entry.  Since we can't fix Win95, instead we look at the entry that
 * it will call and suggest that they don't call it if it's NULL.
 */
BOOL DDAPI DD16_AttemptGamma( HDC hdc )
{
    WORD wLDevice;
    WORD FAR *pw;
    UINT hGDI = GetGdiDS();

    wLDevice = GetW(hdc, 0x34);
    if( wLDevice != 0 )
    {
        pw = MAKELP(hGDI, wLDevice);
        if (!IsBadReadPtr(pw, 0x80))
        {
            pw = MAKELP(hGDI, wLDevice + 0x7C);
            if (*pw != NULL)
            {
                return TRUE;
            }
        }
    }
    return FALSE;

} /* DD16_AttemptGamma */

/*
 * DD16_IsDeviceBusy
 *
 * Determines if the device represented by the HDC is
 * busy or not.
 */
BOOL DDAPI DD16_IsDeviceBusy( HDC hdc )
{
    DIBENGINE FAR *pde;

    pde = GetPDevice(hdc);
    if(pde == NULL)
        return FALSE;

    Assert(pde->deType==0x5250);
    return pde->deFlags & BUSY;
} /* DD16_IsDeviceBusy */

/////////////////////////////////////////////////////////////////////////////
//
//  DD16_Stretch
//
//  call the DIBENG to do a stretch.
//
/////////////////////////////////////////////////////////////////////////////

extern int FAR PASCAL DIB_Stretch(
    DIBENGINE FAR *dst, int, int, int, int,
    DIBENGINE FAR *src, int, int, int, int,
    DWORD Rop, LPVOID lpPBrush, LPVOID lpDrawMode, LPRECT lpClip);

extern int FAR PASCAL DIB_BitBlt(
    DIBENGINE FAR *dst, int xD, int yD,
    DIBENGINE FAR *src, int xS, int yS, int w, int h,
    DWORD Rop, LPVOID lpPBrush, LPVOID lpDrawMode);

typedef struct {
    short int	  Rop2;
    short int	  bkMode;
    unsigned long int bkColor;
    unsigned long int TextColor;
    short int	  TBreakExtra;
    short int	  BreakExtra;
    short int	  BreakErr;
    short int	  BreakRem;
    short int	  BreakCount;
    short int	  CharExtra;

    unsigned long int LbkColor;
    unsigned long int LTextColor;
    DWORD		  ICMCXform;
    short		  StretchBltMode;
    DWORD		  eMiterLimit;
} DRAWMODE;

int DDAPI DD16_Stretch(DWORD DstPtr, int DstPitch, UINT DstBPP, int DstX, int DstY, int DstDX, int DstDY,
                       DWORD SrcPtr, int SrcPitch, UINT SrcBPP, int SrcX, int SrcY, int SrcDX, int SrcDY)//, long Rop3)

{
    DIBENGINE   src;
    DIBENGINE	dst;
    DRAWMODE    dm;
    RECT        rc;
    static DIB8	bmiStretch = {sizeof(BITMAPINFOHEADER), 1, -1, 1, 8, BI_RGB, 0, 0, 0, 0, 0};

    //
    //	make sure we have a flat sel
    //
    if (FlatSel == 0)
        return -1;

    // Set the bitdepth on the bitmapinfo
    Assert( DstBPP == SrcBPP );
    bmiStretch.bi.biBitCount = DstBPP;

    //
    //	setup source DIBENG
    //
    if (SrcPtr)
    {
        src.deType          = TYPE_DIBENG;
        src.deWidth         = 10000;
        src.deHeight        = 10000;
        src.deWidthBytes    = SrcPitch;
        src.dePlanes        = 1;
        src.deBitsPixel     = SrcBPP;
        src.deReserved1     = 0;
        src.deDeltaScan     = SrcPitch;
        src.delpPDevice     = NULL;
        src.deBitsOffset    = SrcPtr;
        src.deBitsSelector  = FlatSel;
        src.deFlags         = SELECTEDDIB;
        src.deVersion       = VER_DIBENG;
        src.deBitmapInfo    = (BITMAPINFO *)&bmiStretch;
        src.deBeginAccess   = 0;
        src.deEndAccess     = 0;
        src.deDriverReserved= 0;
    }

    //
    //	setup dest DIBENG
    //
    dst.deType		 = TYPE_DIBENG;
    dst.deWidth          = 10000;
    dst.deHeight         = 10000;
    dst.deWidthBytes	 = DstPitch;
    dst.dePlanes	 = 1;
    dst.deBitsPixel	 = DstBPP;
    dst.deReserved1	 = 0;
    dst.deDeltaScan	 = DstPitch;
    dst.delpPDevice	 = NULL;
    dst.deBitsOffset	 = DstPtr;
    dst.deBitsSelector	 = FlatSel;
    dst.deFlags 	 = SELECTEDDIB;
    dst.deVersion	 = VER_DIBENG;
    dst.deBitmapInfo     = (BITMAPINFO *)&bmiStretch;
    dst.deBeginAccess	 = 0;
    dst.deEndAccess	 = 0;
    dst.deDriverReserved = 0;


    //
    //  this memory *might* be in VRAM so setup things to
    //  work right.
    //
    //  ATTENTION we should only do this for video memory
    //  surfaces not memory surfaces.
    //  If any are set, set all the bits to force the DIBENG to
    //  not do a screen to screen blit (which apparently has a bug).
    //
    if (pdeDisplay && (pdeDisplay->deFlags & (NON64KBANK|BANKEDVRAM|BANKEDSCAN)))
    {
        dst.deFlags |= (NON64KBANK|BANKEDVRAM|BANKEDSCAN);
        src.deFlags |= (NON64KBANK|BANKEDVRAM|BANKEDSCAN);
    }

    //
    //	now call the DIBENG
    //

    if(SrcPtr == (DWORD)NULL)
    {
        DPF("Blitting from Primary with HDC unsupported!");
        return FALSE;
    }
    else if ((DstDX == SrcDX) && (DstDY == SrcDY))
    {
	    //DPF("Calling DIB_BitBlt");
	    // NOTE: If the source and destination video memory pointers
	    // are the same then we simply pass the destination
	    // DIBENG for the source as this is how the blt code spots
	    // the fact that the source and destination surfaces are
	    // the same and so takes the necessary action to handle
	    // overlapping surfaces
	    #ifdef DEBUG
	    	if( DstPtr == SrcPtr)
		{
		    Assert(DstPitch == SrcPitch);
		    Assert(DstBPP   == SrcBPP);
		}
	    #endif
	    return DIB_BitBlt(&dst, DstX, DstY,
			      (DstPtr == SrcPtr) ? &dst : &src,
			      SrcX, SrcY, SrcDX, SrcDY, SRCCOPY, // Rop3,
			      NULL, &dm);
    }
    else
    {
        rc.left = DstX;
	    rc.top = DstY;
	    rc.right = DstX + DstDX;
	    rc.bottom = DstY + DstDY;

	    dm.StretchBltMode = STRETCH_DELETESCANS;

/*        DPF("Calling DIB_StretchBlt with:");
        DPF("\tdst.deType = 0x%x(%s)",dst.deType,(dst.deType == TYPE_DIBENG ? "TYPE_DIBENG" : "**UNKNOWN**"));
        DPF("\tdst.deWidth = %d",dst.deWidth);
        DPF("\tdst.deHeight = %d",dst.deHeight);
        DPF("\tdst.deWidthBytes = %d",dst.deWidthBytes);
        DPF("\tdst.dePlanes = %d",dst.dePlanes);
        DPF("\tdst.deBitsPixel = %d",dst.deBitsPixel);
        DPF("\tdst.deReserved1 = %ld",dst.deReserved1);
        DPF("\tdst.deDeltaScan = %ld",dst.deDeltaScan);
        DPF("\tdst.delpPDevice = 0x%x",dst.delpPDevice);
        DPF("\tdst.deBitsOffset = 0x%x",dst.deBitsOffset);
        DPF("\tdst.deBitsSelector = 0x%x",dst.deBitsSelector);
        DPF("\tdst.deFlags = 0x%x(%s)",dst.deFlags,(dst.deFlags == SELECTEDDIB ? "SELECTEDDIB" : "**UNKNOWN**"));
        DPF("\tdst.deVersion = %d(%s)",dst.deVersion,(dst.deVersion == VER_DIBENG ? "VER_DIBENG" : "**UNKNOWN**"));

        DPF("\t\tdst.deBitmapInfo->bmiHeader.biSize = %ld",dst.deBitmapInfo->bmiHeader.biSize);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biWidth = %ld",dst.deBitmapInfo->bmiHeader.biWidth);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biHeight = %ld",dst.deBitmapInfo->bmiHeader.biHeight);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biPlanes = %d",dst.deBitmapInfo->bmiHeader.biPlanes);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biBitCount = %d",dst.deBitmapInfo->bmiHeader.biBitCount);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biCompression = 0x%x(%s)",dst.deBitmapInfo->bmiHeader.biCompression,((dst.deBitmapInfo->bmiHeader.biCompression == BI_RGB) ? "BI_RGB" : "**UNKNOWN**"));
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biSizeImage = %ld",dst.deBitmapInfo->bmiHeader.biSizeImage);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biXPelsPerMeter = %ld",dst.deBitmapInfo->bmiHeader.biXPelsPerMeter);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biYPelsPerMeter = %ld",dst.deBitmapInfo->bmiHeader.biYPelsPerMeter);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biClrUsed = %ld",dst.deBitmapInfo->bmiHeader.biClrUsed);
        DPF("\t\tdst.deBitmapInfo->bmiHeader.biClrImportant = %ld",dst.deBitmapInfo->bmiHeader.biClrImportant);

        DPF("\tdst.deBeginAccess = 0x%x",dst.deBeginAccess);
        DPF("\tdst.deEndAccess = 0x%x",dst.deEndAccess);
        DPF("\tdst.deDriverReserved = 0x%x",dst.deDriverReserved);

        DPF("");
        DPF("\tDstX  = %d",DstX);
        DPF("\tDstY  = %d",DstY);
        DPF("\tDstDX = %d",DstDX);
        DPF("\tDstDY = %d",DstDY);

        DPF("");

        DPF("\tsrc.deType = 0x%x(%s)",src.deType,(src.deType == TYPE_DIBENG ? "TYPE_DIBENG" : "**UNKNOWN**"));
        DPF("\tsrc.deWidth = %d",src.deWidth);
        DPF("\tsrc.deHeight = %d",src.deHeight);
        DPF("\tsrc.deWidthBytes = %d",src.deWidthBytes);
        DPF("\tsrc.dePlanes = %d",src.dePlanes);
        DPF("\tsrc.deBitsPixel = %d",src.deBitsPixel);
        DPF("\tsrc.deReserved1 = %ld",src.deReserved1);
        DPF("\tsrc.deDeltaScan = %ld",src.deDeltaScan);
        DPF("\tsrc.delpPDevice = 0x%x",src.delpPDevice);
        DPF("\tsrc.deBitsOffset = 0x%x",src.deBitsOffset);
        DPF("\tsrc.deBitsSelector = 0x%x",src.deBitsSelector);
        DPF("\tsrc.deFlags = 0x%x(%s)",src.deFlags,(src.deFlags == SELECTEDDIB ? "SELECTEDDIB" : "**UNKNOWN**"));
        DPF("\tsrc.deVersion = %d(%s)",src.deVersion,(src.deVersion == VER_DIBENG ? "VER_DIBENG" : "**UNKNOWN**"));

        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biSize = %ld",src.deBitmapInfo->bmiHeader.biSize);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biWidth = %ld",src.deBitmapInfo->bmiHeader.biWidth);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biHeight = %ld",src.deBitmapInfo->bmiHeader.biHeight);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biPlanes = %d",src.deBitmapInfo->bmiHeader.biPlanes);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biBitCount = %d",src.deBitmapInfo->bmiHeader.biBitCount);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biCompression = 0x%x(%s)",src.deBitmapInfo->bmiHeader.biCompression,((src.deBitmapInfo->bmiHeader.biCompression == BI_RGB) ? "BI_RGB" : "**UNKNOWN**"));
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biSizeImage = %ld",src.deBitmapInfo->bmiHeader.biSizeImage);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biXPelsPerMeter = %ld",src.deBitmapInfo->bmiHeader.biXPelsPerMeter);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biYPelsPerMeter = %ld",src.deBitmapInfo->bmiHeader.biYPelsPerMeter);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biClrUsed = %ld",src.deBitmapInfo->bmiHeader.biClrUsed);
        DPF("\t\tsrc.deBitmapInfo->bmiHeader.biClrImportant = %ld",src.deBitmapInfo->bmiHeader.biClrImportant);

        DPF("\tsrc.deBeginAccess = 0x%x",src.deBeginAccess);
        DPF("\tsrc.deEndAccess = 0x%x",src.deEndAccess);
        DPF("\tsrc.deDriverReserved = 0x%x",src.deDriverReserved);

        DPF("");
        DPF("\tSrcX  = %d",SrcX);
        DPF("\tSrcY  = %d",SrcY);
        DPF("\tSrcDX = %d",SrcDX);
        DPF("\tSrcDY = %d",SrcDY);

        DPF("");

        DPF("\tdm.StretchBltMode = STRETCH_DELETESCANS");

        DPF("");

        DPF("\trc.left  = %d",rc.left);
        DPF("\trc.top  = %d",rc.top);
        DPF("\trc.right = %d",rc.right);
        DPF("\trc.bottom = %d",rc.bottom);

        DPF("");
*/

        return DIB_Stretch(&dst, DstX, DstY, DstDX, DstDY,
						    &src, SrcX, SrcY, SrcDX, SrcDY, SRCCOPY, // Rop3,
						    NULL, &dm, &rc);
    }
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void GdiHelpCleanUp()
{
    if (FlatSel)
    {
        SetSelectorLimit(FlatSel, 0);
        FreeSelector(FlatSel);
        FlatSel = 0;
    }

    if (hdcCache)
    {
        FreeDC(hdcCache);
        hdcCache = NULL;
    }

    if (hVisRgn)
    {
        DeleteObject(hVisRgn);
        hVisRgn = NULL;
    }

    if (pdeDisplay)
    {
        pdeDisplay = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOL GdiHelpInit()
{
    InitDC();
    return FlatSel!=NULL && pdeDisplay!=NULL;
}

#endif // DirectDraw
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\ddhal.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddhal.c
 *  Content:	16-bit DirectDraw HAL
 *		These routines redirect the callbacks from the 32-bit
 *		side to the driver
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   03-feb-95	craige	performance tuning, ongoing work
 *   03-mar-95	craige	added WaitForVerticalBlank
 *   11-mar-95	craige	palette stuff
 *   16-mar-95	craige	added DD16_SelectPalette
 *   24-mar-95	craige	added DD16_GetTimeSel
 *   04-apr-95	craige	call display driver for get/set palette
 *   14-may-95	craige	added DD16_EnableReboot; cleaned up obsolete junk
 *   23-may-95	craige	removed DD16_GetTimeSel; cleaned up more obsolete junk
 *   28-may-95	craige	cleaned up HAL: added DDThunk16_GetBltStatus;
 *			DDThunk16_GetFlipStatus; DDThunk16_GetScanLine
 *   13-jul-95  toddla  remove _export from thunk functions
 *   13-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   01-oct-96	ketand	added GetAvailDriverMemory
 *   21-jan-97	ketand	Fix SetEntries for multimon.
 *   27-jan-97	ketand	Remove unused DD16_GetPaletteEntries; it didn't work for multi-mon
 *			and wasn't worth fixing.
 *   03-feb-97	ketand	Fix DC leak w.r.t. MakeObjectPrivate.
 *
 ***************************************************************************/
#include "ddraw16.h"

#define DPF_MODNAME "DDRAW16"

/****************************************************************************
 *
 * DRIVER CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * DDThunk16_CreatePalette
 */
DWORD DDAPI DDThunk16_CreatePalette( LPDDHAL_CREATEPALETTEDATA lpCreatePaletteData )
{
    return lpCreatePaletteData->CreatePalette( lpCreatePaletteData );

} /* DDThunk16_CreateSurface */

/*
 * DDThunk16_CreateSurface
 */
DWORD DDAPI DDThunk16_CreateSurface( LPDDHAL_CREATESURFACEDATA lpCreateSurfaceData )
{
    return lpCreateSurfaceData->CreateSurface( lpCreateSurfaceData );

} /* DDThunk16_CreateSurface */

/*
 * DDThunk16_CanCreateSurface
 */
DWORD DDAPI DDThunk16_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA lpCanCreateSurfaceData )
{
    return lpCanCreateSurfaceData->CanCreateSurface( lpCanCreateSurfaceData );

} /* DDThunk16_CanCreateSurface */

/*
 * DDThunk16_WaitForVerticalBlank
 */
DWORD DDAPI DDThunk16_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlankData )
{
    return lpWaitForVerticalBlankData->WaitForVerticalBlank( lpWaitForVerticalBlankData );

} /* DDThunk16_WaitForVerticalBlank */

/*
 * DDThunk16_DestroyDriver
 */
DWORD DDAPI DDThunk16_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA lpDestroyDriverData )
{

    return lpDestroyDriverData->DestroyDriver( lpDestroyDriverData );

} /* DDThunk16_DestroyDriver */

/*
 * DDThunk16_SetMode
 */
DWORD DDAPI DDThunk16_SetMode( LPDDHAL_SETMODEDATA lpSetModeData )
{

    return lpSetModeData->SetMode( lpSetModeData );

} /* DDThunk16_SetMode */

/*
 * DDThunk16_GetScanLine
 */
DWORD DDAPI DDThunk16_GetScanLine( LPDDHAL_GETSCANLINEDATA lpGetScanLineData )
{

    return lpGetScanLineData->GetScanLine( lpGetScanLineData );

} /* DDThunk16_GetScanLine */

/*
 * DDThunk16_SetExclusiveMode
 */
DWORD DDAPI DDThunk16_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA lpSetExclusiveModeData )
{

    return lpSetExclusiveModeData->SetExclusiveMode( lpSetExclusiveModeData );

} /* DDThunk16_SetExclusiveMode */

/*
 * DDThunk16_FlipToGDISurface
 */
DWORD DDAPI DDThunk16_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA lpFlipToGDISurfaceData )
{

    return lpFlipToGDISurfaceData->FlipToGDISurface( lpFlipToGDISurfaceData );

} /* DDThunk16_FlipToGDISurface */

/*
 * DDThunk16_GetAvailDriverMemory
 */
DWORD DDAPI DDThunk16_GetAvailDriverMemory( LPDDHAL_GETAVAILDRIVERMEMORYDATA lpGetAvailDriverMemoryData )
{

    return lpGetAvailDriverMemoryData->GetAvailDriverMemory( lpGetAvailDriverMemoryData );

} /* DDThunk16_GetAvailDriverMemory */

/*
 * DDThunk16_UpdateNonLocalHeap
 */
DWORD DDAPI DDThunk16_UpdateNonLocalHeap( LPDDHAL_UPDATENONLOCALHEAPDATA lpUpdateNonLocalHeapData )
{

    return lpUpdateNonLocalHeapData->UpdateNonLocalHeap( lpUpdateNonLocalHeapData );

} /* DDThunk16_UpdateNonLocalHeap */

/****************************************************************************
 *
 * SURFACE CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * DDThunk16_DestroySurface
 */
DWORD DDAPI DDThunk16_DestroySurface( LPDDHAL_DESTROYSURFACEDATA lpDestroySurfaceData )
{

    return lpDestroySurfaceData->DestroySurface( lpDestroySurfaceData );

} /* DDThunk16_DestroySurface */

/*
 * DDThunk16_Flip
 */
DWORD DDAPI DDThunk16_Flip( LPDDHAL_FLIPDATA lpFlipData )
{
    return lpFlipData->Flip( lpFlipData );

} /* DDThunk16_Flip */

/*
 * DDThunk16_Blt
 */
DWORD DDAPI DDThunk16_Blt( LPDDHAL_BLTDATA lpBltData )
{
    return lpBltData->Blt( lpBltData );

} /* DDThunk16_Blt */

/*
 * DDThunk16_Lock
 */
DWORD DDAPI DDThunk16_Lock( LPDDHAL_LOCKDATA lpLockData )
{
    return lpLockData->Lock( lpLockData );

} /* DDThunk16_Lock */

/*
 * DDThunk16_Unlock
 */
DWORD DDAPI DDThunk16_Unlock( LPDDHAL_UNLOCKDATA lpUnlockData )
{
    return lpUnlockData->Unlock( lpUnlockData );

} /* DDThunk16_Unlock */

/*
 * DDThunk16_AddAttachedSurface
 */
DWORD DDAPI DDThunk16_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA lpAddAttachedSurfaceData )
{
    return lpAddAttachedSurfaceData->AddAttachedSurface( lpAddAttachedSurfaceData );

} /* DDThunk16_AddAttachedSurface */

/*
 * DDThunk16_SetColorKey
 */
DWORD DDAPI DDThunk16_SetColorKey( LPDDHAL_SETCOLORKEYDATA lpSetColorKeyData )
{
    return lpSetColorKeyData->SetColorKey( lpSetColorKeyData );

} /* DDThunk16_SetColorKey */

/*
 * DDThunk16_SetClipList
 */
DWORD DDAPI DDThunk16_SetClipList( LPDDHAL_SETCLIPLISTDATA lpSetClipListData )
{
    return lpSetClipListData->SetClipList( lpSetClipListData );

} /* DDThunk16_ClipList */

/*
 * DDThunk16_UpdateOverlay
 */
DWORD DDAPI DDThunk16_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA lpUpdateOverlayData )
{
    return lpUpdateOverlayData->UpdateOverlay( lpUpdateOverlayData );

} /* DDThunk16_UpdateOverlay */

/*
 * DDThunk16_SetOverlayPosition
 */
DWORD DDAPI DDThunk16_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA lpSetOverlayPositionData )
{
    return lpSetOverlayPositionData->SetOverlayPosition( lpSetOverlayPositionData );

} /* DDThunk16_SetOverlayPosition */

/*
 * DDThunk16_SetPalette
 */
DWORD DDAPI DDThunk16_SetPalette( LPDDHAL_SETPALETTEDATA lpSetPaletteData )
{
    return lpSetPaletteData->SetPalette( lpSetPaletteData );

} /* DDThunk16_SetPalette */

/*
 * DDThunk16_GetBltStatus
 */
DWORD DDAPI DDThunk16_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA lpGetBltStatusData )
{
    return lpGetBltStatusData->GetBltStatus( lpGetBltStatusData );

} /* DDThunk16_GetBltStatus */

/*
 * DDThunk16_GetFlipStatus
 */
DWORD DDAPI DDThunk16_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatusData )
{
    return lpGetFlipStatusData->GetFlipStatus( lpGetFlipStatusData );

} /* DDThunk16_GetFlipStatus */

/****************************************************************************
 *
 * PALETTE CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * DDThunk16_DestroyPalette
 */
DWORD DDAPI DDThunk16_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA lpDestroyPaletteData )
{
    return lpDestroyPaletteData->DestroyPalette( lpDestroyPaletteData );

} /* DDThunk16_CreateSurface */

/*
 * DDThunk16_SetEntries
 */
DWORD DDAPI DDThunk16_SetEntries( LPDDHAL_SETENTRIESDATA lpSetEntriesData )
{
    return lpSetEntriesData->SetEntries( lpSetEntriesData );

} /* DDThunk16_CreateSurface */


/****************************************************************************
 *
 * PRIVATE HELPER FNS TO CALL PRIVATE 16-BIT SERVICES
 *
 ***************************************************************************/

/*
 * DD16_SelectPalette
 */
void DDAPI DD16_SelectPalette( HDC hdc, HPALETTE hpal, BOOL f )
{
    extern HANDLE FAR PASCAL GDISelectPalette(HDC,HANDLE,BOOL);
    extern DWORD FAR PASCAL GDIRealizePalette(HDC);

    GDISelectPalette( hdc, hpal, f );
    GDIRealizePalette( hdc );

} /* DD16_SelectPalette */

BOOL (FAR PASCAL *OEMSetPalette)( WORD wStartIndex, WORD wNumEntries, LPPALETTEENTRY lpPalette );

// Special hooks so we can do the right thing on Multi-mon systems
// And also so we can get the PDevice from the Dc.
#define SD_GETPDEV      0x000F      // this constant lives in testing.h!
extern DWORD PASCAL GDISeeGDIDo(WORD wMsg, WORD wParam, LONG lParam);
#define GethModuleFromDC(hdc) (HMODULE)HIWORD(GDISeeGDIDo(SD_GETPDEV, (WORD)hdc, 0))
#define GetPDeviceFromDC(hdc)    (UINT)LOWORD(GDISeeGDIDo(SD_GETPDEV, (WORD)hdc, 0))

/*
 * DD16_SetPaletteEntries
 */
BOOL DDAPI DD16_SetPaletteEntries(
		HDC hdc,
		DWORD dwBase,
		DWORD dwNumEntries,
		LPPALETTEENTRY lpColorTable,
		BOOL fPrimary )
{
    HMODULE     hmod;
    #ifdef DEBUG
	UINT        rc;

	rc = GetDeviceCaps( hdc, RASTERCAPS );

	if( !(rc & RC_PALETTE) )
	{
	    DPF_ERR( "DD16_SetPaletteEntries: not a paletized mode" );
            _asm int 3
	    return FALSE;
	}
	if( lpColorTable == NULL )
	{
	    DPF_ERR( "DD16_SetPaletteEntries: lpColorTable == NULL" );
            _asm int 3
	    return FALSE;
	}
	if( dwBase >= 256 || dwBase + dwNumEntries > 256 || dwNumEntries == 0 )
	{
            DPF_ERR( "DD16_SetPaletteEntries: bad params passed" );
            _asm int 3
	    return FALSE;
	}

    #endif

    if( fPrimary )
    {
	DWORD pDevice = 0;
	if( OEMSetPalette == NULL )
	{
	    hmod = GetModuleHandle( "DISPLAY" );
	    if( hmod == NULL )
	    {
		return FALSE;
	    }
	    OEMSetPalette = (LPVOID) GetProcAddress( hmod, MAKEINTATOM(22) );
	    if( OEMSetPalette == NULL )
	    {
		return FALSE;
	    }
	}

	// WARNING: Don't change anything from here to the end of the function without
	// checking the assembly!

	// ToddLa says that we need to put the pdevice into EDX before
	// making this call. It will matter for advanced video hardware
	// that supports multiple different external ports.
	pDevice = (DWORD) GetPDevice(hdc);
	_asm
	{
	    ;; The following line of code is actually
	    ;; mov edx, dword ptr pDevice
	    ;; The 16-bit compiler we have can't deal with such complexities
	    _emit 66h _asm mov dx, word ptr pDevice        ;edx = pDevice
	}
	return OEMSetPalette( (WORD) dwBase, (WORD) dwNumEntries, lpColorTable );
    }
    else
    {
	BOOL (FAR PASCAL *OEMSetPaletteTmp)( WORD wStartIndex, WORD wNumEntries, LPPALETTEENTRY lpPalette );
	DWORD pDevice = 0;
	DWORD dwGDI;
	BOOL wasPrivate;
	extern BOOL WINAPI MakeObjectPrivate(HANDLE hObj, BOOL bPrivate);

	// Not the primary? Then we need to get the module handle
	// by asking GDI. (This doesn't work in Win95 however, so this should
	// only be happening on Multi-mon systems.)

	DPF( 4, "About to set the palette for non-primary device." );

	wasPrivate = MakeObjectPrivate( hdc, TRUE );

	dwGDI = GDISeeGDIDo(SD_GETPDEV, (WORD)hdc, 0);

	MakeObjectPrivate( hdc, wasPrivate );

	if( dwGDI == -1 )
	{
	    DPF_ERR( "GDIGetModuleHandle failed!. Couldn't set palette" );
	    return FALSE;
	}

	hmod = (HMODULE)HIWORD(dwGDI);

	// Got the module?
	if( hmod == NULL )
	{
	    DPF_ERR( "GDIGetModuleHandle failed!. Couldn't set palette" );
	    return FALSE;
	}

	// Now go get the entrypoint:
	OEMSetPaletteTmp = (LPVOID) GetProcAddress( hmod, MAKEINTATOM(22) );
	if( OEMSetPaletteTmp == NULL )
	{
	    DPF_ERR( "GetProcAddress failed!. Couldn't set palette" );
	    return FALSE;
	}

	// WARNING: Don't change anything from here to the end of the function without
	// checking the assembly!

	// ToddLa says that we need to put the pdevice into EDX before
	// making this call. It will matter for advanced video hardware
	// that supports multiple different external ports.
        pDevice = (DWORD)(UINT)LOWORD(dwGDI) << 16;
	_asm
	{
	    ;; The following line of code is actually
	    ;; mov edx, dword ptr pDevice
	    ;; The 16-bit compiler we have can't deal with such complexities
	    _emit 66h _asm mov dx, word ptr pDevice        ;edx = pDevice
	}
	return OEMSetPaletteTmp( (WORD) dwBase, (WORD) dwNumEntries, lpColorTable );
    }


} /* DD16_SetPaletteEntries */

#define REBOOT_DEVICE_ID    9
#define REBOOT_DISABLE      0x0101
#define REBOOT_ENABLE       0x0102

/*
 * doEnableReboot
 */
static void PASCAL doEnableReboot( UINT EnableDisableFlag )
{
    _asm
    {
        xor     di,di
        mov     es,di
        mov     ax,1684h
        mov     bx,REBOOT_DEVICE_ID
        int     2fh
        mov     ax,es
        or      ax,di
        jz      exit
        push    cs
        push    offset exit
        push    es
        push    di
        mov     ax, EnableDisableFlag
        retf
exit:
    }

} /* doEnableReboot */

/*
 * DD16_EnableReboot
 */
void DDAPI DD16_EnableReboot( BOOL enable )
{
    if( enable )
    {
	doEnableReboot( REBOOT_ENABLE );
    }
    else
    {
	doEnableReboot( REBOOT_DISABLE );
    }

} /* DD16_EnableReboot */

/*
 * DD16_InquireVisRgn
 */
HRGN DDAPI DD16_InquireVisRgn( HDC hdc )
{
    extern HRGN WINAPI InquireVisRgn(HDC hdc);

    return InquireVisRgn( hdc );

} /* DD16_InquireVisRgn */

/*
 * DDThunk16_ColorControl
 */
DWORD DDAPI DDThunk16_ColorControl( LPDDHAL_COLORCONTROLDATA lpColorData )
{
    return lpColorData->ColorControl( lpColorData );

} /* DDThunk16_ColorControl */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\gdihelp.h ===
////////////////////////////////////////////////////////////////////////
//
// GDIHELP.H  - GDI TOOLHELP FUNCTIONS
//
// a bunch of GDI utility functions that are usefull for walking
// all GDI objects and dinking with them.
//
// ToddLa
//
////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

////////////////////////////////////////////////////////////////////////
//
// object enumeration functions
//
////////////////////////////////////////////////////////////////////////

#define OBJ_PEN          1
#define OBJ_BRUSH        2
#define OBJ_FONT         3
#define OBJ_PALETTE      4
#define OBJ_BITMAP       5
#define OBJ_RGN          6
#define OBJ_DC           7
#define OBJ_DISABLED_DC  8
#define OBJ_METADC       9
#define OBJ_METAFILE     10
#define OBJ_SAVEDC       42
#define OBJ_MAX          OBJ_SAVEDC

BOOL        BeginGdiSnapshot(void);
void        EndGdiSnapshot(void);

typedef     void (*EnumGdiObjectsCallback)(HGDIOBJ, LPARAM lParam);
void        EnumGdiObjects(UINT type, EnumGdiObjectsCallback callback, LPARAM lParam);

////////////////////////////////////////////////////////////////////////
//
// query information functions
//
////////////////////////////////////////////////////////////////////////

HBITMAP     StockBitmap(void);
BOOL        IsMemoryDC(HDC hdc);
BOOL        IsScreenDC(HDC hdc);
BOOL        IsObjectPrivate(HGDIOBJ h);
BOOL        IsObjectStock(HGDIOBJ h);

HANDLE      GetObjectOwner(HGDIOBJ h);
LPCSTR      GetObjectOwnerName(HGDIOBJ h);

HBITMAP     CurrentBitmap(HDC hdc);
HBRUSH      CurrentBrush(HDC hdc);
HPEN        CurrentPen(HDC hdc);
HPALETTE    CurrentPalette(HDC hdc);

HDC         GetBitmapDC(HBITMAP hbm);
HPALETTE    GetBitmapPalette(HBITMAP hbm);

////////////////////////////////////////////////////////////////////////
//
// conversion functions.
//
////////////////////////////////////////////////////////////////////////

HBITMAP     ConvertDDBtoDS(HBITMAP hbm);
HBITMAP     ConvertDStoDDB(HBITMAP hbm, BOOL fForceConvert);
HBRUSH      ConvertPatternBrush(HBRUSH hbr);
void        ConvertIcon(HICON hIcon);

void        ConvertObjects(void);
void        ConvertObjectsBack(void);
void        ConvertBitmapsBack(BOOL fForceConvert);

void        ReRealizeObjects(void);

LPVOID      GetPDevice(HDC hdc);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\libinit.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
;
;   File:       libinit.asm
;   Content:    DLL entry point - used to avoid dragging in CLIB
;   History:
;    Date	By	Reason
;    ====	==	======
;    29-mar-95	craige	initial implementation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        .286p

        .xlist
        include cmacros.inc
        .list

?PLM=1  ; Pascal calling convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   segmentation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   external functions
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externFP LocalInit           ; in KERNEL
        externFP LibMain             ; C code to do DLL init

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   data segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sBegin Data

        assumes ds, Data

; stuff needed to avoid the C runtime coming in, and init the Windows
; reserved parameter block at the base of DGROUP

        org 0               ; base of DATA segment!

        dd  0               ; so null pointers get 0

maxRsrvPtrs = 5
        dw  maxRsrvPtrs

usedRsrvPtrs = 0
labelDP <PUBLIC, rsrvptrs>

DefRsrvPtr  macro   name
        globalW     name, 0
        usedRsrvPtrs = usedRsrvPtrs + 1
endm

DefRsrvPtr  pLocalHeap          ; local heap pointer
DefRsrvPtr  pAtomTable          ; atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
        dw maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
        __acrtused = 1

sEnd Data

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

sBegin CodeSeg

        assumes cs, CodeSeg

public LibEntry
LibEntry PROC FAR

        ; push frame for LibMain (hModule, cbHeap, lpszCmdLine)

        push di
        push cx
        push es
        push si

        ; init the local heap (if one is declared in the .def file)

        jcxz no_heap

        cCall LocalInit, <0, 0, cx>

no_heap:
        cCall LibMain
	
	ret

LibEntry ENDP

sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\modenot.c ===
//=============================================================================
//
//  Copyright (C) 1997 Microsoft Corporation. All rights reserved.
//
//     File:  modenot.c
//  Content:  16-bit display mode change notification handling
//
//  Date        By        Reason
//  ----------  --------  -----------------------------------------------------
//  08/27/1997  johnstep  Initial implementation
//
//=============================================================================

#include "ddraw16.h"

#define MODECHANGE_BEGIN    1
#define MODECHANGE_END      2
#define MODECHANGE_ENABLE   3
#define MODECHANGE_DISABLE  4

//=============================================================================
//
//  Function: ModeChangeNotify
//
//  This exported function is called by name by User for display mode changes,
//  including enabling and disabling the display.
//
//  Parameters:
//
//      UINT code [IN] - one of the following values:
//          MODECHANGE_BEGIN
//          MODECHANGE_END
//          MODECHANGE_ENABLE
//          MODECHANGE_DISABLE
//
//      LPDEVMODE pdm [IN] - includes the name of the display device
//
//      DWORD flags [IN] - CDS flags
//
//  Return:
//
//      FALSE to prevent display settings to change
//
//=============================================================================

BOOL WINAPI _loadds ModeChangeNotify(UINT code, LPDEVMODE pdm, DWORD flags)
{
    extern BOOL DDAPI DD32_HandleExternalModeChange(LPDEVMODE pdm);

    DPF(9, "ModeChangeNotify: %d (Device: %s)", code, pdm->dmDeviceName);
    
    switch (code)
    {
    case MODECHANGE_BEGIN:
    case MODECHANGE_DISABLE:
        return DD32_HandleExternalModeChange(pdm);
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\libmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       libmain.c
 *  Content:	entry points in the DLL
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   03-jul-95	craige	export instance handle
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddraw16.h"

// in gdihelp.c
extern void GdiHelpCleanUp(void);
extern BOOL GdiHelpInit(void);

// in modex.c
extern UINT ModeX_Width;

extern WORD hselSecondary;

HINSTANCE	hInstApp;
HGLOBAL         hAlloc = 0;

int FAR PASCAL LibMain(HINSTANCE hInst, WORD wHeapSize, LPCSTR lpCmdLine)
{
    hInstApp = hInst;
    pWin16Lock = GetWin16Lock();
    GdiHelpInit();
    DPFINIT();
    hAlloc = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, 65536); 
    hselSecondary = (WORD) hAlloc;
    if( hselSecondary )
    {
        LocalInit(hselSecondary, 16, 65536-4);  // Keep DWORD aligned
    }

    return 1;
}

BOOL FAR PASCAL _loadds WEP( WORD wParm )
{
    DPF( 1, "WEP" );

    //
    // clean up DCI
    //
    if( wFlatSel )
    {
        VFDEndLinearAccess();
        SetSelLimit( wFlatSel, 0 );
        FreeSelector( wFlatSel );
        wFlatSel = 0;
    }

    if( hAlloc )
    {
        GlobalFree( hAlloc );
    }

    //
    // let gdihelp.c cleaup global objects
    //
    GdiHelpCleanUp();

    //
    // if we are still in ModeX, leave now
    //
    if( ModeX_Width )
    {
        ModeX_RestoreMode();
    }

    return 1;
}

extern BOOL FAR PASCAL thk3216_ThunkConnect16( LPSTR pszDll16, LPSTR pszDll32, WORD  hInst, DWORD dwReason);
extern BOOL FAR PASCAL thk1632_ThunkConnect16( LPSTR pszDll16, LPSTR pszDll32, WORD  hInst, DWORD dwReason);

#define DLL_PROCESS_ATTACH 1    
#define DLL_THREAD_ATTACH  2    
#define DLL_THREAD_DETACH  3    
#define DLL_PROCESS_DETACH 0

static char __based(__segname("LIBMAIN_TEXT"))  szDll16[] = DDHAL_DRIVER_DLLNAME;
static char __based(__segname("LIBMAIN_TEXT"))  szDll32[] = DDHAL_APP_DLLNAME;

BOOL FAR PASCAL __export DllEntryPoint(
		DWORD dwReason,
		WORD  hInst,
		WORD  wDS,
		WORD  wHeapSize,
		DWORD dwReserved1,
		WORD  wReserved2)
{
    DPF( 1, "DllEntryPoint: dwReason=%ld, hInst=%04x, dwReserved1=%08lx, wReserved2=%04x",
                dwReason, hInst, wDS, dwReserved1, wReserved2 );

    if( !thk3216_ThunkConnect16( szDll16, szDll32, hInst, dwReason))
    {
        return FALSE;
    }
    if( !thk1632_ThunkConnect16( szDll16, szDll32, hInst, dwReason))
    {
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:	allocates memory; uses global blocks and sub-allocates
 *		out of those using LocalAlloc
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   29-dec-94	craige	initial implementation
 *   12-jan-95	craige	use clib as an option
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddraw16.h"

#if 0
#define USE_CLIB

#ifdef USE_CLIB
#include <malloc.h>
#else
#define GLOBAL_BLOCK_SIZE	32768

typedef struct _HEAPLIST
{
    struct _HEAPLIST	FAR *lpLink;
    WORD		wSel;
    GLOBALHANDLE	hMem;
} HEAPLIST, FAR *LPHEAPLIST;

static LPHEAPLIST	lphlHeap;

/*
 * tryAlloc - try to allocate from a heap
 */
static LPVOID tryAlloc( WORD sel, WORD size )
{
    void	NEAR *ptr;

    _asm push ds
    _asm mov ax, sel
    _asm mov ds, ax
    ptr = (void NEAR *) LocalAlloc( LPTR, size );
    _asm pop ds
    if( ptr == (void NEAR *) NULL )
    {
	return (void FAR *) NULL;
    }
    return MAKELP( sel, ptr );

} /* tryAlloc */
#endif

#ifdef DEBUG
LONG	lAllocCount;
#endif

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID MemAlloc( UINT size )
{
    LPVOID		lptr;
    #ifndef USE_CLIB
	LPHEAPLIST	curr;
	GLOBALHANDLE	gh;
	LPVOID		lpnew;
	WORD		sel;
    #endif

    #ifdef DEBUG
    	lAllocCount++;
    #endif

    #ifdef USE_CLIB
	lptr = _fmalloc( size );
	if( lptr != NULL )
	{
	    _fmemset( lptr, 0, size );
	}
	else
	{
	    DPF( 1, "Alloc of size %u FAILED!", size );
	}
	return lptr;
    #else
    
	/*
	 * run our current list of GlobalAlloc'ed chunks
	 */
	curr = lphlHeap;
	while( curr != NULL )
	{
	    lptr = tryAlloc( curr->wSel, size );
	    if( lptr != (LPVOID) NULL )
	    {
		return lptr;
	    }
	    curr = curr->lpLink;
	}
    
	/*
	 * no luck, allocate a new global chunk
	 */
	gh = GlobalAlloc( GMEM_SHARE | GMEM_MOVEABLE, GLOBAL_BLOCK_SIZE );
	if( gh == NULL )
	{
	    return NULL;
	}
	lpnew = GlobalLock( gh );
	if( lpnew == NULL )
	{
	    GlobalFree( gh );
	    return NULL;
	}
    
	/*
	 * set up a local heap in this new global chunk
	 */
	sel = SELECTOROF( lpnew );
	if( !LocalInit( sel, 0, GLOBAL_BLOCK_SIZE-1 ) )
	{
	    GlobalUnlock( gh );
	    GlobalFree( gh );
	    return NULL;
	}
	/*
	 * chain this new heap into our list
	 */
	curr = tryAlloc( sel, sizeof( HEAPLIST ) );
	if( curr == NULL )
	{
	    return NULL;
	}
	curr->wSel = sel;
	curr->hMem = gh;
	curr->lpLink = lphlHeap;
	lphlHeap = curr;
    
	/*
	 * go allocate the original request
	 */
	return tryAlloc( sel, size );
    #endif

} /* MemAlloc */

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
    #ifdef USE_CLIB
	_ffree( lptr );
    #else
	WORD	sel;
    
	if( lptr != (LPVOID) NULL )
	{
	    sel = SELECTOROF( lptr );
	    _asm push ds
	    _asm mov ax,sel
	    _asm mov ds,ax
	    LocalFree( OFFSETOF( lptr ) );
	    _asm pop ds
	}
    #endif
    #ifdef DEBUG
    	if( lptr != NULL )
	{
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
    #endif

} /* MemFree */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    #ifndef USE_CLIB
	lphlHeap = NULL;
    #endif
    #ifdef DEBUG
    	lAllocCount = 0;
    #endif
    return TRUE;

} /* MemInit */

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
    #ifdef DEBUG
    	if( lAllocCount != 0 )
	{
	    DPF( 1, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	}
    #endif
    #ifndef USE_CLIB
	LPHEAPLIST		curr;
	LPHEAPLIST		last;
	GLOBALHANDLE	gh;
    
	curr = lphlHeap;
	while( curr != NULL )
	{
	    gh = curr->hMem;
	    last = curr->lpLink;
    //	    GlobalUnfix( gh );
	    GlobalUnlock( gh );
	    GlobalFree( gh );
	    curr = last;
	}
	lphlHeap = NULL;
    #endif
} /* MemFini */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\modex.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	modex.c
 *  Content:	16-bit DirectDraw HAL
 *		These routines redirect the callbacks from the 32-bit
 *		side to the driver
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-aug-95	craige	initial implementation (from dispdib)
 *   10-sep-95  toddla  set/clear the BUSY bit for poor drivers
 *   21-sep-95	craige	bug 1215: use Death/Resurrection for uncertified
 *			drivers only
 *   15-dec-96  jeffno  added more modex modes
 *
 ***************************************************************************/

#include "ddraw16.h"

// in gdihelp.c
extern BOOL bInOurSetMode;
extern UINT FlatSel;
extern DIBENGINE FAR *pdeDisplay;

// in DIBENG
extern void FAR PASCAL DIB_SetPaletteExt(UINT, UINT, LPVOID, DIBENGINE FAR *);

UINT ModeX_Width;
UINT ModeX_Height;

/*
 * IsVGA
 */
BOOL IsVGA()
{
    BOOL f = FALSE;

    _asm
    {
        mov     ax,1A00h                ; Read display combination code
        int     10h
        cmp     al,1Ah                  ; Is function supported?
        jne     NoDisplaySupport

    ; BL should contain active display code, however, on some VGA cards this
    ; call will return the active display in BH.  If BL is zero, BH is assumed to
    ; contain the active display.  This assumes that the only display attached is
    ; then the active display.

        or      bl,bl                   ; Is there an active display?
        jnz     CheckActiveDisplay      ; Yes, then continue on normaly.
        mov     bl,bh                   ; No, then move bh to bl.
        or      bl,bl                   ; Is anything supported?
        jz      NoDisplaySupport

    CheckActiveDisplay:
        cmp     bl,07h                  ; VGA with monochrome display
        je      SetMCGAPresent
        cmp     bl,08h                  ; VGA with color display
        je      SetMCGAPresent
        cmp     bl,0Bh                  ; MCGA with monochrome display
        je      SetMCGAPresent
        cmp     bl,0Ch                  ; MCGA with color display
        jne     NoDisplaySupport

    SetMCGAPresent:
        inc     f                       ; _bMCGAPresent = TRUE

    NoDisplaySupport:

    }

    return f;
}

/*
 * ModeX_Flip
 */
extern WORD ScreenDisplay;
LONG DDAPI ModeX_Flip( DWORD lpBackBuffer )
{
    if( ModeX_Width == 0 )
    {
        DPF(1, "ModeX_Flip: called while not in ModeX!");
        DEBUG_BREAK();
        return DDERR_GENERIC;
    }

    /* PixBlt requires:
     *  -start aligned on DWORD
     *  -width a multiple of 32 OR mutliple of 32 with 8 remaining (i.e. 360x)
     */
    DDASSERT( (ModeX_Width & 0x3)==0 );
    DDASSERT( ((ModeX_Width & 0x1f)==0) || ((ModeX_Width & 0x1f)==8) );
    PixBlt(ModeX_Width,ModeX_Height,MAKELP(FlatSel, 0),lpBackBuffer,ModeX_Width);
    /*
     * We only do the multiple buffering if two buffers will fit in the VGA frame
     * buffer. If not, then it's blt to the visible primary on every Flip.
     * We implement this by not calling FlipPage so our internal idea of which
     * physical page is the back buffer remains the same (i.e. pointing to the
     * front buffer).
     * FlipPage is actually very clever and will refuse to flip if two pages
     * exceed 64k. Since this is setdisplaymode, something of an essential OS
     * service, I'm going to be extra paranoid and do the check here as well.
     * We are working with words, so group operations to avoid overflow.
     * Note that FlipPage is smart enough to do triple buffering if a page is less
     * than 64k/3 (as it is in the x175 nodes(. If we ever implement a scheme 
     * whereby the app can specify dirty subrects to copy (either on flip or by blt) 
     * we'll have to let them know the difference between single-, double- and 
     * triple-buffering or else their idea of what's on the primary could get out of
     * sync.
     */
    if ( (ModeX_Width/4)*ModeX_Height < 32768 ) /* i.e two pages would be < 64k */
    {
        DPF(5,"ModeX_Flip called, display offset is %08x",ScreenDisplay);
        FlipPage();
    }

    return DD_OK;

} /* ModeX_Blt */

#define MODEX_HACK_ENTRY		"AlternateLowResInit"

static BOOL	bCertified;

/*
 * useDeathResurrection
 */
static BOOL useDeathResurrection( void )
{
    int	rc;
    /*
     * is a value specified? if not, use certified bit
     */
    rc =  GetProfileInt( "DirectDraw", MODEX_HACK_ENTRY, -99 );
    if( rc == -99 )
    {
	DPF( 3, "useDeathResurrection = %d", !bCertified );
	return !bCertified;
    }

    /*
     * use ini file entry
     */
    DPF( 3, "OVERRIDE: useDeathResurrection = %d", rc );
    return rc;

} /* useDeathResurrection */


/*
 * patchReg
 */
static WORD patchReg( WORD bpp )
{
    HKEY	 hkey;

    DPF( 3, "patching HKEY_CURRENT_CONFIG\\Display\\Settings\\BitsPerPixel" );

    if( !RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &hkey) )
    {
	char	str[20];
	DWORD	cb;
	
       	if( bpp == 0 )
	{
	    str[0] = 0;
	    cb = sizeof( str );
	    if( !RegQueryValueEx( hkey, "BitsPerPixel", NULL, NULL, str, &cb ) )
	    {
		bpp = atoi( str );
		DPF( 3, "BitsPerPixel of display is \"%s\" (%d)", str, bpp );
		strcpy( str, "8" );
	    }
	}
	else
	{
	    _itoa( bpp, str, 10 );
	}
	if( bpp != 0 )
	{
	    DPF( 3, "Setting BitsPerPixel of display to \"%s\"", str );
	    RegSetValueEx( hkey, "BitsPerPixel", 0, REG_SZ,
	    			(CONST LPBYTE)str, strlen( str ) );
	}
	RegCloseKey( hkey );
    }
    else
    {
	bpp = 0;
    }
    return bpp;

} /* patchReg */


/*
 * DD16_SetCertified
 */
void DDAPI DD16_SetCertified( BOOL iscert )
{
    bCertified = (BOOL) iscert;

} /* DD16_SetCertified */

/*
 * ModeX_SetMode
 */
LONG DDAPI ModeX_SetMode( UINT wWidth, UINT wHeight, UINT wStandardVGAFlag )
{
    LONG lResult = DD_OK;

    if ( (wWidth != 320) && (wWidth != 360) )
    {
        DPF(1, "ModeX_SetMode: %dx%d is an invalid mode!",wWidth,wHeight);
        return DDERR_INVALIDMODE;
    }
    if ( (wHeight != 175) && (wHeight != 200) && (wHeight != 240) &&
         (wHeight != 350) && (wHeight != 400) && (wHeight != 480) )
    {
        DPF(1, "ModeX_SetMode: %dx%d is an invalid mode!",wWidth,wHeight);
        return DDERR_INVALIDMODE;
    }

    if (!IsVGA())
    {
        DPF(1, "not a VGA");
        return DDERR_INVALIDMODE;
    }

    ModeX_Width  = wWidth;
    ModeX_Height = wHeight;

    bInOurSetMode = TRUE;

    _asm
    {
        mov     ax, 4001h
        int     2fh         ; notify background switch
    }

    if( useDeathResurrection() )
    {
	extern FAR PASCAL Death( HDC );
        HDC hdc = GetDC( NULL );
	DPF( 4, "Calling driver Disable" );

        _asm _emit 0x66 _asm _emit 0x60 ; pushad
        Death( hdc );
        _asm _emit 0x66 _asm _emit 0x61 ; popad

	ReleaseDC( NULL, hdc );
    }

    //
    //  after calling disable the BUSY bit better be set
    //  some display driver people thew out our sample code
    //  and rewrote it, and made it "better"
    //
    if (pdeDisplay && !(pdeDisplay->deFlags & BUSY))
    {
        DPF(1, "*** GIVE ME A GUN, NOW!, I WANT TO SHOOT SOMEONE ***");
        pdeDisplay->deFlags |= BUSY;
    }

    DPF( 5, "ModeX_SetMode(%d,%d, VGAFlag:%d)", wWidth, wHeight, wStandardVGAFlag);

    /*
    if (wHeight == 200)
        SetMode320x200x8();
    else if (wHeight == 240)
        SetMode320x240x8();
    else
        SetMode320x400x8();
        */
    if ( wStandardVGAFlag )
    {
        /*
         * Call BIOS to do set mode 013h. Assume successful.
         */
        _asm 
        {
            mov     ax,12h
            int     10h                     ; have BIOS clear memory

            mov     ax,13h                  ; set display mode 320x200x8
            int     10h
        }
    }
    else
    {
        lResult = SetVGAForModeX( wWidth, wHeight );
    }

    bInOurSetMode = FALSE;

    return lResult;

} /* ModeX_Enter */

/*
 * ModeX_Leave
 */
LONG DDAPI ModeX_RestoreMode( void )
{
    if (ModeX_Width == 0)
    {
        DPF(1, "ModeX_RestoreMode: not in ModeX!");
        return DDERR_GENERIC;
    }

    DPF( 4, "Leaving ModeX" );

    ModeX_Width = 0;
    ModeX_Height = 0;

    bInOurSetMode = TRUE;

    _asm
    {
        mov     ax, 0003h   ; text mode
        int     10h
    }

    if( useDeathResurrection() )
    {
	WORD	bpp;
	HDC	hdc;
	extern void FAR PASCAL Resurrection(HDC, LONG, LONG, LONG);
	bpp = patchReg( 0 );
        hdc = GetDC( NULL );
	DPF( 4, "Calling driver Enable" );

        _asm _emit 0x66 _asm _emit 0x60 ; pushad
        Resurrection( hdc, 0, 0, 0 );
        _asm _emit 0x66 _asm _emit 0x61 ; popad

	ReleaseDC( NULL, hdc );
	patchReg( bpp );
    }

    _asm
    {
        mov     ax, 4002h   ; notify foreground
        int     2fh
    }

    //
    //  after calling enable the BUSY bit better be clear
    //  some display driver people thew out our sample code
    //  and rewrote it, and made it "better"
    //
    if (pdeDisplay && (pdeDisplay->deFlags & BUSY))
    {
        DPF(1, "*** GIVE ME A GUN, NOW!, I WANT TO SHOOT SOMEONE ***");
        pdeDisplay->deFlags &= ~BUSY;
    }

    bInOurSetMode = FALSE;

} /* ModeX_Leave */

/*
 * ModeX_SetPaletteEntries
 */
LONG DDAPI ModeX_SetPaletteEntries(UINT wBase, UINT wNumEntries, LPPALETTEENTRY lpColorTable)
{
#ifdef DEBUG
    if (ModeX_Width == 0)
    {
        DPF(0, "ModeX_SetPaletteEntries: not in ModeX!!!");
        DEBUG_BREAK();
        return DDERR_GENERIC;
    }
#endif

    //
    // call the DIBENG so it can update the color table is uses for
    // colr matching.
    //
    if (pdeDisplay)
    {
       DIB_SetPaletteExt(wBase, wNumEntries, lpColorTable, pdeDisplay);
    }

    //
    // now program the hardware DACs
    //
    SetPalette(wBase, wNumEntries, lpColorTable);

    return DD_OK;

} /* ModeX_SetPaletteEntries */

/*============================================================================*
  New ModeX mode-set code.

  This code can manage horizontal resolutions of 320 or 360, with vertical
  resolutions of 175, 200, 240, 350, 400 and 480.

  This chart shows the operations necessary to set each of these modes, and
  the order in which these operations are done.
  Read the chart from top to bottom for a given vertical resolution, doing
  what's appropriate at each operation for the chosen horizontal resolution.

Vertical Res:| 175     200     240     350     400     480   Horizontal
             |                                               Resolution
Operation    |
-------------+-----------------------------------------------------------------
             |
Call int 10h |  ....................... ALL ...........................
             |
Reset CRT and|
put this in  |  a3      No      e3      a3      No      e3      320
MISC_OUTPUT  |  a7      67      e7      a7      67      e7      360
             |
Disable Chain|  ....................... ALL ...........................
             |
CRT_INDEX    |  ....................... ALL ...........................
"tweak"      |
             |
Set 360      |  ........................ NO ..............      320  DUHH!!!!
             |  ........................ YES .............      360
             |
Set Vertical |
             |
Which table? |  350*    None    480*    350     None    480     Both horz. res's.
             |

  * There are two tables defining how registers are to be munged to set a new
  vertical mode; one for 350 and one for 480. To set half this vertical resolution,
  skip the first entry in the table (which sets CRT_INDEX 9 to 0x40
 *============================================================================*/

#define SC_INDEX    0x3c4
#define CRT_INDEX   0x3d4
#define MISC_OUTPUT 0x3c2

/*
 * These def's are to make port to NT painless...
 */
#define WRITE_PORT_USHORT(port,value) {\
 DPF(5,"out %04x,%04x",port,value);_outpw(port,value);\
 _asm push ax         \
 _asm pop  ax         \
 _asm push ax         \
 _asm pop  ax         \
}

#define WRITE_PORT_UCHAR(port,value) {\
 DPF(5,"out %04x,%02x",port,value);_outp(port,value);\
 _asm push ax         \
 _asm pop  ax         \
 _asm push ax         \
 _asm pop  ax         \
}

static WORD wCRT_Tweak[] = {
    0x0014,         /* Turn off DWORD mode                  */
    0xe317          /* Turn on BYTE mode                    */
};
#define NUM_CRT_Tweak (sizeof(wCRT_Tweak)/sizeof(wCRT_Tweak[0]))

static WORD wCRT_Set360Columns[] = {
    0x6b00,         /* Horizontal total         107 */
    0x5901,         /* Horizontal display end   89  */
    0x5a02,         /* Start horizontal blank   90  */
    0x8e03,         /* End horizontal blank         */
    0x5e04,         /* Start horizontal retrace 94  */
    0x8a05,         /* End horizontal retrace       */
    0x2d13          /* Offset register          90  */
};
#define NUM_CRT_Set360Columns (sizeof(wCRT_Set360Columns)/sizeof(wCRT_Set360Columns[0]))

static WORD wCRT_Set175Lines[] = {
    0x1f07,         /* Overflow register            */
    0xbf06,         /* Vertical total           447 */
    0x8310,         /* Vertical retrace start   387 */
    0x8511,         /* Vertical retrace end         */
    0x6315,         /* Start vertical blanking  355 */
    0xba16,         /* End vertical blanking        */
    0x5d12          /* Vertical display end     349 */
};
#define NUM_CRT_Set175Lines (sizeof(wCRT_Set175Lines)/sizeof(wCRT_Set175Lines[0]))


static WORD wCRT_Set240Lines[] = {
    0x0d06,         /* Vertical total           523 */
    0x3e07,         /* Overflow register            */
    0xea10,         /* Vertical retrace start   490 */
    0xac11,         /* Vertical retrace end         */
    0xdf12,         /* Vertical display end     479 */
    0xe715,         /* Start vertical blanking  487 */
    0x0616         /* End vertical blanking        */
};
#define NUM_CRT_Set240Lines (sizeof(wCRT_Set240Lines)/sizeof(wCRT_Set240Lines[0]))

void BatchSetVGARegister(UINT iRegister, LPWORD pWordArray, int iCount)
{
    int i;
    for (i = 0; i< iCount; i++)
    {
        WRITE_PORT_USHORT(iRegister,pWordArray[i]);
    }
}

/*
 * The routines in mvgaxx.asm expect these two initialised.
 * These externs MUST stay in sync with what's in mvgaxx.asm.
 */
extern WORD ScreenOffset;
extern WORD cdwScreenWidthInDWORDS;
/*
 * This must be a multiple of 256
 */
extern WORD cbScreenPageSize;

LONG SetVGAForModeX(UINT wWidth, UINT wHeight)
{
    BOOL    bIsXHundredMode = FALSE;
    BOOL    bIsStretchedMode = FALSE;
    LPWORD  pwVerticalTable;
    UINT    cwVerticalCount;
    
    /*
     * These three are required by routines in mvgaxx.asm
     */
    ScreenOffset = 0;
    ScreenDisplay = 0;
    cdwScreenWidthInDWORDS = wWidth/4;

    /*
     * Page size must be a multiple of 256 as required by
     * FlipPage in vgaxx.asm
     */
    cbScreenPageSize = (wWidth/4 * wHeight + 0xff) & (~0xff) ;
    DDASSERT( (cbScreenPageSize & 0xff) == 0);

    DPF(5,"SetVGAForModeX called (%d,%d)",wWidth,wHeight);

    /*
     * First validate requested resolution
     */
    if ( (wWidth != 320) && (wWidth != 360) )
    {
        return DDERR_UNSUPPORTEDMODE;
    }
    if (
        (wHeight != 175) &&
        (wHeight != 200) &&
        (wHeight != 240) &&
        (wHeight != 350) &&
        (wHeight != 400) &&
        (wHeight != 480) )
    {
        return DDERR_UNSUPPORTEDMODE;
    }

    /*
     * Setup some useful booleans
     */
    if ( (wHeight==200) || (wHeight==400) )
    {
        bIsXHundredMode = TRUE;
    }

    if ( (wHeight == 350) || (wHeight == 400) || (wHeight == 480) )
    {
        bIsStretchedMode = TRUE;
    }


    /*
     * The first step for any mode set is calling BIOS to do set mode 013h
     */
    _asm 
    {
        mov     ax,12h
        int     10h                     ; have BIOS clear memory

        mov     ax,13h                  ; set display mode 320x200x8
        int     10h
    }

    _asm
    {
        mov     dx,CRT_INDEX ;reprogram the CRT Controller
        mov     al,11h  ;VSync End reg contains register write
        out     dx,al   ; protect bit
        inc     dx      ;CRT Controller Data register
        in      al,dx   ;get current VSync End register setting
        and     al,7fh  ;remove write protect on various
        out     dx,al   ; CRTC registers
        dec     dx      ;CRT Controller Index
    }

    BatchSetVGARegister(CRT_INDEX, (LPWORD) wCRT_Tweak, NUM_CRT_Tweak);

    /*
     * Every ModeX mode needs Chain4 turned off etc.
     */
    DPF(5,"Set unchained");
    WRITE_PORT_USHORT(SC_INDEX,0x604);

    /*
     * For everything but 320x200 and 320x400 we need to reset the CRT and
     * reprogram the MISC_OUTPUT register
     */
    if ( ! ((wWidth == 320 ) && (bIsXHundredMode)) )
    {
        WORD wMISC;
        if ( (wHeight == 175) || (wHeight == 350) )
        {
            wMISC = 0xa3;
        }
        else if ( bIsXHundredMode )
        {
            wMISC = 0x63;
        }
        else
        {
            wMISC = 0xe3;
        }

        if ( wWidth == 360 )
        {
            wMISC |= 0x4;
        }

        /*
         * Set the dot clock...
         */
        DPF(5,"Setting dot clock");

        _asm cli;
        WRITE_PORT_USHORT(SC_INDEX,0x100);
        WRITE_PORT_UCHAR(MISC_OUTPUT,wMISC);
        WRITE_PORT_USHORT(SC_INDEX,0x300);
        _asm sti;
    } /* if required reset */

    /*
     * And now the magic scan stretch for 360x modes
     */
    if (wWidth == 360)
    {
        BatchSetVGARegister(CRT_INDEX, (LPWORD) wCRT_Set360Columns, NUM_CRT_Set360Columns);
    }

    /*
     * Now set the vertical resolution....
     * There are two tables, one for 240 and one for 175. We can set double these
     * heights by a single write of 0x40 to sequencer register 9. This trick
     * also works to stretch x200 into x400.
     */
    if (wHeight == 200)
    {
        /*
         * All done for 200 lines
         */
        return DD_OK;
    }

    if (bIsStretchedMode)
    {
        /*
         * Double the cell height for 350, 400 or 480 lines...
         */
        DDASSERT( wHeight == 350 || wHeight == 400 || wHeight == 480 );
        WRITE_PORT_USHORT(CRT_INDEX,0x4009); /* 0x40 into register 9 */
    }
    else
    {
        /*
         * Double the cell height for 350, 400 or 480 lines...
         */
        DDASSERT( wHeight == 175 || wHeight == 200 || wHeight == 240 );
        WRITE_PORT_USHORT(CRT_INDEX,0x4109); /* 0x41 into register 9 */
    }

    if (wHeight == 400)
    {
        /*
         * 400 is simply stretched 200, so we're done
         */
        return DD_OK;
    }

    if ( (wHeight == 175) || (wHeight == 350) )
    {
        pwVerticalTable = wCRT_Set175Lines;
        cwVerticalCount = NUM_CRT_Set175Lines;
    }
    else if ( (wHeight == 240) || (wHeight == 480) )
    {
        pwVerticalTable = wCRT_Set240Lines;
        cwVerticalCount = NUM_CRT_Set240Lines;
    }
#ifdef DEBUG
    else
    {
        DPF_ERR("Flow logic in SetVGAForModeX is wrong!!!");
        DDASSERT(FALSE);
        return DDERR_UNSUPPORTEDMODE;
    }
#endif

    /*
     *Just write the vertical info, and we're done
     */
    BatchSetVGARegister(CRT_INDEX, (LPWORD) pwVerticalTable, cwVerticalCount);

    return DD_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\makefile.inc ===
BuildType=retail
!if defined(NTDEBUG) && "$(NTDEBUG)" != "ntsdnodebug"
BuildType=debug
!endif


$(O)\$(TARGETNAME).dll: 
!ifdef LINKONLY
    @echo LINKONLY does nothing
!else
	@nmake -nologo -f DEFAULT.MK  DEBUG="$(BuildType)" PBIN=$(O)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\modex.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       modex.h
 *  Content:    DirectDraw modex support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-aug-95  craige  created
 *   22-aug-95  toddla  added this nifty comment block
 *   14-dec-96  jeffno  Added prototypes for new ModeX modeset code in modex.c
 *
 ***************************************************************************/

LONG DDAPI ModeX_SetMode(UINT wWidth, UINT wHeight, UINT wStandardVGAFlag );
LONG DDAPI ModeX_RestoreMode(void);
LONG DDAPI ModeX_SetPaletteEntries(UINT wBase, UINT wNumEntries, LPPALETTEENTRY lpColorTable);
LONG DDAPI ModeX_Flip(DWORD lpBackBuffer);

LONG SetVGAForModeX(UINT wWidth, UINT wHeight);

extern void NEAR PASCAL SetMode320x200x8(void);
extern void NEAR PASCAL SetMode320x240x8(void);
extern void NEAR PASCAL SetMode320x400x8(void);
extern void NEAR PASCAL SetPalette(int start, int count, void far *pPal);
extern void NEAR PASCAL PixBlt(int xExt, int yExt,char far *pBits, long offset, int WidthBytes);
extern void NEAR PASCAL FlipPage(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\mvgaxx.h ===
//
// Stuff from MVGAXX.asm
//

#define MODE_320x200x8          0
#define MODE_320x400x8          1
#define MODE_360x480x8          2
#define MODE_320x480x8          3
#define MODE_320x240x8          4
#define MODE_160x120x8          5
#define MODE_320x240x16         6

extern short pascal ScreenSel;

extern DWORD NEAR PASCAL SetMode(int mode);
extern void  NEAR PASCAL RestoreMode(void);
extern void  NEAR PASCAL FlipPage(void);
extern BOOL  NEAR PASCAL SetZoom(int);

extern void  NEAR PASCAL RleBlt(int x, int y, char far *pBits);
extern void  NEAR PASCAL PixBlt(int x, int y, int xExt, int yExt,char far *pBits, long offset, int WidthBytes);

extern void  NEAR PASCAL SetPalette(int start, int count, void far *pPal);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\w32event.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Copyright (c) 1995  Microsoft Corporation.  All Rights Reserved.
;
;   File:       w32event.asm
;   Content:    signal a win32 event
;   History:
;    Date	By	Reason
;    ====	==	======
;    19-jul-95	craige	initial implementation
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        .386p
	
Multimedia_OEM_ID           equ 0440h            ; MS Reserved OEM # 34
MMDEVLDR_Device_ID          equ Multimedia_OEM_ID + 10 ;MMDEVLDR's device ID

MMDEVLDR_API_SetEvent           equ 4                   ;Internal

_TEXT segment para public 'CODE' use16

        assume cs:_TEXT
	
extrn AllocCSToDSAlias: FAR
extrn FreeSelector: FAR 

	MMDEVLDR_Entry	dd	?	; the api entry point for mmdevldr
	

public _SetWin32Event
_SetWin32Event PROC FAR
        mov    dx, MMDEVLDR_API_SetEvent
	mov	ecx, [MMDEVLDR_Entry]
	jecxz	short mmdevldr_load
	jmp	[MMDEVLDR_Entry]
mmdevldr_load:
	push	dx			; save MMDEVLDR command ID
	push	di
	push	si
	push	cs
	call	AllocCStoDSAlias
	mov	si, ax
	xor	di, di			; zero ES:DI before call
	mov	es, di
	mov	ax, 1684h		; get device API entry point
	mov	bx, MMDEVLDR_Device_ID	; virtual device ID
	int	2Fh			; call WIN/386 INT 2F API
	mov	ax, es
	mov	es, si
	mov	word ptr es:MMDEVLDR_Entry, di
	mov	word ptr es:MMDEVLDR_Entry+2, ax
	push	ax
	push	si
	call	FreeSelector
	pop	ax
	or	ax, di
	pop	si
	pop	di
	pop	dx
	jz	short mmdevldr_fail
	jmp	[MMDEVLDR_Entry]
mmdevldr_fail:
	mov	ax, 1;
	retf
_SetWin32Event ENDP

_TEXT	ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\mvgaxx.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  MVGAXX.ASM
;
;   This module contains functions for dealing with the following VGA
;   256 color (modex) modes.
;
;       320x200x8
;       320x400x8
;       320x240x8
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
; 
; 15-Dec-96 jeffno  Made ScreenOffset and ScreenDisplay public so modex.c's
;                   new mode-set code can get at them. Also added cdwScreenWidthInDWORDS
;                   to enable PixBlt to operate correctly with 360x modes.
;
; Copyright (c) 1984-1995 Microsoft Corporation
;
;-----------------------------------------------------------------------;

?PLM = 1
?WIN = 0
.386
	.xlist
	include cmacros.inc
        include mvgaxx.inc
        .list

        externA         __A000h

; size for one 320x240x8 page (in mode X)
;-------------
; This is no longer accurate for x350 etc modex...
; turn it into a WORD and make it public so modex.c can
; set it properly.
;ScreenPageSize          equ  ((80 * 240 + 255) and (not 255))

sBegin  Data

ScreenSel         dw __A000h

;-------------------------------- Public Data ----------------------------------------
;
; The following three WORDS (ScreenOffset, ScreenDisplay and cdwScreenWidthInDWORDS
; and ScreenPageSize) MUST remain in sync with the extern declarations in modex.c
;

_ScreenOffset label word
ScreenOffset      dw 0

_ScreenDisplay label word
ScreenDisplay     dw 0

_cdwScreenWidthInDWORDS label word
cdwScreenWidthInDWORDS     dw 0

_cbScreenPageSize label word
cbScreenPageSize          dw ((80 * 240 + 255) and (not 255))


;expose these so modex.c can set 'em
public  _ScreenOffset
public  _ScreenDisplay
public  _cdwScreenWidthInDWORDS
public  _cbScreenPageSize

;
;
;-------------------------------------------------------------------------------------
sEnd    Data

ifndef SEGNAME
    SEGNAME equ <MODEX_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

; Manually perform "push" dword register instruction to remove warning
PUSHD macro reg
	db	66h
	push	reg
endm

; Manually perform "pop" dword register instruction to remove warning
POPD macro reg
	db	66h
	pop	reg
endm

;---------------------------Public-Routine------------------------------;
; FlipPage
;
;   display the current draw page and select another draw page
;
; Entry:
;
; Returns:
;       none
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       none
; History:
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   FlipPage, <NEAR, PUBLIC>, <>
cBegin
        ; we only program the high byte of the offset.
        ; so the page size must be a multiple of 256
        ; *** This compile-time assert can't be used anymore since cbScreenPageSize
        ; *** is now a static word. There are corresponding asserts in modex.c
        ; *** at the top of SetVGAForModeX().
        ;errnz   <cbScreenPageSize and 255>

        mov     ax,ScreenOffset
        mov     ScreenDisplay,ax
        mov     al,0Ch
        mov     dx,CRT_INDEX
        out     dx,ax

; NOTE. This routine will actually do triple buffering if a page is less
; than 64k/3. We might want to revisit this if we allow apps to specify a 
; dirty subrect to be copied on a flip: if they don't know the difference
; double and triple-buffered they'll get all out of sync.

        mov     ax,cbScreenPageSize
        add     ScreenOffset,ax
        neg     ax
        cmp     ScreenOffset,ax
        jbe     FlipPage13XExit

        mov     ScreenOffset,0

FlipPage13XExit:

cEnd

;---------------------------Public-Routine------------------------------;
; SetPalette
;
;   setup the palette
;
; Entry:
;       start       - first palette index to set
;       count       - count of palette index's
;       pPal        - points to array of RGBQUADs containg colors
;
; Returns:
;       None
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       setramdac
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc  SetPalette, <NEAR, PUBLIC>, <ds,si,di>
        parmW  start
        parmW  count
        parmD  pPal
        localV pal, %(3 * 256)
cBegin
        lds     si,pPal

        mov     bx,start            ; get start pal index
        mov     cx,count            ; get count
        mov     ax,bx
        add     ax,cx
        sub     ax,256              ; see if the count goes beyond the end
        jle     @f                  ;   No, valid range
        sub     cx,ax               ;   Yes, clip it
        mov     count,cx
@@:

;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
;   convert the palette from a array of RGBQUADs (B,G,R,X) to a array of
;   VGA RGBs (R>>2,G>>2,B>>2)
;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;
        lea     di,pal              ; ES:DI --> pal array on stack
        mov     ax,ss
        mov     es,ax

convert_pal_loop:
        lodsw                       ; al=blue, ah=green
        mov     dx,ax               ; dl=blue, dh=green
        lodsw                       ; al=red
        shr     al,2                ; map from 0-255 into 0-63
        shr     dl,2
        shr     dh,2
	xchg	al,dl
        stosb                       ; write red
        xchg    dl,dh               ; switch blue,green
        mov     ax,dx
        stosw                       ; write green,blue

        loop    convert_pal_loop

        lea     si,pal              ; DS:SI --> converted RGBs
        mov     ax,ss
        mov     ds,ax
        mov     cx,count            ; re-load count

        call    setramdac           ; set the physical palette
cEnd

;---------------------------------------------------------------------------
; setramdac  - initialize the ramdac to the values stored in
;	       a color table composed of double words
;
; entry:
;	bx  - index to 1st palette entry
;	cx  - count of indices to program
;    ds:si -> array of RGBs
;
; exit:
;   palette has been loaded
;
; Registers destroyed:
;   al,cx,dx,si
;
;---------------------------------------------------------------------------
        assumes ds,nothing
        assumes es,nothing

	public	setramdac
setramdac   proc near
	mov	ax,bx

	mov	dx,3c8h 		;Color palette write mode index reg.
	out	dx,al

        mov     dx,3c9h                 ;Color palette data reg.

        mov     bx,cx                   ;CX *= 3
        add     cx,cx                   ;
        add     cx,bx                   ;
if 0
        rep     outsb                   ;Set the palette all at once!
else
@@:     lodsb
        out     dx,al
        pause
        loop    @b
endif
	ret
setramdac  endp

;---------------------------Public-Routine------------------------------;
; PixBlt
;
;   copy a bitmap to the screen
;
; Entry:
;       x           - (x,y) pos of lower left of rect
;       y
;       xExt        - width and height of rect
;       yExt
;       pBits       - pointer to bits
;       BitsOffset  - pointer offset to start at.
;       WidthBytes  - width of a bitmap scan
;
; IMPORTANT: SEE WIDTH RESTRICTIONS AS DOCUMENTED WITHIN ROUTINE
; Note reference to cdwScreenWidthInDWORDS.
;
; Returns:
;       none
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;   15-Dec-96   jeffno  Allowed pitch other than 320, extended inner loop
;                       to handle multiples of 320 with remainder 8 pixels 
;                       (for 360x modes)
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc	PixBlt, <NEAR, PUBLIC>, <ds>
        ParmW   xExt        ;14
        ParmW   yExt        ;12
        ParmD   pBits       ;8 10
        ParmD   BitsOffset  ;4 6
        ParmW   WidthBytes  ;2
                            ;0
        localW  next_dst_scan
        localD  next_src_scan
cBegin
        .386
        PUSHD   si	; push esi
        PUSHD   di	; push edi

        xor     esi,esi
        xor     edi,edi
        xor     ebx,ebx

        ; this routine only handles images in multiles of 32 pixels
        ; and they must start 4 pixel aligned
        ; But JeffNo added an extra loop to extend to either a multiple
        ; of 32 (320x) or a multiple of 32 plus 8 extra pixels (360x).
        ; An assert has been added in modex.c to ensure one of these cases.

;        and     xExt,not 31
;;      and     x,not 3

        mov     es,ScreenSel

	mov	ax,cdwScreenWidthInDWORDS
	mov	next_dst_scan,ax

        mov     ax,WidthBytes
        sub     ax,4
        movsx   eax,ax
        mov     next_src_scan,eax

        mov     di,ScreenOffset     ; es:di -> top-left screen

        lds     si,pBits
        add     esi,BitsOffset
        assumes ds,nothing

        mov     al,SC_MAP_MASK
        mov     dx,SC_INDEX
        out     dx,al
align 4
PixBltXLoop:
;-----------------------------------------------------------------;
;   ax      - free
;   bx      - index into dest es:[edi+ebx]  index into source [esi+ebx*4]
;   cx      - loop count
;   dl      - mask
;   dh      - free
;   si      - source pointer (does not change)
;   di      - dest pointer (does not change)

        mov     cx,xExt
        shr     cx,2
        and     cx,0fff8h               ; a left over would give an extra loop at 360x
        mov     dl,11h                  ; dh = mask
align 4
PixBltXPhaseLoop:
        mov     bx,dx                   ; set the mask
        mov     al,dl
        mov     dx,SC_INDEX+1
        out     dx,al
        mov     dx,bx

        xor     bx,bx                   ; start at zero
align 4
PixBltXPixelLoop:
        mov     al,[esi+ebx*4]
        mov     ah,[esi+ebx*4+4]
        mov     es:[di+bx],ax

        mov     al,[esi+ebx*4+8]
        mov     ah,[esi+ebx*4+12]
        mov     es:[di+bx+2],ax

        mov     al,[esi+ebx*4+16]
        mov     ah,[esi+ebx*4+20]
        mov     es:[di+bx+4],ax

        mov     al,[esi+ebx*4+24]
        mov     ah,[esi+ebx*4+28]
        mov     es:[di+bx+6],ax

        add     bx,8
        cmp     bx,cx
        jl      short PixBltXPixelLoop

PixBltXNext:
        inc     esi
        shl     dl,1
        jnc     short PixBltXPhaseLoop

;-----------------------------------------------------------------;
; extra stuff to tack on the extra 2 chains to go from 352 to 360
; Note this little chunk relies on the xExt being a multiple of
; 8 pixels. If xExt is 320, we'll skip this part, and if it's
; 360, we'll do it
;
        test    xExt,08h
        je      short NoExtras      ;branch taken implies width is 320, else 360
        mov     dx,SC_INDEX+1
        mov     al,011h             ;the plane bits
        out     dx,al               ;select plane.

        mov     bx,xExt             ; point to the last 8 columns
        sub     bx,8                
        shr     bx,2

        mov     cl,[esi+ebx*4-4]    ; -4 because esi is 4 greater than start of row
        mov     ch,[esi+ebx*4]
        mov     es:[di+bx],cx

        shl     al,1
        out     dx,al               ;select plane.

        mov     cl,[esi+ebx*4-3]
        mov     ch,[esi+ebx*4+1]
        mov     es:[di+bx],cx

        shl     al,1
        out     dx,al               ;select plane.

        mov     cl,[esi+ebx*4-2]
        mov     ch,[esi+ebx*4+2]
        mov     es:[di+bx],cx

        shl     al,1
        out     dx,al               ;select plane.

        mov     cl,[esi+ebx*4-1]
        mov     ch,[esi+ebx*4+3]
        mov     es:[di+bx],cx

        
NoExtras:
;-----------------------------------------------------------------;

        add     di,next_dst_scan    ;no changes to these to support 360x, since this
        add     esi,next_src_scan   ;assume looped over multiple of 320, and the extra
                                    ;loop didn't change di and esi.

        dec     yExt
        jnz     PixBltXLoop         ;not a short by just 3 bytes!

PixBltXExit:
        POPD    di	; pop edi
        POPD    si	; pop esi
cEnd

;---------------------------Private-Routine------------------------------;
; SetMode320x200x8
;
;   VGA 320x200x8 graphics mode is entered (plain ol' MODE 13h)
;
; Entry:
;
; Returns:
;       360x200x8 graphics mode is entered
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;	INT 10h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

cProc   SetMode320x200x8, <NEAR, PUBLIC>, <ds,si,di>
cBegin
        mov     ScreenOffset,0          ; make sure this is zero
	mov	ScreenDisplay,0 	; make sure this is zero too.

        mov     ax,13h                  ; set display mode 320x200x8
        int     10h
	
        mov     dx,SC_INDEX     ; alter sequencer registers
        mov     ax,0604h
        out     dx,ax           ;disable chain4 mode
	
        mov	dx,CRT_INDEX
	mov	ax,0E317h
	out	dx, ax
	
	mov	ax, 014h
	out	dx, ax
	
cEnd

;---------------------------Private-Macro--------------------------------;
; SLAM port, regs
;
;   Sets a range of VGA registers
;
; Entry:
;   port    port index register
;   regs    table of register values
;
; History:
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

SLAM    macro   port, regs
	local	slam_loop
	local	slam_exit
        mov     cx,(&regs&_end - regs) / 2
	mov	dx,port
	mov	si,offset regs
	jcxz	slam_exit
slam_loop:
        lodsw
        out     dx,ax
        pause
	loop	slam_loop
slam_exit:
        endm

;---------------------------Private-Routine------------------------------;
; SetMode320x400x8
;
;   VGA 320x400x8 graphics mode is entered
;
; Entry:
;
; Returns:
;       320x400x8 graphics mode is entered
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;	INT 10h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,Data
        assumes es,nothing

seq_320x400:
        ;dw      00801h   ; Dot Clock * 2
        dw      00604h    ; Disable chain 4
seq_320x400_end:

crt_320x400:
        dw      04009h  ; cell height
        dw      00014h  ; turn off dword mode
        dw      0e317h  ; turn on byte mode
crt_320x400_end:

	assumes ds,Data
	assumes es,nothing

cProc   SetMode320x400x8, <NEAR, PUBLIC>, <ds,si,di>
cBegin
        mov     ScreenOffset,0          ; make sure this is zero
	mov	ScreenDisplay,0 	; make sure this is zero too.

        mov     ax,12h
        int     10h                     ; have BIOS clear memory

        mov     ax,13h                  ; set display mode 320x200x8
        int     10h

        mov     ax,cs                   ; get segment for data
        mov     ds,ax

        ;
        ;   Set the CRT regs
	;
        SLAM CRT_INDEX, crt_320x400

        ;
        ;   Set the SEQ regs
	;
        SLAM SC_INDEX, seq_320x400
cEnd

;---------------------------Private-Routine------------------------------;
; SetMode320x240x8
;
;   VGA 320x240x8 graphics mode is entered
;
; Entry:
;
; Returns:
;       320x240x8 graphics mode is entered
; Error Returns:
;	None
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;	INT 10h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
	assumes ds,Data
        assumes es,nothing

seq_320x240:
        dw      00604h    ; Disable chain 4
seq_320x240_end:

crt_320x240:
;       dw      00611h  ; un-protect cr0-cr7

        dw      00d06h  ;vertical total
        dw      03e07h  ;overflow (bit 8 of vertical counts)
        dw      04109h  ;cell height (2 to double-scan)
        dw      0ea10h  ;v sync start
        dw      0ac11h  ;v sync end and protect cr0-cr7
        dw      0df12h  ;vertical displayed
        dw      00014h  ;turn off dword mode
        dw      0e715h  ;v blank start
        dw      00616h  ;v blank end
        dw      0e317h  ;turn on byte mode
crt_320x240_end:

cProc   SetMode320x240x8, <NEAR, PUBLIC>, <ds,si,di>
cBegin
        mov     ScreenOffset,0          ; make sure this is zero
	mov	ScreenDisplay,0 	; make sure this is zero too.

        mov     ax,13h                  ; set display mode 320x200x8
        int     10h

        mov     ax,cs                   ; get segment for data
        mov     ds,ax
        assumes ds,Code

        mov     dx,CRT_INDEX ;reprogram the CRT Controller
        mov     al,11h  ;VSync End reg contains register write
        out     dx,al   ; protect bit
        inc     dx      ;CRT Controller Data register
        in      al,dx   ;get current VSync End register setting
        and     al,7fh  ;remove write protect on various
        out     dx,al   ; CRTC registers
        dec     dx      ;CRT Controller Index

        ;
        ;   Set the CRT regs
	;
        SLAM CRT_INDEX, crt_320x240

        mov     dx,SC_INDEX     ; alter sequencer registers
        mov     ax,0604h
        out     dx,ax           ;disable chain4 mode

        ;
        ;   Select a 25 mHz crystal
        ;
        cli
;       mov     dx,SC_INDEX     ; alter sequencer registers
	mov	ax,0100h	; synchronous reset
        out     dx,ax           ; asserted
        pause

        mov     dx,MISC_OUTPUT  ; misc output
        mov     al,0e3h         ; use 25 mHz dot clock
        out     dx,al           ; select it
        pause

        mov     dx,SC_INDEX     ; sequencer again
        mov     ax,0300h        ; restart sequencer
        out     dx,ax           ; running again
        pause
        sti

        ;
        ; now clear the memory.
        ;
        mov     ax,DataBASE
        mov     ds,ax
        assumes ds,Data

        mov     ax,ScreenSel
        mov     es,ax
        xor     di,di

        mov     ax,SC_MAP_MASK + 0F00h
        mov     dx,SC_INDEX
        out     dx,ax

        xor     ax,ax
        mov     cx,8000h
        rep     stosw
cEnd

sEnd    CodeSeg
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\vfd.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  VFD.ASM
;
;   interface code to VFlatD
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1994 Microsoft Corporation
;
; Restrictions:
;
;-----------------------------------------------------------------------;

?PLM = 1
?WIN = 0
	.xlist
	include cmacros.inc
	include VflatD.inc
        .list

sBegin  Data
	globalD VflatD_Proc, 0
	globalW _hselSecondary, 0
sEnd

sBegin  Code
	.386p
	assumes cs,Code
	assumes ds,nothing
	assumes es,nothing

;---------------------------Public-Routine------------------------------;
; VFDCall - return the version of VFlatD
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;       Created.
;-----------------------------------------------------------------------;
	assumes ds,Data
	assumes es,nothing

cProc   VFDCall, <NEAR>, <>
cBegin
	push    esi
	push    edi
	push    es
	pushad

	xor     di,di
	mov     es,di
	mov     ax,1684h
        mov     bx,VflatD_Chicago_ID
	int     2fh                         ;returns with es:di-->VFlatD Entry point
	mov     word ptr [VflatD_Proc][0],di
	mov     word ptr [VflatD_Proc][2],es
	mov     ax,es
	or      ax,di
	jne     short call_vfd

	xor     di,di
	mov     es,di
	mov     ax,1684h
        mov     bx,VflatD_Windows_ID
	int     2fh                         ;returns with es:di-->VFlatD Entry point
	mov     word ptr [VflatD_Proc][0],di
	mov     word ptr [VflatD_Proc][2],es
	mov     ax,es
	or      ax,di
        jnz     short call_vfd

	popad
	pop     es
call_vfd_err:
	xor     eax,eax
	xor     ebx,ebx
	xor     ecx,ecx
	xor     edx,edx
	jmp     call_vfd_exit

call_vfd:
	popad
	pop     es
	call    [VflatD_Proc]
	jc      call_vfd_err

call_vfd_exit:
	pop     edi
	pop     esi
cEnd

;---------------------------Public-Routine------------------------------;
; VFDQuery - return the version of VFlatD
;
; Returns:
;       Wed 04-Jan-1993 13:45:58 -by-  Todd Laney [ToddLa]
;       Created.
;-----------------------------------------------------------------------;
	assumes ds,Data
	assumes es,nothing

cProc   VFDQueryVersion, <FAR, PUBLIC, PASCAL>, <>
cBegin
	xor     eax,eax
	mov     edx,VFlatD_Query
	call    VFDCall
	shld    edx,eax,16
cEnd

cProc   VFDQuerySel, <FAR, PUBLIC, PASCAL>, <>
cBegin
	mov     edx,VFlatD_Query
	call	VFDCall
	and	ebx,0000FFFFh
	mov     eax,ebx
	shld    edx,eax,16
cEnd

cProc   VFDQuerySize, <FAR, PUBLIC, PASCAL>, <>
cBegin
	mov     edx,VFlatD_Query
	call    VFDCall
        mov     eax,ecx
	shld    edx,eax,16
cEnd

cProc   VFDQueryBase, <FAR, PUBLIC, PASCAL>, <>
cBegin
	mov     edx,VFlatD_Query
        call    VFDCall
        mov     eax,edx
	shld    edx,eax,16
cEnd

cProc   VFDReset, <FAR, PUBLIC, PASCAL>, <>
cBegin
        mov     edx,VFlatD_ResetBank
	call	VFDCall
cEnd

cProc   VFDBeginLinearAccess, <FAR, PUBLIC, PASCAL>, <>
cBegin
        mov     edx,VFlatD_Begin_Linear_Access
        mov     dh,1        ;; set flag to allow 4k bank to work.
        call    VFDCall
	shld    edx,eax,16
cEnd

cProc   VFDEndLinearAccess, <FAR, PUBLIC, PASCAL>, <>
cBegin
        mov     edx,VFlatD_End_Linear_Access
	call    VFDCall
	shld    edx,eax,16
cEnd


extrn LocalFree: FAR
extrn LocalAlloc: FAR

cProc   LocalAllocSecondary, <FAR, PUBLIC, PASCAL>, <>
        parmW  flags
        parmW  allocsize
cBegin
	mov     ax, _hselSecondary
	test    ax, ax
	jz      AllocError
	push    ds
	mov     ds, ax
	push    flags
	push    allocsize
	call    LocalAlloc
	mov     dx, ds	; assume success
	pop     ds
	test    ax, ax
	jnz     okay
AllocError:
	xor     dx, dx	; nope failed
okay:
cEnd


cProc   LocalFreeSecondary, <FAR, PUBLIC, PASCAL>, <>
        parmW  lp
cBegin
	push    ds
	mov     ax, _hselSecondary
	test    ax, ax
	jz      FreeError
	mov     ds, ax
	push    lp
	call    LocalFree
FreeError:
	pop     ds
cEnd


sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\moninfo.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       moninfo.c
 *  Content:	Code to query monitor specifications
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-mar-96	kylej	initial implementation (code from Toddla)
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <minivdd.h>
#include "edid.h"

#pragma optimize("gle", off)
#define Not_VxD
#include <vmm.h>
#include <configmg.h>
#pragma optimize("", on)

#include "ddraw16.h"

/***************************************************************************
 * just incase these are not defined, define them localy.
 ***************************************************************************/

#ifndef VDD_OPEN
#define VDD_OPEN            (13 + MINIVDD_SVC_BASE_OFFSET)
#endif

#ifndef VDD_OPEN_TEST
#define VDD_OPEN_TEST       0x00000001
#endif

/***************************************************************************
 ***************************************************************************/
static int myatoi(LPSTR sz)
{
    int i=0;
    int sign=+1;

    if (*sz=='-')
    {
        sign=-1;
        sz++;
    }

    while (*sz && *sz >= '0' && *sz <= '9')
        i = i*10 + (*sz++-'0');

    return i*sign;
}

/***************************************************************************
 VDDCall - make a service call into the VDD
 ***************************************************************************/

#pragma optimize("gle", off)
DWORD VDDCall(DWORD dev, DWORD function, DWORD flags, LPVOID buffer, DWORD buffer_size)
{
    static DWORD   VDDEntryPoint=0;
    DWORD   result=0xFFFFFFFF;

    if (VDDEntryPoint == 0)
    {
        _asm
        {
            xor     di,di           ;set these to zero before calling
            mov     es,di           ;
            mov     ax,1684h        ;INT 2FH: Get VxD API Entry Point
            mov     bx,0ah          ;this is device code for VDD
            int     2fh             ;call the multiplex interrupt
            mov     word ptr VDDEntryPoint[0],di    ;
            mov     word ptr VDDEntryPoint[2],es    ;save the returned data
        }

        if (VDDEntryPoint == 0)
            return result;
    }

    _asm
    {
        _emit 66h _asm push si  ; push esi
        _emit 66h _asm push di  ; push edi
        _emit 66h _asm mov ax,word ptr function     ;eax = function
        _emit 66h _asm mov bx,word ptr dev          ;ebx = device
        _emit 66h _asm mov cx,word ptr buffer_size  ;ecx = buffer_size
        _emit 66h _asm mov dx,word ptr flags        ;edx = flags
        _emit 66h _asm xor di,di                    ; HIWORD(edi)=0
        les     di,buffer
        mov     si,di                               ;si
        call    dword ptr VDDEntryPoint             ;call the VDD's PM API
        cmp     ax,word ptr function
        je      fail
        _emit 66h _asm mov word ptr result,ax
fail:   _emit 66h _asm pop di   ; pop edi
        _emit 66h _asm pop si   ; pop esi
    }

    return result;
}
#pragma optimize("", on)

/***************************************************************************
 * GetDisplayInfo - call the VDD to get the DISPLAYINFO for a device
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *
 * output
 *      DISPLAYINFO filled in
 *
 ***************************************************************************/
DWORD NEAR GetDisplayInfo(LPSTR szDevice, DISPLAYINFO FAR *pdi)
{
    DWORD dev;

    if (szDevice && lstrcmpi(szDevice, "DISPLAY") != 0)
        dev = VDDCall(0, VDD_OPEN, VDD_OPEN_TEST, (LPVOID)szDevice, 0);
    else
        dev = 1;

    if (dev == 0 || dev == 0xFFFFFFFF)
        return 0;

    pdi->diHdrSize = sizeof(DISPLAYINFO);
    pdi->diDevNodeHandle = 0;
    pdi->diMonitorDevNodeHandle = 0;

    VDDCall(dev, VDD_GET_DISPLAY_CONFIG, 0, (LPVOID)pdi, sizeof(DISPLAYINFO));

    if (pdi->diDevNodeHandle == 0)
        return 0;
    else
        return dev;
}

/***************************************************************************
 * GetMonitorMaxSize - returns the max xresolution the monitor supports
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *
 * output
 *      max xresolution of the monitor, or zero if the monitor
 *      is unknown.
 *
 ***************************************************************************/
int DDAPI DD16_GetMonitorMaxSize(LPSTR szDevice)
{
    DISPLAYINFO di;
    char ach[40];
    DWORD cb;

    GetDisplayInfo(szDevice, &di);

    if (di.diMonitorDevNodeHandle == 0)
        return 0;

    //
    // we have the devnode handle for the monitor, read the max
    // size from the registry, first try the HW key then the SW
    // key, this way PnP monitors will be supported.
    //
    ach[0] = 0;
    cb = sizeof(ach);
    CM_Read_Registry_Value(di.diMonitorDevNodeHandle, NULL, "MaxResolution",
        REG_SZ, ach, &cb, CM_REGISTRY_HARDWARE);

    if (ach[0] == 0)
    {
        cb = sizeof(ach);
        CM_Read_Registry_Value(di.diMonitorDevNodeHandle, NULL, "MaxResolution",
            REG_SZ, ach, &cb, CM_REGISTRY_SOFTWARE);
    }

    //
    // ach now contains the maxres, ie "1024,768" convert the xres to a
    // integer and return it.
    //
    return myatoi(ach);
}

/***************************************************************************
 * GetMonitorRefreshRateRanges
 *
 * returns the min/max refresh rate ranges for a given mode
 *
 * input
 *      szDevice    - device name, use NULL (or "DISPLAY") for the primary device.
 *      xres        - xres of the mode to query refresh ranges for
 *      yres        - yres of the mode to query refresh ranges for
 *      pmin        - place to put min refresh
 *      pmax        - place to put max refresh
 *
 * output
 *      true if success
 *      is unknown.
 *
 ***************************************************************************/
BOOL DDAPI DD16_GetMonitorRefreshRateRanges(LPSTR szDevice, int xres, int yres, int FAR *pmin, int FAR *pmax)
{
    DISPLAYINFO di;
    char ach[40];
    DWORD cb;
    HKEY hkey;
    char SaveRes[40];
    char SaveRate[40];
    DWORD dev;

    //
    // set these to zero in case we fail
    //
    *pmin = 0;
    *pmax = 0;

    //
    //  get the devnode handle for the display
    //
    dev = GetDisplayInfo(szDevice, &di);

    if (di.diDevNodeHandle == 0)
        return 0;

    //
    // open the settings key for the device, if no custom key exists
    // use HKCC/Display/Settings
    //
    hkey = NULL;
    VDDCall(dev, VDD_OPEN_KEY, 0, &hkey, sizeof(hkey));

    if (hkey == NULL)
        RegOpenKey(HKEY_CURRENT_CONFIG, "Display\\Settings", &hkey);

    if (hkey == NULL)
        return 0;

    //
    // save the current values of RefreshRate, and Resolution
    //
    SaveRate[0] = 0;
    SaveRes[0] = 0;
    cb = sizeof(SaveRes);
    RegQueryValueEx(hkey, "Resolution", NULL, NULL, SaveRes, &cb);

    cb = sizeof(SaveRate);
    CM_Read_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate",
        REG_SZ, SaveRate, &cb, CM_REGISTRY_SOFTWARE);

    //
    // set our new values, the VDD uses the resoluton in the
    // registry when computing the refresh rate ranges so we need
    // to update the registry to contain the mode we want to test.
    // we also need to write RefreshRate=-1 to enable automatic
    // refresh rate calcultion.
    //
    cb = wsprintf(ach, "%d,%d", xres, yres);
    RegSetValueEx(hkey, "Resolution", NULL, REG_SZ, ach, cb);

    CM_Write_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate",
        REG_SZ, "-1", 2, CM_REGISTRY_SOFTWARE);

    //
    // now call the VDD to get the refresh rate info.
    //
    di.diHdrSize = sizeof(DISPLAYINFO);
    di.diRefreshRateMin = 0;
    di.diRefreshRateMax = 0;
    VDDCall(dev, VDD_GET_DISPLAY_CONFIG, 0, (LPVOID)&di, sizeof(DISPLAYINFO));

    *pmin = di.diRefreshRateMin;
    *pmax = di.diRefreshRateMax;

    //
    // restore the saved values back to the registry
    //
    CM_Write_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate",
        REG_SZ, SaveRate, lstrlen(SaveRate), CM_REGISTRY_SOFTWARE);
    RegSetValueEx(hkey, "Resolution", NULL, REG_SZ, SaveRes, lstrlen(SaveRes));

    RegCloseKey(hkey);
    return TRUE;
}

/***************************************************************************
 * GetDeviceConfig
 *
 * get the device resource config
 *
 * input
 *      szDevice    - device name, use NULL (or "DISPLAY") for the primary device.
 *      lpConfig    - points to a CMCONFIG struct (or NULL)
 *      cbConfig    - size of lpConfig buffer
 *
 * output
 *      return the devnode handle, or 0 if failure
 *
 ***************************************************************************/
DWORD DDAPI DD16_GetDeviceConfig(LPSTR szDevice, LPVOID lpConfig, DWORD cbConfig)
{
    DISPLAYINFO di;

    //
    //  get the devnode handle for the display
    //
    GetDisplayInfo(szDevice, &di);

    if (di.diDevNodeHandle == 0)
        return 0;

    //
    // call CONFIGMG to get the config
    //
    if (lpConfig)
    {
        if (cbConfig < sizeof(CMCONFIG))
            return 0;

        CM_Get_Alloc_Log_Conf((CMCONFIG FAR *)lpConfig, di.diDevNodeHandle, 0);
    }

    //
    // return the DEVNODE handle
    //
    return di.diDevNodeHandle;
}

/***************************************************************************
 * GetMonitorEDIDData
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *
 * output
 *      lpEdidData  - EDID data.
 *
 ***************************************************************************/
int DDAPI DD16_GetMonitorEDIDData(LPSTR szDevice, LPVOID lpEdidData)
{
    DISPLAYINFO di;
    DWORD cb;

    GetDisplayInfo(szDevice, &di);

    if (di.diMonitorDevNodeHandle == 0)
        return 0;

    cb = sizeof( VESA_EDID );
    if (CM_Read_Registry_Value(di.diMonitorDevNodeHandle, NULL, "EDID", REG_BINARY, lpEdidData, &cb, CM_REGISTRY_HARDWARE) == CR_SUCCESS)
    {
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************
 * GetRateFromRegistry
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *
 ***************************************************************************/
DWORD DDAPI DD16_GetRateFromRegistry(LPSTR szDevice)
{
    DISPLAYINFO di;
    DWORD cb;
    BYTE szTemp[20];

    //
    //  get the devnode handle for the display
    //
    GetDisplayInfo(szDevice, &di);

    if (di.diDevNodeHandle == 0)
        return 0;

    cb = sizeof( szTemp );
    if (CM_Read_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate", REG_SZ, szTemp, &cb, CM_REGISTRY_SOFTWARE) == CR_SUCCESS)
    {
        return atoi( szTemp );
    }

    return 0;
}


/***************************************************************************
 * SetRateInRegistry
 *
 * input
 *      szDevice    - device name, use NULL or "DISPLAY" for primary device.
 *      dwRate      - Rate to set in the registry
 *
 ***************************************************************************/
int DDAPI DD16_SetRateInRegistry(LPSTR szDevice, DWORD dwRate)
{
    DISPLAYINFO di;
    DWORD cb;
    BYTE szTemp[20];

    //
    //  get the devnode handle for the display
    //
    GetDisplayInfo(szDevice, &di);

    if (di.diDevNodeHandle == 0)
        return 0;

    wsprintf( szTemp, "%d", (int)dwRate );
    cb = lstrlen( szTemp ) ;
    CM_Write_Registry_Value(di.diDevNodeHandle, "DEFAULT", "RefreshRate", REG_SZ, szTemp, cb, CM_REGISTRY_SOFTWARE);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\dxapi\dxmapper.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dxmapper.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the DXMAP class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

#define DEBUG_BREAKPOINT() DbgBreakPoint()
#define DXVERSION 4

NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
);


ULONG
DXCheckDDrawVersion(
);


ULONG
DXIssueIoctl(IN ULONG	dwFunctionNum,
             IN VOID*   lpvInBuffer,
             IN ULONG	cbInBuffer,
             IN VOID*   lpvOutBuffer,
             IN ULONG	cbOutBuffer
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\mvgaxx.inc ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  MVGAXX.INC
;
; This file contains the definitions of the EGA/VGA registers used by
; MVGAXX.ASM
;
;-----------------------------------------------------------------------;

SC_INDEX        equ     03C4h           ; Sequence Controller Index register
SC_MAP_MASK     equ     0002H
SC_MEMORY_MODE  equ     0004H

GC_INDEX        equ     03CEh           ; Graphics Controller Index register
GC_FUNCTION     equ     0003H
GC_READ_MAP     equ     0004H
GC_MODE         equ     0005h
GC_MISC         equ     0006H
GC_BITMASK      equ     0008H

CRT_INDEX       equ     03D4h           ; CRT index


MISC_OUTPUT     equ     03C2h           ; Miscellaneous Output register
MISC_INPUT      equ     03CCh           ; Miscellaneous Output register read

GRAF_ADDR	equ	0CEh		;Graphics Controller Address Register
GRAF_DATA	equ	0CFh		;Graphics Controller Data    Register

GRAF_SET_RESET	equ	00h		;  Set/Reset Plane Color
GRAF_ENAB_SR	equ	01h		;  Set/Reset Enable
GRAF_COL_COMP	equ	02h		;  Color Compare Register

GRAF_DATA_ROT	equ	03h		;  Data Rotate Register
DR_ROT_CNT	equ	00000111b	;    Data Rotate Count
DR_SET		equ	00000000b	;    Data Unmodified
DR_AND		equ	00001000b	;    Data ANDed with latches
DR_OR		equ	00010000b	;    Data ORed	with latches
DR_XOR		equ	00011000b	;    Data XORed with latches

GRAF_READ_MAP	equ	04h		;  Read Map Select Register
RM_C0		equ	00000000b	;    Read C0 plane
RM_C1		equ	00000001b	;    Read C1 plane
RM_C2		equ	00000010b	;    Read C2 plane
RM_C3		equ	00000011b	;    Read C3 plane

GRAF_MODE	equ	05h		;  Mode Register
M_PROC_WRITE	equ	00000000b	;    Write processor data rotated
M_LATCH_WRITE	equ	00000001b	;    Write latched data
M_COLOR_WRITE	equ	00000010b	;    Write processor data as color
M_AND_WRITE	equ	00000011b	;    Write (procdata AND bitmask)
M_DATA_READ	equ	00000000b	;    Read selected plane
M_COLOR_READ	equ	00001000b	;    Read color compare

GRAF_CDC	equ	07h		;  Color Don't Care Register
GRAF_BIT_MASK	equ	08h		;  Bit Mask Register

SET_WRITE_MAP macro plane_num
        pushem  ax,dx,cx
        mov     cl,plane_num
        and     cl,0011b
        mov     ax,SC_MAP_MASK + 0100h
        mov     dx,SC_INDEX
        shl     ah,cl
        out     dx,ax
        popem   ax,dx,cx
        endm

SET_READ_MAP macro plane_num
        pushem  ax,dx
        mov     ah,plane_num
        mov     al,GC_READ_MAP
        mov     dx,GC_INDEX
        out     dx,ax
        popem   ax,dx
        endm

SET_WRITE_MASK macro plane_mask
        pushem  ax,dx
        mov     al,SC_MAP_MASK
        mov     ah,plane_mask
        mov     dx,SC_INDEX
        out     dx,ax
        popem   ax,dx
        endm

pause   macro
        jmp     $+2
        endm

;----------------------------Private-Macro------------------------------;
; pushem
; popem
;
; Allows giving a list of registers to push/pop on a single line.
; Also allows easy verificaton that pushes and pops are balanced
; because arguements are given in the same order:
;
;	pushem	ax,bx,cx   goes with
;	popem	ax,bx,cx
;
; Arguments:
;	registers to push/pop
; Returns:
;	nothing
; Alters:
;	nothing
; Calls:
;	nothing
; History:
;
;  Mon Mar 09, 1987 06:12:32p	-by-	Wesley O. Rupel   [wesleyr]
; Wrote it!
;-----------------------------------------------------------------------;


pushem	macro	r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12
	irp	x,<r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12>
	ifnb	<x>
	push	x
	endif
	endm
	endm

popem	macro	r1,r2,r3,r4,r5,r6,r7,r8,r9,rA,rB,rC,rD,rE,rF,r10,r11,r12
	irp	x,<r12,r11,r10,rF,rE,rD,rC,rB,rA,r9,r8,r7,r6,r5,r4,r3,r2,r1>
	ifnb	<x>
	pop	x
	endif
	endm
        endm

;-------------------------Macro-----------------------------------------;
; REPSTOSB Dst
;
; store <cx> copies of al at Dst, aliging destination on WORD writes
;
;   Dst         destination, must be of the form SEL:[di] (default is es:[di])
;
; Entry:
;   Dst         -> points to dest buffer
;   al          byte to write
;   cx          count bytes
;
; Alters:
;   AX,BX,CX,DI
;
; NOTE this code assumes the direction flag is set to FORWARD
;
; Returns:
;
; History:
;       Sun 31-Jul-1989  -by-  ToddLa
;	Wrote it.
;
;-----------------------------------------------------------------------;

?REPSTOSB macro Dst
        local   l1
if 0
        mov     ah,al               ; make sure ah == al
        mov     bx,cx               ; save cx for later
        mov     cx,di
        and     cx,0001h
        sub     bx,cx
        rep     stos    byte ptr Dst
        mov     cx,bx
        shr     cx,1
        rep     stos word ptr Dst
        adc     cl,cl
        rep     stos byte ptr Dst
else
        mov     ah,al               ; make sure ah == al
        test    di,1
        jz      l1
        stos    byte ptr Dst
        dec     cx
l1:     shr     cx,1
        rep     stos word ptr Dst
        adc     cl,cl
        rep     stos byte ptr Dst
endif

        endm

REPSTOSB macro Dst
ifb <Dst>
        ?REPSTOSB es:[di]
else
        ?REPSTOSB Dst
endif
        endm

;-------------------------Macro-----------------------------------------;
; REPMOVSB Dst, Src, alignR
;
; copy <cx> bytes from Src to Dst, aliging destination or source
; on WORD writes
;
;   Dst         destination, must be of the form SEL:[di] (default is es:[di])
;   Src         source,      must be of the form SEL:[si] (default is ds:[si])
;   alignR      register to align   si or di (default is di)
;
; Entry:
;   Src         -> points to source buffer
;   Dst         -> points to dest buffer
;   cx          count bytes
;
; Alters:
;   BX,CX,DI,SI
;
; NOTE this code assumes the direction flag is set to FORWARD
;
; Returns:
;
; History:
;       Sun 31-Jul-1989  -by-  ToddLa
;	Wrote it.
;
;-----------------------------------------------------------------------;

?REPMOVSB  macro Dst, Src, alignR
        local   l1
if 0
        mov     bx,cx
        mov     cx,alignR
        and     cx,0001h
        sub     bx,cx
        rep     movs    byte ptr Dst, byte ptr Src
        mov     cx,bx
        shr     cx,1
        rep     movs    word ptr Dst, word ptr Src
        adc     cl,cl
        rep     movs    byte ptr Dst, byte ptr Src
else
        test    alignR,1
        jz      l1
        movs    byte ptr Dst, byte ptr Src
        dec     cx
l1:     shr     cx,1
        rep     movs    word ptr Dst, word ptr Src
        adc     cl,cl
        rep     movs    byte ptr Dst, byte ptr Src
endif
        endm

REPMOVSB  macro Dst, Src, alignR

ifb <Dst>
        ?REPMOVSB es:[di],ds:[si],di
        exitm
endif

ifb <Src>
        ?REPMOVSB Dst,ds:[si],di
        exitm
endif

ifb <alignR>
        ?REPMOVSB Dst,Src,di
        exitm
endif
        ?REPMOVSB Dst,Src,alignR

        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\ddraw16\winwatch.c ===
/*=========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       winwatch.c
 *  Content:	16-bit window watch code
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jun-95	craige	split out of DCIMAN WINWATCH.C, tweaked
 *   22-jun-95	craige	re-worked for clipper stuff
 *   02-jul-95	craige	comment out clipper notify stuff
 *
 ***************************************************************************/
#define _INC_DCIDDI
#include "ddraw16.h"
#undef _INC_DCIDDI

#ifdef CLIPPER_NOTIFY
static LPWINWATCH	lpWWList;
static HHOOK 		hNextCallWndProc;
static BOOL		bUnHook;

long FAR PASCAL _loadds CallWndProcHook(int hc, WPARAM wParam, LPARAM lParam);

extern HRGN FAR PASCAL InquireVisRgn(HDC hdc);
extern DWORD FAR PASCAL GetRegionData(HRGN hrgn, DWORD count, LPRGNDATA prd);

/*
 * doNotify
 */
void doNotify(LPWINWATCH pww, DWORD code)
{
    if( pww->lpCallback )
    {
	extern void DDAPI DD32_ClippingNotify( LPVOID, DWORD );
	DD32_ClippingNotify( pww->self32, code );
    }

} /* doNotify */

/*
 * DD16_WWOpen
 */
void DDAPI DD16_WWOpen( LPWINWATCH ptr )
{
    if( lpWWList == NULL )
    {
	DPF( 2, "Setting Windows Hook" );
	hNextCallWndProc = (HHOOK) SetWindowsHook( WH_CALLWNDPROC,
					(HOOKPROC) CallWndProcHook );
    }
    lpWWList = ptr;

} /* DD16_WWOpen */

/*
 * DD16_WWClose
 */
void DDAPI DD16_WWClose( LPWINWATCH pww, LPWINWATCH newlist )
{
    if( pww->prd16 != NULL )
    {
	LocalFree( (HLOCAL) pww->prd16 );
	pww->prd16 = NULL;
    }
    if( newlist == NULL )
    {
	DPF( 3, "Flagging to Unhook" );
	bUnHook = TRUE;
    }
    lpWWList = newlist;

} /* DD16_WWClose */

/*
 * DD16_WWNotifyInit
 */
void DDAPI DD16_WWNotifyInit(
		LPWINWATCH pww,
		LPCLIPPERCALLBACK lpcallback,
		LPVOID param )
{
    doNotify( pww, WINWATCHNOTIFY_STOP );

    pww->lpCallback = lpcallback;
    pww->lpContext = param;

    doNotify( pww, WINWATCHNOTIFY_START );
    doNotify( pww, WINWATCHNOTIFY_CHANGED );
    pww->fNotify = FALSE;

} /* DD16_WWNotifyInit */

/*
 * getWindowRegionData
 */
static DWORD getWindowRegionData( HWND hwnd, DWORD size, RGNDATA NEAR * prd )
{
    HDC 	hdc;
    DWORD	dw;

    hdc = GetDCEx( hwnd, NULL, DCX_USESTYLE | DCX_CACHE );
    dw = GetRegionData( InquireVisRgn( hdc ), size, prd );
    ReleaseDC( hwnd, hdc );
    return dw;

} /* getWindowRegionData */

/*
 * DD16_WWGetClipList
 */
DWORD DDAPI DD16_WWGetClipList(
		LPWINWATCH pww,
		LPRECT prect,
		DWORD rdsize,
		LPRGNDATA prd )
{   
    DWORD 	dw;
    DWORD    	size;

    /*
     *	we have to see if the intersect rect has changed.
     */
    if( prect )
    {
	if( !EqualRect(prect, &pww->rect) )
	{
	    pww->fDirty = TRUE;
	}
    }
    else
    {
	if( !IsRectEmpty( &pww->rect ) )
	{
	    pww->fDirty = TRUE;
	}
    }

    /*
     * if we are not dirty just return the saved RGNDATA
     */
    if( !pww->fDirty && pww->prd16 )
    {
	size = sizeof( *prd ) + (WORD) pww->prd16->rdh.nRgnSize;
	if( prd == NULL )
	{
	    return size;
	}
	if( rdsize < size )
	{
	    size = rdsize;
	}
	_fmemcpy( prd, pww->prd16, (UINT) size );
	return size;
    }

    /*
     * get the RGNDATA, growing the memory if we have to
     */
    dw = getWindowRegionData( (HWND) pww->hWnd, pww->dwRDSize, pww->prd16 );

    if( dw > pww->dwRDSize )
    {
	DPF( 2, "GetClipList: growing RGNDATA memory from %ld to %ld",pww->dwRDSize, dw);

	if( pww->prd16 != NULL )
	{
	    LocalFree((HLOCAL)pww->prd16);
	}

	/*
	 * allocate new space plus some slop
	 */
	pww->dwRDSize = dw + 8*sizeof(RECTL);
	pww->prd16 = (RGNDATA NEAR *) LocalAlloc(LPTR, (UINT)pww->dwRDSize);

	if( pww->prd16 == NULL )
	{
	    goto error;
	}

	dw = getWindowRegionData( (HWND) pww->hWnd, pww->dwRDSize, pww->prd16 );

	if( dw > pww->dwRDSize )
	{
	    goto error;
	}
    }

    /*
     *	now intersect the region with the passed rect
     */
    if( prect )
    {
	pww->rect = *prect;

	DPF( 2, "GetClipList: intersect with [%d %d %d %d]", *prect);
	ClipRgnToRect( (HWND) pww->hWnd, prect, pww->prd16 );
    }
    else
    {
	SetRectEmpty( &pww->rect );
    }

    pww->fDirty = FALSE;

    size = sizeof( *prd ) + (WORD) pww->prd16->rdh.nRgnSize;
    if( prd == NULL )
    {
	return size;
    }
    if( rdsize < size )
    {
	size = rdsize;
    }
    _fmemcpy( prd, pww->prd16, (UINT) size );
    return size;

error:
    pww->dwRDSize = 0;
    return 0;

} /* DD16_WWGetClipList */

/****************************************************************************
 *                                                                          *
 * ROUTINES TO HANDLE NOTIFICATION MESSAGES FOLLOW                          *
 *                                                                          *
 ****************************************************************************/

/*
 * handleWindowDestroyed
 */
static void handleWindowDestroy( HWND hwnd )
{
    LPWINWATCH	pww;

    DPF( 2, "*** handleWindowDestroy: hwnd=%08lx", hwnd );

again:
    for( pww=lpWWList; pww; pww=pww->next16 )
    {
	if( (hwnd == NULL) || ((HWND)pww->hWnd == hwnd) )
	{
	    extern void DDAPI DD32_WWClose( DWORD );

	    doNotify( pww, WINWATCHNOTIFY_DESTROY );
	    DD32_WWClose( (DWORD) pww->self32 );
	    goto again;
	}
    }

} /* handleWindowDestroy */

/*
 * handleWindowPosChanged
 */
static void handleWindowPosChanged( HWND hwnd )
{
    LPWINWATCH	pww;
    LPWINWATCH	next;
    RECT 	rect;
    RECT	rectT;

    DPF( 20, "*** handleWindowPosChanged: hwnd=%08lx", hwnd );

    /*
     * get the screen rect that changed
     */
    GetWindowRect( hwnd, &rect );

    /*
     * send message to each notify routine
     */
    pww = lpWWList;
    while( pww != NULL )
    {
        next = pww->next16;

	GetWindowRect((HWND)pww->hWnd, &rectT);

	if( IntersectRect( &rectT, &rectT, &rect ) )
	{
	    pww->fNotify = TRUE;
	    pww->fDirty = TRUE;
	}

	if( pww->fNotify && pww->lpCallback )
	{
	    DPF( 20, "clip changed %04X [%d %d %d %d]", (HWND)pww->hWnd, rectT);
	    doNotify( pww, WINWATCHNOTIFY_CHANGED );
	    pww->fNotify = FALSE;
	}
	pww = next;
    }

} /* handleWindowPosChanged */

/*
 * sendChanging
 */
static void sendChanging( LPRECT prect )
{
    LPWINWATCH	pww;
    LPWINWATCH	next;
    RECT 	rectT;

    pww = lpWWList;
    while( pww != NULL )
    {
        next = pww->next16;

        GetWindowRect( (HWND)pww->hWnd, &rectT );

        if( IntersectRect(&rectT, &rectT, prect) )
        {
            pww->fDirty = TRUE;

            if( pww->lpCallback )
            {
                DPF( 20, "clip changing %04X [%d %d %d %d]", (HWND)pww->hWnd, rectT);
                doNotify( pww, WINWATCHNOTIFY_CHANGING );
                pww->fNotify = TRUE;
                pww->fDirty = TRUE;
            }
        }

	pww = next;
    }

} /* sendChanging */

/*
 * handleWindowPosChanging
 */
static void handleWindowPosChanging( HWND hwnd, LPWINDOWPOS pwinpos )
{
    RECT	rect;
    RECT	rect_win;
    int		cx;
    int		cy;

    /*
     *  get the current screen rect.
     */
    DPF( 20, "*** handleWindowPosChanging: hwnd=%08lx", hwnd );
    GetWindowRect( hwnd, &rect_win);
    rect = rect_win;

    if( pwinpos == NULL )
    {
        sendChanging( &rect );
        return;
    }

    /*
     * compute the new rect
     */
    if( pwinpos->flags & SWP_NOSIZE )
    {
        cx = rect.right - rect.left;
        cy = rect.bottom - rect.top;
    }
    else
    {
        cx = pwinpos->cx;
        cy = pwinpos->cy;
    }

    if( !(pwinpos->flags & SWP_NOMOVE) )
    {
        rect.left = pwinpos->x;
        rect.top  = pwinpos->y;

        if( GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD )
        {
            ClientToScreen(GetParent(hwnd), (LPPOINT)&rect);
        }
    }

    rect.right = rect.left + cx;
    rect.bottom = rect.top + cy;

    /*
     * only send changing if we are really changing... if the new
     * rect is the same as the old rect, then check if something else
     * interesting is happening...
     */
    if( EqualRect( &rect, &rect_win ) )
    {
        if( !(pwinpos->flags & SWP_NOZORDER) )
	{
            sendChanging(&rect);
	}

        if( pwinpos->flags & (SWP_SHOWWINDOW|SWP_HIDEWINDOW) )
	{
            sendChanging(&rect);
	}
    }
    else
    {
        sendChanging( &rect_win );
        sendChanging( &rect );
    }

} /* handleWindowPosChanging */

/*
 * checkScreenLock
 */
static void checkScreenLock( void )
{
    static BOOL bScreenLocked;
    BOOL 	is_locked;
    HDC		hdc;
    RECT 	rect;

    hdc = GetDC(NULL);
    is_locked = (GetClipBox(hdc, &rect) == NULLREGION);
    ReleaseDC(NULL, hdc);

    if( is_locked != bScreenLocked )
    {
	/*
	 * pretend the desktop window has moved, this will cause
	 * all WINWATCH handles to be set to dirty, and also be notified.
	 */
	handleWindowPosChanging( GetDesktopWindow(), NULL );
        handleWindowPosChanged( GetDesktopWindow() );
	bScreenLocked = is_locked;
    }

} /* checkScreenLock */

/*
 * CallWndProcHook
 */
long FAR PASCAL _loadds CallWndProcHook( int hc, WPARAM wParam, LPARAM lParam )
{
    /* reversed MSG minus time and pt */
    typedef struct
    {
	LONG	lParam;
	WORD	wParam;
	WORD	message;
	HWND	hwnd;
    } MSGR, FAR *LPMSGR;

    LPMSGR	lpmsg;
    LPWINDOWPOS	lpwinpos;
    long	rc;

    if( hc == HC_ACTION )
    {
	lpmsg = (MSGR FAR *)lParam;

	switch( lpmsg->message )
	{
	case WM_DESTROY:
	    handleWindowDestroy( lpmsg->hwnd );
	    break;

	case WM_WINDOWPOSCHANGING:
	    lpwinpos = (LPWINDOWPOS) lpmsg->lParam;
	    handleWindowPosChanging( lpwinpos->hwnd, lpwinpos );
	    break;

	case WM_WINDOWPOSCHANGED:
	    lpwinpos = (LPWINDOWPOS) lpmsg->lParam;
	    handleWindowPosChanged( lpwinpos->hwnd );
	    break;

	case WM_EXITSIZEMOVE:
	    checkScreenLock();
	    break;
	case WM_ENTERSIZEMOVE:
	    checkScreenLock();
	    break;
	}
    }

    rc = DefHookProc(hc, wParam, lParam, &(HOOKPROC)hNextCallWndProc);
    if( bUnHook )
    {
	DPF( 2, "Unhooking WindowsHook" );
	UnhookWindowsHook( WH_CALLWNDPROC, (HOOKPROC)CallWndProcHook );
	bUnHook = FALSE;
    }
    return rc;

} /* CallWndProcHook */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\dxapi\vxd.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

   vxd.c

Abstract:

   This is the WDM DX mapper driver.

Author:

    smac

Environment:

   Kernel mode only


Revision History:

--*/

#include <windows.h>
#include <vmm.h>
#include "..\ddvxd\dddriver.h"


ULONG DXCheckDDrawVersion( VOID )
{
    ULONG ulRet;

    VxDCall( _DDRAW_GetVersion );
    _asm mov ulRet, eax
    return ulRet;
}


ULONG DXIssueIoctl( ULONG dwFunctionNum, VOID *lpvInBuff, ULONG cbInBuff,
                    VOID *lpvOutBuff, ULONG cbOutBuff )
{
    ULONG ulRet;

    _asm pushad
    _asm push cbOutBuff
    _asm push lpvOutBuff
    _asm push cbInBuff
    _asm push lpvInBuff
    _asm push dwFunctionNum
    VxDCall( _DDRAW_DXAPI_IOCTL );
    _asm mov ulRet, eax
    _asm pop eax
    _asm pop eax
    _asm pop eax
    _asm pop eax
    _asm pop eax
    _asm popad
    return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\inc\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(E,"Driv&er information")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

//
// level    meaning
//  0       Fatal error, user visible
//  1       Warning, user visible
//  2       Info, user visible
//  3       non-user visible errors/warnings
//  4       program flow
//  5       values

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * NOTE: Debug topic A is reserved and always means "API Usage"
 */

/*
 * Note for backward compatibility you can define PROF_SECT here
 * to pick up old-style DPF control from win.ini's [PROF_SECT] debug=
 * setting
 */
/* #define PROF_SECT "MyOldWININISection"*/


#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DDraw"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DDrawDebug"

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */

 /*
  * Note: At run-time, you can set
  *     [DirectX]
  *     <DPF_CONTROL_LINE>=?
  * to get a dump of DPF control string parameters, including all defined topics.
  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\dxapi\wdm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   wdm.c

Abstract:

   This is the WDM DX mapper driver.

Author:

    billpa

Environment:

   Kernel mode only


Revision History:

--*/

#include "wdm.h"
#include "dxapi.h"
#include "dxmapper.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#endif

BOOLEAN DsoundOk = FALSE;


NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    Entry point for explicitely loaded stream class.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - unused.

Return Value:

   STATUS_SUCCESS

--*/
{

    UNREFERENCED_PARAMETER(DriverObject);
    return STATUS_SUCCESS;
}


ULONG
DxApiGetVersion(
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    return (DXCheckDDrawVersion());
}


ULONG
DxApi(
            IN ULONG	dwFunctionNum,
            IN PVOID	lpvInBuffer,
            IN ULONG	cbInBuffer,
            IN PVOID	lpvOutBuffer,
            IN ULONG	cbOutBuffer
)
/*++

Routine Description:

Arguments:

Return Value:

--*/
{

    //
    // if we haven't checked if DSOUND is present and the right version,
    // (or if we've checked before and failed) check and return error if not
    // loaded or correct version.
    //

    if (!DsoundOk) {

        if (DXCheckDDrawVersion() < DXVERSION) {

             return 0;

        } else {

             DsoundOk = TRUE;
        }
    }

    return DXIssueIoctl( dwFunctionNum, lpvInBuffer, cbInBuffer,
    	lpvOutBuffer, cbOutBuffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\inc\ids.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ids.h
 *  Content:    DirectDraw resource ids
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   10-sep-95  toddla  created
 *   20-sep-95	craige	add IDS_PRIMARYDISPLAY
 *
 ***************************************************************************/

// icon ids
#define ID_ICON             42

// string ids
#define IDS_TITLE           100     // dialog box title
#define IDS_DONTWORK_BPP    101     // you must be in 256 color mode or higher.
#define IDS_DONTWORK_DRV    102     // 
#define IDS_PRIMARYDISPLAY  103     // primary display ident. string
#define IDS_TIME_BOMB		104		// time bomb message string
#define IDS_TIME_BOMB_TITLE	105		// time bomb title string
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\inc\ddd3dapi.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995,1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddd3dapi.h
 *  Content:	Interface between DirectDraw and Direct3D.
 *@@BEGIN_MSINTERNAL
 * 
 *  $Id$
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   02/17/96   colinmc Created this file from the obsolete d3dapi.h
 *   03/23/96   colinmc Added process termination cleanup code
 *   04/17/96   colinmc Bug 17008: DirectDraw/Direct3D deadlock
 *   04/25/96	stevela Bug 16803: Name of Direct3D DLL changed.
 *   04/29/96   colinmc Bug 19954: Must query for Direct3D before texture
 *                      or device
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef _DDD3DAPI_H_
#define _DDD3DAPI_H_

// Flags for D3DDEVICEDESC dwDeviceZBufferBitDepth
// copied from direct3d\rast\d3dif\d3dif.hpp, see note there for explanation

#define D3DSWRASTERIZER_ZBUFFERBITDEPTHFLAGS (DDBD_16)

/*
 * File name of the Direct3D DLL.
 */
#define D3D_DLLNAME               "D3DIM.DLL"
#define D3DDX7_DLLNAME            "D3DIM700.DLL"

/*
 * Entry points exported by the Direct3D DLL.
 */
#define D3DCREATE_PROCNAME        "Direct3DCreate"
#define D3DCREATEDEVICE_PROCNAME  "Direct3DCreateDevice"
#define D3DCREATETEXTURE_PROCNAME "Direct3DCreateTexture"
#define D3DHALCLEANUP_PROCNAME    "Direct3D_HALCleanUp"

#ifdef USE_D3D_CSECT
    typedef HRESULT (WINAPI * D3DCreateProc)(LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#else  /* USE_D3D_CSECT */
    typedef HRESULT (WINAPI * D3DCreateProc)(LPCRITICAL_SECTION lpDDCSect,
					     LPUNKNOWN*         lplpD3D,
					     IUnknown*          pUnkOuter);
#endif /* USE_D3D_CSECT */

typedef HRESULT (WINAPI * D3DCreateTextProc)(REFCLSID            riid,
                                             LPDIRECTDRAWSURFACE lpDDS,
					     LPUNKNOWN*          lplpD3DText,
					     IUnknown*           pUnkOuter);
typedef HRESULT (WINAPI * D3DCreateDeviceProc)(REFCLSID            riid,
                                               LPUNKNOWN           lpDirect3D,
                                               LPDIRECTDRAWSURFACE lpDDS,
                                               LPUNKNOWN*          lplpD3DDevice,
                                               IUnknown*           pUnkOuter,
                                               DWORD               dwVersion);

typedef DWORD (WINAPI * D3DGetSWRastPixFmtsProc)(DDPIXELFORMAT **ppDDPF);

typedef HRESULT (WINAPI * D3DHALCleanUpProc)(LPD3DHAL_CALLBACKS lpHALTable, DWORD dwPID);

#endif /* _DDD3DAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\apphack.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       apphack.h
 *  Content:	app compatiblity hacking code
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-sep-96	jeffno	initial implementation after CraigE
 *
 ***************************************************************************/
typedef struct APPHACKS
{
    struct APPHACKS	*lpNext;
    LPSTR		szName;
    DWORD		dwAppId;
    DWORD		dwFlags;
} APPHACKS, *LPAPPHACKS;

extern BOOL		bReloadReg;
extern BOOL		bHaveReadReg;
extern LPAPPHACKS	lpAppList;
extern LPAPPHACKS	*lpAppArray;
extern DWORD		dwAppArraySize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\apphack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       apphack.c
 *  Content:	app compatiblity hacking code
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   27-may-96	craige	initial implementation
 *   28-sep-96	craige	allow binary data in registry (f*cking .inf
 *			can't put in dword into the registry)
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "apphack.h"

#define STRCMP	lstrcmpi


static int sortRtn( LPAPPHACKS *p1, LPAPPHACKS *p2 )
{
    return STRCMP( (*p1)->szName, (*p2)->szName );
}

static int searchRtn( LPSTR key, LPAPPHACKS *p2 )
{
    return STRCMP( key, (*p2)->szName );
}

__inline static BOOL fileRead( HANDLE hfile, void *data, int len )
{
    DWORD	len_read;

    if( !ReadFile( hfile,  data, (DWORD) len, &len_read, NULL ) ||
    	len_read != (DWORD) len )
    {
	return FALSE;
    }
    return TRUE;

} /* fileRead */

__inline static BOOL fileSeek( HANDLE hfile, DWORD offset )
{
    if( SetFilePointer( hfile, offset, NULL, FILE_BEGIN ) != offset )
    {
	return FALSE;
    }
    return TRUE;

} /* fileSeek */


void FreeAppHackData(void)
{
    LPAPPHACKS	next;
    LPAPPHACKS	lphack = lpAppList;

    while( lphack != NULL )
    {
	next = lphack->lpNext;
	MemFree( lphack );
	lphack = next;
    }
    if( lpAppArray != NULL )
    {
	MemFree( lpAppArray );
    }
    lpAppArray = NULL;
    lpAppList = NULL;
    dwAppArraySize = 0;
    bHaveReadReg = FALSE;
}

/*
 * HackMeBaby
 *
 * And we'll have fun fun fun 'til your daddy takes your app hacks away...
 */
DWORD HackMeBaby( void )
{
    char	        fname[_MAX_PATH];
    char	        name[_MAX_PATH];
    HANDLE	        hfile;
    int		        i;
    LPAPPHACKS	        lphack;
    LPAPPHACKS	        *lplphack;
    DWORD               dwScreenSaver;
    IMAGE_NT_HEADERS	nth;
    IMAGE_DOS_HEADER	dh;
    DWORD               appid;
    HKEY                hkey;

    /*
     * bail on the existing info if requested
     */
    if( bReloadReg )
    {

	DPF( 3, "Reloading the compatibility info from the registry" );

	if( lpAppList != NULL )
	{
	    DPF( 4, "Freeing existing compatiblity list" );
	}

        FreeAppHackData();
    }

    /*
     * read the registry for any app hacks
     */
    if( !bHaveReadReg )
    {
	int	index;
	int	count;

	bHaveReadReg = TRUE;
	if( !RegOpenKey( HKEY_LOCAL_MACHINE,
			 REGSTR_PATH_DDRAW "\\" REGSTR_KEY_APPCOMPAT, &hkey ) )
	{
	    index = 0;
	    count = 0;

	    DPF( 4, "Reading App Compatiblity Information" );
	    /*
	     * run through all keys
	     */
	    while( !RegEnumKey( hkey, index, name, sizeof( name ) ) )
	    {
		HKEY	hsubkey;
		DPF( 5, "  Found info for %s", name );

		/*
		 * get info for this specific app
		 */
		if( !RegOpenKey( hkey, name, &hsubkey ) )
		{
		    DWORD	type;
		    DWORD	cb;
		    DWORD	id;
		    DWORD	flags;

		    cb = sizeof( name );
		    if( !RegQueryValueEx( hsubkey, REGSTR_VAL_DDRAW_NAME,
		    			NULL, &type, name, &cb ) )
		    {
			if( type == REG_SZ )
			{
			    cb = sizeof( flags );
			    if( !RegQueryValueEx( hsubkey, REGSTR_VAL_DDRAW_FLAGS,
			    		NULL, &type, (LPSTR) &flags, &cb ) )
			    {
				if( (type == REG_DWORD) ||
				    (type == REG_BINARY && cb == sizeof( flags )) )
				{
				    if( !(flags & ~DDRAW_APPCOMPAT_VALID) )
				    {
					cb = 4;
					if( !RegQueryValueEx( hsubkey, REGSTR_VAL_DDRAW_APPID,
						    NULL, &type, (LPSTR) &id, &cb ) )
					{
					    if( (type == REG_DWORD) ||
						(type == REG_BINARY && cb == sizeof( flags )) )
					    {
						/*
						 * finally!  we have all the data.   save it
						 */
						lphack = MemAlloc( sizeof( *lphack ) + strlen( name ) + 1 );
						if( lphack != NULL )
						{
						    lphack->dwAppId = id;
						    lphack->dwFlags = flags;
						    lphack->szName = &((LPSTR)lphack)[sizeof( *lphack )];
						    lphack->lpNext = lpAppList;
						    lpAppList = lphack;
						    strcpy( lphack->szName, name );
						    count++;
						    DPF( 5, "    Name  = %s", lphack->szName );
						    DPF( 5, "    Flags = 0x%08lx", lphack->dwFlags );
						    DPF( 5, "    AppId = 0x%08lx", lphack->dwAppId );
						}
						else
						{
						    DPF( 0, "    Out of memory!!!" );
						}
					    }
					    else
					    {
						DPF( 0, "    AppID not a DWORD for app %s", name );
					    }
					}
				    }
				    else
				    {
					DPF( 0, "    Invalid flags %08lx for app %s", flags, name );
				    }
				}
				else
				{
				    DPF( 0, "    Flags not a DWORD for app %s", name );
				}
			    }
			    else
			    {
				DPF( 0, "    No flags found for app %s", name );
			    }
			}
			else
			{
			    DPF( 0, "    Executable name not a string!!!" );
			}
		    }
		    else
		    {
			DPF( 0, "    Executable name not found!!!" );
		    }
                    RegCloseKey( hsubkey );
		}
		else
		{
		    DPF( 0, "  RegOpenKey for %ld FAILED!" );
		}

		/*
		 * next reg entry...
		 */
		index++;
	    }
	    DPF( 5, "Enumerated %ld keys, found %ld valid ones", index, count );

	    /*
	     * go make an array we can sort and use later...
	     */
	    if( count > 0 )
	    {
		lpAppArray = MemAlloc( (count+1) * sizeof( LPAPPHACKS ) );
		if( lpAppArray != NULL )
		{
		    LPAPPHACKS	lphack;

		    dwAppArraySize = 0;
		    lphack = lpAppList;
		    while( lphack != NULL )
		    {
			lpAppArray[ dwAppArraySize ] = lphack;
			lphack = lphack->lpNext;
			dwAppArraySize++;
		    }

		    qsort( lpAppArray, count, sizeof( LPAPPHACKS ),
		    			(LPVOID) sortRtn );
		}
		for( count = 0; count< (int) dwAppArraySize; count++ )
		{
		    DPF( 5, "  %s", lpAppArray[count]->szName );
		}
	    }

            RegCloseKey( hkey );
	}
	else
	{
#ifdef WIN95	    
            DPF( 0, "Failed to find registry root" );
#endif
	}

        /*
         * The first time through, we will also check to see if a gamma
         * calibrator is registered.  All we'll do here is read the registry
         * key and if it's non-NULL, we'll assume that one exists.
         */
	if( !RegOpenKey( HKEY_LOCAL_MACHINE,
                         REGSTR_PATH_DDRAW "\\" REGSTR_KEY_GAMMA_CALIBRATOR, &hkey ) )
	{
            DWORD       type;
            DWORD       cb;

            cb = sizeof( szGammaCalibrator );
            if( !RegQueryValueEx( hkey, REGSTR_VAL_GAMMA_CALIBRATOR,
                        NULL, &type, szGammaCalibrator, &cb ) )
            {
                if( ( type == REG_SZ ) &&
                    ( szGammaCalibrator[0] != '\0' ) )
                {
                    bGammaCalibratorExists = TRUE;
                }
            }
            RegCloseKey( hkey );
        }
    }
    else
    {
	DPF( 3, "Registry already scanned, not doing it again" );
    }

    /*
     * find out what process we are dealing with
     */
    hfile =  GetModuleHandle( NULL );
    GetModuleFileName( hfile, fname, sizeof( fname ) );
    DPF( 5, "full name  = %s", fname );
    i = strlen( fname )-1;
    while( i >=0 && fname[i] != '\\' )
    {
	i--;
    }
    i++;
    strcpy( name, &fname[i] );
    DPF( 5, "name       = %s", name );
    lplphack = bsearch( name, lpAppArray, dwAppArraySize, sizeof( LPAPPHACKS ),
    		(LPVOID) searchRtn );

    /*
     * If it has an .SCR extension, assume it's a screensaver.
     */
    dwScreenSaver = 0;
    #ifdef WIN95
        if( ( strlen(name) > 4 ) && !STRCMP( &name[ strlen(name) - 4 ], ".SCR" ) )
        {
            dwScreenSaver = DDRAW_APPCOMPAT_SCREENSAVER;
        }
    #endif

    /*
     * go find the timestamp in the file
     */
    appid = 0;
    do
    {
        hfile = CreateFile( fname, GENERIC_READ, FILE_SHARE_READ,
	        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if( hfile == INVALID_HANDLE_VALUE )
        {
	    DPF( 0, "Could not open file %s", fname );
	    break;
        }
        if( !fileRead( hfile, &dh, sizeof( dh ) ) )
        {
	    DPF( 0, "Could not read DOS header for file %s", fname );
	    break;
        }
        if( dh.e_magic != IMAGE_DOS_SIGNATURE )
        {
	    DPF( 0, "Invalid DOS header for file %s", fname );
	    break;
        }
        if( !fileSeek( hfile, dh.e_lfanew ) )
        {
	    DPF( 0, "Could not seek to PE header in file %s", fname );
	    break;
        }
        if( !fileRead( hfile, &nth, sizeof( nth ) ) )
        {
	    DPF( 0, "Could not read PE header for file %s", fname );
	    break;
        }
        if( nth.Signature != IMAGE_NT_SIGNATURE )
        {
	    DPF( 0, "Bogus PE header for file %s", fname );
	    break;
        }
        appid = nth.FileHeader.TimeDateStamp;
        if( appid == 0 )
        {
	    DPF( 0, "TimeDataStap is 0 for file %s", fname );
	    break;
        }
        DPF( 5, "Obtained appid: 0x%08lx", appid );
        CloseHandle( hfile );
        hfile = NULL;
    } while(0); //fake try-except

    // Now write the values into some known place
    if (appid)
    {
        DWORD dw;

	if( !RegCreateKey( HKEY_LOCAL_MACHINE,
			 REGSTR_PATH_DDRAW "\\" REGSTR_KEY_LASTAPP, &hkey ) )
        {
            RegSetValueEx(hkey, REGSTR_VAL_DDRAW_NAME, 0, REG_SZ, (LPBYTE)name, strlen(name)+1);
            RegSetValueEx(hkey, REGSTR_VAL_DDRAW_APPID, 0, REG_DWORD, (LPBYTE)&appid, sizeof(appid));
            RegCloseKey(hkey);
        }

    }


    if( lplphack != NULL && appid )
    {
	HANDLE	hfile;

	/*
	 * back up to the first match with this name
	 */
	lphack = *lplphack;
	while( lplphack != lpAppArray )
	{
	    lplphack--;
	    if( STRCMP( (*lplphack)->szName, name ) )
	    {
		lplphack++;
		break;
	    }
	    lphack = *lplphack;
	}

	/*
	 * now run through all matches we found
	 */
	hfile = NULL;
	while( 1 )
	{
	    /*
	     * is this one of the ones that matches the calling process?
	     */
	    if( *lplphack == NULL )
	    {
		break;
	    }
	    lphack = *lplphack;
	    if( STRCMP( lphack->szName, name ) )
	    {
		break;
	    }

	    /*
	     * validate timestamp in registry against the one in the file
	     */
	    if( lphack->dwAppId == appid )
	    {
		DPF( 5, "****** Compatiblity data 0x%08lx found for %s",
				lphack->dwFlags, name );
                return lphack->dwFlags | dwScreenSaver;
	    }
	    lplphack++;
	}
	if( hfile != NULL )
	{
	    CloseHandle( hfile );
	}
    }
    return dwScreenSaver;

} /* HackMeBaby */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\alphablt.c ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	alphablt.c
 *  Content:	DirectDraw Surface support for alpha-blended blt
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  30-sep-97 jvanaken	Original version adapted from ddsblt.c
 *
 ***************************************************************************/
#include "ddrawpr.h"


// function from ddraw module ddclip.c
extern HRESULT InternalGetClipList(LPDIRECTDRAWCLIPPER,
				   LPRECT,
				   LPRGNDATA,
				   LPDWORD,
				   LPDDRAWI_DIRECTDRAW_GBL);

#ifndef WINNT
    #define DONE_BUSY()          \
        (*pdflags) &= ~BUSY;
    #define LEAVE_BOTH_NOBUSY()  \
        { if(pdflags)            \
            (*pdflags) &= ~BUSY; \
        }                        \
        LEAVE_BOTH();
#else
    #define DONE_BUSY()
    #define LEAVE_BOTH_NOBUSY()  \
        LEAVE_BOTH();
#endif

#define DONE_LOCKS() \
    if (dest_lock_taken) \
    { \
	InternalUnlock(surf_dest_lcl,NULL,NULL,0); \
	dest_lock_taken = FALSE; \
    } \
    if (src_lock_taken && surf_src_lcl) \
    { \
	InternalUnlock(surf_src_lcl,NULL,NULL,0); \
	src_lock_taken = FALSE; \
    }

#if defined(WIN95)
    #define DONE_EXCLUDE() \
        if (surf_dest_lcl->lpDDClipper != NULL) \
        { \
            if ((pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice && \
                !(*pdrv->lpwPDeviceFlags & HARDWARECURSOR)) \
	    { \
	        DD16_Unexclude(pdrv->dwPDevice); \
	    } \
        }
#elif defined(WINNT)
    #define DONE_EXCLUDE() ;
#endif


/*
 * Stretch-blit info
 */
typedef struct
{
    DWORD	src_height;
    DWORD	src_width;
    DWORD	dest_height;
    DWORD	dest_width;
    BOOL	halonly;    // HEL can't do this alpha-blit
    BOOL	helonly;    // hardware driver can't do this alpha-blit
} STRETCH_BLT_INFO, FAR *LPSTRETCH_BLT_INFO;


/*
 * Alpha-blitting capability bits
 */
typedef struct
{
    // caps for hardware driver
    DWORD	dwCaps;
    DWORD	dwCKeyCaps;
    DWORD	dwFXCaps;
    DWORD	dwAlphaCaps;
    DWORD	dwFilterCaps;

    // caps for HEL
    DWORD	dwHELCaps;
    DWORD	dwHELCKeyCaps;
    DWORD	dwHELFXCaps;
    DWORD	dwHELAlphaCaps;
    DWORD	dwHELFilterCaps;

    // caps common to hardware driver and HEL
    DWORD	dwBothCaps;
    DWORD	dwBothCKeyCaps;
    DWORD	dwBothFXCaps;
    DWORD	dwBothAlphaCaps;
    DWORD	dwBothFilterCaps;

    BOOL	bHALSeesSysmem;
} ALPHA_BLT_CAPS, *LPALPHA_BLT_CAPS;


/*
 * Return a pointer to the DDPIXELFORMAT structure that
 * describes the specified surface's pixel format.
 */
static LPDDPIXELFORMAT getPixelFormatPtr(LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    LPDDPIXELFORMAT pDDPF;

    if (surf_lcl == NULL)
    {
    	return NULL;
    }

    if (surf_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
    {
	// surface contains explicitly defined pixel format
	pDDPF = &surf_lcl->lpGbl->ddpfSurface;
    }
    else
    {
	// surface's pixel format is implicit -- same as primary's
	pDDPF = &surf_lcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay;
    }
    return pDDPF;

}  /* getPixelFormatPtr */


/*
 * Initialize ALPHA_BLT_CAPS structure according to whether source and
 * dest surfaces are in system or video (local or nonlocal) memory.
 */
static void initAlphaBltCaps(DWORD dwDstCaps,
			     DWORD dwSrcCaps,
			     LPDDRAWI_DIRECTDRAW_GBL pdrv,
			     LPALPHA_BLT_CAPS pcaps,
			     LPBOOL helonly)
{
    DDASSERT(pcaps != NULL);

    memset(pcaps, 0, sizeof(ALPHA_BLT_CAPS));

    if ((dwSrcCaps | dwDstCaps) & DDSCAPS_NONLOCALVIDMEM  &&
	  pdrv->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS)
    {
	/*
	 * At least one of the surfaces is nonlocal video memory.  The device
	 * exports different capabilities for local and nonlocal video memory.
	 * If this is a nonlocal-to-local transfer then check the appropriate
	 * caps.  Otherwise, force software emulation of the blit.
	 */
	if (dwSrcCaps & DDSCAPS_NONLOCALVIDMEM && dwDstCaps & DDSCAPS_LOCALVIDMEM)
	{
	    /*
	     * Non-local to local video memory transfer.
	     */
	    DDASSERT(NULL != pdrv->lpddNLVCaps);
	    DDASSERT(NULL != pdrv->lpddNLVHELCaps);
	    DDASSERT(NULL != pdrv->lpddNLVBothCaps);

	    /*
	     * We have specific caps for nonlocal video memory.  Use them.
	     */
	    pcaps->dwCaps =	  pdrv->lpddNLVCaps->dwNLVBCaps;
	    pcaps->dwCKeyCaps =   pdrv->lpddNLVCaps->dwNLVBCKeyCaps;
	    pcaps->dwFXCaps =	  pdrv->lpddNLVCaps->dwNLVBFXCaps;
	    if (pdrv->lpddMoreCaps)
	    {
		if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
		{
		    pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwAlphaCaps;
		}
		if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
		{
		    pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwFilterCaps;
		}
	    }
	
	    pcaps->dwHELCaps =	      pdrv->lpddNLVHELCaps->dwNLVBCaps;
	    pcaps->dwHELCKeyCaps =    pdrv->lpddNLVHELCaps->dwNLVBCKeyCaps;
	    pcaps->dwHELFXCaps =      pdrv->lpddNLVHELCaps->dwNLVBFXCaps;
	    if (pdrv->lpddHELMoreCaps)
	    {
		if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
		{
		    pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwAlphaCaps;
		}
		if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
		{
		    pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwFilterCaps;
		}
	    }
	
	    pcaps->dwBothCaps =       pdrv->lpddNLVBothCaps->dwNLVBCaps;
	    pcaps->dwBothCKeyCaps =   pdrv->lpddNLVBothCaps->dwNLVBCKeyCaps;
	    pcaps->dwBothFXCaps =     pdrv->lpddNLVBothCaps->dwNLVBFXCaps;
	    if (pdrv->lpddBothMoreCaps)
	    {
		if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
		{
		    pcaps->dwBothAlphaCaps = pdrv->lpddBothMoreCaps->dwAlphaCaps;
		}
		if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
		{
		    pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwFilterCaps;
		}
	    }
	    /*
	     * A driver that cannot filter is trivially capable of disabling filtering.
	     * By similar logic, a driver than cannot filter does not fail to respect
	     * the DDABLT_FILTERTRANSPBORDER flag unless filtering is explicitly enabled.
	     */
	    if (!(pcaps->dwFXCaps & DDFXCAPS_BLTFILTER))
	    {
		pcaps->dwFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
                pcaps->dwFXCaps |= DDFXCAPS_BLTFILTER;
	    }
            if (!(pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER))
	    {
		pcaps->dwHELFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
                pcaps->dwHELFXCaps |= DDFXCAPS_BLTFILTER;
	    }
            if (!(pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER))
	    {
		pcaps->dwBothFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
                pcaps->dwBothFXCaps |= DDFXCAPS_BLTFILTER;
	    }

	    pcaps->bHALSeesSysmem =  FALSE;

	    return;
	}

	/*
	 * Nonlocal-to-nonlocal or local-to-nonlocal transfer. Force emulation.
	 */
	*helonly = TRUE;
    }

    if (!(pdrv->ddCaps.dwCaps & DDCAPS_CANBLTSYSMEM))
    {
	if ((dwSrcCaps | dwDstCaps) & DDSCAPS_SYSTEMMEMORY)
	{
            *helonly = TRUE;
	}
    }

    if (dwSrcCaps & dwDstCaps & DDSCAPS_VIDEOMEMORY)
    {
	pcaps->dwCaps =	    pdrv->ddCaps.dwCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwFXCaps;
        if (pdrv->lpddMoreCaps)
	{
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwAlphaCaps;
	    }
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwFilterCaps;
	    }
	}
	
	pcaps->dwHELCaps =     pdrv->ddHELCaps.dwCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwAlphaCaps;
	    }
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwFilterCaps;
	    }
	}
	
	pcaps->dwBothCaps =     pdrv->ddBothCaps.dwCaps;
	pcaps->dwBothCKeyCaps = pdrv->ddBothCaps.dwCKeyCaps;
	pcaps->dwBothFXCaps =   pdrv->ddBothCaps.dwFXCaps;
	if (pdrv->lpddBothMoreCaps)
	{
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwBothAlphaCaps = pdrv->lpddBothMoreCaps->dwAlphaCaps;
	    }
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwFilterCaps;
	    }
	}
	
	pcaps->bHALSeesSysmem = FALSE;
    }
    else if ((dwSrcCaps & DDSCAPS_SYSTEMMEMORY) && (dwDstCaps & DDSCAPS_VIDEOMEMORY))
    {
	pcaps->dwCaps =	    pdrv->ddCaps.dwSVBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwSVBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwSVBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwSVBAlphaCaps;
	    }
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwSVBFilterCaps;
	    }
	}
	
	pcaps->dwHELCaps =     pdrv->ddHELCaps.dwSVBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwSVBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwSVBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwSVBAlphaCaps;
	    }
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwSVBFilterCaps;
	    }
	}
	
	pcaps->dwBothCaps =     pdrv->ddBothCaps.dwSVBCaps;
	pcaps->dwBothCKeyCaps = pdrv->ddBothCaps.dwSVBCKeyCaps;
	pcaps->dwBothFXCaps =   pdrv->ddBothCaps.dwSVBFXCaps;
	if (pdrv->lpddBothMoreCaps)
	{
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
	    {
                pcaps->dwBothAlphaCaps = pdrv->lpddBothMoreCaps->dwSVBAlphaCaps;
	    }
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwSVBFilterCaps;
	    }
	}
	
	pcaps->bHALSeesSysmem = TRUE;
    }
    else if ((dwSrcCaps & DDSCAPS_VIDEOMEMORY) && (dwDstCaps & DDSCAPS_SYSTEMMEMORY))
    {
	pcaps->dwCaps =	    pdrv->ddCaps.dwVSBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwVSBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwVSBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwVSBAlphaCaps;
	    }
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwVSBFilterCaps;
	    }
	}
	
	pcaps->dwHELCaps =     pdrv->ddHELCaps.dwVSBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwVSBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwVSBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwVSBAlphaCaps;
	    }
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwVSBFilterCaps;
	    }
	}
	
	pcaps->dwBothCaps =     pdrv->ddBothCaps.dwVSBCaps;
	pcaps->dwBothCKeyCaps = pdrv->ddBothCaps.dwVSBCKeyCaps;
	pcaps->dwBothFXCaps =   pdrv->ddBothCaps.dwVSBFXCaps;
	if (pdrv->lpddBothMoreCaps)
	{
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwBothAlphaCaps = pdrv->lpddBothMoreCaps->dwVSBAlphaCaps;
	    }
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwVSBFilterCaps;
	    }
	}
	
	pcaps->bHALSeesSysmem = TRUE;
    }
    else if (dwSrcCaps & dwDstCaps & DDSCAPS_SYSTEMMEMORY)
    {
	pcaps->dwCaps =	    pdrv->ddCaps.dwSSBCaps;
	pcaps->dwCKeyCaps = pdrv->ddCaps.dwSSBCKeyCaps;
	pcaps->dwFXCaps =   pdrv->ddCaps.dwSSBFXCaps;
	if (pdrv->lpddMoreCaps)
	{
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwAlphaCaps = pdrv->lpddMoreCaps->dwSSBAlphaCaps;
	    }
	    if (pcaps->dwFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwFilterCaps = pdrv->lpddMoreCaps->dwSSBFilterCaps;
	    }
	}
	
	pcaps->dwHELCaps =     pdrv->ddHELCaps.dwSSBCaps;
	pcaps->dwHELCKeyCaps = pdrv->ddHELCaps.dwSSBCKeyCaps;
	pcaps->dwHELFXCaps =   pdrv->ddHELCaps.dwSSBFXCaps;
	if (pdrv->lpddHELMoreCaps)
	{
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwHELAlphaCaps = pdrv->lpddHELMoreCaps->dwSSBAlphaCaps;
	    }
	    if (pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwHELFilterCaps = pdrv->lpddHELMoreCaps->dwSSBFilterCaps;
	    }
	}
	
	pcaps->dwBothCaps =     pdrv->ddBothCaps.dwSSBCaps;
	pcaps->dwBothCKeyCaps = pdrv->ddBothCaps.dwSSBCKeyCaps;
	pcaps->dwBothFXCaps =   pdrv->ddBothCaps.dwSSBFXCaps;
	if (pdrv->lpddBothMoreCaps)
	{
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTALPHA)
	    {
		pcaps->dwBothAlphaCaps  = pdrv->lpddBothMoreCaps->dwSSBAlphaCaps;
	    }
	    if (pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER)
	    {
		pcaps->dwBothFilterCaps = pdrv->lpddBothMoreCaps->dwSSBFilterCaps;
	    }
	}
	
	pcaps->bHALSeesSysmem = TRUE;
    }

    /*
     * A driver that cannot filter is trivially capable of disabling filtering.
     * By similar logic, a driver than cannot filter does not fail to respect
     * the DDABLT_FILTERTRANSPBORDER flag unless filtering is explicitly enabled.
     */
    if (!(pcaps->dwFXCaps & DDFXCAPS_BLTFILTER))
    {
	pcaps->dwFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
	pcaps->dwFXCaps |= DDFXCAPS_BLTFILTER;
    }
    if (!(pcaps->dwHELFXCaps & DDFXCAPS_BLTFILTER))
    {
	pcaps->dwHELFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
	pcaps->dwHELFXCaps |= DDFXCAPS_BLTFILTER;
    }
    if (!(pcaps->dwBothFXCaps & DDFXCAPS_BLTFILTER))
    {
	pcaps->dwBothFilterCaps = DDFILTCAPS_BLTCANDISABLEFILTER | DDFILTCAPS_BLTTRANSPBORDER;
	pcaps->dwBothFXCaps |= DDFXCAPS_BLTFILTER;
    }

}  /* initAlphaBltCaps */


/*
 * Verify that driver can perform requested stretching for blit.
 */
static HRESULT validateStretching(LPALPHA_BLT_CAPS pcaps,
				  LPSTRETCH_BLT_INFO psbi)
{
    DWORD caps;
    BOOL fail = FALSE;

    /*
     * Can we even stretch at all?
     */
    if (!(pcaps->dwBothCaps & DDCAPS_BLTSTRETCH))
    {
	GETFAILCODEBLT(pcaps->dwCaps,
		       pcaps->dwHELCaps,
		       psbi->halonly,
		       psbi->helonly,
		       DDCAPS_BLTSTRETCH);
	if (fail)
	{
	    return DDERR_NOSTRETCHHW;
	}
    }

    if (psbi->helonly)
	caps = pcaps->dwHELFXCaps;
    else
	caps = pcaps->dwFXCaps;

    /*
     * verify height
     */
    if (psbi->src_height != psbi->dest_height)
    {
	if (psbi->src_height > psbi->dest_height)
	{
	    /*
	     * can we shrink Y arbitrarily?
	     */
	    if (!(caps & (DDFXCAPS_BLTSHRINKY)))
	    {
		/*
		 * see if this is a non-integer shrink
		 */
		if ((psbi->src_height % psbi->dest_height) != 0)
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSHRINKY);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		/*
		 * see if we can integer shrink
		 */
		}
		else if (!(caps & DDFXCAPS_BLTSHRINKYN))
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSHRINKYN);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
	    }
	}
	else
	{
	    if (!(caps & DDFXCAPS_BLTSTRETCHY))
	    {
		/*
		 * see if this is a non-integer stretch
		 */
		if ((psbi->dest_height % psbi->src_height) != 0)
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSTRETCHY);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		/*
		 * see if we can integer stretch
		 */
		}
		else if (!(caps & DDFXCAPS_BLTSTRETCHYN))
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSTRETCHYN);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
	    }
	}
    }

    /*
     * verify width
     */
    if (psbi->src_width != psbi->dest_width)
    {
	if (psbi->src_width > psbi->dest_width)
	{
	    if (!(caps & DDFXCAPS_BLTSHRINKX))
	    {
		/*
		 * Are we stretching by a non-integer factor?
		 */
		if ((psbi->src_width % psbi->dest_width) != 0)
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSHRINKX);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		/*
		 * see if we can integer shrink
		 */
		}
		else if (!(caps & DDFXCAPS_BLTSHRINKXN))
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSHRINKXN);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
	    }
	}
	else
	{
	    if (!(caps & DDFXCAPS_BLTSTRETCHX))
	    {
		/*
		 * Are we stretching by a non-integer factor?
		 */
		if ((psbi->dest_width % psbi->src_width) != 0)
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSTRETCHX);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
		if (!(caps & DDFXCAPS_BLTSTRETCHXN))
		{
		    GETFAILCODEBLT(pcaps->dwFXCaps,
				   pcaps->dwHELFXCaps,
				   psbi->halonly,
				   psbi->helonly,
				   DDFXCAPS_BLTSTRETCHXN);
		    if (fail)
		    {
			return DDERR_NOSTRETCHHW;
		    }
		}
	    }
	}
    }
    return DD_OK;

}  /* validateStretching */



#undef DPF_MODNAME
#define DPF_MODNAME	"AlphaBlt"


/*
 * Wait for pending hardware operation on specified surface to finish.
 *
 * This function waits for the hardware driver to report that it has finished
 * operating on the given surface. We should only call this function if the
 * surface was a system memory surface involved in a DMA/busmastering transfer.
 * Note this function clears the DDRAWISURFGBL_HARDWAREOPSTARTED flag.
 */
static void WaitForHardwareOp(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl,
				LPDDRAWI_DDRAWSURFACE_LCL surf_lcl)
{
    HRESULT hr;
#ifdef DEBUG
    BOOL bSentMessage = FALSE;
    DWORD dwStart = GetTickCount();
#endif

    DDASSERT(surf_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY);
    DPF(5, B, "Waiting for driver to finish with %08x", surf_lcl->lpGbl);
    do
    {
        hr = InternalGetBltStatus(pdrv_lcl, surf_lcl, DDGBS_ISBLTDONE);
#ifdef DEBUG
        if (GetTickCount() - dwStart >= 10000 && !bSentMessage)
	{
	    bSentMessage = TRUE;
	    DPF_ERR("Driver error: Hardware op still pending on surface after 5 sec!");
        }
#endif
    } while (hr == DDERR_WASSTILLDRAWING);

    DDASSERT(hr == DD_OK);
    DPF(5, B, "Driver finished with that surface");
    surf_lcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_HARDWAREOPSTARTED;

}  /* WaitForHardwareOp */


/*
 * DD_Surface_AlphaBlt
 *
 * BitBLT from one surface to another with alpha blending.
 */
HRESULT DDAPI DD_Surface_AlphaBlt(
		LPDIRECTDRAWSURFACE lpDDDestSurface,
		LPRECT lpDestRect,
		LPDIRECTDRAWSURFACE lpDDSrcSurface,
		LPRECT lpSrcRect,
		DWORD dwFlags,
		LPDDALPHABLTFX lpDDAlphaBltFX)
{
    struct
    {
        RGNDATAHEADER rdh;
        RECT clipRect[8];
    } myRgnBuffer;

    DWORD           rc;
    LPDDRAWI_DDRAWSURFACE_INT   surf_src_int;
    LPDDRAWI_DDRAWSURFACE_LCL   surf_src_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   surf_src;
    LPDDRAWI_DDRAWSURFACE_INT   surf_dest_int;
    LPDDRAWI_DDRAWSURFACE_LCL   surf_dest_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   surf_dest;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    LPDDHAL_ALPHABLT        bltfn;
    DDHAL_BLTDATA           bd;
    STRETCH_BLT_INFO        sbi;
    BOOL            fail;
    BOOL            dest_lock_taken=FALSE;
    BOOL            src_lock_taken=FALSE;
    LPVOID          dest_bits;
    LPVOID          src_bits;
    HRESULT         ddrval;
    RECT            rect;
    ALPHA_BLT_CAPS  caps;
    LPWORD          pdflags=0;
    LPRGNDATA       pRgn;
    DDARGB          ddargbScaleFactors;
    DWORD           dwFillValue;
    DWORD           dwDDPFDestFlags;
    DWORD           dwDDPFSrcFlags;

    DDASSERT(sizeof(DDARGB)==sizeof(DWORD));  // we rely on this

    ENTER_BOTH();

    DPF(2,A,"ENTERAPI: DD_Surface_AlphaBlt");
	
    TRY
    {
	ZeroMemory(&bd, sizeof(bd));   // initialize to zero

	/*
         * Validate surface pointers.
         */
        surf_dest_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDDestSurface;
        surf_src_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSrcSurface;
        if (!VALID_DIRECTDRAWSURFACE_PTR(surf_dest_int))
        {
            DPF_ERR("Invalid dest surface") ;
            LEAVE_BOTH();
            return DDERR_INVALIDOBJECT;
        }
        surf_dest_lcl = surf_dest_int->lpLcl;
        surf_dest = surf_dest_lcl->lpGbl;
        if (SURFACE_LOST(surf_dest_lcl))
        {
            DPF_ERR("Dest surface lost") ;
            LEAVE_BOTH();
            return DDERR_SURFACELOST;
        }
        if (surf_src_int != NULL)
        {
            if (!VALID_DIRECTDRAWSURFACE_PTR(surf_src_int))
            {
                DPF_ERR("Invalid source surface");
                LEAVE_BOTH();
                return DDERR_INVALIDOBJECT;
            }
            surf_src_lcl = surf_src_int->lpLcl;
            surf_src = surf_src_lcl->lpGbl;
            if (SURFACE_LOST(surf_src_lcl))
            {
                DPF_ERR("Src surface lost") ;
                LEAVE_BOTH();
                return DDERR_SURFACELOST;
            }
        }
        else
        {
            surf_src_lcl = NULL;
            surf_src = NULL;
        }

        if (dwFlags & ~DDABLT_VALID)
        {
            DPF_ERR("Invalid flags") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

	// Is the DONOTWAIT flag set?
	if (dwFlags & DDABLT_DONOTWAIT)
	{
    	    if (dwFlags & DDABLT_WAIT)
	    {
		DPF_ERR("WAIT and DONOTWAIT flags are mutually exclusive");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    // Unless the DONOTWAIT flag is explicitly set, use the default (WAIT).
	    dwFlags |= DDABLT_WAIT;
	}

	/*
         * Set ARGB scaling factors and fill value to their default values.
	 * Note that setting ddargbScaleFactors to all ones effectively
	 * disables ARGB scaling, and a fill value of zero represents black.
	 */
        *(LPDWORD)&ddargbScaleFactors = ~0UL;
        dwFillValue = 0;

	/*
	 * Read parameters pointed to by lpDDAlphaBltFX argument.
	 */
	if (lpDDAlphaBltFX != 0)
	{
	    if (IsBadWritePtr((LPVOID)lpDDAlphaBltFX, sizeof(DDALPHABLTFX)))
	    {
                DPF_ERR("Argument lpDDAlphaBltFX is a bad pointer") ;
                LEAVE_BOTH();
                return DDERR_INVALIDPARAMS;
	    }
	    if (dwFlags & DDABLT_USEFILLVALUE)
	    {
    		dwFillValue = lpDDAlphaBltFX->dwFillValue;
	    }
	    else
	    {
    		ddargbScaleFactors = lpDDAlphaBltFX->ddargbScaleFactors;
	    }
	}
		
	// Is this a color-fill operation that uses dwFillValue?
	if (dwFlags & DDABLT_USEFILLVALUE && surf_src_lcl == NULL)
	{
	    // Could this possibly be an alpha-blended fill?
	    if (!(dwFlags & DDABLT_NOBLEND))
	    {
		HRESULT hres;

		// If the fill value is less than 100% opaque, we need to
		// do an alpha fill rather than just a simple color fill.
		// Convert physcolor to DDARGB value and test its opacity.
		hres = ConvertFromPhysColor(
					    surf_dest_lcl,
					    &dwFillValue,
					    &ddargbScaleFactors);

		if ((hres == DD_OK) && (ddargbScaleFactors.alpha != 255))
		{
		    // The fill value is not 100% opaque, so do an alpha fill.
		    dwFlags &= ~DDABLT_USEFILLVALUE;
		}
	    }
	    // Make sure DEGRADEARGBSCALING flag is not set.
	    if (dwFlags & DDABLT_DEGRADEARGBSCALING)
	    {
		DPF_ERR("DEGRADEARGBSCALING and USEFILLVALUE flags are incompatible");
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	}

        /*
         * We do not allow blitting to or from an optimized surface.
         */
        if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED ||
            surf_src && surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR("Can't blt optimized surfaces") ;
            LEAVE_BOTH();
            return DDERR_INVALIDPARAMS;
        }

        pdrv = surf_dest->lpDD;
        pdrv_lcl = surf_dest_lcl->lpSurfMore->lpDD_lcl;
	#ifdef WINNT
    	    // Update DDraw handle in driver GBL object.
	    pdrv->hDD = pdrv_lcl->hDD;
	#endif

	/*
	 * Default behavior is to automatically fail-over to software
	 * emulation if hardware driver cannot handle the specified
	 * blit.  The DDABLT_HARDWAREONLY flag overrides this default.
	 */
	sbi.halonly = dwFlags & DDABLT_HARDWAREONLY;
	sbi.helonly = dwFlags & DDABLT_SOFTWAREONLY;

        /*
	 * Only the HEL can blit between two surfaces created by two
	 * different drivers.
         */
        if (surf_src && surf_src->lpDD != pdrv &&
            surf_src->lpDD->dwFlags & DDRAWI_DISPLAYDRV &&
            pdrv->dwFlags & DDRAWI_DISPLAYDRV)
        {
            sbi.helonly = TRUE;
        }
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered validating parameters");
        LEAVE_BOTH();
        return DDERR_INVALIDPARAMS;
    }

    #ifdef USE_ALIAS
    if ((pdrv_lcl->lpDDCB->HALDDMiscellaneous2.AlphaBlt == NULL) &&
	(pdrv->dwBusyDueToAliasedLock > 0))
    {
        /*
         * Aliased locks (the ones that don't take the Win16 lock) don't
         * set the busy bit either (it can't or USER gets very confused).
         * However, we must prevent blits happening via DirectDraw as
         * otherwise we get into the old host talking to VRAM while
         * blitter does at the same time.  Bad.  So fail if there is an
         * outstanding aliased lock just as if the BUSY bit had been set.
         */
        DPF_ERR("Graphics adapter is busy (due to a DirectDraw lock)");
        LEAVE_BOTH();
        return DDERR_SURFACEBUSY;
    }
    #endif /* USE_ALIAS */

    if(surf_src_lcl)
        FlushD3DStates(surf_src_lcl); // Need to flush src because it could be a rendertarget
    FlushD3DStates(surf_dest_lcl);

    /*
     * Test and set the busy bit.  If it was already set, bail.
     */
    #ifdef WIN95
    {
        BOOL isbusy = 0;

	pdflags = pdrv->lpwPDeviceFlags;
	_asm
	{
	    mov eax, pdflags
	    bts word ptr [eax], BUSY_BIT
	    adc byte ptr isbusy,0
	}
	if (isbusy)
	{
	    DPF(3, "BUSY - AlphaBlt");
	    LEAVE_BOTH();
	    return DDERR_SURFACEBUSY;
	}
    }
    #endif

    /*
     * The following code was added to keep all of the HALs from
     * changing their Blt() code when they add video port support.
     * If the video port was using this surface but was recently
     * flipped, we will make sure that the flip actually occurred
     * before allowing access.  This allows double buffered capture
     * w/o tearing.
     */
    if ((surf_src_lcl != NULL) &&
	    (surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT))
    {
	LPDDRAWI_DDVIDEOPORT_INT lpVideoPort;
	LPDDRAWI_DDVIDEOPORT_LCL lpVideoPort_lcl;

	// Look at all video ports to see if any of them recently
	// flipped from this surface.
	lpVideoPort = pdrv->dvpList;
	while(NULL != lpVideoPort)
	{
	    lpVideoPort_lcl = lpVideoPort->lpLcl;
	    if (lpVideoPort_lcl->fpLastFlip == surf_src->fpVidMem)
	    {
		// This can potentially tear - check the flip status
		LPDDHALVPORTCB_GETFLIPSTATUS pfn;
		DDHAL_GETVPORTFLIPSTATUSDATA GetFlipData;
		LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
	
		pdrv_lcl = surf_src_lcl->lpSurfMore->lpDD_lcl;
		pfn = pdrv_lcl->lpDDCB->HALDDVideoPort.GetVideoPortFlipStatus;
		if (pfn != NULL)  // Will simply tear if function not supported
		{
		    GetFlipData.lpDD = pdrv_lcl;
		    GetFlipData.fpSurface = surf_src->fpVidMem;
	
		KeepTrying:
		    rc = DDHAL_DRIVER_NOTHANDLED;
		    DOHALCALL(GetVideoPortFlipStatus, pfn, GetFlipData, rc, 0);
		    if ((DDHAL_DRIVER_HANDLED == rc) &&
		    (DDERR_WASSTILLDRAWING == GetFlipData.ddRVal))
		    {
			if (dwFlags & DDABLT_WAIT)
			{
			    goto KeepTrying;
			}
			LEAVE_BOTH_NOBUSY();
			return DDERR_WASSTILLDRAWING;
		    }
		}
	    }
	    lpVideoPort = lpVideoPort->lpLink;
	}
    }


    TRY
    {
	/*
	 *  Remove any cached run-length-encoded data for the source surface.
	 */
	if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	{
	    extern void FreeRleData(LPDDRAWI_DDRAWSURFACE_LCL);  //in fasthel.c

	    FreeRleData(surf_dest_lcl);
	}

	/*
	 * Is either surface locked?
	 */
	if (surf_dest->dwUsageCount > 0 ||
	    surf_src != NULL && surf_src->dwUsageCount > 0)
	{
	    DPF_ERR("Surface is locked");
	    LEAVE_BOTH_NOBUSY();
	    return DDERR_SURFACEBUSY;
	}

	BUMP_SURFACE_STAMP(surf_dest);

	/*
	 * It is possible this function could be called in the middle
	 * of a mode change, in which case we could trash the frame buffer.
	 * To avoid regression, we will simply succeed the call without
	 * actually doing anything.
	 */
	if (pdrv->dwFlags & DDRAWI_CHANGINGMODE &&
	    !(surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
	{
	    LEAVE_BOTH_NOBUSY()
		return DD_OK;
	}

	/*
	 * Some parameters are valid only if a source surface is specified.
	 */
	if (surf_src == NULL)
	{
	    /*
	     * No source surface is specified, so this must be a fill operation.
	     */
	    if (dwFlags & (DDABLT_MIRRORLEFTRIGHT | DDABLT_MIRRORUPDOWN |
			   DDABLT_FILTERENABLE | DDABLT_FILTERDISABLE |
			   DDABLT_FILTERTRANSPBORDER | DDABLT_KEYSRC))
	    {
		DPF_ERR("Specified flag requires source surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    if (lpSrcRect != NULL)
	    {
		DPF_ERR("Source rectangle specified without source surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    /*
	     * A source surface is specified, so this must be a two-operand blit.
	     */
	    if (dwFlags & DDABLT_USEFILLVALUE)
	    {
		DPF_ERR("USEFILLVALUE flag incompatible with use of source surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Get capability bits for source/dest memory combination.
	 */
	if (surf_src != NULL)
	{
	    // initialize the blit caps according to the surface types
	    initAlphaBltCaps(surf_dest_lcl->ddsCaps.dwCaps,
			     surf_src_lcl->ddsCaps.dwCaps,
			     pdrv,
			     &caps,
			     &sbi.helonly);
	}
	else
	{
	    /*
	     * No source surface.  Use caps for vram-to-vram blits and choose
	     * hal or hel based on whether dest surface is in system memory.
	     * If the dest surface is in nonlocal video memory, we also force
	     * emulation as we don't currently support accelerated operation
	     * with nonlocal video memory as a target.
	     */
	    initAlphaBltCaps(DDSCAPS_VIDEOMEMORY,
			     DDSCAPS_VIDEOMEMORY,
			     pdrv,
			     &caps,
			     &sbi.helonly);

	    if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ||
		surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
	    {
		caps.bHALSeesSysmem = FALSE;
		sbi.helonly = TRUE;
	    }
	}

	/*
	 * Can we really blit?      -- Test DDCAPS_BLTCOLORFILL if src surf is null?
	 */
	if (!(caps.dwBothCaps & DDCAPS_BLT))
	{
	    /*
	     * Unable to blit with both HEL and hardware driver.
	     * Can either of them do the blit?
	     */
	    if (caps.dwCaps & DDCAPS_BLT)
	    {
		sbi.halonly = TRUE;   // hardware driver only
	    }
	    else if (caps.dwHELCaps & DDCAPS_BLT)
	    {
		caps.bHALSeesSysmem = FALSE;
		sbi.helonly = TRUE;    // HEL only
	    }
	    else
	    {
		DPF_ERR("Driver does not support blitting");
		LEAVE_BOTH_NOBUSY();
		return DDERR_NOBLTHW;
	    }
	}

	/*
	 * Validate height and width of destination rectangle.
	 */
	if (lpDestRect != NULL)
	{
	    if (!VALID_RECT_PTR(lpDestRect))
	    {
		DPF_ERR("Invalid dest rect specified");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDRECT;
	    }
	    bd.rDest = *(LPRECTL)lpDestRect;
	}
	else
	{
	    MAKE_SURF_RECT(surf_dest, surf_dest_lcl, bd.rDest);
	}

	sbi.dest_height = bd.rDest.bottom - bd.rDest.top;
	sbi.dest_width  = bd.rDest.right  - bd.rDest.left;

	if (((int)sbi.dest_height <= 0) || ((int)sbi.dest_width <= 0))
	{
	    DPF_ERR("Bad dest width or height -- must be positive and nonzero");
	    LEAVE_BOTH_NOBUSY();
	    return DDERR_INVALIDRECT;
	}

	/*
	 * Validate height and width of source rectangle.
	 */
	if (surf_src != NULL)
	{
	    /*
	     * Get source rectangle.
	     */
	    if (lpSrcRect != NULL)
	    {
		if (!VALID_RECT_PTR(lpSrcRect))
		{
		    DPF_ERR("Invalid src rect specified");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDRECT;
		}
		bd.rSrc = *(LPRECTL)lpSrcRect;
	    }
	    else
	    {
		MAKE_SURF_RECT(surf_src, surf_src_lcl, bd.rSrc);
	    }

	    sbi.src_height = bd.rSrc.bottom - bd.rSrc.top;
	    sbi.src_width  = bd.rSrc.right  - bd.rSrc.left;

	    if (((int)sbi.src_height <= 0) || ((int)sbi.src_width <= 0))
	    {
		DPF_ERR("Bad source width or height -- must be positive and nonzero");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDRECT;
	    }
	    /*
	     * Multi-mon: Is this the primary for the desktop?  This is the
	     * only case where the upper-left coord of the surface is not (0,0).
	     */
	    if ((surf_src->lpDD->dwFlags & DDRAWI_VIRTUALDESKTOP) &&
		(surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE))
	    {
		if ((bd.rSrc.left   < surf_src->lpDD->rectDevice.left) ||
		    (bd.rSrc.top    < surf_src->lpDD->rectDevice.top)  ||
		    (bd.rSrc.right  > surf_src->lpDD->rectDevice.right)||
		    (bd.rSrc.bottom > surf_src->lpDD->rectDevice.bottom))
		{
		    DPF_ERR("Source rect doesn't fit on Desktop");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDRECT;
		}
	    }
	    else
	    {
		if ((int)bd.rSrc.left < 0 ||
		    (int)bd.rSrc.top  < 0 ||
		    (DWORD)bd.rSrc.bottom > (DWORD)surf_src->wHeight ||
		    (DWORD)bd.rSrc.right  > (DWORD)surf_src->wWidth)
		{
		    DPF_ERR("Invalid source rect specified");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDRECT;
		}
	    }

	    /*
	     * Verify stretching...
	     */
	    if (sbi.src_height != sbi.dest_height || sbi.src_width != sbi.dest_width)
	    {
		HRESULT ddrval = validateStretching(&caps, &sbi);

		if (ddrval != DD_OK)
		{
		    DPF_ERR("Can't perform specified stretching");
		    LEAVE_BOTH_NOBUSY();
		    return ddrval;
		}
                /*
		 * Do source and dest rectangles lie on the same surface and overlap?
		 */
		if (surf_src_lcl == surf_dest_lcl &&
			IntersectRect(&rect, (LPRECT)&bd.rSrc, (LPRECT)&bd.rDest))
		{
		    DPF_ERR("Can't stretch if source/dest rectangles overlap");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_OVERLAPPINGRECTS;
		}
	    }
	}

	/*
	 * Get pixel-format flags for source and destination surfaces.
	 */
	dwDDPFDestFlags = getPixelFormatPtr(surf_dest_lcl)->dwFlags;
	if (surf_src_lcl != NULL)
	{
	    dwDDPFSrcFlags = getPixelFormatPtr(surf_src_lcl)->dwFlags;
	}
	else
	{
    	    dwDDPFSrcFlags = 0;
	}

	/*
	 * Special Restrictions on Pixel Formats:
	 * -- If the surfaces have pixel formats that either are FOURCCs
	 *    or are understood by the AlphaBlt HEL, no restrictions are
	 *    imposed on the range of AlphaBlt features available for
	 *    blit and fill operations.  All formats that are understood
	 *    by the HEL are listed in the PFTable array in ablthel.c.
	 * -- If either surface has a non-FOURCC pixel format that is not
	 *    understood by AlphaBlt HEL, only a copy blit is permitted.
	 *    For a copy blit, the source and dest formats are identical,
	 *    and features such as stretching, mirroring, filtering, color
	 *    keying, alpha blending, and ARGB scaling are not used.
	 */
	if ((!(dwDDPFDestFlags & DDPF_FOURCC) &&
	    (GetSurfPFIndex(surf_dest_lcl) == PFINDEX_UNSUPPORTED)) ||
	    ((surf_src_lcl != NULL) && !(dwDDPFDestFlags & DDPF_FOURCC) &&
	    (GetSurfPFIndex(surf_src_lcl) == PFINDEX_UNSUPPORTED)))
	{
            LPDDPIXELFORMAT pDDPFDest = getPixelFormatPtr(surf_dest_lcl);
	    LPDDPIXELFORMAT pDDPFSrc  = getPixelFormatPtr(surf_src_lcl);
            /*
	     * This blit involves a non-FOURCC format that is unknown to the
	     * AlphaBlt HEL.  In this case, we accept the blit operation only
	     * if it is a simple copy blit.  It's okay if the rects overlap.
	     */
	    if ((surf_src_lcl == NULL) || !doPixelFormatsMatch(pDDPFDest, pDDPFSrc))
	    {
		DPF_ERR("Only copy blits are available with specified pixel format");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    // Is the DDABLT_NOBLEND flag specified?
	    if (!(dwFlags & DDABLT_NOBLEND))
	    {		
		DPF_ERR("NOBLEND flag is required to blit with specified pixel format");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    // Are any inappropriate DDABLT flags set?

	    if (dwFlags & (DDABLT_MIRRORUPDOWN | DDABLT_MIRRORLEFTRIGHT |
			   DDABLT_KEYSRC | DDABLT_DEGRADEARGBSCALING |
			   DDABLT_FILTERENABLE | DDABLT_FILTERTRANSPBORDER))
	    {
		DPF_ERR("Specified DDABLT flag is incompatible with pixel format");
                LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
            // Is stretching required for this blit?
            if (sbi.src_height != sbi.dest_height || sbi.src_width != sbi.dest_width)
	    {
		DPF_ERR("Stretching is not permitted with specified pixel format");
                LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    // Are the ARGB-scaling factors disabled (i.e., set to all ones)?
	    if (*(LPDWORD)&ddargbScaleFactors != ~0UL)
	    {
		DPF_ERR("ARGB scaling must be disabled with specified pixel format");
                LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}

	/*
	 * Do source and dest rectangles lie on the same surface and overlap?
	 */
	if (surf_src_lcl == surf_dest_lcl &&
		IntersectRect(&rect, (LPRECT)&bd.rSrc, (LPRECT)&bd.rDest))
	{
	    /*
	     * Yes, enforce restrictions on blits with overlapping rectangles.
	     */
	    if (!(dwFlags & DDABLT_NOBLEND))
	    {
	        DPF_ERR("Can't blit between overlapping rects unless NOBLEND flag is set");
		LEAVE_BOTH_NOBUSY();
		return DDERR_OVERLAPPINGRECTS;
	    }
	    if (dwFlags & (DDABLT_MIRRORUPDOWN | DDABLT_MIRRORLEFTRIGHT |
			   DDABLT_KEYSRC | DDABLT_DEGRADEARGBSCALING |
			   DDABLT_FILTERENABLE | DDABLT_FILTERTRANSPBORDER))
	    {
	        DPF_ERR("Specified flag is illegal if source/dest rectangles overlap");
		LEAVE_BOTH_NOBUSY();
		return DDERR_OVERLAPPINGRECTS;
	    }
	    if (dwDDPFDestFlags & DDPF_FOURCC)
	    {
		DPF_ERR("Overlapping source/dest rectangles illegal with FOURCC surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_OVERLAPPINGRECTS;
	    }
	}

	/*
         * Does the destination surface have a FOURCC pixel format?
	 */
	if (dwDDPFDestFlags & DDPF_FOURCC)
	{
	    // The DDABLT_USEFILLVALUE flag is illegal with a FOURCC dest surface.
	    if (dwFlags & DDABLT_USEFILLVALUE)
	    {
		DPF_ERR("Can't use USEFILLVALUE flag with FOURCC dest surface");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}

	fail = FALSE;   // initialize before using GETFAILCODEBLT macro

	/*
	 * Validate source color key.
	 */
	if (dwFlags & DDABLT_KEYSRC)
	{
            DDASSERT(surf_src != NULL);
	    // make sure we can do this
	    if (!(caps.dwBothCKeyCaps & DDCKEYCAPS_SRCBLT))
	    {
		GETFAILCODEBLT(caps.dwCKeyCaps,
			       caps.dwHELCKeyCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDCKEYCAPS_SRCBLT);
		if (fail)
		{
		    DPF_ERR("KEYSRC specified, not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOCOLORKEYHW;
		}
	    }
	    if (!(surf_src_lcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) ||
		(dwDDPFSrcFlags & (DDPF_FOURCC | DDPF_ALPHAPIXELS)))
	    {
		/*
		 * If the src color-key flag is set but the source surface has
		 * no associated src color key, just clear the flag instead of
		 * treating this as an error.
		 */
		dwFlags &= ~DDABLT_KEYSRC;
	    }
	}

	/*
	 * Validate up/down mirroring
	 */
	if (dwFlags & DDABLT_MIRRORUPDOWN)
	{
	    DDASSERT(surf_src != NULL);
	    if (!(caps.dwBothFXCaps & DDFXCAPS_BLTMIRRORUPDOWN))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTMIRRORUPDOWN);
		if (fail)
		{
		    DPF_ERR("Mirror up/down specified, not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOMIRRORHW;
		}
	    }
	}

	/*
	 * Validate left/right mirroring
	 */
	if (dwFlags & DDABLT_MIRRORLEFTRIGHT)
	{
	    DDASSERT(surf_src != NULL);
	    if (!(caps.dwBothFXCaps & DDFXCAPS_BLTMIRRORLEFTRIGHT))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTMIRRORLEFTRIGHT);
		if (fail)
		{
		    DPF_ERR("Mirror left/right specified, not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOMIRRORHW;
		}
	    }
	}

	/*
	 * Does destination surface have a palette-indexed pixel format?
	 */
	if (dwDDPFDestFlags & (DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 |
			       DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8))
	{
	    /*
	     * Is this a blit or a color-fill operation?
	     */
	    if (surf_src_lcl == NULL)
	    {
		/*
		 * Color-Fill: Palette-indexed dest is illegal without USEFILLVALUE flag.
		 */
		if (!(dwFlags & DDABLT_USEFILLVALUE))
		{
    		    DPF_ERR("USEFILLVALUE flag required to fill palette-indexed dest surface");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
	    }
	    else
	    {
		/*
		 * Blit: Destination surface is palette-indexed, so we require source
		 * surface to have same pixel format as destination.  (Note that this
		 * also makes color fills illegal to palette-indexed dest surfaces.)
		 */
		if (dwDDPFSrcFlags != dwDDPFDestFlags)
		{
		    DPF_ERR("If dest is palette-indexed, source must have same pixel format");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
		if (dwFlags & (DDABLT_FILTERENABLE | DDABLT_FILTERTRANSPBORDER))
		{
		    DPF_ERR("Illegal to specify filtering with palette-indexed destination");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
		if (*(LPDWORD)&ddargbScaleFactors != ~0UL)
		{
		    DPF_ERR("Illegal to enable ARGB scaling with palette-indexed destination");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
		/*
		 * If source and dest surfaces both have attached palettes, we require that
		 * they reference the same palette object.  In a later release, we may relax
		 * this requirement in order to support color-table conversion or dithering.
		 */
		if ((surf_src_lcl->lpDDPalette != NULL) &&
		    (surf_dest_lcl->lpDDPalette != NULL) &&
		    (surf_src_lcl->lpDDPalette->lpLcl->lpGbl->lpColorTable !=
		     surf_dest_lcl->lpDDPalette->lpLcl->lpGbl->lpColorTable))
		{
		    DPF_ERR("If source and dest surfaces both have palettes, must be same palette");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
	    }
	}
	else if (dwDDPFSrcFlags & (DDPF_PALETTEINDEXED1 | DDPF_PALETTEINDEXED2 |
				   DDPF_PALETTEINDEXED4 | DDPF_PALETTEINDEXED8) &&
		    (surf_src_lcl->lpDDPalette == NULL ||
		     surf_src_lcl->lpDDPalette->lpLcl->lpGbl->lpColorTable == NULL))
	{
	    /*
	     * Conversion of source pixels to destination pixel format is
	     * impossible because source surface has no attached palette.
	     */
	    DPF_ERR( "No palette associated with palette-indexed source surface" );
	    LEAVE_BOTH_NOBUSY();
	    return DDERR_NOPALETTEATTACHED;
	}

	/*
	 * We do no ARGB scaling if NOBLEND flag is set.
	 */
	if (dwFlags & DDABLT_NOBLEND)
	{
	    if (dwFlags & DDABLT_DEGRADEARGBSCALING)
	    {
		DPF_ERR("NOBLEND and DEGRADEARGBSCALING flags are incompatible");
		LEAVE_BOTH();
		return DDERR_INVALIDPARAMS;
	    }
	    if (surf_src != NULL && *(LPDWORD)&ddargbScaleFactors != ~0UL)
	    {
		DPF_ERR("ARGB scaling of source surface illegal if NOBLEND flag is set");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else if ((dwDDPFSrcFlags | dwDDPFDestFlags) & DDPF_ALPHAPIXELS)
	{
	    /*
	     * We've been asked to perform a blit or fill that requires blending
	     * with the alpha-channel information in the pixel formats for one
	     * or both surfaces.  Verify that the driver supports this.
	     */
	    if (!(caps.dwBothFXCaps & DDFXCAPS_BLTALPHA))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTALPHA);
		if (fail)
		{
		    DPF_ERR("Alpha-blended blit requested, but not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	    /*
	     * Verify that the driver supports surfaces whose pixel
	     * formats contain an alpha-channel component.
	     */
	    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTALPHAPIXELS))
	    {
		GETFAILCODEBLT(caps.dwAlphaCaps,
			       caps.dwHELAlphaCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDALPHACAPS_BLTALPHAPIXELS);
		if (fail)
		{
		    DPF_ERR("Alpha pixel format specified, but not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }

	    /*
	     * Does dest surface have alpha channel?
	     */
	    if (dwDDPFDestFlags & DDPF_ALPHAPIXELS)
	    {
		/*
		 * Verify that destination surface has a premultiplied-
		 * alpha pixel format.  Non-premultiplied alpha won't do.
		 */
		if (!(dwDDPFDestFlags & DDPF_ALPHAPREMULT))
		{
		    DPF_ERR("Illegal to blend with non-premultiplied alpha in dest surface");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_INVALIDPARAMS;
		}
		/*
		 * Verify that driver can handle premultiplied-alpha pixel format.
		 * (Dest surface is not allowed to be non-premultiplied alpha.)
		 */
		if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTPREMULT))
		{
		    GETFAILCODEBLT(caps.dwAlphaCaps,
				   caps.dwHELAlphaCaps,
				   sbi.halonly,
				   sbi.helonly,
				   DDALPHACAPS_BLTPREMULT);
		    if (fail)
		    {
			DPF_ERR("No driver support for premultiplied alpha");
			LEAVE_BOTH_NOBUSY();
			return DDERR_NOALPHAHW;
		    }
		}
	    }

	    /*
	     * Does source surface have alpha channel?
	     */
	    if (dwDDPFSrcFlags & DDPF_ALPHAPIXELS)
	    {
                /*
		 * Are we asking the driver to handle both ARGB scaling and a
		 * source alpha channel when it can't do both at the same time?
		 */
		if (*(LPDWORD)&ddargbScaleFactors != ~0 &&
		    !(caps.dwBothAlphaCaps & DDALPHACAPS_BLTALPHAANDARGBSCALING) &&
                    !(dwFlags & DDABLT_DEGRADEARGBSCALING))
		{
                    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTALPHAANDARGBSCALING))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTALPHAANDARGBSCALING);
			if (fail)
			{
			    DPF_ERR("No driver support for alpha channel and ARGB scaling in same blit");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }
		}
		/*
		 * Are color components in pixel format premultiplied by the
		 * alpha component or not?  In either case, verify that the
		 * driver supports the specified alpha format.
		 */
		if (dwDDPFSrcFlags & DDPF_ALPHAPREMULT)
		{
		    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTPREMULT))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTPREMULT);
			if (fail)
			{
			    DPF_ERR("No driver support for premultiplied alpha");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }
		}
		else
		{
		    DWORD val = 0x01010101UL*ddargbScaleFactors.alpha;

		    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTNONPREMULT))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTNONPREMULT);
			if (fail)
			{
			    DPF_ERR("No driver support for non-premultiplied alpha");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }

		    /*
		     * We allow only one-factor ARGB scaling with a source
		     * surface that has a non-premultiplied alpha pixel format.
		     * The following code enforces this rule.
		     */
		    if (*(LPDWORD)&ddargbScaleFactors != val)
		    {
			if (dwFlags & DDABLT_DEGRADEARGBSCALING)
			{
			    *(LPDWORD)&ddargbScaleFactors = val;
			}
			else
			{
			    DPF_ERR("Can't do 2 or 4-mult ARGB scaling with non-premultiplied alpha surface");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_INVALIDPARAMS;
			}
		    }
		}
	    }
	}

	/*
	 * If filtering is to be explicitly enabled or disabled, verify that
	 * the hardware driver is capable of performing the blit as requested.
	 */
	if (dwFlags & (DDABLT_FILTERENABLE | DDABLT_FILTERDISABLE | DDABLT_FILTERTRANSPBORDER))
	{
	    /*
	     * Is driver capable of doing any kind of filtering at all?
	     */
	    if (!(caps.dwBothFXCaps & DDFXCAPS_BLTFILTER))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTFILTER);
		if (fail)
		{
		    DPF_ERR("No driver support for filtered blit");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	    if (!(~dwFlags & (DDABLT_FILTERENABLE | DDABLT_FILTERDISABLE)))
	    {
		DPF_ERR("Illegal to both enable and disable filtering");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    if (!(~dwFlags & (DDABLT_FILTERTRANSPBORDER | DDABLT_FILTERDISABLE)))
	    {
		DPF_ERR("Illegal to set FILTERTRANSPBORDER if filtering is explicitly disabled");
		LEAVE_BOTH_NOBUSY();
		return DDERR_INVALIDPARAMS;
	    }
	    if ((dwFlags & DDABLT_FILTERENABLE) &&
                !(caps.dwBothFilterCaps & DDFILTCAPS_BLTQUALITYFILTER))
	    {
		GETFAILCODEBLT(caps.dwFilterCaps,
			       caps.dwHELFilterCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFILTCAPS_BLTQUALITYFILTER);
		if (fail)
		{
		    DPF_ERR("No driver support for filtered blit");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	    if ((dwFlags & DDABLT_FILTERDISABLE) &&
                !(caps.dwBothFilterCaps & DDFILTCAPS_BLTCANDISABLEFILTER))
	    {
		GETFAILCODEBLT(caps.dwFilterCaps,
			       caps.dwHELFilterCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFILTCAPS_BLTCANDISABLEFILTER);
		if (fail)
		{
		    DPF_ERR("Driver cannot disable filtering for blits");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	    if ((dwFlags & DDABLT_FILTERTRANSPBORDER) &&
                !(caps.dwBothFilterCaps & DDFILTCAPS_BLTTRANSPBORDER))
	    {
		GETFAILCODEBLT(caps.dwFilterCaps,
			       caps.dwHELFilterCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFILTCAPS_BLTTRANSPBORDER);
		if (fail)
		{
		    DPF_ERR("Driver cannot filter with transparent border");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }
	}

	/*
	 * Validate ARGB scaling factors.
	 */
	if (!(dwFlags & DDABLT_DEGRADEARGBSCALING) &&
		    *(LPDWORD)&ddargbScaleFactors != ~0UL &&
                    !(surf_src_lcl == NULL && ddargbScaleFactors.alpha == 255))
	{
	    /*
	     * Some kind of ARGB scaling is specified.  Can the driver
	     * do any kind of alpha blending at all?
	     */
            if (!(caps.dwBothFXCaps & DDFXCAPS_BLTALPHA))
	    {
		GETFAILCODEBLT(caps.dwFXCaps,
			       caps.dwHELFXCaps,
			       sbi.halonly,
			       sbi.helonly,
			       DDFXCAPS_BLTALPHA);
		if (fail)
		{
		    DPF_ERR("ARGB scaling requested for blit, but not supported");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_NOALPHAHW;
		}
	    }

	    /*
	     * We permit a color factor to be bigger than the alpha
	     * factor only if the hardware uses saturated arithmetic
	     * to prevent the calculated color value from overflowing.
	     */
	    if (!(dwFlags & DDABLT_NOBLEND) &&
		   (ddargbScaleFactors.red   > ddargbScaleFactors.alpha ||
		    ddargbScaleFactors.green > ddargbScaleFactors.alpha ||
		    ddargbScaleFactors.blue  > ddargbScaleFactors.alpha))
	    {
		/*
		 * Driver must be capable of doing saturated arithmetic.
		 */
		if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTSATURATE))
		{
		    GETFAILCODEBLT(caps.dwAlphaCaps,
				   caps.dwHELAlphaCaps,
				   sbi.halonly,
				   sbi.helonly,
				   DDALPHACAPS_BLTSATURATE);
		    if (fail)
		    {
			// Neither the H/W driver nor HEL can handle it, so fail.
			DPF_ERR("Driver can't do saturated arithmetic during alpha blending");
			LEAVE_BOTH_NOBUSY();
			return DDERR_NOALPHAHW;
		    }
		}
	    }
	    /*
	     * Is this an alpha-blit or an alpha-fill operation?
	     */
	    if (surf_src_lcl == NULL)
	    {
		/*
		 * This is an alpha fill.  Can the driver handle it?
		 */
		if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTALPHAFILL))
		{
		    GETFAILCODEBLT(caps.dwAlphaCaps,
				   caps.dwHELAlphaCaps,
				   sbi.halonly,
				   sbi.helonly,
				   DDALPHACAPS_BLTALPHAFILL);
		    if (fail)
		    {
			// Neither the H/W driver nor HEL can handle it, so fail.
			DPF_ERR("Driver can't do alpha-blended color-fill operation");
			LEAVE_BOTH_NOBUSY();
			return DDERR_NOALPHAHW;
		    }
		}
    	    }
	    else
	    {
    		/*
		 * Alpha blit.  Can the driver handle any ARGB scaling at all?
		 */
		#define ARGBSCALINGBITS   \
		(DDALPHACAPS_BLTARGBSCALE1F | DDALPHACAPS_BLTARGBSCALE2F | DDALPHACAPS_BLTARGBSCALE4F)

		if (!(caps.dwBothAlphaCaps & ARGBSCALINGBITS))
		{
		    GETFAILCODEBLT(caps.dwAlphaCaps,
				   caps.dwHELAlphaCaps,
				   sbi.halonly,
				   sbi.helonly,
				   ARGBSCALINGBITS);
		    if (fail)
		    {
			// Neither the H/W driver nor HEL can handle it, so fail.
			DPF_ERR("Driver can't handle any ARGB scaling at all");
			LEAVE_BOTH_NOBUSY();
			return DDERR_NOALPHAHW;
		    }
		}
		#undef ARGBSCALINGBITS

		if (ddargbScaleFactors.red != ddargbScaleFactors.green ||
			ddargbScaleFactors.red != ddargbScaleFactors.blue)
		{
		    /*
		     * Driver must be capable of doing 4-factor ARGB scaling.
		     */
		    if (!(caps.dwBothAlphaCaps & DDALPHACAPS_BLTARGBSCALE4F))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTARGBSCALE4F);
			if (fail)
			{
			    // Neither the H/W driver nor HEL can handle it, so fail.
			    DPF_ERR("Driver can't handle 4-factor ARGB scaling");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }
		}
		else if (ddargbScaleFactors.red != ddargbScaleFactors.alpha)
		{
		    /*
		     * Driver must be capable of doing 2-factor ARGB scaling.
		     */
		    if (!(caps.dwBothAlphaCaps & (DDALPHACAPS_BLTARGBSCALE2F |
						  DDALPHACAPS_BLTARGBSCALE4F)))
		    {
			GETFAILCODEBLT(caps.dwAlphaCaps,
				       caps.dwHELAlphaCaps,
				       sbi.halonly,
				       sbi.helonly,
				       DDALPHACAPS_BLTARGBSCALE2F |
						  DDALPHACAPS_BLTARGBSCALE4F);
			if (fail)
			{
			    // Neither the H/W driver nor HEL can handle it, so fail.
			    DPF_ERR("Driver can't handle 2-factor ARGB scaling");
			    LEAVE_BOTH_NOBUSY();
			    return DDERR_NOALPHAHW;
			}
		    }
		}
	    }
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
	DPF_ERR("Exception encountered validating parameters");
	LEAVE_BOTH_NOBUSY();
	return DDERR_INVALIDPARAMS;
    }

    DDASSERT(!(sbi.halonly && sbi.helonly));

    /*
     * Are we permitted to degrade the specified ARGB-scaling operation
     * to one the driver can handle?
     */
    if (dwFlags & DDABLT_DEGRADEARGBSCALING)
    {
	DWORD dwFXCaps, dwAlphaCaps;

        // Get the caps for the selected driver.
	dwFXCaps = (sbi.helonly) ? caps.dwHELFXCaps : caps.dwFXCaps;
	dwAlphaCaps = (sbi.helonly) ? caps.dwHELAlphaCaps : caps.dwAlphaCaps;

	if (!(dwFXCaps & DDFXCAPS_BLTALPHA))
	{
	    /*
	     * The driver should have done this anyway, but just in case...
	     */
	    dwAlphaCaps = 0;
	}

	/*
	 * Is this a blit or a fill operation?
	 */
	if (surf_src_lcl == NULL)
	{
	    /*
	     * This is a fill -- and possibly an alpha fill.
	     */
	    if (!(dwAlphaCaps & DDALPHACAPS_BLTALPHAFILL))
	    {
		/*
		 * The driver can't do an alpha fill, so we'll ask
		 * it to do just a simple color fill instead.
		 */
		ddargbScaleFactors.alpha = 255;
	    }
	}
	else
	{
	    /*
	     * This is a blit.  What are the driver's ARGB-scaling capabilities?
	     */
	    if (!(dwAlphaCaps & (DDALPHACAPS_BLTARGBSCALE1F |
				 DDALPHACAPS_BLTARGBSCALE2F |
				 DDALPHACAPS_BLTARGBSCALE4F)))
	    {
		/*
		 * Driver can't do any kind of ARGB scaling at all, so just
		 * disable ARGB scaling by setting all four factors to 255.
		 */
		*(LPDWORD)&ddargbScaleFactors = ~0UL;
	    }
	    else if (!(dwAlphaCaps & (DDALPHACAPS_BLTARGBSCALE2F |
				      DDALPHACAPS_BLTARGBSCALE4F)))
	    {
    		/*
		 * The driver can do only 1-factor ARGB scaling, so set the
		 * three color factors to the same value as the alpha factor.
		 */
                *(LPDWORD)&ddargbScaleFactors = 0x01010101UL*ddargbScaleFactors.alpha;
	    }
	    else if (!(dwAlphaCaps & DDALPHACAPS_BLTARGBSCALE4F))
	    {
    		/*
		 * Driver can do only 2-factor ARGB scaling, so make sure
		 * all three color factors are set to the same value.
		 */
		if (ddargbScaleFactors.red != ddargbScaleFactors.green ||
			ddargbScaleFactors.red != ddargbScaleFactors.blue)
		{
		    /*
		     * Set all three color factors to value F, which is the
		     * weighted average of their specified values (Fr,Fg,Fb):
		     *     F = .299*Fr + .587*Fg + .114*Fb
		     */
		    DWORD F = 19595UL*ddargbScaleFactors.red +
				38470UL*ddargbScaleFactors.green +
				7471UL*ddargbScaleFactors.blue;

		    ddargbScaleFactors.red =
			ddargbScaleFactors.green =
			ddargbScaleFactors.blue = (BYTE)(F >> 16);
		}
	    }
	    if (!(dwAlphaCaps & DDALPHACAPS_BLTALPHAANDARGBSCALING))
	    {
    		/*
		 * Driver can't handle both a source alpha channel and ARGB scaling
		 * factors in the same blit operation, so just turn off ARGB scaling.
		 */
		*(LPDWORD)&ddargbScaleFactors = ~0UL;
	    }
	}

	/*
	 * Can driver do saturated arithmetic for alpha blit or alpha fill?
	 */
	if (!(dwAlphaCaps & DDALPHACAPS_BLTSATURATE))
	{
	    /*
	     * Driver can't do saturated arithmetic, so make sure no
	     * no color factors exceed the value of the alpha factor.
	     */
	    if (ddargbScaleFactors.red > ddargbScaleFactors.alpha)
	    {
		ddargbScaleFactors.red = ddargbScaleFactors.alpha;
	    }
	    if (ddargbScaleFactors.green > ddargbScaleFactors.alpha)
	    {
		ddargbScaleFactors.green = ddargbScaleFactors.alpha;
	    }
	    if (ddargbScaleFactors.blue > ddargbScaleFactors.alpha)
	    {
		ddargbScaleFactors.blue = ddargbScaleFactors.alpha;
	    }
	}
    }

    /*
     * Tell the driver to do the blit.
     */
    TRY
    {
	/*
	 * Finish loading blit data for HAL callback.
	 */
        bd.lpDD = pdrv;
	bd.lpDDDestSurface = surf_dest_lcl;
	bd.lpDDSrcSurface = surf_src_lcl;
	bd.ddargbScaleFactors = ddargbScaleFactors;
        bd.bltFX.dwSize = sizeof( DDBLTFX );
	/*
	 * For the AlphaBlt callback, the rOrigDest and rOrigSrc members
	 * ALWAYS contain the original dest and source rects.
	 */
	bd.rOrigDest = bd.rDest;
	bd.rOrigSrc = bd.rSrc;
        /*
         * The only AlphaBlt API flags that are propagated to the
	 * driver are those that have no Blt API equivalents.
         */
	bd.dwAFlags = dwFlags & (DDABLT_FILTERENABLE | DDABLT_FILTERDISABLE |
				 DDABLT_FILTERTRANSPBORDER | DDABLT_NOBLEND);
        /*
         * This flag tells the driver that it's a source-over-dest operation.
         * This flag is never passed by the Blt API, so drivers which have a
         * unified DDI can distinguish who called them
         */
        bd.dwAFlags |= DDABLT_SRCOVERDEST;

	if (dwFlags & DDABLT_KEYSRC)   // source color key?
	{
	    bd.dwFlags |= DDBLT_KEYSRCOVERRIDE;
	    bd.bltFX.ddckSrcColorkey = surf_src_lcl->ddckCKSrcBlt;
	}

	if (dwFlags & (DDABLT_MIRRORLEFTRIGHT | DDABLT_MIRRORUPDOWN))
	{
	    bd.dwFlags |= DDBLT_DDFX;

	    if (dwFlags & DDABLT_MIRRORLEFTRIGHT)    //left-right mirroring?
	    {
		bd.bltFX.dwDDFX |= DDBLTFX_MIRRORLEFTRIGHT;
	    }
	    if (dwFlags & DDABLT_MIRRORUPDOWN)	     // up-down mirroring?
	    {
		bd.bltFX.dwDDFX |= DDBLTFX_MIRRORUPDOWN;
	    }
	}

	/*
	 * If the specified blit operation can be handled by the Blt HAL
	 * callback instead of by the AlphaBlt HAL callback, should it
	 * treat the blit as a color-fill or a source-copy operation?
	 */
	if (surf_src_lcl != NULL)
	{
	    //it's a srccopy. Set flags appropriately
	    bd.dwFlags |= DDBLT_ROP;
	    bd.bltFX.dwROP = SRCCOPY;
	    bd.dwROPFlags = ROP_HAS_SOURCE;  // 0x00000001
	}
	else
	{
            // This is a fill operation of some kind.
	    if (dwFlags & DDABLT_USEFILLVALUE)
	    {
    		HRESULT hres;

		// The client specified a fill value in the dest pixel format.
		bd.bltFX.dwFillColor = dwFillValue;
                bd.dwFlags |= DDBLT_COLORFILL;
	    }
	    else if ((bd.ddargbScaleFactors.alpha == 255) || (dwFlags & DDABLT_NOBLEND))
	    {
                // The client specified an alpha fill, but no alpha blending is
		// required, so we can replace it with a simple color fill.
		// convert the ARGB value to a physcolor:
		HRESULT hres = ConvertToPhysColor(
						  surf_dest_lcl,
						  &bd.ddargbScaleFactors,
						  &bd.bltFX.dwFillColor);

                // Make sure this is not a FOURCC or some other funny pixel format.
		if (hres == DD_OK)
		{
		    bd.dwFlags |= DDBLT_COLORFILL;
		}
	    }
	}

#ifdef WINNT
	// Did the mode change since ENTER_DDRAW?
	if (DdQueryDisplaySettingsUniqueness() != uDisplaySettingsUnique)
	{
	    // mode changed, don't do the blt
	    DPF_ERR("Mode changed between ENTER_DDRAW and HAL call");
	    LEAVE_BOTH_NOBUSY()
		return DDERR_SURFACELOST;
	}
#endif

#if defined(WIN95)
	/*
	 * Some drivers (like S3) do stuff in their BeginAccess call
	 * that screws up stuff that they did in their DDHAL Lock Call.
	 *
	 * Exclusion needs to happen BEFORE the lock call to prevent this.
	 *
	 */
	if (surf_dest_lcl->lpDDClipper != NULL)
	{
	    /*
	     * exclude the mouse cursor.
	     *
	     * we only need to do this for the windows display driver
	     *
	     * we only need to do this if we are blitting to or from the
	     * primary surface.
	     *
	     * we only do this in the clipping case, we figure if the
	     * app cares enough to not scribble all over other windows
	     * he also cares enough to not to wipe out the cursor.
	     *
	     * we only need to do this if the driver is using a
	     * software cursor.
	     *
	     * NOTE
	     *  we should check and only do this on the primary?
	     *  we should make sure the clipper is window based?
	     *  we should check for the source being the primary?
	     *
	     */
	    if ((pdrv->dwFlags & DDRAWI_DISPLAYDRV) && pdrv->dwPDevice &&
		!(*pdrv->lpwPDeviceFlags & HARDWARECURSOR) &&
                (surf_dest->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) )
	    {
		if (lpDDDestSurface == lpDDSrcSurface)
		{
		    RECTL rcl;
		    UnionRect((RECT*)&rcl, (RECT*)&bd.rDest, (RECT*)&bd.rSrc);
		    DD16_Exclude(pdrv->dwPDevice, &rcl);
		}
		else
		{
		    DD16_Exclude(pdrv->dwPDevice, &bd.rDest);
		}
	    }
	}
#endif

#ifdef WINNT
    get_clipping_info:
#endif
	/*
	 * Determine clipping region for destination surface.
	 */
	{
	    LPDIRECTDRAWCLIPPER pClipper;
	    RECT rcDestSurf;

	    pRgn = (LPRGNDATA)&myRgnBuffer;  // this buffer's probably big enough
	    pClipper = (LPDIRECTDRAWCLIPPER)surf_dest_lcl->lpSurfMore->lpDDIClipper;
	    SetRect(&rcDestSurf, 0, 0, surf_dest->wWidth, surf_dest->wHeight);

	    if (pClipper == NULL)
	    {
		/*
		 * The destination surface has no attached clipper.
		 * Set the clip region to a single rectangle the
		 * width and height of the primary surface.
		 */
		pRgn->rdh.nCount = 1;        // default = a single clip rect
		memcpy((LPRECT)&pRgn->Buffer, &rcDestSurf, sizeof(RECT));
                /*
                 * Add a rect to the region list if this is a managed surface
                 */
                if(IsD3DManaged(surf_dest_lcl))
                {
                    LPREGIONLIST lpRegionList = surf_dest_lcl->lpSurfMore->lpRegionList;
                    if(lpDestRect)
                    {
                        if(lpRegionList->rdh.nCount != NUM_RECTS_IN_REGIONLIST)
                        {
                            lpRegionList->rect[(lpRegionList->rdh.nCount)++] = bd.rDest;
                            lpRegionList->rdh.nRgnSize += sizeof(RECT);
                            if(bd.rDest.left < lpRegionList->rdh.rcBound.left)
                                lpRegionList->rdh.rcBound.left = bd.rDest.left;
                            if(bd.rDest.right > lpRegionList->rdh.rcBound.right)
                                lpRegionList->rdh.rcBound.right = bd.rDest.right;
                            if(bd.rDest.top < lpRegionList->rdh.rcBound.top)
                                lpRegionList->rdh.rcBound.top = bd.rDest.top;
                            if(bd.rDest.bottom > lpRegionList->rdh.rcBound.bottom)
                                lpRegionList->rdh.rcBound.bottom = bd.rDest.bottom;
                        }
                    }
                    else
                    {
                        /* Mark everything dirty */
                        lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                    }
                }
	    }
	    else
	    {
		DWORD rgnSize = 0;
		LPDDRAWI_DIRECTDRAW_GBL pdrv = surf_dest_lcl->lpGbl->lpDD;

		/*
		 * This surface has an attached clipper.  Get the clip list.
		 */
		ddrval = InternalGetClipList(pClipper,
					     &rcDestSurf,
					     NULL,  // we just want rgnSize
					     &rgnSize,
					     pdrv);
		if (ddrval != DD_OK)
		{
		    DPF_ERR("Couldn't get size of clip region");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_GENERIC;
		}
		if (rgnSize > sizeof(myRgnBuffer))
		{
		    /*
		     * Statically allocated region buffer isn't big enough.
		     * Need to dynamically allocate a bigger buffer.
		     */
		    pRgn = (LPRGNDATA)MemAlloc(rgnSize);
		    if (!pRgn)
		    {
			// couldn't allocate memory for clip region
			DPF_ERR("Can't allocate memory to buffer clip region");
			LEAVE_BOTH_NOBUSY();
			return DDERR_OUTOFMEMORY;
		    }
		}
		ddrval = InternalGetClipList(pClipper,
					     &rcDestSurf,
					     pRgn,
					     &rgnSize,
					     pdrv);
		if (ddrval != DD_OK)
		{
		    // can't get clip region
		    if (pRgn != (LPRGNDATA)&myRgnBuffer)
		    {
			MemFree(pRgn);
		    }
		    DPF_ERR("Can't get dest clip region");
		    LEAVE_BOTH_NOBUSY();
		    return DDERR_GENERIC;
		}

                if(IsD3DManaged(surf_dest_lcl))
                {
                    /* We don't want to deal with this mess, so mark everything dirty */
                    surf_dest_lcl->lpSurfMore->lpRegionList->rdh.nCount = NUM_RECTS_IN_REGIONLIST;
                }
	    }
	    /*
	     * Load clipping info into data struct for HAL callback.
	     */
	    bd.dwRectCnt = pRgn->rdh.nCount;
	    bd.prDestRects = (LPRECT)&pRgn->Buffer;
	}

	/*
	 * Does the driver have to do any clipping?
	 */
	if (bd.dwRectCnt > 1)
	{
            // Yes, clipping is (probably) required.
	    bd.IsClipped = TRUE;
	}
	else if (bd.dwRectCnt == 0)
	{
	    // Window is completely obscured, so don't draw anything.
	    LEAVE_BOTH_NOBUSY();
	    return DD_OK;
	}
	else
	{
	    /*
	     * The visibility region consists of a single clip rect.
	     * Is any portion of the destination rectangle visible?
	     */
	    if (!IntersectRect((LPRECT)&bd.rDest, (LPRECT)&bd.rOrigDest,
				&bd.prDestRects[0]))
	    {
		// No portion of the destination rectangle is visible.
		LEAVE_BOTH_NOBUSY();
		return DD_OK;
	    }

	    /*
	     * Will the source rectangle have to be adjusted to
	     * compensate for the clipping of the dest rect?
	     */
	    if (surf_src_lcl != NULL &&
		    !EqualRect((LPRECT)&bd.rDest, (LPRECT)&bd.rOrigDest))
	    {
		// Yes, the source rect must be adjusted.
		if (sbi.dest_width != sbi.src_width ||
			sbi.dest_height != sbi.src_height)
		{
		    /*
		     * The driver must do the clipping for a stretched blit
		     * because bd.rSrc permits us to express the adjusted
		     * source rect only to the nearest integer coordinates.
		     */
		    bd.IsClipped = TRUE;
		}
		else
		{
    		    // We can do the clipping here for a nonstretched blit.
		    POINT p;

		    p.x = bd.rOrigSrc.left - bd.rOrigDest.left;
		    p.y = bd.rOrigSrc.top  - bd.rOrigDest.top;
		    CopyRect((LPRECT)&bd.rSrc, (LPRECT)&bd.rDest);
		    OffsetRect((LPRECT)&bd.rSrc, p.x, p.y);
		}
	    }
	}

        /*
	 * Older drivers may support the Blt callback, but not the AlphaBlt
	 * callback.  One of these drivers may be able to perform the specified
	 * blit operation as long as it doesn't use any AlphaBlt-specific
	 * features such as alpha blending, ARGB scaling, or filtering.
	 * In this case, we can use the Blt callback to perform the blit.
         * Decide which DDI to call. Start off assuming Alpha DDI
         */
	bltfn = pdrv_lcl->lpDDCB->HALDDMiscellaneous2.AlphaBlt;
        bd.dwFlags |= DDBLT_AFLAGS;   // assume we'll use AlphaBlt callback

        /*
         * Check to see if we can pass this call to old blt DDI
         */
        if ( !((dwDDPFDestFlags | dwDDPFSrcFlags) & DDPF_ALPHAPIXELS) &&
		 !(dwFlags & DDABLT_FILTERENABLE) )
        {
            // There are no alpha pixels involved. Maybe we can use the Blt DDI
            if ( (bd.ddargbScaleFactors.alpha == 255) && (!sbi.helonly) )
            {
		LPDDPIXELFORMAT pDDPFDest = getPixelFormatPtr(surf_dest_lcl);
		LPDDPIXELFORMAT pDDPFSrc = getPixelFormatPtr(surf_src_lcl);

		// If this is a blit (and not a color fill), the source and dest pixel
		// formats must be identical and the scaling factors must all be 1.0.
		if ( (surf_src_lcl == NULL) ||
		     (!memcmp(pDDPFDest, pDDPFSrc, sizeof(DDPIXELFORMAT)) &&
		      (~0UL == *((LPDWORD)(&bd.ddargbScaleFactors)))) )
		{
		    // Make sure the driver doesn't have to do any clipping.  Also ensure
		    // that the driver does not require DDraw to pagelock sysmem surfaces.
		    if (!bd.IsClipped &&
    			(!caps.bHALSeesSysmem ||
                         pdrv->ddCaps.dwCaps2 & DDCAPS2_NOPAGELOCKREQUIRED))
		    {
			// Verify that the driver supports the Blt HAL callback.
			bltfn = (LPDDHAL_ALPHABLT) pdrv_lcl->lpDDCB->HALDDSurface.Blt;

			if (bltfn)
			{
			    bd.dwFlags &= ~DDBLT_AFLAGS;  // we'll use Blt callback
			    if (surf_src_lcl == NULL)
			    {
				DPF(4,"Calling Blt DDI for AlphaBlt color fill");
			    }
			    else
			    {
				DPF(4,"Calling Blt DDI for AlphaBlt copy");
			    }
			    /*
			     * The following thunk address is used by the Blt callback,
			     * but is ignored by the AlphaBlt callback.
			     */
			    bd.Blt = pdrv_lcl->lpDDCB->cbDDSurfaceCallbacks.Blt;
			}
		    }
		}
            }
        }

	/*
	 * Set up for a HAL or a HEL call?
	 */
	if (bltfn == NULL)
	{
            /*
             * Neither the alphablt nor blt ddi calls apply or aren't implemented
             */
	    sbi.helonly = TRUE;
	}
	if (sbi.helonly && sbi.halonly)
	{
	    DPF_ERR("AlphaBlt not supported in software or hardware");
	    if (pRgn != (LPRGNDATA)&myRgnBuffer)
	    {
		MemFree(pRgn);	 // this clip region was malloc'd
	    }
	    LEAVE_BOTH_NOBUSY();
	    return DDERR_NOBLTHW;
	}

	/*
	 * Can the hardware driver perform the blit?
	 */
	if (!sbi.helonly)
	{
	    /*
	     * Yes, we're going to do a hardware-accelerated blit.
	     */
	    DPF(4, "Hardware AlphaBlt");
            /*
             * The DDI was selected above
             */
	    //bd.AlphaBlt = NULL;  // 32-bit call, no thunk

	    /*
	     * Tell the hardware driver to perform the blit.  We may have to wait
	     * if the driver is still busy with a previous drawing operation.
	     */
	    do
	    {
		DOHALCALL_NOWIN16(AlphaBlt, bltfn, bd, rc, sbi.helonly);
                if (rc != DDHAL_DRIVER_HANDLED || bd.ddRVal != DDERR_WASSTILLDRAWING)
		{
		    break;    // driver's finished for better or worse...
		}
		DPF(4, "Waiting...");

	    } while (dwFlags & DDABLT_WAIT);

	    /*
	     * Was the hardware driver able to handle the blit?
	     */
	    if (rc == DDHAL_DRIVER_HANDLED)
	    {
#ifdef WINNT
                if (bd.ddRVal == DDERR_VISRGNCHANGED)
                {
                    if (pRgn != (LPRGNDATA)&myRgnBuffer)
                    {
                        MemFree(pRgn);
                    }
                    DPF(5,"Resetting VisRgn for surface %x", surf_dest_lcl);
                    DdResetVisrgn(surf_dest_lcl, (HWND)0);
                    goto get_clipping_info;
                }
#endif
		if (bd.ddRVal != DDERR_WASSTILLDRAWING)
		{
		    /*
		     * Yes, the blit was handled by the hardware driver.
		     * If source or dest surface is in system memory, tag it so
		     * we know it's involved in an ongoing hardware operation.
		     */
		    if (bd.ddRVal == DD_OK && caps.bHALSeesSysmem)
		    {
			DPF(5,B,"Tagging surface %08x", surf_dest);
			if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
			    surf_dest->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPDEST;
			if (surf_src)
			{
			    DPF(5,B,"Tagging surface %08x", surf_src);
			    if (surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
				surf_src->dwGlobalFlags |= DDRAWISURFGBL_HARDWAREOPSOURCE;
			}
		    }
		}
	    }
	    else
	    {
		DDASSERT(rc == DDHAL_DRIVER_NOTHANDLED);
		/*
		 * No, the hardware driver says it could not handle the blit.
		 * If sbi.halonly = FALSE, we'll let the HEL do the blit.
		 */
		sbi.helonly = TRUE;   // force fail-over to HEL
	    }
	}

	/*
	 * Do we need to ask the HEL to perform the blit?
	 */
	if (sbi.helonly && !sbi.halonly)
	{
	    /*
	     * Yes, we'll ask the HEL to do a software-emulated blit.
	     */
	    bltfn = pdrv_lcl->lpDDCB->HELDDMiscellaneous2.AlphaBlt;
	    /*
	     * Is dest surface in system memory or video memory?
	     */
	    if (surf_dest_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	    {
		/*
		 * Destination surface is in system memory.
		 * If this surface was involved in a hardware op, we need to
		 * probe the driver to see if it's done.  NOTE: This assumes
		 * that only one driver can be responsible for a system-memory
		 * operation. See comment with WaitForHardwareOp.
		 */
		if (surf_dest->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED)
		{
		    WaitForHardwareOp(pdrv_lcl, surf_dest_lcl);
		}
		dest_lock_taken = FALSE;
	    }
	    else
	    {
		/*
		 * Wait loop:  Take write lock on dest surface in video memory.
		 */
		while(1)
		{
		    ddrval = InternalLock(surf_dest_lcl, &dest_bits, NULL, 0);
		    if (ddrval == DD_OK)
		    {
			GET_LPDDRAWSURFACE_GBL_MORE(surf_dest)->fpNTAlias = (FLATPTR)dest_bits;
			break;   // successfully locked dest surface
		    }
		    if (ddrval != DDERR_WASSTILLDRAWING)
		    {
			/*
			 * Can't lock dest surface.  Fail the call.
			 */
			if (pRgn != (LPRGNDATA)&myRgnBuffer)
			{
			    MemFree(pRgn);   // this clip region was malloc'd
			}
			DONE_EXCLUDE();
			DONE_BUSY();
			LEAVE_BOTH();
			return ddrval;
		    }
		}
		dest_lock_taken = TRUE;
	    }

	    if (surf_src && surf_src != surf_dest)
	    {
		/*
		 * Is source surface in system memory or video memory?
		 */
		if (surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
		{
		    /*
		     * Source surface is in system memory.
		     * If this surface was involved in a hardware op, we need to
		     * probe the driver to see if it's done.  NOTE: This assumes
		     * that only one driver can be responsible for a system-memory
		     * operation. See comment with WaitForHardwareOp.
		     */
		    if (surf_src &&
			surf_src_lcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY &&
			surf_src->dwGlobalFlags & DDRAWISURFGBL_HARDWAREOPSTARTED)
		    {
			WaitForHardwareOp(pdrv_lcl, surf_src_lcl);
		    }
		    src_lock_taken = FALSE;
		}
		else
		{
		    /*
		     * Wait loop:  Take lock on source surface in video memory.
		     */
		    while(1)
		    {
			ddrval = InternalLock(surf_src_lcl, &src_bits, NULL, DDLOCK_READONLY);
			if (ddrval == DD_OK)
			{
			    GET_LPDDRAWSURFACE_GBL_MORE(surf_src)->fpNTAlias = (FLATPTR)src_bits;
			    break;   // successfully locked source surface
			}
			if (ddrval != DDERR_WASSTILLDRAWING)
			{
			    /*
			     * We can't lock the source surface.  Fail the call.
			     */
			    if (dest_lock_taken)
			    {
				InternalUnlock(surf_dest_lcl, NULL, NULL, 0);
			    }
			    if (pRgn != (LPRGNDATA)&myRgnBuffer)
			    {
				MemFree(pRgn);	 // this clip region was malloc'd
			    }
			    DONE_EXCLUDE();
			    DONE_BUSY();
			    LEAVE_BOTH();
			    return ddrval;
			}
		    }
		    src_lock_taken = TRUE;
		}
	    }

	    /*
	     * Tell the HEL to perform the blit.
	     */
#ifdef WINNT
    try_again:
#endif
            DOHALCALL_NOWIN16(AlphaBlt, bltfn, bd, rc, sbi.helonly);
#ifdef WINNT
	    if (rc == DDHAL_DRIVER_HANDLED && bd.ddRVal == DDERR_VISRGNCHANGED)
            {
                DPF(5,"Resetting VisRgn for surface %x", surf_dest_lcl);
                DdResetVisrgn(surf_dest_lcl, (HWND)0);
                goto try_again;
            }
#endif
	}

	/*
	 * If clip region was malloc'd, free it now.
	 */
	if (pRgn != (LPRGNDATA)&myRgnBuffer)
	{
	    MemFree(pRgn);
	}

        if(IsD3DManaged(surf_dest_lcl))
            MarkDirty(surf_dest_lcl);

	DONE_LOCKS();

	/*
	 * Exclusion needs to happen after unlock call
	 */
	DONE_EXCLUDE();
	DONE_BUSY();
	LEAVE_BOTH();
	return bd.ddRVal;
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
	DPF_ERR("Exception encountered doing alpha blt");
	DONE_LOCKS();
	DONE_EXCLUDE();
	DONE_BUSY();
	LEAVE_BOTH();
	return DDERR_EXCEPTION;
    }

} /* DD_Surface_AlphaBlt */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\cliprgn.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       cliprgn.c
 *  Content:	Clip a region to a rectangle
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   23-jun-95	craige	initial implementation
 *   05-jul-95	kylej	change ClipRgnToRect to assume that the clipping
 *			rect is in screen space coordinates instead of 
 *                      window coordinates.
 *   05-feb-97	ketand	Remove the previous optimization that assumed that
 *			GetVisRgn was smaller than or equal to the ClientRect
 *			Replace with a different faster optimization.
 *
 ***************************************************************************/
#include "ddrawpr.h"

/*
 * ClipRgnToRect
 */
void ClipRgnToRect( LPRECT prect, LPRGNDATA prd )
{
    RECT	rect;
    int 	i;
    int		n;
    LPRECTL	prectlD;
    LPRECTL	prectlS;


    if( prect == NULL || prd == NULL )
    {
	return;
    }

    // If the bounding rect of the region is exactly equal to
    // or inside of the Restricting rect then we know
    // we don't have to do any more work.
    //
    // In the common case, the rcBound will be the client
    // area of a window and so will the restricting rect.
    if( prect->top    <= prd->rdh.rcBound.top &&
	prect->bottom >= prd->rdh.rcBound.bottom &&
	prect->left   <= prd->rdh.rcBound.left &&
	prect->right  >= prd->rdh.rcBound.right)
    {
	return;
    }
    
    // If the bounding rect doesn't equal the prect then
    // we might have to do some clipping.
    rect = *prect;

    prectlD = (LPRECTL) prd->Buffer;
    prectlS = (LPRECTL) prd->Buffer;
    n = (int)prd->rdh.nCount;

    for( i=0; i<n; i++ )
    {
	prectlD->left  = max(prectlS->left, rect.left);
	prectlD->right = min(prectlS->right, rect.right);
	prectlD->top   = max(prectlS->top, rect.top);
	prectlD->bottom= min(prectlS->bottom, rect.bottom);

	prectlS++;

	if( (prectlD->bottom - prectlD->top <= 0) ||
	    (prectlD->right - prectlD->left <= 0) )
	{
	    prd->rdh.nCount--;	// dont count empty rect.
	}
	else
	{
	    prectlD++;
	}
    }

    return;

} /* ClipRgnToRect */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddagp.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "ddrawpr.h"

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

#define PAGE_COUNT(Bytes) (((Bytes) + (PAGE_SIZE - 1)) / PAGE_SIZE)
#define PAGE_ROUND(Bytes) (((Bytes) + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1))

//
// AGP memory policy parameters.
//

// Maximum amount of AGP memory to use.  Currently 32MB.
// Recomputed when the DirectDraw interface is created.
DWORD dwAGPPolicyMaxBytes = 32 * 1024 * 1024;

// Amount of memory to commit when a commit is needed.
// Reset when the DirectDraw interface is created.
DWORD dwAGPPolicyCommitDelta = DEFAULT_AGP_COMMIT_DELTA;

#if DBG
// Internal tracking of current AGP memory size.
DWORD dwAGPPolicyCurrentBytes = 0;
#endif

DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  PVOID *ppvReservation )
{
    DWORD dwNumPages;
    
    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != pfpLinStart );
    DDASSERT( NULL                 != pliDevStart );
    DDASSERT( NULL                 != ppvReservation );

    /*
     * The first thing to do is make sure our AGP policy is respected.
     * The easy way to do that is to limit how much we reserve...
     */
    dwSize = min(dwSize, dwAGPPolicyMaxBytes);

    /*
     * DDraw will attempt to reserve space for the heap, but if that fails,
     * we'll ratchet down the reservation by 4 megs at a time until it works.
     * This is a defensive move that should prevent a few problems for AGP
     * aware drivers on memphis: they cannot know how large an aperture to
     * claim (cuz of weird OS restraints like the fact that
     * half the ap is reserved for UC and the other half WC etc, plus
     * random BIOS limitations.
     * We arbitrarily decide that 4 megs is the legal minimum.
     */
    while (dwSize >= 0x400000 )
    {
        dwNumPages = PAGE_COUNT(dwSize);
        if ( OsAGPReserve( hdev, dwNumPages, fIsUC, fIsWC,
                           pfpLinStart, pliDevStart, ppvReservation ) )
        {
            return dwSize;
        }

        /*
         * If the driver asked for WC but the processor doesn't support WC,
         * then OsAGPReserve will have failed. The best thing to do is try
         * again with UC...
         * If the aperture size is the problem, then this will still fail
         * and we'll back off and try again WC.
         */
        if (fIsWC)
        {
            if ( OsAGPReserve( hdev, dwNumPages, TRUE, FALSE,
                               pfpLinStart, pliDevStart, ppvReservation ) )
            {
                return dwSize;
            }
        }

        /*
         * Subtract 4 megs and try again
         */
        dwSize -= 0x400000;
    }

    return 0;
} /* AGPReserve */

BOOL AGPCommit( HANDLE hdev, PVOID pvReservation,
                DWORD dwOffset, DWORD dwSize )
{
    DWORD         dwFirstPage;
    DWORD         dwLastPage;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( NULL                 != pvReservation );
    DDASSERT( 0UL                  != dwSize );

#if DBG
    if( (dwAGPPolicyCurrentBytes + dwSize ) > dwAGPPolicyMaxBytes )
    {
        VDPF(( 0, V, "Maximum number of AGP bytes exceeded. Failing commit" ));
        return FALSE;
    }
#endif

    /*
     * If the start lies in the middle of a page then we assume that the
     * page it lies in has already been committed.
     */
    dwFirstPage = PAGE_COUNT(dwOffset);
    
    /*
     * We assume that if the end lies in the middle of the page then that
     * page has not already been committed.
     */
    dwLastPage = PAGE_COUNT(dwOffset + dwSize);
    
    if( ( dwLastPage == dwFirstPage) ||
        OsAGPCommit( hdev, pvReservation,
                     dwFirstPage, dwLastPage - dwFirstPage ) )
    {
#if DBG
        dwAGPPolicyCurrentBytes += dwSize;
#endif
	return TRUE;
    }
    else
    {
	return FALSE;
    }
} /* AGPCommit */

BOOL AGPDecommitAll( HANDLE hdev, PVOID pvReservation, DWORD dwSize )
{
    DWORD dwNumPages;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );
    DDASSERT( 0UL                  != dwSize );

#if DBG
    /*
     * Can't do much if this baby fails so just decrement the page
     * count.
     */
    DDASSERT( dwAGPPolicyCurrentBytes >= dwSize );
    dwAGPPolicyCurrentBytes -= dwSize;
#endif

    return OsAGPDecommitAll( hdev, pvReservation, PAGE_COUNT(dwSize) );
} /* AGPDecommitAll */

BOOL AGPFree( HANDLE hdev, PVOID pvReservation )
{
    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );

    return OsAGPFree( hdev, pvReservation );
} /* AGPFree */

#ifndef __NTDDKCOMP__

#define OSR2_POINT_0_BUILD_NUMBER           1111
#define OSR2_BUILD_NUMBER_A                 1212
#define OSR2_BUILD_NUMBER_B                 1214

/*
 * Does this operating system understand AGP?
 *
 * NOTE: There may be a better way of determining this but for now I will
 * assumed that Memphis and NT 5.0 class operating systems are AGP aware.
 *
 * NOTE: The VXD handle is (obviously) only important on Win95. On NT
 * NULL should be passed.
 */
BOOL OSIsAGPAware( HANDLE hvxd )
{
    OSVERSIONINFO osvi;
    BOOL          success;
    BOOL          fIsVMMAGPAware;

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    success = GetVersionEx(&osvi);
    DDASSERT( success );

    if( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {
	DPF( 5, "Major version = %d", osvi.dwMajorVersion );
	DPF( 5, "Minor version = %d", osvi.dwMinorVersion );
	DPF( 5, "Build number  = %d", LOWORD(osvi.dwBuildNumber) );

	if( ( osvi.dwMajorVersion > 4UL ) ||
	    ( ( osvi.dwMajorVersion == 4UL ) &&
	      ( osvi.dwMinorVersion >= 10UL ) &&
	      ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
	{
	    /*
	     * Memphis or greater version of Win95. AGP support assumed.
	     */
	    DPF( 2, "AGP aware Windows95 detected. Enabling AGP" );
	    return TRUE;
	}
	else if( ( osvi.dwMajorVersion == 4UL ) &&
	         ( osvi.dwMinorVersion == 0UL ) &&
		 ( ( LOWORD( osvi.dwBuildNumber ) == OSR2_BUILD_NUMBER_A ) ||
  		   ( LOWORD( osvi.dwBuildNumber ) == OSR2_BUILD_NUMBER_B ) ||
  		   ( LOWORD( osvi.dwBuildNumber ) == OSR2_POINT_0_BUILD_NUMBER ) ) )
	{
	    DPF( 3, "Win95 OSR 2.1 detected. Checking VMM for AGP services" );

	    fIsVMMAGPAware = FALSE;
	    #ifdef    WIN95
		DDASSERT( INVALID_HANDLE_VALUE != hvxd );
		fIsVMMAGPAware = vxdIsVMMAGPAware( hvxd );
	    #else  /* WIN95 */
		/*
		 * Should never occur as this would mean we are running an NT
		 * binary on a 95 system.
		 */
		DDASSERT(FALSE);
	    #endif /* WIN95 */

	    if( fIsVMMAGPAware )
	    {
		/*
		 * AGP services are present in the VMM. Enable AGP.
		 */
		DPF( 2, "OSR 2.1 VMM has AGP services. Enabled AGP" );
		return TRUE;
	    }
	    else
	    {
		/*
		 * No AGP services. Disable AGP.
		 */
		DPF( 2, "OSR 2.1 VMM has no AGP services. AGP not available" );
		return FALSE;
	    }
	}
	else
	{
	    DPF( 2, "Win95 Gold, OSR 1.0 or OSR 2.0 detected. No AGP support available" );
	    return FALSE;
	}

    }
    else if( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        /*
         * AGP support assumed in NT 5.0 and above.
         */
        if( osvi.dwMajorVersion >= 5UL )
        {
            DPF( 2, "AGP aware WindowsNT detected. Enabling AGP" );
            return TRUE;
        }
    }

    /*
     * If we got to here we failed the AGP aware test.
     */
    DPF( 1, "Operating system is not AGP aware. Disabling AGP" );
    return FALSE;
} /* OSIsAGPAware */

#endif // __NTDDKCOMP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddagp9x.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp9x.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw on Win9x
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "ddrawpr.h"

#ifdef WIN95

/*
 * We define the page lock IOCTLs here so that we don't have to include ddvxd.h.
 * These must match the corresponding entries in ddvxd.h
 */
#define DDVXD_IOCTL_GARTRESERVE             57
#define DDVXD_IOCTL_GARTCOMMIT              58
#define DDVXD_IOCTL_GARTUNCOMMIT            59
#define DDVXD_IOCTL_GARTFREE                60
#define DDVXD_IOCTL_GARTMEMATTRIBUTES       61
#define DDVXD_IOCTL_ISVMMAGPAWARE           68

#define PAGE_SIZE 4096
#define PAGE_COUNT(Bytes) (((Bytes) + (PAGE_SIZE - 1)) / PAGE_SIZE)
#define PAGE_ROUND(Bytes) (((Bytes) + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1))

#undef DPF_MODNAME
#define DPF_MODNAME	"OsAGPReserve"

/*
 * OsAGPReserve
 *
 * Reserve a portion of the address space for use as an AGP aperature.
 */
BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                    FLATPTR *lpfpGARTLin, LARGE_INTEGER *pliGARTDev,
                   PVOID *ppvReservation )
{
    DWORD  cbReturned;
    BOOL   rc;
    struct GRInput
    {
	DWORD  dwNumPages; /* Number of bytes of address space to reserve */
	DWORD  dwAlign;    /* Alignment of start of address space         */
	DWORD  fIsUC;      /* Address range should be uncachable          */
	DWORD  fIsWC;      /* Address range should be write combining     */
    } grInput;
    struct GROutput
    {
	FLATPTR fpGARTLin; /* Linear address of reserved space            */
	FLATPTR fpGARTDev; /* High physical address of reserved space     */
    } grOutput;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != dwNumPages );
    DDASSERT( NULL                 != lpfpGARTLin );
    DDASSERT( NULL                 != pliGARTDev );

    *lpfpGARTLin = 0UL;
    pliGARTDev->QuadPart = 0UL;

    grInput.dwNumPages = dwNumPages;
    grInput.dwAlign    = 0;      /* Hard code alignment of 4K for now       */
    grInput.fIsUC      = fIsUC;
    grInput.fIsWC      = fIsWC;

    DPF( 5, "OsGARTReserve" );
    DPF( 5, "Number of pages to reserve = 0x%08x", grInput.dwNumPages );
    DPF( 5, "Uncachable                 = 0x%08x", fIsUC );
    DPF( 5, "Write combining            = 0x%08x", fIsWC );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTRESERVE,
			  &grInput,
			  sizeof( grInput ),
			  &grOutput,
			  sizeof( grOutput ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(grOutput) );

	if( 0UL == grOutput.fpGARTLin )
	{
	    DPF(2, "Linear address of GART range is NULL. Call failed, reducing size by 4 Meg" );
	    rc = FALSE;
	}
	else
	{
	    *lpfpGARTLin = grOutput.fpGARTLin;
	    *ppvReservation = (LPVOID)grOutput.fpGARTLin;
	    pliGARTDev->QuadPart = grOutput.fpGARTDev;
            DPF( 5,"returned GARTLin: %08x",*lpfpGARTLin);
            DPF( 5,"returned GARTDev: %08x",pliGARTDev->QuadPart);
	}
    }
    else
    {
	DPF( 0, "Could not reserve 0x%08x pages of GART space", grInput.dwNumPages );
    }

    return rc;
} /* OsAGPReserve */

#undef DPF_MODNAME
#define DPF_MODNAME	"OsAGPCommit"

/*
 * OsAGPCommit
 *
 * Commit memory to the given portion of a previously reserved GART
 * range
 */
BOOL OsAGPCommit( HANDLE hdev, PVOID pvReservation,
                  DWORD dwPageOffset, DWORD dwNumPages )
{
    DWORD  cbReturned;
    BOOL   rc;
    struct GCInput
    {
	FLATPTR fpGARTLin;    /* Start of GART range reserved previously                      */
	DWORD   dwPageOffset; /* Offset from start of GART range of first page to be commited */
	DWORD   dwNumPages;   /* Number of pages to be commited                               */
	DWORD   dwFlags;      /* Flags (zero init)                                            */
    } gcInput;
    struct GCOutput
    {
	BOOL    fSuccess;  /* Result of GARTCommit                                     */
	FLATPTR fpGARTDev; /* Device address of memory commited                        */
    } gcOutput;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );

    gcInput.fpGARTLin    = (FLATPTR) pvReservation;
    gcInput.dwFlags      = 0;

    /*
     * If the start lies in the middle of a page then we assume that the
     * page it lies in has already been commited.
     */
    gcInput.dwPageOffset = dwPageOffset;

    /*
     * We assume that if the end lies in the middle of the page then that
     * page has not already been commited.
     */
    gcInput.dwNumPages = dwNumPages;
    if( 0UL == gcInput.dwNumPages )
    {
	DPF( 0, "All necessary GART pages already commited. Done." );
	return TRUE;
    }

    DPF( 5, "OsGARTCommit" );
    DPF( 5, "GART linear start address                   = 0x%08x", pvReservation );
    DPF( 5, "Offset from start of reserved address space = 0x%08x", gcInput.dwPageOffset );
    DPF( 5, "Number of pages to commit                   = 0x%08x", gcInput.dwNumPages );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTCOMMIT,
			  &gcInput,
			  sizeof( gcInput ),
			  &gcOutput,
			  sizeof( gcOutput ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(gcOutput) );

	if( !gcOutput.fSuccess )
	{
	    DPF_ERR( "Attempt to commit GART memory failed. Insufficient memory" );
	    rc = FALSE;
	}
	else
	{
	    DDASSERT( 0UL != gcOutput.fpGARTDev );
	}
    }
    else
    {
	DPF( 0, "Could not commit 0x%08x pages of GART space", gcInput.dwNumPages );
    }

    return rc;
} /* OsAGPCommit */

#undef DPF_MODNAME
#define DPF_MODNAME	"OsAGPDecommitAll"

/*
 * OsAGPDecommitAll
 *
 * Decommit a range of GART space previously commited with GARTCommit
 */
BOOL OsAGPDecommitAll( HANDLE hdev, PVOID pvReservation, DWORD dwNumPages )
{
    DWORD  dwDummy;
    DWORD  cbReturned;
    BOOL   rc;
    struct GUInput
    {
	FLATPTR fpGARTLin;    /* Start of GART range reserved previously                    */
	DWORD   dwPageOffset; /* Offset from start of GART range of first page to decommit  */
	DWORD   dwNumPages;   /* Number of pages to decommit                                */
    } guInput;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );
    DDASSERT( 0UL                  != dwNumPages );

    guInput.fpGARTLin    = (FLATPTR) pvReservation;
    guInput.dwPageOffset = 0;
    guInput.dwNumPages   = dwNumPages;

    DPF( 5, "OsGARTUnCommit" );
    DPF( 5, "GART linear start address                   = 0x%08x", pvReservation );
    DPF( 5, "Offset from start of reserved address space = 0x%08x", guInput.dwPageOffset );
    DPF( 5, "Number of pages to decommit                 = 0x%08x", guInput.dwNumPages );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTUNCOMMIT,
			  &guInput,
			  sizeof( guInput ),
			  &dwDummy,
			  sizeof( dwDummy ),
			  &cbReturned,
			  NULL );

    #ifdef DEBUG
	if( rc )
	{
	    DDASSERT( cbReturned == sizeof(dwDummy) );
	}
	else
	{
	    DPF( 0, "Could not decommit 0x%08x pages of GART space", guInput.dwNumPages );
	}
    #endif /* DEBUG */

    return rc;
} /* OsAGPDecommitAll */

#undef DPF_MODNAME
#define DPF_MODNAME	"OsGARTFree"

/*
 * OsAGPFree
 *
 * Free a GART range previously reserved with GARTReserve
 */
BOOL OsAGPFree( HANDLE hdev, PVOID pvReservation )
{
    DWORD  dwDummy;
    DWORD  cbReturned;
    BOOL   rc;
    LPVOID fpGARTLin = pvReservation;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != fpGARTLin );

    DPF( 5, "OsGARTFree" );
    DPF( 5, "GART linear start address = 0x%08x", fpGARTLin );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTFREE,
			  &fpGARTLin,
			  sizeof( fpGARTLin ),
			  &dwDummy,
			  sizeof( dwDummy ),
			  &cbReturned,
			  NULL );

    #ifdef DEBUG
	if( rc )
	{
	    DDASSERT( cbReturned == sizeof(dwDummy) );
	}
	else
	{
	    DPF( 0, "Could not free GART space at 0x%08x", fpGARTLin );
	}
    #endif /* DEBUG */

    return rc;
} /* OsAGPFree */

// Not currently used.
#if 0

#undef DPF_MODNAME
#define DPF_MODNAME	"OsGARTMemAttributes"

/*
 * OsGARTMemAttributes
 *
 * Get the memory attributes of a GART memory range previously allocated
 * with GARTReserve
 */
BOOL OsGARTMemAttributes( HANDLE hdev, FLATPTR fpGARTLin, LPDWORD lpdwAttribs )
{
    DWORD  cbReturned;
    BOOL   rc;
    DWORD  dwAttribs;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != fpGARTLin );
    DDASSERT( NULL                 != lpdwAttribs );

    *lpdwAttribs = 0UL;

    DPF( 5, "OsGARTMemAttributes" );
    DPF( 5, "GART linear start address = 0x%08x", fpGARTLin );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_GARTMEMATTRIBUTES,
			  &fpGARTLin,
			  sizeof( fpGARTLin ),
			  &dwAttribs,
			  sizeof( dwAttribs ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(dwAttribs) );

	*lpdwAttribs = dwAttribs;
    }
    else
    {
	DPF( 0, "Could not get the memory attributes of GART space at 0x%08x", fpGARTLin );
    }

    return rc;
} /* OsGARTMemAttributes */

#endif // Unused code.

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdVMMIsAGPAware"

/*
 * vxdIsVMMAGPAware
 *
 * Does the VMM we are running on export the AGP services?
 */
BOOL vxdIsVMMAGPAware( HANDLE hdev )
{
    DWORD  cbReturned;
    BOOL   rc;
    BOOL   fIsAGPAware;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );

    DPF( 4, "vxdIsVMMAGPAware" );

    rc = DeviceIoControl( hdev,
                          DDVXD_IOCTL_ISVMMAGPAWARE,
			  NULL,
			  0UL,
			  &fIsAGPAware,
			  sizeof( fIsAGPAware ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(fIsAGPAware) );
	return fIsAGPAware;
    }
    else
    {
	DPF_ERR( "Could not determine if OS is AGP aware. Assuming it's not" );
	return FALSE;
    }
} /* vxdIsVMMAGPAware */

#endif // WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddagpnt.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagpnt.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw on NT
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "ddrawpr.h"

#ifndef WIN95

// Currently the hdev passed in is the DirectDraw global, so
// look up the AGP interface in it.
#define GET_AGPI(hdev) (&((EDD_DIRECTDRAW_GLOBAL *)hdev)->AgpInterface)

#define CHECK_GET_AGPI(hdev, pvai) \
    (pvai) = GET_AGPI(hdev); \
    ASSERTGDI((pvai)->Context != NULL, "No AGP context");

// Offset to use for biasing AGP heaps.
#define DDNLV_HEAP_BIAS PAGE_SIZE

/*
 * OsAGPReserve
 *
 * Reserve resources for use as an AGP aperture.
 */
BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   PVOID *ppvReservation )
{
    AGP_INTERFACE *pai;
    BOOLEAN Cached;

    CHECK_GET_AGPI(hdev, pai);

    if (fIsUC)
    {
        Cached = FALSE;
    }
    else
    {
        Cached = TRUE;
    }

    // On NT heaps are kept with offsets rather than pointers so
    // always return a base offset as the starting address.  The
    // base offset is non-zero so that successful heap allocations
    // always have a non-zero value.
    *pfpLinStart = DDNLV_HEAP_BIAS;
    
    *pliDevStart = pai->AgpServices.
        AgpReservePhysical(pai->Context, dwNumPages,
                           Cached, ppvReservation);
    return *ppvReservation != NULL;
} /* OsAGPReserve */

/*
 * OsAGPCommit
 *
 * Commit memory to the given portion of a previously reserved range.
 */
BOOL OsAGPCommit( HANDLE hdev, PVOID pvReservation, DWORD dwPageOffset,
                  DWORD dwNumPages )
{
    AGP_INTERFACE *pai;

    CHECK_GET_AGPI(hdev, pai);

    return pai->AgpServices.AgpCommitPhysical(pai->Context,
                                              pvReservation,
                                              dwNumPages, dwPageOffset);
} /* OsAGPCommit */

/*
 * OsAGPDecommitAll
 *
 * Decommit everything in a reserved area.
 */
BOOL OsAGPDecommitAll( HANDLE hdev, PVOID pvReservation, DWORD dwNumPages )
{
    AGP_INTERFACE *pai;

    CHECK_GET_AGPI(hdev, pai);

    // Decommit memory.
    pai->AgpServices.AgpFreePhysical(pai->Context, pvReservation,
                                     dwNumPages, 0);
    return TRUE;
} /* OsAGPDecommitAll */

/*
 * OsAGPFree
 *
 * Free a previously reserved range.
 */
BOOL OsAGPFree( HANDLE hdev, PVOID pvReservation )
{
    AGP_INTERFACE *pai;
    
    CHECK_GET_AGPI(hdev, pai);

    pai->AgpServices.AgpReleasePhysical(pai->Context,
                                        pvReservation);
    return TRUE;
} /* OsAGPFree */

#endif // !WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddalias.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddalias.c
 *  Content:	DirectDraw support for allocating and mapping linear virtual
 *              memory aliased for video memory.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   05-jul-96	colinmc	initial implementation
 *   10-oct-96  colinmc Refinements of the Win16 locking stuff
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   25-jan-97  colinmc AGP work
 *   01-jun-97  colinmc Bug xxxx: Defensive video memory checking to catch
 *                      based video memory pointers passed by drivers
 *
 ***************************************************************************/

#include "ddrawpr.h"

#ifdef USE_ALIAS

#ifdef WINNT
    #include "ddrawgdi.h"
#endif

#pragma optimize("gle", off)
#define Not_VxD
#include <vmm.h>
#include <configmg.h>
#pragma optimize("", on)

/*
 * We define the page lock IOCTLs here so that we don't have to include ddvxd.h.
 * These must match the corresponding entries in ddvxd.h
 */
#define DDVXD_IOCTL_MEMRESERVEALIAS         23
#define DDVXD_IOCTL_MEMCOMMITALIAS          24
#define DDVXD_IOCTL_MEMREDIRECTALIAS        25
#define DDVXD_IOCTL_MEMDECOMMITALIAS        26
#define DDVXD_IOCTL_MEMFREEALIAS            27
#define DDVXD_IOCTL_MEMCOMMITPHYSALIAS      55
#define DDVXD_IOCTL_MEMREDIRECTPHYSALIAS    56
#define DDVXD_IOCTL_LINTOPHYS               69
#define GET_PIXELFORMAT( pdrv, psurf_lcl )                     \
    ( ( ( psurf_lcl )->dwFlags & DDRAWISURF_HASPIXELFORMAT ) ? \
	&( ( psurf_lcl )->lpGbl->ddpfSurface )               : \
	&( ( pdrv )->vmiData.ddpfDisplay ) )

#define WIDTH_TO_BYTES( bpp, w ) ( ( ( ( w ) * ( bpp ) ) + 7 ) >> 3 )

BOOL UnmapHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo );

/*
 * Are the heaps mapped at all?
 */
#define HEAPALIASINFO_MAPPED ( HEAPALIASINFO_MAPPEDREAL | HEAPALIASINFO_MAPPEDDUMMY )

#define MAP_HEAP_ALIAS_TO_VID_MEM( hvxd, lpHeapAlias )      \
    vxdMapVMAliasToVidMem( (hvxd),                          \
	                   (lpHeapAlias)->lpAlias,          \
			   (lpHeapAlias)->dwAliasSize,      \
		           (LPVOID)(lpHeapAlias)->fpVidMem )

#define MAP_HEAP_ALIAS_TO_DUMMY_MEM( hvxd, lpHeapAlias )    \
    vxdMapVMAliasToDummyMem( (hvxd),                        \
	                     (lpHeapAlias)->lpAlias,        \
			     (lpHeapAlias)->dwAliasSize )

#define UNMAP_HEAP_ALIAS( hvxd, lpHeapAlias )               \
    vxdUnmapVMAlias( (hvxd),                                \
	             (lpHeapAlias)->lpAlias,                \
	             (lpHeapAlias)->dwAliasSize )

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdAllocVMAlias"

/*
 * vxdAllocVMAlias
 *
 * Allocate a virtual memory alias for a portion of video memory
 * starting with the given start address and size.
 */
static BOOL vxdAllocVMAlias( HANDLE hvxd, LPVOID lpVidMem, DWORD dwSize, LPVOID *lplpAlias )
{
    LPVOID lpAlias;
    DWORD  cbReturned;
    BOOL   rc;
    struct RAInput
    {
	LPBYTE lpVidMem;
	DWORD  dwSize;
    } raInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpVidMem );
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != lplpAlias );

    raInput.lpVidMem = (LPBYTE) lpVidMem;
    raInput.dwSize   = dwSize;

    DPF( 5, "Trying to allocate alias starting at 0x%08x of size 0x%04x", lpVidMem, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMRESERVEALIAS,
			  &raInput,
			  sizeof( raInput ),
			  &lpAlias,
			  sizeof( lpAlias ),
			  &cbReturned,
			  NULL);

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(lpAlias) );

	*lplpAlias = lpAlias;
    }
    else
    {
	DPF( 0, "Could not allocate an alias for video memory starting at 0x%08x", lpVidMem );

	*lplpAlias = NULL;
    }

    return rc;
} /* vxdAllocVMAlias */

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdFreeVMAlias"

/*
 * vxdFreeVMAlias
 *
 * Free the virtual memory alias with the given start address and size.
 */
static BOOL vxdFreeVMAlias( HANDLE hvxd, LPVOID lpAlias, DWORD dwSize )
{
    BOOL  rc;
    BOOL  fSuccess;
    DWORD cbReturned;
    struct FAInput
    {
	LPBYTE pAlias;
	DWORD  cbBuffer;
    } faInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpAlias);
    DDASSERT( 0UL                  != dwSize );

    faInput.pAlias   = (LPBYTE) lpAlias;
    faInput.cbBuffer = dwSize;

    DPF( 5, "Trying to free an alias starting at 0x%08x of size 0x%04x", lpAlias, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMFREEALIAS,
			  &faInput,
			  sizeof( faInput ),
			  &fSuccess,
			  sizeof( fSuccess ),
			  &cbReturned,
			  NULL);

    if( !rc || !fSuccess )
    {
	DPF( 0, "Could not free an alias starting at 0x%08x (rc = %d fSuccess = %d)", lpAlias, rc, fSuccess );
	return FALSE;
    }

    return TRUE;
} /* vxdFreeVMAlias */

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdMapVMAliasToVidMem"

/*
 * vxdMapVMAliasToVidMem
 *
 * Map the the virtual memory alias with the given start address and size
 * to the porition of video memory with the given start address.
 */
static BOOL vxdMapVMAliasToVidMem( HANDLE hvxd, LPVOID lpAlias, DWORD dwSize, LPVOID lpVidMem )
{
    BOOL  rc;
    BOOL  fSuccess;
    DWORD cbReturned;
    struct CAInput
    {
	LPBYTE pAlias;
	LPBYTE pVidMem;
	DWORD  cbBuffer;
    } caInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpAlias );
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != lpVidMem );

    caInput.pAlias   = (LPBYTE) lpAlias;
    caInput.pVidMem  = (LPBYTE) lpVidMem;
    caInput.cbBuffer = dwSize;

    DPF( 5, "Trying to map an alias starting at 0x%08x of size 0x%04x to video memory starting at 0x%08x", lpAlias, dwSize, lpVidMem );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMCOMMITPHYSALIAS,
                          &caInput,
                          sizeof( caInput ),
                          &fSuccess,
                          sizeof( fSuccess ),
                          &cbReturned,
                          NULL);

    if( !rc || !fSuccess )
    {
        DPF( 0, "Could not map an alias starting at 0x%08x (rc = %d fSuccess = %d)", lpAlias, rc, fSuccess );
	return FALSE;
    }

    return TRUE;
} /* vxdMapVMAliasToVidMem */

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdMapVMAliasToDummyMem"

/*
 * vxdMapVMAliasToDummyMem
 *
 * Map the the virtual memory alias with the given start address and size
 * to a read / write dummy page.
 */
static BOOL vxdMapVMAliasToDummyMem( HANDLE hvxd, LPVOID lpAlias, DWORD dwSize )
{
    BOOL  rc;
    BOOL  fSuccess;
    DWORD cbReturned;
    struct RAInput
    {
	LPBYTE pAlias;
	DWORD  cbBuffer;
    } raInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpAlias);
    DDASSERT( 0UL                  != dwSize );

    raInput.pAlias   = (LPBYTE) lpAlias;
    raInput.cbBuffer = dwSize;

    DPF( 5, "Trying to map an alias starting at 0x%08x of size 0x%04x to dummy memory" , lpAlias, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMREDIRECTPHYSALIAS,
			  &raInput,
	                  sizeof( raInput ),
	                  &fSuccess,
	                  sizeof( fSuccess ),
	                  &cbReturned,
	                  NULL);

    if( !rc || !fSuccess )
    {
	DPF( 0, "Could not map an alias starting at 0x%08x to dummy memory (rc = %d fSuccess = %d)", lpAlias, rc, fSuccess );
	return FALSE;
    }

    return TRUE;
} /* vxdMapVMAliasToDummyMem */

#undef DPF_MODNAME
#define DPF_MODNAME	"vxdUnmapVMAlias"

/*
 * vxdUnmapVMAlias
 *
 * Unmap the the virtual memory alias with the given start address and size.
 */
static BOOL vxdUnmapVMAlias( HANDLE hvxd, LPVOID lpAlias, DWORD dwSize )
{
    BOOL  rc;
    BOOL  fSuccess;
    DWORD cbReturned;
    struct DAInput
    {
	LPBYTE pAlias;
	DWORD  cbBuffer;
    } daInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpAlias);
    DDASSERT( 0UL                  != dwSize );

    daInput.pAlias   = (LPBYTE) lpAlias;
    daInput.cbBuffer = dwSize;

    DPF( 5, "Trying to unmap an alias starting at 0x%08x of size 0x%04x", lpAlias, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_MEMDECOMMITALIAS,
			  &daInput,
			  sizeof( daInput ),
			  &fSuccess,
			  sizeof( fSuccess ),
			  &cbReturned,
			  NULL );

    if( !rc || !fSuccess )
    {
	DPF( 0, "Could not unmap an alias starting at 0x%08x (rc = %d fSuccess = %d)", lpAlias, rc, fSuccess );
	return FALSE;
    }

    return TRUE;
} /* vxdUnmapVMAlias */

static BOOL vxdLinToPhys( HANDLE hvxd, LPVOID lpLin, DWORD dwSize, LPVOID* lplpPhys )
{
    BOOL  rc;
    LPBYTE lpPhys;
    DWORD cbReturned;
    struct DAInput
    {
	LPBYTE pLin;
	DWORD  cbBuffer;
    } daInput;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpLin);
// There really is a bug here: 27001. But since it's MOSTLY inoccuous, I'll turn the spew off.
//    DDASSERT( 0UL                  != dwSize );

    daInput.pLin   = (LPBYTE) lpLin;
    daInput.cbBuffer = dwSize;

    DPF( 5, "Trying to map an linear address at 0x%08x of size 0x%04x to physical address", lpLin, dwSize );

    rc = DeviceIoControl( hvxd,
                          DDVXD_IOCTL_LINTOPHYS,
			  &daInput,
			  sizeof( daInput ),
			  &lpPhys,
			  sizeof( lpPhys ),
			  &cbReturned,
			  NULL );

    if( rc )
    {
	DDASSERT( cbReturned == sizeof(lpPhys) );

	*lplpPhys = lpPhys;
    }
    else
    {
	DPF( 0, "Could not map linear address at 0x%08x to physical address", lpLin );

	*lplpPhys = NULL;
    }

    return rc;
} /* vxdUnmapVMAlias */

#undef DPF_MODNAME
#define DPF_MODNAME	"AllocHeapAlias"

/*
 * AllocHeapAlias
 *
 * Allocate a virtual memory alias for the given heap
 */
static BOOL AllocHeapAlias( HANDLE hvxd, FLATPTR fpStart, DWORD dwSize, LPHEAPALIAS lpHeapAlias )
{
    LPVOID lpAlias;
    BOOL   fSuccess;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( 0UL                  != fpStart ); /* This is a physical address pointer */
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != lpHeapAlias );

    /*
     * Attempt to allocate an alias for this heap.
     */
    fSuccess = vxdAllocVMAlias( hvxd, (LPVOID) fpStart, dwSize, &lpAlias );
    if( fSuccess )
    {
	lpHeapAlias->fpVidMem    = fpStart;
	lpHeapAlias->lpAlias     = lpAlias;
	lpHeapAlias->dwAliasSize = dwSize;
    }
    else
    {
	lpHeapAlias->fpVidMem    = 0UL;
	lpHeapAlias->lpAlias     = NULL;
	lpHeapAlias->dwAliasSize = 0UL;
    }

    return fSuccess;
} /* AllocHeapAlias */

#undef DPF_MODNAME
#define DPF_MODNAME	"FreeHeapAlias"

/*
 * FreeHeapAlias
 *
 * Free the given virtual memory heap alias
 */
static BOOL FreeHeapAlias( HANDLE hvxd, LPHEAPALIAS lpHeapAlias )
{
    BOOL fSuccess;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != lpHeapAlias );

    if( NULL != lpHeapAlias->lpAlias )
    {
	fSuccess = vxdFreeVMAlias( hvxd, lpHeapAlias->lpAlias, lpHeapAlias->dwAliasSize );
	lpHeapAlias->fpVidMem    = 0UL;
	lpHeapAlias->lpAlias     = NULL;
	lpHeapAlias->dwAliasSize = 0UL;
    }

    return fSuccess;
} /* FreeHeapAliases */

#undef DPF_MODNAME
#define DPF_MODNAME	"CreateHeapAliases"

/*
 * CreateHeapAliases
 *
 * Create a new set of virtual memory heap aliases for the given global
 * object
 */
HRESULT CreateHeapAliases( HANDLE hvxd, LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPHEAPALIASINFO         phaiInfo;
    DWORD                   dwNumHeaps;
    DWORD                   dwSize;
    DWORD                   dwHeapNo;
    int                     i;
    int                     n;
    HRESULT                 hres;
    CMCONFIG	            config;
    LPVIDMEM                pvm;

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );
    DDASSERT( NULL                 != pdrv );
    DDASSERT( NULL                 == pdrv->phaiHeapAliases );

    DDASSERT( !( pdrv->dwFlags & DDRAWI_NOHARDWARE ) );
    DDASSERT( !( pdrv->dwFlags & DDRAWI_MODEX ) );
    DDASSERT( 0UL != pdrv->vmiData.fpPrimary );

    if (DD16_GetDeviceConfig(pdrv->cDriverName, &config, sizeof(config)) == 0)
    {
        DPF_ERR("Could not get display devices's address space ranges");
        return DDERR_GENERIC;
    }
    // First we count the cards local vid mem windows in the config space
    dwNumHeaps = config.wNumMemWindows;
    DPF(5, "Config Space windows = %d", dwNumHeaps);
    // Then we cycle through the AGP heaps that we need to alias
    for( i = 0; i < (int)pdrv->vmiData.dwNumHeaps; i++ )
    {
	if( ( pdrv->vmiData.pvmList[i].dwFlags & VIDMEM_ISNONLOCAL ) )
	{
            // Found AGP heap
            ++dwNumHeaps;
        }
    }
    DPF(5, "dwNumHeaps = %d", dwNumHeaps);

    /*
     * Allocate the heap alias info.
     */
    phaiInfo = MemAlloc( sizeof( HEAPALIASINFO ) );
    if( NULL == phaiInfo )
    {
	DPF_ERR( "Insufficient memory to map the heap alias info" );
	return DDERR_OUTOFMEMORY;
    }

    /*
     * Heaps are not yet mapped.
     */
    phaiInfo->dwFlags &= ~HEAPALIASINFO_MAPPED;

    /*
     * Allocate the array of heap aliases.
     */
    phaiInfo->lpAliases = MemAlloc( dwNumHeaps * sizeof( HEAPALIAS ) );
    if( NULL == phaiInfo->lpAliases )
    {
        DPF_ERR( "Insufficient memory to allocate heap alias array" );
	MemFree( phaiInfo );
        return DDERR_OUTOFMEMORY;
    }
    phaiInfo->dwNumHeaps = dwNumHeaps;

    /*
     * Allocate the aliases for each vid mem config space window.
     */
    for( i = 0; i < (int) config.wNumMemWindows; i++ )
    {
        DPF(5, "Window %d: wMemAttrib = %d", i, config.wMemAttrib[i]);
        DPF(5, "Window %d: dMemBase = 0x%08x", i, config.dMemBase[i]);
        DPF(5, "Window %d: dMemLength = 0x%08x", i, config.dMemLength[i]);
	if ((config.wMemAttrib[i] & fMD_MemoryType) == fMD_ROM)
        {
            DPF(5, "fMD_MemoryType == fMD_ROM, skipping...");
	    continue;
        }
	if( !AllocHeapAlias( hvxd, config.dMemBase[i], config.dMemLength[i], &phaiInfo->lpAliases[i] ) )
	{
	    DPF_ERR( "Insufficient memory to allocate virtual memory alias" );
	    /*
	     * Discard any aliases already allocated.
	     */
	    for( n = 0; n < i; n++)
		FreeHeapAlias( hvxd, &phaiInfo->lpAliases[n] );
	    MemFree( phaiInfo->lpAliases );
	    MemFree( phaiInfo );
	    return DDERR_OUTOFMEMORY;
	}
    }

    /*
     * Allocate the aliases for each AGP heap.
     */
    dwHeapNo = config.wNumMemWindows;
    for( i = 0; i < (int)pdrv->vmiData.dwNumHeaps; i++ )
    {
        pvm = &(pdrv->vmiData.pvmList[i]);
	if( ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
        {
            DPF(5, "AGP Heap %d: fpGARTLin = 0x%08x", i, pvm->lpHeap->fpGARTLin);
            DPF(5, "AGP Heap %d: fpGARTDev = 0x%08x", i, pvm->lpHeap->fpGARTDev);
            DPF(5, "AGP Heap %d: dwTotalSize = 0x%08x", i, pvm->lpHeap->dwTotalSize);
	    if( !AllocHeapAlias( hvxd, pvm->lpHeap->fpGARTDev, pvm->lpHeap->dwTotalSize, &phaiInfo->lpAliases[dwHeapNo] ) )
	    {
	        DPF_ERR( "Insufficient memory to allocate virtual memory alias" );
	        /*
	         * Discard any aliases already allocated.
	         */
	        for( n = 0; n < (int)dwHeapNo; n++)
		    FreeHeapAlias( hvxd, &phaiInfo->lpAliases[n] );
	        MemFree( phaiInfo->lpAliases );
	        MemFree( phaiInfo );
	        return DDERR_OUTOFMEMORY;
	    }
            dwHeapNo++;
        }
    }

    /*
     * Now map all the aliases to video memory.
     */
    hres = MapHeapAliasesToVidMem( hvxd, phaiInfo );
    if( FAILED( hres ) )
    {
        for( i = 0; i < (int) dwNumHeaps; i++)
            FreeHeapAlias( hvxd, &phaiInfo->lpAliases[i] );
        MemFree( phaiInfo->lpAliases );
        MemFree( phaiInfo );
        return hres;
    }

    /*
     * The global object holds a single reference to the aliases
     */
    phaiInfo->dwRefCnt = 1UL;
    pdrv->phaiHeapAliases = phaiInfo;

    return DD_OK;
} /* CreateHeapAliases */

#undef DPF_MODNAME
#define DPF_MODNAME	"ReleaseHeapAliases"

/*
 * ReleaseHeapAliases
 *
 * Release the given heap aliases.
 */
BOOL ReleaseHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo )
{
    int i;

    DDASSERT( NULL != phaiInfo );
    DDASSERT( 0UL  != phaiInfo->dwRefCnt );

    phaiInfo->dwRefCnt--;
    if( 0UL == phaiInfo->dwRefCnt )
    {
	DDASSERT( INVALID_HANDLE_VALUE != hvxd );

	DPF( 4, "Heap aliases reference count is zero: discarding aliases" );

	/*
	 * If the heaps are currently mapped then unmap them before
	 * freeing them.
	 */
	DDASSERT( phaiInfo->dwFlags & HEAPALIASINFO_MAPPED );
	UnmapHeapAliases( hvxd, phaiInfo );

	/*
	 * Release all the virtual memory aliases.
	 */
	for( i = 0; i < (int) phaiInfo->dwNumHeaps; i++ )
	{
	    if( NULL != phaiInfo->lpAliases[i].lpAlias )
		FreeHeapAlias( hvxd, &phaiInfo->lpAliases[i] );
	}

	MemFree( phaiInfo->lpAliases );
	MemFree( phaiInfo );
    }

    return TRUE;
} /* ReleaseHeapAliases */

#undef DPF_MODNAME
#define DPF_MODNAME	"MapHeapAliasesToVidMem"

/*
 * MapHeapAliasesToVidMem
 *
 * Map all the heap aliases to video memory.
 */
HRESULT MapHeapAliasesToVidMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo )
{
    int i;

    DDASSERT( NULL != phaiInfo );

    if( phaiInfo->dwFlags & HEAPALIASINFO_MAPPEDREAL )
    {
        DPF( 4, "Heap aliases already mapped to real video memory" );
        return DD_OK;
    }

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );

    for( i = 0; i < (int) phaiInfo->dwNumHeaps; i++ )
    {
	/*
	 * NOTE: If any of the maps fail then we just discard the
	 * alias and continue. Memory allocated out of the failed
	 * heap will need the Win16 lock taken.
	 */
	if( NULL != phaiInfo->lpAliases[i].lpAlias )
	{
	    if( !MAP_HEAP_ALIAS_TO_VID_MEM( hvxd, &phaiInfo->lpAliases[i] ) )
	    {
		DPF( 0, "Heap %d failed to map. Discarding that alias", i );
		FreeHeapAlias( hvxd, &phaiInfo->lpAliases[i] );
	    }
	}
    }

    phaiInfo->dwFlags = ((phaiInfo->dwFlags & ~HEAPALIASINFO_MAPPEDDUMMY) | HEAPALIASINFO_MAPPEDREAL);

    return DD_OK;
} /* MapHeapAliasesToVidMem */

#undef DPF_MODNAME
#define DPF_MODNAME	"MapHeapAliasesToDummyMem"

/*
 * MapHeapAliasesToDummyMem
 *
 * Map all the heap aliases to the dummy read / write page.
 *
 * NOTE: The heap aliases must be mapped to real video memory before
 * calling this function.
 */
HRESULT MapHeapAliasesToDummyMem( HANDLE hvxd, LPHEAPALIASINFO phaiInfo )
{
    int     i;
    HRESULT hres;

    DDASSERT( NULL != phaiInfo );

    if( phaiInfo->dwFlags & HEAPALIASINFO_MAPPEDDUMMY )
    {
        DPF( 4, "Heap aliases already mapped to dummy memory" );
        return DD_OK;
    }

    DDASSERT( phaiInfo->dwFlags & HEAPALIASINFO_MAPPEDREAL );
    DDASSERT( INVALID_HANDLE_VALUE != hvxd );

    hres = DD_OK;
    for( i = 0; i < (int) phaiInfo->dwNumHeaps; i++ )
    {
	if( NULL != phaiInfo->lpAliases[i].lpAlias )
	{
	    if( !MAP_HEAP_ALIAS_TO_DUMMY_MEM( hvxd, &phaiInfo->lpAliases[i] ) )
	    {
		/*
		 * Keep going but flag the failure.
		 */
		DPF( 0, "Could not map the heap alias to dummy memory" );
		hres = DDERR_GENERIC;
	    }
	}
    }

    phaiInfo->dwFlags = ((phaiInfo->dwFlags & ~HEAPALIASINFO_MAPPEDREAL) | HEAPALIASINFO_MAPPEDDUMMY);

    return hres;
} /* MapHeapAliasesToDummyMem */

#undef DPF_MODNAME
#define DPF_MODNAME	"UnmapHeapAliases"

/*
 * UnmapHeapAliases
 *
 * Unmap all the heap aliases.
 */
BOOL UnmapHeapAliases( HANDLE hvxd, LPHEAPALIASINFO phaiInfo )
{
    int i;

    DDASSERT( NULL != phaiInfo );

    if( 0UL == ( phaiInfo->dwFlags & HEAPALIASINFO_MAPPED ) )
    {
        DPF( 4, "Heap aliases already unmapped" );
        return TRUE;
    }

    DDASSERT( INVALID_HANDLE_VALUE != hvxd );

    for( i = 0; i < (int) phaiInfo->dwNumHeaps; i++ )
    {
	if( NULL != phaiInfo->lpAliases[i].lpAlias )
	{
	    /*
	     * Nothing we can do if the unmap fails.
	     */
	    UNMAP_HEAP_ALIAS( hvxd, &phaiInfo->lpAliases[i] );
	}
    }

    phaiInfo->dwFlags &= ~HEAPALIASINFO_MAPPED;

    return TRUE;
} /* UnmapHeapAliases */

/*
 * GetAliasedVidMem
 *
 * Get an alias for the given surface with the given video
 * memory pointer.
 */
FLATPTR GetAliasedVidMem( LPDDRAWI_DIRECTDRAW_LCL   pdrv_lcl,
			  LPDDRAWI_DDRAWSURFACE_LCL surf_lcl,
			  FLATPTR                   fpVidMem )
{
    LPDDRAWI_DDRAWSURFACE_GBL surf;
    LPDDRAWI_DIRECTDRAW_GBL   pdrv;
    LPDDPIXELFORMAT           lpddpf;
    DWORD                     dwVidMemSize;
    int                       n;
    LPHEAPALIAS               phaAlias;
    DWORD                     dwHeapOffset;
    FLATPTR                   fpAliasedVidMem;
    FLATPTR                   fpPhysVidMem;
    BOOL fSuccess;

    DDASSERT( NULL != pdrv_lcl );
    DDASSERT( NULL != surf_lcl );
    DDASSERT( 0UL  != fpVidMem );

    surf = surf_lcl->lpGbl;
    pdrv = pdrv_lcl->lpGbl;

    /*
     * If there are not heap aliases we can't really return one.
     */
    if( NULL == pdrv->phaiHeapAliases )
    {
	DPF( 3, "Driver has no heap aliases. Returning a NULL alias pointer" );
	return (FLATPTR)NULL;
    }

    /*
     * Compute the (inclusive) last byte in the surface. We need this
     * to ensure that a surface pointers lies exactly in an aliased
     * heap.
     */
    if (surf_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
        dwVidMemSize = surf->dwLinearSize;
    else
    {
        GET_PIXEL_FORMAT( surf_lcl, surf, lpddpf );
        dwVidMemSize = ( ( ( surf->wHeight - 1 ) * labs( surf->lPitch ) ) +
		       WIDTH_TO_BYTES( lpddpf->dwRGBBitCount, surf->wWidth ) );
    }
    DPF(5, "dwVidMemSize = 0x%08x", dwVidMemSize);
    fpAliasedVidMem = 0UL;
    fSuccess = vxdLinToPhys((HANDLE) pdrv_lcl->hDDVxd, (LPVOID)fpVidMem, dwVidMemSize, (LPVOID*)&fpPhysVidMem);
    if (fSuccess && (fpPhysVidMem != 0))
    {
        phaAlias = &pdrv->phaiHeapAliases->lpAliases[0];
        n = (int) pdrv->phaiHeapAliases->dwNumHeaps;
        while( n-- )
        {
	    DPF( 5, "Checking heap %d Heap start = 0x%08x Heap size = 0x%08x VidMem = 0x%08x",
	         n, phaAlias->fpVidMem, phaAlias->dwAliasSize , fpPhysVidMem );

	    if( ( NULL        != phaAlias->lpAlias  ) &&
	        ( fpPhysVidMem    >= phaAlias->fpVidMem ) &&
	        ( fpPhysVidMem + dwVidMemSize <= ( phaAlias->fpVidMem + phaAlias->dwAliasSize ) ) )
	    {
	        /*
	         * Compute the aliased pointer we are going to return.
	         */
	        dwHeapOffset = (DWORD) fpPhysVidMem - phaAlias->fpVidMem;
	        fpAliasedVidMem = (FLATPTR) ( ( (LPBYTE) phaAlias->lpAlias ) + dwHeapOffset );

	        DPF( 5, "Aliased pointer: 0x%08x - Offset: 0x%08x - Aliased heap: 0x%08x - VidMem heap: 0x%08x",
		     fpAliasedVidMem, dwHeapOffset, phaAlias->lpAlias, phaAlias->fpVidMem );
	        break;
	    }
	    phaAlias++;
        }
    }
    else
        DPF(4, "Could not find contiguous physical memory for linear mem pointer.");
    return fpAliasedVidMem;
}

#endif /* USE_ALIAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\classfac.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       classfac.c
 *  Content:	direct draw class factory code
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   24-dec-95	craige	initial implementation
 *   05-jan-96	kylej	added interface structures
 *   14-mar-96  colinmc added a class factory for clippers
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   22-oct-97  jeffno  Merge class factories, add classfac for CLSID_DirectDrawFactory2
 *
 ***************************************************************************/
#include "ddrawpr.h"

static IClassFactoryVtbl	directDrawClassFactoryVtbl;

typedef struct DDRAWCLASSFACTORY
{
   IClassFactoryVtbl 		*lpVtbl;
   DWORD			dwRefCnt;
   CLSID                        TargetCLSID;
} DDRAWCLASSFACTORY, *LPDDRAWCLASSFACTORY;

#define VALIDEX_DIRECTDRAWCF_PTR( ptr ) \
	( !IsBadWritePtr( ptr, sizeof( DDRAWCLASSFACTORY )) && \
	(ptr->lpVtbl == &directDrawClassFactoryVtbl) )

/************************************************************
 *
 * DirectDraw Driver Class Factory Member Functions.
 *
 ************************************************************/

#define DPF_MODNAME "DirectDrawClassFactory::QueryInterface"

/*
 * DirectDrawClassFactory_QueryInterface
 */
STDMETHODIMP DirectDrawClassFactory_QueryInterface(
		LPCLASSFACTORY this,
		REFIID riid,
		LPVOID *ppvObj )
{
    LPDDRAWCLASSFACTORY	pcf;

    DPF( 2, A, "ClassFactory::QueryInterface" );
    ENTER_DDRAW();
    TRY
    {
	pcf = (LPDDRAWCLASSFACTORY)this;
	if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
	{
	    DPF_ERR(  "Invalid this ptr" );
	    LEAVE_DDRAW();
	    return E_FAIL;
	}

	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF_ERR( "Invalid object ptr" );
	    LEAVE_DDRAW();
	    return E_INVALIDARG;
	}
	*ppvObj = NULL;

	if( !VALID_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid iid ptr" );
	    LEAVE_DDRAW();
	    return E_INVALIDARG;
	}

	if( IsEqualIID(riid, &IID_IClassFactory) ||
			IsEqualIID(riid, &IID_IUnknown))
	{
	    pcf->dwRefCnt++; 
	    *ppvObj = this;
	    LEAVE_DDRAW();
	    return S_OK;
	}
	else
	{ 
	    DPF( 0, "E_NOINTERFACE" );
	    LEAVE_DDRAW();
	    return E_NOINTERFACE;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

} /* DirectDrawClassFactory_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::AddRef"

/*
 * DirectDrawClassFactory_AddRef
 */
STDMETHODIMP_(ULONG) DirectDrawClassFactory_AddRef( LPCLASSFACTORY this )
{
    LPDDRAWCLASSFACTORY pcf;

    ENTER_DDRAW();
    TRY
    {
	pcf = (LPDDRAWCLASSFACTORY)this;
	if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
	{
	    DPF_ERR(  "Invalid this ptr" );
	    LEAVE_DDRAW();
	    return (ULONG)E_FAIL;
	}
	pcf->dwRefCnt++;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return (ULONG)E_INVALIDARG;
    }

    DPF( 5, "ClassFactory::AddRef, dwRefCnt=%ld", pcf->dwRefCnt );
    LEAVE_DDRAW();
    return pcf->dwRefCnt;

} /* DirectDrawClassFactory_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::Release"

/*
 * DirectDrawClassFactory_Release
 */
STDMETHODIMP_(ULONG) DirectDrawClassFactory_Release( LPCLASSFACTORY this )
{
    LPDDRAWCLASSFACTORY	pcf;

    ENTER_DDRAW();
    TRY
    {
	pcf = (LPDDRAWCLASSFACTORY)this;
	if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
	{
	    DPF_ERR(  "Invalid this ptr" );
	    LEAVE_DDRAW();
	    return (ULONG)E_FAIL;
	}
	pcf->dwRefCnt--;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return (ULONG)E_INVALIDARG;
    }
    DPF( 5, "ClassFactory::Release, dwRefCnt=%ld", pcf->dwRefCnt );

    if( pcf->dwRefCnt != 0 )
    {
	LEAVE_DDRAW();
	return pcf->dwRefCnt;
    }
    MemFree( pcf );
    LEAVE_DDRAW();
    return 0;

} /* DirectDrawClassFactory_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::CreateInstance"

/*
 * DirectDrawClassFactory_CreateInstance
 *
 * Creates an instance of a DirectDraw object
 */
STDMETHODIMP DirectDrawClassFactory_CreateInstance(
		LPCLASSFACTORY this,
		LPUNKNOWN pUnkOuter,
		REFIID riid,
		LPVOID *ppvObj
)
{
    HRESULT			hr = DD_OK;
    LPDDRAWI_DIRECTDRAW_INT	pdrv_int = NULL;
    LPDDRAWCLASSFACTORY		pcf;
    LPDIRECTDRAWCLIPPER               pclipper;

    DPF( 2, A, "ClassFactory::CreateInstance" );

    pcf = (LPDDRAWCLASSFACTORY) this;
    if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
    {
	DPF_ERR( "Invalid this ptr" );
	return E_INVALIDARG;
    }

    if( !VALIDEX_IID_PTR( riid ) )
    {
	DPF_ERR( "Invalid iid ptr" );
	return E_INVALIDARG;
    }

    if( !VALIDEX_PTR_PTR( ppvObj ) )
    {
	DPF_ERR( "Invalid object ptr" );
	return E_INVALIDARG;
    }

#ifdef POSTPONED
    if (pUnkOuter && !IsEqualIID(riid,&IID_IUnknown))
    {
        DPF_ERR("Can't aggregate with a punkouter != IUnknown");
        return CLASS_E_NOAGGREGATION;
    }
#else
    if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }
#endif

    /*
     * is DirectDraw supported on this system?
     */
    if( !DirectDrawSupported( TRUE ) )
    {
	DPF_ERR( "DirectDraw not supported!" );
	return E_FAIL;
    }

    /*
     * go build an DirectDraw interface
     *
     * NOTE: We provide the "uninitialized callback table
     * to prevent the use of this object for anything other
     * than AddRef(), Release() or Initialized().
     */
    ENTER_DDRAW();
    if ( IsEqualIID(&pcf->TargetCLSID, &CLSID_DirectDraw ) ||
         IsEqualIID(&pcf->TargetCLSID, &CLSID_DirectDraw7 ) )
    {
        if ( IsEqualIID(riid, &IID_IUnknown) )
        {
            /*
             * If we're aggregated, then we don't need to worry about the IUnknown being
             * the runtime identity (we are hidden inside the outer, since it's the one
             * that will field the QI for IUnknown).
             * This means we can point an aggregated interface at the nondelegating
             * unknowns
             */
            if (pUnkOuter)
            {
#ifdef POSTPONED
                pdrv_int = NewDriverInterface( NULL, &ddUninitNonDelegatingUnknownCallbacks );
#else
                pdrv_int = NewDriverInterface( NULL, &ddUninitCallbacks );
#endif
            }
            else
            {
                /*
                 * Not aggregated, so the IUnknown has to have the same pointer value
                 * as the IDirectDraw interfaces, since QI always simply returns the
                 * this ptr when asked for IUnknown
                 * (Note this actually doesn't work right now because Initalize will swap
                 * vtbls).
                 */
                pdrv_int = NewDriverInterface( NULL, &ddUninitCallbacks );
            }
        }
        else if ( IsEqualIID(riid, &IID_IDirectDraw) )
        {
            pdrv_int = NewDriverInterface( NULL, &ddUninitCallbacks );
        }
        else if ( IsEqualIID(riid, &IID_IDirectDraw2) )
        {
            pdrv_int = NewDriverInterface( NULL, &dd2UninitCallbacks );
        }
        else if ( IsEqualIID(riid, &IID_IDirectDraw4) )
        {
            pdrv_int = NewDriverInterface( NULL, &dd4UninitCallbacks );
        }
        else if ( IsEqualIID(riid, &IID_IDirectDraw7) )
        {
            pdrv_int = NewDriverInterface( NULL, &dd7UninitCallbacks );
        }


        if( NULL == pdrv_int )
        {
	    DPF( 0, "Call to NewDriverInterface failed" );
	    hr = E_OUTOFMEMORY;
        }

#ifdef POSTPONED
        /*
         * 
         */
        if (pUnkOuter)
        {
            pdrv_int->lpLcl->pUnkOuter = pUnkOuter;
        }
        else
        {
            pdrv_int->lpLcl->pUnkOuter = (IUnknown*) &UninitNonDelegatingIUnknownInterface;
        }
#endif

        pdrv_int->dwIntRefCnt--;
        pdrv_int->lpLcl->dwLocalRefCnt--;

        /*
         * NOTE: We call DD_QueryInterface() explicitly rather than
         * going through the vtable as the "uninitialized" interface
         * we are using here has QueryInterface() disabled.
         */
        if (SUCCEEDED(hr))
        {
            hr = DD_QueryInterface( (LPDIRECTDRAW) pdrv_int, riid, ppvObj );
            if( FAILED( hr ) )
            {
                DPF( 0, "Could not get interface id, hr=%08lx", hr );
                RemoveLocalFromList( pdrv_int->lpLcl );
                RemoveDriverFromList( pdrv_int, FALSE );
	        MemFree( pdrv_int->lpLcl );
                MemFree( pdrv_int );
            }
            else
            {
                DPF( 5, "New Interface=%08lx", *ppvObj );
            }
        }
    }
    else
    if ( IsEqualIID(&pcf->TargetCLSID, &CLSID_DirectDrawClipper ) )
    {
        /*
         * Build a new clipper.
         *
         * Unlike the DirectDraw driver objects, clippers create via
         * CoCreateInstance() are born pretty much initialized. The only
         * thing initialization might actually do is to reparent the
         * clipper to a given driver object. Otherwise all Initialize()
         * does is set a flag.
         */
        hr = InternalCreateClipper( NULL, 0UL, &pclipper, NULL, FALSE, NULL, NULL );
        if( FAILED( hr ) )
        {
	    DPF_ERR( "Failed to create the new clipper interface" );
        }

        /*
         * NOTE: Bizarre code fragment below works as follows:
         *
         * 1) InternalCreateClipper() returns a clipper with a reference count
         *    of 1 for each of the interface, local and global objects.
         * 2) QueryInterface() can do one of two things. It can either just return
         *    the same interface in which case the interface, local and global
         *    objects all get a reference count of 2 or it can return a different
         *    interface in which case both interfaces have a reference count of
         *    1 and the local and global objects have a reference count of 2.
         * 3) The immediate Release() following the QueryInterface() will in either
         *    case decrement the reference counts of the local and global objects
         *    to 1 (as required). If the same interface was returned by
         *    QueryInterface() then its reference count is decremented to 1 (as
         *    required). If a different interface was returned then the old
         *    interface is decremented to zero and it is released (as required).
         *    Also, if QueryInterface() fails, the Release() will decrement all
         *    the reference counts to 0 and the object will be freed.
         *
         * So it all makes perfect sense - really! (CMcC)
         *
         * ALSO NOTE: We call DD_Clipper_QueryInterface() explicitly rather than
         * going through the vtable as the "uninitialized" interface we are using
         * here has QueryInterface() disabled.
         */
        hr = DD_Clipper_QueryInterface( pclipper, riid, ppvObj );
        DD_Clipper_Release( pclipper );
        if( FAILED( hr ) )
        {
            DPF( 0, "Could not get interface id, hr=%08lx", hr );
        }
        else
        {
            DPF( 5, "New Interface=%08lx", *ppvObj );
        }
    }
#ifdef POSTPONED
    else if ( IsEqualIID(&pcf->TargetCLSID, &CLSID_DirectDrawFactory2) )
    {
        LPDDFACTORY2 lpDDFac = NULL;
        /*
         * Build a new DirectDrawFactory2
         * This returns an object, with refcnt=0. The QI then bumps that to 1.
         */
        hr = InternalCreateDDFactory2( &lpDDFac, pUnkOuter );
        if( SUCCEEDED( hr ) )
        {
            /*
             * The QI should catch that the vtable is the ddrawfactory2 vtable,
             * and simply bump the addref on the passed-in pointer. This means we
             * won't orphan the pointer created by InternalCreateDDFactory2.
             */
            hr = ((IUnknown*)lpDDFac)->lpVtbl->QueryInterface( (IUnknown*)lpDDFac, riid, ppvObj );
            if( SUCCEEDED( hr ) )
            {
                DPF( 5, "New DDFactory2 Interface=%08lx", *ppvObj );
            }
            else
            {
                MemFree(lpDDFac);
                DPF( 0, "Could not get DDFactory2 interface id, hr=%08lx", hr );
            }
        }
        else
        {
	    DPF_ERR( "Failed to create the new dd factory2 interface" );
        }
    }
#endif
    LEAVE_DDRAW();
    return hr;

} /* DirectDrawClassFactory_CreateInstance */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::LockServer"

/*
 * DirectDrawClassFactory_LockServer
 *
 * Called to force our DLL to stayed loaded
 */
STDMETHODIMP DirectDrawClassFactory_LockServer(
                LPCLASSFACTORY this,
                BOOL fLock
)
{
    HRESULT		hr;
    HANDLE		hdll;
    LPDDRAWCLASSFACTORY	pcf;

    pcf = (LPDDRAWCLASSFACTORY) this;
    if( !VALIDEX_DIRECTDRAWCF_PTR( pcf ) )
    {
	DPF_ERR( "Invalid this ptr" );
	return E_INVALIDARG;
    }

    /*
     * call CoLockObjectExternal
     */
    DPF( 2, A, "ClassFactory::LockServer" );
    hr = E_UNEXPECTED;
    hdll = LoadLibrary( "OLE32.DLL" );
    if( hdll != NULL )
    {
	HRESULT (WINAPI * lpCoLockObjectExternal)(LPUNKNOWN, BOOL, BOOL );
	lpCoLockObjectExternal = (LPVOID) GetProcAddress( hdll, "CoLockObjectExternal" );
	if( lpCoLockObjectExternal != NULL )
	{
	    hr = lpCoLockObjectExternal( (LPUNKNOWN) this, fLock, TRUE );
	}
	else
	{
	    DPF_ERR( "Error! Could not get procaddr for CoLockObjectExternal" );
	}
    }
    else
    {
	DPF_ERR( "Error! Could not load OLE32.DLL" );
    }

    /*
     * track the number of server locks total
     */
    if( SUCCEEDED( hr ) )
    {
	ENTER_DDRAW();
	if( fLock )
	{
	    dwLockCount++;
	}
	else
	{
	    #ifdef DEBUG
		if( (int) dwLockCount <= 0 )
		{
		    DPF( 0, "Invalid LockCount in LockServer! (%d)", dwLockCount );
		    DEBUG_BREAK();
		}
	    #endif
	    dwLockCount--;
	}
	DPF( 5, "LockServer:dwLockCount =%ld", dwLockCount );
	LEAVE_DDRAW();
    }
    return hr;

} /* DirectDrawClassFactory_LockServer */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawClassFactory::CreateInstance"


static IClassFactoryVtbl directDrawClassFactoryVtbl =
{
        DirectDrawClassFactory_QueryInterface,
        DirectDrawClassFactory_AddRef,
        DirectDrawClassFactory_Release,
        DirectDrawClassFactory_CreateInstance,
        DirectDrawClassFactory_LockServer
};

#undef DPF_MODNAME
#define DPF_MODNAME "DllGetClassObject"

/*
 * DllGetClassObject
 *
 * Entry point called by COM to get a ClassFactory pointer
 */
HRESULT WINAPI DllGetClassObject(
		REFCLSID rclsid,
		REFIID riid,
		LPVOID *ppvObj )
{
    LPDDRAWCLASSFACTORY	pcf;
    HRESULT		hr;

    /*
     * validate parms
     */
    if( !VALIDEX_PTR_PTR( ppvObj ) )
    {
	DPF_ERR( "Invalid object ptr" );
	return E_INVALIDARG;
    }
    *ppvObj = NULL;
    if( !VALIDEX_IID_PTR( rclsid ) )
    {
	DPF_ERR( "Invalid clsid ptr" );
	return E_INVALIDARG;
    }
    if( !VALIDEX_IID_PTR( riid ) )
    {
	DPF_ERR( "Invalid iid ptr" );
	return E_INVALIDARG;
    }

    /*
     * is this one our class ids?
     */
    if( IsEqualCLSID( rclsid, &CLSID_DirectDraw ) ||
        IsEqualCLSID( rclsid, &CLSID_DirectDraw7 ) ||
        IsEqualCLSID( rclsid, &CLSID_DirectDrawClipper ) ||
        IsEqualCLSID( rclsid, &CLSID_DirectDrawFactory2 ))
    {
	/*
	 * It's the DirectDraw driver class ID.
	 */

	/*
	 * only allow IUnknown and IClassFactory
	 */
	if( !IsEqualIID( riid, &IID_IUnknown ) &&
    	    !IsEqualIID( riid, &IID_IClassFactory ) )
	{
	    return E_NOINTERFACE;
	}

	/*
	 * create a class factory object
	 */
	ENTER_DDRAW();
	pcf = MemAlloc( sizeof( DDRAWCLASSFACTORY ) );
	if( pcf == NULL )
	{
	    LEAVE_DDRAW();
	    return E_OUTOFMEMORY;
	}

	pcf->lpVtbl = &directDrawClassFactoryVtbl;
	pcf->dwRefCnt = 0;
        memcpy(&pcf->TargetCLSID,rclsid,sizeof(*rclsid));
	#pragma message( REMIND( "Do we need to have a refcnt of 0 after DllGetClassObject?" ))
	hr = DirectDrawClassFactory_QueryInterface( (LPCLASSFACTORY) pcf, riid, ppvObj );
	if( FAILED( hr ) )
	{
	    MemFree( pcf );
	    *ppvObj = NULL;
	    DPF( 0, "QueryInterface failed, rc=%08lx", hr );
	}
	else
	{
	    DPF( 5, "DllGetClassObject succeeded, pcf=%08lx", pcf );
	}
	LEAVE_DDRAW();
	return hr;
    }
    else
    {
        return E_FAIL;
    }

} /* DllGetClassObject */

/*
 * DllCanUnloadNow
 *
 * Entry point called by COM to see if it is OK to free our DLL
 */
HRESULT WINAPI DllCanUnloadNow( void )
{
    HRESULT	hr;

    DPF( 2, A, "DllCanUnloadNow called" );
    hr = S_FALSE;
    ENTER_DDRAW();

    /*
     * Only unload if there are no driver objects and no global
     * clipper objects (there won't be any local clipper objects
     * as they are destroyed by their driver so the check on driver
     * object handles them).
     */
    if( ( lpDriverObjectList  == NULL ) &&
        ( lpDriverLocalList == NULL ) &&
	( lpGlobalClipperList == NULL ) )
    {
	if( dwLockCount == 0 )
	{
	    DPF( 3, "It is OK to unload" );
	    hr = S_OK;
	}
    }
    LEAVE_DDRAW();
    return hr;

} /* DllCanUnloadNow */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddcallbk.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcallbk.c
 *  Content:    Callback tables management code
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   23-jan-96  kylej   initial implementation
 *   03-feb-96  colinmc fixed DirectDraw QueryInterface bug
 *   24-feb-96  colinmc added a function to enable a client to determine if
 *                      the callback tables had already been initialized.
 *   13-mar-96  kylej   added DD_Surface_GetDDInterface
 *   21-mar-96  colinmc added special "unitialized" interfaces for the
 *                      driver and clipper objects
 *   13-jan-97 jvanaken basic support for IDirectDrawSurface3 interface
 *   29-jan-97  smac    Removed un-needed VPE functions
 *   03-mar-97  smac    Added kernel mode interface
 *   08-mar-97  colinmc New member to set surface memory pointer
 *   30-sep-97  jeffno  IDirectDraw4
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *
 ***************************************************************************/
#include "ddrawpr.h"

/*
 * Under Windows95 only one copy of a callback table exists and it is
 * shared among all processes using DirectDraw.  Under Windows NT, there
 * is a unique callback table for each process using DirectDraw.  This is
 * because the address of the member functions is guaranteed to be the
 * same from process to process under Windows 95 but may be different in
 * each process under Windows NT.  We initialize the callback tables in
 * a function rather than initializing them at compile time so that the
 * callback tables will not be shared under NT.
 */

DIRECTDRAWCALLBACKS     ddCallbacks;
DIRECTDRAWCALLBACKS     ddUninitCallbacks;
DIRECTDRAW2CALLBACKS        dd2UninitCallbacks;
DIRECTDRAW2CALLBACKS        dd2Callbacks;
DIRECTDRAW4CALLBACKS        dd4UninitCallbacks;
DIRECTDRAW4CALLBACKS        dd4Callbacks;
DIRECTDRAW7CALLBACKS        dd7UninitCallbacks;
DIRECTDRAW7CALLBACKS        dd7Callbacks;
DIRECTDRAWSURFACECALLBACKS  ddSurfaceCallbacks;
DIRECTDRAWSURFACE2CALLBACKS ddSurface2Callbacks;
DIRECTDRAWSURFACE3CALLBACKS ddSurface3Callbacks;
DIRECTDRAWSURFACE4CALLBACKS ddSurface4Callbacks;
DIRECTDRAWSURFACE7CALLBACKS ddSurface7Callbacks;
DIRECTDRAWPALETTECALLBACKS  ddPaletteCallbacks;
DIRECTDRAWCLIPPERCALLBACKS  ddClipperCallbacks;
DIRECTDRAWCLIPPERCALLBACKS  ddUninitClipperCallbacks;
DDVIDEOPORTCONTAINERCALLBACKS ddVideoPortContainerCallbacks;
DIRECTDRAWVIDEOPORTCALLBACKS ddVideoPortCallbacks;
DIRECTDRAWVIDEOPORTNOTIFYCALLBACKS ddVideoPortNotifyCallbacks;
DIRECTDRAWCOLORCONTROLCALLBACKS ddColorControlCallbacks;
DIRECTDRAWGAMMACONTROLCALLBACKS ddGammaControlCallbacks;
DIRECTDRAWKERNELCALLBACKS    ddKernelCallbacks;
DIRECTDRAWSURFACEKERNELCALLBACKS ddSurfaceKernelCallbacks;
DDVIDEOACCELERATORCONTAINERCALLBACKS ddMotionCompContainerCallbacks;
DIRECTDRAWVIDEOACCELERATORCALLBACKS ddMotionCompCallbacks;

#ifdef POSTPONED
DIRECTDRAWSURFACEPERSISTCALLBACKS   ddSurfacePersistCallbacks;
DIRECTDRAWSURFACEPERSISTSTREAMCALLBACKS  ddSurfacePersistStreamCallbacks;
DIRECTDRAWPALETTEPERSISTCALLBACKS   ddPalettePersistCallbacks;
DIRECTDRAWPALETTEPERSISTSTREAMCALLBACKS  ddPalettePersistStreamCallbacks;
DIRECTDRAWOPTSURFACECALLBACKS ddOptSurfaceCallbacks;
DDFACTORY2CALLBACKS         ddFactory2Callbacks;
DIRECTDRAWPALETTE2CALLBACKS ddPalette2Callbacks;
#endif

#ifdef POSTPONED
NONDELEGATINGUNKNOWNCALLBACKS  ddNonDelegatingUnknownCallbacks;
NONDELEGATINGUNKNOWNCALLBACKS  ddUninitNonDelegatingUnknownCallbacks;

/*
 * This is an interface which points to the nondelegating unknowns
 */
LPVOID NonDelegatingIUnknownInterface;
LPVOID UninitNonDelegatingIUnknownInterface;
#endif

#ifdef STREAMING
DIRECTDRAWSURFACESTREAMINGCALLBACKS ddSurfaceStreamingCallbacks;
#endif
#ifdef COMPOSITION
DIRECTDRAWSURFACECOMPOSITIONCALLBACKS ddSurfaceCompositionCallbacks;
#endif

#undef DPF_MODNAME
#define DPF_MODNAME "Uninitialized"

/*
 * The horror, the horror...
 *
 * These are placeholder functions which sit in the interfaces of
 * uninitialized objects. They are there to prevent people calling
 * member functions before Initialize() is called.
 *
 * Now, you may well be wondering why there are five of them rather
 * than just one. Well, unfortunately, DDAPI expands out to __stdcall
 * which means that it is the callee's responsibility to clean up the
 * stack. Hence, if we have one, zero argument function say and it is
 * called through the vtable in place of a four argument function we
 * will leave four dwords on the stack when we exit. This is ugly
 * and potentially dangerous. Therefore, we have one stub function for
 * each number of arguments in the member interfaces (between 1 and 5).
 * This works because we are very regular in passing only DWORD/LPVOID
 * size parameters on the stack. Ugly but there it is.
 */

HRESULT DDAPI DD_Uninitialized1Arg( LPVOID arg1 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized2Arg( LPVOID arg1, LPVOID arg2 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized3Arg( LPVOID arg1, LPVOID arg2, LPVOID arg3 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized4Arg( LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized5Arg( LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4, LPVOID arg5 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}

HRESULT DDAPI DD_Uninitialized6Arg( LPVOID arg1, LPVOID arg2, LPVOID arg3, LPVOID arg4, LPVOID arg5, LPVOID arg6 )
{
    DPF_ERR( "Object is not initialized - call Initialized()" );
    return DDERR_NOTINITIALIZED;
}


#undef DPF_MODNAME
#define DPF_MODNAME "CallbackTablesInitialized"

BOOL CallbackTablesInitialized( void )
{
    /*
     * Arbitrarily we check to see if ddCallbacks.QueryInterface
     * contains the correct value to determine whether the
     * callbacks are already initialized.
     */
    if( ddCallbacks.QueryInterface == DD_QueryInterface )
        return TRUE;
    else
        return FALSE;
}

#undef DPF_MODNAME
#define DPF_MODNAME "InitCallbackTables"

void InitCallbackTables( void )
{
    /*
     * DirectDraw object methods Ver 1.0
     */
#ifdef POSTPONED
    ddCallbacks.QueryInterface = DD_DelegatingQueryInterface;
    ddCallbacks.AddRef = DD_DelegatingAddRef;
    ddCallbacks.Release = DD_DelegatingRelease;
#else
    ddCallbacks.QueryInterface = DD_QueryInterface;
    ddCallbacks.AddRef = DD_AddRef;
    ddCallbacks.Release = DD_Release;
#endif
    ddCallbacks.Compact = DD_Compact;
    ddCallbacks.CreateClipper = DD_CreateClipper;
    ddCallbacks.CreatePalette = DD_CreatePalette;
    ddCallbacks.CreateSurface = DD_CreateSurface;
    ddCallbacks.DuplicateSurface = DD_DuplicateSurface;
    ddCallbacks.EnumDisplayModes = DD_EnumDisplayModes;
    ddCallbacks.EnumSurfaces = DD_EnumSurfaces;
    ddCallbacks.FlipToGDISurface = DD_FlipToGDISurface;
    ddCallbacks.GetCaps = DD_GetCaps;
    ddCallbacks.GetDisplayMode = DD_GetDisplayMode;
    ddCallbacks.GetFourCCCodes = DD_GetFourCCCodes;
    ddCallbacks.GetGDISurface = DD_GetGDISurface;
    ddCallbacks.GetMonitorFrequency = DD_GetMonitorFrequency;
    ddCallbacks.GetScanLine = DD_GetScanLine;
    ddCallbacks.GetVerticalBlankStatus = DD_GetVerticalBlankStatus;
    ddCallbacks.Initialize = DD_Initialize;
    ddCallbacks.RestoreDisplayMode = DD_RestoreDisplayMode;
    ddCallbacks.SetCooperativeLevel = DD_SetCooperativeLevel;
    ddCallbacks.SetDisplayMode = DD_SetDisplayMode;
    ddCallbacks.WaitForVerticalBlank = DD_WaitForVerticalBlank;

#ifdef POSTPONED
    /*
     * Delegating Unknown Callbacks
     */
    ddNonDelegatingUnknownCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddNonDelegatingUnknownCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddNonDelegatingUnknownCallbacks.Release = (LPVOID)DD_Release;

    /*
     * Uninitialized Delegating Unknown Callbacks
     */
    ddUninitNonDelegatingUnknownCallbacks.QueryInterface = (LPVOID)DD_UnInitedQueryInterface;
    ddUninitNonDelegatingUnknownCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddUninitNonDelegatingUnknownCallbacks.Release = (LPVOID)DD_Release;

    /*
     * This is a special static interface whose vtable points to the nondelegating unknown
     */
    NonDelegatingIUnknownInterface = (LPVOID) &ddNonDelegatingUnknownCallbacks;
    UninitNonDelegatingIUnknownInterface = (LPVOID) &ddUninitNonDelegatingUnknownCallbacks;
#endif

    /*
     * DirectDraw "uninitialized" object methods Ver 1.0
     */
#ifdef POSTPONED
    ddUninitCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    ddUninitCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    ddUninitCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    ddUninitCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddUninitCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddUninitCallbacks.Release = (LPVOID)DD_Release;
#endif
    ddUninitCallbacks.Compact = (LPVOID)DD_Uninitialized1Arg;
    ddUninitCallbacks.CreateClipper = (LPVOID)DD_Uninitialized4Arg;
    ddUninitCallbacks.CreatePalette =   (LPVOID)DD_Uninitialized5Arg;
    ddUninitCallbacks.CreateSurface =   (LPVOID)DD_Uninitialized4Arg;
    ddUninitCallbacks.DuplicateSurface = (LPVOID)DD_Uninitialized3Arg;
    ddUninitCallbacks.EnumDisplayModes = (LPVOID)DD_Uninitialized5Arg;
    ddUninitCallbacks.EnumSurfaces = (LPVOID)DD_Uninitialized5Arg;
    ddUninitCallbacks.FlipToGDISurface = (LPVOID)DD_Uninitialized1Arg;
    ddUninitCallbacks.GetCaps = (LPVOID)DD_Uninitialized3Arg;
    ddUninitCallbacks.GetDisplayMode = (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.GetFourCCCodes = (LPVOID)DD_Uninitialized3Arg;
    ddUninitCallbacks.GetGDISurface =   (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.GetMonitorFrequency = (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.GetScanLine = (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.GetVerticalBlankStatus = (LPVOID)DD_Uninitialized2Arg;
    ddUninitCallbacks.Initialize = DD_Initialize;
    ddUninitCallbacks.RestoreDisplayMode = (LPVOID)DD_Uninitialized1Arg;
    ddUninitCallbacks.SetCooperativeLevel = (LPVOID)DD_Uninitialized3Arg;
    ddUninitCallbacks.SetDisplayMode = (LPVOID)DD_Uninitialized4Arg;
    ddUninitCallbacks.WaitForVerticalBlank = (LPVOID)DD_Uninitialized3Arg;

    /*
     * DirectDraw "uninitialized" object methods Ver 2.0
     */
#ifdef POSTPONED
    dd2UninitCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd2UninitCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd2UninitCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd2UninitCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd2UninitCallbacks.AddRef = (LPVOID)DD_AddRef;
    dd2UninitCallbacks.Release = (LPVOID)DD_Release;
#endif
    dd2UninitCallbacks.Compact = (LPVOID)DD_Uninitialized1Arg;
    dd2UninitCallbacks.CreateClipper = (LPVOID)DD_Uninitialized4Arg;
    dd2UninitCallbacks.CreatePalette =  (LPVOID)DD_Uninitialized5Arg;
    dd2UninitCallbacks.CreateSurface =  (LPVOID)DD_Uninitialized4Arg;
    dd2UninitCallbacks.DuplicateSurface = (LPVOID)DD_Uninitialized3Arg;
    dd2UninitCallbacks.EnumDisplayModes = (LPVOID)DD_Uninitialized5Arg;
    dd2UninitCallbacks.EnumSurfaces = (LPVOID)DD_Uninitialized5Arg;
    dd2UninitCallbacks.FlipToGDISurface = (LPVOID)DD_Uninitialized1Arg;
    dd2UninitCallbacks.GetCaps = (LPVOID)DD_Uninitialized3Arg;
    dd2UninitCallbacks.GetDisplayMode = (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.GetFourCCCodes = (LPVOID)DD_Uninitialized3Arg;
    dd2UninitCallbacks.GetGDISurface =  (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.GetMonitorFrequency = (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.GetScanLine = (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.GetVerticalBlankStatus = (LPVOID)DD_Uninitialized2Arg;
    dd2UninitCallbacks.Initialize = (LPVOID)DD_Initialize;
    dd2UninitCallbacks.RestoreDisplayMode = (LPVOID)DD_Uninitialized1Arg;
    dd2UninitCallbacks.SetCooperativeLevel = (LPVOID)DD_Uninitialized3Arg;
    dd2UninitCallbacks.SetDisplayMode = (LPVOID)DD_Uninitialized6Arg;
    dd2UninitCallbacks.WaitForVerticalBlank = (LPVOID)DD_Uninitialized3Arg;

    /*
     * DirectDraw "uninitialized" object methods Ver 4.0
     */
#ifdef POSTPONED
    dd4UninitCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd4UninitCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd4UninitCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd4UninitCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd4UninitCallbacks.AddRef = (LPVOID)DD_AddRef;
    dd4UninitCallbacks.Release = (LPVOID)DD_Release;
#endif
    dd4UninitCallbacks.Compact = (LPVOID)DD_Uninitialized1Arg;
    dd4UninitCallbacks.CreateClipper = (LPVOID)DD_Uninitialized4Arg;
    dd4UninitCallbacks.CreatePalette =  (LPVOID)DD_Uninitialized5Arg;
    dd4UninitCallbacks.CreateSurface =  (LPVOID)DD_Uninitialized4Arg;
    dd4UninitCallbacks.DuplicateSurface = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.EnumDisplayModes = (LPVOID)DD_Uninitialized5Arg;
    dd4UninitCallbacks.EnumSurfaces = (LPVOID)DD_Uninitialized5Arg;
    dd4UninitCallbacks.FlipToGDISurface = (LPVOID)DD_Uninitialized1Arg;
    dd4UninitCallbacks.GetCaps = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.GetDisplayMode = (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.GetFourCCCodes = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.GetGDISurface =  (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.GetMonitorFrequency = (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.GetScanLine = (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.GetVerticalBlankStatus = (LPVOID)DD_Uninitialized2Arg;
    dd4UninitCallbacks.Initialize = (LPVOID)DD_Initialize;
    dd4UninitCallbacks.RestoreDisplayMode = (LPVOID)DD_Uninitialized1Arg;
    dd4UninitCallbacks.SetCooperativeLevel = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.SetDisplayMode = (LPVOID)DD_Uninitialized6Arg;
    dd4UninitCallbacks.WaitForVerticalBlank = (LPVOID)DD_Uninitialized3Arg;
    dd4UninitCallbacks.GetSurfaceFromDC = (LPVOID) DD_Uninitialized3Arg;
    dd4UninitCallbacks.RestoreAllSurfaces = (LPVOID) DD_Uninitialized1Arg;
    dd4UninitCallbacks.TestCooperativeLevel = (LPVOID) DD_Uninitialized1Arg;
    dd4UninitCallbacks.GetDeviceIdentifier = (LPVOID) DD_Uninitialized2Arg;

    /*
     * DirectDraw "uninitialized" object methods Ver 5.0
     */
#ifdef POSTPONED
    dd7UninitCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd7UninitCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd7UninitCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd7UninitCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd7UninitCallbacks.AddRef = (LPVOID)DD_AddRef;
    dd7UninitCallbacks.Release = (LPVOID)DD_Release;
#endif
    dd7UninitCallbacks.Compact = (LPVOID)DD_Uninitialized1Arg;
    dd7UninitCallbacks.CreateClipper = (LPVOID)DD_Uninitialized4Arg;
    dd7UninitCallbacks.CreatePalette =  (LPVOID)DD_Uninitialized5Arg;
    dd7UninitCallbacks.CreateSurface =  (LPVOID)DD_Uninitialized4Arg;
    dd7UninitCallbacks.DuplicateSurface = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.EnumDisplayModes = (LPVOID)DD_Uninitialized5Arg;
    dd7UninitCallbacks.EnumSurfaces = (LPVOID)DD_Uninitialized5Arg;
    dd7UninitCallbacks.FlipToGDISurface = (LPVOID)DD_Uninitialized1Arg;
    dd7UninitCallbacks.GetCaps = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.GetDisplayMode = (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.GetFourCCCodes = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.GetGDISurface =  (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.GetMonitorFrequency = (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.GetScanLine = (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.GetVerticalBlankStatus = (LPVOID)DD_Uninitialized2Arg;
    dd7UninitCallbacks.Initialize = (LPVOID)DD_Initialize;
    dd7UninitCallbacks.RestoreDisplayMode = (LPVOID)DD_Uninitialized1Arg;
    dd7UninitCallbacks.SetCooperativeLevel = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.SetDisplayMode = (LPVOID)DD_Uninitialized6Arg;
    dd7UninitCallbacks.WaitForVerticalBlank = (LPVOID)DD_Uninitialized3Arg;
    dd7UninitCallbacks.GetSurfaceFromDC = (LPVOID) DD_Uninitialized3Arg;
    dd7UninitCallbacks.RestoreAllSurfaces = (LPVOID) DD_Uninitialized1Arg;
    dd7UninitCallbacks.TestCooperativeLevel = (LPVOID) DD_Uninitialized1Arg;
    dd7UninitCallbacks.GetDeviceIdentifier = (LPVOID) DD_Uninitialized2Arg;
#ifdef POSTPONED
    dd7UninitCallbacks.CreateSurfaceFromStream = (LPVOID) DD_Uninitialized5Arg;
    dd7UninitCallbacks.CreateSurfaceFromFile = (LPVOID) DD_Uninitialized5Arg;
#endif

    /*
     * DirectDraw object methods Ver 2.0
     */
#ifdef POSTPONED
    dd2Callbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd2Callbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd2Callbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd2Callbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd2Callbacks.AddRef = (LPVOID)DD_AddRef;
    dd2Callbacks.Release = (LPVOID)DD_Release;
#endif
    dd2Callbacks.Compact = (LPVOID)DD_Compact;
    dd2Callbacks.CreateClipper = (LPVOID)DD_CreateClipper;
    dd2Callbacks.CreatePalette = (LPVOID)DD_CreatePalette;
    dd2Callbacks.CreateSurface = (LPVOID)DD_CreateSurface;
    dd2Callbacks.DuplicateSurface = (LPVOID)DD_DuplicateSurface;
    dd2Callbacks.EnumDisplayModes = (LPVOID)DD_EnumDisplayModes;
    dd2Callbacks.EnumSurfaces = (LPVOID)DD_EnumSurfaces;
    dd2Callbacks.FlipToGDISurface = (LPVOID)DD_FlipToGDISurface;
    dd2Callbacks.GetAvailableVidMem = (LPVOID)DD_GetAvailableVidMem;
    dd2Callbacks.GetCaps = (LPVOID)DD_GetCaps;
    dd2Callbacks.GetDisplayMode = (LPVOID)DD_GetDisplayMode;
    dd2Callbacks.GetFourCCCodes = (LPVOID)DD_GetFourCCCodes;
    dd2Callbacks.GetGDISurface = (LPVOID)DD_GetGDISurface;
    dd2Callbacks.GetMonitorFrequency = (LPVOID)DD_GetMonitorFrequency;
    dd2Callbacks.GetScanLine = (LPVOID)DD_GetScanLine;
    dd2Callbacks.GetVerticalBlankStatus = (LPVOID)DD_GetVerticalBlankStatus;
    dd2Callbacks.Initialize = (LPVOID)DD_Initialize;
    dd2Callbacks.RestoreDisplayMode = (LPVOID)DD_RestoreDisplayMode;
    dd2Callbacks.SetCooperativeLevel = (LPVOID)DD_SetCooperativeLevel;
    dd2Callbacks.SetDisplayMode = (LPVOID)DD_SetDisplayMode2;
    dd2Callbacks.WaitForVerticalBlank = (LPVOID)DD_WaitForVerticalBlank;


    /*
     * DirectDraw object methods Ver 4.0
     */
#ifdef POSTPONED
    dd4Callbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd4Callbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd4Callbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd4Callbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd4Callbacks.AddRef = (LPVOID)DD_AddRef;
    dd4Callbacks.Release = (LPVOID)DD_Release;
#endif
    dd4Callbacks.Compact = (LPVOID)DD_Compact;
    dd4Callbacks.CreateClipper = (LPVOID)DD_CreateClipper;
    dd4Callbacks.CreatePalette = (LPVOID)DD_CreatePalette;
    dd4Callbacks.CreateSurface = (LPVOID)DD_CreateSurface4;
    dd4Callbacks.DuplicateSurface = (LPVOID)DD_DuplicateSurface;
    dd4Callbacks.EnumDisplayModes = (LPVOID)DD_EnumDisplayModes4;
    dd4Callbacks.EnumSurfaces = (LPVOID)DD_EnumSurfaces4;
    dd4Callbacks.FlipToGDISurface = (LPVOID)DD_FlipToGDISurface;
    dd4Callbacks.GetAvailableVidMem = (LPVOID)DD_GetAvailableVidMem4;
    dd4Callbacks.GetCaps = (LPVOID)DD_GetCaps;
    dd4Callbacks.GetDisplayMode = (LPVOID)DD_GetDisplayMode;
    dd4Callbacks.GetFourCCCodes = (LPVOID)DD_GetFourCCCodes;
    dd4Callbacks.GetGDISurface = (LPVOID)DD_GetGDISurface;
    dd4Callbacks.GetMonitorFrequency = (LPVOID)DD_GetMonitorFrequency;
    dd4Callbacks.GetScanLine = (LPVOID)DD_GetScanLine;
    dd4Callbacks.GetVerticalBlankStatus = (LPVOID)DD_GetVerticalBlankStatus;
    dd4Callbacks.Initialize = (LPVOID)DD_Initialize;
    dd4Callbacks.RestoreDisplayMode = (LPVOID)DD_RestoreDisplayMode;
    dd4Callbacks.SetCooperativeLevel = (LPVOID)DD_SetCooperativeLevel;
    dd4Callbacks.SetDisplayMode = (LPVOID)DD_SetDisplayMode2;
    dd4Callbacks.WaitForVerticalBlank = (LPVOID)DD_WaitForVerticalBlank;
    dd4Callbacks.GetSurfaceFromDC = (LPVOID) DD_GetSurfaceFromDC;
    dd4Callbacks.RestoreAllSurfaces = (LPVOID) DD_RestoreAllSurfaces;
    dd4Callbacks.TestCooperativeLevel = (LPVOID) DD_TestCooperativeLevel;
    dd4Callbacks.GetDeviceIdentifier = (LPVOID) DD_GetDeviceIdentifier;

    /*
     * DirectDraw object methods Ver 5.0
     */
#ifdef POSTPONED
    dd7Callbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    dd7Callbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    dd7Callbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    dd7Callbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    dd7Callbacks.AddRef = (LPVOID)DD_AddRef;
    dd7Callbacks.Release = (LPVOID)DD_Release;
#endif
    dd7Callbacks.Compact = (LPVOID)DD_Compact;
    dd7Callbacks.CreateClipper = (LPVOID)DD_CreateClipper;
    dd7Callbacks.CreatePalette = (LPVOID)DD_CreatePalette;
    dd7Callbacks.CreateSurface = (LPVOID)DD_CreateSurface4;
    dd7Callbacks.DuplicateSurface = (LPVOID)DD_DuplicateSurface;
    dd7Callbacks.EnumDisplayModes = (LPVOID)DD_EnumDisplayModes4;
    dd7Callbacks.EnumSurfaces = (LPVOID)DD_EnumSurfaces4;
    dd7Callbacks.FlipToGDISurface = (LPVOID)DD_FlipToGDISurface;
    dd7Callbacks.GetAvailableVidMem = (LPVOID)DD_GetAvailableVidMem4;
    dd7Callbacks.GetCaps = (LPVOID)DD_GetCaps;
    dd7Callbacks.GetDisplayMode = (LPVOID)DD_GetDisplayMode;
    dd7Callbacks.GetFourCCCodes = (LPVOID)DD_GetFourCCCodes;
    dd7Callbacks.GetGDISurface = (LPVOID)DD_GetGDISurface;
    dd7Callbacks.GetMonitorFrequency = (LPVOID)DD_GetMonitorFrequency;
    dd7Callbacks.GetScanLine = (LPVOID)DD_GetScanLine;
    dd7Callbacks.GetVerticalBlankStatus = (LPVOID)DD_GetVerticalBlankStatus;
    dd7Callbacks.Initialize = (LPVOID)DD_Initialize;
    dd7Callbacks.RestoreDisplayMode = (LPVOID)DD_RestoreDisplayMode;
    dd7Callbacks.SetCooperativeLevel = (LPVOID)DD_SetCooperativeLevel;
    dd7Callbacks.SetDisplayMode = (LPVOID)DD_SetDisplayMode2;
    dd7Callbacks.WaitForVerticalBlank = (LPVOID)DD_WaitForVerticalBlank;
    dd7Callbacks.GetSurfaceFromDC = (LPVOID) DD_GetSurfaceFromDC;
    dd7Callbacks.RestoreAllSurfaces = (LPVOID) DD_RestoreAllSurfaces;
    dd7Callbacks.TestCooperativeLevel = (LPVOID) DD_TestCooperativeLevel;
    dd7Callbacks.GetDeviceIdentifier = (LPVOID) DD_GetDeviceIdentifier7;
    dd7Callbacks.StartModeTest = (LPVOID) DD_StartModeTest;
    dd7Callbacks.EvaluateMode = (LPVOID) DD_EvaluateMode;
#ifdef POSTPONED
    dd7Callbacks.CreateSurfaceFromStream = (LPVOID) DD_CreateSurfaceFromStream;
    dd7Callbacks.CreateSurfaceFromFile = (LPVOID) DD_CreateSurfaceFromFile;
#endif

    /*
     * DirectDraw Surface object methods Ver 1.0
     */
    ddSurfaceCallbacks.QueryInterface = DD_Surface_QueryInterface;
    ddSurfaceCallbacks.AddRef = DD_Surface_AddRef;
    ddSurfaceCallbacks.Release = DD_Surface_Release;
    ddSurfaceCallbacks.AddAttachedSurface = DD_Surface_AddAttachedSurface;
    ddSurfaceCallbacks.AddOverlayDirtyRect = DD_Surface_AddOverlayDirtyRect;
    ddSurfaceCallbacks.Blt = DD_Surface_Blt;
    ddSurfaceCallbacks.BltBatch = DD_Surface_BltBatch;
    ddSurfaceCallbacks.BltFast = DD_Surface_BltFast;
    ddSurfaceCallbacks.DeleteAttachedSurface = DD_Surface_DeleteAttachedSurfaces;
    ddSurfaceCallbacks.EnumAttachedSurfaces = DD_Surface_EnumAttachedSurfaces;
    ddSurfaceCallbacks.EnumOverlayZOrders = DD_Surface_EnumOverlayZOrders;
    ddSurfaceCallbacks.Flip = DD_Surface_Flip;
    ddSurfaceCallbacks.GetAttachedSurface = DD_Surface_GetAttachedSurface;
    ddSurfaceCallbacks.GetBltStatus = DD_Surface_GetBltStatus;
    ddSurfaceCallbacks.GetCaps = DD_Surface_GetCaps;
    ddSurfaceCallbacks.GetClipper = DD_Surface_GetClipper;
    ddSurfaceCallbacks.GetColorKey = DD_Surface_GetColorKey;
    ddSurfaceCallbacks.GetDC = DD_Surface_GetDC;
    ddSurfaceCallbacks.GetFlipStatus = DD_Surface_GetFlipStatus;
    ddSurfaceCallbacks.GetOverlayPosition = DD_Surface_GetOverlayPosition;
    ddSurfaceCallbacks.GetPalette = DD_Surface_GetPalette;
    ddSurfaceCallbacks.GetPixelFormat = DD_Surface_GetPixelFormat;
    ddSurfaceCallbacks.GetSurfaceDesc = DD_Surface_GetSurfaceDesc;
    ddSurfaceCallbacks.Initialize = DD_Surface_Initialize;
    ddSurfaceCallbacks.IsLost = DD_Surface_IsLost;
    ddSurfaceCallbacks.Lock = DD_Surface_Lock;
    ddSurfaceCallbacks.ReleaseDC = DD_Surface_ReleaseDC;
    ddSurfaceCallbacks.Restore = DD_Surface_Restore;
    ddSurfaceCallbacks.SetClipper = DD_Surface_SetClipper;
    ddSurfaceCallbacks.SetColorKey = DD_Surface_SetColorKey;
    ddSurfaceCallbacks.SetOverlayPosition = DD_Surface_SetOverlayPosition;
    ddSurfaceCallbacks.SetPalette = DD_Surface_SetPalette;
    ddSurfaceCallbacks.Unlock = DD_Surface_Unlock;
    ddSurfaceCallbacks.UpdateOverlay = DD_Surface_UpdateOverlay;
    ddSurfaceCallbacks.UpdateOverlayDisplay = DD_Surface_UpdateOverlayDisplay;
    ddSurfaceCallbacks.UpdateOverlayZOrder = DD_Surface_UpdateOverlayZOrder;

    /*
     * DirectDraw Surface object methods Ver 2.0
     */
    ddSurface2Callbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurface2Callbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurface2Callbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurface2Callbacks.AddAttachedSurface = (LPVOID)DD_Surface_AddAttachedSurface;
    ddSurface2Callbacks.AddOverlayDirtyRect = (LPVOID)DD_Surface_AddOverlayDirtyRect;
    ddSurface2Callbacks.Blt = (LPVOID)DD_Surface_Blt;
    ddSurface2Callbacks.BltBatch = (LPVOID)DD_Surface_BltBatch;
    ddSurface2Callbacks.BltFast = (LPVOID)DD_Surface_BltFast;
    ddSurface2Callbacks.DeleteAttachedSurface = (LPVOID)DD_Surface_DeleteAttachedSurfaces;
    ddSurface2Callbacks.EnumAttachedSurfaces = (LPVOID)DD_Surface_EnumAttachedSurfaces;
    ddSurface2Callbacks.EnumOverlayZOrders = (LPVOID)DD_Surface_EnumOverlayZOrders;
    ddSurface2Callbacks.Flip = (LPVOID)DD_Surface_Flip;
    ddSurface2Callbacks.GetAttachedSurface = (LPVOID)DD_Surface_GetAttachedSurface;
    ddSurface2Callbacks.GetBltStatus = (LPVOID)DD_Surface_GetBltStatus;
    ddSurface2Callbacks.GetCaps = (LPVOID)DD_Surface_GetCaps;
    ddSurface2Callbacks.GetClipper = (LPVOID)DD_Surface_GetClipper;
    ddSurface2Callbacks.GetColorKey = (LPVOID)DD_Surface_GetColorKey;
    ddSurface2Callbacks.GetDC = (LPVOID)DD_Surface_GetDC;
    ddSurface2Callbacks.GetDDInterface = (LPVOID)DD_Surface_GetDDInterface;
    ddSurface2Callbacks.GetFlipStatus = (LPVOID)DD_Surface_GetFlipStatus;
    ddSurface2Callbacks.GetOverlayPosition = (LPVOID)DD_Surface_GetOverlayPosition;
    ddSurface2Callbacks.GetPalette = (LPVOID)DD_Surface_GetPalette;
    ddSurface2Callbacks.GetPixelFormat = (LPVOID)DD_Surface_GetPixelFormat;
    ddSurface2Callbacks.GetSurfaceDesc = (LPVOID)DD_Surface_GetSurfaceDesc;
    ddSurface2Callbacks.Initialize = (LPVOID)DD_Surface_Initialize;
    ddSurface2Callbacks.IsLost = (LPVOID)DD_Surface_IsLost;
    ddSurface2Callbacks.Lock = (LPVOID)DD_Surface_Lock;
    ddSurface2Callbacks.ReleaseDC = (LPVOID)DD_Surface_ReleaseDC;
    ddSurface2Callbacks.Restore = (LPVOID)DD_Surface_Restore;
    ddSurface2Callbacks.SetClipper = (LPVOID)DD_Surface_SetClipper;
    ddSurface2Callbacks.SetColorKey = (LPVOID)DD_Surface_SetColorKey;
    ddSurface2Callbacks.SetOverlayPosition = (LPVOID)DD_Surface_SetOverlayPosition;
    ddSurface2Callbacks.SetPalette = (LPVOID)DD_Surface_SetPalette;
    ddSurface2Callbacks.Unlock = (LPVOID)DD_Surface_Unlock;
    ddSurface2Callbacks.UpdateOverlay = (LPVOID)DD_Surface_UpdateOverlay;
    ddSurface2Callbacks.UpdateOverlayDisplay = (LPVOID)DD_Surface_UpdateOverlayDisplay;
    ddSurface2Callbacks.UpdateOverlayZOrder = (LPVOID)DD_Surface_UpdateOverlayZOrder;
    ddSurface2Callbacks.PageLock = (LPVOID)DD_Surface_PageLock;
    ddSurface2Callbacks.PageUnlock = (LPVOID)DD_Surface_PageUnlock;

    /*
     * DirectDraw Surface object methods Ver 3.0
     */
    ddSurface3Callbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurface3Callbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurface3Callbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurface3Callbacks.AddAttachedSurface = (LPVOID)DD_Surface_AddAttachedSurface;
    ddSurface3Callbacks.AddOverlayDirtyRect = (LPVOID)DD_Surface_AddOverlayDirtyRect;
    ddSurface3Callbacks.Blt = (LPVOID)DD_Surface_Blt;
    ddSurface3Callbacks.BltBatch = (LPVOID)DD_Surface_BltBatch;
    ddSurface3Callbacks.BltFast = (LPVOID)DD_Surface_BltFast;
    ddSurface3Callbacks.DeleteAttachedSurface = (LPVOID)DD_Surface_DeleteAttachedSurfaces;
    ddSurface3Callbacks.EnumAttachedSurfaces = (LPVOID)DD_Surface_EnumAttachedSurfaces;
    ddSurface3Callbacks.EnumOverlayZOrders = (LPVOID)DD_Surface_EnumOverlayZOrders;
    ddSurface3Callbacks.Flip = (LPVOID)DD_Surface_Flip;
    ddSurface3Callbacks.GetAttachedSurface = (LPVOID)DD_Surface_GetAttachedSurface;
    ddSurface3Callbacks.GetBltStatus = (LPVOID)DD_Surface_GetBltStatus;
    ddSurface3Callbacks.GetCaps = (LPVOID)DD_Surface_GetCaps;
    ddSurface3Callbacks.GetClipper = (LPVOID)DD_Surface_GetClipper;
    ddSurface3Callbacks.GetColorKey = (LPVOID)DD_Surface_GetColorKey;
    ddSurface3Callbacks.GetDC = (LPVOID)DD_Surface_GetDC;
    ddSurface3Callbacks.GetDDInterface = (LPVOID)DD_Surface_GetDDInterface;
    ddSurface3Callbacks.GetFlipStatus = (LPVOID)DD_Surface_GetFlipStatus;
    ddSurface3Callbacks.GetOverlayPosition = (LPVOID)DD_Surface_GetOverlayPosition;
    ddSurface3Callbacks.GetPalette = (LPVOID)DD_Surface_GetPalette;
    ddSurface3Callbacks.GetPixelFormat = (LPVOID)DD_Surface_GetPixelFormat;
    ddSurface3Callbacks.GetSurfaceDesc = (LPVOID)DD_Surface_GetSurfaceDesc;
    ddSurface3Callbacks.Initialize = (LPVOID)DD_Surface_Initialize;
    ddSurface3Callbacks.IsLost = (LPVOID)DD_Surface_IsLost;
    ddSurface3Callbacks.Lock = (LPVOID)DD_Surface_Lock;
    ddSurface3Callbacks.ReleaseDC = (LPVOID)DD_Surface_ReleaseDC;
    ddSurface3Callbacks.Restore = (LPVOID)DD_Surface_Restore;
    ddSurface3Callbacks.SetClipper = (LPVOID)DD_Surface_SetClipper;
    ddSurface3Callbacks.SetColorKey = (LPVOID)DD_Surface_SetColorKey;
    ddSurface3Callbacks.SetOverlayPosition = (LPVOID)DD_Surface_SetOverlayPosition;
    ddSurface3Callbacks.SetPalette = (LPVOID)DD_Surface_SetPalette;
    ddSurface3Callbacks.Unlock = (LPVOID)DD_Surface_Unlock;
    ddSurface3Callbacks.UpdateOverlay = (LPVOID)DD_Surface_UpdateOverlay;
    ddSurface3Callbacks.UpdateOverlayDisplay = (LPVOID)DD_Surface_UpdateOverlayDisplay;
    ddSurface3Callbacks.UpdateOverlayZOrder = (LPVOID)DD_Surface_UpdateOverlayZOrder;
    ddSurface3Callbacks.PageLock = (LPVOID)DD_Surface_PageLock;
    ddSurface3Callbacks.PageUnlock = (LPVOID)DD_Surface_PageUnlock;
    ddSurface3Callbacks.SetSurfaceDesc = (LPVOID)DD_Surface_SetSurfaceDesc;

    /*
     * DirectDraw Surface object methods Ver 4.0
     */
    ddSurface4Callbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurface4Callbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurface4Callbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurface4Callbacks.AddAttachedSurface = (LPVOID)DD_Surface_AddAttachedSurface;
    ddSurface4Callbacks.AddOverlayDirtyRect = (LPVOID)DD_Surface_AddOverlayDirtyRect;
    ddSurface4Callbacks.Blt = (LPVOID)DD_Surface_Blt;
    ddSurface4Callbacks.BltBatch = (LPVOID)DD_Surface_BltBatch;
    ddSurface4Callbacks.BltFast = (LPVOID)DD_Surface_BltFast;
    ddSurface4Callbacks.ChangeUniquenessValue = (LPVOID) DD_Surface_ChangeUniquenessValue;
    ddSurface4Callbacks.DeleteAttachedSurface = (LPVOID)DD_Surface_DeleteAttachedSurfaces;
    ddSurface4Callbacks.EnumAttachedSurfaces = (LPVOID)DD_Surface_EnumAttachedSurfaces;
    ddSurface4Callbacks.EnumOverlayZOrders = (LPVOID)DD_Surface_EnumOverlayZOrders;
    ddSurface4Callbacks.Flip = (LPVOID)DD_Surface_Flip;
    ddSurface4Callbacks.GetAttachedSurface = (LPVOID)DD_Surface_GetAttachedSurface4;
    ddSurface4Callbacks.GetBltStatus = (LPVOID)DD_Surface_GetBltStatus;
    ddSurface4Callbacks.GetCaps = (LPVOID)DD_Surface_GetCaps4;
    ddSurface4Callbacks.GetClipper = (LPVOID)DD_Surface_GetClipper;
    ddSurface4Callbacks.GetColorKey = (LPVOID)DD_Surface_GetColorKey;
    ddSurface4Callbacks.GetDC = (LPVOID)DD_Surface_GetDC;
    ddSurface4Callbacks.GetDDInterface = (LPVOID)DD_Surface_GetDDInterface;
    ddSurface4Callbacks.GetFlipStatus = (LPVOID)DD_Surface_GetFlipStatus;
    ddSurface4Callbacks.GetOverlayPosition = (LPVOID)DD_Surface_GetOverlayPosition;
    ddSurface4Callbacks.GetPalette = (LPVOID)DD_Surface_GetPalette;
    ddSurface4Callbacks.GetPixelFormat = (LPVOID)DD_Surface_GetPixelFormat;
    ddSurface4Callbacks.GetSurfaceDesc = (LPVOID)DD_Surface_GetSurfaceDesc4;
    ddSurface4Callbacks.GetUniquenessValue = (LPVOID)DD_Surface_GetUniquenessValue;
    ddSurface4Callbacks.Initialize = (LPVOID)DD_Surface_Initialize;
    ddSurface4Callbacks.IsLost = (LPVOID)DD_Surface_IsLost;
    ddSurface4Callbacks.Lock = (LPVOID)DD_Surface_Lock;
    ddSurface4Callbacks.ReleaseDC = (LPVOID)DD_Surface_ReleaseDC;
    ddSurface4Callbacks.Restore = (LPVOID)DD_Surface_Restore;
    ddSurface4Callbacks.SetClipper = (LPVOID)DD_Surface_SetClipper;
    ddSurface4Callbacks.SetColorKey = (LPVOID)DD_Surface_SetColorKey;
    ddSurface4Callbacks.SetOverlayPosition = (LPVOID)DD_Surface_SetOverlayPosition;
    ddSurface4Callbacks.SetPalette = (LPVOID)DD_Surface_SetPalette;
    ddSurface4Callbacks.Unlock = (LPVOID)DD_Surface_Unlock4;
    ddSurface4Callbacks.UpdateOverlay = (LPVOID)DD_Surface_UpdateOverlay;
    ddSurface4Callbacks.UpdateOverlayDisplay = (LPVOID)DD_Surface_UpdateOverlayDisplay;
    ddSurface4Callbacks.UpdateOverlayZOrder = (LPVOID)DD_Surface_UpdateOverlayZOrder;
    ddSurface4Callbacks.PageLock = (LPVOID)DD_Surface_PageLock;
    ddSurface4Callbacks.PageUnlock = (LPVOID)DD_Surface_PageUnlock;
    ddSurface4Callbacks.SetSurfaceDesc = (LPVOID)DD_Surface_SetSurfaceDesc4;
    ddSurface4Callbacks.SetPrivateData = (LPVOID)DD_Surface_SetPrivateData;
    ddSurface4Callbacks.GetPrivateData = (LPVOID)DD_Surface_GetPrivateData;
    ddSurface4Callbacks.FreePrivateData = (LPVOID)DD_Surface_FreePrivateData;

    /*
     * DirectDraw Surface object methods Ver 5.0
     */
    ddSurface7Callbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurface7Callbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurface7Callbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurface7Callbacks.AddAttachedSurface = (LPVOID)DD_Surface_AddAttachedSurface;
    ddSurface7Callbacks.AddOverlayDirtyRect = (LPVOID)DD_Surface_AddOverlayDirtyRect;
    ddSurface7Callbacks.Blt = (LPVOID)DD_Surface_Blt;
    ddSurface7Callbacks.BltBatch = (LPVOID)DD_Surface_BltBatch;
    ddSurface7Callbacks.BltFast = (LPVOID)DD_Surface_BltFast;
    ddSurface7Callbacks.ChangeUniquenessValue = (LPVOID) DD_Surface_ChangeUniquenessValue;
    ddSurface7Callbacks.DeleteAttachedSurface = (LPVOID)DD_Surface_DeleteAttachedSurfaces;
    ddSurface7Callbacks.EnumAttachedSurfaces = (LPVOID)DD_Surface_EnumAttachedSurfaces;
    ddSurface7Callbacks.EnumOverlayZOrders = (LPVOID)DD_Surface_EnumOverlayZOrders;
    ddSurface7Callbacks.Flip = (LPVOID)DD_Surface_Flip;
    ddSurface7Callbacks.GetAttachedSurface = (LPVOID)DD_Surface_GetAttachedSurface7;
    ddSurface7Callbacks.GetBltStatus = (LPVOID)DD_Surface_GetBltStatus;
    ddSurface7Callbacks.GetCaps = (LPVOID)DD_Surface_GetCaps4;
    ddSurface7Callbacks.GetClipper = (LPVOID)DD_Surface_GetClipper;
    ddSurface7Callbacks.GetColorKey = (LPVOID)DD_Surface_GetColorKey;
    ddSurface7Callbacks.GetDC = (LPVOID)DD_Surface_GetDC;
    ddSurface7Callbacks.GetDDInterface = (LPVOID)DD_Surface_GetDDInterface;
    ddSurface7Callbacks.GetFlipStatus = (LPVOID)DD_Surface_GetFlipStatus;
    ddSurface7Callbacks.GetOverlayPosition = (LPVOID)DD_Surface_GetOverlayPosition;
    ddSurface7Callbacks.GetPalette = (LPVOID)DD_Surface_GetPalette;
    ddSurface7Callbacks.GetPixelFormat = (LPVOID)DD_Surface_GetPixelFormat;
    ddSurface7Callbacks.GetSurfaceDesc = (LPVOID)DD_Surface_GetSurfaceDesc4;
    ddSurface7Callbacks.GetUniquenessValue = (LPVOID)DD_Surface_GetUniquenessValue;
    ddSurface7Callbacks.Initialize = (LPVOID)DD_Surface_Initialize;
    ddSurface7Callbacks.IsLost = (LPVOID)DD_Surface_IsLost;
    ddSurface7Callbacks.Lock = (LPVOID)DD_Surface_Lock;
    ddSurface7Callbacks.ReleaseDC = (LPVOID)DD_Surface_ReleaseDC;
    ddSurface7Callbacks.Restore = (LPVOID)DD_Surface_Restore;
    ddSurface7Callbacks.SetClipper = (LPVOID)DD_Surface_SetClipper;
    ddSurface7Callbacks.SetColorKey = (LPVOID)DD_Surface_SetColorKey;
    ddSurface7Callbacks.SetOverlayPosition = (LPVOID)DD_Surface_SetOverlayPosition;
    ddSurface7Callbacks.SetPalette = (LPVOID)DD_Surface_SetPalette;
    ddSurface7Callbacks.Unlock = (LPVOID)DD_Surface_Unlock4;
    ddSurface7Callbacks.UpdateOverlay = (LPVOID)DD_Surface_UpdateOverlay;
    ddSurface7Callbacks.UpdateOverlayDisplay = (LPVOID)DD_Surface_UpdateOverlayDisplay;
    ddSurface7Callbacks.UpdateOverlayZOrder = (LPVOID)DD_Surface_UpdateOverlayZOrder;
    ddSurface7Callbacks.PageLock = (LPVOID)DD_Surface_PageLock;
    ddSurface7Callbacks.PageUnlock = (LPVOID)DD_Surface_PageUnlock;
    ddSurface7Callbacks.SetSurfaceDesc = (LPVOID)DD_Surface_SetSurfaceDesc4;
    ddSurface7Callbacks.SetPrivateData = (LPVOID)DD_Surface_SetPrivateData;
    ddSurface7Callbacks.GetPrivateData = (LPVOID)DD_Surface_GetPrivateData;
    ddSurface7Callbacks.FreePrivateData = (LPVOID)DD_Surface_FreePrivateData;
#ifdef POSTPONED2
    ddSurface7Callbacks.AlphaBlt = (LPVOID)DD_Surface_AlphaBlt;
    ddSurface7Callbacks.SetSpriteDisplayList = (LPVOID)DD_Surface_SetSpriteDisplayList;
    ddSurface7Callbacks.Resize = (LPVOID)DD_Surface_Resize;
#endif //POSTPONED2
    ddSurface7Callbacks.SetPriority = (LPVOID)DD_Surface_SetPriority;
    ddSurface7Callbacks.GetPriority = (LPVOID)DD_Surface_GetPriority;
    ddSurface7Callbacks.SetLOD = (LPVOID)DD_Surface_SetLOD;
    ddSurface7Callbacks.GetLOD = (LPVOID)DD_Surface_GetLOD;

    /*
     * DirectDraw Palette object methods V1.0
     */
    ddPaletteCallbacks.QueryInterface = DD_Palette_QueryInterface;
    ddPaletteCallbacks.AddRef = DD_Palette_AddRef;
    ddPaletteCallbacks.Release = DD_Palette_Release;
    ddPaletteCallbacks.GetCaps = DD_Palette_GetCaps;
    ddPaletteCallbacks.GetEntries = DD_Palette_GetEntries;
    ddPaletteCallbacks.Initialize = DD_Palette_Initialize;
    ddPaletteCallbacks.SetEntries = DD_Palette_SetEntries;

    /*
     * DirectDraw Clipper object methods V1.0
     */
    ddClipperCallbacks.QueryInterface = DD_Clipper_QueryInterface;
    ddClipperCallbacks.AddRef = DD_Clipper_AddRef;
    ddClipperCallbacks.Release = DD_Clipper_Release;
    ddClipperCallbacks.GetClipList = DD_Clipper_GetClipList;
    ddClipperCallbacks.GetHWnd = DD_Clipper_GetHWnd;
    ddClipperCallbacks.Initialize = DD_Clipper_Initialize;
    ddClipperCallbacks.IsClipListChanged = DD_Clipper_IsClipListChanged;
    ddClipperCallbacks.SetClipList = DD_Clipper_SetClipList;
    ddClipperCallbacks.SetHWnd = DD_Clipper_SetHWnd;

    /*
     * DirectDraw "uninitialied" Clipper object methods V1.0
     */
#ifdef WINNT
    ddUninitClipperCallbacks.QueryInterface = (LPVOID)DD_UnInitedClipperQueryInterface;
#else
    ddUninitClipperCallbacks.QueryInterface = (LPVOID)DD_Uninitialized3Arg;
#endif
    ddUninitClipperCallbacks.AddRef = (LPVOID)DD_Clipper_AddRef;
    ddUninitClipperCallbacks.Release = (LPVOID)DD_Clipper_Release;
    ddUninitClipperCallbacks.GetClipList = (LPVOID)DD_Uninitialized4Arg;
    ddUninitClipperCallbacks.GetHWnd = (LPVOID)DD_Uninitialized2Arg;
    ddUninitClipperCallbacks.Initialize = DD_Clipper_Initialize;
    ddUninitClipperCallbacks.IsClipListChanged = (LPVOID)DD_Uninitialized2Arg;
    ddUninitClipperCallbacks.SetClipList = (LPVOID)DD_Uninitialized3Arg;
    ddUninitClipperCallbacks.SetHWnd = (LPVOID)DD_Uninitialized3Arg;

#ifdef STREAMING
    ddSurfaceStreamingCallbacks.QueryInterface = DD_Surface_QueryInterface;
    ddSurfaceStreamingCallbacks.AddRef = DD_Surface_AddRef;
    ddSurfaceStreamingCallbacks.Release = DD_Surface_Release;
    ddSurfaceStreamingCallbacks.Lock = DD_SurfaceStreaming_Lock;
    ddSurfaceStreamingCallbacks.SetNotificationCallback = DD_SurfaceStreaming_SetNotificationCallback;
    ddSurfaceStreamingCallbacks.Unlock = DD_SurfaceStreaming_Unlock;
#endif

#ifdef COMPOSITION
    ddSurfaceCompositionCallbacks.QueryInterface = DD_Surface_QueryInterface;
    ddSurfaceCompositionCallbacks.AddRef = DD_Surface_AddRef;
    ddSurfaceCompositionCallbacks.Release = DD_Surface_Release;
    ddSurfaceCompositionCallbacks.AddSurfaceDependency = DD_SurfaceComposition_AddSurfaceDependency;
    ddSurfaceCompositionCallbacks.Compose = DD_SurfaceComposition_Compose;
    ddSurfaceCompositionCallbacks.DeleteSurfaceDependency = DD_SurfaceComposition_DeleteSurfaceDependency;
    ddSurfaceCompositionCallbacks.DestLock = DD_SurfaceComposition_DestLock;
    ddSurfaceCompositionCallbacks.DestUnlock = DD_SurfaceComposition_DestUnlock;
    ddSurfaceCompositionCallbacks.EnumSurfaceDependencies = DD_SurfaceComposition_EnumSurfaceDependencies;
    ddSurfaceCompositionCallbacks.GetCompositionOrder = DD_SurfaceComposition_GetCompositionOrder;
    ddSurfaceCompositionCallbacks.SetCompositionOrder = DD_SurfaceComposition_SetCompositionOrder;
#endif

    /*
     * DirectDrawVideoPort object methods Ver 1.0
     */
#ifdef POSTPONED
    ddVideoPortContainerCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    ddVideoPortContainerCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    ddVideoPortContainerCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    ddVideoPortContainerCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddVideoPortContainerCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddVideoPortContainerCallbacks.Release = (LPVOID)DD_Release;
#endif
    ddVideoPortContainerCallbacks.CreateVideoPort = DDVPC_CreateVideoPort;
    ddVideoPortContainerCallbacks.EnumVideoPorts = DDVPC_EnumVideoPorts;
    ddVideoPortContainerCallbacks.GetVideoPortConnectInfo = DDVPC_GetVideoPortConnectInfo;
    ddVideoPortContainerCallbacks.QueryVideoPortStatus = DDVPC_QueryVideoPortStatus;

    /*
     * DirectDrawVideoPortStream object methods Ver 1.0
     */
    ddVideoPortCallbacks.QueryInterface = (LPVOID)DD_VP_QueryInterface;
    ddVideoPortCallbacks.AddRef = DD_VP_AddRef;
    ddVideoPortCallbacks.Release = DD_VP_Release;
    ddVideoPortCallbacks.SetTargetSurface = DD_VP_SetTargetSurface;
    ddVideoPortCallbacks.Flip = DD_VP_Flip;
    ddVideoPortCallbacks.GetBandwidthInfo = DD_VP_GetBandwidth;
    ddVideoPortCallbacks.GetColorControls = DD_VP_GetColorControls;
    ddVideoPortCallbacks.GetInputFormats = DD_VP_GetInputFormats;
    ddVideoPortCallbacks.GetOutputFormats = DD_VP_GetOutputFormats;
    ddVideoPortCallbacks.GetFieldPolarity = DD_VP_GetField;
    ddVideoPortCallbacks.GetVideoLine = DD_VP_GetLine;
    ddVideoPortCallbacks.GetVideoSignalStatus = DD_VP_GetSignalStatus;
    ddVideoPortCallbacks.StartVideo = DD_VP_StartVideo;
    ddVideoPortCallbacks.StopVideo = DD_VP_StopVideo;
    ddVideoPortCallbacks.UpdateVideo = DD_VP_UpdateVideo;
    ddVideoPortCallbacks.WaitForSync = DD_VP_WaitForSync;
    ddVideoPortCallbacks.SetColorControls = DD_VP_SetColorControls;

#ifdef WINNT
    /*
     * DirectDrawVideoPortNotify object methods Ver 1.0
     */
    ddVideoPortNotifyCallbacks.QueryInterface = (LPVOID)DD_VP_QueryInterface;
    ddVideoPortNotifyCallbacks.AddRef = (LPVOID)DD_VP_AddRef;
    ddVideoPortNotifyCallbacks.Release = (LPVOID)DD_VP_Release;
    ddVideoPortNotifyCallbacks.AcquireNotification = DD_VP_Notify_AcquireNotification;
    ddVideoPortNotifyCallbacks.ReleaseNotification = DD_VP_Notify_ReleaseNotification;
#endif

    /*
     * DirectDrawColorControl object methods Ver 1.0
     */
    ddColorControlCallbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddColorControlCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddColorControlCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddColorControlCallbacks.GetColorControls = DD_Color_GetColorControls;
    ddColorControlCallbacks.SetColorControls = DD_Color_SetColorControls;

    /*
     * DirectDrawKernel interface
     */
#ifdef POSTPONED
    ddKernelCallbacks.QueryInterface = (LPVOID)DD_DelegatingQueryInterface;
    ddKernelCallbacks.AddRef = (LPVOID)DD_DelegatingAddRef;
    ddKernelCallbacks.Release = (LPVOID)DD_DelegatingRelease;
#else
    ddKernelCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddKernelCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddKernelCallbacks.Release = (LPVOID)DD_Release;
#endif
    ddKernelCallbacks.GetCaps = DD_Kernel_GetCaps;
    ddKernelCallbacks.GetKernelHandle = DD_Kernel_GetKernelHandle;
    ddKernelCallbacks.ReleaseKernelHandle = DD_Kernel_ReleaseKernelHandle;

    /*
     * DirectDrawSurfaceKernel interface
     */
    ddSurfaceKernelCallbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddSurfaceKernelCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurfaceKernelCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurfaceKernelCallbacks.GetKernelHandle = DD_SurfaceKernel_GetKernelHandle;
    ddSurfaceKernelCallbacks.ReleaseKernelHandle = DD_SurfaceKernel_ReleaseKernelHandle;

#ifdef POSTPONED
    /*
     * DirectDraw Palette object methods V2.0
     */
    ddPalette2Callbacks.QueryInterface = (LPVOID) DD_Palette_QueryInterface;
    ddPalette2Callbacks.AddRef = (LPVOID) DD_Palette_AddRef;
    ddPalette2Callbacks.Release = (LPVOID) DD_Palette_Release;
    ddPalette2Callbacks.ChangeUniquenessValue = (LPVOID) DD_Palette_ChangeUniquenessValue;
    ddPalette2Callbacks.GetCaps = (LPVOID) DD_Palette_GetCaps;
    ddPalette2Callbacks.GetEntries = (LPVOID) DD_Palette_GetEntries;
    ddPalette2Callbacks.Initialize = (LPVOID) DD_Palette_Initialize;
    ddPalette2Callbacks.SetEntries = (LPVOID) DD_Palette_SetEntries;
    ddPalette2Callbacks.SetPrivateData = (LPVOID) DD_Palette_SetPrivateData;
    ddPalette2Callbacks.GetPrivateData = (LPVOID) DD_Palette_GetPrivateData;
    ddPalette2Callbacks.FreePrivateData = (LPVOID) DD_Palette_FreePrivateData;
    ddPalette2Callbacks.GetUniquenessValue = (LPVOID) DD_Palette_GetUniquenessValue;
    ddPalette2Callbacks.IsEqual = (LPVOID) DD_Palette_IsEqual;

    /*
     * DirectDrawFactory2 callbacks
     */
    ddFactory2Callbacks.QueryInterface = DDFac2_QueryInterface;
    ddFactory2Callbacks.AddRef = DDFac2_AddRef;
    ddFactory2Callbacks.Release = DDFac2_Release;
    ddFactory2Callbacks.CreateDirectDraw = (LPVOID)DDFac2_CreateDirectDraw;
    ddFactory2Callbacks.DirectDrawEnumerate = (LPVOID)DDFac2_DirectDrawEnumerate;

    /*
     * Surface IPersist interface
     */
    ddSurfacePersistCallbacks.QueryInterface = (LPVOID) DD_Surface_QueryInterface;
    ddSurfacePersistCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurfacePersistCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurfacePersistCallbacks.GetClassID = (LPVOID) DD_Surface_Persist_GetClassID;
    /*
     * Surface IPersistStream interface
     */
    ddSurfacePersistStreamCallbacks.QueryInterface = (LPVOID) DD_Surface_QueryInterface;
    ddSurfacePersistStreamCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddSurfacePersistStreamCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddSurfacePersistStreamCallbacks.GetClassID = (LPVOID) DD_Surface_Persist_GetClassID;
    ddSurfacePersistStreamCallbacks.IsDirty =  (LPVOID) DD_Surface_PStream_IsDirty;
    ddSurfacePersistStreamCallbacks.Load = (LPVOID) DD_Surface_PStream_Load;
    ddSurfacePersistStreamCallbacks.Save = (LPVOID) DD_Surface_PStream_Save;
    ddSurfacePersistStreamCallbacks.GetSizeMax = (LPVOID) DD_PStream_GetSizeMax;

    /*
     * Palette IPersist interface
     */
    ddPalettePersistCallbacks.QueryInterface = (LPVOID) DD_Palette_QueryInterface;
    ddPalettePersistCallbacks.AddRef = (LPVOID)DD_Palette_AddRef;
    ddPalettePersistCallbacks.Release = (LPVOID)DD_Palette_Release;
    ddPalettePersistCallbacks.GetClassID = (LPVOID) DD_Palette_Persist_GetClassID;
    /*
     * Palette IPersistStream interface
     */
    ddPalettePersistStreamCallbacks.QueryInterface = (LPVOID) DD_Palette_QueryInterface;
    ddPalettePersistStreamCallbacks.AddRef = (LPVOID)DD_Palette_AddRef;
    ddPalettePersistStreamCallbacks.Release = (LPVOID)DD_Palette_Release;
    ddPalettePersistStreamCallbacks.GetClassID = (LPVOID) DD_Palette_Persist_GetClassID;
    ddPalettePersistStreamCallbacks.IsDirty =  (LPVOID) DD_Palette_PStream_IsDirty;
    ddPalettePersistStreamCallbacks.Load = (LPVOID) DD_Palette_PStream_Load;
    ddPalettePersistStreamCallbacks.Save = (LPVOID) DD_Palette_PStream_Save;
    ddPalettePersistStreamCallbacks.GetSizeMax = (LPVOID) DD_PStream_GetSizeMax;

    /*
     * DirectDraw OptSurface object methods
     */
    ddOptSurfaceCallbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddOptSurfaceCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddOptSurfaceCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddOptSurfaceCallbacks.GetOptSurfaceDesc = (LPVOID)DD_OptSurface_GetOptSurfaceDesc;
    ddOptSurfaceCallbacks.LoadUnoptimizedSurf = (LPVOID)DD_OptSurface_LoadUnoptimizedSurf;
    ddOptSurfaceCallbacks.CopyOptimizedSurf = (LPVOID)DD_OptSurface_CopyOptimizedSurf;
    ddOptSurfaceCallbacks.Unoptimize = (LPVOID)DD_OptSurface_Unoptimize;
#endif //POSTPONED
    /*
     * DDMotionCompContainer object methods Ver 1.0
     */
    ddMotionCompContainerCallbacks.QueryInterface = (LPVOID)DD_QueryInterface;
    ddMotionCompContainerCallbacks.AddRef = (LPVOID)DD_AddRef;
    ddMotionCompContainerCallbacks.Release = (LPVOID)DD_Release;
    ddMotionCompContainerCallbacks.CreateVideoAccelerator = DDMCC_CreateMotionComp;
    ddMotionCompContainerCallbacks.GetCompBufferInfo = DDMCC_GetCompBuffInfo;
    ddMotionCompContainerCallbacks.GetInternalMemInfo = DDMCC_GetInternalMoCompInfo;
    ddMotionCompContainerCallbacks.GetUncompFormatsSupported = DDMCC_GetUncompressedFormats;
    ddMotionCompContainerCallbacks.GetVideoAcceleratorGUIDs = DDMCC_GetMotionCompGUIDs;

    /*
     * DirectDrawMotionComp object methods Ver 1.0
     */
    ddMotionCompCallbacks.QueryInterface = (LPVOID)DD_MC_QueryInterface;
    ddMotionCompCallbacks.AddRef = (LPVOID)DD_MC_AddRef;
    ddMotionCompCallbacks.Release = (LPVOID)DD_MC_Release;
    ddMotionCompCallbacks.BeginFrame = DD_MC_BeginFrame;
    ddMotionCompCallbacks.EndFrame = DD_MC_EndFrame;
    ddMotionCompCallbacks.QueryRenderStatus = DD_MC_QueryRenderStatus;
    ddMotionCompCallbacks.Execute = DD_MC_RenderMacroBlocks;

    /*
     * DirectDrawColorControl object methods Ver 1.0
     */
    ddGammaControlCallbacks.QueryInterface = (LPVOID)DD_Surface_QueryInterface;
    ddGammaControlCallbacks.AddRef = (LPVOID)DD_Surface_AddRef;
    ddGammaControlCallbacks.Release = (LPVOID)DD_Surface_Release;
    ddGammaControlCallbacks.GetGammaRamp = DD_Gamma_GetGammaRamp;
    ddGammaControlCallbacks.SetGammaRamp = DD_Gamma_SetGammaRamp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddclip.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddclip.c
 *  Content:    DirectDraw clipper functions
 *
 *              NOTE:
 *              For functions that manipulate the winwatch list,
 *              we need to take the win16 lock after we take the directdraw
 *              lock.   The reason for this is that we can get an async
 *              call from the 16-bit side when a window is closed
 *              to release winwatch object.   Since the win16 lock is held
 *              when the callup occurs, this makes it safe to manipulate
 *              the structures.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   21-jun-95  craige  initial implementation
 *   23-jun-95  craige  connect with winwatch stuff
 *   25-jun-95  craige  minor bug fix; one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   02-jul-95  craige  commented out clipper notification stuff
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  craige  added Initialize
 *   11-jul-95  craige  fail aggregation calls
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock
 *   31-jul-95  craige  validate flags
 *   05-aug-95  craige  bug 260 - clip user defined rgn to screen
 *   09-dec-95  colinmc added execute buffer support
 *   15-dec-95  colinmc made clippers sharable across surfaces
 *   19-dec-95  kylej   added NT cliplist support
 *   02-jan-96  kylej   handle new interface structs.
 *   17-jan-96	kylej	fixed NT vis region bug
 *   22-feb-96  colinmc clippers no longer need to be associated with a
 *                      DirectDraw object - they can be created independently.
 *   03-mar-96  colinmc fixed problem with QueryInterface returning local
 *                      object rather than interface
 *   13-mar-96  colinmc added IID validation to QueryInterface.
 *   14-mar-96  colinmc added class factory support
 *   18-mar-96  colinmc Bug 13545: Independent clipper cleanup
 *   21-mar-96  colinmc Bug 13316: Unitialized interfaces
 *   09-apr-96  colinmc Bug 13991: Parameter validation on IsClipListChanged
 *   26-mar-96  jeffno  Watched HWNDs under NT
 *   20-sep-96	ketand  GetClipList optimization
 *   21-jan-96	ketand	Deleted unused WinWatch code. Fixed clipping for multi-mon.
 *   07-feb-96	ketand	bug5673: fix clipping when VisRgn is larger than ClientRect
 *   24-mar-97  jeffno  Optimized Surfaces
 *   05-nov-97 jvanaken Support for master sprite list in SetSpriteDisplayList
 *
 ***************************************************************************/

 #include "ddrawpr.h"

#ifdef WINNT
    #include "ddrawgdi.h"
#endif

// function in ddsprite.c to remove invalid clipper from master sprite list
extern void RemoveSpriteClipper(LPDDRAWI_DIRECTDRAW_GBL, LPDDRAWI_DDRAWCLIPPER_INT);

/*
 * GLOBAL NOTE: You will notice that these functions usually fetch the
 * DirectDraw global object pointer from the global clipper object during
 * parameter validation. You may wonder why this is given that clippers
 * are pretty much completely independent of drivers. Well, this is purely
 * for parameter validation purposes. We just want to ensure that we can
 * dereference the clipper global object - we could use any parameter.
 * So don't remove this code when you notice its not used. It serves
 * a purpose.
 * Probably should wrap this stuff up in a nice macro.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDraw::DD_UnInitedClipperQueryInterface"
/*
 * DD_UnInitedClipperQueryInterface
 */
HRESULT DDAPI DD_UnInitedClipperQueryInterface(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_UnInitedClipperQueryInterface");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF( 1, "Invalid clipper pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check guids
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawClipper) )
    {
	DD_Clipper_AddRef( lpDDClipper );
	*ppvObj = (LPVOID) this_int;
	LEAVE_DDRAW();
	return DD_OK;
    }
    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_UnInitedClipperQueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::QueryInterface"

/*
 * DD_Clipper_QueryInterface
 */
HRESULT DDAPI DD_Clipper_QueryInterface(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_QueryInterface");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF( 1, "Invalid clipper pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check guids
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawClipper) )
    {
	DD_Clipper_AddRef( lpDDClipper );
	*ppvObj = (LPVOID) this_int;
	LEAVE_DDRAW();
	return DD_OK;
    }
    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DD_Clipper_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::AddRef"

/*
 * DD_Clipper_AddRef
 */
DWORD DDAPI DD_Clipper_AddRef( LPDIRECTDRAWCLIPPER lpDDClipper )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    DWORD                       rcnt;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_AddRef");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;

	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * update clipper reference count
     */
    this->dwRefCnt++;
    this_lcl->dwLocalRefCnt++;
    this_int->dwIntRefCnt++;
    rcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;

    DPF( 5, "Clipper %08lx addrefed, refcnt = %ld", this, rcnt );

    LEAVE_DDRAW();
    return this_int->dwIntRefCnt;

} /* DD_Clipper_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::Release"

/*
 * RemoveClipperFromList
 *
 * Remove a clipper from its owning clipper list.
 *
 * The clipper can either be a member of a global clipper list
 * (if no DirectDraw object owns it) or the clipper list of its
 * owning DirectDraw driver object. If pdrv == NULL then the
 * clipper will be removed from the global clipper list. If
 * pdrv != NULL the clipper will be removed from the clipper
 * list of that driver object. It is an error if the clipper
 * is not on the appropriate clipper list.
 *
 * Returns TRUE if the clipper was succesfully removed
 * Returns FALSE if the clipper could not be found on the
 * appropriate clipper list
 */
static BOOL RemoveClipperFromList( LPDDRAWI_DIRECTDRAW_GBL pdrv,
			           LPDDRAWI_DDRAWCLIPPER_INT this_int )
{
    LPDDRAWI_DDRAWCLIPPER_INT curr_int;
    LPDDRAWI_DDRAWCLIPPER_INT last_int;

    curr_int = ( ( pdrv != NULL ) ? pdrv->clipperList : lpGlobalClipperList );
    last_int = NULL;
    while( curr_int != this_int )
    {
	last_int = curr_int;
	curr_int = curr_int->lpLink;
	if( curr_int == NULL )
	{
	    return FALSE;
	}
    }
    if( last_int == NULL )
    {
	if( pdrv != NULL )
	    pdrv->clipperList = pdrv->clipperList->lpLink;
	else
	    lpGlobalClipperList = lpGlobalClipperList->lpLink;
    }
    else
    {
	last_int->lpLink = curr_int->lpLink;
    }

    return TRUE;
}

/*
 * InternalClipperRelease
 *
 * Done with a clipper.   if no one else is using it, then we can free it.
 * Also called by ProcessClipperCleanup
 *
 * Assumes DirectDrawLock is taken
 */
ULONG DDAPI InternalClipperRelease( LPDDRAWI_DDRAWCLIPPER_INT this_int )
{
    DWORD			intrefcnt;
    DWORD                       lclrefcnt;
    DWORD                       gblrefcnt;
    LPDDRAWI_DDRAWCLIPPER_LCL	this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    BOOL                        root_object_deleted;
    BOOL                        do_free;
    IUnknown *                  pOwner = NULL;

    this_lcl = this_int->lpLcl;
    this = this_lcl->lpGbl;
    pdrv = this->lpDD;

    /*
     * decrement reference count to this clipper.  If it hits zero,
     * cleanup
     */
    this->dwRefCnt--;
    this_lcl->dwLocalRefCnt--;
    this_int->dwIntRefCnt--;
    gblrefcnt = this->dwRefCnt;
    lclrefcnt = this_lcl->dwLocalRefCnt & ~OBJECT_ISROOT;
    intrefcnt = this_int->dwIntRefCnt;
    root_object_deleted = FALSE;
    DPF( 5, "Clipper %08lx released, refcnt = %ld", this, lclrefcnt );

    /*
     * interface object deleted?
     */
    if( intrefcnt == 0 )
    {
	RemoveClipperFromList( pdrv, this_int );
#ifdef POSTPONED2
	/*
	 * If clipper interface object is referenced in master sprite
	 * list, delete those references from the list.
	 */
	if (this->dwFlags & DDRAWICLIP_INMASTERSPRITELIST)
	{
    	    RemoveSpriteClipper(pdrv, this_int);
	}
#endif //POSTPONED2

	/*
	 * Invalidate the interface and free it
	 */
	this_int->lpVtbl = NULL;
	this_int->lpLcl = NULL;

	MemFree( this_int );
    }


    /*
     * local object deleted?
     */
    if( lclrefcnt == 0 )
    {

        /*
         * If the ddraw interface which created this clipper caused the surface to addref the ddraw
         * object, then we need to release that addref now.
         */
        pOwner = this_lcl->pAddrefedThisOwner;

	/*
	 * see if we are deleting the root object
	 */
	if( this_lcl->dwLocalRefCnt & OBJECT_ISROOT )
	{
	    root_object_deleted = TRUE;
	}
    }

    /*
     * did the object get globally deleted?
     */
    do_free = FALSE;
    if( gblrefcnt == 0 )
    {
	do_free = TRUE;

	// Need to free the static clip list
	MemFree( this->lpStaticClipList );
	this->lpStaticClipList = NULL;

	/*
	 * if this was the final delete, but this wasn't the root object,
	 * then we need to delete the dangling root object
	 */
	if( !root_object_deleted )
	{
	    LPDDRAWI_DDRAWCLIPPER_LCL   rootx;

	    rootx = (LPVOID) (((LPSTR) this) - sizeof( DDRAWI_DDRAWCLIPPER_LCL ) );
	    MemFree( rootx );
	}
    }
    else if( lclrefcnt == 0 )
    {
	/*
	 * only remove the object if it wasn't the root.   if it
	 * was the root, we must leave it dangling until the last
	 * object referencing it goes away.
	 */
	if( !root_object_deleted )
	{
	    do_free = TRUE;
	}
    }

    /*
     * free the object if needed
     */
    if( do_free )
    {
	/*
	 * just in case someone comes back in with this pointer, set
	 * an invalid vtbl & data ptr.
	 */
	this_lcl->lpGbl = NULL;

	MemFree( this_lcl );
    }

    /*
     * If the clipper took a ref count on the ddraw object that created it,
     * release that ref now as the very last thing
     * We don't want to do this on ddhelp's thread cuz it really mucks up the
     * process cleanup stuff. 
     */
    if (pOwner && (dwHelperPid != GetCurrentProcessId()) )
    {
        pOwner->lpVtbl->Release(pOwner);
    }

    return intrefcnt;

} /* InternalClipperRelease */

/*
 * DD_Clipper_Release
 */
ULONG DDAPI DD_Clipper_Release( LPDIRECTDRAWCLIPPER lpDDClipper )
{
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    ULONG                       rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_Release");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALIDEX_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
	this_lcl = this_int->lpLcl;

	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    rc = InternalClipperRelease( this_int );
    LEAVE_DDRAW();
    return rc;

} /* DD_Clipper_Release */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::SetHwnd"
/*
 * DD_Clipper_SetHWnd
 */
HRESULT DDAPI DD_Clipper_SetHWnd(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		DWORD dwFlags,
		HWND hWnd )
{
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;


    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_SetHWnd");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( hWnd != NULL )
	{
	    if( !IsWindow( hWnd ) )
	    {
		DPF_ERR( "Invalid window handle" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    (HWND) this->hWnd = hWnd;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_SetHWnd */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper::GetHwnd"
/*
 * DD_Clipper_GetHWnd
 */
HRESULT DDAPI DD_Clipper_GetHWnd(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		HWND FAR *lphWnd )
{
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;

    /*
     * validate parms
     */
    TRY
    {
	ENTER_DDRAW();

	DPF(2,A,"ENTERAPI: DD_Clipper_GetHWnd");

	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_HWND_PTR( lphWnd ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	*lphWnd = (HWND) this->hWnd;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_GetHWnd */

#define SIZE_OF_A_CLIPLIST(lpRgn) \
        (sizeof(RGNDATAHEADER)+sizeof(RECTL)*lpRgn->rdh.nCount)

HRESULT InternalGetClipList(
    		LPDIRECTDRAWCLIPPER lpDDClipper,
		LPRECT lpRect,
		LPRGNDATA lpClipList,
		LPDWORD lpdwSize,
		LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    HRESULT	    ddrval = DD_OK;
    DWORD	    cbRealSize;
    HDC             hdc;
    HRGN            hrgn;
    RECT	    rectT;
#ifndef WIN95
    DWORD           cbSaveSize;
#endif

    this = ((LPDDRAWI_DDRAWCLIPPER_INT)(lpDDClipper))->lpLcl->lpGbl;

    // if no hwnd specified, then it is just a static cliplist
    if( this->hWnd == 0 )
    {
	if( this->lpStaticClipList == NULL )
	{
	    return DDERR_NOCLIPLIST;
	}
	cbRealSize = SIZE_OF_A_CLIPLIST( this->lpStaticClipList );
	if( lpClipList == NULL )
	{
	    *lpdwSize = cbRealSize;
	    return DD_OK;
	}
	if( *lpdwSize < cbRealSize )
	{
	    DPF_ERR( "Region size too small" );
	    *lpdwSize = cbRealSize;
	    return DDERR_REGIONTOOSMALL;
	}

	memcpy( lpClipList, this->lpStaticClipList, cbRealSize );
	ClipRgnToRect( lpRect, lpClipList );
	return DD_OK;
    }

    // Use an hwnd for the clipping
    #ifdef WIN95
    {
	hdc = GetDCEx( (HWND)this->hWnd, NULL, DCX_USESTYLE | DCX_CACHE );
	if( hdc == NULL )
	{
	    DPF_ERR( "GetDCEx failed" );
	    return DDERR_GENERIC;
	}

	hrgn = DD16_InquireVisRgn( hdc );
	if( hrgn == NULL )
	{
	    DPF_ERR( "InquireVisRgn failed" );
	    ReleaseDC( (HWND)this->hWnd, hdc );
	    return DDERR_GENERIC;
	}
    }
    #else
    {
        int APIENTRY GetRandomRgn( HDC hdc, HRGN hrgn, int iNum );
        int rc;

	hdc = GetDC( (HWND) this->hWnd );
	if( hdc == NULL )
	{
	    DPF_ERR( "GetDC failed" );
	    return DDERR_GENERIC;
	}

	// Create the appropriate Region object
	hrgn = CreateRectRgn( 0, 0, 0, 0 );
	if( hrgn == NULL )
	{
	    DPF_ERR( "CreateRectRgn failed" );
	    ReleaseDC( (HWND) this->hWnd, hdc );
	    return DDERR_GENERIC;
	}

	// Set the Region to the DC
	rc = GetRandomRgn( hdc, hrgn, 4 );
	if( rc == -1 )
	{
	    DPF_ERR( "GetRandomRgn failed" );
	    ReleaseDC( (HWND) this->hWnd, hdc );
	    DeleteObject( hrgn );
	    return DDERR_GENERIC;
	}
    }
    #endif

    // Client only asking for a size?
    if( lpClipList == NULL )
    {
	// Get the size
	*lpdwSize = GetRegionData( hrgn, 0, NULL );

	// Release allocations
	ReleaseDC( (HWND) this->hWnd, hdc );
	DeleteObject( hrgn );

	// Check if GetRegionData failed
	if( *lpdwSize == 0 )
	    return DDERR_GENERIC;
	return DD_OK;
    }

#ifndef WIN95
    // Store the size passed in, because GetRegionData may trash it.
    cbSaveSize = *lpdwSize;
#endif

    // Get the window's region's REGIONDATA
    cbRealSize = GetRegionData( hrgn, *lpdwSize, lpClipList );

#ifndef WIN95
    if (cbRealSize == 0)
    {
        cbRealSize = GetRegionData(hrgn, 0, NULL);
        if (cbSaveSize < cbRealSize)
        {
            ReleaseDC( (HWND)this->hWnd, hdc );
            DeleteObject( hrgn );

            *lpdwSize = cbRealSize;
            DPF(4, "size of clip region too small");
            return DDERR_REGIONTOOSMALL;
        }
    }
#endif

    ReleaseDC( (HWND)this->hWnd, hdc );
    DeleteObject( hrgn );

    if( cbRealSize == 0 )
    {
        DPF_ERR( "GetRegionData failed" );
	return DDERR_GENERIC;
    }

#ifdef WIN95
    // GetRegionData may have failed because the buffer
    // was too small
    if( *lpdwSize < cbRealSize )
    {
	DPF( 4, "size of clip region too small" );
	*lpdwSize = cbRealSize;
	return DDERR_REGIONTOOSMALL;
    }
#endif

    // Before we do anything more, we need to make sure
    // to clip the Rgn to ClientRect of the Window. Normally
    // this is not necessary; but InquireVisRgn might
    // tell us the vis region of the parent window if the window
    // was a dialog or other wnd that used CS_PARENTDC
    GetClientRect( (HWND) this->hWnd, &rectT );
    ClientToScreen( (HWND) this->hWnd, (LPPOINT)&rectT );
    ClientToScreen( (HWND) this->hWnd, ((LPPOINT)&rectT)+1 );
    ClipRgnToRect( &rectT, lpClipList );

    // lpDD may be NULL if the clipper was created independently
    if(	pdrv &&
	(pdrv->cMonitors > 1) &&
	(pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
    {
	// On multi-mon systems, the Desktop coordinates may be different
	// from the device coordinates. On the primary, they are the same however.
	// The lpRect passed in is in device coordinates; so we need to convert it
	// into desktop coordinates.
	UINT i;
	LPRECT prectClip;

	if( pdrv->rectDevice.top != 0 ||
	    pdrv->rectDevice.left != 0 )
	{
	    RECT rectT;
	    if( lpRect != NULL )
	    {
	        rectT.left = lpRect->left + pdrv->rectDevice.left;
	        rectT.right = lpRect->right + pdrv->rectDevice.left;
	        rectT.top = lpRect->top + pdrv->rectDevice.top;
	        rectT.bottom = lpRect->bottom + pdrv->rectDevice.top;
	    }
	    else
	    {
	        rectT = pdrv->rectDevice;
	    }

	    // Clip the cliplist to the target rect
	    ClipRgnToRect( &rectT, lpClipList );

	    // Clip the cliplist to the device's rect
	    ClipRgnToRect( &pdrv->rectDevice, lpClipList );

	    // Iterate over each rect in the region
	    for (   i = 0, prectClip = (LPRECT)lpClipList->Buffer;
		    i < lpClipList->rdh.nCount;
		    i++, prectClip++ )
	    {
		// Convert each Rect into Device coordinates
		prectClip->left -= pdrv->rectDevice.left;
		prectClip->right -= pdrv->rectDevice.left;
		prectClip->top -= pdrv->rectDevice.top;
		prectClip->bottom -= pdrv->rectDevice.top;
	    }
	}
	else
	{
	    // Clip the cliplist to the target rect
	    ClipRgnToRect( lpRect, lpClipList );

	    // Clip the cliplist to the device's rect
	    ClipRgnToRect( &pdrv->rectDesktop, lpClipList );
	}
    }
    else
    {
        ClipRgnToRect( lpRect, lpClipList );
    }

    return DD_OK;
}


/*
 * DD_Clipper_GetClipList
 */
HRESULT DDAPI DD_Clipper_GetClipList(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		LPRECT lpRect,
		LPRGNDATA lpClipList,
		LPDWORD lpdwSize )
{
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    DWORD                       size;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_GetClipList");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	if( !VALID_DWORD_PTR( lpdwSize ) )
	{
	    DPF_ERR( "Invalid size ptr" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( lpRect != NULL )
	{
	    if( !VALID_RECT_PTR( lpRect ) )
	    {
		DPF_ERR( "Invalid rectangle ptr" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    size = lpRect->left;
	}
	if( lpClipList != NULL )
	{
	    if( !VALID_RGNDATA_PTR( lpClipList, *lpdwSize ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDCLIPLIST;
	    }
	    // Touch the last address in the promised block to verify
	    // the memory is actually there.  Note that we are
	    // standing on our head here to prevent the optimizing
	    // compiler from helping us by removing this code.  This
	    // is done by the macro above, but we want it in the
	    // retail build, too.
	    {
		volatile BYTE *foo = ((BYTE*)lpClipList) + *lpdwSize - 1;
		BYTE bar = *foo;
	    }
	    lpClipList->rdh.nCount = 0;
	}

	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * go fetch the clip list
     */

    {
	HRESULT ddrval;

	#ifdef WIN16_SEPARATE
	    ENTER_WIN16LOCK();
	#endif

	ddrval = InternalGetClipList( lpDDClipper, lpRect, lpClipList, lpdwSize, pdrv );

	#ifdef WIN16_SEPARATE
	    LEAVE_WIN16LOCK();
	#endif

	LEAVE_DDRAW();
	return ddrval;
    }

} /* DD_Clipper_GetClipList */

/*
 * DD_Clipper_SetClipList
 */
HRESULT DDAPI DD_Clipper_SetClipList(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		LPRGNDATA lpClipList,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWCLIPPER_INT	this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPRGNDATA                   prd;
    DWORD                       size;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_SetClipList");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;

	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

	if( lpClipList != NULL )
	{
	    if( !VALID_RGNDATA_PTR( lpClipList, sizeof(RGNDATA) ) )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDCLIPLIST;
	    }

	    if( lpClipList->rdh.nCount <= 0 )
	    {
		LEAVE_DDRAW();
		return DDERR_INVALIDCLIPLIST;
	    }

	    if( this_lcl->lpDD_int == NULL || this_lcl->lpDD_int->lpVtbl != &ddCallbacks )
	    {
		if( (lpClipList->rdh.dwSize < sizeof(RGNDATAHEADER)) ||
		    (lpClipList->rdh.iType != RDH_RECTANGLES ) ||
		    IsBadReadPtr(lpClipList, SIZE_OF_A_CLIPLIST(lpClipList)) )
		{
		    LEAVE_DDRAW();
		    return DDERR_INVALIDCLIPLIST;
		}
	    }
	}

	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * can't set a clip list if there is an hwnd
     */
    if( this->hWnd != 0 )
    {
	DPF_ERR( "Can't set a clip list: hwnd set" );
	LEAVE_DDRAW();
	return DDERR_CLIPPERISUSINGHWND;
    }

    /*
     * if NULL, just delete old cliplist
     */
    if( lpClipList == NULL )
    {
	MemFree( this->lpStaticClipList );
	this->lpStaticClipList = NULL;
	LEAVE_DDRAW();
	return DD_OK;
    }

    /*
     * duplicate the user's region data
     */
    size = SIZE_OF_A_CLIPLIST(lpClipList);
    prd = MemAlloc( size );
    if( prd == NULL )
    {
	LEAVE_DDRAW();
	return DDERR_OUTOFMEMORY;
    }
    memcpy( prd, lpClipList, size );

    /*
     * save cliplist info
     */
    MemFree( this->lpStaticClipList );
    this->lpStaticClipList = prd;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_SetClipList */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper:IsClipListChanged"

/*
 * DD_Clipper_IsClipListChanged
 */
HRESULT DDAPI DD_Clipper_IsClipListChanged(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		BOOL FAR *lpbChanged )
{
    LPDDRAWI_DDRAWCLIPPER_INT	     this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL        this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL        this;
    volatile LPDDRAWI_DIRECTDRAW_GBL pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_IsClipListChanged");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	pdrv = this->lpDD;
	*lpbChanged = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    #pragma message( REMIND( "Do we want to just fail non-watched IsClipListChanged?" ))
    *lpbChanged = TRUE;
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_IsClipListChanged */


#undef DPF_MODNAME
#define DPF_MODNAME "GetClipper"

/*
 * DD_Surface_GetClipper
 *
 * Surface function: get the clipper associated with surface
 */
HRESULT DDAPI DD_Surface_GetClipper(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWCLIPPER FAR * lplpDDClipper)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetClipper");

    /*
     * validate parms
     */
    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;

	if( !VALID_PTR_PTR( lplpDDClipper ) )
	{
	    DPF_ERR( "Invalid clipper pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	*lplpDDClipper = NULL;
	pdrv = this->lpDD;

	if( this_lcl->lpSurfMore->lpDDIClipper == NULL )
	{
	    DPF_ERR( "No clipper associated with surface" );
	    LEAVE_DDRAW();
	    return DDERR_NOCLIPPERATTACHED;
	}
        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "It is an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    DD_Clipper_AddRef( (LPDIRECTDRAWCLIPPER) this_lcl->lpSurfMore->lpDDIClipper );
    *lplpDDClipper = (LPDIRECTDRAWCLIPPER) this_lcl->lpSurfMore->lpDDIClipper;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_GetClipper */

#undef DPF_MODNAME
#define DPF_MODNAME     "SetClipper"

/*
 * DD_Surface_SetClipper
 *
 * Surface function: set the clipper associated with surface
 */
HRESULT DDAPI DD_Surface_SetClipper(
		LPDIRECTDRAWSURFACE lpDDSurface,
		LPDIRECTDRAWCLIPPER lpDDClipper )
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   this;
    LPDDRAWI_DDRAWCLIPPER_INT   this_clipper_int;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    BOOL                        detach;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetClipper");

    /*
     * validate parms
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
        if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
        {
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        if( this_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ||
            this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            /*
             * Can't attach a clipper to an execute buffer or an optimized
             * surface.
             */
            DPF_ERR( "Invalid surface type: can't attach clipper" );
            LEAVE_DDRAW();
            return DDERR_INVALIDSURFACETYPE;
        }

        this_clipper_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
        if( this_clipper_int != NULL )
        {
            if( !VALID_DIRECTDRAWCLIPPER_PTR( this_clipper_int ) )
            {
                LEAVE_DDRAW();
                return DDERR_INVALIDOBJECT;
            }
        }
        pdrv = this->lpDD;

        //
        // For now, if the current surface is optimized, quit
        //
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            DPF_ERR( "Cannot set clipper to an optimized surface" );
            LEAVE_DDRAW();
            return DDERR_ISOPTIMIZEDSURFACE;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DDRAW();
        return DDERR_INVALIDPARAMS;
    }

    /*
     * NULL clipper, remove clipper from this surface
     */
    detach = FALSE;
    if( this_clipper_int == NULL )
    {
        detach = TRUE;
        this_clipper_int = this_lcl->lpSurfMore->lpDDIClipper;
        if( this_clipper_int == NULL )
        {
            DPF_ERR( "No attached clipper" );
            LEAVE_DDRAW();
            return DDERR_NOCLIPPERATTACHED;
        }
    }

    /*
     * removing the clipper from the surface?
     */
    if( detach )
    {
        this_lcl->lpDDClipper = NULL;
        this_lcl->lpSurfMore->lpDDIClipper = NULL;
        DD_Clipper_Release( (LPDIRECTDRAWCLIPPER) this_clipper_int );
        LEAVE_DDRAW();
        return DD_OK;
    }

    /*
     * Setting the clipper.
     * You can set the same clipper multiple times without bumping
     * the reference count. This is done for orthogonality with
     * palettes.
     */
    if( this_clipper_int != this_lcl->lpSurfMore->lpDDIClipper )
    {
        /*
         * If there was an existing clipper release it now.
         */
        if( this_lcl->lpSurfMore->lpDDIClipper != NULL)
            DD_Clipper_Release( (LPDIRECTDRAWCLIPPER) this_lcl->lpSurfMore->lpDDIClipper );

        this_lcl->lpSurfMore->lpDDIClipper = this_clipper_int;
        this_lcl->lpDDClipper = this_clipper_int->lpLcl;
        DD_Clipper_AddRef( (LPDIRECTDRAWCLIPPER) this_clipper_int );
    }

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Surface_SetClipper */

#undef DPF_MODNAME
#define DPF_MODNAME     "InternalCreateClipper"

/*
 * InternalCreateClipper
 *
 * Core clipper creation.
 *
 * NOTE: Assumes the caller has already entered the DirectDraw critical
 * section.
 */
HRESULT InternalCreateClipper(
		LPDDRAWI_DIRECTDRAW_GBL  lpDD,
		DWORD                    dwFlags,
		LPDIRECTDRAWCLIPPER FAR *lplpDDClipper,
		IUnknown FAR            *pUnkOuter,
		BOOL                     fInitialized,
		LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl,
		LPDDRAWI_DIRECTDRAW_INT lpDD_int )
{
    LPDDRAWI_DDRAWCLIPPER_INT	pclipper_int;
    LPDDRAWI_DDRAWCLIPPER_LCL   pclipper_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL   pclipper;
    DWORD                       clipper_size;

    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }

    TRY
    {
	/*
	 * NOTE: We do not attempt to validate the DirectDraw
	 * object passed in. This will be NULL if we are creating
	 * a clipper not owned by any DirectDraw object.
	 * IDirectDraw_CreateClipper will validate this for us.
	 */

	if( !VALID_PTR_PTR( lplpDDClipper ) )
	{
	    DPF_ERR( "Invalid pointer to pointer to clipper" );
	    return DDERR_INVALIDPARAMS;
	}
	*lplpDDClipper = NULL;

	/*
	 * verify flags
	 */
	if( dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * allocate the clipper object
     */
    clipper_size = sizeof( DDRAWI_DDRAWCLIPPER_GBL ) +
	       sizeof( DDRAWI_DDRAWCLIPPER_LCL );
    pclipper_lcl = (LPDDRAWI_DDRAWCLIPPER_LCL) MemAlloc( clipper_size );
    if( pclipper_lcl == NULL )
    {
	DPF_ERR( "Insufficient memory to allocate the clipper" );
	return DDERR_OUTOFMEMORY;
    }
    pclipper_lcl->lpGbl = (LPDDRAWI_DDRAWCLIPPER_GBL) (((LPSTR)pclipper_lcl) +
			sizeof( DDRAWI_DDRAWCLIPPER_LCL ) );
    pclipper = pclipper_lcl->lpGbl;
    pclipper_lcl->lpDD_lcl = lpDD_lcl;
    pclipper_lcl->lpDD_int = lpDD_int;


    pclipper_int = MemAlloc( sizeof( DDRAWI_DDRAWCLIPPER_INT ));
    if( NULL == pclipper_int)
    {
	DPF_ERR( "Insufficient memory to allocate the clipper" );
	MemFree( pclipper_lcl );
	return DDERR_OUTOFMEMORY;
    }

    /*
     * set up data
     */
    pclipper_int->lpLcl = pclipper_lcl;
    pclipper_int->dwIntRefCnt = 0;	// will be addrefed later

    /*
     * Link the clipper into the appropriate list (either the
     * given DirectDraw object's list or the global clipper
     * list dependening on whether it is being created off
     * a DirectDraw object or nor.
     */
    if( lpDD != NULL)
    {
	/*
	 * The DirectDraw object's list.
	 */
	pclipper_int->lpLink = lpDD->clipperList;
	lpDD->clipperList    = pclipper_int;
    }
    else
    {
	/*
	 * The global clipper list.
	 */
	pclipper_int->lpLink = lpGlobalClipperList;
	lpGlobalClipperList = pclipper_int;
    }

    /*
     * fill in misc stuff
     *
     * NOTE: The DirectDraw object pointer will be initialized by
     * IDirectDraw_CreateClipper. DirectDrawClipperCreate will
     * leave it NULL'd out.
     */
    pclipper->lpDD = lpDD;
    pclipper->dwFlags = 0UL;

    /*
     * bump reference count, return object
     */
    pclipper->dwProcessId = GetCurrentProcessId();
    pclipper_lcl->dwLocalRefCnt = OBJECT_ISROOT;

    if( fInitialized )
    {
	/*
	 * Initialized by default. Use the real vtable.
	 */
	pclipper->dwFlags |= DDRAWICLIP_ISINITIALIZED;
	pclipper_int->lpVtbl = (LPVOID) &ddClipperCallbacks;
    }
    else
    {
	/*
	 * Object is not initialized. Use the dummy vtable
	 * which only lets the caller call AddRef(), Release()
	 * and Initialize().
	 */
	pclipper_int->lpVtbl = (LPVOID) &ddUninitClipperCallbacks;
    }

    DD_Clipper_AddRef( (LPDIRECTDRAWCLIPPER) pclipper_int );

    *lplpDDClipper = (LPDIRECTDRAWCLIPPER) pclipper_int;

    /*
     * If this ddraw object generates independent child objects, then this clipper takes
     * a ref count on that ddraw object. First check lpDD_int, as this object may not
     * be owned by a DDraw object.
     */
    if (lpDD_int && CHILD_SHOULD_TAKE_REFCNT(lpDD_int))
    {
        IDirectDraw *pdd = (IDirectDraw*) lpDD_int;

        pdd->lpVtbl->AddRef(pdd);
        pclipper_lcl->pAddrefedThisOwner = (IUnknown *) pdd;
    }

    return DD_OK;
} /* InternalCreateClipper */

#undef DPF_MODNAME
#define DPF_MODNAME     "CreateClipper"

/*
 * DD_CreateClipper
 *
 * Driver function: create a clipper
 */
HRESULT DDAPI DD_CreateClipper(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDIRECTDRAWCLIPPER FAR *lplpDDClipper,
		IUnknown FAR *pUnkOuter )
{
    HRESULT                     hRes;
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreateClipper");

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * Actually create the clipper.
     */
    hRes = InternalCreateClipper( this, dwFlags, lplpDDClipper, pUnkOuter, TRUE, this_lcl, this_int );

    LEAVE_DDRAW();

    return hRes;
} /* DD_CreateClipper */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawCreateClipper"

/*
 * DirectDrawCreateClipper
 *
 * One of the three end-user API exported from DDRAW.DLL.
 * Creates a DIRECTDRAWCLIPPER object not owned by a
 * particular DirectDraw object.
 */
HRESULT WINAPI DirectDrawCreateClipper( DWORD dwFlags, LPDIRECTDRAWCLIPPER FAR *lplpDDClipper, IUnknown FAR *pUnkOuter )
{
    HRESULT hRes;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DirectDrawCreateClipper");	

    hRes = InternalCreateClipper( NULL, dwFlags, lplpDDClipper, pUnkOuter, TRUE, NULL, NULL );

    LEAVE_DDRAW();

    return hRes;
} /* DirectDrawCreateClipper */

#undef DPF_MODNAME
#define DPF_MODNAME "Clipper: Initialize"

/*
 * DD_Clipper_Initialize
 */
HRESULT DDAPI DD_Clipper_Initialize(
		LPDIRECTDRAWCLIPPER lpDDClipper,
		LPDIRECTDRAW lpDD,
		DWORD dwFlags )
{
    LPDDRAWI_DDRAWCLIPPER_INT this_int;
    LPDDRAWI_DDRAWCLIPPER_LCL this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL this_gbl;
    LPDDRAWI_DIRECTDRAW_INT   pdrv_int;
    LPDDRAWI_DIRECTDRAW_GBL   pdrv_gbl;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Clipper_Initialize");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWCLIPPER_INT) lpDDClipper;
	if( !VALID_DIRECTDRAWCLIPPER_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid clipper interface pointer" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	this_lcl = this_int->lpLcl;
	this_gbl = this_lcl->lpGbl;

	pdrv_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( NULL != pdrv_int )
	{
	    if( !VALID_DIRECTDRAW_PTR( pdrv_int ) )
	    {
		DPF_ERR( "Invalid DirectDraw object" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    pdrv_gbl = pdrv_int->lpLcl->lpGbl;
	}
	else
	{
	    pdrv_gbl = NULL;
	}

	if( this_gbl->dwFlags & DDRAWICLIP_ISINITIALIZED )
	{
	    DPF_ERR( "Clipper already initialized" );
	    LEAVE_DDRAW();
	    return DDERR_ALREADYINITIALIZED;
	}

	/*
	 * Validate flags - no flags currently supported
	 */
	if( 0UL != dwFlags )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * As we don't support any flags the only function of Initialize() is
     * to move the clipper from the global list to the list of the supplied
     * driver object. If no driver is supplied Initialized is a no-op.
     * CoCreateInstance() does all the initialization necessary.
     */
    if( NULL != pdrv_gbl )
    {
	RemoveClipperFromList( NULL, this_int );
	this_int->lpLink = pdrv_gbl->clipperList;
	pdrv_gbl->clipperList = this_int;
	this_gbl->lpDD = pdrv_gbl;
	this_lcl->lpDD_lcl = pdrv_int->lpLcl;
	this_lcl->lpDD_int = pdrv_int;
    }

    this_gbl->dwFlags |= DDRAWICLIP_ISINITIALIZED;

    /*
     * The real vtable can be used now.
     */
    this_int->lpVtbl = &ddClipperCallbacks;

    LEAVE_DDRAW();
    return DD_OK;

} /* DD_Clipper_Initialize */

/*
 * ProcessClipperCleanup
 *
 * A process is done, clean up any clippers it may have created
 *
 * NOTE: we enter with a lock taken on the DIRECTDRAW object.
 */
void ProcessClipperCleanup( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWCLIPPER_INT   pclipper_int;
    LPDDRAWI_DDRAWCLIPPER_INT   ppnext_int;
    DWORD                       rcnt;
    ULONG                       rc;

    /*
     * Cleaning up the clippers is now a two stage process. We need to
     * clean up all the clippers create via CreateClipper(), i.e., those
     * attached to a DirectDraw driver object. We also need to clean up
     * those clippers created by thise process with DirectDrawClipperCreate,
     * i.e., those not attached to a driver object.
     */

    /*
     * run through all clippers owned by the driver object, and find ones
     * that have been accessed by this process.  If the pdrv_lcl parameter is
     * non-null, only clean them up if they were created by that local object.
     */
    DPF( 4, "ProcessClipperCleanup" );

    if( NULL != pdrv )
    {
	DPF( 5, "Cleaning up clippers owned by driver object 0x%08x", pdrv );
	pclipper_int = pdrv->clipperList;
    }
    else
    {
	pclipper_int = NULL;
    }
    while( pclipper_int != NULL )
    {
	ppnext_int = pclipper_int->lpLink;

	/*
	 * All clippers in this list should have a valid back pointer to
	 * this driver object.
	 */
	DDASSERT( pclipper_int->lpLcl->lpGbl->lpDD == pdrv );

	rc = 1;
	if( (pclipper_int->lpLcl->lpGbl->dwProcessId == pid) &&
	    ( (pdrv_lcl == NULL) || (pdrv_lcl == pclipper_int->lpLcl->lpDD_lcl) ))
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = pclipper_int->dwIntRefCnt;
	    DPF( 5, "Process %08lx had %ld accesses to clipper %08lx", pid, rcnt, pclipper_int );
	    while( rcnt >  0 )
	    {
		rc = InternalClipperRelease( pclipper_int );
		/* GEE: 0 is now an error code,
		 * errors weren't handled before anyway,
		 * does this matter.
		 */
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	else
	{
	    DPF( 5, "Process %08lx does not have access to clipper" );
	}
	pclipper_int = ppnext_int;
    }

    /*
     * Now clean up the global clipper list.
     * If the pdrv_lcl parameter is not NULL then we are only cleaning up clipper
     * objects created by a particular local driver object.  In this case we
     * do not want to free the global clippers.
     *
     * NOTE: The DirectDraw lock is taken so we can safely access this global object.
     */

    if( NULL != pdrv_lcl )
    {
	DPF( 4, "Not cleaning up clippers not owned by a driver object");
	return;
    }

    DPF( 4, "Cleaning up clippers not owned by a driver object" );

    pclipper_int = lpGlobalClipperList;
    while( pclipper_int != NULL )
    {
	ppnext_int = pclipper_int->lpLink;

	/*
	 * The clippers in this list should never have a back pointer to a driver
	 * object.
	 */
	DDASSERT( pclipper_int->lpLcl->lpGbl->lpDD == NULL );

	rc = 1;
	if( pclipper_int->lpLcl->lpGbl->dwProcessId == pid )
	{
	    /*
	     * release the references by this process
	     */
	    rcnt = pclipper_int->dwIntRefCnt;
	    while( rcnt >  0 )
	    {
		rc = InternalClipperRelease( pclipper_int );
		/* GEE: 0 is now an error code,
		 * errors weren't handled before anyway,
		 * does this matter.
		 */
		if( rc == 0 )
		{
		    break;
		}
		rcnt--;
	    }
	}
	pclipper_int = ppnext_int;
    }

    DPF( 4, "Done ProcessClipperCleanup" );

} /* ProcessClipperCleanup */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddesurf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddesurf.c
 *  Content:	DirectDraw EnumSurfaces support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   25-jan-95	craige	split out of ddraw.c, enhanced
 *   31-jan-95	craige	and even more ongoing work...
 *   27-feb-95	craige 	new sync. macros
 *   19-mar-95	craige	use HRESULTs
 *   01-apr-95	craige	happy fun joy updated header file
 *   14-may-95	craige	cleaned out obsolete junk
 *   24-may-95  kylej   removed references to obsolete ZOrder variables
 *   07-jun-95	craige	only allow enumeration of surfaces that belong to
 *			the calling process
 *   12-jun-95	craige	new process list stuff
 *   16-jun-95	craige	removed fpVidMemOrig
 *   25-jun-95	craige	one ddraw mutex
 *   26-jun-95	craige	reorganized surface structure
 *   28-jun-95	craige	ENTER_DDRAW at very start of fns
 *   30-jun-95	craige	use DDRAWI_HASPIXELFORMAT/HASOVERLAYDATA
 *   01-jul-95	craige	comment out compostion stuff
 *   03-jul-95  kylej   rewrote the CANBECREATED iteration
 *   04-jul-95	craige	YEEHAW: new driver struct; SEH
 *   19-jul-95	craige	EnumSurfaces wasn't wrapping all parm validation
 *   31-jul-95	craige	flag validation
 *   09-dec-95  colinmc added execute buffer support
 *   15-dec-95  colinmc fixed bug when filling surface description
 *   18-dec-95  colinmc additional caps bit checking in EnumSurfaces
 *   05-jan-95	kylej	added interface structures
 *   17-feb-96  colinmc fixed problem limiting size of execute buffers
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   29-apr-96  colinmc Bug 20063: incorrect surface description returned
 *                      for z-buffer
 *   24-mar-97  jeffno  Optimized Surfaces
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

#undef  DPF_MODNAME
#define DPF_MODNAME "GetSurfaceDesc"

/*
 * FillDDSurfaceDesc
 *
 * NOTE: Special cases execute buffers as they have no pixel format or height.
 * You may wonder why this function is execute buffer aware when execute
 * buffers are skipped by EnumSurfaces. Well, FillDDSurfaceDesc is not simply
 * used when enumerating surfaces. It is also used when locking a surface so
 * it needs to fill in the correct stuff for execute buffers.
 */
void FillEitherDDSurfaceDesc(
		LPDDRAWI_DDRAWSURFACE_LCL lpDDSurfaceX,
		LPDDSURFACEDESC2 lpDDSurfaceDesc )
{
    LPDDRAWI_DDRAWSURFACE_GBL	lpDDSurface;

    DDASSERT(lpDDSurfaceDesc);
    DDASSERT(lpDDSurfaceDesc->dwSize == sizeof(DDSURFACEDESC) || lpDDSurfaceDesc->dwSize == sizeof(DDSURFACEDESC2) );

    lpDDSurface = lpDDSurfaceX->lpGbl;

    lpDDSurfaceDesc->dwFlags = DDSD_CAPS;
    lpDDSurfaceDesc->ddsCaps.dwCaps = lpDDSurfaceX->ddsCaps.dwCaps;
    if (lpDDSurfaceDesc->dwSize >= sizeof (DDSURFACEDESC2))
    {
        lpDDSurfaceDesc->ddsCaps.ddsCapsEx = lpDDSurfaceX->lpSurfMore->ddsCapsEx;
        if (DDSD_TEXTURESTAGE & lpDDSurfaceX->lpSurfMore->dwTextureStage)
        {
            lpDDSurfaceDesc->dwFlags |= DDSD_TEXTURESTAGE;
            lpDDSurfaceDesc->dwTextureStage = (lpDDSurfaceX->lpSurfMore->dwTextureStage & ~DDSD_TEXTURESTAGE);
        }
        else
            lpDDSurfaceDesc->dwTextureStage = 0;

        lpDDSurfaceDesc->dwFVF = lpDDSurfaceX->lpSurfMore->dwFVF;
        if (lpDDSurfaceX->lpSurfMore->dwFVF)
        {
            lpDDSurfaceDesc->dwFlags |= DDSD_FVF;
        }
    }

    lpDDSurfaceDesc->lpSurface = (FLATPTR) NULL;

    if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASCKEYDESTBLT )
    {
        lpDDSurfaceDesc->dwFlags |= DDSD_CKDESTBLT;
        lpDDSurfaceDesc->ddckCKDestBlt = lpDDSurfaceX->ddckCKDestBlt;
    }
    if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASCKEYSRCBLT )
    {
        lpDDSurfaceDesc->dwFlags |= DDSD_CKSRCBLT;
        lpDDSurfaceDesc->ddckCKSrcBlt = lpDDSurfaceX->ddckCKSrcBlt;
    }
    if( lpDDSurfaceX->dwFlags & DDRAWISURF_FRONTBUFFER )
    {
        lpDDSurfaceDesc->dwFlags |= DDSD_BACKBUFFERCOUNT;
        lpDDSurfaceDesc->dwBackBufferCount = lpDDSurfaceX->dwBackBufferCount;
    }
    if( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
    {
	DDASSERT( lpDDSurfaceX->lpSurfMore != NULL );
	lpDDSurfaceDesc->dwFlags |= DDSD_MIPMAPCOUNT;
	lpDDSurfaceDesc->dwMipMapCount = lpDDSurfaceX->lpSurfMore->dwMipMapCount;
    }

    /*
     * Initialize the width, height and pitch of the surface description.
     */
    if( (lpDDSurfaceX->dwFlags & DDRAWISURF_HASPIXELFORMAT) &&
    	(lpDDSurface->ddpfSurface.dwFlags & DDPF_FOURCC) )
    {
	lpDDSurfaceDesc->dwFlags |= ( DDSD_WIDTH | DDSD_HEIGHT );
	lpDDSurfaceDesc->dwWidth  = (DWORD) lpDDSurface->wWidth;
	lpDDSurfaceDesc->dwHeight = (DWORD) lpDDSurface->wHeight;

    	switch (lpDDSurface->ddpfSurface.dwFourCC)
	{
	case FOURCC_DXT1:
	case FOURCC_DXT2:
	case FOURCC_DXT3:
	case FOURCC_DXT4:
	case FOURCC_DXT5:
	    /*
	     * A compressed texture surface is allocated as an integral number
	     * of blocks of 4x4 pixels.  It has no pixel pitch as such, so we
	     * return the linear size of the storage allocated for the surface.
	     */
	    lpDDSurfaceDesc->dwFlags |= DDSD_LINEARSIZE;
	    lpDDSurfaceDesc->dwLinearSize = lpDDSurface->dwLinearSize;
	    break;

	default:
    	    // This is what we've always done for FOURCCs, but is it correct?
	    lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
            lpDDSurfaceDesc->lPitch   = lpDDSurface->lPitch;
    	    break;
	}
    }
    else if( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
	/*
	 * For execute buffer the height is not valid and both the width
	 * and pitch are set to the linear size of the execute buffer.
	 */
        lpDDSurfaceDesc->dwFlags |= ( DDSD_WIDTH | DDSD_PITCH );
	lpDDSurfaceDesc->dwWidth  = lpDDSurface->dwLinearSize;
        lpDDSurfaceDesc->dwHeight = 0UL;
	lpDDSurfaceDesc->lPitch   = (LONG) lpDDSurface->dwLinearSize;
    }
#if 0 //Old code
    else if ( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED )
    {
        lpDDSurfaceDesc->dwFlags |= ( DDSD_WIDTH | DDSD_HEIGHT );
	lpDDSurfaceDesc->dwWidth  = (DWORD) lpDDSurface->wWidth;
        lpDDSurfaceDesc->dwHeight = (DWORD) lpDDSurface->wHeight;
        if ( !(lpDDSurfaceX->lpGbl->dwGlobalFlags & DDRAWISURFGBL_MEMFREE ) )
        {
            if (lpDDSurfaceX->lpGbl->dwGlobalFlags & DDRAWISURFGBL_LATEALLOCATELINEAR)
            {
                /*
                 * Surface was allocated as a formless chunk.
                 */
                lpDDSurfaceDesc->dwFlags |= DDSD_LINEARSIZE;
                lpDDSurfaceDesc->dwLinearSize = lpDDSurfaceX->lpGbl->dwLinearSize;
            }
            else
            {
                lpDDSurfaceDesc->dwFlags |= DDSD_PITCH;
	        lpDDSurfaceDesc->lPitch   = lpDDSurface->lPitch;
            }
        }
    }
#endif //0
    else
    {
        lpDDSurfaceDesc->dwFlags |= ( DDSD_WIDTH | DDSD_HEIGHT | DDSD_PITCH );
	lpDDSurfaceDesc->dwWidth  = (DWORD) lpDDSurface->wWidth;
        lpDDSurfaceDesc->dwHeight = (DWORD) lpDDSurface->wHeight;
	lpDDSurfaceDesc->lPitch   = lpDDSurface->lPitch;
    }

    /*
     * Initialize the pixel format.
     */
    if( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        /*
         * Dummy pixel format for execute buffers.
         */
        memset(&lpDDSurfaceDesc->ddpfPixelFormat, 0, sizeof(DDPIXELFORMAT));
        lpDDSurfaceDesc->ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);

        if (lpDDSurfaceDesc->dwSize >= sizeof (DDSURFACEDESC2))
        {
            if (lpDDSurfaceX->lpSurfMore->dwFVF)
            {
                lpDDSurfaceDesc->dwFVF = lpDDSurfaceX->lpSurfMore->dwFVF;
                lpDDSurfaceDesc->dwFlags |= DDSD_FVF;
            }
        }
    }
    else if( lpDDSurfaceX->ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
    {

	DDASSERT( lpDDSurfaceX->dwFlags & DDRAWISURF_HASPIXELFORMAT );
	DDASSERT( lpDDSurface->ddpfSurface.dwFlags & DDPF_ZBUFFER );
	DDASSERT( lpDDSurface->ddpfSurface.dwZBufferBitDepth !=0);

        // Note: DX5 copied the pixfmt from the surface but left the DDSD_PIXELFORMAT
        //       flag off because CreateSurface couldn't handle ZBuffers with pxfmts
        //       (because of Complex Surfaces).  Now it can, so I'm turning it on for dx6 apps

        // copy info to SD pixfmt.  This is what DX5 did too.
        lpDDSurfaceDesc->ddpfPixelFormat = lpDDSurface->ddpfSurface;

        // for pre-dx6 apps, fill in legacy SD ZBufferBitDepth field, but don't set pixfmt flag
        if (lpDDSurfaceDesc->dwSize == sizeof (DDSURFACEDESC)) {
            ((DDSURFACEDESC *)lpDDSurfaceDesc)->dwZBufferBitDepth=lpDDSurface->ddpfSurface.dwZBufferBitDepth;
            lpDDSurfaceDesc->dwFlags |= DDSD_ZBUFFERBITDEPTH;
        } else {
        // for dx6 apps, set PIXFMT flag, but not legacy SD ZBufferBitDepth field
            lpDDSurfaceDesc->dwFlags |= DDSD_PIXELFORMAT;
        }
    }
    else
    {
        lpDDSurfaceDesc->dwFlags |= DDSD_PIXELFORMAT;
        if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASPIXELFORMAT )
        {
            lpDDSurfaceDesc->ddpfPixelFormat=lpDDSurface->ddpfSurface;
        }
        else
        {
            lpDDSurfaceDesc->ddpfPixelFormat=lpDDSurface->lpDD->vmiData.ddpfDisplay;
        }
    }

    if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASOVERLAYDATA )
    {
        if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASCKEYDESTOVERLAY )
        {
            lpDDSurfaceDesc->dwFlags |= DDSD_CKDESTOVERLAY;
	    lpDDSurfaceDesc->ddckCKDestOverlay = lpDDSurfaceX->ddckCKDestOverlay;
        }
        if( lpDDSurfaceX->dwFlags & DDRAWISURF_HASCKEYSRCOVERLAY )
        {
            lpDDSurfaceDesc->dwFlags |= DDSD_CKSRCOVERLAY;
	    lpDDSurfaceDesc->ddckCKSrcOverlay = lpDDSurfaceX->ddckCKSrcOverlay;
        }
    }
    else
    {
	lpDDSurfaceDesc->ddckCKDestOverlay.dwColorSpaceLowValue = 0;
	lpDDSurfaceDesc->ddckCKDestOverlay.dwColorSpaceHighValue = 0;
	lpDDSurfaceDesc->ddckCKSrcOverlay.dwColorSpaceLowValue = 0;
	lpDDSurfaceDesc->ddckCKSrcOverlay.dwColorSpaceHighValue = 0;
    }

} /* FillEitherDDSurfaceDesc */

void FillDDSurfaceDesc(
		LPDDRAWI_DDRAWSURFACE_LCL lpDDSurfaceX,
		LPDDSURFACEDESC lpDDSurfaceDesc )
{
    memset(lpDDSurfaceDesc,0, sizeof( DDSURFACEDESC ));
    lpDDSurfaceDesc->dwSize = sizeof( DDSURFACEDESC );
    FillEitherDDSurfaceDesc(lpDDSurfaceX, (LPDDSURFACEDESC2) lpDDSurfaceDesc);
}
void FillDDSurfaceDesc2(
		LPDDRAWI_DDRAWSURFACE_LCL lpDDSurfaceX,
		LPDDSURFACEDESC2 lpDDSurfaceDesc )
{
    memset(lpDDSurfaceDesc,0, sizeof( DDSURFACEDESC2 ));
    lpDDSurfaceDesc->dwSize = sizeof( DDSURFACEDESC2 );
    FillEitherDDSurfaceDesc(lpDDSurfaceX, lpDDSurfaceDesc);
}

/*
 * tryMatch
 *
 * tries to match a surface description with a surface object
 */
static BOOL tryMatch( LPDDRAWI_DDRAWSURFACE_LCL curr_lcl, LPDDSURFACEDESC2 psd )
{
    DWORD	flags;
    BOOL	no_match;
    LPDDRAWI_DDRAWSURFACE_GBL	curr;

    curr = curr_lcl->lpGbl;

    flags = psd->dwFlags;
    no_match = FALSE;

    if( flags & DDSD_CAPS )
    {
        if (curr_lcl->ddsCaps.dwCaps != psd->ddsCaps.dwCaps)
        {
            return FALSE;
        }
	if( memcmp( &curr_lcl->lpSurfMore->ddsCapsEx, &psd->ddsCaps.ddsCapsEx, sizeof( DDSCAPSEX ) ) )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_HEIGHT )
    {
	if( (DWORD) curr->wHeight != psd->dwHeight )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_WIDTH )
    {
	if( (DWORD) curr->wWidth != psd->dwWidth )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_LPSURFACE )
    {
	if( (LPVOID) curr->fpVidMem != psd->lpSurface )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_CKDESTBLT )
    {
	if( memcmp( &curr_lcl->ddckCKDestBlt, &psd->ddckCKDestBlt, sizeof( DDCOLORKEY ) ) )
	{
	    return FALSE;
	}
    }
    if( flags & DDSD_CKSRCBLT )
    {
	if( memcmp( &curr_lcl->ddckCKSrcBlt, &psd->ddckCKSrcBlt, sizeof( DDCOLORKEY ) ) )
	{
	    return FALSE;
	}
    }

    if( flags & DDSD_BACKBUFFERCOUNT )
    {
	if( curr_lcl->dwBackBufferCount != psd->dwBackBufferCount )
	{
	    return FALSE;
	}
    }

    if( flags & DDSD_MIPMAPCOUNT )
    {
	DDASSERT( curr_lcl->lpSurfMore != NULL );
	if( curr_lcl->lpSurfMore->dwMipMapCount != psd->dwMipMapCount )
	{
	    return FALSE;
	}
    }

    /*
     * these fields are not always present
     */
    if( flags & DDSD_PIXELFORMAT )
    {
	if( curr_lcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	{
	    if( memcmp( &curr->ddpfSurface, &psd->ddpfPixelFormat, sizeof( DDPIXELFORMAT ) ) )
	    {
		return FALSE;
	    }
	}
	else
	{
	    // surface description specifies pixel format but there is no
	    // pixel format in the surface.
	    return FALSE;
	}
    }

    if( curr_lcl->dwFlags & DDRAWISURF_HASOVERLAYDATA )
    {
        if( flags & DDSD_CKDESTOVERLAY )
        {
	    if( memcmp( &curr_lcl->ddckCKDestOverlay, &psd->ddckCKDestOverlay, sizeof( DDCOLORKEY ) ) )
	    {
		return FALSE;
	    }
	}
	if( flags & DDSD_CKSRCOVERLAY )
	{
	    if( memcmp( &curr_lcl->ddckCKSrcOverlay, &psd->ddckCKSrcOverlay, sizeof( DDCOLORKEY ) ) )
	    {
		return FALSE;
	    }
	}
    }
    else
    {
	if( ( flags & DDSD_CKDESTOVERLAY ) ||
	    ( flags & DDSD_CKSRCOVERLAY ) )
	{
	    return FALSE;
	}
    }

    return TRUE;

} /* tryMatch */

/*
 * What can we create? The popular question asked by the application.
 *
 * We will permute through the following items for each surface description:
 *
 * - FOURCC codes (dwFourCC)
 * - dimensions (dwHeight, dwWidth - based on modes avail only)
 * - RGB formats
 */
#define ENUM_FOURCC	0x000000001
#define ENUM_DIMENSIONS	0x000000002
#define ENUM_RGB	0x000000004

#undef  DPF_MODNAME
#define DPF_MODNAME	"EnumSurfaces"

/*
 * DD_EnumSurfaces
 */
HRESULT DDAPI DD_EnumSurfaces(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDDSURFACEDESC lpDDSD,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK lpEnumCallback )
{
    DDSURFACEDESC2 ddsd2;

    DPF(2,A,"ENTERAPI: DD_EnumSurfaces");

    TRY
    {
	if( lpDDSD != NULL )
	{
	    if( !VALID_DDSURFACEDESC_PTR( lpDDSD ) )
	    {
	        DPF_ERR( "Invalid surface description. Did you set the dwSize member to sizeof(DDSURFACEDESC)?" );
                DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	        return DDERR_INVALIDPARAMS;
	    }
            ZeroMemory(&ddsd2,sizeof(ddsd2));
            memcpy(&ddsd2,lpDDSD,sizeof(*lpDDSD));
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters: Bad LPDDSURFACEDESC" );
        DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	return DDERR_INVALIDPARAMS;
    }

    ddsd2.dwSize = sizeof(ddsd2);

    if (lpDDSD)
        return DD_EnumSurfaces4(lpDD,dwFlags, &ddsd2, lpContext, (LPDDENUMSURFACESCALLBACK2) lpEnumCallback);
    else
        return DD_EnumSurfaces4(lpDD,dwFlags, NULL, lpContext, (LPDDENUMSURFACESCALLBACK2) lpEnumCallback);
}

/*
 * DD_EnumSurfaces4
 */
HRESULT DDAPI DD_EnumSurfaces4(
		LPDIRECTDRAW lpDD,
		DWORD dwFlags,
		LPDDSURFACEDESC2 lpDDSD,
		LPVOID lpContext,
		LPDDENUMSURFACESCALLBACK2 lpEnumCallback )
{
    LPDDRAWI_DIRECTDRAW_INT	this_int;
    LPDDRAWI_DIRECTDRAW_LCL	this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL	this;
    LPDDRAWI_DDRAWSURFACE_INT	curr_int;
    LPDDRAWI_DDRAWSURFACE_LCL	curr_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL	curr;
    DWORD			rc;
    BOOL			needit;
    DDSURFACEDESC2		dsd;
    LPDDSURFACEDESC2		pdsd;
    DWORD			flags;
    HRESULT                     ddrval;
    LPDIRECTDRAWSURFACE		psurf;
    DWORD			caps;
    DDSCAPSEX                   capsEx;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_EnumSurfaces4");

    /*
     * validate parameters
     */
    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( !VALID_DIRECTDRAW_PTR( this_int ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	this = this_lcl->lpGbl;
	if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
	{
	    DPF_ERR( "Invalid callback routine" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( dwFlags & ~DDENUMSURFACES_VALID )
	{
	    DPF_ERR( "Invalid flags" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
	if( lpDDSD != NULL )
	{
	    if( !VALID_DDSURFACEDESC2_PTR( lpDDSD ) )
	    {
                DPF_ERR("Bad DDSURFACEDESC2 ptr.. did you set the dwSize?");
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    caps = lpDDSD->ddsCaps.dwCaps;
	    capsEx = lpDDSD->ddsCaps.ddsCapsEx;
	}

	/*
	 * are flags OK?
	 */
	if( (dwFlags & DDENUMSURFACES_ALL) )
	{
	    if( dwFlags & (DDENUMSURFACES_MATCH | DDENUMSURFACES_NOMATCH) )
	    {
		DPF_ERR( "can't match or nomatch DDENUMSURFACES_ALL" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
	    if( lpDDSD == NULL )
	    {
		DPF_ERR( "No surface description" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	    if( (dwFlags & DDENUMSURFACES_MATCH) && (dwFlags & DDENUMSURFACES_NOMATCH) )
	    {
		DPF_ERR( "can't match and nomatch together" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}
	if( dwFlags & DDENUMSURFACES_CANBECREATED )
	{
	    if( !(dwFlags & DDENUMSURFACES_MATCH) ||
		 (dwFlags & (DDENUMSURFACES_ALL | DDENUMSURFACES_NOMATCH) ) )
	    {
		DPF_ERR( "can only use MATCH for CANBECREATED" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	}

	if( lpDDSD != NULL )
	{
	    /*
	     * validate surface descriptions...
	     */
	    pdsd = lpDDSD;
	    flags = pdsd->dwFlags;

	    /*
	     * read-only flags
	     */
	    if( flags & DDSD_LPSURFACE )
	    {
		DPF_ERR( "Read-only flag specified in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

	    /*
	     * Check for bogus caps bits.
	     */
            if( caps & ~DDSCAPS_VALID )
	    {
		DPF_ERR( "Invalid surface capability bits specified" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }

            if( caps & DDSCAPS_OPTIMIZED )
            {
                DPF_ERR( "Optimized surfaces cannot be enumerated" );
                LEAVE_DDRAW();
                // ATTENTION: Should be an error, but we return DD_OK for
                // App-Compat reasons.
                return DD_OK;
            }

            if (capsEx.dwCaps2 & ~DDSCAPS2_VALID)
            {
                DPF_ERR( "invalid DDSURFACEDESC.DDSCAPS.dwSCaps2 specified" );
		LEAVE_DDRAW();
                return DDERR_INVALIDCAPS;
            }

            if (capsEx.dwCaps3 & ~DDSCAPS3_VALID)
            {
                DPF_ERR( "invalid DDSURFACEDESC.DDSCAPS.dwSCaps3 specified" );
		LEAVE_DDRAW();
                return DDERR_INVALIDCAPS;
            }

            if (capsEx.dwCaps4 & ~DDSCAPS4_VALID)
            {
                DPF_ERR( "invalid DDSURFACEDESC.DDSCAPS.dwSCaps4 specified" );
		LEAVE_DDRAW();
                return DDERR_INVALIDCAPS;
            }


            /*
             * You cannot enumerate over execute buffers (they are
             * not visible through the user level API).
             */
            if( caps & DDSCAPS_EXECUTEBUFFER )
            {
                DPF_ERR( "Invalid surface capability bit specified in surface desc" );
                LEAVE_DDRAW();
                return DDERR_INVALIDPARAMS;
            }

	    /*
	     * check height/width
	     */
	    if( ((flags & DDSD_HEIGHT) && !(flags & DDSD_WIDTH)) ||
		(!(flags & DDSD_HEIGHT) && (flags & DDSD_WIDTH)) )
	    {
		DPF_ERR( "Specify both height & width in surface desc" );
		LEAVE_DDRAW();
		return DDERR_INVALIDPARAMS;
	    }
	
	    /*
	     * certain things you can and can't look for during CANBECREATED
	     */
	    if( dwFlags & DDENUMSURFACES_CANBECREATED )
	    {
		if( flags & (DDSD_CKDESTOVERLAY|
			     DDSD_CKDESTBLT|
			     DDSD_CKSRCOVERLAY|
			     #ifdef COMPOSITION
				DDSD_COMPOSITIONORDER |
			     #endif
			     DDSD_CKSRCBLT ))
		{
		    DPF_ERR( "Invalid flags specfied with CANBECREATED" );
		    LEAVE_DDRAW();
		    return DDERR_INVALIDPARAMS;
		}
		if( !(flags & DDSD_CAPS) )
		{
		    flags |= DDSD_CAPS;	// assume this...
		}
	    }
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * if this is a request for what can be created, do it.
     */
    if( dwFlags & DDENUMSURFACES_CANBECREATED )
    {
	BOOL	        do_rgb=FALSE;
	BOOL	        do_fourcc=FALSE;
	BOOL	        do_dim=FALSE;
	LPDDPIXELFORMAT pdpf;
	DWORD	        i;
	DWORD	        mode;
	DWORD	        dimension_cnt;
	struct	        _dim
	{
	    DWORD       dwWidth;
	    DWORD       dwHeight;
	} *dim;
	DWORD		fourcc_cnt;
	struct		_fourcc
	{
	    DWORD	fourcc;
	    BOOL	is_fourcc;
	    BOOL	is_rgb;
	    DWORD	dwBPP;
	    DWORD	dwRBitMask;
	    DWORD	dwGBitMask;
	    DWORD	dwBBitMask;
	    DWORD       dwAlphaBitMask;
	} *fourcc;
	BOOL		done;
	BOOL            is_primary;
        DWORD           dwNumModes;
        LPDDHALMODEINFO lpModeInfo;

#ifndef WIN95
        LPCTSTR             pszDevice;
        DEVMODE             dm;
        DWORD               dwMaxModes;

        if (_stricmp(this->cDriverName, "DISPLAY"))
        {
            pszDevice = this->cDriverName;
        }
        else
        {
            pszDevice = NULL;
        }

        dwMaxModes = 256;
        lpModeInfo = MemAlloc(dwMaxModes * sizeof (*lpModeInfo));
        if (lpModeInfo == NULL)
        {
	    LEAVE_DDRAW();
            return DDERR_OUTOFMEMORY;
        }

        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;
        for (mode = 0, dwNumModes = 0;
            EnumDisplaySettings(pszDevice, mode, &dm); mode++)
        {
            if (dm.dmBitsPerPel >= 8)
            {
                lpModeInfo[dwNumModes].dwWidth = (WORD)dm.dmPelsWidth;
                lpModeInfo[dwNumModes].dwHeight = (WORD)dm.dmPelsHeight;
                lpModeInfo[dwNumModes].dwBPP = (WORD)dm.dmBitsPerPel;
                lpModeInfo[dwNumModes].wRefreshRate = (WORD)dm.dmDisplayFrequency;

                switch (dm.dmBitsPerPel)
                {
                case 8:
                    break;

                case 15:
                    lpModeInfo[dwNumModes].dwRBitMask = 0x7C00;
                    lpModeInfo[dwNumModes].dwGBitMask = 0x03E0;
                    lpModeInfo[dwNumModes].dwBBitMask = 0x001F;
                    lpModeInfo[dwNumModes].dwAlphaBitMask = 0;
                    lpModeInfo[dwNumModes].dwBPP = 16;
                    break;

                case 16:
                    if (this->lpModeInfo->dwBPP == 16)
                    {
                        lpModeInfo[dwNumModes].dwRBitMask = this->lpModeInfo->dwRBitMask;
                        lpModeInfo[dwNumModes].dwGBitMask = this->lpModeInfo->dwGBitMask;
                        lpModeInfo[dwNumModes].dwBBitMask = this->lpModeInfo->dwBBitMask;
                        lpModeInfo[dwNumModes].dwAlphaBitMask = this->lpModeInfo->dwAlphaBitMask;
                    }
                    else
                    {
                        lpModeInfo[dwNumModes].dwRBitMask = 0xF800;
                        lpModeInfo[dwNumModes].dwGBitMask = 0x07E0;
                        lpModeInfo[dwNumModes].dwBBitMask = 0x001F;
                        lpModeInfo[dwNumModes].dwAlphaBitMask = 0;
                    }
                    break;

                case 24:
                case 32:
                    lpModeInfo[dwNumModes].dwRBitMask = 0x00FF0000;
                    lpModeInfo[dwNumModes].dwGBitMask = 0x0000FF00;
                    lpModeInfo[dwNumModes].dwBBitMask = 0x000000FF;
                    lpModeInfo[dwNumModes].dwAlphaBitMask = 0;
                    break;
                }

                dwNumModes++;

                if (dwNumModes >= dwMaxModes)
                {
                    LPDDHALMODEINFO p = lpModeInfo;

                    dwMaxModes <<= 1;        
                    
                    lpModeInfo = MemAlloc(dwMaxModes * sizeof (*lpModeInfo));
                    if (lpModeInfo != NULL)
                    {
                        CopyMemory(lpModeInfo, p,
                            (dwMaxModes >> 1) * sizeof(*lpModeInfo));
                    }
                    
                    MemFree(p);

                    if (lpModeInfo == NULL)
                    {
	                LEAVE_DDRAW();
                        return DDERR_OUTOFMEMORY;
                    }
                }
            }
        }
#else
        dwNumModes = this->dwNumModes;
        lpModeInfo = this->lpModeInfo;
#endif

        dim = MemAlloc( sizeof(*dim) * dwNumModes );
        fourcc = MemAlloc( sizeof(*fourcc) * (dwNumModes+this->dwNumFourCC) );
	if( ( lpDDSD->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) == 0 )
	{
	    is_primary = FALSE;
	}
	else
	{
	    is_primary = TRUE;
	}
	pdpf = &(lpDDSD->ddpfPixelFormat);
	if( lpDDSD->dwFlags & DDSD_PIXELFORMAT )
	{
	    if( pdpf->dwFlags & DDPF_YUV )
	    {
	        do_fourcc = TRUE;
	    }
	    if( pdpf->dwFlags & DDPF_RGB )
	    {
	        do_rgb = TRUE;
	    }
	}
	if( !(lpDDSD->dwFlags & DDSD_HEIGHT) && !is_primary )
	{
	    do_dim = TRUE;
	}
	
	// set up dimension iteration
	dimension_cnt = 0;
	if( do_dim )
	{
	    for(mode=0, dimension_cnt = 0; mode < dwNumModes; mode++)
	    {
	        for(i=0; i<dimension_cnt; i++)
	        {
		    if( ( lpModeInfo[mode].dwWidth == dim[i].dwWidth ) &&
		        ( lpModeInfo[mode].dwHeight == dim[i].dwHeight ) )
		    {
		        break;
		    }
	        }
	        if( i == dimension_cnt )
	        {
		    // we found a new height and width
		    dim[dimension_cnt].dwWidth = lpModeInfo[mode].dwWidth;
		    dim[dimension_cnt].dwHeight = lpModeInfo[mode].dwHeight;
		    dimension_cnt++;
	        }
	    }
	}
	else
	{
	    // No dimension iteration required.
	    dimension_cnt = 1;
	    dim[0].dwWidth = lpDDSD->dwWidth;
	    dim[0].dwHeight = lpDDSD->dwHeight;
	}

	// set up fourcc/rgb iteration
	fourcc_cnt = 0;
	if( do_rgb )
	{
	    for(mode=0; mode < dwNumModes; mode++)
	    {
                for(i=0; i<fourcc_cnt; i++)
	        {
		    if( ( lpModeInfo[mode].dwBPP == (WORD)fourcc[i].dwBPP) &&
                        ( lpModeInfo[mode].dwRBitMask = fourcc[i].dwRBitMask ) &&
                        ( lpModeInfo[mode].dwGBitMask = fourcc[i].dwGBitMask ) &&
                        ( lpModeInfo[mode].dwBBitMask = fourcc[i].dwBBitMask ) &&
                        ( lpModeInfo[mode].dwAlphaBitMask = fourcc[i].dwAlphaBitMask ) )
		    {
		        break;
		    }
	        }
	        if( i == fourcc_cnt )
	        {
		    // we found a rgb format
		    fourcc[fourcc_cnt].dwBPP = (DWORD)lpModeInfo[mode].dwBPP;
		    fourcc[fourcc_cnt].dwRBitMask = lpModeInfo[mode].dwRBitMask;
		    fourcc[fourcc_cnt].dwGBitMask = lpModeInfo[mode].dwGBitMask;
		    fourcc[fourcc_cnt].dwBBitMask = lpModeInfo[mode].dwBBitMask;
		    fourcc[fourcc_cnt].dwAlphaBitMask = lpModeInfo[mode].dwAlphaBitMask;
		    fourcc[fourcc_cnt].is_fourcc = FALSE;
		    fourcc[fourcc_cnt].is_rgb = TRUE;
		    fourcc_cnt++;
	        }
	    }
	}

	if( do_fourcc )
	{
	    for(mode=0; mode < this->dwNumFourCC; mode++)
	    {
		// store the new fourcc code
		fourcc[fourcc_cnt].fourcc = this->lpdwFourCC[ mode ];
		fourcc[fourcc_cnt].is_fourcc = TRUE;
		fourcc[fourcc_cnt].is_rgb = FALSE;
		fourcc_cnt++;
 	    }
	}
	if( fourcc_cnt == 0 )
	{
	    fourcc_cnt = 1;
	    fourcc[0].is_rgb = FALSE;
	    fourcc[0].is_fourcc = FALSE;
	}
	
	// iterate through all the possibilities...
	if( !is_primary )
	{
	    lpDDSD->dwFlags |= DDSD_HEIGHT;
	    lpDDSD->dwFlags |= DDSD_WIDTH;
	}
	done = FALSE;
	for(mode=0; mode<dimension_cnt; mode++)
	{
	    lpDDSD->dwWidth = dim[mode].dwWidth;
	    lpDDSD->dwHeight = dim[mode].dwHeight;
	    for(i=0; i<fourcc_cnt; i++)
	    {
		if( fourcc[i].is_fourcc )
		{
		    pdpf->dwFlags = DDPF_YUV;
		    pdpf->dwFourCC = fourcc[i].fourcc;
		}
		else if( fourcc[i].is_rgb )
		{
		    pdpf->dwFlags = DDPF_RGB;
		    if( fourcc[i].dwBPP == 8 )
		    {
			pdpf->dwFlags |= DDPF_PALETTEINDEXED8;
		    }
		    pdpf->dwRGBBitCount = fourcc[i].dwBPP;
		    pdpf->dwRBitMask = fourcc[i].dwRBitMask;
		    pdpf->dwGBitMask = fourcc[i].dwGBitMask;
		    pdpf->dwBBitMask = fourcc[i].dwBBitMask;
		    pdpf->dwRGBAlphaBitMask = fourcc[i].dwAlphaBitMask;
		}
		
		done = FALSE;
		// The surface desc is set up, now try to create the surface
                // This will create a surface4-vtabled surface if on IDirectDraw4 int or higher
		ddrval = InternalCreateSurface( this_lcl, lpDDSD, &psurf, this_int, NULL, 0 );
		if( ddrval == DD_OK )
		{
		    FillDDSurfaceDesc2( ((LPDDRAWI_DDRAWSURFACE_INT)psurf)->lpLcl, &dsd );

                    /*
                     * Possible regression risk: make sure only DDSURFACEDESC size passed to
                     * old interfaces
                     */
                    if (LOWERTHANDDRAW4(this_int))
                    {
                        dsd.dwSize = sizeof(DDSURFACEDESC);
                    }

		    rc = lpEnumCallback( NULL,  &dsd, lpContext );
		    InternalSurfaceRelease((LPDDRAWI_DDRAWSURFACE_INT)psurf, FALSE, FALSE );
		}
		if( done )
		{
		    break;
		}
	    }
	    if( done )
	    {
		break;
	    }
	}

	LEAVE_DDRAW();
	MemFree( dim );
	MemFree( fourcc );
#ifndef WIN95
        MemFree( lpModeInfo );
#endif        
        return DD_OK;
    }

    /*
     * if it isn't a request for what exists already, then FAIL
     */
    if( !(dwFlags & DDENUMSURFACES_DOESEXIST) )
    {
        DPF(0,"Invalid Flags. You must specify at least DDENUMSURFACES_DOESEXIST or DDENUMSURFACES_CANBECREATED");
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * run through all surfaces, seeing which ones we need
     */
    curr_int = this->dsList;
    while( curr_int != NULL )
    {
	curr_lcl = curr_int->lpLcl;
        curr = curr_lcl->lpGbl;
	// only enumerate the surface if it belongs to the calling local object
        if( curr_lcl->lpSurfMore->lpDD_lcl == this_lcl )
        {
    	    needit = FALSE;

            /*
             * Execute buffers are invisible to the user level API so
             * ensure we never show the user one of those.
             */
            if( !( curr_lcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER ) )
            {
    	        if( dwFlags & DDENUMSURFACES_ALL )
    	        {
    	            needit = TRUE;
    	        }
    	        else
    	        {
    	            needit = tryMatch( curr_lcl, lpDDSD );
    	            if( dwFlags & DDENUMSURFACES_NOMATCH )
    	            {
    		        needit = !needit;
    	            }
    	        }
            }
    	    if( needit )
    	    {
                LPDIRECTDRAWSURFACE4 returnedInt = (LPDIRECTDRAWSURFACE4) curr_int;

    	        FillDDSurfaceDesc2( curr_lcl, &dsd );
                if (LOWERTHANDDRAW4(this_int))
                {
    	            DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) curr_int , &IID_IDirectDrawSurface, (void**) & returnedInt);
                    dsd.dwSize = sizeof(DDSURFACEDESC);
                }
                else if (this_int->lpVtbl == &dd4Callbacks)
                {
    	            DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) curr_int , &IID_IDirectDrawSurface4, (void**) & returnedInt);
                }
                else
                {
    	            DD_Surface_QueryInterface( (LPDIRECTDRAWSURFACE) curr_int , &IID_IDirectDrawSurface7, (void**) & returnedInt);
                }

    	        rc = lpEnumCallback( returnedInt, &dsd, lpContext );
    	        if( rc == 0 )
    	        {
    		    break;
    	        }
    	    }
        }
        curr_int = curr_int->lpLink;
    }
    LEAVE_DDRAW();
    return DD_OK;

} /* DD_EnumSurfaces */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddcolor.c ===
/*==========================================================================
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcolor.c
 *  Content: 	Implements the DirectDrawColorControl interface, which
 *              allows controlling the colors in a primary or overlay surface.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   13-sept-96	scottm	created
 *   03-mar-97	scottm	Save/restore color when the surace is released
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME "DirectDrawColorControl"


/*
 * DD_Color_GetColorControls
 */
HRESULT DDAPI DD_Color_GetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor )
{
    LPDDHALCOLORCB_COLORCONTROL	pfn;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    DDHAL_COLORCONTROLDATA      ColorData;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Color_GetColorControls");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDCC;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    	if( (NULL == lpColor ) || !VALID_DDCOLORCONTROL_PTR( lpColor ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    pfn = pdrv_lcl->lpDDCB->HALDDColorControl.ColorControl;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	ColorData.lpDD = pdrv_lcl->lpGbl;
    	ColorData.lpDDSurface = this_lcl;
	ColorData.dwFlags = DDRAWI_GETCOLOR;
	ColorData.lpColorData = lpColor;

	DOHALCALL( ColorControl, pfn, ColorData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != ColorData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return ColorData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * DD_Color_SetColorControls
 */
HRESULT DDAPI DD_Color_SetColorControls(LPDIRECTDRAWCOLORCONTROL lpDDCC, LPDDCOLORCONTROL lpColor )
{
    LPDDHALCOLORCB_COLORCONTROL	pfn;
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    DDHAL_COLORCONTROLDATA ColorData;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Color_SetColorControls");

    /*
     * Validate parameters
     */
    TRY
    {
    	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDCC;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
    	if( (NULL == lpColor ) || !VALID_DDCOLORCONTROL_PTR( lpColor ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * If this is the first time, we want to save the current color settings
     * so we can restore them when the app exists.
     */
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( this_lcl->lpGbl );
    if( lpSurfGblMore->lpColorInfo == NULL )
    {
	DDCOLORCONTROL ddTempColor;
	HRESULT ddRVal;

	ddTempColor.dwSize = sizeof( ddTempColor );
	ddRVal = DD_Color_GetColorControls( lpDDCC, &ddTempColor );
	if( ddRVal == DD_OK )
	{
	    lpSurfGblMore->lpColorInfo = MemAlloc( sizeof( ddTempColor ) );
	    if( lpSurfGblMore->lpColorInfo != NULL )
	    {
		memcpy( lpSurfGblMore->lpColorInfo, &ddTempColor,
		    sizeof( ddTempColor ) );
	    }
	}
    }

    pfn = pdrv_lcl->lpDDCB->HALDDColorControl.ColorControl;
    if( pfn != NULL )
    {
	/*
	 * Call the HAL
	 */
    	ColorData.lpDD = pdrv_lcl->lpGbl;
    	ColorData.lpDDSurface = this_lcl;
	ColorData.dwFlags = DDRAWI_SETCOLOR;
	ColorData.lpColorData = lpColor;

	DOHALCALL( ColorControl, pfn, ColorData, rc, 0 );
	if( DDHAL_DRIVER_HANDLED != rc )
    	{
    	    LEAVE_DDRAW();
    	    return DDERR_UNSUPPORTED;
    	}
	else if( DD_OK != ColorData.ddRVal )
	{
	    LEAVE_DDRAW();
	    return ColorData.ddRVal;
	}
    }
    else
    {
    	LEAVE_DDRAW();
    	return DDERR_UNSUPPORTED;
    }

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * ReleaseColorControl
 */
VOID ReleaseColorControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface )
{
    LPDDHALCOLORCB_COLORCONTROL	pfn;
    DDHAL_COLORCONTROLDATA ColorData;
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpSurfGblMore;
    DWORD rc;

    ENTER_DDRAW();

    /*
     * Restore the hardware if the color controls were changed
     */
    pdrv_lcl = lpSurface->lpSurfMore->lpDD_lcl;
    lpSurfGblMore = GET_LPDDRAWSURFACE_GBL_MORE( lpSurface->lpGbl );
    if( lpSurfGblMore->lpColorInfo != NULL )
    {
    	pfn = pdrv_lcl->lpDDCB->HALDDColorControl.ColorControl;
    	if( pfn != NULL )
    	{
	    /*
	     * Call the HAL
	     */
    	    ColorData.lpDD = pdrv_lcl->lpGbl;
    	    ColorData.lpDDSurface = lpSurface;
	    ColorData.dwFlags = DDRAWI_SETCOLOR;
	    ColorData.lpColorData = lpSurfGblMore->lpColorInfo;

	    DOHALCALL( ColorControl, pfn, ColorData, rc, 0 );
	}

	/*
	 * Now release the previously allocated memory
	 */
	MemFree( lpSurfGblMore->lpColorInfo );
	lpSurfGblMore->lpColorInfo = NULL;
    }

    LEAVE_DDRAW();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddfake.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddfake.c
 *  Content:	fake out that we are a driver (for HEL)
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-mar-95	craige 	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   30-jun-95	craige	turned off > 16bpp
 *   04-jul-95	craige	YEEHAW: new driver struct
 *   15-jul-95	craige	set DDCAPS_NOHARDWARE
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   22-jul-95	craige	emulation only needs to initialize correctly
 *   19-dec-95  jeffno  Counting number of modes in BuildModes fails if only 1 mode available\
 *   09-jan-96	kylej	re-enable > 16bpp modes
 *   13-mar-96  jeffno  Buildmodes not called under NT. Fix a >16bpp problem.
 *   19-apr-96  colinmc Bug 18059: New driver caps bit to indicate that a
 *                      driver can't interleave 2D and 3D operations in a
 *                      3D scene
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   15-oct-96  toddla  multimonitor support
 *   17-jan-97  colinmc Fixed problem with multimonitor on emulated displays
 *
 ***************************************************************************/
#include "ddrawpr.h"

static DWORD ropsSupported[DD_ROP_SPACE] = {
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

/*
 * getBitMask
 */
BOOL getBitMask( LPDDHALMODEINFO pmi )
{
    pmi->wFlags = 0;
    if( pmi->dwBPP == 8 )
    {
	pmi->wFlags |= DDMODEINFO_PALETTIZED;
    }
    switch( pmi->dwBPP )
    {
    case 8:
	pmi->dwRBitMask = 0;
	pmi->dwGBitMask = 0;
	pmi->dwBBitMask = 0;
	break;
    case 16:
	pmi->dwRBitMask = 0xf800;
	pmi->dwGBitMask = 0x07e0;
	pmi->dwBBitMask = 0x001f;
	break;
    case 24:
	pmi->dwRBitMask = 0xff0000;
	pmi->dwGBitMask = 0x00ff00;
	pmi->dwBBitMask = 0x0000ff;
	break;
    case 32:
	pmi->dwRBitMask = 0xff0000;
	pmi->dwGBitMask = 0x00ff00;
	pmi->dwBBitMask = 0x0000ff;
	break;
    default:
    	return FALSE;
    }
    return TRUE;

} /* getBitMask */

/*
 * getDisplayMode
 *
 * get the current display settings
 */
static BOOL getDisplayMode( HDC hdc, LPDDHALMODEINFO pmi, DWORD FAR *pfreq )
{
    if( hdc != NULL )
    {
	pmi->dwBPP = GetDeviceCaps( hdc, BITSPIXEL ) * GetDeviceCaps( hdc, PLANES );
	*pfreq = GetDeviceCaps( hdc, VREFRESH );
	pmi->dwWidth = GetDeviceCaps( hdc, HORZRES );
	pmi->dwHeight = GetDeviceCaps( hdc, VERTRES );
	pmi->lPitch = GetDeviceCaps( hdc, DESKTOPHORZRES );
	DPF( 5, "getDisplayMode:" );
	DPF( 5, "    bpp=%ld, refresh=%ld", pmi->dwBPP, *pfreq );
	DPF( 5, "    dwHeight=%ld, dwWidth=%ld", pmi->dwHeight, pmi->dwWidth );
	DPF( 5, "    lStride=%ld", pmi->lPitch );
	getBitMask( pmi );
    }
    else
    {
	return FALSE;
    }
    return TRUE ;

} /* getDisplayMode */

/*
 * BuildModes
 *
 * build a HAL mode info array by using EnumDisplaySettings
 */
DWORD BuildModes( LPSTR szDevice, LPDDHALMODEINFO FAR *ppddhmi )
{
    DWORD		nummodes;
    DWORD               maxmodes;
    DWORD		cmode;
    DEVMODE		dm0;
    DEVMODE		dm;
    LPDDHALMODEINFO     pmi;

    ZeroMemory(&dm0,sizeof(dm0));
    ZeroMemory(&dm,sizeof(dm));
    dm0.dmSize = dm.dmSize = sizeof(dm0);

    /*
     * count the number of modes
     */
    nummodes = 0;
    cmode = 0;
    while( 1 )
    {
	if( cmode == 0 )
	{
            if( !EnumDisplaySettings( szDevice, cmode, &dm0 ) )
	    {
		break;
	    }
	}
	else
	{
            if( !EnumDisplaySettings( szDevice, cmode, &dm ) )
	    {
		break;
	    }
	}
	cmode++;
    	if( cmode==1 ? dm0.dmBitsPerPel >= 8 : dm.dmBitsPerPel >= 8 ) //was incorrectly counting when only 1 mode.
	{
	    nummodes++;
	}
    }
    DPF( 5, "Driver says nummodes=%d", nummodes );
    if( nummodes == 0 )
    {
	*ppddhmi = NULL;
	return 0;
    }

    /*
     * allocate some memory to hold all the mode data
     */
    pmi = MemAlloc( nummodes * sizeof( DDHALMODEINFO ) );
    if( pmi == NULL )
    {
	*ppddhmi = NULL;
	return 0;
    }

    /*
     * go get the mode data
     */
    cmode = 0;
    maxmodes = nummodes;
    nummodes = 0;
    while( 1 )
    {
        if (nummodes >= maxmodes)
        {
            break;
        }
	if( cmode == 0 )
	{
	    dm = dm0;
	}
	else
	{
            if( !EnumDisplaySettings( szDevice, cmode, &dm ) )
	    {
		break;
	    }
	}
	cmode++;
	/*
	 * don't care about 4bpp or 1bpp modes...
	 */
	if( dm.dmBitsPerPel < 8 )
	{
	    continue;
	}
    	pmi[nummodes].dwWidth = dm.dmPelsWidth;
    	pmi[nummodes].dwHeight = dm.dmPelsHeight;
    	pmi[nummodes].lPitch = dm.dmPelsWidth;
    	pmi[nummodes].dwBPP = dm.dmBitsPerPel;
    	pmi[nummodes].dwAlphaBitMask = 0;
	getBitMask( &pmi[nummodes] );
	nummodes++;
    }
    DPF( 5, "Enum Display Settings says nummodes=%d", nummodes );

    *ppddhmi = pmi;
    return nummodes;

} /* BuildModes */

/*
 * BuildPixelFormat
 *
 * generate a pixel format structure based on the mode
 */
void BuildPixelFormat(
                HDC             hdc,
		LPDDHALMODEINFO pmi,
		LPDDPIXELFORMAT pdpf )
{
    HBITMAP	    hbm;
    BITMAPINFO	    *pbmi;

    pdpf->dwSize = sizeof( DDPIXELFORMAT );
    pdpf->dwYUVBitCount = 0;
    pdpf->dwYBitMask = 0;
    pdpf->dwUBitMask = 0;
    pdpf->dwVBitMask = 0;
    pdpf->dwYUVAlphaBitMask = 0;
    pdpf->dwFourCC = 0;

    pdpf->dwFlags = DDPF_RGB;
    if( pmi->wFlags & DDMODEINFO_PALETTIZED )
    {
	pdpf->dwFlags |= DDPF_PALETTEINDEXED8;
    }
    pdpf->dwRGBBitCount = pmi->dwBPP;

    /*
     * This looks suspiciously like it was intended to run on 8 or 16 bpp
     * and nothing else. I changed it so we do this for 24 and 32 bpp
     * modes as well. jeffno 960610
     */
    if( pmi->dwBPP != 8 && hdc)
    {
        pbmi = (BITMAPINFO *)MemAlloc( sizeof( BITMAPINFOHEADER ) + 256 * 4 );
	if( pbmi )
	{
	    hbm = CreateCompatibleBitmap(hdc, 1, 1);
            if (hbm == NULL)
            {
                DPF( 0, "CreateCompatibleBitmap failed; unable to build pixel format");
            }
            else
            {
	        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
	        pbmi->bmiHeader.biBitCount = 0;
	        GetDIBits(hdc, hbm, 0, 1, NULL, pbmi, DIB_RGB_COLORS);
	        pbmi->bmiHeader.biClrUsed = 0;
	        pbmi->bmiHeader.biCompression = BI_BITFIELDS;
	        GetDIBits(hdc, hbm, 0, 1, NULL, pbmi, DIB_RGB_COLORS);

	        pmi->dwRBitMask = *(long*)&(pbmi->bmiColors[0]);
	        pmi->dwGBitMask = *(long*)&(pbmi->bmiColors[1]);
	        pmi->dwBBitMask = *(long*)&(pbmi->bmiColors[2]);

	        DeleteObject( hbm );
            }
	    MemFree( pbmi );
	}
    }

    pdpf->dwRBitMask = pmi->dwRBitMask;
    pdpf->dwGBitMask = pmi->dwGBitMask;
    pdpf->dwBBitMask = pmi->dwBBitMask;
    pdpf->dwRGBAlphaBitMask = pmi->dwAlphaBitMask = 0;
    DPF(5, "Masks for current mode are: %08x %08x %08x", pdpf->dwRBitMask, pdpf->dwGBitMask, pdpf->dwBBitMask);
} /* BuildPixelFormat */

/*
 * FakeDDCreateDriverObject
 *
 * fake up that we are a driver that can't do anything...
 */
LPDDRAWI_DIRECTDRAW_GBL FakeDDCreateDriverObject(
                HDC hdc_dd,
                LPSTR szDrvName,
		LPDDRAWI_DIRECTDRAW_GBL pdd_old,
		BOOL reset,
                HANDLE hDDVxd )
{
    DDHALINFO			ddhi;
    LPDDRAWI_DIRECTDRAW_GBL	pdd;
    DDPIXELFORMAT		dpf;
    LPDDHALMODEINFO		pmi;
    DDHALMODEINFO		cmodeinfo;
    DWORD                       freq;
    LPSTR                       szDevice;

    if( (szDrvName != NULL) && (_stricmp(szDrvName, "DISPLAY") != 0) )
        szDevice = szDrvName;
    else
        szDevice = NULL;

    /*
     * initialize the DDHALINFO struct
     */
    memset( &ddhi, 0, sizeof( ddhi ) );
    ddhi.dwSize = sizeof( ddhi );

    /*
     * capabilities supported (none)
     */
    ddhi.ddCaps.dwCaps = DDCAPS_NOHARDWARE;
    ddhi.ddCaps.dwCaps2 = 0;
    ddhi.ddCaps.dwFXCaps = 0;
    ddhi.ddCaps.dwCKeyCaps = 0;
    ddhi.ddCaps.ddsCaps.dwCaps = 0;

    /*
     * pointer to primary surface
     */
    ddhi.vmiData.fpPrimary = 0;

    /*
     * build mode and pixel format info
     */
    pmi = &cmodeinfo;
    if( !getDisplayMode( hdc_dd, pmi, &freq ) )
    {
        DPF( 0, "Could not get base mode" );
	return NULL;
    }
    #if WIN95
    {
	int	i;
        ddhi.dwNumModes = BuildModes( szDevice, &ddhi.lpModeInfo );
	ddhi.dwModeIndex = (DWORD)-1;
	for( i=0;i<(int)ddhi.dwNumModes;i++ )
	{
	    if( (ddhi.lpModeInfo[i].dwBPP == pmi->dwBPP) &&
	    	(ddhi.lpModeInfo[i].dwHeight == pmi->dwHeight) &&
	    	(ddhi.lpModeInfo[i].dwWidth == pmi->dwWidth) )
	    {
		ddhi.dwModeIndex = i;
		DPF( 5, "dwModeIndex = %d", i );
		break;
	    }
	}
    }
    #else
    {
        if (!GetCurrentMode(pdd_old, &ddhi, szDrvName))
        {
            DPF(0, "Could not get current mode information");
            return NULL;
        }
    }
    #endif

    ddhi.vmiData.dwDisplayHeight = pmi->dwHeight;
    ddhi.vmiData.dwDisplayWidth = pmi->dwWidth;
    ddhi.vmiData.lDisplayPitch = pmi->lPitch;

    /*
     * set up pixel format of primary surface
     */
    BuildPixelFormat( hdc_dd, pmi, &dpf );
    ddhi.vmiData.ddpfDisplay = dpf;

    /*
     * fourcc code information
     */
    ddhi.ddCaps.dwNumFourCCCodes = 0;
    ddhi.lpdwFourCC = NULL;

    /*
     * Fill in heap info
     */
    ddhi.vmiData.dwNumHeaps = 0;
    ddhi.vmiData.pvmList = NULL;

    /*
     * required alignments of the scanlines of each kind of memory
     * (DWORD is the MINIMUM)
     */
    ddhi.vmiData.dwOffscreenAlign = sizeof( DWORD );
    ddhi.vmiData.dwOverlayAlign = sizeof( DWORD );
    ddhi.vmiData.dwTextureAlign = sizeof( DWORD );
    ddhi.vmiData.dwAlphaAlign = sizeof( DWORD );
    ddhi.vmiData.dwZBufferAlign = sizeof( DWORD );

    /*
     * callback functions
     */
    ddhi.lpDDCallbacks = NULL;
    ddhi.lpDDSurfaceCallbacks = NULL;
    ddhi.lpDDPaletteCallbacks = NULL;

    /*
     * create the driver object
     */
    pdd = DirectDrawObjectCreate( &ddhi, reset, pdd_old, hDDVxd, szDrvName, 0, 0 /* ATTENTION: No lcl flags in emulation */ );

    if( pdd != NULL )
    {
	pdd->dwFlags |= DDRAWI_NOHARDWARE;
        pdd->dwFlags |= DDRAWI_DISPLAYDRV;
        pdd->dwFlags |= DDRAWI_GDIDRV;

        lstrcpy(pdd->cDriverName, szDrvName);

        /*
    	 * get mode info from HEL
     	 */
    	{
	    void UpdateDirectDrawMode( LPDDRAWI_DIRECTDRAW_GBL this );
	    UpdateDirectDrawMode( pdd );
    	}
    }

    MemFree( ddhi.lpModeInfo );

    return pdd;

} /* FakeDDCreateDriverObject */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\dddefwp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddefwp.c
 *  Content:    DirectDraw processing of Window messages
 *              Takes care of palette changes, mode setting
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   26-mar-95  craige  initial implementation
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-may-95  craige  use driver-level csects only
 *   02-jun-95  craige  flesh it out
 *   06-jun-95  craige  added SetAppHWnd
 *   07-jun-95  craige  more fleshing...
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  new surface structure
 *   25-jun-95  craige  one ddraw mutex
 *   30-jun-95  kylej   use GetProcessPrimary instead of lpPrimarySurface
 *                      invalidate all primary surfaces upon focus lost
 *                      or regained.
 *   30-jun-95  craige  minimze window for CAD, ALT-TAB, ALT-ESC or CTRL-ESC
 *   04-jul-95  craige  YEEHAW: new driver struct
 *   06-jul-95  craige  prevent reentry
 *   08-jul-95  craige  allow dsound to share
 *   08-jul-95  kylej   remove call to ResetSysPalette
 *   11-jul-95  craige  DSoundHelp & internalSetAppHWnd needs to take a pid
 *   13-jul-95  craige  first step in mode set fix; made it work.
 *   15-jul-95  craige  unhook at WM_DESTROY; don't escape on ALT; do a
 *                      SetActiveWindow( NULL ) to stop tray from showing
 *                      our button as depressed
 *   17-jul-95  craige  don't process hot key messages & activation messages
 *                      for non-excl mode apps; SetActiveWindow is bogus,
 *                      get bottom window in Z order and make it foreground
 *   18-jul-95  craige  use flags instead of refcnt to track WININFO
 *   29-jul-95  toddla  make ALT+TAB and CTRL+ESC work.
 *   31-jul-95  toddla  make ALT+TAB and CTRL+ESC work better.
 *   09-aug-95  craige  bug 424 - allow switching to/from apps without primary
 *                      surfaces to work
 *   09-aug-95  craige  bug 404 - don't pass WM_ACTIVATEAPP messages to dsound
 *                      if app iconic
 *   10-aug-95  toddla  check WININFO_DSOUNDHOOKED before calling DSound
 *   10-aug-95  toddla  handle unhooking after/during WM_DESTROY right.
 *   13-aug-95  toddla  added WININFO_ACTIVELIE
 *   23-aug-95  craige  bug 388,610
 *   25-aug-95  craige  bug 709
 *   27-aug-95  craige  bug 735: call SetPaletteAlways
 *   04-sep-95  craige  bug 894: force mode set when activating
 *   09-sep-95  toddla  dont send nested WM_ACTIVATEAPP messages
 *   26-sep-95  craige  bug 1364: use new csect to avoid dsound deadlock
 *   09-jan-96  kylej   new interface structures
 *   13-apr-96  colinmc Bug 17736: No notification to driver of flip to GDI
 *   20-apr-96  kylej   Bug 16747: Make exclusive window visible if it is not.
 *   23-apr-96  kylej   Bug 14680: Make sure exclusive window is not maximized.
 *   16-may-96  kylej   Bug 23013: pass the correct flags to StartExclusiveMode
 *   17-may-96  colinmc Bug 23029: Alt-tabbing straight back to a full screen
 *                      does not send the app an WM_ACTIVATEAPP
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   16-oct-96  colinmc Added PrintScreen support to allow screen grabbing
 *   05-feb-96  ketand  Bug 1749: Alt-Tab from fullscreen app would cause cycling when
 *                      the only other window running is the Start::Run window.
 *   03-mar-97  jeffno  Structure name change to avoid conflict w/ ActiveAccessibility
 *   24-mar-97  colinmc Bug 6913: Enable ModeX PRINTSCREEN
 *
 ***************************************************************************/
#include "ddrawpr.h"

#define TOPMOST_ID      0x4242
#define TOPMOST_TIMEOUT 1500

#define USESHOWWINDOW

#ifdef WIN95
    extern CRITICAL_SECTION     csWindowList;
    #define ENTERWINDOWLISTCSECT    EnterCriticalSection( &csWindowList );
    #define LEAVEWINDOWLISTCSECT    LeaveCriticalSection( &csWindowList );
#elif defined(WINNT)
    extern HANDLE hWindowListMutex;
    #define ENTERWINDOWLISTCSECT    WaitForSingleObject(hWindowListMutex,INFINITE);
    #define LEAVEWINDOWLISTCSECT    ReleaseMutex(hWindowListMutex);
#else
    #error "Win95 or winnt- make up your mind!"
#endif

#ifndef ENUM_CURRENT_SETTINGS
#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#endif


/*
 * DD_GetDeviceRect
 *
 * get the rect in screen space for this device.
 * on a single monitor system this is (0,0) - (SM_CXSCREEN,SM_CYSCREEN)
 */
BOOL DD_GetDeviceRect(LPDDRAWI_DIRECTDRAW_GBL pdrv, RECT *prc)
{
    //
    // this is a non-DISPLAY device for compatibility with DDRAW 3.x
    // we should use the size of the primary display.
    //
    if (!(pdrv->dwFlags & DDRAWI_DISPLAYDRV))
    {
        DPF( 4, "DD_GetDeviceRect: not a display driver, using screen rect.");
        SetRect(prc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
        return TRUE;
    }

    if (_stricmp(pdrv->cDriverName, "DISPLAY") == 0)
    {
        SetRect(prc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
    }
    else
    {
        #ifdef WIN95
            DEVMODE dm;
            ZeroMemory(&dm, sizeof(dm));
            dm.dmSize = sizeof(dm);

            EnumDisplaySettings(pdrv->cDriverName, ENUM_CURRENT_SETTINGS, &dm);

            //
            // the position of the device is in the dmPosition field
            //
            CopyMemory(prc, &dm.dmOrientation, sizeof(RECT));

            if (IsRectEmpty(prc))
            {
                //
                // this device is not attached to the desktop
                // what should we do?
                //
                //      make the window the size of the primary?
                //
                //      put the window out in space?
                //
                //      dont move the window?
                //
                DPF( 4, "DD_GetDeviceRect: device is not attached to desktop.");

                // put window on primary
                SetRect(prc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));

                // put window off in space.
                //SetRect(prc,10000,10000,10000+dm.dmPelsWidth,10000+dm.dmPelsHeight);

                // dont move window
                // return FALSE
            }
        #else
            if( GetNTDeviceRect( pdrv->cDriverName, prc ) != DD_OK )
            {
                DPF( 4, "DD_GetDeviceRect: device is not attached to desktop.");
                SetRect(prc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
            }
        #endif
    }

    DPF( 5, "DD_GetDeviceRect: %s [%d %d %d %d]",pdrv->cDriverName, prc->left, prc->top, prc->right, prc->bottom);
    return TRUE;
}


#ifdef GDIDDPAL
/*
 * getPalette
 *
 * Get a pointer to a palette object.
 * Takes a lock on the driver object and the palette object.
 */
LPDDRAWI_DDRAWPALETTE_LCL getPalette( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    LPDDRAWI_DDRAWPALETTE_LCL   ppal_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;

    if( pdrv_lcl->lpGbl->dwFlags & DDRAWI_HASGDIPALETTE )
    {
        psurf_lcl = pdrv_lcl->lpPrimary;
        if( psurf_lcl != NULL )
        {
            ppal_lcl = psurf_lcl->lpDDPalette;
            return ppal_lcl;
        }
    }

    return NULL;

} /* getPalette */
#endif

static LONG     bHelperStarting=0;
static BOOL     bStartHelper=0;
static BYTE     sys_key=0;
static DWORD    sys_state=0;


/*
 * IsTaskWindow
 */
BOOL IsTaskWindow(HWND hwnd)
{
    DWORD dwStyleEx = GetWindowLong(hwnd, GWL_EXSTYLE);

    // Following windows do not qualify to be shown in task list:
    //   Switch  Window, Hidden windows (unless they are the active
    //   window), Disabled windows, Kanji Conv windows.
    //   Ignore windows that are actually child windows.
    return(((dwStyleEx & WS_EX_APPWINDOW) ||
           !(dwStyleEx & WS_EX_TOOLWINDOW)) &&
            IsWindowVisible(hwnd) &&
            IsWindowEnabled(hwnd) &&
            GetParent(hwnd) == NULL);
}

/*
 * CountTaskWindows
 */
int CountTaskWindows()
{
    HWND hwnd;
    int n;

    for (n=0,
        hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
        hwnd!= NULL;
        hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        if (IsTaskWindow(hwnd))
            n++;
    }

    return n;
}

/*
 * ClipTheCursor
 *
 * A DINPUT app keeps track of movement based on the delta from the last
 * movement.  On a multi-mon system, the delta can be larger than the
 * app's window, but a fullscreen non-multimon aware app might count on
 * windows clipping the mouse to the primary so it could totally break
 * (e.g. Dungeon Keeper).  This hack will clip/unclip the cursor movement
 * to the monitor if the app is not multi-mon aware.
 */
void ClipTheCursor( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, LPRECT lpRect )
{
    /*
     * Only unclip if it was previously clipped
     */
    if( lpRect == NULL )
    {
        if( pdrv_lcl->dwLocalFlags & DDRAWILCL_CURSORCLIPPED )
        {
            pdrv_lcl->dwLocalFlags &= ~DDRAWILCL_CURSORCLIPPED;
            ClipCursor( NULL );
        }
    }

    /*
     * Only clip them if they are not multi-mon aware and they own
     * exclusive mode
     */
    else if( !( pdrv_lcl->dwLocalFlags & DDRAWILCL_EXPLICITMONITOR ) &&
        ( pdrv_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE ) &&
        ( pdrv_lcl->dwLocalFlags & DDRAWILCL_ACTIVEYES ) )
    {
        /*
         * Hack to allow user to use debugger
         */
        #ifdef DEBUG
            if( !( pdrv_lcl->dwLocalFlags & DDRAWILCL_DISABLEINACTIVATE ) )
            {
        #endif
                pdrv_lcl->dwLocalFlags |= DDRAWILCL_CURSORCLIPPED;
                ClipCursor( lpRect );
        #ifdef DEBUG
            }
        #endif
    }
}

//
// make the passed window fullscreen and topmost and set a timer
// to make the window topmost again, what a hack.
//
void MakeFullscreen(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, HWND hwnd)
{
    RECT rc;

    if (DD_GetDeviceRect(pdrv_lcl->lpGbl, &rc))
    {
        SetWindowPos(hwnd, NULL, rc.left, rc.top,
            rc.right - rc.left,rc.bottom - rc.top,
            SWP_NOZORDER | SWP_NOACTIVATE);

        ClipTheCursor( pdrv_lcl, &rc );
    }

    if (GetForegroundWindow() == (HWND)pdrv_lcl->hFocusWnd)
    {
        // If the exclusive mode window is not visible, make it so.
        if(!IsWindowVisible( hwnd ) )
        {
            ShowWindow(hwnd, SW_SHOW);
        }

        SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        // If the exclusive mode window is maximized, restore it.
        if( IsZoomed( hwnd ) )
        {
            ShowWindow(hwnd, SW_RESTORE);
        }
    }
    if( giTopmostCnt < MAX_TIMER_HWNDS )
    {
        ghwndTopmostList[giTopmostCnt++] = hwnd;
    }
    SetTimer( (HWND)pdrv_lcl->hFocusWnd, TOPMOST_ID, TOPMOST_TIMEOUT, NULL);
}

//
// Same as MakeFullscreen only it does it for every DirectDraw object that
// thinks it has hooked the window
//
void MakeAllFullscreen(LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl, HWND hwnd)
{
    LPDDRAWI_DIRECTDRAW_LCL this_lcl;

    /*
     * We need to maintain old behavior in the non-multimon case
     */
    giTopmostCnt = 0;
    MakeFullscreen( pdrv_lcl, (HWND) pdrv_lcl->hWnd );

    /*
     * Don't do this on multimon when de-activating.
     * Hack to minimize singlemon code impact - this function gets called
     * by the WM_DISPLAYCHANGE message, which gets called on a
     * RestoreDisplayMode when leaving exclusive mode on a deactivate.
     * Consider not calling MakeAllFullScreen when DDRAWILCL_ACTIVENO is set
     */
    if (!IsMultiMonitor() ||
        !(pdrv_lcl->dwLocalFlags & DDRAWILCL_ACTIVENO))
    {
        /*
         * Don't enter normal critical section because this is called
         * during WM_DISPLAYCHANGE which could cause problems.
         */
        ENTER_DRIVERLISTCSECT();
        this_lcl = lpDriverLocalList;
        while( this_lcl != NULL )
        {
            if( ( this_lcl != pdrv_lcl ) &&
                ( this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE ) &&
                ( this_lcl->hFocusWnd == (ULONG_PTR) hwnd ) &&
                ( this_lcl->dwLocalFlags & DDRAWILCL_HOOKEDHWND ) &&
                ( this_lcl->hWnd != pdrv_lcl->hWnd ) )
            {
                MakeFullscreen( this_lcl, (HWND)this_lcl->hWnd );
            }
            this_lcl = this_lcl->lpLink;
        }
        LEAVE_DRIVERLISTCSECT();
    }
}

void InternalSetForegroundWindow(HWND hWnd)
{
    DWORD dwTimeout;
    SystemParametersInfo( SPI_GETFOREGROUNDLOCKTIMEOUT, 0, (LPVOID) &dwTimeout, 0 );
    SystemParametersInfo( SPI_SETFOREGROUNDLOCKTIMEOUT, 0, NULL, 0 );
#ifdef WINNT
    //
    // This works around a focus bug. If an app does createwindow,destroywindow,createwindow,
    // then it may not get focus on the second create because some other window stole it in
    // the meantime.
    //
    mouse_event(MOUSEEVENTF_WHEEL,0,0,0,0);
#endif
    SetForegroundWindow(hWnd);
    SystemParametersInfo( SPI_SETFOREGROUNDLOCKTIMEOUT, 0, (LPVOID) ULongToPtr(dwTimeout), 0 );
}
/*
 * handleActivateApp
 */
void handleActivateApp(
        LPDDRAWI_DIRECTDRAW_LCL this_lcl,
        LPDDWINDOWINFO pwinfo,
        BOOL is_active,
        BOOL bFirst )
{
    LPDDRAWI_DDRAWPALETTE_INT   ppal_int;
    LPDDRAWI_DDRAWPALETTE_LCL   ppal_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    DWORD                       pid;
    HRESULT                     ddrval;
    BOOL                        has_excl;
    BOOL                        excl_exists;
    BOOL                        bMinimize = TRUE;

    this = this_lcl->lpGbl;
    pid = GetCurrentProcessId();

    psurf_int = this_lcl->lpPrimary;
    if( psurf_int != NULL )
    {
        psurf_lcl = psurf_int->lpLcl;
        psurf = psurf_lcl->lpGbl;
        ppal_int = psurf_lcl->lpDDPalette;
        if( NULL != ppal_int )
        {
            ppal_lcl = ppal_int->lpLcl;
        }
        else
        {
            ppal_lcl = NULL;
        }
    }
    else
    {
        psurf_lcl = NULL;
        ppal_lcl = NULL;
    }

    /*
     * An app could take exclusive mode just as another app is being activated by alt-tab.
     * Should we do anything about this remote chance?
     */

    CheckExclusiveMode(this_lcl, &excl_exists, &has_excl, TRUE, NULL, FALSE);

    /*
     * stuff to do before the mode set if deactivating
     */
    if( !is_active )
    {
        /*
         * flip back to GDI if deactivating
         */
        if( (psurf_lcl != NULL) && has_excl )
        {
            FlipToGDISurface( this_lcl, psurf_int); //, this->fpPrimaryOrig );
        }

        if( has_excl )
        {
            /*
             * Exclusive mode app losing or gaining focus.
             * If gaining focus, invalidate all non-exclusive mode primary
             * surfaces.  If losing focus, invalidate the exclusive-mode
             * primary surface so that non-exclusive apps can restore
             * their primaries.
             *
             * NOTE: This call MUST come after FlipToGDISurface, or
             * else FlipToGDISurface will fail. craige 7/4/95
             *
             * NOTE: if we are coming in or out of exclusive mode,
             * we need to invalidate all surfaces so that resources are
             * available. craige 7/9/94
             *
             */
            InvalidateAllSurfaces( this, (HANDLE) this_lcl->hDDVxd, TRUE );
        }
    }
    /*
     * stuff to do before mode set if activating
     */
    else
    {
        /*
         * restore exclusive mode. Here we don't release the ref we took on the exclusive mode mutex,
         * since we want to keep the exclusive mode mutex.
         */
        if( this_lcl->dwLocalFlags & DDRAWILCL_ISFULLSCREEN )
        {
            this->dwFlags |= DDRAWI_FULLSCREEN;
        }
        StartExclusiveMode( this_lcl, pwinfo->DDInfo.dwDDFlags, pid );
        has_excl = TRUE;
    }

    /*
     * NOTE: We used to invalidate here but that was strange as it would
     * mean doing the invalidate twice as StartExclusiveMode() always
     * invalidates. So now we only explicitly invalidate if an exlcusive
     * mode app is being deactivated. StartExclusiveMode() handles the
     * other case.
     */

    /*
     * restore hwnd if we are about to be activated
     */
    if ( (pwinfo->DDInfo.dwDDFlags & DDSCL_FULLSCREEN) &&
        !(pwinfo->DDInfo.dwDDFlags & DDSCL_NOWINDOWCHANGES) &&
        IsWindowVisible(pwinfo->hWnd))
    {
        if (is_active)
        {
            pwinfo->dwFlags |= WININFO_SELFSIZE;

            #ifdef USESHOWWINDOW
                ShowWindow(pwinfo->hWnd, SW_SHOWNOACTIVATE);
            #else
            {
                RECT rc;

                if (DD_GetDeviceRect(this, &rc))
                {
                    SetWindowPos(pwinfo->hWnd, NULL,rc.left, rc.top,
                        rc.right  - rc.left,rc.bottom - rc.top,
                        SWP_NOZORDER | SWP_NOACTIVATE);
                }
            }
            #endif

            pwinfo->dwFlags &= ~WININFO_SELFSIZE;
        }
    }

    /*
     * restore the mode
     */
    if( !is_active )
    {
        if( (!excl_exists) || has_excl )
        {
            DPF( 4, "INACTIVE: %08lx: Restoring original mode (%ld)", GetCurrentProcessId(), this->dwModeIndexOrig );
            if( RestoreDisplayMode( this_lcl, TRUE ) == DDERR_UNSUPPORTED )
            {
                #ifdef WINNT
                    /*
                     * If RestoreDisplayMode failed, we are probably on a different desktop.  In this case,
                     * we should not minimize the window or else things won't work right when we switch
                     * back to the original desktop.
                     */
                    HDESK hDesktop;
                    static BYTE szName1[256];
                    static BYTE szName2[256];
                    DWORD dwTemp;

                    // Get the name of the current desktop
                    hDesktop = OpenInputDesktop( 0, FALSE, DESKTOP_READOBJECTS );
                    GetUserObjectInformation( hDesktop, UOI_NAME, szName1, sizeof( szName1 ), &dwTemp );
                    CloseDesktop( hDesktop );

                    // Get the name of the apps' desktop
                    hDesktop = GetThreadDesktop( GetCurrentThreadId() );
                    GetUserObjectInformation( hDesktop, UOI_NAME, szName2, sizeof( szName2 ), &dwTemp );
                    if( lstrcmp( szName1, szName2 ) )
                    {
                        bMinimize = FALSE;
                    }
                #endif
            }
        }
    }
    else
    {
        DPF( 4, "ACTIVE: %08lx: Setting app's preferred mode (%ld)", GetCurrentProcessId(), this_lcl->dwPreferredMode );
        SetDisplayMode( this_lcl, this_lcl->dwPreferredMode, TRUE, TRUE );
    }

    /*
     * stuff to do after the mode set if activating
     */
    if( is_active )
    {
        /*
         * restore the palette
         */
        if( ppal_lcl != NULL )
        {
            ddrval = SetPaletteAlways( psurf_int, (LPDIRECTDRAWPALETTE) ppal_int );
            DPF( 5, "SetPalette, ddrval = %08lx (%ld)", ddrval, LOWORD( ddrval ) );
        }
    }
    /*
     * stuff to do after the mode set if deactivating
     */
    else
    {
        if( has_excl )
        {
            /*
             * ...and this will finally release the exclusive mode mutex
             */
            DoneExclusiveMode( this_lcl );
        }
    }

    /*
     * minimize window if deactivating
     */
    if ( (pwinfo->DDInfo.dwDDFlags & DDSCL_FULLSCREEN) &&
        !(pwinfo->DDInfo.dwDDFlags & DDSCL_NOWINDOWCHANGES) &&
        IsWindowVisible(pwinfo->hWnd))
    {
        pwinfo->dwFlags |= WININFO_SELFSIZE;

        if( is_active )
        {
            MakeFullscreen(this_lcl, (HWND)this_lcl->hWnd);
        }
        else if( bMinimize )
        {
            // get the last active popup
            this_lcl->hWndPopup = (ULONG_PTR) GetLastActivePopup(pwinfo->hWnd);
            if ((HWND) this_lcl->hWndPopup == pwinfo->hWnd)
            {
                this_lcl->hWndPopup = 0;
            }

            #ifdef USESHOWWINDOW
                ShowWindow(pwinfo->hWnd, SW_SHOWMINNOACTIVE);
            #else
                SetWindowPos(pwinfo->hWnd, NULL, 0, 0, 0, 0,
                    SWP_NOZORDER | SWP_NOACTIVATE);
            #endif
        }

        pwinfo->dwFlags &= ~WININFO_SELFSIZE;
    }

    /*
     * We only want to do the following stuff once
     */
    if( !bFirst )
    {
        return;
    }

#ifdef WIN95
    /*
     * if we got deactivated because of a syskey
     * then send that key to user now.
     * This is unnecessary for NT.
     *
     * NOTE because we disabled all the task-switching
     * hot keys the system did not see the hot key that
     * caused us to deactivate.
     *
     * if there is only one window to activate, activate the
     * desktop (shell window)
     */
    if( has_excl && sys_key && !is_active )
    {
        if (CountTaskWindows() <= 1)
        {
            DPF( 4, "activating the desktop" );

            /*
             * Calling SetforegroundWindow will cause WM_ACTIVATEAPP messages
             * to be sent, but if we get here, we are already processing a
             * WM_ACTIVATEAPP message and are holding the critical section.
             * If we don't LEAVE_DDRAW now, this will cause us to call the
             * apps WindProc w/ the critical section held, which results in
             * a deadlock situation for at least one app (Ashes to Ashes).
             * Leaving and re-entering does mean that we can't rely on the
             * DDraw state to be the same, but we are done using the
             * structures for now anyway.
             * smac 3/20/97
             */
            LEAVE_DDRAW();
            InternalSetForegroundWindow(GetWindow(pwinfo->hWnd, GW_HWNDLAST));
            ENTER_DDRAW();

            // we just activated the desktop, so we *dont* want
            // to force a ALT+ESC or ALT+TAB, we do want to force
            // a CTRL+ESC.

            if (sys_key != VK_ESCAPE || (sys_state & 0x20000000))
                sys_key = 0;
        }

        if (sys_key)
        {
            BYTE state_key;
            BOOL state_key_down;

            DPF( 4, "sending sys key to USER key=%04x state=%08x",sys_key,sys_state);

            if (sys_state & 0x20000000)
                state_key = VK_MENU;
            else
                state_key = VK_CONTROL;

            state_key_down = GetAsyncKeyState(state_key) < 0;

            if (!state_key_down)
                keybd_event(state_key, 0, 0, 0);

            keybd_event(sys_key, 0, 0, 0);
            keybd_event(sys_key, 0, KEYEVENTF_KEYUP, 0);

            if (!state_key_down)
                keybd_event(state_key, 0, KEYEVENTF_KEYUP, 0);
        }
    }
#endif

    sys_key = 0;

} /* handleActivateApp */

static DWORD    dwTime2=0;
/*
 * tryHotKey
 */
static void tryHotKey( WORD flags )
{
    static int          iState=0;
    static DWORD        dwTime=0;
    #define TOGGLE1     0xe02a
    #define TOGGLE2     0xe036

    if( !bHelperStarting )
    {
        if( iState == 0 )
        {
            if( flags == TOGGLE1 )
            {
                dwTime = GetTickCount();
                iState++;
            }
        }
        else
        {
            if( iState == 5 )
            {
                iState = 0;
                if( flags == TOGGLE2 )
                {
                    if( (GetTickCount() - dwTime) < 2500 )
                    {
                        if( InterlockedExchange( &bHelperStarting, TRUE ) )
                        {
                            return;
                        }
                        dwTime2 = GetTickCount();
                        DPF( 5, "********** GET READY FOR A SURPRISE **********" );
                        return;
                    }
                }
            }
            else
            {
                if( !(iState & 1) )
                {
                    iState = (flags == TOGGLE1) ? iState+1 : 0;
                }
                else
                {
                    iState = (flags == TOGGLE2) ? iState+1 : 0;
                }
            }
        }
    }
    else
    {
        if( !bStartHelper )
        {
            bHelperStarting = FALSE;
            dwTime2 = 0;
        }
    }
    return;

} /* tryHotKey */

static LPDDWINDOWINFO GetDDrawWindowInfo( HWND hwnd )
{
    LPDDWINDOWINFO    lpwi=lpWindowInfo;

    while( NULL != lpwi )
    {
        if( lpwi->hWnd == hwnd )
        {
            return lpwi;
        }
        lpwi = lpwi->lpLink;
    }
    return NULL;
}

static void delete_wininfo( LPDDWINDOWINFO curr )
{
    LPDDWINDOWINFO    prev;

    if( NULL == curr )
        return;

    // curr is at the head of the list, delete it and return
    if( curr == lpWindowInfo )
    {
        lpWindowInfo = curr->lpLink;
        MemFree( curr );
        return;
    }
    if( NULL == lpWindowInfo )
        return;

    // find curr in the list, delete it and return
    for(prev=lpWindowInfo; NULL != prev->lpLink; prev = prev->lpLink)
    {
        if( curr == prev->lpLink )
        {
            break;
        }
    }
    if( NULL == prev->lpLink )
    {
        // couldn't find it
        return;
    }

    prev->lpLink = curr->lpLink;
    MemFree( curr );
}

/*
 * Copy the contents of the given surface to the clipboard
 */
static HRESULT copySurfaceToClipboard( HWND hwnd,
                                       LPDDRAWI_DDRAWSURFACE_INT lpSurface,
                                       LPDDRAWI_DDRAWPALETTE_INT lpOverridePalette )
{
    HRESULT                   hres;
    LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl;
    LPDDRAWI_DDRAWSURFACE_GBL lpSurfGbl;
    LPDDPIXELFORMAT           lpddpf;
    DDSURFACEDESC             ddsd;
    DWORD                     dwBitDepth;
    DWORD                     dwRBitMask;
    DWORD                     dwGBitMask;
    DWORD                     dwBBitMask;
    DWORD                     dwSize;
    DWORD                     dwDIBPitch;
    HANDLE                    hDIB;
    BITMAPINFO*               lpDIB;
    HDC                       hdc;
    LPDDRAWI_DDRAWPALETTE_INT lpPalette;
    DWORD                     dwCompression;
    DWORD                     dwColorTableSize;
    RGBQUAD                   rgbColorTable[256];
    LPPALETTEENTRY            lppeColorTable;
    PALETTEENTRY              peColorTable[256];
    LPBYTE                    lpBits;
    int                       i;
    DWORD                     y;
    LPBYTE                    lpDstScan;
    LPBYTE                    lpSrcScan;

    DDASSERT( NULL != lpSurface );
    lpSurfLcl = lpSurface->lpLcl;
    DDASSERT( NULL != lpSurfLcl );
    lpSurfGbl = lpSurfLcl->lpGbl;
    DDASSERT( NULL != lpSurfGbl );

    if( lpSurfLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
        lpddpf = &lpSurfGbl->ddpfSurface;
    else
        lpddpf = &lpSurfLcl->lpSurfMore->lpDD_lcl->lpGbl->vmiData.ddpfDisplay;

    dwBitDepth = lpddpf->dwRGBBitCount;
    dwRBitMask = lpddpf->dwRBitMask;
    dwGBitMask = lpddpf->dwGBitMask;
    dwBBitMask = lpddpf->dwBBitMask;

    switch (dwBitDepth)
    {
        case 8UL:
            if(! ( lpddpf->dwFlags & DDPF_PALETTEINDEXED8 ) )
            {
                DPF( 0, "Non-palettized 8-bit surfaces are not supported" );
                return DDERR_INVALIDPIXELFORMAT;
            }
            dwColorTableSize = 256UL;
            if( NULL != lpOverridePalette )
                lpPalette = lpOverridePalette;
            else
                lpPalette = lpSurfLcl->lpDDPalette;
            if( NULL == lpPalette )
            {
                hdc = (HDC) lpSurfLcl->lpSurfMore->lpDD_lcl->hDC;
                if( NULL == hdc )
                {
                    DPF( 2, "No palette attached. Non-display driver. Using gray scale." );
                    for( i = 0; i < 256; i++ )
                    {
                        peColorTable[i].peRed    = (BYTE)i;
                        peColorTable[i].peGreen  = (BYTE)i;
                        peColorTable[i].peBlue   = (BYTE)i;
                        peColorTable[i].peFlags  = 0;
                    }
                }
                else
                {
                    DPF( 2, "No palette attached. Using system palette entries" );
                    GetSystemPaletteEntries( hdc, 0, 256, peColorTable );
                }
                lppeColorTable = peColorTable;
            }
            else
            {
                DDASSERT( NULL != lpPalette->lpLcl );
                DDASSERT( NULL != lpPalette->lpLcl->lpGbl );
                if( !( lpPalette->lpLcl->lpGbl->dwFlags & DDRAWIPAL_256 ) )
                {
                    DPF( 0, "Palette is not an 8-bit palette" );
                    return DDERR_INVALIDPIXELFORMAT;
                }
                lppeColorTable = lpPalette->lpLcl->lpGbl->lpColorTable;
                DDASSERT( NULL != lppeColorTable );
            }
            for (i = 0; i < 256; i++)
            {
                rgbColorTable[i].rgbBlue     = lppeColorTable->peBlue;
                rgbColorTable[i].rgbGreen    = lppeColorTable->peGreen;
                rgbColorTable[i].rgbRed      = lppeColorTable->peRed;
                rgbColorTable[i].rgbReserved = 0;
                lppeColorTable++;
            }
            dwCompression = BI_RGB;
            break;
        case 16UL:
            if( ( 0x7C00UL == dwRBitMask ) &&
                ( 0x03E0UL == dwGBitMask ) &&
                ( 0x001FUL == dwBBitMask ) )
            {
                dwColorTableSize = 0UL;
                dwCompression = BI_RGB;
            }
            else if( ( 0xF800UL == dwRBitMask ) &&
                     ( 0x07E0UL == dwGBitMask ) &&
                     ( 0x001FUL == dwBBitMask ) )
            {
                dwColorTableSize = 3UL;
                rgbColorTable[0] = *( (RGBQUAD*) &dwRBitMask );
                rgbColorTable[1] = *( (RGBQUAD*) &dwGBitMask );
                rgbColorTable[2] = *( (RGBQUAD*) &dwBBitMask );
                dwCompression = BI_BITFIELDS;
            }
            else
            {
                DPF( 0, "Unsupported 16-bit pixel format" );
                return DDERR_INVALIDPIXELFORMAT;
            }
            break;
        case 24UL:
            if( ( 0x000000FFUL == dwBBitMask ) &&
                ( 0x0000FF00UL == dwGBitMask ) &&
                ( 0x00FF0000UL == dwRBitMask ) )
            {
                dwColorTableSize = 0UL;
                dwCompression = BI_RGB;
            }
            else
            {
                DPF( 0, "Unsupported 24-bit pixel format" );
                return DDERR_INVALIDPIXELFORMAT;
            }
            break;
        case 32UL:
            if( ( 0x000000FFUL == dwRBitMask ) &&
                ( 0x0000FF00UL == dwGBitMask ) &&
                ( 0x00FF0000UL == dwBBitMask ) )
            {
                dwColorTableSize = 0UL;
                dwCompression = BI_RGB;
            }
            else if( ( 0x00FF0000UL == dwRBitMask ) &&
                     ( 0x0000FF00UL == dwGBitMask ) &&
                     ( 0x000000FFUL == dwBBitMask ) )
            {
                dwColorTableSize = 3UL;
                rgbColorTable[0] = *( (RGBQUAD*) &dwRBitMask );
                rgbColorTable[1] = *( (RGBQUAD*) &dwGBitMask );
                rgbColorTable[2] = *( (RGBQUAD*) &dwBBitMask );
                dwCompression = BI_BITFIELDS;
            }
            else
            {
                DPF( 0, "Unsupported 32-bit pixel format" );
                return DDERR_INVALIDPIXELFORMAT;
            }
            break;
        default:
            DPF( 0, "Unsupported pixel depth" );
            return DDERR_INVALIDPIXELFORMAT;
    };

    dwDIBPitch = ( ( ( ( lpSurfGbl->wWidth * dwBitDepth ) + 31 ) >> 3 ) & ~0x03UL );
    dwSize = sizeof( BITMAPINFOHEADER ) +
                 ( dwColorTableSize * sizeof( RGBQUAD ) ) +
                 ( lpSurfGbl->wHeight * dwDIBPitch );

    hDIB = GlobalAlloc( GHND | GMEM_DDESHARE, dwSize );
    if( 0UL == hDIB )
    {
        DPF( 0, "Unsufficient memory for DIB" );
        return DDERR_OUTOFMEMORY;
    }
    lpDIB = (BITMAPINFO*) GlobalLock( hDIB );
    if( NULL == lpDIB )
    {
        DPF( 0, "Unsufficient memory for DIB" );
        GlobalFree( hDIB );
        return DDERR_OUTOFMEMORY;
    }

    lpBits = ( (LPBYTE) lpDIB ) + sizeof( BITMAPINFOHEADER ) + ( dwColorTableSize * sizeof( RGBQUAD ) );

    lpDIB->bmiHeader.biSize          = sizeof( BITMAPINFOHEADER );
    lpDIB->bmiHeader.biWidth         = (LONG) lpSurfGbl->wWidth;
    lpDIB->bmiHeader.biHeight        = (LONG) lpSurfGbl->wHeight;
    lpDIB->bmiHeader.biPlanes        = 1;
    lpDIB->bmiHeader.biBitCount      = (WORD) dwBitDepth;
    lpDIB->bmiHeader.biCompression   = dwCompression;
    lpDIB->bmiHeader.biXPelsPerMeter = 1L;
    lpDIB->bmiHeader.biYPelsPerMeter = 1L;
    if( 8UL == dwBitDepth )
    {
        lpDIB->bmiHeader.biClrUsed      = 256UL;
        lpDIB->bmiHeader.biClrImportant = 256UL;
    }
    else
    {
        lpDIB->bmiHeader.biClrUsed      = 0UL;
        lpDIB->bmiHeader.biClrImportant = 0UL;
    }
    if( 0UL != dwColorTableSize )
        CopyMemory( &lpDIB->bmiColors[0], rgbColorTable, dwColorTableSize * sizeof( RGBQUAD ) );

    ZeroMemory( &ddsd, sizeof( ddsd ) );
    ddsd.dwSize = sizeof( ddsd );
    hres = DD_Surface_Lock( (LPDIRECTDRAWSURFACE) lpSurface,
                            NULL,
                            &ddsd,
                            DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT,
                            0UL );
    if( FAILED( hres ) )
    {
        DPF( 0, "Could not lock the surface" );
        GlobalUnlock( hDIB );
        GlobalFree( hDIB );
        return hres;
    }

    for( y = 0; y < ddsd.dwHeight; y++ )
    {
        lpDstScan = lpBits + ( y * dwDIBPitch );
        lpSrcScan = ( (LPBYTE) ddsd.lpSurface ) + ( ( ( ddsd.dwHeight - 1UL ) - y ) * ddsd.lPitch );
        CopyMemory( lpDstScan, lpSrcScan, dwDIBPitch );
    }

    hres = DD_Surface_Unlock( (LPDIRECTDRAWSURFACE) lpSurface, NULL );
    if( FAILED( hres ) )
    {
        DPF( 0, "Could not unlock the surface" );
        GlobalUnlock( hDIB );
        GlobalFree( hDIB );
        return hres;
    }

    GlobalUnlock( hDIB );

    if( OpenClipboard( hwnd ) )
    {
        EmptyClipboard();
        if( NULL == SetClipboardData( CF_DIB, hDIB ) )
        {
            DPF( 0, "Could not copy the bitmap to the clipboard" );
            return DDERR_GENERIC;
        }
        CloseClipboard();
    }
    else
    {
        DPF( 0, "Clipboard open by another application" );
        DDERR_GENERIC;
    }

    return DD_OK;
} /* copySurfaceToClipboard */

/*
 * HandleTimer
 *
 * This function exists because it requires some local variables and if
 * we always push them on the stack each time the WindowProc is called, we
 * see cases where the stack crashes.  By putting them in a sperate function,
 * they only get pushed when a timer message occurs.
 */
void HandleTimer( LPDDWINDOWINFO curr )
{
    HWND hwndTopmostList[MAX_TIMER_HWNDS];
    BOOL bFound;
    int iCnt;
    int i;
    int j;

    DPF(4, "Bringing window to top");

    /*
     * Save the hwnds locally since the list can change
     * out from under us.
     */
    iCnt = 0;
    while( iCnt < giTopmostCnt )
    {
        hwndTopmostList[iCnt] = ghwndTopmostList[iCnt++];
    }
    giTopmostCnt = 0;

    for( i = 0; i < iCnt; i++ )
    {
        /*
         * There may be duplicates in the list, so make sure
         * to call SetWindowPos only once per hwnd.
         */
        bFound = FALSE;
        for( j = 0; (j < i) && !bFound; j++ )
        {
            if( hwndTopmostList[i] == hwndTopmostList[j] )
            {
                bFound = TRUE;
            }
        }
        if( !bFound )
        {
            curr->dwFlags |= WININFO_SELFSIZE;
            SetWindowPos( hwndTopmostList[i], HWND_TOPMOST,
                0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
            curr->dwFlags &= ~WININFO_SELFSIZE;
        }
    }
}

/*
 * This function exists for the same reason as HandleTimer
 */

void CopyPrimaryToClipBoard(HWND hWnd, LPDDWINDOWINFO curr)
{
    LPDDRAWI_DIRECTDRAW_GBL   this;
    LPDDRAWI_DIRECTDRAW_LCL   this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT lpPrimary;
    ENTER_DDRAW();

    this_lcl = curr->DDInfo.lpDD_lcl;
    DDASSERT( NULL != this_lcl );
    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );
    lpPrimary = this_lcl->lpPrimary;
    if( NULL != lpPrimary)
    {
        if( this->dwFlags & DDRAWI_MODEX )
        {
            LPDIRECTDRAWSURFACE       lpSurface;
            LPDIRECTDRAWSURFACE       lpBackBuffer;
            LPDDRAWI_DDRAWSURFACE_INT lpBackBufferInt;
            LPDDRAWI_DDRAWPALETTE_INT lpPalette;
            DDSCAPS                   ddscaps;
            HRESULT                   hres;

            DPF( 4, "Copying ModeX backbuffer to the clipboard" );

            lpSurface = (LPDIRECTDRAWSURFACE) this_lcl->lpPrimary;
            ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
            hres = lpSurface->lpVtbl->GetAttachedSurface( lpSurface, &ddscaps, &lpBackBuffer );
            if( !FAILED( hres ) )
            {
                DDASSERT( NULL != lpBackBuffer );

                lpBackBufferInt = (LPDDRAWI_DDRAWSURFACE_INT) lpBackBuffer;

                if( NULL == lpBackBufferInt->lpLcl->lpDDPalette )
                {
                    DPF( 2, "Using ModeX primary palette for PRINTSCREEN" );
                    DDASSERT( NULL != lpPrimary->lpLcl );
                    lpPalette = lpPrimary->lpLcl->lpDDPalette;
                }
                else
                {
                    DPF( 2, "Using ModeX backbuffer palette for PRINTSCREEN" );
                    DDASSERT( NULL != lpBackBufferInt->lpLcl );
                    lpPalette = lpBackBufferInt->lpLcl->lpDDPalette;
                }

                copySurfaceToClipboard( hWnd, lpBackBufferInt, lpPalette );
                lpBackBuffer->lpVtbl->Release( lpBackBuffer );
            }
            else
            {
                DPF( 0, "Could not PRINTSCREEN - ModeX primary has no attached backbuffer" );
            }
        }
        else
        {
            DPF( 4, "Copying linear primary surface to the clipboard" );
            copySurfaceToClipboard( hWnd, lpPrimary, NULL );
        }
    }
    else
    {
        DPF( 0, "Could not PRINTSCREEN - no primary" );
    }

    LEAVE_DDRAW();
}

/*
 * WindowProc
 */
LRESULT WINAPI WindowProc(
                HWND hWnd,
                UINT uMsg,
                WPARAM wParam,
                LPARAM lParam )
{
    #ifdef GDIDDPAL
        LPDDRAWI_DDRAWPALETTE_LCL       ppal_lcl;
    #endif
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    BOOL                        is_active;
    LPDDWINDOWINFO              curr;
    WNDPROC                     proc;
    BOOL                        get_away;
    LRESULT                     rc;
    BOOL                        is_hot;
    BOOL                        is_excl;

    /*
     * find the hwnd
     */
    curr = GetDDrawWindowInfo(hWnd);
    if( curr == NULL || curr->dwSmag != WININFO_MAGIC )
    {
        DPF( 0, "FATAL ERROR! Window Proc Called for hWnd %08lx, but not in list!", hWnd );
        DEBUG_BREAK();
        return DefWindowProc( hWnd, uMsg, wParam, lParam );
    }

    /*
     * unhook at destroy (or if the WININFO_UNHOOK bit is set)
     */
    proc = curr->lpWndProc;

    if( uMsg == WM_NCDESTROY )
    {
        DPF (4, "*** WM_NCDESTROY unhooking window ***" );
        curr->dwFlags |= WININFO_UNHOOK;
    }

    if( curr->dwFlags & WININFO_UNHOOK )
    {
        DPF (4, "*** Unhooking window proc" );

        if (curr->dwFlags & WININFO_ZOMBIE)
        {
            DPF (4, "*** Freeing ZOMBIE WININFO ***" );
            delete_wininfo( curr );
        }

        KillTimer(hWnd,TOPMOST_ID);
        SetWindowLongPtr( hWnd, GWLP_WNDPROC, (INT_PTR) proc );

        rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );
        return rc;
    }

    /*
     * Code to defer app activation of minimized app until it is restored.
     */
    switch( uMsg )
    {
    #ifdef WIN95
    case WM_POWERBROADCAST:
        if( (wParam == PBT_APMSUSPEND) || (wParam == PBT_APMSTANDBY) )
    #else
    //winnt doesn't know about standby vs suspend
    case WM_POWER:
        if( wParam == PWR_SUSPENDREQUEST)
    #endif
        {
            DPF( 4, "WM_POWERBROADCAST: deactivating application" );
            SendMessage( hWnd, WM_ACTIVATEAPP, 0, GetCurrentThreadId() );
        }
        break;
    case WM_SIZE:
        DPF( 4, "WM_SIZE hWnd=%X wp=%04X, lp=%08X", hWnd, wParam, lParam);

        if( !(curr->dwFlags & WININFO_INACTIVATEAPP)
            && ((wParam == SIZE_RESTORED) || (wParam == SIZE_MAXIMIZED))
            && !(curr->dwFlags & WININFO_SELFSIZE)
            && (GetForegroundWindow() == hWnd) )
        {
#ifdef WINNT
            //
            // Wouldncha know it, but NT's messaging order is HUGELY different when alt-tabbing
            // between two exclusive mode apps. The first WM_SIZE sent to the activating app is
            // sent BEFORE the deactivating app loses FSE. This WM_SIZE is totally necessary to
            // reactivate the activating app, but it has to wait until the app loses FSE.
            // So, we simply wait on the exclusive mode mutex. This seems to work!
            //
            {
                DWORD dwWaitResult;
                dwWaitResult = WaitForSingleObject(hExclusiveModeMutex, INFINITE);
                switch (dwWaitResult)
                {
                case WAIT_OBJECT_0:
                case WAIT_ABANDONED:
                    ReleaseMutex( hExclusiveModeMutex );
                    break;
                case WAIT_TIMEOUT:
                default:
                    DDASSERT(!"Unexpected return value from WaitForSingleObject");
                }

            }
#endif
            DPF( 4, "WM_SIZE: Window restored, sending WM_ACTIVATEAPP" );
            PostMessage( hWnd, WM_ACTIVATEAPP, 1, GetCurrentThreadId() );
        }
        else
        {
            DPF( 4, "WM_SIZE: Window restored, NOT sending WM_ACTIVATEAPP" );
        }
        break;

    case WM_ACTIVATEAPP:
        if( IsIconic( hWnd ) && wParam )
        {
            DPF( 4, "WM_ACTIVATEAPP: Ignoring while minimized" );
            return 0;
        }
        else
        {
            curr->dwFlags |= WININFO_INACTIVATEAPP;
        }
        break;
    case WM_KEYUP:
        if( ( VK_SNAPSHOT == wParam ) && ( dwRegFlags & DDRAW_REGFLAGS_ENABLEPRINTSCRN ) )
        {
        CopyPrimaryToClipBoard(hWnd, curr);
        }
        break;
    }

    /*
     * direct sound need to be called?
     */
    if ( curr->dwFlags & WININFO_DSOUNDHOOKED )
    {
        if( curr->lpDSoundCallback != NULL )
        {
            curr->lpDSoundCallback( hWnd, uMsg, wParam, lParam );
        }
    }

    /*
     * is directdraw involved here?
     */
    if( !(curr->dwFlags & WININFO_DDRAWHOOKED) )
    {
        rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );

        // clear the WININFO_INACTIVATEAPP bit, but make sure to make sure
        // we are still hooked!
        if (uMsg == WM_ACTIVATEAPP && (GetDDrawWindowInfo(hWnd) != NULL))
        {
            curr->dwFlags &= ~WININFO_INACTIVATEAPP;
        }
        return rc;
    }

#ifdef DEBUG
    if ( (curr->DDInfo.dwDDFlags & DDSCL_FULLSCREEN) &&
        !(curr->DDInfo.dwDDFlags & DDSCL_NOWINDOWCHANGES) &&
        !IsIconic(hWnd) )
    {
        if (GetForegroundWindow() == hWnd)
        {
            HWND hwndT;
            RECT rc,rcT;

            GetWindowRect(hWnd, &rc);

            for (hwndT = GetWindow(hWnd, GW_HWNDFIRST);
                hwndT && hwndT != hWnd;
                hwndT = GetWindow(hwndT, GW_HWNDNEXT))
            {
                if (IsWindowVisible(hwndT))
                {
                    GetWindowRect(hwndT, &rcT);
                    if (IntersectRect(&rcT, &rcT, &rc))
                    {
                        DPF(4, "Window %08x is on top of us!!", hwndT);
                    }
                }
            }
        }
    }
#endif

    /*
     * NOTE: we don't take the DLL csect here.   By not doing this, we can
     * up the performance here.   However, this means that the application
     * could have a separate thread kill exclusive mode while window
     * messages were being processed.   This could cause our death.
     * Is this OK?
     */

    this_lcl = curr->DDInfo.lpDD_lcl;
    switch( uMsg )
    {
    /*
     * WM_SYSKEYUP
     *
     * watch for system keys of app trying to switch away from us...
     *
     * we only need to do this on Win95 because we have disabled all
     * the task-switching hot keys.  on NT we will get switched
     * away from normaly by the system.
     */
//#ifdef WIN95
    case WM_SYSKEYUP:
        DPF( 4, "WM_SYSKEYUP: wParam=%08lx lParam=%08lx", wParam, lParam );
        get_away = FALSE;
        is_hot = FALSE;
        if( wParam == VK_TAB )
        {
            if( lParam & 0x20000000l )
            {
                if( curr->dwFlags & WININFO_IGNORENEXTALTTAB )
                {
                    DPF( 5, "AHHHHHHHHHHHH Ignoring AltTab" );
                }
                else
                {
                    get_away = TRUE;
                }
            }
        }
        else if( wParam == VK_ESCAPE )
        {
            get_away = TRUE;
        }
#ifdef WIN95
        else if( wParam == VK_SHIFT )
        {
            if( HIBYTE( HIWORD( lParam ) ) == 0xe0 )
            {
                tryHotKey( HIWORD( lParam ) );
            }
        }
#endif

        is_excl = ((this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE) != 0);

#ifdef WIN95
        if( get_away && dwTime2 != 0 )
        {
            if( GetTickCount() - dwTime2 < 2500 )
            {
                DPF( 4, "********** WANT TO SEE SOMETHING _REALLY_ SCARY? *************" );
                bStartHelper = TRUE;
                is_hot = TRUE;
            }
            else
            {
                bHelperStarting = FALSE;
                dwTime2 = 0;
            }
        }
        else
        {
            bHelperStarting = FALSE;
        }
#endif

        curr->dwFlags &= ~WININFO_IGNORENEXTALTTAB;

        if( (get_away && is_excl) || is_hot )
        {
            DPF( 4, "Hot key pressed, switching away from app" );
            if( is_hot && !is_excl )
            {
                PostMessage( hWnd, WM_USER+0x1234, 0xFFBADADD, 0xFFADDBAD );
            }
            else
            {
                sys_key = (BYTE)wParam;
                sys_state = (DWORD)lParam;
                PostMessage( hWnd, WM_ACTIVATEAPP, 0, GetCurrentThreadId() );
            }
        }
        break;
//#endif

    /*
     * WM_SYSCOMMAND
     *
     * watch for screen savers, and don't allow them!
     *
     */
    case WM_SYSCOMMAND:
        is_excl = ((this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE) != 0);
        if( is_excl )
        {
            switch( wParam )
            {
            case SC_SCREENSAVE:
                DPF( 3, "Ignoring screen saver!" );
                return 1;
#ifndef WINNT
            case SC_MONITORPOWER:
                /*
                 * Allow screen savers to power down but not apps.
                 * This is because windows doesn't see joystick events
                 * so will power down a game even though they have been
                 * using the joystick.
                 */
                if( this_lcl->dwAppHackFlags & DDRAW_APPCOMPAT_SCREENSAVER )
                {
                    /*
                     * However, we don't want the screen saver to call the
                     * hardware because things can go wrong, so we will simply
                     * invalidate all of the surfaces and not allowed them
                     * to be restored until we are powered back up.
                     */
                    this_lcl->dwLocalFlags |= DDRAWILCL_POWEREDDOWN;
                    InvalidateAllSurfaces( this_lcl->lpGbl,
                        (HANDLE) this_lcl->hDDVxd, TRUE );
                }
                else
                {
                    DPF( 3, "Ignoring monitor power command!" );
                    return 1;
                }
                break;
#endif
            // allow window to be restored even if it has popup(s)
            case SC_RESTORE:
                if (this_lcl->hWndPopup)
                {
                    ShowWindow(hWnd, SW_RESTORE);
                }
                break;
            }
        }
        break;

    case WM_TIMER:
        if (wParam == TOPMOST_ID )
        {
            if ( GetForegroundWindow() == hWnd && !IsIconic(hWnd) )
            {
                HandleTimer(curr);
            }

            KillTimer(hWnd, wParam);
            return 0;
        }
        break;

#ifdef USESHOWWINDOW
    case WM_DISPLAYCHANGE:
        DPF( 4, "WM_DISPLAYCHANGE: %dx%dx%d", LOWORD(lParam), HIWORD(lParam), wParam );

        //
        //  WM_DISPLAYCHANGE is *sent* to the thread that called
        //  change display settings, we will most likely have the
        //  direct draw lock, make sure we set the WININFO_SELFSIZE
        //  bit while calling down the chain to prevent deadlock
        //
        if ( (DDSCL_DX8APP & curr->DDInfo.dwDDFlags) &&
            !(DDRAWI_FULLSCREEN & this_lcl->lpGbl->dwFlags ))
        {
            // this is caused by DoneExclusiveMode() to restore original desktop
            return 0L;   // don't send to app, it's caused by MakeFullScreen
        }
        curr->dwFlags |= WININFO_SELFSIZE;

        if ( (curr->DDInfo.dwDDFlags & DDSCL_FULLSCREEN) &&
            !(curr->DDInfo.dwDDFlags & DDSCL_NOWINDOWCHANGES) )
        {
            MakeAllFullscreen(this_lcl, hWnd);
        }

        rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );

        // clear the WININFO_SELFSIZE bit, but make sure to make sure
        // we are still hooked!
        if (GetDDrawWindowInfo(hWnd) != NULL)
        {
            curr->dwFlags &= ~WININFO_SELFSIZE;
        }
        return rc;
#endif

    /*
     * WM_ACTIVATEAPP
     *
     * the application has been reactivated.   In this case, we need to
     * reset the mode
     *
     */
    case WM_ACTIVATEAPP:
        is_excl = ((this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE) != 0);

        if( is_excl )
        {
            is_active = (BOOL)wParam && GetForegroundWindow() == hWnd && !IsIconic(hWnd);

            #ifdef DEBUG
                /*
                 * Hack to allow debugging on multi-mon systems w/o minimizing
                 * the app all of the time.
                 */
                if( this_lcl->dwLocalFlags & DDRAWILCL_DISABLEINACTIVATE )
                {
                    wParam = is_active = TRUE;
                }
            #endif

            if (!is_active && wParam != 0)
            {
                DPF( 3, "WM_ACTIVATEAPP: setting wParam to 0, not realy active");
                wParam = 0;
            }

            if( is_active )
            {
                DPF( 5, "WM_ACTIVATEAPP: BEGIN Activating app pid=%08lx, tid=%08lx",
                                        GetCurrentProcessId(), GetCurrentThreadId() );
            }
            else
            {
                DPF( 5, "WM_ACTIVATEAPP: BEGIN Deactivating app pid=%08lx, tid=%08lx",
                                        GetCurrentProcessId(), GetCurrentThreadId() );
            }
            ENTER_DDRAW();
            if( is_active && (this_lcl->dwLocalFlags & DDRAWILCL_ACTIVEYES) )
            {
                DPF( 4, "*** Already activated" );
            }
            else
            if( !is_active && (this_lcl->dwLocalFlags & DDRAWILCL_ACTIVENO) )
            {
                DPF( 4, "*** Already deactivated" );
            }
            else
            {
                DPF( 4, "*** Active state changing" );
                if( is_active )
                {
                    if (GetAsyncKeyState( VK_MENU ) < 0)
                        DPF(4, "ALT key is DOWN");

                    if (GetKeyState( VK_MENU ) < 0)
                        DPF(4, "we think the ALT key is DOWN");

                    if( GetAsyncKeyState( VK_MENU ) < 0 )
                    {
                        curr->dwFlags |= WININFO_IGNORENEXTALTTAB;
                        DPF( 4, "AHHHHHHH Setting to ignore next alt tab" );
                    }
                    else
                    {
                        curr->dwFlags &= ~WININFO_IGNORENEXTALTTAB;
                    }
                }

                /*
                 * In the multi-mon scenario, it's possible that multiple
                 * devices are using this same window, so we need to do
                 * the following for each device.
                 */
                this_lcl->dwLocalFlags &= ~(DDRAWILCL_ACTIVEYES|DDRAWILCL_ACTIVENO);
                if( is_active )
                {
                    this_lcl->dwLocalFlags |= DDRAWILCL_ACTIVEYES;
                }
                else
                {
                    this_lcl->dwLocalFlags |= DDRAWILCL_ACTIVENO;
                }
                handleActivateApp( this_lcl, curr, is_active, TRUE );

                pdrv_lcl = lpDriverLocalList;
                while( pdrv_lcl != NULL )
                {
                    if( ( this_lcl->lpGbl != pdrv_lcl->lpGbl ) &&
                        ( pdrv_lcl->hFocusWnd == (ULONG_PTR) hWnd ) &&
                        ( pdrv_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE ) &&
                        ( pdrv_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV ) &&
                        ( this_lcl->lpGbl->dwFlags & DDRAWI_DISPLAYDRV ) )
                    {
                        pdrv_lcl->dwLocalFlags &= ~(DDRAWILCL_ACTIVEYES|DDRAWILCL_ACTIVENO);
                        if( is_active )
                        {
                            pdrv_lcl->dwLocalFlags |= DDRAWILCL_ACTIVEYES;
                        }
                        else
                        {
                            pdrv_lcl->dwLocalFlags |= DDRAWILCL_ACTIVENO;
                        }
                        handleActivateApp( pdrv_lcl, curr, is_active, FALSE );
                    }
                    pdrv_lcl = pdrv_lcl->lpLink;
                }
            }
            #ifdef DEBUG
                if( is_active )
                {
                    DPF( 4, "WM_ACTIVATEAPP: DONE Activating app pid=%08lx, tid=%08lx",
                                            GetCurrentProcessId(), GetCurrentThreadId() );
                }
                else
                {
                    DPF( 4, "WM_ACTIVATEAPP: DONE Deactivating app pid=%08lx, tid=%08lx",
                                            GetCurrentProcessId(), GetCurrentThreadId() );
                }
            #endif

            // set focus to last active popup
            if (is_active && this_lcl->hWndPopup)
            {
                if (IsWindow((HWND) this_lcl->hWndPopup))
                {
                    SetFocus((HWND) this_lcl->hWndPopup);
                }
                this_lcl->hWndPopup = 0;
            }

            LEAVE_DDRAW();
            HIDESHOW_IME();     //Show/hide the IME OUTSIDE of the ddraw critsect.
            if( !is_active && bStartHelper )
            {
                PostMessage( hWnd, WM_USER+0x1234, 0xFFBADADD, 0xFFADDBAD );
            }
        }

        rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );

        // clear the WININFO_INACTIVATEAPP bit, but make sure to make sure
        // we are still hooked!
        if (GetDDrawWindowInfo(hWnd) != NULL)
        {
            curr->dwFlags &= ~WININFO_INACTIVATEAPP;
        }
        return rc;

        break;

#ifdef WIN95
    case WM_USER+0x1234:
        if( wParam == 0xFFBADADD && lParam == 0xFFADDBAD )
        {
            if( bStartHelper )
            {
                //HelperCreateThread();
            }
            bHelperStarting = FALSE;
            bStartHelper = FALSE;
            dwTime2 = 0;
            return 0;
        }
        break;
#endif

    #ifdef GDIDDPAL
        case WM_PALETTECHANGED:
            if( (HWND) wParam == hWnd )
            {
                break;
            }
            // fall through
        case WM_QUERYNEWPALETTE:
            ENTER_DDRAW();
            ppal_lcl = getPalette( this_lcl );
            if( ppal_lcl != NULL )
            {
            }
            LEAVE_DDRAW();
            break;
        case WM_PAINT:
            ENTER_DDRAW();
            ppal_lcl = getPalette( this_lcl );
            if( ppal_lcl != NULL )
            {
            }
            LEAVE_DDRAW();
            break;
    #endif
    }
    if ((curr->dwFlags & WININFO_SELFSIZE) &&
        (curr->DDInfo.dwDDFlags & DDSCL_DX8APP))
    {
        return 0L;   // don't send to app, it's caused by MakeFullScreen
    }
    rc = CallWindowProc( proc, hWnd, uMsg, wParam, lParam );
    return rc;

} /* WindowProc */

#undef DPF_MODNAME
#define DPF_MODNAME     "SetCooperativeLevel"

/*
 * DeviceWindowProc
 *
 * This is the Window Proc when the app asks us to create the device window.
 */
LRESULT WINAPI DeviceWindowProc(
                HWND hWnd,
                UINT uMsg,
                WPARAM wParam,
                LPARAM lParam )
{
    HWND hParent;
    LPCREATESTRUCT lpCreate;

    switch( uMsg )
    {
    case WM_CREATE:
        lpCreate = (LPCREATESTRUCT) lParam;
        SetWindowLongPtr( hWnd, 0, (INT_PTR) lpCreate->lpCreateParams );
        break;

    case WM_SETFOCUS:
        hParent = (HWND) GetWindowLongPtr( hWnd, 0 );
        if( IsWindow( hParent ) )
        {
            SetFocus( hParent );
        }
        break;

    case WM_SETCURSOR:
        SetCursor(NULL);
        break;
    }

    return DefWindowProc( hWnd, uMsg, wParam, lParam );

} /* WindowProc */

/*
 * CleanupWindowList
 *
 * This function is called by the helper thread after termination and
 * it's purpose is to remove any entries in the window list that could
 * be left around due to subclassing, etc.
 */
VOID CleanupWindowList( DWORD pid )
{
    LPDDWINDOWINFO        curr;

    /*
     * find the window list item associated with this process
     */
    curr = lpWindowInfo;
    while( curr != NULL )
    {
        if( curr->dwPid == pid )
        {
            break;
        }
        curr = curr->lpLink;
    }

    if( curr != NULL )
    {
        delete_wininfo( curr );
    }
} /* CleanupWindowList */


/*
 * internalSetAppHWnd
 *
 * Set the WindowList struct up with the app's hwnd info
 * Must be called with DLL & driver locks taken.
 */
HRESULT internalSetAppHWnd(
                LPDDRAWI_DIRECTDRAW_LCL this_lcl,
                HWND hWnd,
                DWORD dwFlags,
                BOOL is_ddraw,
                WNDPROC lpDSoundWndProc,
                DWORD pid )
{
    LPDDWINDOWINFO        curr;
    LPDDWINDOWINFO        prev;

    /*
     * find the window list item associated with this process
     */
    curr = lpWindowInfo;
    prev = NULL;
    while( curr != NULL )
    {
        if( curr->dwPid == pid )
        {
            break;
        }
        prev = curr;
        curr = curr->lpLink;
    }

    /*
     * check if this is OK
     */
    if( curr == NULL )
    {
        if( hWnd == NULL )
        {
            DPF( 1, "HWnd must be specified" );
            return DDERR_NOHWND;
        }
    }
    else
    {
        if( hWnd != NULL )
        {
            if( curr->hWnd != hWnd )
            {
                DPF( 1, "Hwnd %08lx no good: Different Hwnd (%08lx) already set for process",
                                    hWnd, curr->hWnd );
                return DDERR_HWNDALREADYSET;
            }
        }
    }

    /*
     * are we shutting an HWND down?
     */
    if( hWnd == NULL )
    {
        if( is_ddraw )
        {
            curr->dwFlags &= ~WININFO_DDRAWHOOKED;
        }
        else
        {
            curr->dwFlags &= ~WININFO_DSOUNDHOOKED;
        }

        if( (curr->dwFlags & (WININFO_DSOUNDHOOKED|WININFO_DDRAWHOOKED)) == 0 )
        {
            if( IsWindow(curr->hWnd) )
            {
                WNDPROC proc;

                proc = (WNDPROC) GetWindowLongPtr( curr->hWnd, GWLP_WNDPROC );

                if( proc != (WNDPROC) WindowProc &&
                    proc != (WNDPROC) curr->lpWndProc )
                {
                    DPF( 3, "Window has been subclassed; cannot restore!" );
                    curr->dwFlags |= WININFO_ZOMBIE;
                }
                else if (GetWindowThreadProcessId(curr->hWnd, NULL) !=
                         GetCurrentThreadId())
                {
                    DPF( 3, "intra-thread window unhook, letting window proc do it" );
                    curr->dwFlags |= WININFO_UNHOOK;
                    curr->dwFlags |= WININFO_ZOMBIE;
                    PostMessage(curr->hWnd, WM_NULL, 0, 0);
                }
                else
                {
                    DPF( 4, "Unsubclassing window %08lx", curr->hWnd );
                    KillTimer(hWnd,TOPMOST_ID);
                    SetWindowLongPtr( curr->hWnd, GWLP_WNDPROC, (INT_PTR) curr->lpWndProc );
                    delete_wininfo( curr );
                }
            }
            else
            {
                delete_wininfo( curr );
            }
        }
    }
    /*
     * changing or adding an hwnd then...
     */
    else
    {
        /*
         * brand new object...
         */
        if( curr == NULL )
        {
            if( GetDDrawWindowInfo(hWnd) != NULL)
            {
                DPF_ERR("Window already has WinInfo structure");
                return DDERR_INVALIDPARAMS;
            }

            curr = MemAlloc( sizeof( DDWINDOWINFO ) );
            if( curr == NULL )
            {
                return DDERR_OUTOFMEMORY;
            }
            curr->dwSmag = WININFO_MAGIC;
            curr->dwPid = pid;
            curr->lpLink = lpWindowInfo;
            lpWindowInfo = curr;
            curr->hWnd = hWnd;
            curr->lpWndProc = (WNDPROC) GetWindowLongPtr( hWnd, GWLP_WNDPROC );

            SetWindowLongPtr( hWnd, GWLP_WNDPROC, (INT_PTR) WindowProc );
        }

        /*
         * set ddraw/dsound specific data
         */
        if( is_ddraw )
        {
            curr->DDInfo.lpDD_lcl = this_lcl;
            curr->DDInfo.dwDDFlags = dwFlags;
            curr->dwFlags |= WININFO_DDRAWHOOKED;
        }
        else
        {
            curr->lpDSoundCallback = lpDSoundWndProc;
            curr->dwFlags |= WININFO_DSOUNDHOOKED;
        }
        DPF( 4, "Subclassing window %08lx", curr->hWnd );
    }
    return DD_OK;

} /* internalSetAppHWnd */

/*
 * ChangeHookedLCL
 *
 * This function is called when an object wants to un-hook the window,
 * but another object is still using it.  If the driver being unhooked is
 * the one that actaully did the hook, we need to setup the other LCL as
 * the one to use.
 */
HRESULT ChangeHookedLCL( LPDDRAWI_DIRECTDRAW_LCL this_lcl,
        LPDDRAWI_DIRECTDRAW_LCL new_lcl, DWORD pid )
{
    LPDDWINDOWINFO        curr;

    /*
     * find the window list item associated with this process
     */
    curr = lpWindowInfo;
    while( curr != NULL )
    {
        if( curr->dwPid == pid )
        {
            break;
        }
        curr = curr->lpLink;
    }
    if( curr == NULL )
    {
        return DD_OK;
    }

    /*
     * Are we shutting down the object that has hooked the hwnd?
     */
    if( (curr->dwFlags & WININFO_DDRAWHOOKED) &&
        ( curr->DDInfo.lpDD_lcl == this_lcl ) )
    {
        /*
         * Yes - make it use the new LCL
         */
        curr->DDInfo.lpDD_lcl = new_lcl;
    }
    return DD_OK;
}

#undef DPF_MODNAME

/*
 * SetAppHWnd
 *
 * Set the WindowList struct up with the app's hwnd info
 */
HRESULT SetAppHWnd(
                LPDDRAWI_DIRECTDRAW_LCL this_lcl,
                HWND hWnd,
                DWORD dwFlags )
{
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    DWORD       pid;
    HRESULT     ddrval;

    /*
     * set up the window
     */
    if( hWnd && (dwFlags & DDSCL_EXCLUSIVE) )
    {
        /*
         * make the window fullscreen and topmost
         */
        if ( (dwFlags & DDSCL_FULLSCREEN) &&
            !(dwFlags & DDSCL_NOWINDOWCHANGES))
        {
            MakeFullscreen(this_lcl, hWnd);
        }
    }

    /*
     * Don't hook the hWnd if it's already hooked and don't unhook it if
     * it's still being used by another object.
     */
    pid = GETCURRPID();
    pdrv_lcl = lpDriverLocalList;
    while( pdrv_lcl != NULL )
    {
        if( ( pdrv_lcl->lpGbl != this_lcl->lpGbl ) &&
            ( pdrv_lcl->dwLocalFlags & DDRAWILCL_HOOKEDHWND ) &&
            ( pdrv_lcl->hFocusWnd == this_lcl->hFocusWnd ) )
        {
            if( hWnd != NULL )
            {
                // Already hooked - no need to do more
                return DD_OK;
            }
            else
            {
                ENTERWINDOWLISTCSECT
                ddrval = ChangeHookedLCL( this_lcl, pdrv_lcl, pid );
                LEAVEWINDOWLISTCSECT
                return ddrval;
            }
        }
        pdrv_lcl = pdrv_lcl->lpLink;
    }

    ENTERWINDOWLISTCSECT
    if( hWnd == NULL )
    {
        ddrval = internalSetAppHWnd( this_lcl, NULL, dwFlags, TRUE, NULL, pid );
    }
    else
    {
        ddrval = internalSetAppHWnd( this_lcl, (HWND)this_lcl->hFocusWnd, dwFlags, TRUE, NULL, pid );
    }
    LEAVEWINDOWLISTCSECT
    return ddrval;

} /* SetAppHWnd */

/*
 * DSoundHelp
 */
HRESULT __stdcall DSoundHelp( HWND hWnd, WNDPROC lpWndProc, DWORD pid )
{
    HRESULT     ddrval;

    DPF( 4, "DSoundHelp: hWnd = %08lx, lpWndProc = %08lx, pid = %08lx", hWnd, lpWndProc, pid );
    ENTERWINDOWLISTCSECT
    ddrval = internalSetAppHWnd( NULL, hWnd, 0, FALSE, lpWndProc, pid );
    LEAVEWINDOWLISTCSECT
    return ddrval;

} /* DSoundHelp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddcreate.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcreate.c
 *  Content:    DirectDraw create object.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   31-dec-94  craige  initial implementation
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   13-feb-94  craige  allow 32-bit callbacks
 *   21-feb-95  craige  disconnect anyone who forgot to do it themselves
 *   27-feb-95  craige  new sync. macros
 *   06-mar-95  craige  HEL integration
 *   08-mar-95  craige  new APIs
 *   11-mar-95  craige  palette stuff
 *   15-mar-95  craige  more HEL integration
 *   19-mar-95  craige  use HRESULTs, process termination cleanup fixes
 *   27-mar-95  craige  linear or rectangular vidmem
 *   28-mar-95  craige  removed Get/SetColorKey, added FlipToGDISurface
 *   29-mar-95  craige  reorg to only call driver once per creation, and
 *                      to allow driver to load us first
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   09-apr-95  craige  fixed deadlock situation with a process having a lock
 *                      on the primary surface while another process starts
 *   12-apr-95  craige  bug when driver object freed (extra leave csect)
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  fail load if no DD components present
 *   06-may-95  craige  use driver-level csects only
 *   09-may-95  craige  escape call to get 32-bit DLL
 *   12-may-95  craige  added DirectDrawEnumerate; use GUIDs in DirectDrawCreate
 *   14-may-95  craige  call DoneExclusiveMode during CurrentProcessCleanup
 *   15-may-95  craige  restore display mode on a per-process basis
 *   19-may-95  craige  memory leak on mode change
 *   23-may-95  craige  added Flush, GetBatchLimit, SetBatchLimit
 *   24-may-95  craige  plugged another memory leak; allow fourcc codes &
 *                      number of vmem heaps to change
 *   26-may-95  craige  some idiot freed the vmem heaps and then tried to
 *                      free the surfaces!
 *   28-may-95  craige  unicode support; make sure blt means at least srccopy
 *   05-jun-95  craige  removed GetVersion, FreeAllSurfaces, DefWindowProc;
 *                      change GarbageCollect to Compact
 *   06-jun-95  craige  call RestoreDisplayMode
 *   07-jun-95  craige  removed DCLIST
 *   12-jun-95  craige  new process list stuff
 *   16-jun-95  craige  new surface structure
 *   18-jun-95  craige  specify pitch for rectangular memory; deadlock
 *                      with MemAlloc16 if we don't take the DLL lock
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  replaced batch limit/flush stuff with BltBatch
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns
 *   02-jul-95  craige  new registry format
 *   03-jul-95  craige  YEEHAW: new driver struct; SEH
 *   06-jul-95  craige  RemoveFromDriverList was screwing up links
 *   07-jul-95  craige  added pdevice stuff
 *   08-jul-95  craige  call InvalidateAllSurfaces
 *   10-jul-95  craige  support SetOverlayPosition
 *   11-jul-95  craige  validate pdevice is from a dibeng mini driver;
 *                      fail aggregation calls; one ddraw object/process
 *   13-jul-95  craige  ENTER_DDRAW is now the win16 lock; need to
 *                      leave Win16 lock while doing ExtEscape calls
 *   14-jul-95  craige  allow driver to specify heap is already allocated
 *   15-jul-95  craige  invalid HDC set in emulation only
 *   18-jul-95  craige  need to initialize dwPreferredMode
 *   20-jul-95  craige  internal reorg to prevent thunking during modeset
 *   20-jul-95  toddla  zero DDHALINFO before thunking in case nobody home.
 *   22-jul-95  craige  emulation only needs to initialize correctly
 *   29-jul-95  toddla  added DEBUG code to clear driver caps
 *   31-jul-95  toddla  added DD_HAL_VERSION
 *   31-jul-95  craige  set DDCAPS_BANKSWITCHED
 *   01-aug-95  toddla  added dwPDevice to DDRAWI_DIRECTDRAW_GBL
 *   10-aug-95  craige  validate alignment fields
 *   13-aug-95  craige  check DD_HAL_VERSION & set DDCAPS2_CERTIFIED
 *   21-aug-95  craige  mode X support
 *   27-aug-95  craige  bug 738: use GUID instead of IID
 *   05-sep-95  craige  bug 814
 *   08-sep-95  craige  bug 845: reset driver callbacks every time
 *   09-sep-95  craige  bug 949: don't allow ddraw to run in 4bpp
 *                      bug 951: NULL out fn tables at reset
 *   10-sep-95  toddla  dont allow DirectDrawCreate to work for < 8bpp mode.
 *   10-sep-95  toddla  added Message box when DirectDrawCreate fails
 *   20-sep-95  craige  made primary display desc. a string resource
 *   21-sep-95  craige  bug 1215: let ddraw16 know about certified for modex
 *   21-nov-95  colinmc made Direct3D a queryable interface off DirectDraw
 *   27-nov-95  colinmc new member to return available vram of a given type
 *                      (defined by DDSCAPS)
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consitency with Direct3D
 *   09-dec-95  colinmc execute buffer support
 *   15-dec-95  colinmc fixed bug setting HAL up for execute buffers
 *   25-dec-95  craige  added InternalDirectDrawCreate for ClassFactory work
 *   31-dec-95  craige  more ClassFactory work
 *   04-jan-96  kylej   add driver interface structures
 *   22-jan-96  jeffno  NT driver conversation in createSurface.
 *                      Since vidmem ptrs can legally be 0 for kernel, added
 *                      DDRAWISURFACEGBL_ISGDISURFACE and use that to find gdi
 *   02-feb-96  kylej   Move HAL function pointers to local object
 *   28-feb-96  kylej   Change DDHALINFO structure
 *   02-mar-96  colinmc Repulsive hack to support interim drivers
 *   06-mar-96  kylej   init HEL even with non-display drivers
 *   13-mar-96  craige  Bug 7528: hw that doesn't have modex
 *   13-mar-96  jeffno  Dynamic mode switch support for NT
 *                      Register process IDs with NT kernel stuff
 *   16-mar-96  colinmc Callback tables now initialized in dllmain
 *   18-mar-96  colinmc Bug 13545: Independent clippers cleanup
 *   22-mar-96  colinmc Bug 13316: uninitialized interfaces
 *   23-mar-96  colinmc Bug 12252: Direct3D not cleaned up properly on crash
 *   14-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   16-apr-96  colinmc Bug 17921: Remove interim driver support
 *   19-apr-96  colinmc Bug 18059: New caps bit to indicate that driver
 *                      can't interleave 2D and 3D operations during scene
 *                      rendering
 *   11-may-96  colinmc Bug 22293: Now validate GUID passed to DirectDraw
 *                      Create in retail as well as debug
 *   16-may-96  colinmc Bug 23215: Not checking for a mode index of -1
 *                      on driver initialization
 *   27-may-96  kylej   Bug 24595: Set Certified bit after call to
 *                      FakeDDCreateDriverObject.
 *   26-jun-96  colinmc Bug 2041: DirectDraw needs time bomb
 *   22-jul-96  colinmc Work Item: Minimal stackable driver support
 *   23-aug-96  craige  registry entries for sw only and modex only
 *   31-aug-96  colinmc Removed erroneous time bomb
 *   03-sep-96  craige  App compatibilty stuff
 *   01-oct-96  ketand  added GetAvailVidMem entrypoint for driver callbacks
 *   05-sep-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   10-oct-96  colinmc Refinements of the Win16 locking stuff
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   15-oct-96  toddla  support multimonitor
 *   09-nov-96  colinmc Fixed problem with old and new drivers not working
 *                      with DirectDraw
 *   17-nov-96  colinmc Added ability to use PrintScrn key to snapshot
 *                      DirectDraw applications.
 *   08-dec-96  colinmc Initial AGP support
 *   21-jan-97  ketand  Added a rectMonitor to lpDD_gbl to allow for correct clipping
 *                      on multi-monitor systems.
 *   25-jan-97  nwilt   Instance GUID in GetDriverInfo struct
 *                      Query for D3DCallbacks2 w/no deps on D3D
 *   27-jan-97  colinmc Fixed problem with multi-mon on emulated displays
 *   27-jan-97  ketand  Multi-mon. Remove bad globals; pass them explicitly. Fix ATTENTIONs.
 *   29-jan-97  smac    Removed old ring 0 code
 *   30-jan-97  colinmc Work item 4125: Add time bomb for beta
 *   30-jan-97  jeffno  Allow surfaces wider than the primary
 *   30-jan-97  ketand  Only enumerate secondaries for multi-mon systems.
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *   07-feb-97  ketand  Zero DisplayDevice struct between calls to EnumDisplayDevices.
 *                      Fix memory leak w.r.t. GetAndValidateNewHalInfo
 *   24-feb-97  ketand  Update Rects whenever a display change occurs.
 *   24-feb-97  ketand  Add a dwContext to GetDriverInfoData
 *   03-mar-97  smac    Added kernel mode interface
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc Added support for DMA style AGP usage
 *   11-mar-97  jeffno  Asynchronous DMA support
 *   11-mar-97  nwilt   Fail driver create if driver exports some DrawPrimitive
 *                      exports without exporting all of them.
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   20-mar-97  nwilt   #6625 and D3D extended caps
 *   24-mar-97  jeffno  Optimized Surfaces
 *   13-may-97  colinmc AGP support on OSR 2.1 systems
 *   26-may-97  nwilt   Fail driver create if driver sets D3DDEVCAPS_DRAWPRIMTLVERTEX
 *                      without exporting the callbacks.
 *   31-jul-97 jvanaken Bug 7093:  Ensure unique HDC for each process/driver pair
 *                      in a multimonitor system.
 *   16-sep-97  jeffno  DirectDrawEnumerateEx
 *   30-sep-97  jeffno  IDirectDraw4
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   05-nov-97 jvanaken Support for master sprite list in SetSpriteDisplayList
 *   24-may-00  RichGr  IA64: Remove casts from pointer assignment, effectively
 *                      changing assignment from DWORD(32-bit only) to
 *                      ULONG_PTR(32/64-bit).  Change debug output to use %p
 *                      format specifier instead of %x for 32/64-bit pointers.
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

#include "apphack.h"
#ifdef WINNT
    #include <ddrawint.h>
    #include "ddrawgdi.h"
    #define BUILD_DDDDK
    #include "d3dhal.h"
#endif

#ifdef WIN95
#include "d3dhal.h"
#endif

#ifdef DEBUG
    #define static
#endif
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"
#define DPF_MODNAME     "DirectDrawObjectCreate"

#define DISPLAY_STR     "display"

HMONITOR GetMonitorFromDeviceName(LPSTR szName);

#ifdef WINNT
DWORD    GetNumberOfMonitorAttachedToDesktop(VOID);
DWORD APIENTRY GetDriverInfo2(LPDDRAWI_DIRECTDRAW_GBL lpGbl,DWORD* pdwDrvRet,DWORD dwType,DWORD dwSize,void* pBuffer);
#endif

char g_szPrimaryDisplay[MAX_DRIVER_NAME] = "";

void getPrimaryDisplayName(void);

void    convertV1DDHALINFO( LPDDHALINFO lpDDHALInfo );

DWORD   dwRegFlags;             // registry flags
// ATTENTION: Does this work for Multi-Mon??
WORD    dwFakeFlags = 0;        // Magic flags for the PDevice??

#ifdef WIN95
    /*
     * DDHELP's handle for communicating with the DirectSound VXD. We need this
     * when we are executing DDRAW code with one of DDHELP's threads.
     */
    HANDLE hHelperDDVxd = INVALID_HANDLE_VALUE;
    #define CLOSEVXD( hvxd ) CloseHandle( hvxd )

#else /* WIN95 */

    #define CLOSEVXD( hvxd )

#endif /* WIN95 */


//#ifdef WIN95

/*
 * initial HAL callbacks
 */

#ifndef WINNT //don't want these just yet

static DDHAL_DDCALLBACKS ddHALDD =
{
    sizeof( DDHAL_DDCALLBACKS ),
    0,
    _DDHAL_DestroyDriver,
    _DDHAL_CreateSurface,
    NULL,                       // _DDHAL_DrvSetColorKey
    _DDHAL_SetMode,
    _DDHAL_WaitForVerticalBlank,
    _DDHAL_CanCreateSurface,
    _DDHAL_CreatePalette,
    _DDHAL_GetScanLine,
    _DDHAL_SetExclusiveMode,
    _DDHAL_FlipToGDISurface
};

static DDHAL_DDSURFACECALLBACKS ddHALDDSurface =
{
    sizeof( DDHAL_DDSURFACECALLBACKS ),
    0,
    _DDHAL_DestroySurface,
    _DDHAL_Flip,
    _DDHAL_SetClipList,
    _DDHAL_Lock,
    _DDHAL_Unlock,
    _DDHAL_Blt,
    _DDHAL_SetColorKey,
    _DDHAL_AddAttachedSurface,
    _DDHAL_GetBltStatus,
    _DDHAL_GetFlipStatus,
    _DDHAL_UpdateOverlay,
    _DDHAL_SetOverlayPosition,
    NULL,
    _DDHAL_SetPalette
};

static DDHAL_DDPALETTECALLBACKS ddHALDDPalette =
{
    sizeof( DDHAL_DDPALETTECALLBACKS ),
    0,
    _DDHAL_DestroyPalette,
    _DDHAL_SetEntries
};

/*
 * NOTE: Currently don't support thunking for these babies. If
 * a driver does the execute buffer thing it must explicitly
 * export 32-bit functions to handle these calls.
 * !!! NOTE: Need to determine whether we will ever need to
 * support thunking for this HAL.
 */
static DDHAL_DDEXEBUFCALLBACKS ddHALDDExeBuf =
{
    sizeof( DDHAL_DDEXEBUFCALLBACKS ),
    0,
    NULL, /* CanCreateExecuteBuffer */
    NULL, /* CreateExecuteBuffer    */
    NULL, /* DestroyExecuteBuffer   */
    NULL, /* LockExecuteBuffer      */
    NULL  /* UnlockExecuteBuffer    */
};

/*
 * NOTE: Currently don't support thunking for these babies. If
 * a driver does the video port thing it must explicitly
 * export 32-bit functions to handle these calls.
 * !!! NOTE: Need to determine whether we will ever need to
 * support thunking for this HAL.
 */
static DDHAL_DDVIDEOPORTCALLBACKS ddHALDDVideoPort =
{
    sizeof( DDHAL_DDVIDEOPORTCALLBACKS ),
    0,
    NULL,       // CanCreateVideoPort
    NULL,       // CreateVideoPort
    NULL,       // FlipVideoPort
    NULL,       // GetVideoPortBandwidthInfo
    NULL,       // GetVideoPortInputFormats
    NULL,       // GetVideoPortOutputFormats
    NULL,       // GetCurrentAutoflipSurface
    NULL,       // GetVideoPortField
    NULL,       // GetVideoPortLine
    NULL,       // GetVideoPortConnectInfo
    NULL,       // DestroyVideoPort
    NULL,       // GetVideoPortFlipStatus
    NULL,       // UpdateVideoPort
    NULL,       // WaitForVideoPortSync
    NULL,       // GetVideoSignalStatus
    NULL        // ColorControl
};

/*
 * NOTE: Currently don't support thunking for these babies. If
 * a driver has a kernel mode interface it must explicitly
 * export 32-bit functions to handle these calls.
 */
static DDHAL_DDKERNELCALLBACKS ddHALDDKernel =
{
    sizeof( DDHAL_DDKERNELCALLBACKS ),
    0,
    NULL,       // SyncSurfaceData
    NULL        // SyncVideoPortData
};

static DDHAL_DDCOLORCONTROLCALLBACKS    ddHALDDColorControl =
{
    sizeof( DDHAL_DDSURFACECALLBACKS ),
    0,
    _DDHAL_ColorControl
};
#endif //not defined winnt

//#endif //defined(WIN95)

#ifndef WIN16_SEPARATE
    #ifdef WIN95
	CRITICAL_SECTION ddcCS = {0};
	#define ENTER_CSDDC() EnterCriticalSection( &ddcCS )
	#define LEAVE_CSDDC() LeaveCriticalSection( &ddcCS )
    #else
	#define ENTER_CSDDC()
	#define LEAVE_CSDDC()
    #endif
#else
    #define ENTER_CSDDC()
    #define LEAVE_CSDDC()
#endif

// DisplayGUID - GUID used to enumerate secondary displays.
//
// {67685559-3106-11d0-B971-00AA00342F9F}
//
// we use this GUID and the next 32 for enumerating devices
// returned via EnumDisplayDevices
//
static const GUID DisplayGUID =
    {0x67685559,0x3106,0x11d0,{0xb9,0x71,0x0,0xaa,0x0,0x34,0x2f,0x9f}};

/*
 * DISPLAY_DEVICEA
 *
 * define a local copy of the structures and constants needed
 * to call EnumDisplayDevices
 *
 */
#ifndef DISPLAY_DEVICE_ATTACHED_TO_DESKTOP
#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008
#define DISPLAY_DEVICE_VGA                 0x00000010
typedef struct {
    DWORD  cb;
    CHAR   DeviceName[MAX_DRIVER_NAME];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
} DISPLAY_DEVICEA;
#endif

/*
 * xxxEnumDisplayDevices
 *
 * wrapper around the new Win32 API EnumDisplayDevices
 * uses GetProcAddress() so we run on Win95.
 *
 * this function exists in NT 4.0 and Win97 (Memphis) but not Win95
 *
 */
BOOL xxxEnumDisplayDevicesA(LPVOID lpUnused, DWORD iDevice, DISPLAY_DEVICEA *pdd, DWORD dwFlags)
{
    HANDLE h = GetModuleHandle("USER32");
    BOOL (WINAPI *pfnEnumDisplayDevices)(LPVOID, DWORD, DISPLAY_DEVICEA *, DWORD);

    (FARPROC)pfnEnumDisplayDevices = GetProcAddress(h,"EnumDisplayDevicesA");

    //
    // NT 4.0 had a EnumDisplayDevicesA but it does not have the same
    // number of params, so ignore it unless a GetMonitorInfoA exists too.
    //
    if (GetProcAddress(h,"GetMonitorInfoA") == NULL)
	pfnEnumDisplayDevices = NULL;

    if (pfnEnumDisplayDevices)
    {
	return (*pfnEnumDisplayDevices)(lpUnused, iDevice, pdd, dwFlags);
    }

    return FALSE;
}

/*
 * xxxChangeDisplaySettingsEx
 *
 * wrapper around the new Win32 API ChangeDisplaySettingsEx
 * uses GetProcAddress() so we run on Win95.
 *
 * this function exists in NT 4.0 and Win97 (Memphis) but not Win95
 *
 */
LONG xxxChangeDisplaySettingsExA(LPCSTR szDevice, LPDEVMODEA pdm, HWND hwnd, DWORD dwFlags,LPVOID lParam)
{
    // We don't use ChangeDisplaySettingsEx on WIN95 because there is a magic
    // bit in DDraw16 that needs to be set/unset for us to correctly distinguish
    // between our own mode sets and external mode sets. (We need to know because
    // of RestoreMode state.)
#ifdef WINNT
    HANDLE h = GetModuleHandle("USER32");
    LONG (WINAPI *pfnChangeDisplaySettingsExA)(LPCSTR,LPDEVMODEA,HWND,DWORD,LPVOID);

    (FARPROC)pfnChangeDisplaySettingsExA = GetProcAddress(h,"ChangeDisplaySettingsExA");

    if (pfnChangeDisplaySettingsExA)
    {
        LONG lRet;
        NotifyDriverToDeferFrees();
	lRet = (*pfnChangeDisplaySettingsExA)(szDevice, pdm, hwnd, dwFlags, lParam);
        if (lRet != DISP_CHANGE_SUCCESSFUL)
        {
            NotifyDriverOfFreeAliasedLocks();
        }
        return lRet;
    }
    else
#endif
    if (szDevice == NULL)
    {
	return DD16_ChangeDisplaySettings(pdm, dwFlags);
    }
#ifdef WIN95
    else
    {
	// This method works on Win95 for mode-setting other
	// devices. We're not yet sure whether the equivalent would
	// work for NT; so we'd rather call the 'approved' API (ChangeDisplaySettingsExA above.)
        if (pdm != NULL)
        {
	    lstrcpy(pdm->dmDeviceName,szDevice);
        }
	return DD16_ChangeDisplaySettings(pdm, dwFlags);
    }
#else
    else
    {
        return DISP_CHANGE_FAILED;
    }
#endif
}
// Multi-monitor defines; these are wrong in the TRANGO tree;
// so I need to define them here explicitly. When we move to
// something that matches Memphis/NT5 then we can remove these
#undef SM_XVIRTUALSCREEN
#undef SM_YVIRTUALSCREEN
#undef SM_CXVIRTUALSCREEN
#undef SM_CYVIRTUALSCREEN
#undef SM_CMONITORS
#define SM_XVIRTUALSCREEN       76
#define SM_YVIRTUALSCREEN       77
#define SM_CXVIRTUALSCREEN      78
#define SM_CYVIRTUALSCREEN      79
#define SM_CMONITORS            80

#ifndef ENUM_CURRENT_SETTINGS
#define ENUM_CURRENT_SETTINGS       ((DWORD)-1)
#endif

// This function walks through all GBLs and calls update rect on them
// This is called by DDHELP when it receives a message regarding WM_DISPLAYCHANGE
void UpdateAllDeviceRects( void )
{
    LPDDRAWI_DIRECTDRAW_LCL     tmp_lcl;
    ENTER_DDRAW();

    DPF( 1, W, "WM_DISPLAYCHANGE being processed by DDraw" );
    tmp_lcl = lpDriverLocalList;
    while( tmp_lcl )
    {
	// This interface may be "uninitialized" in which case
	// it doesn't point to a global object yet.
	if( tmp_lcl->lpGbl )
	{
	    DPF( 4, W, "Updating rect for %s", tmp_lcl->lpGbl->cDriverName );
	    UpdateRectFromDevice( tmp_lcl->lpGbl );
	}
	tmp_lcl = tmp_lcl->lpLink;
    }

    LEAVE_DDRAW();
    return;
}

#ifdef WINNT
// This function gets the device rect by calling GetMonitorInfo.
// On Win98, we got this by calling EnumDisplaySettings, but this
// doesn't work on NT5 and reading the documentation, it never
// indicates that it should work, so we'll just do it the documented
// way.
HRESULT GetNTDeviceRect( LPSTR pDriverName, LPRECT lpRect )
{
    MONITORINFO MonInfo;
    HMONITOR hMon;

    MonInfo.cbSize = sizeof( MONITORINFO );
    if( _stricmp( pDriverName, DISPLAY_STR ) == 0 )
    {
        hMon = GetMonitorFromDeviceName( g_szPrimaryDisplay );
    }
    else
    {
        hMon = GetMonitorFromDeviceName( pDriverName );
    }
    if( hMon != NULL )
    {
        if( GetMonitorInfo( hMon, &MonInfo ) != 0 )
        {
      	    CopyMemory( lpRect, &MonInfo.rcMonitor, sizeof(RECT) );
            return DD_OK;
        }
    }
    return DDERR_GENERIC;
}
#endif

// This function updates our GBL with topology information
// relevant to the device in question.
void UpdateRectFromDevice(
	LPDDRAWI_DIRECTDRAW_GBL    pdrv )
{
    DEVMODE dm;

    // Sanity Check
    DDASSERT( pdrv );

    pdrv->cMonitors = GetSystemMetrics( SM_CMONITORS );
    if( pdrv->cMonitors > 1 )
    {
	#ifdef WIN95
	    /*
	     * First, get the device rectangle
	     */
	    ZeroMemory( &dm, sizeof(dm) );
	    dm.dmSize = sizeof(dm);

	    // Get the DevMode for current settings
	    if( _stricmp( pdrv->cDriverName, DISPLAY_STR ) == 0 )
	    {
	        // Don't need g_szPrimaryDisplay here, just use NULL!!!
	        EnumDisplaySettings( g_szPrimaryDisplay, ENUM_CURRENT_SETTINGS, &dm );
	    }
	    else
	    {
	        EnumDisplaySettings( pdrv->cDriverName, ENUM_CURRENT_SETTINGS, &dm );
	    }

	    //
	    // the position of the device is in the dmPosition field
	    // which happens to be unioned with dmOrientation. dmPosition isn't defined
	    // in our current header
	    //
	    // BUG-BUG:  After reading the definition of the DEVMODE struct in
	    // wingdi.h, I'm amazed that the entire dest rectangle should be
	    // stored at &dm.dmOrientation.  But the code below obviously works,
	    // so I'm reluctant to change it until I know what's going on.

	    CopyMemory( &pdrv->rectDevice, &dm.dmOrientation, sizeof(RECT) );
	#else
            if( GetNTDeviceRect( pdrv->cDriverName, &pdrv->rectDevice ) != DD_OK )
            {
        	pdrv->rectDevice.left =  0;
        	pdrv->rectDevice.top = 0;
        	pdrv->rectDevice.right = pdrv->vmiData.dwDisplayWidth;
        	pdrv->rectDevice.bottom = pdrv->vmiData.dwDisplayHeight;
            }
	#endif
    }
    if( ( pdrv->cMonitors <= 1 ) || IsRectEmpty( &pdrv->rectDevice ) )
    {
	pdrv->rectDevice.left =  0;
	pdrv->rectDevice.top = 0;
	pdrv->rectDevice.right = pdrv->vmiData.dwDisplayWidth;
	pdrv->rectDevice.bottom = pdrv->vmiData.dwDisplayHeight;
    }

    DPF( 1, W, "Device's rect is %d, %d, %d, %d", pdrv->rectDevice.left, pdrv->rectDevice.top, pdrv->rectDevice.right, pdrv->rectDevice.bottom );

    /*
     * Now get the desktop rect.  If we are in virtual desktop mode,
     * we will get the whole dektop; otherwise, we will use the device
     * rectangle.
     */
    // BUG-BUG:  The VIRTUALDESKTOP and ATTACHEDTODESKTOP flags referred to
    // below are never set if we reach this point when we're creating a new
    // surface.  That means that in a multimon system, pdrv->rectDesktop
    // gets set to pdrv->rectDevice instead of to the full desktop.
    if( ( pdrv->dwFlags & DDRAWI_VIRTUALDESKTOP ) &&
	( pdrv->dwFlags & DDRAWI_ATTACHEDTODESKTOP ) )
    {
	int x, y;
	x = GetSystemMetrics( SM_XVIRTUALSCREEN );  // left
	y = GetSystemMetrics( SM_YVIRTUALSCREEN );  // right

	SetRect(    &pdrv->rectDesktop,
		    x,  // left
		    y,  // top
		    x + GetSystemMetrics( SM_CXVIRTUALSCREEN ), // right
		    y + GetSystemMetrics( SM_CYVIRTUALSCREEN ) // bottom
		    );

    }
    else
    {
	memcpy( &pdrv->rectDesktop, &pdrv->rectDevice, sizeof( RECT ) );
    }

    DPF( 1, W, "Desktop's rect is %d, %d, %d, %d", pdrv->rectDesktop.left, pdrv->rectDesktop.top, pdrv->rectDesktop.right, pdrv->rectDesktop.bottom );

    return;
}

/*
 * IsVGADevice()
 *
 * determine if the passed device name is a VGA
 *
 */
BOOL IsVGADevice(LPSTR szDevice)
{
    //
    //  assume "DISPLAY" and "DISPLAY1" are VGA devices
    //
    if (_stricmp(szDevice, DISPLAY_STR) == 0)
	return TRUE;

    return FALSE;
}

/*
 * number of callbacks in a CALLBACK struct
 */
#define NUM_CALLBACKS( ptr ) ((ptr->dwSize-2*sizeof( DWORD ))/ sizeof( LPVOID ))

#if defined( WIN95 )
/*
 * loadSecondaryDriver
 *
 * Determine if a secondary DirectDraw driver key is present in the registry.
 * If it is extract the DLL name and (optional) entry point to invoke. Load
 * the DLL in DDHELP's address space, get the validation entry point and
 * invoke it. If it returns TRUE and gives us back a GUID we have certified
 * as a secondary driver, call its HAL patching function.
 *
 * If any of this stuff fails we simply ignore the error. No secondary driver
 * - no problem.
 *
 * Returns TRUE if a secondary is successfully loaded.
 */
static BOOL loadSecondaryDriver( LPDDHALINFO lpDDHALInfo )
{
    HKEY                     hKey;
    DWORD                    dwType;
    DWORD                    dwSize;
    LPSECONDARY_VALIDATE     fpValidate;
    LPSECONDARY_PATCHHALINFO fpPatchHALInfo;
    char                     szDriverName[MAX_SECONDARY_DRIVERNAME];
    char                     szEntryPoint[MAX_SECONDARY_ENTRYPOINTNAME];
    GUID                     guid;
    BOOL                     bLoaded = FALSE;

    /*
     * Any secondary driver information in the registry at all?
     */
    if( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
				     REGSTR_PATH_SECONDARY,
				     &hKey ) )
    {
	/*
	 * Extract the entry point of the secondary driver. If no entry
	 * point is specified we will use the default instead.
	 */
	dwSize = sizeof( szEntryPoint ) - 1;
	if( ERROR_SUCCESS == RegQueryValueEx( hKey,
					      REGSTR_VALUE_SECONDARY_ENTRYPOINTNAME,
					      NULL,
					      &dwType,
					      szEntryPoint,
					      &dwSize ) )
	{
	    if( REG_SZ != dwType )
	    {
		/*
		 * Key is not a string. Bail.
		 */
		RegCloseKey( hKey );
		return FALSE;
	    }
	}
	else
	{
	    /*
	     * No entry point sepecified. Use the default.
	     */
	    lstrcpy( szEntryPoint, DEFAULT_SECONDARY_ENTRYPOINTNAME );
	}

	/*
	 * Extract the name of the secondary driver's DLL.
	 */
	dwSize = sizeof( szDriverName ) - 1;
	if( ERROR_SUCCESS == RegQueryValueEx( hKey,
					      REGSTR_VALUE_SECONDARY_DRIVERNAME,
					      NULL,
					      &dwType,
					      szDriverName,
					      &dwSize ) )
	{
	    if( REG_SZ == dwType )
	    {
		/*
		 * Now ask DDHELP to load this DLL and invoke the entry point specified.
		 * The value returned by DDHELP will be the address of the secondary
		 * driver's validation function if all went well.
		 */
		#if defined(WIN95)
		    LEAVE_WIN16LOCK();
		#endif
		fpValidate = (LPSECONDARY_VALIDATE)HelperLoadDLL( szDriverName, szEntryPoint, 0UL );
		#if defined(WIN95)
		    ENTER_WIN16LOCK();
		#endif
		if( NULL != fpValidate )
		{
		    /*
		     * Now we need to invoke the validate entry point to ensure that
		     * the secondary driver has been certified by us (and that it actually
		     * wants to run).
		     */
		    fpPatchHALInfo = (fpValidate)( &guid );
		    if( NULL != fpPatchHALInfo )
		    {
			/*
			 * Got returned a non-NULL HAL patching function so the secondary
			 * driver wishes to run. However, we need to verify that the driver
			 * is one we have certified as being OK to run. Check the guid.
			 */
			if( IsEqualIID( &guid, &guidCertifiedSecondaryDriver ) )
			{
                            LPVOID  pFlipRoutine = (LPVOID) lpDDHALInfo->lpDDSurfaceCallbacks->Flip;

			    /*
			     * Its a certified secondary driver so invoke its HAL patching
			     * function with the given HAL info and callback thunks.
			     * The rule is if this function failes the DDHALINFO must be
			     * unmodified so we can carry on regardless.
			     */
			    (*fpPatchHALInfo)(lpDDHALInfo, &ddHALDD, &ddHALDDSurface, &ddHALDDPalette, &ddHALDDExeBuf);

                            //
                            // Only say we loaded it if the HALInfo was changed, specifically if the PVR took
                            // over the surface flip routine. This is an absolute must for the PVR.
                            // If the PVR is turned off via the control panel, then this fn pointer will be unchanged,
                            // and we can know later not to enumerate the PVR via GetDeviceIdentifier.
                            //
                            if (pFlipRoutine != (LPVOID) lpDDHALInfo->lpDDSurfaceCallbacks->Flip) 
                            {
                                bLoaded = TRUE;
                            }
			}
		    }
		}
	    }
	}
	RegCloseKey( hKey );
    }

    return bLoaded;
}
#endif /* WIN95 */

/*
 * mergeHELCaps
 *
 * merge HEL caps with default caps
 */
static void mergeHELCaps( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    int i;

    if( pdrv->dwFlags & DDRAWI_EMULATIONINITIALIZED )
    {
	pdrv->ddBothCaps.dwCaps &= pdrv->ddHELCaps.dwCaps;
	pdrv->ddBothCaps.dwCaps2 &= pdrv->ddHELCaps.dwCaps2;
	pdrv->ddBothCaps.dwCKeyCaps &= pdrv->ddHELCaps.dwCKeyCaps;
	pdrv->ddBothCaps.dwFXCaps &= pdrv->ddHELCaps.dwFXCaps;
	pdrv->lpddBothMoreCaps->dwAlphaCaps &= pdrv->lpddHELMoreCaps->dwAlphaCaps;
	pdrv->lpddBothMoreCaps->dwFilterCaps &= pdrv->lpddHELMoreCaps->dwFilterCaps;
#ifdef POSTPONED2
	pdrv->lpddBothMoreCaps->dwTransformCaps &= pdrv->lpddHELMoreCaps->dwTransformCaps;
#endif //POSTPONED2

	pdrv->ddBothCaps.dwSVBCaps &= pdrv->ddHELCaps.dwSVBCaps;
	pdrv->ddBothCaps.dwSVBCKeyCaps &= pdrv->ddHELCaps.dwSVBCKeyCaps;
	pdrv->ddBothCaps.dwSVBFXCaps &= pdrv->ddHELCaps.dwSVBFXCaps;
	pdrv->lpddBothMoreCaps->dwSVBAlphaCaps &= pdrv->lpddHELMoreCaps->dwSVBAlphaCaps;
	pdrv->lpddBothMoreCaps->dwSVBFilterCaps &= pdrv->lpddHELMoreCaps->dwSVBFilterCaps;
#ifdef POSTPONED2
	pdrv->lpddBothMoreCaps->dwSVBTransformCaps &= pdrv->lpddHELMoreCaps->dwSVBTransformCaps;
#endif //POSTPONED2

	pdrv->ddBothCaps.dwVSBCaps &= pdrv->ddHELCaps.dwVSBCaps;
	pdrv->ddBothCaps.dwVSBCKeyCaps &= pdrv->ddHELCaps.dwVSBCKeyCaps;
	pdrv->ddBothCaps.dwVSBFXCaps &= pdrv->ddHELCaps.dwVSBFXCaps;
	pdrv->lpddBothMoreCaps->dwVSBAlphaCaps &= pdrv->lpddHELMoreCaps->dwVSBAlphaCaps;
	pdrv->lpddBothMoreCaps->dwVSBFilterCaps &= pdrv->lpddHELMoreCaps->dwVSBFilterCaps;
#ifdef POSTPONED2
	pdrv->lpddBothMoreCaps->dwVSBTransformCaps &= pdrv->lpddHELMoreCaps->dwVSBTransformCaps;
#endif //POSTPONED2

	pdrv->ddBothCaps.dwSSBCaps &= pdrv->ddHELCaps.dwSSBCaps;
	pdrv->ddBothCaps.dwSSBCKeyCaps &= pdrv->ddHELCaps.dwSSBCKeyCaps;
	pdrv->ddBothCaps.dwSSBFXCaps &= pdrv->ddHELCaps.dwSSBFXCaps;
	pdrv->lpddBothMoreCaps->dwSSBAlphaCaps &= pdrv->lpddHELMoreCaps->dwSSBAlphaCaps;
	pdrv->lpddBothMoreCaps->dwSSBFilterCaps &= pdrv->lpddHELMoreCaps->dwSSBFilterCaps;
#ifdef POSTPONED2
	pdrv->lpddBothMoreCaps->dwSSBTransformCaps &= pdrv->lpddHELMoreCaps->dwSSBTransformCaps;
#endif //POSTPONED2

	for( i=0;i<DD_ROP_SPACE;i++ )
	{
	    pdrv->ddBothCaps.dwRops[i] &= pdrv->ddHELCaps.dwRops[i];
	    pdrv->ddBothCaps.dwSVBRops[i] &= pdrv->ddHELCaps.dwSVBRops[i];
	    pdrv->ddBothCaps.dwVSBRops[i] &= pdrv->ddHELCaps.dwVSBRops[i];
	    pdrv->ddBothCaps.dwSSBRops[i] &= pdrv->ddHELCaps.dwSSBRops[i];
	}
	pdrv->ddBothCaps.ddsCaps.dwCaps &= pdrv->ddHELCaps.ddsCaps.dwCaps;

	if( NULL != pdrv->lpddNLVBothCaps )
	{
	    DDASSERT( NULL != pdrv->lpddNLVHELCaps );

	    pdrv->lpddNLVBothCaps->dwNLVBCaps     &= pdrv->lpddNLVHELCaps->dwNLVBCaps;
	    pdrv->lpddNLVBothCaps->dwNLVBCaps2    &= pdrv->lpddNLVHELCaps->dwNLVBCaps2;
	    pdrv->lpddNLVBothCaps->dwNLVBCKeyCaps &= pdrv->lpddNLVHELCaps->dwNLVBCKeyCaps;
	    pdrv->lpddNLVBothCaps->dwNLVBFXCaps   &= pdrv->lpddNLVHELCaps->dwNLVBFXCaps;
	    for( i = 0; i < DD_ROP_SPACE; i++ )
		pdrv->lpddNLVBothCaps->dwNLVBRops[i] &= pdrv->lpddNLVHELCaps->dwNLVBRops[i];
	}

	if( pdrv->lpddBothMoreCaps != NULL )
	{
	    DDASSERT( pdrv->lpddHELMoreCaps != NULL );

	    pdrv->lpddBothMoreCaps->dwAlphaCaps    &= pdrv->lpddHELMoreCaps->dwAlphaCaps;
	    pdrv->lpddBothMoreCaps->dwSVBAlphaCaps &= pdrv->lpddHELMoreCaps->dwSVBAlphaCaps;
	    pdrv->lpddBothMoreCaps->dwVSBAlphaCaps &= pdrv->lpddHELMoreCaps->dwVSBAlphaCaps;
	    pdrv->lpddBothMoreCaps->dwSSBAlphaCaps &= pdrv->lpddHELMoreCaps->dwSSBAlphaCaps;

	    pdrv->lpddBothMoreCaps->dwFilterCaps    &= pdrv->lpddHELMoreCaps->dwFilterCaps;
	    pdrv->lpddBothMoreCaps->dwSVBFilterCaps &= pdrv->lpddHELMoreCaps->dwSVBFilterCaps;
	    pdrv->lpddBothMoreCaps->dwVSBFilterCaps &= pdrv->lpddHELMoreCaps->dwVSBFilterCaps;
	    pdrv->lpddBothMoreCaps->dwSSBFilterCaps &= pdrv->lpddHELMoreCaps->dwSSBFilterCaps;

#ifdef POSTPONED2
	    pdrv->lpddBothMoreCaps->dwTransformCaps    &= pdrv->lpddHELMoreCaps->dwTransformCaps;
	    pdrv->lpddBothMoreCaps->dwSVBTransformCaps &= pdrv->lpddHELMoreCaps->dwSVBTransformCaps;
	    pdrv->lpddBothMoreCaps->dwVSBTransformCaps &= pdrv->lpddHELMoreCaps->dwVSBTransformCaps;
	    pdrv->lpddBothMoreCaps->dwSSBTransformCaps &= pdrv->lpddHELMoreCaps->dwSSBTransformCaps;
#endif //POSTPONED2
	}
    }
} /* mergeHELCaps */

// This variable is a shared instance and has been moved to dllmain.c: BOOL     bReloadReg;

/*
 * capsInit
 *
 * initialize shared caps
 */
static void capsInit( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    #ifdef DEBUG
	if( GetProfileInt("DirectDraw","nohwblt",0) )
	{
	    pdrv->ddCaps.dwCaps &= ~DDCAPS_BLT;
	    DPF( 2, "Turning off blt <<<<<<<<<<<<<<<<<<<<<<<<<<" );
	}
	if( GetProfileInt("DirectDraw","nohwtrans",0) )
	{
	    pdrv->ddCaps.dwCKeyCaps &= ~(DDCKEYCAPS_DESTBLT|DDCKEYCAPS_SRCBLT);
	    DPF( 2, "Turning off hardware transparency <<<<<<<<<<<<<<<<<<<<<<<<<<" );
	}
	if( GetProfileInt("DirectDraw","nohwfill",0) )
	{
	    pdrv->ddCaps.dwCaps &= ~(DDCAPS_BLTCOLORFILL);
	    DPF( 2, "Turning off color fill <<<<<<<<<<<<<<<<<<<<<<<<<<" );
	}
    #endif

    // initialize the BothCaps structure
    pdrv->ddBothCaps = pdrv->ddCaps;
    if( NULL != pdrv->lpddNLVCaps )
    {
	DDASSERT( NULL != pdrv->lpddNLVBothCaps );

	memcpy( pdrv->lpddNLVBothCaps, pdrv->lpddNLVCaps, sizeof( DDNONLOCALVIDMEMCAPS ) );
    }
    else if ( pdrv->lpddNLVBothCaps != NULL)
    {
        ZeroMemory( pdrv->lpddNLVBothCaps, sizeof( DDNONLOCALVIDMEMCAPS ) );
        pdrv->lpddNLVBothCaps->dwSize = sizeof( DDNONLOCALVIDMEMCAPS );
    }

    if( pdrv->lpddBothMoreCaps != NULL )
    {
	DDASSERT( pdrv->lpddMoreCaps != NULL );

	memcpy(pdrv->lpddBothMoreCaps, pdrv->lpddMoreCaps, sizeof(DDMORECAPS));
    }
} /* capsInit */

#ifdef WINNT
//
// pdd_gbl may be null (if coming from the create code path) or non null (from the reset code path).
// We assert that if pdd_gbl==NULL, then we can't be in an emulated ModeX mode, because the
// only way to get there is to use a ddraw object to set such a mode. So we only have to check
// for fake modex mode if pdd_gbl is non-null.
//
BOOL GetCurrentMode(LPDDRAWI_DIRECTDRAW_GBL pdd_gbl, LPDDHALINFO lpHalInfo, char *szDrvName)
{
    LPDDHALMODEINFO pmi;
    DEVMODE dm;
    HDC hdc;
    LPCTSTR pszDevice;

    pmi = MemAlloc(sizeof (DDHALMODEINFO));

    if (pmi)
    {
        pszDevice = _stricmp(szDrvName, DISPLAY_STR) ? szDrvName : NULL;

        ZeroMemory(&dm, sizeof dm);
        dm.dmSize = sizeof dm;

        if ( pdd_gbl && pdd_gbl->dwFlags & DDRAWI_MODEX )
        {
            // If the current mode is modex, then we could only have gotten here if
            // it's the current mode.
            pmi->dwWidth = pdd_gbl->dmiCurrent.wWidth;
            pmi->dwHeight = pdd_gbl->dmiCurrent.wHeight;
            pmi->dwBPP = pdd_gbl->dmiCurrent.wBPP;
            pmi->wRefreshRate = pdd_gbl->dmiCurrent.wRefreshRate;
            pmi->lPitch = pmi->dwWidth;
            pmi->dwRBitMask = 0;
            pmi->dwGBitMask = 0;
            pmi->dwBBitMask = 0;
            pmi->dwAlphaBitMask = 0;
        }
        else if (EnumDisplaySettings(pszDevice, ENUM_CURRENT_SETTINGS, &dm))
        {
            pmi->dwWidth = dm.dmPelsWidth;
            pmi->dwHeight = dm.dmPelsHeight;
            pmi->dwBPP = dm.dmBitsPerPel;
            pmi->wRefreshRate = (WORD) dm.dmDisplayFrequency;
            pmi->lPitch = (pmi->dwWidth * pmi->dwBPP) >> 3;

            if (pmi->dwBPP > 8)
            {
                void FillBitMasks(LPDDPIXELFORMAT pddpf, HDC hdc);
                DDPIXELFORMAT ddpf;

                hdc = DD_CreateDC(szDrvName);
                if (hdc)
                {
                    FillBitMasks(&ddpf, hdc);
                    DD_DoneDC(hdc);
                }

                if (pmi->dwBPP == 15)
                {
                    pmi->dwBPP = 16;
                    pmi->wFlags = DDMODEINFO_555MODE;
                }

                pmi->dwRBitMask = ddpf.dwRBitMask;
                pmi->dwGBitMask = ddpf.dwGBitMask;
                pmi->dwBBitMask = ddpf.dwBBitMask;
                pmi->dwAlphaBitMask = ddpf.dwRGBAlphaBitMask;
            }
            else
            {
                pmi->wFlags = DDMODEINFO_PALETTIZED;
            }

            lpHalInfo->dwNumModes = 1;
            lpHalInfo->dwMonitorFrequency = pmi->wRefreshRate;
        }
        else
        {
            MemFree(pmi);
            pmi = NULL;
        }
    }

    lpHalInfo->lpModeInfo = pmi;
    return pmi != NULL;
}
#endif

static HRESULT
GetDriverInfo(LPDDHAL_GETDRIVERINFO lpGetDriverInfo,
	      LPDDHAL_GETDRIVERINFODATA lpGDInfo,
	      LPVOID lpDriverInfo, 
              DWORD dwSize, 
              const GUID *lpGUID, 
              LPDDRAWI_DIRECTDRAW_GBL lpDD,
              BOOL bInOut)  // Indicates whether the data passed is in/out or just out
{
    int i;

    // 1K temp buffer to pull driver info into
    static DWORD dwDriverInfoBuffer[256];

    if (bInOut)
    {
        DDASSERT((dwSize & 3) == 0);

        // Copy over the data from our source
	memcpy(dwDriverInfoBuffer, lpDriverInfo, dwSize);

        // Only dead-beef the unused part of the buffer
        i = dwSize>>2;
    }
    else
    {
        i = 0;
    }

    for (i; i < 256; i += 1)
	dwDriverInfoBuffer[i] = 0xdeadbeef;

#ifdef DEBUG
    if(dwSize>255*sizeof(DWORD)) {  // 0xdeadbeef overwrite test wont work unless dwSize>>2 <= 255
       DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Internal DDraw Error:  GetDriverInfo() dwSize parameter > 1020");
       return DDERR_NODIRECTDRAWSUPPORT;
    }
#endif

    memset(lpGDInfo, 0, sizeof(*lpGDInfo) );
    lpGDInfo->dwSize = sizeof(*lpGDInfo);
    lpGDInfo->dwFlags = 0;
    memcpy(&lpGDInfo->guidInfo, lpGUID, sizeof(*lpGUID) );
    lpGDInfo->dwExpectedSize = dwSize;
    lpGDInfo->lpvData = dwDriverInfoBuffer;
    lpGDInfo->ddRVal = DDERR_GENERIC;

    // Pass a context variable so that the driver
    // knows which instance of itself to use
    // w.r.t. this function. These are different
    // values on Win95 and NT.
#ifdef WIN95
    lpGDInfo->dwContext = lpDD->dwReserved3;
#else
    lpGDInfo->dwContext = lpDD->hDD;
#endif

    if ( lpGetDriverInfo(lpGDInfo) == DDHAL_DRIVER_HANDLED && lpGDInfo->ddRVal == DD_OK )
    {
	// Fail if the driver wrote more bytes than the expected size
	if (dwDriverInfoBuffer[dwSize>>2] != 0xdeadbeef)
	{
	    return DDERR_NODIRECTDRAWSUPPORT;
	}
	memcpy(lpDriverInfo, dwDriverInfoBuffer, min(dwSize, lpGDInfo->dwActualSize));
    }
    return lpGDInfo->ddRVal;
}

static BOOL
ValidateCallbacks(LPVOID lpCallbacks)
{
    int N = ((((DWORD FAR *) lpCallbacks)[0] >> 2) - 2) / (sizeof(DWORD_PTR) / sizeof(DWORD));
    if (N > 0)
    {
	    DWORD dwFlags = ((DWORD FAR *) lpCallbacks)[1];
	    DWORD bit = 1;
	    int i;
        LPVOID *pcbrtn = (LPVOID *) &(((DWORD FAR *) lpCallbacks)[2]);
	    for (i = 0; i < N; i += 1)
	    {
            LPVOID cbrtn;
	        cbrtn = *pcbrtn++;

	        // If a function is non-NULL and they failed to set the
	        // 32-bit flag, fail.  We might support 16-bit callbacks
	        // in future but not for now.
	        if ( (cbrtn != NULL) && ( 0 == (dwFlags & bit) ) )
		        return FALSE;

	        if (dwFlags & bit)
	        {
#if defined(NT_FIX) || defined(WIN95)   // check this some other way            // If the bit is set, validate the callback.
		        if (! VALIDEX_CODE_PTR(cbrtn) )
		        {
		            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32-bit callback");
		            return FALSE;
		        }
#endif
	        }
	        bit <<= 1;
	    }
    }
    return TRUE;
}

/*
 * Validate the core HAL information the driver passed to us.
 */
BOOL
ValidateCoreHALInfo( LPDDHALINFO lpDDHALInfo )
{
    int                             i;
    LPVIDMEM                        pvm;
    int                             numcb;
    LPDDHAL_DDCALLBACKS             drvcb;
    LPDDHAL_DDSURFACECALLBACKS      surfcb;
    LPDDHAL_DDPALETTECALLBACKS      palcb;
    LPDDHAL_DDEXEBUFCALLBACKS       exebufcb;
    DWORD                           bit;
    LPVOID                          cbrtn;

    TRY
    {
	/*
	 * Valid HAL info
	 */
	if( !VALIDEX_DDHALINFO_PTR( lpDDHALInfo ) )
	{
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid DDHALINFO provided: 0x%p",lpDDHALInfo );
	    if( lpDDHALInfo != NULL )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: size = was %d, expecting %d or %d", lpDDHALInfo->dwSize, sizeof( DDHALINFO ), sizeof( DDHALINFO_V1) );
	    }
	    return FALSE;
	}
	if( lpDDHALInfo->dwSize == sizeof( DDHALINFO_V1 ) )
	{
	    /*
	     * The DDHALINFO structure returned by the driver is in the DDHALINFO_V1
	     * format.  Convert it to the new DDHALINFO structure.
	     */
	    convertV1DDHALINFO( lpDDHALInfo );
	}

	/*
	 * validate video memory heaps
	 */
	for( i=0;i<(int)lpDDHALInfo->vmiData.dwNumHeaps;i++ )
	{
	    pvm = &lpDDHALInfo->vmiData.pvmList[i];
	    if( pvm->dwFlags & VIDMEM_ISNONLOCAL )
	    {
		/*
		 * NOTE: It is entirely legal to pass a NULL fpStart for a non-local
		 * heap. The start address is meaningless for non-local heaps.
		 */

		/*
		 * If the heap is non-local then the driver must have specified
		 * the DDCAPS2_NONLOCALVIDMEM. If it hasn't we fail the initialization.
		 */
		if( !( lpDDHALInfo->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM ) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Non-local video memory heap passed but DDCAPS2_NONLOCALVIDMEM not specified" );
		    return FALSE;
		}
	    }
	    else
	    {
		if( (pvm->fpStart == (FLATPTR) NULL) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid video memory fpStart pointer passed" );
		    return FALSE;
		}

		/*
		 * This is not a local video memory heap and WC is specified. Currently
		 * this is not legal.
		 */
		#pragma message( REMIND( "Look into enabling WC on local vid mem" ) )
		if( pvm->dwFlags & VIDMEM_ISWC )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver can't specify write combining with a local video memory heap" );
		    return FALSE;
		}
	    }
	}

	/*
	 * validate pixel format
	 *
	 * NOTE:  The dwSize check below may seem redundant since the DDPIXELFORMAT
	 * struct is embedded in a DDHAL struct whose size has already been validated.
	 * But removing this test caused stress failures with drivers that do not
	 * support DDraw.  The drivers were running "accelerated" but with virtually
	 * no caps.  So we'll keep this test until the problem is better understood.
	 */
	if( lpDDHALInfo->vmiData.ddpfDisplay.dwSize != sizeof( DDPIXELFORMAT ) )
	{
            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid DDPIXELFORMAT in DDHALINFO.vmiData: bad size" );
	    return FALSE;
	}
	/*
	 * DX4; Validate it some more.
	 */
	if ( (lpDDHALInfo->vmiData.ddpfDisplay.dwFlags & DDPF_PALETTEINDEXED8) &&
		(lpDDHALInfo->vmiData.ddpfDisplay.dwRGBBitCount != 8) )
	{
            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid DDPIXELFORMAT in DDHALINFO.vmiData: palettized mode must be 8bpp" );
	    return FALSE;
	}

	/*
	 * validate driver callback
	 */
	drvcb = lpDDHALInfo->lpDDCallbacks;
	if( drvcb != NULL )
	{
	    if( !VALID_PTR_PTR( drvcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid driver callback ptr" );
		return FALSE;
	    }
	    if( !VALIDEX_DDCALLBACKSSIZE( drvcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid size field in lpDriverCallbacks" );
		return FALSE;
	    }

	    numcb = NUM_CALLBACKS( drvcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( drvcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    cbrtn = (LPVOID) (&drvcb->DestroyDriver)[i];
		    if( cbrtn != NULL )
		    {
			#if defined(NT_FIX) || defined(WIN95)   // check this some other way
			    if( !VALIDEX_CODE_PTR( cbrtn ) )
			    {
				DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32-bit callback in lpDriverCallbacks" );
				return FALSE;
			    }
			#endif
		    }
		}
		bit <<= 1;
	    }
	}

	/*
	 * Turn off optimized surfaces just for now
	 */
	if (lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
	{
	    DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver tried to set DDSCAPS_OPTIMIZED. Not allowed for this release");
	    return FALSE;
	}

	/*
	 * We used to ensure that no driver ever set dwCaps2. However,
	 * we have now run out of bits in ddCaps.dwCaps so we need to
	 * allow drivers to set bits in dwCaps2. Hence all we do now
	 * is ensure that drivers don't try and impersonate certified
	 * drivers by returning DDCAPS2_CERTIFIED. This is something
	 * we turn on - they can't set it.
	 */
	if( lpDDHALInfo->ddCaps.dwCaps2 & DDCAPS2_CERTIFIED )
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver tried to set the DDCAPS2_CERTIFIED" );
	    return FALSE;
	}

	/*
	 * validate surface callbacks
	 */
	surfcb = lpDDHALInfo->lpDDSurfaceCallbacks;
	if( surfcb != NULL )
	{
	    if( !VALID_PTR_PTR( surfcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid surface callback ptr" );
		return FALSE;
	    }
	    if( !VALIDEX_DDSURFACECALLBACKSSIZE( surfcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid size field in lpSurfaceCallbacks" );
		return FALSE;
	    }
	    numcb = NUM_CALLBACKS( surfcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( surfcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    cbrtn = (LPVOID) (&surfcb->DestroySurface)[i];
		    if( cbrtn != NULL )
		    {
			#if defined(NT_FIX) || defined(WIN95) //check some other way
			    if( !VALIDEX_CODE_PTR( cbrtn ) )
			    {
				DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32/64-bit callback in lpSurfaceCallbacks" );
                                // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
				DPF( 0, "Callback = 0x%p, i = %d, bit = 0x%08lx", cbrtn, i, bit );
				return FALSE;
			    }
			#endif
		    }
		}
		bit <<= 1;
	    }
	}

	/*
	 * validate palette callbacks
	 */
	palcb = lpDDHALInfo->lpDDPaletteCallbacks;
	if( palcb != NULL )
	{
	    if( !VALID_PTR_PTR( palcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid palette callback ptr" );
		return FALSE;
	    }
	    if( !VALIDEX_DDPALETTECALLBACKSSIZE( palcb ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid size field in lpPaletteCallbacks" );
		return FALSE;
	    }
	    numcb = NUM_CALLBACKS( palcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( palcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    cbrtn = (LPVOID) (&palcb->DestroyPalette)[i];
		    if( cbrtn != NULL )
		    {
			#if defined(NT_FIX) || defined(WIN95)
			    if( !VALIDEX_CODE_PTR( cbrtn ) )
			    {
				DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32-bit callback in lpPaletteCallbacks" );
				return FALSE;
			    }
			#endif
		    }
		}
		bit <<= 1;
	    }
	}

	/*
	 * validate execute buffer callbacks - but only (and I mean ONLY) if
	 * its a V2 driver and it knows about execute buffers.
	 */
	if( lpDDHALInfo->dwSize >= DDHALINFOSIZE_V2 )
	{
	    exebufcb = lpDDHALInfo->lpDDExeBufCallbacks;
	    if( exebufcb != NULL )
	    {
		if( !VALID_PTR_PTR( exebufcb ) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid execute buffer callback ptr" );
		    return FALSE;
		}
		if( !VALIDEX_DDEXEBUFCALLBACKSSIZE( exebufcb ) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid size field in lpExeBufCallbacks" );
		    return FALSE;
		}
		numcb = NUM_CALLBACKS( exebufcb );
		bit = 1;
		for( i=0;i<numcb;i++ )
		{
		    if( exebufcb->dwFlags & bit )
		    {
                        // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
			cbrtn = (LPVOID) (&exebufcb->CanCreateExecuteBuffer)[i];
			if( cbrtn != NULL )
			{
			    #if defined(NT_FIX) || defined(WIN95)
				if( !VALIDEX_CODE_PTR( cbrtn ) )
				{
				    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Invalid 32-bit callback in lpExeBufCallbacks" );
				    return FALSE;
				}
			    #endif
			}
		    }
		    bit <<= 1;
		}
	    }
	}

	/*
	 * Make sure a mode table was specified
	 */
	if( ( lpDDHALInfo->dwNumModes > 0 ) &&
	    ( lpDDHALInfo->lpModeInfo == NULL ) )
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver says modes are supported, but DDHALINFO.lpModeInfo = NULL" );
	    return FALSE;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Exception encountered validating driver HAL information" );
	DEBUG_BREAK();
	return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the new HAL information from a driver (if any) and validate it.
 */
static BOOL
GetAndValidateNewHALInfo( LPDDRAWI_DIRECTDRAW_GBL pddd,
			  LPDDHALINFO             lpDDHALInfo )
{
    pddd->lpD3DHALCallbacks2 = 0;
    pddd->lpD3DHALCallbacks3 = 0;
    pddd->lpZPixelFormats = NULL;
    pddd->pGetDriverInfo = NULL;
#ifdef POSTPONED
    pddd->lpDDUmodeDrvInfo = NULL;
    pddd->lpDDOptSurfaceInfo = NULL;
#endif

    TRY
    {
	memset(&pddd->lpDDCBtmp->HALDDMiscellaneous, 0, sizeof(pddd->lpDDCBtmp->HALDDMiscellaneous) );
	memset(&pddd->lpDDCBtmp->HALDDMiscellaneous2, 0, sizeof(pddd->lpDDCBtmp->HALDDMiscellaneous2) );
#ifndef WIN95
        memset(&pddd->lpDDCBtmp->HALDDNT, 0, sizeof(pddd->lpDDCBtmp->HALDDNT) );
#endif
	memset(&pddd->lpDDCBtmp->HALDDVideoPort, 0, sizeof(pddd->lpDDCBtmp->HALDDVideoPort) );
	memset(&pddd->lpDDCBtmp->HALDDColorControl, 0, sizeof(pddd->lpDDCBtmp->HALDDColorControl) );
	memset(&pddd->lpDDCBtmp->HALDDKernel, 0, sizeof(pddd->lpDDCBtmp->HALDDKernel) );

	    /*
	     * Allocate memory for D3D DDI interfaces queried from GetDriverInfo
	     * (the freeing of this memory for failed driver init needs work)
	     */
	pddd->lpD3DHALCallbacks2 = MemAlloc( D3DHAL_CALLBACKS2SIZE );
	if (! pddd->lpD3DHALCallbacks2)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Out of memory querying D3DCallbacks2" );
	    goto failed;
	}
	pddd->lpD3DHALCallbacks3 = MemAlloc( D3DHAL_CALLBACKS3SIZE );
	if (! pddd->lpD3DHALCallbacks3)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Out of memory querying D3DCallbacks3" );
	    goto failed;
	}

#ifdef POSTPONED
	pddd->lpDDUmodeDrvInfo =
	    (LPDDUMODEDRVINFO) MemAlloc (sizeof (DDUMODEDRVINFO));
	if (! pddd->lpDDUmodeDrvInfo)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Out of memory querying UserModeDriverInfo" );
	    goto failed;
	}
#endif

	if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
	{
	    HRESULT ret;
	    DDHAL_GETDRIVERINFODATA gdidata;
	    D3DHAL_CALLBACKS2 D3DCallbacks2;
	    D3DHAL_CALLBACKS3 D3DCallbacks3;

	    if (! VALIDEX_CODE_PTR (lpDDHALInfo->GetDriverInfo) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: GetDriverInfo callback bit set, but not valid" );
		goto failed;
	    }

        // use fact that code pointer was validated before...
        pddd->pGetDriverInfo=lpDDHALInfo->GetDriverInfo;

	    /*
	     * Probe the driver with a GUID of bogusness. If it claims to
	     * understand this one, then fail driver create.
	     */
	    {
		DWORD dwFakeGUID[4];
		DWORD dwTemp[10];

		memcpy(dwFakeGUID, &CLSID_DirectDraw, sizeof(dwFakeGUID));
		dwFakeGUID[3] += GetCurrentProcessId();

		ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				    dwTemp,
				    sizeof(dwTemp),
				    (const GUID *) dwFakeGUID, pddd,
                                    FALSE /* bInOut */);
		if ( ret == DD_OK )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Driver claimed support via GetDriverInfo for bogus GUID!" );
		    goto failed;
		}
	    }

            /*
             * Notify driver about DXVERSION on NT
             */
#ifndef WIN95
            if (lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFO2)
            {
                // This buffer is used to pass information down to the driver and get
                // information back from the driver. The GetDriverInfo2 header and
                // any additional information to pass to the driver is copied into this
                // buffer prior to calling GetDriverInfo2. After the call the information
                // returned by the driver is contained in this buffer. All information
                // passed to and from the driver must fit within a buffer of this size.

                // The buffer used by GetDriverInfo2 is constrained to the maximum size
                // specified below by restrictions in the Win2K kernel. It is vital that
                // all data passed to the driver and received from the driver via
                // GetDriverInfo2 fit within a buffer of this number of DWORDS.
                // This size has to be less than 1K to let the kernel do its own buffer
                // overwrite testing.
                #define MAX_GDI2_BUFFER_DWORD_SIZE (249)

                DWORD                  buffer[MAX_GDI2_BUFFER_DWORD_SIZE];
                DD_DXVERSION*          pDXVersion;
        
                // Set up the DXVersion call
                memset(&buffer, 0, sizeof(buffer));
                pDXVersion = (DD_DXVERSION *)buffer;

                // Before we do anything else, we notify the
                // driver about the DX version information. We ignore
                // errors here.
                pDXVersion->gdi2.dwReserved     = sizeof(DD_STEREOMODE);
                pDXVersion->gdi2.dwMagic        = D3DGDI2_MAGIC;
                pDXVersion->gdi2.dwType         = D3DGDI2_TYPE_DXVERSION;
                pDXVersion->gdi2.dwExpectedSize = sizeof(DD_DXVERSION);
                pDXVersion->dwDXVersion         = DD_RUNTIME_VERSION;

                // We assert the sizes are the same because we need to
                // persuade the kernel into accepting this call.
                DDASSERT(sizeof(DD_STEREOMODE) == sizeof(DD_DXVERSION));

	        ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				    buffer,
				    sizeof(DD_STEREOMODE),
				    &GUID_GetDriverInfo2, pddd,
                                    TRUE /* bInOut */);

                // Errors are ignored here
                ret = 0;

                // Also notify the driver that we have the AGP aliasing
                // work-around in place.
                {
                    DD_DEFERRED_AGP_AWARE_DATA  aad;
                    DWORD                       dwDrvRet;

                    GetDriverInfo2(pddd,
                                   &dwDrvRet,
                                   D3DGDI2_TYPE_DEFERRED_AGP_AWARE,
                                   sizeof(aad), &aad);
                }
            }
#endif // !WIN95

	    memset(&pddd->lpDDCBtmp->HALDDMiscellaneous, 0, sizeof(DDHAL_DDMISCELLANEOUSCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDMiscellaneous,
				sizeof(DDHAL_DDMISCELLANEOUSCALLBACKS),
				&GUID_MiscellaneousCallbacks, pddd,
                                FALSE /* bInOut */ );
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDMISCELLANEOUSCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDMiscellaneous ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDMISCELLANEOUSCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDMiscellaneous) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous): flags set incorrectly" );
		    goto failed;
		}

	    }

	    // Get HALDDMiscellaneous2 interface.
	    memset(&pddd->lpDDCBtmp->HALDDMiscellaneous2, 0, sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDMiscellaneous2,
				sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS),
				&GUID_Miscellaneous2Callbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous2): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDMISCELLANEOUS2CALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDMiscellaneous2 ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous2): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDMiscellaneous2) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Miscellaneous2): flags set incorrectly" );
		    goto failed;
		}

                if (lpDDHALInfo->lpD3DGlobalDriverData &&
                    (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & 
                     (D3DDEVCAPS_DRAWPRIMITIVES2EX | D3DDEVCAPS_HWTRANSFORMANDLIGHT) )
                   )
                {
                    // If a driver responds to the Misc2 GUID, then it better return
                    // a non-null GetDriverState callback.
		    if (0 == pddd->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState)
		    {
		        DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (HALDDMiscellaneous2): no GetDriverState support" );
		        goto failed;
		    }
#ifdef WIN95
                    // On Win95 the CreateSurfaceEx should be non-NULL
		    if (0 == pddd->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx)
		    {
		        DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (HALDDMiscellaneous2): CreateSurfaceEx must be reported with D3DDEVCAPS_DRAWPRIMITIVES2EX" );
		        goto failed;
		    }
#else //WIN95
                    // DX7 drivers should export GetDriverState always, if they 
                    // didnt, then most likely they are the transition drivers that 
                    // are still DX6 and will need to be updated. For now dont 
                    // validate the presence of this callback. Simply use its 
                    // presence or absence to spoof the legacy texture callbacks.
                    DDASSERT( lpDDHALInfo->lpD3DHALCallbacks->TextureCreate  == NULL);
                    DDASSERT( lpDDHALInfo->lpD3DHALCallbacks->TextureDestroy == NULL);
                    DDASSERT( lpDDHALInfo->lpD3DHALCallbacks->TextureSwap    == NULL);
                    DDASSERT( lpDDHALInfo->lpD3DHALCallbacks->TextureGetSurf == NULL);
#endif //WIN95
                }
	    }

#ifdef WIN95
	    if (0 != pddd->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx)
	    {
                if (lpDDHALInfo->lpD3DGlobalDriverData)
                {
                    if (!(lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & 
                        D3DDEVCAPS_DRAWPRIMITIVES2EX))
                    {
                        if(lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dpcTriCaps.dwRasterCaps & 
                            D3DPRASTERCAPS_ZBUFFERLESSHSR)
                        //legacy powerVR stackable driver would actually forward new callbacks
                        //if the primary driver supports the new callbacks
                        {
                            pddd->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx=0;
                            pddd->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState=0;
                            pddd->lpDDCBtmp->HALDDMiscellaneous2.DestroyDDLocal=0;
                        }
                        else
                        {
                    
		            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (HALDDMiscellaneous2): CreateSurfaceEx must be reported with D3DDEVCAPS_DRAWPRIMITIVES2EX" );
		            goto failed;
                        }
                    }
                }
	    }
#else   //WIN95
            memset(&pddd->lpDDCBtmp->HALDDNT, 0, sizeof(DDHAL_DDNTCALLBACKS) );
            /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
            ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
                                &pddd->lpDDCBtmp->HALDDNT,
                                sizeof(DDHAL_DDNTCALLBACKS),
                                &GUID_NTCallbacks, pddd,
                                FALSE /* bInOut */);
            // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
            // overwrote its buffer.

            if ( ret == DDERR_NODIRECTDRAWSUPPORT )
            {
                DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (NT): Driver overwrote callbacks buffer" );
                goto failed;
            }

            if ( ret == DD_OK )
            {
                // Fail create if driver already failed validation or
                // claims support but it's not valid.

                if (! VALIDEX_DDNTCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDNT ) ||
                    ( gdidata.dwActualSize < sizeof(DDHAL_DDNTCALLBACKS ) ) )

                {
                    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (NT): size not valid" );
                    goto failed;
                }

                if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDNT) )
                {
                    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (NT): flags set incorrectly" );
                    goto failed;
                }
            }

            memset(&pddd->lpDDCBtmp->HALDDVPE2, 0, sizeof(DDHAL_DDVPE2CALLBACKS) );
            /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
            ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
                                &pddd->lpDDCBtmp->HALDDVPE2,
                                sizeof(DDHAL_DDVPE2CALLBACKS),
                                &GUID_VPE2Callbacks, pddd,
                                FALSE /* bInOut */);
            // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
            // overwrote its buffer.

            if ( ret == DDERR_NODIRECTDRAWSUPPORT )
            {
                DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VPE2): Driver overwrote callbacks buffer" );
                goto failed;
            }

            if ( ret == DD_OK )
            {
                // Fail create if driver already failed validation or
                // claims support but it's not valid.

                if (! VALIDEX_DDVPE2CALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDVPE2 ) ||
                    ( gdidata.dwActualSize < sizeof(DDHAL_DDVPE2CALLBACKS ) ) )

                {
                    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VPE2): size not valid" );
                    goto failed;
                }

                if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDVPE2) )
                {
                    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VPE2): flags set incorrectly" );
                    goto failed;
                }
            }
#endif

	    memset(&pddd->lpDDCBtmp->HALDDVideoPort, 0, sizeof(DDHAL_DDVIDEOPORTCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDVideoPort,
				sizeof(DDHAL_DDVIDEOPORTCALLBACKS),
				&GUID_VideoPortCallbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.
	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VideoPort): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDVIDEOPORTCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDVideoPort ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDVIDEOPORTCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VideoPort): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDVideoPort) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (VideoPort): flags set incorrectly" );
		    goto failed;
		}
	    }

            memset(&pddd->lpDDCBtmp->HALDDMotionComp, 0, sizeof(DDHAL_DDMOTIONCOMPCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
                                &pddd->lpDDCBtmp->HALDDMotionComp,
                                sizeof(DDHAL_DDMOTIONCOMPCALLBACKS),
                                &GUID_MotionCompCallbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.
	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (MotionComp): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

                if (! VALIDEX_DDMOTIONCOMPCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDMotionComp ) ||
                    ( gdidata.dwActualSize < sizeof(DDHAL_DDMOTIONCOMPCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (MotionComp): size not valid" );
		    goto failed;
		}

                if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDMotionComp) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (MotionComp): flags set incorrectly" );
		    goto failed;
		}
	    }

	    memset(&pddd->lpDDCBtmp->HALDDColorControl, 0, sizeof(DDHAL_DDCOLORCONTROLCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDColorControl,
				sizeof(DDHAL_DDCOLORCONTROLCALLBACKS),
				&GUID_ColorControlCallbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (ColorControl): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDCOLORCONTROLCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDColorControl ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDCOLORCONTROLCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (ColorControl): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDColorControl) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (ColorControl): flags set incorrectly" );
		    goto failed;
		}
	    }

	    /*
	     *  Probe and validate D3DCallbacks2 support
	     */
	    // memset assures Clear2 will be NULL for DX5 drivers
	    memset(&D3DCallbacks2, 0, D3DHAL_CALLBACKS2SIZE );

	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&D3DCallbacks2, D3DHAL_CALLBACKS2SIZE,
				&GUID_D3DCallbacks2, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_D3DCALLBACKS2SIZE (&D3DCallbacks2 ))
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&D3DCallbacks2) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): flags set incorrectly" );
		    goto failed;
		}

		if  ( (D3DCallbacks2.DrawOnePrimitive ||
		       D3DCallbacks2.DrawOneIndexedPrimitive ||
		       D3DCallbacks2.DrawPrimitives) &&
		      (! (D3DCallbacks2.DrawOnePrimitive &&
			  D3DCallbacks2.DrawOneIndexedPrimitive &&
			  D3DCallbacks2.DrawPrimitives) ) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): must export all or none of DrawPrimitive callbacks" );
		    goto failed;
		}

#if 0
		if ( D3DCallbacks2.DrawOnePrimitive )
		{
		    // If they export DrawPrimitive driver entry points but did
		    // not set D3DDEVCAPS_DRAWPRIMTLVERTEX, fail driver create.
		    if (! (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMTLVERTEX) )
		    {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): DrawPrimitive entry points exported" );
			DPF_ERR( "from driver but D3DDEVCAPS_DRAWPRIMTLVERTEX not set" );
			goto failed;
		    }

		}
		else
		{
		    // If they set the caps but don't export the entry points,
		    // fail driver create.
		    if (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMTLVERTEX )
		    {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks2): D3DDEVCAPS_DRAWPRIMTLVERTEX set" );
			DPF_ERR( "but no DrawPrimitive entry points exported" );
			goto failed;
		    }

		}
#endif

		memcpy((LPVOID) pddd->lpD3DHALCallbacks2, &D3DCallbacks2, D3DHAL_CALLBACKS2SIZE);

	    }
	    else{
		memset((LPVOID) pddd->lpD3DHALCallbacks2, 0, D3DHAL_CALLBACKS2SIZE );
	    }

	    /*
	     *  Probe and validate D3DCallbacks3 support
	     */
	    memset(&D3DCallbacks3, 0, D3DHAL_CALLBACKS3SIZE );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&D3DCallbacks3, D3DHAL_CALLBACKS3SIZE,
				&GUID_D3DCallbacks3, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): Driver overwrote callbacks buffer" );
            goto failed;
        }

	    if ( ret == DD_OK
#ifdef WIN95    // currently enforced in win95 to only make PowerVR DX5 driver work
		&& (lpDDHALInfo->lpD3DGlobalDriverData &&
                (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_DRAWPRIMITIVES2) )
#endif  //WIN95
	       )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_D3DCALLBACKS3SIZE (&D3DCallbacks3 ) ||
		    ( gdidata.dwActualSize < D3DHAL_CALLBACKS3SIZE ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&D3DCallbacks3) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): flags set incorrectly" );
		    goto failed;
		}

		// DrawPrimitives2, ValidateTextureStageState and are the compulsory
        // DDI in Callbacks3 DX6+ drivers support TextureStages, hence it is
        // reasonable to require them to support ValidateTextureStageState
		if (0 == D3DCallbacks3.DrawPrimitives2)
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): no DrawPrimitives2 support" );
		    goto failed;
		}
		if (0 == D3DCallbacks3.ValidateTextureStageState)
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3): no ValidateTextureStageState support" );
		    goto failed;
		}
#ifdef WIN95
		// Now pass the driver the callback pointer to parse unknown
		// execute-buffer commands.
		// If this call fails then fail creating the driver. We need
		// to be this harsh so that the IHVs are forced to
		// implement this callback!
		memset(&gdidata, 0, sizeof(gdidata) );
		gdidata.dwSize = sizeof(gdidata);
		gdidata.dwFlags = 0;
		gdidata.dwContext = pddd->dwReserved3;
		memcpy(&gdidata.guidInfo, &GUID_D3DParseUnknownCommandCallback, sizeof(GUID_D3DParseUnknownCommandCallback) );
		gdidata.dwExpectedSize = 0;
		gdidata.lpvData = &D3DParseUnknownCommand; // We pass the pointer to function
		gdidata.ddRVal = DDERR_GENERIC;
		ret = lpDDHALInfo->GetDriverInfo(&gdidata);
		if (ret != DDHAL_DRIVER_HANDLED || gdidata.ddRVal != DD_OK)
		{
		    // Fail driver creation!
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (D3DCallbacks3) GUID_D3DParseUnknownCommandCallback not recognized, fail driver creation" );
		    goto failed;
		}
#endif
		memcpy((LPVOID) pddd->lpD3DHALCallbacks3, &D3DCallbacks3, D3DHAL_CALLBACKS3SIZE);

	    }
	    else{
                if (lpDDHALInfo->lpD3DGlobalDriverData)
                    lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps &= ~D3DDEVCAPS_DRAWPRIMITIVES2;
		memset((LPVOID) pddd->lpD3DHALCallbacks3, 0, D3DHAL_CALLBACKS3SIZE );
	    }

#if WIN95
	    memset(&pddd->lpDDCBtmp->HALDDKernel, 0, sizeof(DDHAL_DDKERNELCALLBACKS) );
	    /* Get callbacks, validate them and put them in pddd->lpDDCBtmp */
	    ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo, &gdidata,
				&pddd->lpDDCBtmp->HALDDKernel,
				sizeof(DDHAL_DDKERNELCALLBACKS),
				&GUID_KernelCallbacks, pddd,
                                FALSE /* bInOut */);
	    // GetDriverInfo returns DDERR_NODIRECTDRAWSUPPORT if driver
	    // overwrote its buffer.

	    if ( ret == DDERR_NODIRECTDRAWSUPPORT )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Kernel): Driver overwrote callbacks buffer" );
		goto failed;
	    }

	    if ( ret == DD_OK )
	    {
		// Fail create if driver already failed validation or
		// claims support but it's not valid.

		if (! VALIDEX_DDKERNELCALLBACKSSIZE (&pddd->lpDDCBtmp->HALDDKernel ) ||
		    ( gdidata.dwActualSize < sizeof(DDHAL_DDKERNELCALLBACKS ) ) )

		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Kernel): size not valid" );
		    goto failed;
		}

		if (! ValidateCallbacks(&pddd->lpDDCBtmp->HALDDKernel) )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: CALLBACKS VALIDATION FAILURE (Kernel): flags set incorrectly" );
		    goto failed;
		}
	    }
#endif

	    /*
	     * Get Z Pixel Formats, if driver supports this call.
	     * Ideally I'd like to handle this the same as TextureFormats, but
	     * D3DHAL_GLOBALDRIVERDATA is unexpandable if old drivers are to work,
	     * so must create new guid and graft this query onto callback validation
	     */
	    {
		DWORD tempbuf[249];  // make this <1K bytes or GetDriverInfo() fails cuz it cant do its "expected size overwrite" test within its own 1K tempbuffer

		// variable size field--delay mallocing space until we know how much is needed.
		// have GetDriverInfo stick results in tempbuf

		ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo,
				    &gdidata,
				    tempbuf,
				    sizeof(tempbuf),  // "expected" bytesize is 249*4, this allows for 31 DDPIXELFORMATs which should be enough
				    &GUID_ZPixelFormats, pddd,
                                    FALSE /* bInOut */);
		if(ret!=DD_OK)
		{
		    // A DX6+ driver (until we radically revamp our DDI) is
		    // one that responds to Callbacks3 (with DP2 support)
		    // This is a non-issue on NT, since the only DX6+ is
		    // available on it.

		    // DX6+ drivers have to field this GUID, if they
		    // report Clear2 (the DDI for stencil clear). No excuses!!
		    if (pddd->lpD3DHALCallbacks3->Clear2)
		    {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: A DX6+ driver should report its ZPixelFormats");
			goto failed;
		    }
		    else
		    {
			DPF(2,"GetDriverInfo: ZPixelFormats not supported by driver");  // driver is pre-dx6
			pddd->dwNumZPixelFormats=0;   pddd->lpZPixelFormats=NULL;
		    }
		}
		else
		{

		    // verify returned buffer is of an expected size
		    if((gdidata.dwActualSize-sizeof(DWORD)) % sizeof(DDPIXELFORMAT) != 0) {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Error in driver's ZPixelFormats query: driver returned bad-sized buffer");
			goto failed;
		    }

		    if((tempbuf[0]*sizeof(DDPIXELFORMAT)+sizeof(DWORD))>sizeof(tempbuf)) {
			DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Error: driver returned bogus number of Z Formats: %u",pddd->dwNumZPixelFormats );
			goto failed;
		    }

		    pddd->dwNumZPixelFormats=tempbuf[0];

		    pddd->lpZPixelFormats = MemAlloc(pddd->dwNumZPixelFormats*sizeof(DDPIXELFORMAT));

		    if (!pddd->lpZPixelFormats) {
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****: Out of memory querying Z Pixel Formats" );
			goto failed;
		    }

		    memcpy(pddd->lpZPixelFormats,&tempbuf[1],pddd->dwNumZPixelFormats*sizeof(DDPIXELFORMAT));

#ifdef DEBUG
		    // simple validation of pixel format fields
		    {
			DWORD ii;

			DPF(5,E,"Number of Z Pixel Formats: %u",pddd->dwNumZPixelFormats);
			for(ii=0;ii<pddd->dwNumZPixelFormats;ii++) {
			    DPF(5,E,"DDPF_ZBUFFER: %u, DDPF_STENCILBUFFER: %u",0!=(pddd->lpZPixelFormats[ii].dwFlags&DDPF_ZBUFFER),0!=(pddd->lpZPixelFormats[ii].dwFlags&DDPF_STENCILBUFFER));
			    DPF(5,E,"zbits %d, stencilbits %d, zbitmask %X, stencilbitmask %X",pddd->lpZPixelFormats[ii].dwZBufferBitDepth,
				pddd->lpZPixelFormats[ii].dwStencilBitDepth,pddd->lpZPixelFormats[ii].dwZBitMask,pddd->lpZPixelFormats[ii].dwStencilBitMask);
			    if(!(pddd->lpZPixelFormats[ii].dwFlags&DDPF_ZBUFFER)) {
				DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Error in driver's returned ZPixelFormats: ZBUFFER flag not set");
				goto failed;
			    }
			}
		    }
#endif //DEBUG
		}
	    }


	    DPF(4,E, "Done querying driver for callbacks");

	} // if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERCALLBACKSSET )
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Exception encountered validating driver HAL information" );
	DEBUG_BREAK();
	goto failed;
    }

    return TRUE;
failed:
    MemFree((LPVOID) pddd->lpZPixelFormats);
    pddd->lpZPixelFormats = 0;
    MemFree((LPVOID) pddd->lpD3DHALCallbacks2);
    pddd->lpD3DHALCallbacks2 = 0;
    MemFree((LPVOID) pddd->lpD3DHALCallbacks3);
    pddd->lpD3DHALCallbacks3 = 0;
#ifdef POSTPONED
    MemFree ((LPVOID) pddd->lpDDUmodeDrvInfo);
    pddd->lpDDUmodeDrvInfo = 0;
    MemFree ((LPVOID) pddd->lpDDOptSurfaceInfo);
    pddd->lpDDOptSurfaceInfo = 0;
#endif

    return FALSE;
}

/*
 * GetExtendedHeapAlignment
 * Call the driver to see if it requires alignment for the given heap.
 * Return a pointer to the filled-in alignment data within the block passed in
 * or NULL if failure or no alignment required.
 */
LPHEAPALIGNMENT GetExtendedHeapAlignment( LPDDRAWI_DIRECTDRAW_GBL pddd, LPDDHAL_GETHEAPALIGNMENTDATA pghad, int iHeap)
{
    HRESULT rc;
    LPDDHAL_GETHEAPALIGNMENT ghafn =
	pddd->lpDDCBtmp->HALDDMiscellaneous.GetHeapAlignment;

    DDASSERT(pghad);
    ZeroMemory((LPVOID)pghad,sizeof(*pghad));

    if( ghafn != NULL )
    {
	#ifdef WIN95
	    pghad->dwInstance = pddd->dwReserved3;
	#else
	    pghad->dwInstance = pddd->hDD;
	#endif
	pghad->dwHeap = (DWORD)iHeap;
	pghad->ddRVal = DDERR_GENERIC;
	pghad->Alignment.dwSize = sizeof(HEAPALIGNMENT);

	DOHALCALL_NOWIN16( GetHeapAlignment , ghafn, (*pghad), rc, FALSE );
	if ( (rc == DDHAL_DRIVER_HANDLED) && (pghad->ddRVal == DD_OK) )
	{
	    /*
	     * Validate alignment
	     */
	    if ( pghad->Alignment.ddsCaps.dwCaps & ~DDHAL_ALIGNVALIDCAPS )
	    {
		DPF(0,"****DirectDraw driver error****:Invalid alignment caps (at most %08x expected, %08x received) in heap %d",DDHAL_ALIGNVALIDCAPS, pghad->Alignment.ddsCaps.dwCaps,iHeap);
		return NULL;
	    }
	    /*
	     * Turning on this flag means that ComputePitch will ignore the
	     * legacy alignment fields in VIDMEMINFO for all heaps, not just
	     * iHeap.
	     */
	    DPF(5,V,"Driver reports extended alignment for heap %d",iHeap);
	    pddd->dwFlags |= DDRAWI_EXTENDEDALIGNMENT;
	    return & pghad->Alignment;
	}
    }
    return NULL;
}

/*
 * Get the non-local video memory blitting capabilities.
 */
BOOL GetNonLocalVidMemCaps( LPDDHALINFO lpDDHALInfo, LPDDRAWI_DIRECTDRAW_GBL pddd )
{
    DDASSERT( NULL != lpDDHALInfo );
    DDASSERT( NULL != pddd );
    DDASSERT( NULL == pddd->lpddNLVCaps );

    /*
     * We are forced to treat NLVHELCaps and NLVBothCaps differently. Originally, we were destroying
     * them here and letting a subsequent HELInit intiialize the HELCaps, and initcaps/mergeHELCaps
     * rebuild them. Trouble is, there's no HELInit along the reset code path (resetting a driver
     * object after a mode change). This means we were freeing the hel caps and never refilling them
     * after a mode switch. Since the HEL caps are mode-independent, we can get away with not releasing
     * the NLVHELCaps every mode switch. Now we will simply trust that once allocated, they are always valid.
     * After this routine is called, a subsequent initcaps/mergeHELCaps will regenerate the NLVBothCaps
     * from the driver caps (which may have changed- but we rebuilt them anyway) and the unchanging
     * HEL caps.
     *
     * I am leaving this code here commented out as documentation.
     *
     * if( NULL != pddd->lpddNLVHELCaps )
     * {
     *  MemFree( pddd->lpddNLVHELCaps );
     *  pddd->lpddNLVHELCaps = NULL;
     * }
     * if( NULL != pddd->lpddNLVBothCaps )
     * {
     *  MemFree( pddd->lpddNLVBothCaps );
     *  pddd->lpddNLVBothCaps = NULL;
     * }
     */

    if( lpDDHALInfo->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM )
    {
	DDNONLOCALVIDMEMCAPS ddNLVCaps;

	ZeroMemory( &ddNLVCaps, sizeof( ddNLVCaps ) );
	if( lpDDHALInfo->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEMCAPS )
	{
	    HRESULT hres;

	    /*
	     * The driver has different capabilities for non-local video memory
	     * to local video memory blitting. If the driver has a GetDriverInfo
	     * entry point defined then query it. If the driver doesn't want to
	     * handle the query then just assume it has no non-local video memory
	     * capabilities.
	     */
	    hres = DDERR_GENERIC;
	    if( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
	    {
		DDHAL_GETDRIVERINFODATA gdiData;

		hres = GetDriverInfo( lpDDHALInfo->GetDriverInfo,
				      &gdiData,
				      &ddNLVCaps,
				      sizeof( DDNONLOCALVIDMEMCAPS ),
				      &GUID_NonLocalVidMemCaps,
				      pddd,
                                      FALSE /* bInOut */ );
		if( DD_OK == hres )
		{
		    /*
		     * We should never get back more data than we asked for.
		     */
		    DDASSERT( gdiData.dwActualSize <= sizeof( DDNONLOCALVIDMEMCAPS ) );

		    /*
		     * The driver thinks it worked. Check it has done something sensible.
		     */
		    if( ( ddNLVCaps.dwSize     < ( 2UL * sizeof( DWORD ) ) ) ||
			( gdiData.dwActualSize < ( 2UL * sizeof( DWORD ) ) ) )
		    {
			/*
			 * Invalid size returned by the driver. Fail initialization.
			 */
			DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not initialization. Invalid non-local vidmem caps returned by driver" );
			return FALSE;
		    }

		    /*
		     * We zeroed the structure before passing it to the driver so
		     * everything is cool if we got less data than we asked for.
		     * Just bump the size up to the expected size.
		     */
		    ddNLVCaps.dwSize = sizeof( DDNONLOCALVIDMEMCAPS );
		}
		else if ( DDERR_GENERIC != hres )
		{
		    /*
		     * If we failed for any other reason than generic (which means
		     * driver not handled in this scenario) then fail initialization.
		     * Things have gone badly wrong.
		     */
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Fatal error when querying for non-local video memory caps" );
		    return FALSE;
		}
	    }
	    if( DDERR_GENERIC == hres )
	    {
		/*
		 * Driver doesn't have a GetDriverInfo entry point or it does but doesn't
		 * want to handle GUID_GetNonLocalVidMemCaps. Assume this means no caps
		 * at all. The structure is already zeroed so just set the size.
		 */
		ddNLVCaps.dwSize = sizeof( DDNONLOCALVIDMEMCAPS );
	    }
	}
	else
	{
	    int i;

	    /*
	     * The driver does not have non-local video memory capabilities which
	     * are different from the video ones so just make the non-local case
	     * identical to the video memory ones.
	     */
	    ddNLVCaps.dwSize = sizeof( DDNONLOCALVIDMEMCAPS );

	    ddNLVCaps.dwNLVBCaps = lpDDHALInfo->ddCaps.dwCaps;
	    ddNLVCaps.dwNLVBCaps2 = lpDDHALInfo->ddCaps.dwCaps2;
	    ddNLVCaps.dwNLVBCKeyCaps = lpDDHALInfo->ddCaps.dwCKeyCaps;
	    ddNLVCaps.dwNLVBFXCaps = lpDDHALInfo->ddCaps.dwFXCaps;
	    for( i = 0; i < DD_ROP_SPACE; i++ )
		ddNLVCaps.dwNLVBRops[i] = lpDDHALInfo->ddCaps.dwRops[i];
	}
#ifndef WINNT
	/*
	 * Memphis: Max AGP is sysmem-12megs, same as VGARTD,
	 */
	if ( (dwRegFlags & DDRAW_REGFLAGS_AGPPOLICYMAXBYTES) == 0)
	{
	    /*
	     * If there's nothing in the registry, figure our own out
	     */
	    MEMORYSTATUS s = {sizeof(s)};

	    GlobalMemoryStatus(&s);
	    if (s.dwTotalPhys > 0xc00000)
		dwAGPPolicyMaxBytes = (DWORD)(s.dwTotalPhys - 0xc00000);
	    else
		dwAGPPolicyMaxBytes = 0;
	    DPF(1,"Max AGP size set to %08x (total phys is %08x)",dwAGPPolicyMaxBytes,s.dwTotalPhys);
	}
	else
	{
	    DPF(1,"Max AGP size set to registry value of %08x",dwAGPPolicyMaxBytes);
	}
#endif
	/*
	 * If we got this far we have some valid non-local video memory capabilities so
	 * allocate the storage in the driver object to hold them.
	 */
	pddd->lpddNLVCaps = (LPDDNONLOCALVIDMEMCAPS)MemAlloc( sizeof( DDNONLOCALVIDMEMCAPS ) );
	if( NULL == pddd->lpddNLVCaps)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate non-local video memory capabilities" );
	    return FALSE;
	}


	/*
	 * If the NLVHELcaps pointer is null, we'll allocate it here.
	 */
	if( NULL == pddd->lpddNLVHELCaps)
	    pddd->lpddNLVHELCaps = (LPDDNONLOCALVIDMEMCAPS)MemAlloc( sizeof( DDNONLOCALVIDMEMCAPS ) );
	if( NULL == pddd->lpddNLVHELCaps)
	{
	    MemFree( pddd->lpddNLVCaps );
	    pddd->lpddNLVCaps = NULL;
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate non-local video memory capabilities" );
	    return FALSE;
	}

	/*
	 * If the NLVBothCaps pointer is null, we'll allocate it here.
	 */
	if( NULL == pddd->lpddNLVBothCaps)
	    pddd->lpddNLVBothCaps = (LPDDNONLOCALVIDMEMCAPS)MemAlloc( sizeof( DDNONLOCALVIDMEMCAPS ) );
	if( NULL == pddd->lpddNLVBothCaps)
	{
	    MemFree( pddd->lpddNLVCaps );
	    pddd->lpddNLVCaps = NULL;
	    MemFree( pddd->lpddNLVHELCaps );
	    pddd->lpddNLVHELCaps = NULL;
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate non-local video memory capabilities" );
	    return FALSE;
	}

	/*
	 * This code is structure so by this point the size of the temporary buffer should
	 * be sizeof( DDNONLOCALVIDMEMCAPS )
	 */
	DDASSERT( sizeof( DDNONLOCALVIDMEMCAPS ) == ddNLVCaps.dwSize );
	CopyMemory(pddd->lpddNLVCaps, &ddNLVCaps, sizeof( DDNONLOCALVIDMEMCAPS ) );

	/*
	 * The HEL caps and the merged caps are zero to start with (they are initialized later).
	 * (actually they may not be zero in the reset case: we don't destroy the hel caps
	 * on mode changes anymore.)
	 */
	pddd->lpddNLVHELCaps->dwSize  = sizeof( DDNONLOCALVIDMEMCAPS );
	pddd->lpddNLVBothCaps->dwSize = sizeof( DDNONLOCALVIDMEMCAPS );
    }

    return TRUE;
} /* GetNonLocalVidMemCaps */


/*
 * This function is currently only used in NT
 */

#ifdef WINNT

BOOL GetDDStereoMode( LPDDRAWI_DIRECTDRAW_GBL pdrv,
                      DWORD dwWidth,
                      DWORD dwHeight,
                      DWORD dwBpp,
                      DWORD dwRefreshRate)
{
    DDHAL_GETDRIVERINFODATA     gdidata;
    HRESULT                     hres;
    DDSTEREOMODE                ddStereoMode;
    
    DDASSERT( pdrv != NULL );

    /*
     * If driver does not support GetDriverInfo callback, it also
     * has no extended capabilities to report, so we're done.
     */
    if( !VALIDEX_CODE_PTR (pdrv->pGetDriverInfo) )
    {
        return FALSE;
    }

    /*
     * The mode can't be stereo if the driver doesn't support it...
     */
    if (0 == (pdrv->ddCaps.dwCaps2 & DDCAPS2_STEREO))
    {
        return FALSE;
    }

    ZeroMemory( &ddStereoMode, sizeof(DDSTEREOMODE));

    ddStereoMode.dwSize=sizeof(DDSTEREOMODE);
    ddStereoMode.dwWidth=dwWidth;
    ddStereoMode.dwHeight=dwHeight;
    ddStereoMode.dwBpp=dwBpp;
    ddStereoMode.dwRefreshRate=dwRefreshRate;

    ddStereoMode.bSupported = TRUE;

    /*
     * Get the actual driver data
     */
    memset(&gdidata, 0, sizeof(gdidata) );
    gdidata.dwSize = sizeof(gdidata);
    gdidata.dwFlags = 0;
    gdidata.guidInfo = GUID_DDStereoMode; 
    gdidata.dwExpectedSize = sizeof(DDSTEREOMODE);
    gdidata.lpvData = &ddStereoMode;
    gdidata.ddRVal = DDERR_GENERIC;

    // Pass a context variable so that the driver
    // knows which instance of itself to use
    // w.r.t. this function. These are different
    // values on Win95 and NT.
#ifdef WIN95
    gdidata.dwContext = pdrv->dwReserved3;
#else
    gdidata.dwContext = pdrv->hDD;
#endif

    if ( pdrv->pGetDriverInfo(&gdidata) == DDHAL_DRIVER_HANDLED)
    {
        // GUID_DDStereoMode is a way to turn OFF stereo per-mode, since
        // it is expected that a driver that can do stereo can do stereo in
        // any mode.

        if( gdidata.ddRVal == DD_OK )
        {
            return ddStereoMode.bSupported;
        }
    }

    return TRUE;

} /* GetDDStereoMode */

#endif //WINNT


BOOL GetDDMoreSurfaceCaps( LPDDHALINFO lpDDHALInfo, LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    DDHAL_GETDRIVERINFODATA     gdiData;
    HRESULT                     hres;
    DWORD                       dwSize;
    LPDDMORESURFACECAPS         lpddMoreSurfaceCaps=NULL;
    BOOL                        retval=TRUE;
    DWORD                       heap;

    DDASSERT( lpDDHALInfo != NULL );
    DDASSERT( pdrv != NULL );

    /*
     * If driver does not support GetDriverInfo callback, it also
     * has no extended capabilities to report, so we're done.
     */
    if( !(lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET) )
    {
	goto Succeeded;
    }

    /*
     * The size of DDMORESURFACECAPS is variable.
     * We have to do this calculation signed, since dwNumHeaps might be zero, in which case we need
     * to subtract some from sizeof DDMORESURFACECAPS.
     */
    dwSize = (DWORD) (sizeof(DDMORESURFACECAPS) + (((signed int)pdrv->vmiData.dwNumHeaps)-1) * sizeof(DDSCAPSEX)*2 );

    /*
     * Allocate some temporary space.
     * The caps bits will go into the pdrv, and the extended heap restrictions will go into
     * the VMEMHEAP structs off of pdrv->vmiData->pvmList->lpHeap
     */
    lpddMoreSurfaceCaps = (LPDDMORESURFACECAPS)MemAlloc( dwSize );
    if (lpddMoreSurfaceCaps == NULL)
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate extended surface capabilities" );
	goto Failed;
    }
    ZeroMemory( lpddMoreSurfaceCaps , dwSize);

    /*
     * Get the actual driver data
     */
    hres = GetDriverInfo( lpDDHALInfo->GetDriverInfo,
			  &gdiData,
			  lpddMoreSurfaceCaps,
			  dwSize,
			  &GUID_DDMoreSurfaceCaps,
			  pdrv,
                          FALSE /* bInOut */ );

    if( hres != DD_OK )
    {
        goto Succeeded;
    }


    /*
     * We should never get back more data than we asked for.  If we
     * do, that probably means the driver version is newer than the
     * DirectDraw runtime version.  In that case, we just fail.
     */
    if( gdiData.dwActualSize > dwSize )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Driver gives too big a size for DDMORESURFACECAPS. Check the dwSize calculation." );
	goto Failed;
    }

    /*
     * The surface caps go into the pdrv:
     */
    pdrv->ddsCapsMore = lpddMoreSurfaceCaps->ddsCapsMore;

    if (pdrv->vmiData.dwNumHeaps == 0)
    {
	/*
	 * No heaps means we are done
	 */
	goto Succeeded;
    }
    DDASSERT(NULL != pdrv->vmiData.pvmList);

    for (heap = 0; heap < pdrv->vmiData.dwNumHeaps; heap ++ )
    {
	LPVMEMHEAP lpHeap = pdrv->vmiData.pvmList[heap].lpHeap;
	/*
	 * A quick sanity check. If we have nonzero dwNumHeaps, then we better have
	 * a heap descriptor pointer. This also saves us if someone rearranges the caller of this
	 * routine so that the vidmeminit calls have not yet been made.
	 */
	if (!lpHeap)
	{
	    DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Rearrange this call to GetDDMoreSurfaceCaps so it comes after vidmeminit");
	    goto Failed;
	}
	lpHeap->ddsCapsEx = lpddMoreSurfaceCaps->ddsExtendedHeapRestrictions[heap].ddsCapsEx;
	lpHeap->ddsCapsExAlt = lpddMoreSurfaceCaps->ddsExtendedHeapRestrictions[heap].ddsCapsExAlt;
    }

Succeeded:
    retval = TRUE;
    goto Exit;
Failed:
    retval = FALSE;
Exit:
    MemFree(lpddMoreSurfaceCaps);
    return retval;
} /* GetDDMoreSurfaceCaps */


/*
 * Interrogate the driver to get more driver capabilities, as specified in
 * the DDMORECAPS structure.  These caps augment those specified by the
 * driver in the DDHALINFO structure.  Return TRUE if the call succeeds,
 * or FALSE if an error condition is detected.  If the call succeeds, the
 * function ensures that storage is allocated for all of the DirectDraw
 * object's additional caps.
 */
BOOL GetDDMoreCaps( LPDDHALINFO lpDDHALInfo, LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    DDMORECAPS ddMoreCaps;
    DDHAL_GETDRIVERINFODATA gdiData;
    HRESULT hres;

    DDASSERT( lpDDHALInfo != NULL );
    DDASSERT( pdrv != NULL );

    /*
     * Make sure memory is allocated and initialized for the driver's
     * lpddMoreCaps, lpddHELMoreCaps, and lpddBothMoreCaps pointers.
     */
    if (pdrv->lpddMoreCaps == NULL)    // hardware caps
    {
	pdrv->lpddMoreCaps = (LPDDMORECAPS)MemAlloc( sizeof( DDMORECAPS ) );
	if (pdrv->lpddMoreCaps == NULL)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate extended capabilities" );
	    return FALSE;
	}
    }
    ZeroMemory( pdrv->lpddMoreCaps, sizeof(DDMORECAPS) );
    pdrv->lpddMoreCaps->dwSize = sizeof( DDMORECAPS );

    if (pdrv->lpddHELMoreCaps == NULL)    // HEL caps
    {
	pdrv->lpddHELMoreCaps = (LPDDMORECAPS)MemAlloc( sizeof( DDMORECAPS ) );
	if (pdrv->lpddHELMoreCaps == NULL)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate extended capabilities" );
	    return FALSE;
	}
	ZeroMemory( pdrv->lpddHELMoreCaps, sizeof(DDMORECAPS) );
	pdrv->lpddHELMoreCaps->dwSize = sizeof( DDMORECAPS );
    }

    if (pdrv->lpddBothMoreCaps == NULL)    // bitwise AND of hardware and HEL caps
    {
	pdrv->lpddBothMoreCaps = (LPDDMORECAPS)MemAlloc( sizeof( DDMORECAPS ) );
	if (pdrv->lpddBothMoreCaps == NULL)
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate extended capabilities" );
	    return FALSE;
	}
    }
    ZeroMemory( pdrv->lpddBothMoreCaps, sizeof(DDMORECAPS) );
    pdrv->lpddBothMoreCaps->dwSize = sizeof( DDMORECAPS );

    /*
     * If driver does not support GetDriverInfo callback, it also
     * has no extended capabilities to report, so we're done.
     */
    if( !(lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET) )
    {
	return TRUE;    // no extended capabilities to report
    }

#if 0
    /*
     * Get the extended capabilities from the driver.
     */
    ZeroMemory( &ddMoreCaps, sizeof( DDMORECAPS ) );

    hres = GetDriverInfo( lpDDHALInfo->GetDriverInfo,
			  &gdiData,
			  &ddMoreCaps,
			  sizeof( DDMORECAPS ),
			  &GUID_DDMoreCaps,
			  pdrv );

    if( hres != DD_OK )
    {
	return TRUE;    // no extended capabilities to report
    }

    /*
     * We should never get back more data than we asked for.  If we
     * do, that probably means the driver version is newer than the
     * DirectDraw runtime version.  In that case, we just fail.
     */
    if( gdiData.dwActualSize > sizeof( DDMORECAPS ) )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Driver gives too big a size for DDMORECAPS" );
	return FALSE;    // error
    }

    /*
     * We zeroed the structure before passing it to the driver so
     * everything is cool if we got less data than we asked for.
     * Just bump the size up to the expected size.
     */
    ddMoreCaps.dwSize = sizeof( DDMORECAPS );

    /*
     * Store the hardware driver's extended caps in the global DirectDraw object.
     */
    CopyMemory(pdrv->lpddMoreCaps, &ddMoreCaps, sizeof( DDMORECAPS ) );
#endif
    return TRUE;

} /* GetDDMoreCaps */

/*
 * DirectDrawObjectCreate
 *
 * Create a DIRECTDRAW object.
 */
LPDDRAWI_DIRECTDRAW_GBL DirectDrawObjectCreate(
		LPDDHALINFO lpDDHALInfo,
		BOOL reset,
		LPDDRAWI_DIRECTDRAW_GBL oldpdd,
		HANDLE hDDVxd,
		char *szDrvName,
		DWORD dwDriverContext, 
                DWORD dwLocalFlags )
{
    LPDDRAWI_DIRECTDRAW_GBL     pddd=NULL;
    int                         drv_size;
    int                         drv_callbacks_size;
    int                         size;
    LPVIDMEM                    pvm;
    int                         i;
    int                         j;
    int                         devheapno;
    int                         numcb;
    LPDDHAL_DDCALLBACKS         drvcb;
    LPDDHAL_DDSURFACECALLBACKS  surfcb;
    LPDDHAL_DDPALETTECALLBACKS  palcb;
    LPDDHAL_DDEXEBUFCALLBACKS   exebufcb;
    DWORD                       bit;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    DWORD                       freevm;
    BOOL                        isagpaware;
    #ifdef WIN95
	DWORD                   ptr16;
    #endif

    #ifdef WINNT
	/*
	 * Need somewhere to put the callback fn ptrs given to us by the NT driver...
	 */
    DDHAL_DDCALLBACKS               ddNTHALDD;
    DDHAL_DDSURFACECALLBACKS        ddNTHALDDSurface;
    DDHAL_DDPALETTECALLBACKS        ddNTHALDDPalette;
    D3DHAL_CALLBACKS                d3dNTHALCallbacks;
    D3DHAL_CALLBACKS               *pd3dNTHALCallbacks=0;
    D3DHAL_GLOBALDRIVERDATA         d3dNTHALDriverData;
    D3DHAL_GLOBALDRIVERDATA        *pd3dNTHALDriverData;
    LPDDSURFACEDESC                 pddsdD3dTextureFormats;
    DDHAL_DDEXEBUFCALLBACKS         ddNTHALBufferCallbacks;
    LPDDHAL_DDEXEBUFCALLBACKS       pddNTHALBufferCallbacks;
    BOOL                            ismemalloced=FALSE;
    #endif

    ENTER_DDRAW();

    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 4, "DirectDrawObjectCreate: oldpdd == 0x%p, reset = %d", oldpdd, reset );

    DDASSERT( (oldpdd == NULL) == (reset==FALSE) );

    /*
     * make sure the driver isn't trying to lie to us about the old object
     * This check should always be made at the top of this routine, since it's
     * possible in stress scenarios for ddhelp's modeset thread to wake up
     * just before it's killed at the end of DD_Release (since the code to kill
     * the mode set thread is executed AFTER the last LEAVE_DDRAW in DD_Release).
     */
    DPF( 5, "DIRECTDRAW object passed in = 0x%p", oldpdd );
    if( oldpdd != NULL )
    {
	pdrv_lcl = lpDriverLocalList;
	while( pdrv_lcl != NULL )
	{
	    if( pdrv_lcl->lpGbl == oldpdd )
	    {
		break;
	    }
	    pdrv_lcl = pdrv_lcl->lpLink;
	}
	if( pdrv_lcl == NULL )
	{
	    DPF_ERR( "REUSED DRIVER OBJECT SPECIFIED, BUT NOT IN LIST" );
	    DDASSERT(FALSE);
	    goto ErrorExit;
	}
    }

    // If a null driver name is passed in then use the one
    // in the oldpdd passed in. We need one or the other!
    if( szDrvName == NULL )
    {
	if( oldpdd == NULL )
	{
	    DPF_ERR( "DDrawObjectCreate: oldpdd == NULL && szDrvName == NULL" );
	    DDASSERT( 0 );
	    goto ErrorExit;
	}
	szDrvName = oldpdd->cDriverName;
    }

    #ifdef USE_ALIAS
	if( NULL != oldpdd )
	{
	    /*
	     * The absolutely first thing we want to do is to check to see if there are
	     * any outstanding video memory locks and if there are we need to remap
	     * the aliased to dummy memory to ensure we don't write over memory we don't
	     * own or to memory that does not exist.
	     */
	    if( ( NULL != oldpdd->phaiHeapAliases ) && ( oldpdd->phaiHeapAliases->dwRefCnt > 1UL ) )
	    {
		DDASSERT( INVALID_HANDLE_VALUE != hDDVxd );
		if( FAILED( MapHeapAliasesToDummyMem( hDDVxd, oldpdd->phaiHeapAliases ) ) )
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not map existing video memory aliases to dummy memory" );
		    goto ErrorExit;
		}
	    }
	}
    #endif /* USE_ALIAS */

    /*
     * Is this OS AGP aware?
     *
     * NOTE: VXD handle is only necessary on Win95. On NT, hDDVxd will simply
     * be NULL and be unused by this function.
     */
#ifdef WINNT
    isagpaware = TRUE;
#else
    isagpaware = OSIsAGPAware( hDDVxd );
    if( !isagpaware )
    {
	if( dwRegFlags & DDRAW_REGFLAGS_FORCEAGPSUPPORT )
	{
	    /*
	     * Pretend the OS is AGP aware for debugging purposes.
	     */
	    DPF( 1, "Force enabling AGP support for debugging purposes" );
	    isagpaware = TRUE;
	}
    }
#endif //not WINNT
    if( dwRegFlags & DDRAW_REGFLAGS_DISABLEAGPSUPPORT )
    {
	/*
	 * Pretend the OS is not AGP aware.
	 */
	DPF( 1, "Disabling APG support for debugging purposes" );
	isagpaware = FALSE;
    }

    /*
     * Under NT, we're forced to create a direct draw global object before we can
     * query the driver for its ddhalinfo.
     * Consequently, we validate the incoming ddhalinfo pointer first in its very
     * own try-except block, then allocate the global structure, then (on NT only)
     * call the driver to register the global object and get its halinfo.
     * (Under win95, the halinfo will have been filled in by the caller) jeffno 960116
     */

    /*
     * initialize a new driver object if we don't have one already
     */
    if( (oldpdd == NULL) || reset )
    {
        // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF( 4, "oldpdd == 0x%p, reset = %d", oldpdd, reset );
	/*
	 * Allocate memory for the global object.
	 * We also allocate a DDHAL_CALLBACKS structure with the global
	 * object.  This structure is used to hold the single copy of
	 * the HAL function table under Win95 and it is used as
	 * temporary storage of the function table under NT
	 */
	drv_size = sizeof( DDRAWI_DIRECTDRAW_GBL );
	drv_callbacks_size = drv_size + sizeof( DDHAL_CALLBACKS );
	#ifdef WIN95
	    pddd = (LPDDRAWI_DIRECTDRAW_GBL) MemAlloc16( drv_callbacks_size, &ptr16 );
	#else
	    pddd = (LPDDRAWI_DIRECTDRAW_GBL) MemAlloc( drv_callbacks_size );
	#endif
	DPF( 5,"Driver Object: %ld base bytes", drv_callbacks_size );
	if( pddd == NULL )
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not allocate space for driver object" );
	    goto ErrorExit;
	}

	#ifdef WIN95
	// Store the value returned by the 32-bit driver
	// into the pdrv; this allows the 32-bit driver to remember
	// any state it needs to for all future calls to it. This
	// was added for multi-monitor support. <kd>
	if( oldpdd )
	    pddd->dwReserved3= oldpdd->dwReserved3;
	else
	    pddd->dwReserved3 = dwDriverContext;
	DPF( 5, "dwReserved3 of DDrawGbl is set to 0x%x", pddd->dwReserved3 );

	// Initialize value of global DDRAW.VXD handle to INVALID_HANDLE_VALUE.
	// This should always normally be INVALID_HANDLE_VALUE, unless if we
	// are in the middle of a createSurface() call.
	pddd->hDDVxd = (DWORD) INVALID_HANDLE_VALUE;
	DPF( 6, "hDDVxd of DDrawGbl is set to INVALID_HANDLE_VALUE - 0x%p", pddd->hDDVxd );
        #else
            /*
             * In the reset code path, this per-process hDD will have been stuffed into
             * the oldpdd by FetchDirectDrawData.
             */
            if (reset)
            {
                DDASSERT(oldpdd);
                pddd->hDD = oldpdd->hDD;
            }
	#endif WIN95

	pddd->lpDDCBtmp = (LPDDHAL_CALLBACKS)(((LPSTR) pddd) + drv_size );

#ifdef WINNT
        pddd->SurfaceHandleList.dwList=NULL;
        pddd->SurfaceHandleList.dwFreeList=0;
	if (lpDDHALInfo && !(lpDDHALInfo->ddCaps.dwCaps & DDCAPS_NOHARDWARE))
	{
	    HDC hDC;
	    BOOL bNewMode;
	    BOOL bRetVal;
	    /*
	     * Now that we have a ddraw GBL structure available, we can tell
	     * the driver about it...
	     */
	    DPF(5,K,"WinNT driver conversation started");

            if (!reset)
            {
	        hDC = DD_CreateDC( szDrvName );   // create temporary DC
	        if (!hDC)
	        {
    		    DPF(0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Unable to create temporary DC for driver");
		    goto ErrorExit;
	        }
                bRetVal = DdCreateDirectDrawObject(pddd, hDC);
                DD_DoneDC(hDC);   // delete temporary DC
                if (!bRetVal)
	        {
		    /*
		     * this means we're in emulation
		     */
		    DPF(0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:NT Kernel mode would not create driver object... Failing over to emulation");
		    goto ErrorExit;
	        }
            }

	    /*
	     * Now we can get the driver info...
	     * The first call to this routine lets us know how much space to
	     * reserve for the fourcc and vidmem lists
	     */
	    if (!DdReenableDirectDrawObject(pddd,&bNewMode) ||
		!DdQueryDirectDrawObject(pddd,
					 lpDDHALInfo,
					 &ddNTHALDD,
					 &ddNTHALDDSurface,
					 &ddNTHALDDPalette,
					 &d3dNTHALCallbacks,
					 &d3dNTHALDriverData,
					 &ddNTHALBufferCallbacks,
					 NULL,
					 NULL,
					 NULL))
	    {
		DPF(1, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:First call to DdQueryDirectDrawObject failed!");
		goto ErrorExit;
	    }
	    /*
	     * The second call allows the driver to fill in the fourcc and
	     * vidmem lists. First we make space for them.
	     */
	    lpDDHALInfo->vmiData.pvmList = MemAlloc(lpDDHALInfo->vmiData.dwNumHeaps * sizeof(VIDMEM));
	    if (NULL == lpDDHALInfo->vmiData.pvmList)
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No RAM for pvmList");
		goto ErrorExit;
	    }
	    lpDDHALInfo->lpdwFourCC = MemAlloc(lpDDHALInfo->ddCaps.dwNumFourCCCodes * sizeof(DWORD));
	    if (NULL == lpDDHALInfo->lpdwFourCC)
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No RAM for FourCC List");
		goto ErrorExit;
	    }
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(5, K, "numheaps = %d, numfourcc = %d", lpDDHALInfo->vmiData.dwNumHeaps, lpDDHALInfo->ddCaps.dwNumFourCCCodes);
	    DPF(5, K, "ptrs: 0x%p, 0x%p", lpDDHALInfo->lpdwFourCC, lpDDHALInfo->vmiData.pvmList);

	    // If Direct3D information was returned, allocate space for
	    // the real information to be stored in and for the
	    // appropriate number of texture formats
	    if (d3dNTHALCallbacks.dwSize > 0 &&
		d3dNTHALDriverData.dwSize > 0)
	    {
                // We need to allocate space for the d3dhalcallbacks etc. only once,
                // since d3d caches them across mode changes.
                // We are allowed to reallocate the texture format list, since d3d only
                // caches a pointer to D3DHAL_GLOBALDRIVERDATA, which is where the pointer
                // to the texture formats is kept.

                if ( NULL == oldpdd || NULL == oldpdd->lpD3DHALCallbacks )
                {
		    pddd->lpD3DHALCallbacks = pd3dNTHALCallbacks =
                        (LPD3DHAL_CALLBACKS) MemAlloc(sizeof(D3DHAL_CALLBACKS)+
					          sizeof(D3DHAL_GLOBALDRIVERDATA)+
					          sizeof(DDHAL_DDEXEBUFCALLBACKS));

                    // Mark memory allocated in this path (not get from old one)
                    // so that we can free this memory if error occur later.

                    ismemalloced = TRUE;
                }
                else
                    pddd->lpD3DHALCallbacks = pd3dNTHALCallbacks = oldpdd->lpD3DHALCallbacks;

		if (pd3dNTHALCallbacks == NULL)
		{
		    DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****:D3D memory allocation failed!");
		    goto ErrorExit;
		}

		pd3dNTHALDriverData = (LPD3DHAL_GLOBALDRIVERDATA)
		    (pd3dNTHALCallbacks+1);
		pddNTHALBufferCallbacks = (LPDDHAL_DDEXEBUFCALLBACKS)
		    (pd3dNTHALDriverData+1);

                // free old texture list and allocate a new one.
                MemFree(pd3dNTHALDriverData->lpTextureFormats);
                pddsdD3dTextureFormats = pd3dNTHALDriverData->lpTextureFormats =
                    MemAlloc(sizeof(DDSURFACEDESC) * d3dNTHALDriverData.dwNumTextureFormats);

                // WOW64: include the number of textures in the driver data so that WOW64 can
                // thunk the texture formats
                pd3dNTHALDriverData->dwNumTextureFormats = d3dNTHALDriverData.dwNumTextureFormats;
	    }
	    else
	    {
		pd3dNTHALCallbacks = NULL;
		pd3dNTHALDriverData = NULL;
		pddNTHALBufferCallbacks = NULL;
                pddsdD3dTextureFormats = NULL;
	    }

	    if (!DdQueryDirectDrawObject(pddd,
					 lpDDHALInfo,
					 &ddNTHALDD,
					 &ddNTHALDDSurface,
					 &ddNTHALDDPalette,
					 pd3dNTHALCallbacks,
					 pd3dNTHALDriverData,
					 pddNTHALBufferCallbacks,
					 pddsdD3dTextureFormats,
					 lpDDHALInfo->lpdwFourCC,
					 lpDDHALInfo->vmiData.pvmList))
	    {
		DPF(1, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Third call to DdQueryDirectDrawObject failed!");
		goto ErrorExit;
	    }
	    #ifdef DEBUG
	    {
		int i;
		DPF(5,K,"NT driver video ram data as reported by driver:");
		DPF(5,K,"   VIDMEMINFO.fpPrimary        =%08x",lpDDHALInfo->vmiData.fpPrimary);
		DPF(5,K,"   VIDMEMINFO.dwFlags          =%08x",lpDDHALInfo->vmiData.dwFlags);
		DPF(5,K,"   VIDMEMINFO.dwDisplayWidth   =%08x",lpDDHALInfo->vmiData.dwDisplayWidth);
		DPF(5,K,"   VIDMEMINFO.dwDisplayHeight  =%08x",lpDDHALInfo->vmiData.dwDisplayHeight);
		DPF(5,K,"   VIDMEMINFO.lDisplayPitch    =%08x",lpDDHALInfo->vmiData.lDisplayPitch);
		DPF(5,K,"   VIDMEMINFO.dwOffscreenAlign =%08x",lpDDHALInfo->vmiData.dwOffscreenAlign);
		DPF(5,K,"   VIDMEMINFO.dwOverlayAlign   =%08x",lpDDHALInfo->vmiData.dwOverlayAlign);
		DPF(5,K,"   VIDMEMINFO.dwTextureAlign   =%08x",lpDDHALInfo->vmiData.dwTextureAlign);
		DPF(5,K,"   VIDMEMINFO.dwZBufferAlign   =%08x",lpDDHALInfo->vmiData.dwZBufferAlign);
		DPF(5,K,"   VIDMEMINFO.dwAlphaAlign     =%08x",lpDDHALInfo->vmiData.dwAlphaAlign);
		DPF(5,K,"   VIDMEMINFO.dwNumHeaps       =%08x",lpDDHALInfo->vmiData.dwNumHeaps);

		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwSize            =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwSize);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwFlags           =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwFlags);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwFourCC          =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwFourCC);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwRGBBitCount     =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwRGBBitCount);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwRBitMask        =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwRBitMask);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwGBitMask        =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwGBitMask);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwBBitMask        =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwBBitMask);
		DPF(5,K,"   VIDMEMINFO.ddpfDisplay.dwRGBAlphaBitMask =%08x",lpDDHALInfo->vmiData.ddpfDisplay.dwRGBAlphaBitMask);

                // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPF(5, K, "   Vidmem list ptr is 0x%p", lpDDHALInfo->vmiData.pvmList);
		for (i=0;i<(int) lpDDHALInfo->vmiData.dwNumHeaps;i++)
		{
		    DPF(5, K, "        heap flags: %03x", lpDDHALInfo->vmiData.pvmList[i].dwFlags);
		    DPF(5, K, "    Start of chunk: 0x%p", lpDDHALInfo->vmiData.pvmList[i].fpStart);
		    DPF(5, K, "      End of chunk: 0x%p", lpDDHALInfo->vmiData.pvmList[i].fpEnd);
		}
	    }
	    #endif


	    lpDDHALInfo->lpDDCallbacks = &ddNTHALDD;
	    lpDDHALInfo->lpDDSurfaceCallbacks = &ddNTHALDDSurface;
	    lpDDHALInfo->lpDDPaletteCallbacks = &ddNTHALDDPalette;

	    ddNTHALBufferCallbacks.dwSize =sizeof ddNTHALBufferCallbacks; //since kernel is busted
            ddNTHALBufferCallbacks.dwFlags = 
                    DDHAL_EXEBUFCB32_CANCREATEEXEBUF|
                    DDHAL_EXEBUFCB32_CREATEEXEBUF   |
                    DDHAL_EXEBUFCB32_DESTROYEXEBUF  |
                    DDHAL_EXEBUFCB32_LOCKEXEBUF     |
                    DDHAL_EXEBUFCB32_UNLOCKEXEBUF   ;
	    lpDDHALInfo->lpDDExeBufCallbacks = &ddNTHALBufferCallbacks;

            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(5, K, "Surface callback as reported by Kernel is 0x%p", lpDDHALInfo->lpDDCallbacks->CreateSurface);
	}
	else
	{
	    /*
	     * Normally, we specify a null DC handle to register our fake 
             * DDraw driver, but with secondary monitors we need to specify
             * a device DC or else things fall apart.
	     */
            HDC hdcTemp = NULL;

            if( ( _stricmp( szDrvName, DISPLAY_STR ) != 0 ) &&
	        ( _stricmp( szDrvName, g_szPrimaryDisplay ) != 0 ) &&
                IsMultiMonitor() &&
                ( ( szDrvName[0] == '\\' ) && 
                  ( szDrvName[1] == '\\' ) && 
                  ( szDrvName[2] == '.') ) )
            {
                hdcTemp = DD_CreateDC( szDrvName );   // create temporary DC
            }

            if (!DdCreateDirectDrawObject(pddd, hdcTemp))
	    {
		DPF(1, "NT Kernel mode would not create fake DD driver object");
		goto ErrorExit;
	    }
            if( hdcTemp != NULL )
            {
                DD_DoneDC(hdcTemp);   // delete temporary DC
            }
	}
        if (!GetCurrentMode(oldpdd, lpDDHALInfo, szDrvName))
        {
            DPF(0, "Could not get current mode information");
            goto ErrorExit;
        }
        if (oldpdd && oldpdd->lpModeInfo)
        {
            DDASSERT(oldpdd->lpModeInfo == &oldpdd->ModeInfo);
            memcpy(&oldpdd->ModeInfo, lpDDHALInfo->lpModeInfo, sizeof (DDHALMODEINFO));
        }

#endif //WINNT


    } //end if oldpdd==NULL || reset

    if( !ValidateCoreHALInfo( lpDDHALInfo ) )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Exception encountered validating driver parameters" );
	goto ErrorExit;
    }

    // We only want to get new HALInfo if we haven't already
    // done this. The oldpdd == NULL check implies that we are
    // building a driver from scratch.
    if( (oldpdd == NULL) && pddd && !GetAndValidateNewHALInfo( pddd, lpDDHALInfo ) )
    {
	DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Exception encountered querying for optional driver parameters" );
	goto ErrorExit;
    }

    /*
     * reset specified without a driver object existing is just a create
     */
    if( reset && (oldpdd == NULL) )
    {
	reset = FALSE;
    }

    /*
     * initialize a new driver object if we don't have one already
     */
    if( (oldpdd == NULL) || reset )
    {
	DPF(4,"oldpdd == NULL || reset");
	/*
	 * validate blt stuff
	 */
	if( lpDDHALInfo->ddCaps.dwCaps & DDCAPS_BLT )
	{
	    if( lpDDHALInfo->lpDDSurfaceCallbacks->Blt == NULL )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No Blt Fn, but BLT specified" );
		goto ErrorExit;
	    }
	    if( !(lpDDHALInfo->ddCaps.dwRops[ (SRCCOPY>>16)/32 ] &
		(1<<((SRCCOPY>>16) % 32)) ) )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:BLT specified, but SRCCOPY not supported!" );
		goto ErrorExit;
	    }
	}
	else
	{
	    DPF( 2, "Driver can't blt" );
	}

	/*
	 * validate align fields
	 */
	if( lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN )
	{
	    if( !VALID_ALIGNMENT( lpDDHALInfo->vmiData.dwOffscreenAlign ) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid dwOffscreenAlign (%d) with DDSCAPS_OFFSCREENPLAIN specified",
			lpDDHALInfo->vmiData.dwOffscreenAlign );
		goto ErrorExit;
	    }
	}
	if( lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_OVERLAY )
	{
	    if( !VALID_ALIGNMENT( lpDDHALInfo->vmiData.dwOverlayAlign ) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid dwOverlayAlign (%d) with DDSCAPS_OVERLAY specified",
			lpDDHALInfo->vmiData.dwOverlayAlign );
		goto ErrorExit;
	    }
	}
	if( lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
	{
	    if( !VALID_ALIGNMENT( lpDDHALInfo->vmiData.dwZBufferAlign ) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid dwZBufferAlign (%d) with DDSCAPS_ZBUFFER specified",
			lpDDHALInfo->vmiData.dwZBufferAlign );
		goto ErrorExit;
	    }
	}
	if( lpDDHALInfo->ddCaps.ddsCaps.dwCaps & DDSCAPS_TEXTURE )
	{
	    if( !VALID_ALIGNMENT( lpDDHALInfo->vmiData.dwTextureAlign ) )
	    {
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Invalid dwTextureAlign (%d) with DDSCAPS_TEXTURE specified",
			lpDDHALInfo->vmiData.dwTextureAlign );
		goto ErrorExit;
	    }
	}

#ifndef WINNT
	/*
	 * NT only reports one display mode if we are in the Ctrl-Alt-Del screen
	 * so don't fail if NT changes the number of display modes.
	 */

	/*
	 * make sure display driver doesn't try to change the number of
	 * modes supported after a mode change
	 */
	if( reset )
	{
	    if( lpDDHALInfo->dwNumModes != 0 )
	    {
		if( lpDDHALInfo->dwNumModes != oldpdd->dwSaveNumModes )
		{
		    DPF(0, "*******************************************************");
		    DPF(0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Reset attempted to change number of modes from %d to %d",oldpdd->dwSaveNumModes,lpDDHALInfo->dwNumModes );
		    DPF(0, "*******************************************************");
		    goto ErrorExit;
		}
	    }
	}
#endif

	/* memory for pddd was allocated at the top of this routine */

	/*
	 * If this is the first time through, initialize a bunch of stuff.
	 * There are a number of fields that we only need to fill in when
	 * the driver object is created.
	 */
	if( !reset )
	{
	    #ifdef WIN95
		/*
		 * set up a 16-bit pointer for use by the driver
		 */
		pddd->lp16DD = (LPVOID) ptr16;
		DPF( 5, "pddd->lp16DD = %08lx", pddd->lp16DD );
	    #endif

	    /*
	     * fill in misc. values
	     */
	    pddd->lpDriverHandle = pddd;
	    pddd->hInstance = lpDDHALInfo->hInstance;

	    // init doubly-linked overlay zorder list
	    pddd->dbnOverlayRoot.next = &(pddd->dbnOverlayRoot);
	    pddd->dbnOverlayRoot.prev = pddd->dbnOverlayRoot.next;
	    pddd->dbnOverlayRoot.object = NULL;
	    pddd->dbnOverlayRoot.object_int = NULL;

	    /*
	     * modes...
	     */
	    pddd->dwNumModes = lpDDHALInfo->dwNumModes;
	    pddd->dwSaveNumModes = lpDDHALInfo->dwNumModes;
	    if( pddd->dwNumModes > 0 )
	    {
		size = pddd->dwNumModes * sizeof( DDHALMODEINFO );
#ifdef WIN95
		pddd->lpModeInfo = MemAlloc( size );
		if( pddd->lpModeInfo == NULL )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate mode info!" );
		    goto ErrorExit;
		}
#else
		pddd->lpModeInfo = &pddd->ModeInfo;
                DDASSERT( 1 == pddd->dwNumModes );
#endif
		memcpy( pddd->lpModeInfo, lpDDHALInfo->lpModeInfo, size );
		#ifdef WIN95
		    /*
		     * Check if we can add Mode X
		     */
		    do
		    {
			if (lpDDHALInfo->dwFlags & DDHALINFO_MODEXILLEGAL)
			{
			    break;
			}
			/*
			 * ModeX not allowed for PC98
			 * Check OS's locale.
			 */
			if ( GetSystemDefaultLCID() == 0x0411 )
			{
			    /*
			     * System is Windows 95 J
			     * Now retrieve keyboard ID to check PC98
			     */
			    DWORD dwSubType = GetKeyboardType(1);
			    if (HIBYTE(dwSubType) == 0x0D)
			    {
				/* NEC PC98 series */
				break;
			    }
			}
			/* NOT NEC PC98 series */
			if (IsVGADevice( szDrvName ))
			{
			    AddModeXModes( pddd );

			    /*
			     * OR in modex and/or standard VGA caps, so the app knows if
			     * it can pass the standard vga flag to enum modes.
			     */
			    lpDDHALInfo->ddCaps.ddsCaps.dwCaps |= (DDSCAPS_STANDARDVGAMODE|DDSCAPS_MODEX);
			    /*
			     * Do the HEL caps just for rationality
			     */
			    pddd->ddHELCaps.ddsCaps.dwCaps |= (DDSCAPS_STANDARDVGAMODE|DDSCAPS_MODEX);
			}
			break;
		    } while(0);
                    ExpandModeTable( pddd );
                    MassageModeTable( pddd );
		#endif
	    }
	    else
	    {
		pddd->lpModeInfo = NULL;
	    }

	    /*
	     * driver naming..  This is a special case for when we are
	     * invoked by the display driver directly, and not through
	     * the DirectDrawCreate path. Basically, everything except
	     * special 'secondary devices' like the 3DFx are DISPLAYDRV.
	     *
	     * If the driver says it's primary; ok. Else if it is "DISPLAY"
	     * or if the name is like "\\.\display4" then it is a Memphis/NT5
	     * multi-mon display device.
	     */
	    if( (lpDDHALInfo->dwFlags & DDHALINFO_ISPRIMARYDISPLAY) ||
		_stricmp( szDrvName, DISPLAY_STR ) == 0 ||
		(szDrvName[0] == '\\' && szDrvName[1] == '\\' && szDrvName[2] == '.') )
	    {
		pddd->dwFlags |= DDRAWI_DISPLAYDRV;
		pddd->dwFlags |= DDRAWI_GDIDRV;
		lstrcpy( pddd->cDriverName, szDrvName );
	    }

	    /*
	     * modex modes are illegal on some hardware.  specifically
	     * NEC machines in japan.  this allows the driver to specify
	     * that its hardware does not support modex.  modex modes are
	     * then turned off everywhere as a result.
	     */
	    if( lpDDHALInfo->dwFlags & DDHALINFO_MODEXILLEGAL )
	    {
		pddd->dwFlags |= DDRAWI_MODEXILLEGAL;
	    }
	}
	/*
	 * resetting
	 */
	else
	{
	    /*
	     * copy old struct onto new one (before we start updating)
	     * preserve the lpDDCB pointer
	     */
	    {
		LPDDHAL_CALLBACKS   save_ptr=pddd->lpDDCBtmp;
		memcpy( pddd, oldpdd, drv_callbacks_size );
		pddd->lpDDCBtmp = save_ptr;
	    }

	    /*
	     * mark all existing surfaces as gone. Note, we don't rebuild
	     * the aliases at this point as they are going to be rebuilt
	     * below anyway.
	     */
	    InvalidateAllSurfaces( oldpdd, hDDVxd, FALSE );

	    #ifdef USE_ALIAS
		/*
		 * The video memory heaps are about to go so release the
		 * aliases to those heaps that the local objects maintain.
		 *
		 * NOTE: If any surfaces are currently locked and using
		 * those aliases then the aliases will not actually be
		 * discarded until the last lock is released. In which
		 * case these aliases will be mapped to the dummy page
		 * by this point.
		 */
		if( NULL != oldpdd->phaiHeapAliases )
		{
		    DDASSERT( INVALID_HANDLE_VALUE != hDDVxd );
		    ReleaseHeapAliases( hDDVxd, oldpdd->phaiHeapAliases );
		    /*
		     * NOTE: Need to NULL out the heap alias pointer in the
		     * new driver object also as we just copied them above.
		     */
		    oldpdd->phaiHeapAliases = NULL;
		    pddd->phaiHeapAliases = NULL;
		}
	    #endif /* USE_ALIAS */

#ifndef WINNT
	    /*
	     * discard old vidmem heaps
	     */
	    for( i=0;i<(int)oldpdd->vmiData.dwNumHeaps;i++ )
	    {
		pvm = &(oldpdd->vmiData.pvmList[i]);
		if( pvm->lpHeap != NULL )
		{
		    HeapVidMemFini( pvm, hDDVxd );
		}
	    }
#endif //not WINNT
	}

	/*
	 * fill in misc data
	 */
	pddd->ddCaps = lpDDHALInfo->ddCaps;

	pddd->vmiData.fpPrimary = lpDDHALInfo->vmiData.fpPrimary;
	pddd->vmiData.dwFlags = lpDDHALInfo->vmiData.dwFlags;
	pddd->vmiData.dwDisplayWidth = lpDDHALInfo->vmiData.dwDisplayWidth;
	pddd->vmiData.dwDisplayHeight = lpDDHALInfo->vmiData.dwDisplayHeight;
	pddd->vmiData.lDisplayPitch = lpDDHALInfo->vmiData.lDisplayPitch;
	pddd->vmiData.ddpfDisplay = lpDDHALInfo->vmiData.ddpfDisplay;
	pddd->vmiData.dwOffscreenAlign = lpDDHALInfo->vmiData.dwOffscreenAlign;
	pddd->vmiData.dwOverlayAlign = lpDDHALInfo->vmiData.dwOverlayAlign;
	pddd->vmiData.dwTextureAlign = lpDDHALInfo->vmiData.dwTextureAlign;
	pddd->vmiData.dwZBufferAlign = lpDDHALInfo->vmiData.dwZBufferAlign;
	pddd->vmiData.dwAlphaAlign = lpDDHALInfo->vmiData.dwAlphaAlign;

#ifdef WIN95
	/*
	 * We need to compute the number of heaps that are actually usable.
	 * The number of usable heaps may be different from the number of
	 * heap descriptors passed to us by the driver due to AGP. If the
	 * driver attempts to pass AGP heaps to use and the OS we are running
	 * under doesn't have AGP support we can't use those heaps so we
	 * ignore them.
	 */
	pddd->vmiData.dwNumHeaps = lpDDHALInfo->vmiData.dwNumHeaps;
	for( i=0;i<(int)lpDDHALInfo->vmiData.dwNumHeaps;i++ )
	{
	    if( ( lpDDHALInfo->vmiData.pvmList[i].dwFlags & VIDMEM_ISNONLOCAL ) && !isagpaware )
	    {
		DPF(3, "Discarding AGP heap %d", i);
		pddd->vmiData.dwNumHeaps--;
	    }
	}

	/*
	 * NOTE: Its not illegal to end up with no video memory heaps at this point.
	 * Under the current AGP implementation the primary is always in local
	 * video memory so we always end up with a valid primary if nothing else.
	 * Therefore, we stay in non-emulated mode.
	 */
        #ifdef WIN95
	    #ifdef DEBUG
	        if( 0UL == pddd->vmiData.dwNumHeaps )
	        {
		    DPF( 2, "All video memory heaps have been disabled." );
	        }
	    #endif /* DEBUG */
        #endif //WIN95
#endif
	/*
	 * fpPrimaryOrig has no user-mode meaning under NT... primary's surface may have different address
	 * across processes.
	 * There is a new flag (DDRAWISURFGBL_ISGDISURFACE) which identifies a surface gbl object
	 * as representing the surface which GDI believes is the front buffer. jeffno 960122
	 */
	pddd->fpPrimaryOrig = lpDDHALInfo->vmiData.fpPrimary;
        // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(5,"Primary video ram pointer is 0x%p", lpDDHALInfo->vmiData.fpPrimary);
#ifdef WIN95
	pddd->dwMonitorFrequency = lpDDHALInfo->dwMonitorFrequency;
	if( ( pddd->dwMonitorFrequency == 0 ) &&
	    ( lpDDHALInfo->dwModeIndex != (DWORD) -1 ) &&
	    ( lpDDHALInfo->lpModeInfo != NULL ) &&
	    ( lpDDHALInfo->lpModeInfo[lpDDHALInfo->dwModeIndex].wRefreshRate != 0 ) &&
            !( lpDDHALInfo->lpModeInfo[lpDDHALInfo->dwModeIndex].wFlags & DDMODEINFO_MAXREFRESH ))
	{
	    pddd->dwMonitorFrequency = lpDDHALInfo->lpModeInfo[lpDDHALInfo->dwModeIndex].wRefreshRate;
	}
	pddd->dwModeIndexOrig = lpDDHALInfo->dwModeIndex;
        pddd->dwModeIndex = lpDDHALInfo->dwModeIndex;
	DPF( 5, "Current and Original Mode = %d", pddd->dwModeIndex );
	DPF( 5, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ MODE INDEX = %ld", pddd->dwModeIndex );
#else
        pddd->dmiCurrent.wWidth = (WORD) lpDDHALInfo->lpModeInfo->dwWidth;
        pddd->dmiCurrent.wHeight = (WORD) lpDDHALInfo->lpModeInfo->dwHeight;
        if (lpDDHALInfo->lpModeInfo->dwBPP == 16)
        {
            pddd->dmiCurrent.wBPP = (lpDDHALInfo->lpModeInfo->wFlags & DDMODEINFO_555MODE) ? 15 : 16;
        }
        else
        {
            pddd->dmiCurrent.wBPP = (BYTE) lpDDHALInfo->lpModeInfo->dwBPP;
        }
        pddd->dmiCurrent.wRefreshRate = lpDDHALInfo->lpModeInfo->wRefreshRate;
        pddd->dwMonitorFrequency = lpDDHALInfo->lpModeInfo->wRefreshRate;
        pddd->dmiCurrent.wMonitorsAttachedToDesktop = (BYTE) GetNumberOfMonitorAttachedToDesktop();
#endif

	/*
	 * pdevice info
	 */
	#ifdef WIN95
	    if( lpDDHALInfo->lpPDevice != NULL )
	    {
		LPDIBENGINE     pde;

		pde = MapSLFix( (DWORD) lpDDHALInfo->lpPDevice );
		if( (pde->deType != 0x5250) || !(pde->deFlags & MINIDRIVER))
		{
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Not a DIBEngine mini driver" );
		    goto ErrorExit;
		}
		pddd->dwPDevice = (DWORD)lpDDHALInfo->lpPDevice;
		pddd->lpwPDeviceFlags = &pde->deFlags;
                // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		DPF( 5, "lpPDevice = 0x%p", pde );
		if(pde->deBitsPixel == 16)
		{
		    if(pde->deFlags & FIVE6FIVE)
		    {
			pddd->vmiData.ddpfDisplay.dwRBitMask = 0xf800;
			pddd->vmiData.ddpfDisplay.dwGBitMask = 0x07e0;
			pddd->vmiData.ddpfDisplay.dwBBitMask = 0x001f;
		    }
		    else
		    {
			pddd->vmiData.ddpfDisplay.dwRBitMask = 0x7c00;
			pddd->vmiData.ddpfDisplay.dwGBitMask = 0x03e0;
			pddd->vmiData.ddpfDisplay.dwBBitMask = 0x001f;
		    }
		    // Update the current mode to reflect the correct bitmasks
		    // NOTE: The driver can return a dwModeIndex of -1 if in
		    // a currently unsupported mode. Therefore, we must not
		    // initialize these masks if such an index has been
		    // returned.
		    if( 0xFFFFFFFFUL != pddd->dwModeIndex )
		    {
			pddd->lpModeInfo[ pddd->dwModeIndex ].dwRBitMask = pddd->vmiData.ddpfDisplay.dwRBitMask;
			pddd->lpModeInfo[ pddd->dwModeIndex ].dwGBitMask = pddd->vmiData.ddpfDisplay.dwGBitMask;
			pddd->lpModeInfo[ pddd->dwModeIndex ].dwBBitMask = pddd->vmiData.ddpfDisplay.dwBBitMask;
		    }
		    DPF(5, "Setting the bitmasks for the driver (R:%04lx G:%04lx B:%04lx)",
			pddd->vmiData.ddpfDisplay.dwRBitMask,
			pddd->vmiData.ddpfDisplay.dwGBitMask,
			pddd->vmiData.ddpfDisplay.dwBBitMask);
		}
	    }
	    else
	#else
	    /*
	     * Grab masks from NT driver
	     */
	    pddd->vmiData.ddpfDisplay.dwRBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwRBitMask;
	    pddd->vmiData.ddpfDisplay.dwGBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwGBitMask;
	    pddd->vmiData.ddpfDisplay.dwBBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwBBitMask;
	    if( 0xFFFFFFFFUL != pddd->dwModeIndex )
	    {
		pddd->lpModeInfo[ pddd->dwModeIndex ].dwRBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwRBitMask;
		pddd->lpModeInfo[ pddd->dwModeIndex ].dwGBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwGBitMask;
		pddd->lpModeInfo[ pddd->dwModeIndex ].dwBBitMask = lpDDHALInfo->vmiData.ddpfDisplay.dwBBitMask;
	    }
	    DPF(5, "Setting the bitmasks for the driver (R:%04lx G:%04lx B:%04lx)",
		pddd->vmiData.ddpfDisplay.dwRBitMask,
		pddd->vmiData.ddpfDisplay.dwGBitMask,
		pddd->vmiData.ddpfDisplay.dwBBitMask);
	#endif
	    {
		if( !reset )
		{
		    pddd->dwPDevice = 0;
		    pddd->lpwPDeviceFlags = (WORD *)&dwFakeFlags;
		}
	    }

	/*
	 * fourcc codes...
	 */
        MemFree( pddd->lpdwFourCC );
        pddd->lpdwFourCC = NULL;
        if (oldpdd != NULL)
        {
            oldpdd->lpdwFourCC = NULL;
        }
	pddd->ddCaps.dwNumFourCCCodes = lpDDHALInfo->ddCaps.dwNumFourCCCodes;
	pddd->dwNumFourCC = pddd->ddCaps.dwNumFourCCCodes;
	if( pddd->ddCaps.dwNumFourCCCodes > 0 )
	{
	    size = pddd->ddCaps.dwNumFourCCCodes * sizeof( DWORD );
	    pddd->lpdwFourCC = MemAlloc( size );
	    if( pddd->lpdwFourCC == NULL )
	    {
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate FOURCC data!" );
		goto ErrorExit;
	    }
	    memcpy( pddd->lpdwFourCC, lpDDHALInfo->lpdwFourCC, size );
	}

    /*
     * Extended 3D caps structure
     *
     */
    if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
    {
        HRESULT ret;
        DDHAL_GETDRIVERINFODATA gdidata;

        if (oldpdd != NULL)
        {
            oldpdd->lpD3DExtendedCaps = 0;
        }

        if (! pddd->lpD3DExtendedCaps)
        {
            pddd->lpD3DExtendedCaps = MemAlloc( D3DHAL_D3DEXTENDEDCAPSSIZE );
        }
        if (! pddd->lpD3DExtendedCaps)
        {
            DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not allocate D3D extended caps structure" );
        }
        else
        {
            memset( (LPVOID) pddd->lpD3DExtendedCaps, 0, D3DHAL_D3DEXTENDEDCAPSSIZE );
            ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo,
                      &gdidata,
                      (LPVOID) pddd->lpD3DExtendedCaps,
                      D3DHAL_D3DEXTENDEDCAPSSIZE,
                      &GUID_D3DExtendedCaps, 
                      pddd,
                      FALSE /* bInOut */);

            if (ret != DD_OK)
            {
                DPF ( 2,"D3D Extended Caps query failed" );
                MemFree( (LPVOID) pddd->lpD3DExtendedCaps );
                pddd->lpD3DExtendedCaps = 0;
            }
        }

        // Extended caps was not compulsory for pre-DX6 drivers.
        // Extended caps is compulsory for DX6+ drivers since it contains
        // information about the driver's multitexture capabilities, FVF
        // support and stencil support.
        if (pddd->lpD3DHALCallbacks3->DrawPrimitives2)
        {
            if (pddd->lpD3DExtendedCaps == NULL)
            {
                DPF_ERR ( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:DX6+ drivers should report D3D Extended Caps, failing driver creation" );
                goto ErrorExit;
            }
            else if (gdidata.dwActualSize != pddd->lpD3DExtendedCaps->dwSize)
            {
                DPF_ERR ( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Actual size reported is not equal to dwSize field in the Extended caps structure" );
                goto ErrorExit;
            }
            else if (pddd->lpD3DExtendedCaps->dwSize < D3DHAL_D3DDX6EXTENDEDCAPSSIZE)
            {
                DPF_ERR ( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Driver reported insufficient D3D Extended Caps, failing driver creation" );
                goto ErrorExit;
            }

            // If stencil capabilities are reported the driver should have
            // exported Clear2
            if (pddd->lpD3DExtendedCaps->dwStencilCaps != 0)
            {
                if ((pddd->lpD3DHALCallbacks3->Clear2 == NULL) &&
                    (0 == pddd->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState)
                   )
                {
                    DPF_ERR ( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Pre DX7 Driver should report clear2 if any stencilcaps are set, failing driver creation" );
                    goto ErrorExit;
                }
            }
        }
    }
    else    // Driver doesn't have DDHALINFO_GETDRIVERINFOSET
    {
        if (pddd->lpD3DExtendedCaps)
        {
            memset( (LPVOID) pddd->lpD3DExtendedCaps, 0, D3DHAL_D3DEXTENDEDCAPSSIZE );
            if (oldpdd)
            {
                oldpdd->lpD3DExtendedCaps = NULL;
            }
        }
    }

        if (lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFO2)
        {
            pddd->dwFlags |= DDRAWI_DRIVERINFO2;
        }

	/*
	 * video port descriptions
	 */
	if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
	{
	    MemFree( pddd->lpDDVideoPortCaps );
	    pddd->lpDDVideoPortCaps = NULL;
            if (oldpdd != NULL)
            {
	        oldpdd->lpDDVideoPortCaps = NULL;
            }
	    pddd->ddCaps.dwMaxVideoPorts = lpDDHALInfo->ddCaps.dwMaxVideoPorts;
	    if( pddd->ddCaps.dwMaxVideoPorts > 0 )
	    {
		HRESULT ret;
		DDHAL_GETDRIVERINFODATA gdidata;

		size = pddd->ddCaps.dwMaxVideoPorts * sizeof( DDVIDEOPORTCAPS );
		pddd->lpDDVideoPortCaps = MemAlloc( size );
		if( pddd->lpDDVideoPortCaps == NULL )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate video port caps!" );
		    goto ErrorExit;
		}
		memset( pddd->lpDDVideoPortCaps, 0, size );

		ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo,
				    &gdidata,
				    pddd->lpDDVideoPortCaps,
				    size,
				    &GUID_VideoPortCaps, pddd,
                                    FALSE /* bInOut */);

		if (ret != DD_OK)
		{
		    DPF ( 2,"VideoPortCaps query failed" );
		    MemFree(pddd->lpDDVideoPortCaps);
		    pddd->lpDDVideoPortCaps = NULL;
		}
	    }
	}

	/*
	 * Kernel mode capabilities
	 *
	 * We only get these once we munge them when creating the driver
	 * object and we don't want to munge them everytime.  We do need
	 * to munge the video port caps, however, to reflect the autoflip
	 * capabilities.
	 */
	if ( lpDDHALInfo->dwFlags & DDHALINFO_GETDRIVERINFOSET )
	{
	    if (pddd->lpDDKernelCaps == NULL)
	    {
		HRESULT ret;
		DDHAL_GETDRIVERINFODATA gdidata;

		size = sizeof( DDKERNELCAPS );
		pddd->lpDDKernelCaps = MemAlloc( size );
		if( pddd->lpDDKernelCaps == NULL )
		{
		   DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate kernel caps!" );
		   goto ErrorExit;
		}
		memset( pddd->lpDDKernelCaps, 0, size );

		ret = GetDriverInfo(lpDDHALInfo->GetDriverInfo,
				    &gdidata,
				    pddd->lpDDKernelCaps,
				    size,
				    &GUID_KernelCaps, pddd,
                                    FALSE /* bInOut */);
		#ifdef WIN95
		    if( !IsWindows98() )
		    {
			ret = DDERR_GENERIC;
		    }
		#endif

		if (ret != DD_OK)
		{
		    DPF ( 2, "KernelCaps query failed" );
		    MemFree(pddd->lpDDKernelCaps);
		    pddd->lpDDKernelCaps = NULL;
		    }
	    }
#ifdef WIN95
	    else
	    {
		MungeAutoflipCaps(pddd);
	    }
#endif
	}

	/*
	 * fill in rops
	 */
	if( lpDDHALInfo->ddCaps.dwCaps & DDCAPS_BLT )
	{
	    for( i=0;i<DD_ROP_SPACE;i++ )
	    {
		pddd->ddCaps.dwRops[i] = lpDDHALInfo->ddCaps.dwRops[i];
	    }
	}

	/*
	 * get (or generate) the non-local video memory caps.
	 */
	MemFree( pddd->lpddNLVCaps );
	pddd->lpddNLVCaps = NULL;
        if (oldpdd != NULL)
        {
            oldpdd->lpddNLVCaps = NULL;
        }
	if( !GetNonLocalVidMemCaps( lpDDHALInfo, pddd ) )
	{
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not initialize non-local video memory caps" );
	    goto ErrorExit;
	}

	/*
	 * Get the driver's extended capabilities.
	 */
	if( !GetDDMoreCaps( lpDDHALInfo, pddd ) )
	{
	    // An error occurred during GetDDMoreCaps() call above.
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not initialize extended caps" );
	    goto ErrorExit;
	}

	/*
	 * Direct3D data structures
	 */
//#ifdef WINNT
//	MemFree((void *)pddd->lpD3DHALCallbacks);
//#endif
	if( lpDDHALInfo->dwSize >= DDHALINFOSIZE_V2 )
	{
	    // Direct3D data is present
	    pddd->lpD3DGlobalDriverData = lpDDHALInfo->lpD3DGlobalDriverData;
	    pddd->lpD3DHALCallbacks = lpDDHALInfo->lpD3DHALCallbacks;
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 5, "DDHALInfo contains D3D pointers: 0x%p 0x%p", pddd->lpD3DGlobalDriverData, pddd->lpD3DHALCallbacks);
	}
	else
	{
	    // No Direct3D data present in DDHALInfo
	    pddd->lpD3DGlobalDriverData = 0;
	    pddd->lpD3DHALCallbacks = 0;
	    DPF( 1, "No Direct3D Support in driver");
	}

	freevm = 0;
#ifndef WINNT
        /*
         * NT kernel does the memory management now
         */
	MemFree( pddd->vmiData.pvmList );
        pddd->vmiData.pvmList = NULL;
        if (oldpdd != NULL)
        {
            oldpdd->vmiData.pvmList = NULL;
        }
	if( pddd->vmiData.dwNumHeaps > 0 )
	{
	    size = sizeof( VIDMEM ) * pddd->vmiData.dwNumHeaps;
	    pddd->vmiData.pvmList = MemAlloc( size );
	    if( pddd->vmiData.pvmList == NULL )
	    {
	       DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Insufficient memory to allocate heap info!" );
	       goto ErrorExit;
	    }
	}

	devheapno = 0;
	for( i=0;i<(int)lpDDHALInfo->vmiData.dwNumHeaps;i++ )
	{
	    /*
	     * Ask driver for any additional heap alignment requirements
	     */
	    DDHAL_GETHEAPALIGNMENTDATA ghad;
	    LPHEAPALIGNMENT pghad=0;
	    /*
	     * pghad will be null if no alignment
	     */
	    pghad = GetExtendedHeapAlignment(pddd, &ghad, i );

	    if( !( lpDDHALInfo->vmiData.pvmList[i].dwFlags & VIDMEM_ISNONLOCAL ) || isagpaware )
	    {
		DWORD dwHeapFlags;

		pvm = &(pddd->vmiData.pvmList[devheapno]);
		*pvm = lpDDHALInfo->vmiData.pvmList[i];

		dwHeapFlags = 0UL;

		/*
		 * if a heap is specified, then we don't need to allocate
		 * one ourselves (for shared media devices)
		 */
		if( !(pvm->dwFlags & VIDMEM_ISHEAP) )
		{
		    #ifdef DEBUG
			if( pvm->dwFlags & VIDMEM_ISLINEAR )
			{
			    int vram = GetProfileInt("DirectDraw", "vram", -1);

			    if (vram > 0 && (pvm->fpStart + vram*1024L-1) < pvm->fpEnd)
			    {
                                // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
				DPF( 1, "pretending display card has only %dk VRAM", vram);
				DPF( 1, "pvm->fpStart = 0x%p, pvm->fpEnd = 0x%p", pvm->fpStart, pvm->fpEnd );
				pvm->fpEnd = pvm->fpStart + vram*1024L-1;
			    }
			}
		    #endif
		    DPF(5,V,"Heap #%d is 0x%08x x 0x%08x",devheapno,pvm->dwWidth,pvm->dwHeight);
		    if ( ! HeapVidMemInit( pvm, pddd->vmiData.lDisplayPitch, hDDVxd , pghad ) )
		    {
			pvm->lpHeap = NULL;

                        /*
                         * If this is an AGP heap, we probably failed because we couldn't reserve
                         * any AGP memory.  This this case, we simply want to remove the heap
                         * rather than fail to emulation.  We do not want to remove the AGP
                         * caps, however, since some drivers (e.g. nVidia) can allocate it
                         * without using our heap.
                         */
                        if( pvm->dwFlags & VIDMEM_ISNONLOCAL )
                        {
                            /*
                             * At this time, dwNumHeaps should always be greater than 0,
                             * but I added the check anyway in case something changes later.
                             */
                            if( pddd->vmiData.dwNumHeaps > 0 )
                            {
                                if( --pddd->vmiData.dwNumHeaps == 0 )
                                {
                                    MemFree( pddd->vmiData.pvmList );
                                    pddd->vmiData.pvmList = NULL;
                                }
                            }
                            continue;
                        }
		    }
		}

		if( pvm->lpHeap == NULL )
		{
		    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not create video memory heap!" );
		    for( j=0;j<devheapno;j++ )
		    {
			pvm = &(pddd->vmiData.pvmList[j]);
			HeapVidMemFini( pvm, hDDVxd );
	    }
		    goto ErrorExit;
		}

		freevm += VidMemAmountFree( pvm->lpHeap );

		devheapno++;
	    }
	    else
	    {
		/*
		 * This is an AGP memory heap but the operating system
		 * does not have the necessary AGP extensions. Discard
		 * this heap descriptor.
		 */
		DPF( 1, "Discarding AGP heap %d. OS does not have AGP support", i );
	    }
        }
#endif //not WINNT
	pddd->ddCaps.dwVidMemTotal = freevm;

	/*
	 * Grab any extended surface caps and heap restrictions from the driver
	 */
	if( !GetDDMoreSurfaceCaps( lpDDHALInfo, pddd ) )
	{
	    // An error occurred during GetDDMoreCaps() call above.
	    DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not initialize extended surface caps" );
	    goto ErrorExit;
	}

	/*
	 * Differences between win95 and NT HAL setup.
	 * On Win95, the 32bit entry points (DDHALCALLBACKS.DDHAL...) are reset to point to the
	 * helper functions inside w95hal.c, and only overwritten (with what comes in in the
	 * DDHALINFO structure from the driver) if the corresponding bit is set in the DDHALINFO's
	 * lpDD*...dwFlags coming in from the driver.
	 * On NT, there's no thunking, so the only use for the pointers stored in the
	 * DDHALCALLBACKS.cb... entries is deciding if there's a HAL function pointer before
	 * doing a HALCALL. Since the 32 bit callbacks are not initialized to point
	 * to the w95hal.c stubs, we zero them out before copying the individual driver callbacks
	 * one by one.
	 */

	/*
	 * set up driver HAL
	 */
	#ifdef WIN95
	    //Initialise HAL to 32-bit stubs in w95hal.c:
	    pddd->lpDDCBtmp->HALDD = ddHALDD;
	#else
	    memset(&pddd->lpDDCBtmp->HALDD,0,sizeof(pddd->lpDDCBtmp->HALDD));
	#endif
	drvcb = lpDDHALInfo->lpDDCallbacks;
	if( drvcb != NULL )
	{
	    numcb = NUM_CALLBACKS( drvcb );
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(5,"DDHal callback flags:%08x",drvcb->dwFlags);
	    for (i=0;i<numcb;i++) DPF(5,"   0x%p",(&drvcb->DestroyDriver)[i]);

	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( drvcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    (&pddd->lpDDCBtmp->HALDD.DestroyDriver)[i] = (&drvcb->DestroyDriver)[i];
		}
		bit <<= 1;
	    }
	}

	/*
	 * set up surface HAL
	 */
	#ifdef WIN95
	    pddd->lpDDCBtmp->HALDDSurface = ddHALDDSurface;
	#else
	    memset(&pddd->lpDDCBtmp->HALDDSurface,0,sizeof(pddd->lpDDCBtmp->HALDDSurface));
	#endif
	surfcb = lpDDHALInfo->lpDDSurfaceCallbacks;
	if( surfcb != NULL )
	{
	    numcb = NUM_CALLBACKS( surfcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( surfcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    (&pddd->lpDDCBtmp->HALDDSurface.DestroySurface)[i] = (&surfcb->DestroySurface)[i];
		}
		bit <<= 1;
	    }
	}

	/*
	 * set up palette callbacks
	 */
	#ifdef WIN95
	    pddd->lpDDCBtmp->HALDDPalette = ddHALDDPalette;
	#else
	    memset (&pddd->lpDDCBtmp->HALDDPalette,0,sizeof(pddd->lpDDCBtmp->HALDDPalette));
	#endif
	palcb = lpDDHALInfo->lpDDPaletteCallbacks;
	if( palcb != NULL )
	{
	    numcb = NUM_CALLBACKS( palcb );
	    bit = 1;
	    for( i=0;i<numcb;i++ )
	    {
		if( palcb->dwFlags & bit )
		{
                    // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
		    (&pddd->lpDDCBtmp->HALDDPalette.DestroyPalette)[i] = (&palcb->DestroyPalette)[i];
		}
		bit <<= 1;
	    }
	}

	/*
	 * set up execute buffer callbacks
	 * NOTE: Need explicit check for V2 driver as V1 driver knows nothing
	 * about these. For an old driver the default HAL callback table will
	 * be used unmodified.
	 */
	#ifdef WIN95
	    pddd->lpDDCBtmp->HALDDExeBuf = ddHALDDExeBuf;
	#endif
	if( lpDDHALInfo->dwSize >= DDHALINFOSIZE_V2 )
	{
	    exebufcb = lpDDHALInfo->lpDDExeBufCallbacks;
	    if( exebufcb != NULL )
	    {
		numcb = NUM_CALLBACKS( exebufcb );
		bit = 1;
		for( i=0;i<numcb;i++ )
		{
		    if( exebufcb->dwFlags & bit )
		    {
                        // 5/24/2000(RichGr): IA64: Remove (DWORD FAR*) casts from pointer assignment.
			(&pddd->lpDDCBtmp->HALDDExeBuf.CanCreateExecuteBuffer)[i] = (&exebufcb->CanCreateExecuteBuffer)[i];
		    }
		    bit <<= 1;
		}
	    }
	}

	/*
	 * make sure we wipe out old callbacks!
	 */
	memset( &pddd->lpDDCBtmp->cbDDCallbacks, 0, sizeof( pddd->lpDDCBtmp->cbDDCallbacks ) );
	memset( &pddd->lpDDCBtmp->cbDDSurfaceCallbacks, 0, sizeof( pddd->lpDDCBtmp->cbDDSurfaceCallbacks ) );
	memset( &pddd->lpDDCBtmp->cbDDPaletteCallbacks, 0, sizeof( pddd->lpDDCBtmp->cbDDPaletteCallbacks ) );
	memset( &pddd->lpDDCBtmp->cbDDExeBufCallbacks,  0, sizeof( pddd->lpDDCBtmp->cbDDExeBufCallbacks ) );

	/*
	 * copy callback routines
	 */
	if( lpDDHALInfo->lpDDCallbacks != NULL )
	{
	    memcpy( &pddd->lpDDCBtmp->cbDDCallbacks, lpDDHALInfo->lpDDCallbacks,
		    (UINT) lpDDHALInfo->lpDDCallbacks->dwSize );
	}
	if( lpDDHALInfo->lpDDSurfaceCallbacks != NULL )
	{
	    memcpy( &pddd->lpDDCBtmp->cbDDSurfaceCallbacks, lpDDHALInfo->lpDDSurfaceCallbacks,
		    (UINT) lpDDHALInfo->lpDDSurfaceCallbacks->dwSize );
	}
	if( lpDDHALInfo->lpDDPaletteCallbacks != NULL )
	{
	    memcpy( &pddd->lpDDCBtmp->cbDDPaletteCallbacks, lpDDHALInfo->lpDDPaletteCallbacks,
		    (UINT) lpDDHALInfo->lpDDPaletteCallbacks->dwSize );
	}
	if( ( lpDDHALInfo->dwSize >= DDHALINFOSIZE_V2  ) &&
	    ( lpDDHALInfo->lpDDExeBufCallbacks != NULL ) )
	{
	    memcpy( &pddd->lpDDCBtmp->cbDDExeBufCallbacks, lpDDHALInfo->lpDDExeBufCallbacks,
		    (UINT) lpDDHALInfo->lpDDExeBufCallbacks->dwSize );
	}

#ifndef WIN95
        if (pddd->lpDDCBtmp->HALDDNT.SetExclusiveMode)
        {
            pddd->lpDDCBtmp->HALDD.SetExclusiveMode =
                pddd->lpDDCBtmp->cbDDCallbacks.SetExclusiveMode =
                    pddd->lpDDCBtmp->HALDDNT.SetExclusiveMode;
        }
        if (pddd->lpDDCBtmp->HALDDNT.FlipToGDISurface)
        {
            pddd->lpDDCBtmp->HALDD.FlipToGDISurface =
                pddd->lpDDCBtmp->cbDDCallbacks.FlipToGDISurface =
                   pddd->lpDDCBtmp->HALDDNT.FlipToGDISurface;
        }
#endif

	/*
	 * init shared caps
	 */
	capsInit( pddd );
        mergeHELCaps( pddd );

	/*
	 * if we were asked to reset, keep the new data
	 */
	if( reset )
	{
	    /*
	     * copy new structure onto original one
	     * being careful to preserve lpDDCB
	     */
	    {
		LPDDHAL_CALLBACKS save_ptr = oldpdd->lpDDCBtmp;
		memcpy( oldpdd, pddd, drv_callbacks_size );
		oldpdd->lpDDCBtmp = save_ptr;
	    }
	    MemFree( pddd );
	    pddd = oldpdd;
	}
    }
    else
    {
	DPF( 4, "Driver object already exists" );
	#ifdef DEBUG
	    /*
	     * pddd is now allocated at the top of the routine, before the if that goes
	     * with the preceding else... jeffno 960115
	     */
	    if (pddd)
	    {
		DPF(4,"Allocated space for a driver object when it wasn't necessary!");
	    }
	#endif
	MemFree(pddd);  //should be NULL, just in case...
	pddd = oldpdd;
    }

    /*
     * set bank switched
     */
    if( pddd->dwFlags & DDRAWI_DISPLAYDRV )
    {
	HDC     hdc;
	hdc = DD_CreateDC( szDrvName );
	if( DCIIsBanked( hdc ) ) //NT_FIX??
	{
	    pddd->ddCaps.dwCaps |= DDCAPS_BANKSWITCHED;
	    DPF( 2, "Setting DDCAPS_BANKSWITCHED" );
	}
	else
	{
	    pddd->ddCaps.dwCaps &= ~DDCAPS_BANKSWITCHED;
	    DPF( 2, "NOT Setting DDCAPS_BANKSWITCHED" );
	}
	DD_DoneDC( hdc );

        /*
         * Display drivers can all render windowed
         */
        //BEGIN VOODOO2 HACK
        if ( (0 == (dwRegFlags & DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES)) ||
             (IsVGADevice( szDrvName )) )
        //END VOODOO2 HACK
        {
            pddd->ddCaps.dwCaps2 |= DDCAPS2_CANRENDERWINDOWED;
        }
    }
    InitGamma( pddd, szDrvName );

    /*
     * Disable non-local video memory if the operating system
     * is not AGP aware.
     */
    if( ( pddd->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM ) && !isagpaware )
    {
	DPF( 2, "OS is not AGP aware. Disabling DDCAPS2_NONLOCALVIDMEM" );
	pddd->ddCaps.dwCaps2 &= ~DDCAPS2_NONLOCALVIDMEM;
    }

    if( !( pddd->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM ))
    {
	if (lpDDHALInfo->lpD3DGlobalDriverData && (lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps & D3DDEVCAPS_TEXTURENONLOCALVIDMEM))
	{   //some drivers(Riva128 on PCI) incorrectly sets D3DDEVCAPS_TEXTURENONLOCALVIDMEM
            DPF( 1, "driver set D3DDEVCAPS_TEXTURENONLOCALVIDMEM w/o DDCAPS2_NONLOCALVIDMEM:turning off D3DDEVCAPS_TEXTURENONLOCALVIDMEM" );
	    lpDDHALInfo->lpD3DGlobalDriverData->hwCaps.dwDevCaps &= ~D3DDEVCAPS_TEXTURENONLOCALVIDMEM;
	}
    }

    #ifdef USE_ALIAS
	/*
	 * Can we use VRAM aliasing and PDEVICE modification to avoid taking
	 * the Win16 lock when locking a VRAM surface? Can't if the device is
	 * bankswitched or if the DIB Engine is not a version we recognize.
	 */
	if (!(lpDDHALInfo->ddCaps.dwCaps & DDCAPS_NOHARDWARE))
	{
	    if( ( pddd->dwFlags & DDRAWI_DISPLAYDRV )           &&
		( ( pddd->ddCaps.dwCaps & DDCAPS_BANKSWITCHED ) || ( !DD16_FixupDIBEngine() ) ) )
	    {
		pddd->dwFlags |= DDRAWI_NEEDSWIN16FORVRAMLOCK;
		DPF( 2, "Win16 lock must be taken for VRAM locks" );
	    }
	    else
	    {
		pddd->dwFlags &= ~DDRAWI_NEEDSWIN16FORVRAMLOCK;
		DPF( 2, "Taking the Win16 lock may not be necessary for VRAM locks" );
	    }

	    /*
	     * Create the virtual memory heap aliases for this global object
	     */
	    if(  ( pddd->dwFlags & DDRAWI_DISPLAYDRV ) &&
		!( pddd->dwFlags & DDRAWI_NEEDSWIN16FORVRAMLOCK ) )
	    {
		DDASSERT( INVALID_HANDLE_VALUE != hDDVxd );
		if( FAILED( CreateHeapAliases( hDDVxd, pddd ) ) )
		{
                    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
		    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Could not create the heap aliases for driver object 0x%p", pddd );
		    goto ErrorExit;
		}
	    }
	}
    #endif /* USE_ALIAS */

#ifdef WIN95
    /*
     * If we have a driver which has AGP support and which has provided us with a
     * notification callback so that we can tell it the GART linear and physical
     * addresses of the heaps it provided to us then invoke that callback now
     * for the non-local heaps we initialized.
     */
    if( (NULL != pddd) && (pddd->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM) )
    {
	LPDDHAL_UPDATENONLOCALHEAP   unlhfn;
	DDHAL_UPDATENONLOCALHEAPDATA unlhd;
	LPVIDMEM                     lpHeap;
	DWORD                        rc;

	unlhfn = pddd->lpDDCBtmp->HALDDMiscellaneous.UpdateNonLocalHeap;
	if( NULL != unlhfn )
	{
	    unlhd.lpDD               = pddd;
            unlhd.ulPolicyMaxBytes   = dwAGPPolicyMaxBytes;
	    unlhd.ddRVal             = DDERR_GENERIC; /* Force the driver to return something sensible */
	    unlhd.UpdateNonLocalHeap = NULL;
	    for( i = 0; i < (int)pddd->vmiData.dwNumHeaps; i++ )
	    {
		lpHeap = &pddd->vmiData.pvmList[i];
		if( lpHeap->dwFlags & VIDMEM_ISNONLOCAL )
		{
		    DPF( 4, "Notifying driver of update to non-local heap %d", i );
		    unlhd.dwHeap    = i;
		    unlhd.fpGARTLin = lpHeap->lpHeap->fpGARTLin;
		    unlhd.fpGARTDev = lpHeap->lpHeap->fpGARTDev;
		    DOHALCALL( UpdateNonLocalHeap, unlhfn, unlhd, rc, FALSE );

		    /*
		     * Currently this callback is pure notification. The driver
		     * cannot fail it.
		     */
		    DDASSERT( DDHAL_DRIVER_HANDLED == rc );
		    DDASSERT( DD_OK == unlhd.ddRVal );
		}
	    }
	}
    }
#endif

    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 5, "DirectDrawObjectCreate: Returning global object 0x%p", pddd );

    #ifdef WINNT
	MemFree(lpDDHALInfo->lpdwFourCC);
	MemFree(lpDDHALInfo->vmiData.pvmList);
    #endif

    LEAVE_DDRAW();
    return pddd;

ErrorExit:
    // We must not free memory in the reset path, since the oldpdd will survive this
    // call to DirectDrawObjectCreate, and be freed by IDD::Release sometime later.
    // We will not NULL out all these ptrs either, since that would invite a bazillion
    // stress failures elsewhere in the code. We will leave the ptrs valid, but set
    // DDUNSUPPORTEDMODE in the mode index, both to throttle further usage of this ddraw
    // global (which now is full of caps etc. from the wrong mode) and as an indicator 
    // that this is what happened in future stress investigations.
    // We are also going to wimp out and change only the NT path.

    if (pddd
#ifdef WINNT
        && !reset
#endif
        )
    {
	MemFree( pddd->lpDDVideoPortCaps );
	MemFree( pddd->lpddNLVCaps );
	MemFree( pddd->lpddNLVHELCaps );
	MemFree( pddd->lpddNLVBothCaps );
	MemFree( pddd->lpD3DHALCallbacks2 );
	MemFree( pddd->lpD3DHALCallbacks3 );
	MemFree( pddd->lpZPixelFormats );
	MemFree( pddd->lpddMoreCaps );
	MemFree( pddd->lpddHELMoreCaps );
	MemFree( pddd->lpddBothMoreCaps );
    #ifdef POSTPONED
	MemFree( pddd->lpDDOptSurfaceInfo );
	MemFree( pddd->lpDDUmodeDrvInfo );
    #endif //POSTPONED
    #ifdef WINNT
    	if (pddd->hDD != 0)
	{
            // Delete the object if not resetting. If we were just resetting
            // we should not delete it as it may work later; the call to
            // enable or query the DirectDraw object may have failed because
            // the system is displaying the logon desktop, or is in 4 bpp or
            // another unsupported mode.
            if (!reset)
            {
                DdDeleteDirectDrawObject(pddd);
            }
	}
    #endif //WINNT
	MemFree( pddd );
    }
#ifdef WINNT
    if (reset && pddd)
    {
        pddd->dwModeIndex = DDUNSUPPORTEDMODE;
    }

    MemFree(lpDDHALInfo->lpdwFourCC);
    MemFree(lpDDHALInfo->vmiData.pvmList);
    if (ismemalloced && !reset)
    {
        MemFree(pd3dNTHALCallbacks);
    }
#endif
    LEAVE_DDRAW();
    return NULL;

} /* DirectDrawObjectCreate */

#pragma message( REMIND( "I'm drowning in a sea of ancient unfixed pragma reminders" ) )

/*
 * CleanUpD3DHAL
 *
 * Notify the Direct3D driver using the ContextDestroyAll callbacks
 * that the given process has died so that it may cleanup any context
 * associated with that process.
 *
 * NOTE: This function is only invoked if we have Direct3D
 * support in the DirectDraw driver and if the process
 * terminates without cleaning up normally.
 *
 * I would call the ContextDestroyAll callback directly from here
 * instead of through this convoluted exported fn, but d3dhal.h
 * can't be included here because of the dependencies.
 */

void CleanUpD3DHAL(LPD3DHAL_CALLBACKS lpD3DHALCallbacks, DWORD pid, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl)
{
    D3DHALCleanUpProc lpD3DHALCleanUpProc;
    HINSTANCE   hD3DInstance;
    if (DDRAWILCL_DIRECTDRAW7 & pdrv_lcl->dwLocalFlags)
    {
         hD3DInstance = LoadLibrary( D3DDX7_DLLNAME );
	 DPF(4,"Calling %s in %s",D3DHALCLEANUP_PROCNAME,D3DDX7_DLLNAME);
    }
    else
    {
         hD3DInstance = LoadLibrary( D3D_DLLNAME );
	 DPF(4,"Calling %s in %s",D3DHALCLEANUP_PROCNAME,D3D_DLLNAME);
    }

    // Attempt to locate the cleanup entry point.
    if (0 != hD3DInstance)
    {
        lpD3DHALCleanUpProc = (D3DHALCleanUpProc)GetProcAddress( hD3DInstance,
							         D3DHALCLEANUP_PROCNAME );
        if( NULL == lpD3DHALCleanUpProc )
        {
	    // this is really either an internal error, or d3dim.dll is suddenly missing
	    DPF(0,"Error: can't find cleanup entry point %s in %s, driver's 3D resources won't be freed",D3DHALCLEANUP_PROCNAME,D3D_DLLNAME);
        }
        else
        {
            (*lpD3DHALCleanUpProc)( lpD3DHALCallbacks, pid );
        }
        FreeLibrary(hD3DInstance);
    }
}

#ifdef WIN95

/*
 * CurrentProcessCleanup
 *
 * make sure terminating process cleans up after itself...
 */
BOOL CurrentProcessCleanup( BOOL was_term )
{
    DWORD                       pid;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_link_int;
    BOOL                        rc;
    BOOL                        fD3DCleanedUp;

    ENTER_DDRAW();

    pid = GETCURRPID();
    pdrv_int = lpDriverObjectList;
    rc = FALSE;
    fD3DCleanedUp = FALSE;

    /*
     * run through each driver, looking for the current process handle
     * Delete all local objects created by this process.
     */
    while( pdrv_int != NULL )
    {
	pdrv_link_int = pdrv_int->lpLink;
	/*
	 * if we find the process, release it and remove it from list
	 */
	pdrv_lcl = pdrv_int->lpLcl;
	if( pdrv_lcl->dwProcessId == pid )
	{
	    DWORD       refcnt;

	    pdrv = pdrv_lcl->lpGbl;

            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 4, "Process %08lx still attached to driver 0x%p", pid, pdrv_int );
	    DPF( 5, "    Refcnt = %ld", pdrv_int->dwIntRefCnt );
	    if( pdrv != NULL )
	    {
		DPF( 5, "    DRV Refcnt = %ld", pdrv->dwRefCnt );
	    }

            // Clean up DX8
            #ifdef WIN95
                CleanupD3D8( pdrv, TRUE, pid);
            #endif

	    rc = TRUE;

	    /*
	     * D3D uses a bogus DDraw interface to create surfaces, which
	     * means that we AddRef the LCL and GBL, but since the INT is
	     * not in the lpDriverObjectList, we never release them.  The
	     * result is that LCL/GBLs are never released and this causes
	     * lots of problems (for example, we don't call DonExclusiveMode
	     * to turn off the 3DFX pass through).  If the process cleans up
	     * correctly, so does D3D, but if we cleanup on DDHELPs thread,
	     * D3D has already been unloaded.  The work-around is to
	     * determine if this is the last INT referncing the LCL and if
	     * the ref counts don't match, make the INT re count match the LCL.
	     */
	    if( dwHelperPid == GetCurrentProcessId() )
	    {
		LPDDRAWI_DIRECTDRAW_INT     pTemp_int;

		pTemp_int = lpDriverObjectList;
		while( pTemp_int != NULL )
		{
		    if( ( pTemp_int != pdrv_int ) &&
			( pTemp_int->lpLcl == pdrv_lcl ) )
		    {
			break;
		    }
		    pTemp_int = pTemp_int->lpLink;
		}
		if( pTemp_int == NULL )
		{
		    pdrv_int->dwIntRefCnt = pdrv_lcl->dwLocalRefCnt;
		}
	    }

	    /*
	     * punt process from any surfaces and palettes
	     */
	    if( pdrv != NULL )
	    {
#ifdef POSTPONED2
		ProcessSpriteCleanup( pdrv, pid );   // master sprite list
#endif //POSTPONED2
		ProcessSurfaceCleanup( pdrv, pid, NULL );
		ProcessPaletteCleanup( pdrv, pid, NULL );
		ProcessClipperCleanup( pdrv, pid, NULL );
		ProcessVideoPortCleanup( pdrv, pid, NULL );
	    }

	    /*
	     * Has the process terminated and a Direct3D driver
	     * object been queried off this driver object?
	     */
	    if( was_term && ( pdrv_lcl->pD3DIUnknown != NULL ) )
	    {
		/*
		 * Yes... so we need to do two things:
		 *
		 * 1) Simply discard the IUnknown interface pointer
		 *    for the Direct3D object as that object is now
		 *    gone (it was allocated by a local DLL in a
		 *    local heap of a process that is now gone).
		 *
		 * 2) If we have hardware 3D support and we have not
		 *    yet notified the driver of the death of this
		 *    process tell it now.
		 */
		DPF( 4, "Discarding Direct3D interface - process terminated" );
		pdrv_lcl->pD3DIUnknown = NULL;

		if( ( pdrv->lpD3DHALCallbacks != NULL ) && !fD3DCleanedUp )
		{
		    DPF( 4, "Notifying Direct3D driver of process termination" );
		    CleanUpD3DHAL( pdrv->lpD3DHALCallbacks, pid, pdrv_lcl);
		    fD3DCleanedUp = TRUE;
		}
	    }

	    /*
	     * now release the driver object
	     * If exclusive mode was held by this process, it will
	     * be relinquished when the local object is deleted.
	     */
	    refcnt = pdrv_int->dwIntRefCnt;
	    while( refcnt > 0 )
	    {
		DD_Release( (LPDIRECTDRAW) pdrv_int );
		refcnt--;
	    }
	}

	/*
	 * go to the next driver
	 */
	pdrv_int = pdrv_link_int;
    }

    /*
     * Release driver independent clippers owned by this process.
     */
    ProcessClipperCleanup( NULL, pid, NULL );

    /*
     * Remove any process entries from the window list.  They could be left
     * around if the window was subclassed.
     */
    CleanupWindowList( pid );

    LEAVE_DDRAW();
    DPF( 4, "Done with CurrentProcessCleanup, rc = %d", rc);
    return rc;

} /* CurrentProcessCleanup */

#endif //WIN95
/*
 * RemoveDriverFromList
 *
 * remove driver object from linked list of driver objects.
 * assumes DirectDraw lock is taken.
 */
void RemoveDriverFromList( LPDDRAWI_DIRECTDRAW_INT lpDD_int, BOOL final )
{
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int;
    LPDDRAWI_DIRECTDRAW_INT     pdlast_int;

    ENTER_DRIVERLISTCSECT();
    pdrv_int = lpDriverObjectList;
    pdlast_int = NULL;
    while( pdrv_int != NULL )
    {
	if( pdrv_int == lpDD_int )
	{
	    if( pdlast_int == NULL )
	    {
		lpDriverObjectList = pdrv_int->lpLink;
	    }
	    else
	    {
		pdlast_int->lpLink = pdrv_int->lpLink;
	    }
	    break;
	}
	pdlast_int = pdrv_int;
	pdrv_int = pdrv_int->lpLink;
    }
    #ifdef DEBUG
	if( pdrv_int == NULL )
	{
	    DPF( 3, "ERROR!! Could not find driver in global object list" );
	}
    #endif
    LEAVE_DRIVERLISTCSECT();

} /* RemoveDriverFromList */

/*
 * RemoveLocalFromList
 *
 * remove local object from linked list of local objects.
 * assumes DirectDraw lock is taken.
 */
void RemoveLocalFromList( LPDDRAWI_DIRECTDRAW_LCL this_lcl )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdlast_lcl;

    ENTER_DRIVERLISTCSECT();
    pdrv_lcl = lpDriverLocalList;
    pdlast_lcl = NULL;
    while( pdrv_lcl != NULL )
    {
	if( pdrv_lcl == this_lcl )
	{
	    if( pdlast_lcl == NULL )
	    {
		lpDriverLocalList = pdrv_lcl->lpLink;
	    }
	    else
	    {
		pdlast_lcl->lpLink = pdrv_lcl->lpLink;
	    }
	    break;
	}
	pdlast_lcl = pdrv_lcl;
	pdrv_lcl = pdrv_lcl->lpLink;
    }
    #ifdef DEBUG
	if( pdrv_lcl == NULL )
	{
	    DPF( 3, "ERROR!! Could not find driver local in global list" );
	}
    #endif
    LEAVE_DRIVERLISTCSECT();

} /* RemoveLocalFromList */

/*
 * doneDC
 */
void DD_DoneDC( HDC hdc_dd )
{
    if( hdc_dd != NULL )
    {
        // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF( 5, "DeleteDC 0x%p", hdc_dd );
	DeleteDC( hdc_dd );
	hdc_dd = NULL;
    }

} /* doneDC */

#undef DPF_MODNAME
#define DPF_MODNAME     "DirectDrawCreate"

// prototype for helinit
BOOL HELInit( LPDDRAWI_DIRECTDRAW_GBL pdrv, BOOL helonly );

/*
 * helInit
 */
BOOL helInit( LPDDRAWI_DIRECTDRAW_GBL pdrv, DWORD dwFlags, BOOL hel_only )
{

    if( (dwFlags & DDCREATE_HARDWAREONLY) )
    {
	return TRUE;
    }
    /*
     * get the HEL to fill in details:
     *
     * - dwHELDriverCaps
     * - dwHELStretchDriverCaps
     * - dwHELRopsSupported
     * - ddsHELCaps
     * - HELDD
     * - HELDDSurface
     * - HELDDPalette
     * - HELDDExeBuf
     */
    if( HELInit( pdrv, hel_only ) )
    {
	/*
	 * find the intersection of the driver and the HEL caps...
	 */
	pdrv->dwFlags |= DDRAWI_EMULATIONINITIALIZED;
	mergeHELCaps( pdrv );
    }
    else
    {
	DPF( 3, "HELInit failed" );
	pdrv->dwFlags |= DDRAWI_NOEMULATION;
    }

    return TRUE;

} /* helInit */

/*
 * createDC
 *
 * create a new DC given a device name.
 * doneDC() should be called to free DC
 *
 * the following are valid for device names:
 *
 *      DISPLAY      - the main display device via CreateDC("DISPLAY", ...)
 *                     this is the normal case.
 *
 *      foobar       - the foobar.drv via CreateDC("foobar", ...)
 *                     used for secondary displays listed in the registry
 *
 *      \\.\DisplayX - display device X via CreateDC(NULL,"\\.\DisplayX",...)
 *                     used on Memphis and NT5 for secondary displays
 *
 */
HDC DD_CreateDC( LPSTR pdrvname )
{
    HDC         hdc;
    UINT        u;

    DDASSERT( pdrvname != NULL );

#ifdef DEBUG
    if (pdrvname[0] == 0)
    {
	DPF( 3, "createDC() empty string!!!" );
	DebugBreak();
	return NULL;
    }
#endif

    #if defined(NT_FIX) || defined(WIN95)
	u = SetErrorMode( SEM_NOOPENFILEERRORBOX );
    #endif
    #ifdef WINNT
    	/*
	 * Note that DirectDraw refers to the driver for the primary monitor
	 * in a multimon system as "display", but NT uses "display" to refer
	 * to the desktop as a whole.  To handle this mismatch, we store
	 * NT's name for the primary monitor's driver in g_szPrimaryDisplay
	 * and substitute this name in place of "display" in our calls to NT.
	 */
        if ( GetSystemMetrics( SM_CMONITORS ) > 1 )
        {
	    if ( (_stricmp(pdrvname, DISPLAY_STR) == 0) )
	    {
	        if (g_szPrimaryDisplay[0] == '\0')
	        {
		    getPrimaryDisplayName();
	        }
	        pdrvname = g_szPrimaryDisplay;
	    }
        }
    #endif //WINNT

    DPF( 5, "createDC(%s)", pdrvname );

    if (pdrvname[0] == '\\' && pdrvname[1] == '\\' && pdrvname[2] == '.')
	hdc = CreateDC( NULL, pdrvname, NULL, NULL);
    else
	hdc = CreateDC( pdrvname, NULL, NULL, NULL);

    #if defined(NT_FIX) || defined(WIN95) //fix this error mode stuff
	SetErrorMode( u );
    #endif

    if (hdc == NULL)
    {
	DPF( 3, "createDC(%s) FAILED!", pdrvname );
    }

    return hdc;

} /* createDC */

/*
 * CreateFirstDC
 *
 * same as DD_CreateDC, except DDHELP is notified of the new driver.
 * used only durring
 */
static HDC DD_CreateFirstDC( LPSTR pdrvname )
{
    #ifdef WIN95
    if (pdrvname != NULL)
    {
	#ifndef WIN16_SEPARATE
	    LEAVE_DDRAW();
	#endif
	SignalNewDriver( pdrvname, TRUE );
	#ifndef WIN16_SEPARATE
	    ENTER_DDRAW();
	#endif
    }
    #endif

    return DD_CreateDC(pdrvname);

} /* createDC */


/*
 * strToGUID
 *
 * converts a string in the form xxxxxxxx-xxxx-xxxx-xx-xx-xx-xx-xx-xx-xx-xx
 * into a guid
 */
static BOOL strToGUID( LPSTR str, GUID * pguid )
{
    int         idx;
    LPSTR       ptr;
    LPSTR       next;
    DWORD       data;
    DWORD       mul;
    BYTE        ch;
    BOOL        done;

    idx = 0;
    done = FALSE;
    while( !done )
    {
	/*
	 * find the end of the current run of digits
	 */
	ptr = str;
	while( (*str) != '-' && (*str) != 0 )
	{
	    str++;
	}
	if( *str == 0 )
	{
	    done = TRUE;
	}
	else
	{
	    next = str+1;
	}

	/*
	 * scan backwards from the end of the string to the beginning,
	 * converting characters from hex chars to numbers as we go
	 */
	str--;
	mul = 1;
	data = 0;
	while( str >= ptr )
	{
	    ch = *str;
	    if( ch >= 'A' && ch <= 'F' )
	    {
		data += mul * (DWORD) (ch-'A'+10);
	    }
	    else if( ch >= 'a' && ch <= 'f' )
	    {
		data += mul * (DWORD) (ch-'a'+10);
	    }
	    else if( ch >= '0' && ch <= '9' )
	    {
		data += mul * (DWORD) (ch-'0');
	    }
	    else
	    {
		return FALSE;
	    }
	    mul *= 16;
	    str--;
	}

	/*
	 * stuff the current number into the guid
	 */
	switch( idx )
	{
	case 0:
	    pguid->Data1 = data;
	    break;
	case 1:
	    pguid->Data2 = (WORD) data;
	    break;
	case 2:
	    pguid->Data3 = (WORD) data;
	    break;
	default:
	    pguid->Data4[ idx-3 ] = (BYTE) data;
	    break;
	}

	/*
	 * did we find all 11 numbers?
	 */
	idx++;
	if( idx == 11 )
	{
	    if( done )
	    {
		return TRUE;
	    }
	    else
	    {
		return FALSE;
	    }
	}
	str = next;
    }
    return FALSE;

} /* strToGUID */

/*
 * getDriverNameFromGUID
 *
 * look up the name of a driver based on the interface id
 */
BOOL getDriverNameFromGUID( GUID *pguid, LPSTR pdrvname, BOOL *pisdisp, BOOL *pisprimary )
{
    DWORD       keyidx;
    HKEY        hkey;
    HKEY        hsubkey;
    char        keyname[256];
    DWORD       cb;
    DWORD       type;
    GUID        guid;

    *pisdisp = FALSE;
    *pdrvname = 0;

    /*
     * first check for a driver guid returned via EnumDisplayDevices.
     */
    if (pguid->Data1 >= DisplayGUID.Data1 &&
	pguid->Data1 <= DisplayGUID.Data1 + 32 &&
	memcmp(&pguid->Data2,&DisplayGUID.Data2,sizeof(GUID)-sizeof(DWORD))==0)
    {
	DISPLAY_DEVICEA dd;

	ZeroMemory(&dd, sizeof(dd));
	dd.cb = sizeof(dd);

	if (xxxEnumDisplayDevicesA(NULL, pguid->Data1 - DisplayGUID.Data1, &dd, 0)
        #ifdef WINNT
            && (dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)
        #endif
            )
	{
	    lstrcpy(pdrvname, dd.DeviceName);
	    if( dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE )
	    {
		*pisprimary = TRUE;
	    }
	    *pisdisp = TRUE;
	    return TRUE;
	}

	return FALSE;
    }

    if( RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDHW, &hkey ) )
    {
	DPF( 3, "No registry information for any drivers" );
	return FALSE;
    }
    keyidx = 0;

    /*
     * enumerate all subkeys under HKEY_LOCALMACHINE\Hardware\DirectDrawDrivers
     */
    while( !RegEnumKey( hkey, keyidx, keyname, sizeof( keyname ) ) )
    {
	if( strToGUID( keyname, &guid ) )
	{
	    if( !RegOpenKey( hkey, keyname, &hsubkey ) )
	    {
		if( IsEqualGUID( pguid, &guid ) )
		{
		    cb = MAX_PATH-1;
		    if( !RegQueryValueEx( hsubkey, REGSTR_KEY_DDHW_DRIVERNAME, NULL, &type,
				(CONST LPBYTE)pdrvname, &cb ) )
		    {
			if( type == REG_SZ )
			{
			    DPF( 5, "Found driver \"%s\"\n", pdrvname );
			    RegCloseKey( hsubkey );
			    RegCloseKey( hkey );
			    return TRUE;
			}
		    }
		    DPF_ERR( "Could not get driver name!" );
		    RegCloseKey( hsubkey );
		    RegCloseKey( hkey );
		    return FALSE;
		}
		RegCloseKey( hsubkey );
	    }
	}
	keyidx++;
    }
    RegCloseKey( hkey );
    return FALSE;

} /* getDriverNameFromGUID */

/*
 * NewDriverInterface
 *
 * contruct a new interface to an existing driver object
 */
LPVOID NewDriverInterface( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPVOID lpvtbl )
{
    LPDDRAWI_DIRECTDRAW_INT     pnew_int;
    LPDDRAWI_DIRECTDRAW_LCL     pnew_lcl;
    DWORD                       size;

    if( (lpvtbl == &ddCallbacks)       ||
	(lpvtbl == &ddUninitCallbacks) ||
	(lpvtbl == &dd2UninitCallbacks) ||
	(lpvtbl == &dd2Callbacks) ||
	(lpvtbl == &dd4UninitCallbacks) ||
//      (lpvtbl == &ddUninitNonDelegatingUnknownCallbacks) ||
	(lpvtbl == &dd4Callbacks) ||
	(lpvtbl == &dd7UninitCallbacks) ||
	(lpvtbl == &dd7Callbacks) )
    {
	size = sizeof( DDRAWI_DIRECTDRAW_LCL );
    }
    else
    {
	return NULL;
    }

    pnew_lcl = MemAlloc( size );
    if( NULL == pnew_lcl )
    {
	return NULL;
    }
    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 5, "***New local allocated 0x%p for global pdrv 0x%p", pnew_lcl, pdrv );

    pnew_int = MemAlloc( sizeof( DDRAWI_DIRECTDRAW_INT ) );
    if( NULL == pnew_int )
    {
	MemFree( pnew_lcl );
	return NULL;
    }
    /*
     * set up data
     */
    ENTER_DRIVERLISTCSECT();
    pnew_int->lpVtbl = lpvtbl;
    pnew_int->lpLcl = pnew_lcl;
    pnew_int->dwIntRefCnt = 1;
    pnew_int->lpLink = lpDriverObjectList;
    lpDriverObjectList = pnew_int;

    pnew_lcl->lpGbl = pdrv;
    pnew_lcl->dwLocalRefCnt = 1;
    pnew_lcl->dwProcessId = GetCurrentProcessId();
    pnew_lcl->hGammaCalibrator = (ULONG_PTR) INVALID_HANDLE_VALUE;
    pnew_lcl->lpGammaCalibrator = NULL;
#ifdef WIN95
    pnew_lcl->SurfaceHandleList.dwList=NULL;
    pnew_lcl->SurfaceHandleList.dwFreeList=0;
#endif  //WIN95
    pnew_lcl->lpLink = lpDriverLocalList;
    lpDriverLocalList = pnew_lcl;
    if( pdrv != NULL )
    {
	pnew_lcl->lpDDCB = pdrv->lpDDCBtmp;
	pnew_lcl->lpGbl->dwRefCnt++;
#ifdef WIN95
        pnew_lcl->dwPreferredMode = pdrv->dwModeIndex;
#else
        pnew_lcl->dmiPreferred = pdrv->dmiCurrent;
#endif
    }

    #ifdef WIN95
	/*
	 * NOTE: We no longer get the DirectSound VXD handle at this point.
	 * We not get initialize it in InternalDirectDrawCreate(). This works
	 * well as the only two places this code currently gets invoked are
	 * the class factory stuff and DirectDrawCreate(). In the case of the
	 * class factory stuff this means there will be no VXD handle until
	 * initialize is called. This is not a problem, however, as there
	 * is nothing you can do with the VXD handle until Initialize() is
	 * called.
	 */
	pnew_lcl->hDDVxd = (DWORD) INVALID_HANDLE_VALUE;
    #endif /* WIN95 */

    /*
     * We lazily evaluate the Direct3D interface. Also note that
     * the Direct3D IUnknown goes into the local DirectDraw object
     * rather than the global one as the Direct3D DLL is not shared.
     * Everyone gets their own copy.
     */
    pnew_lcl->hD3DInstance = NULL;
    pnew_lcl->pD3DIUnknown = NULL;
    LEAVE_DRIVERLISTCSECT();

    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF( 5, "New driver object created, interface ptr = 0x%p", pnew_int );
    return pnew_int;

} /* NewDriverInterface */


/*
 * FetchDirectDrawData
 *
 * Go get new HAL info...
 */
LPDDRAWI_DIRECTDRAW_GBL FetchDirectDrawData(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		BOOL reset,
		DWORD hInstance,
		HANDLE hDDVxd,
		char * szDrvName,
		DWORD dwDriverContext,
                LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{

	DWORD                           dw16BitVidmemInfo;
	DWORD                           dw32BitVidmemInfo;
	DDHALINFO                       ddhi;
	LPDDRAWI_DIRECTDRAW_GBL         newpdrv;
        BOOL                            bLoadedSecondary=FALSE;

	if( szDrvName == NULL )
	{
	    if ( pdrv == NULL )
	    {
		// This shouldn't happen
		DPF_ERR( "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:FetchDirectDrawData: Driver and Driver Name is NULL");
		DDASSERT( 0 );
		return 0;
	    }
	    szDrvName = pdrv->cDriverName;
	}
	if( pdrv != NULL && (pdrv->dwFlags & DDRAWI_NOHARDWARE) )
	{
	    HDC hdc;
	    // ATTENTION: why do this? Can't we just say pdrv->hdc instead of creating a dc??
	    hdc = DD_CreateDC( pdrv->cDriverName );
	    newpdrv = FakeDDCreateDriverObject( hdc, pdrv->cDriverName, pdrv, TRUE, hDDVxd );
	    if (newpdrv)
	    {
	       newpdrv->ddCaps.dwCaps2 |= DDCAPS2_CERTIFIED;
	       UpdateRectFromDevice( newpdrv );
	    }
	    DD_DoneDC( hdc );
	    return newpdrv;
	}
	else
	{
	    ZeroMemory(&ddhi, sizeof(ddhi));

	    if( pdrv != NULL )
	    {
		ddhi.hInstance = pdrv->hInstance;
	    }
	    else
	    {
		ddhi.hInstance = hInstance;
	    }

#if defined(WIN95)

	    ENTER_WIN16LOCK();
	    DD16_GetHALInfo( &ddhi );

	    if( ddhi.lpDDCallbacks != NULL )
	    {
		ddhi.lpDDCallbacks = MapSLFix( (DWORD) ddhi.lpDDCallbacks );
	    }
	    if( ddhi.lpDDSurfaceCallbacks != NULL )
	    {
		ddhi.lpDDSurfaceCallbacks = MapSLFix( (DWORD) ddhi.lpDDSurfaceCallbacks );
	    }
	    if( ddhi.lpDDPaletteCallbacks != NULL )
	    {
		ddhi.lpDDPaletteCallbacks = MapSLFix( (DWORD) ddhi.lpDDPaletteCallbacks );
	    }
	    if( ( ddhi.dwSize >= DDHALINFOSIZE_V2 ) && ( ddhi.lpDDExeBufCallbacks != NULL ) )
	    {
		ddhi.lpDDExeBufCallbacks = MapSLFix( (DWORD) ddhi.lpDDExeBufCallbacks );
	    }
	    if( ddhi.lpdwFourCC != NULL )
	    {
		ddhi.lpdwFourCC = MapSLFix( (DWORD) ddhi.lpdwFourCC );
	    }
	    if( ddhi.lpModeInfo != NULL )
	    {
		ddhi.lpModeInfo = MapSLFix( (DWORD) ddhi.lpModeInfo );
	    }
	    if( ddhi.vmiData.pvmList != NULL )
	    {
		dw16BitVidmemInfo = (DWORD) ddhi.vmiData.pvmList;
		ddhi.vmiData.pvmList = MapSLFix( (DWORD)dw16BitVidmemInfo );
		dw32BitVidmemInfo = (DWORD) ddhi.vmiData.pvmList;
	    }

            if ( ddhi.lpD3DGlobalDriverData && 	
                (ddhi.dwFlags & DDHALINFO_GETDRIVERINFOSET) && !reset)
            {
	        // this is a hack to Enforce D3DDEVCAPS_DRAWPRIMITIVES2 only on satackable drivers
	        // but not on Primary drivers as we are reluctant to force DDI revised
	        ddhi.lpD3DGlobalDriverData->hwCaps.dwDevCaps |= D3DDEVCAPS_DRAWPRIMITIVES2;
            }

	    /*
	     * Give a secondary driver (if any) a chance.
	     */
	    if (IsVGADevice(szDrvName))
	    {
		/*
		 * Only allow secondaries to hijack primary device
		 */
		bLoadedSecondary = loadSecondaryDriver( &ddhi );
	    }

#endif
            #ifdef WINNT
                /*
                 * This is necessary to make GetDriverInfo function on NT. The handle in pdrv-hDD is per-process,
                 * so we need to fetch it from the local object. If this is a create call, then pdrv and pdrv_lcl
                 * will be null, and DirectDrawObjectCreate will create the hDD for this driver/process pair.
                 * If this is not a create call then it's a reset call, and we can stuff the already created hDD
                 * into the global so that it can be passed into GetDriverInfo. (Yes, a hack).
                 */
                if (pdrv_lcl && pdrv)
                {
                    DDASSERT(reset == TRUE);
                    pdrv->hDD = pdrv_lcl->hDD;
                }
            #endif

            newpdrv = DirectDrawObjectCreate( &ddhi, reset, pdrv, hDDVxd, szDrvName, dwDriverContext, 
                pdrv_lcl ? pdrv_lcl->dwLocalFlags : 0);

	    if( newpdrv )
	    {
		// Is this a
		// Figure out the RECT for the device
		UpdateRectFromDevice( newpdrv );

                //Record if a secondary (PowerVR) was loaded
                if ( bLoadedSecondary )
                {
                    newpdrv->dwFlags |= DDRAWI_SECONDARYDRIVERLOADED;
                }
	    }
            #ifdef WINNT
                /*
                 * On NT, they can switch to and from 4bpp modes where DDraw
                 * can't be used.  If DirectDrawObjectCreate fails,
                 * set the mode index and clear out the caps and set
                 * dwModeIndex to unsupported so that it can't create or
                 * restore surfaces.
                 */
                if( pdrv != NULL)
                {
                    if( newpdrv )
                    {
                        pdrv->dwModeIndex = 0;
                    }
                    else
                    {
                        pdrv->dwModeIndex = DDUNSUPPORTEDMODE;
                        memset( &( pdrv->ddCaps ), 0, sizeof( DDCORECAPS ) );
                        pdrv->ddCaps.dwSize = sizeof( DDCORECAPS );
                        pdrv->ddCaps.dwCaps = DDCAPS_NOHARDWARE;
                    }
                }
            #endif

	    /*
	     * Tell the HEL a mode has changed (possibly externally)
	     */
	    ResetBITMAPINFO(newpdrv);
	    #ifdef WINNT
		//GetCurrentMode will have allocated mem for this. If it's null, it hasn't.
		MemFree( ddhi.lpModeInfo );
	    #endif

	    #if defined(WIN95)
		LEAVE_WIN16LOCK();
	    #endif
	}
    return newpdrv;

} /* FetchDirectDrawData */

/*
 * DirectDrawSupported
 */
BOOL DirectDrawSupported( BOOL bDisplayMessage )
{
    HDC         hdc;
    unsigned    u;

    hdc = GetDC( NULL );
    u = GetDeviceCaps( hdc, BITSPIXEL ) * GetDeviceCaps( hdc, PLANES );
    ReleaseDC( NULL, hdc );

    if(( u < 8 ) && bDisplayMessage)
    {
	DPF( 0, "DirectDraw does not work in less than 8bpp modes" );
        #ifdef WIN95
	    DirectDrawMsg(MAKEINTRESOURCE(IDS_DONTWORK_BPP));
        #endif
	return FALSE;
    }
    return TRUE;

} /* DirectDrawSupported */

/*
 * DirectDrawCreate
 *
 * One of the two end-user API exported from DDRAW.DLL.
 * Creates the DIRECTDRAW object.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawCreate"

HRESULT WINAPI DirectDrawCreate(
		GUID FAR * lpGUID,
		LPDIRECTDRAW FAR *lplpDD,
		IUnknown FAR *pUnkOuter )
{
    HRESULT hr;
    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(2,A,"ENTERAPI: DirectDrawCreate");
    DPF(3,A,"   GUID *: 0x%p, LPLPDD: 0x%p, pUnkOuter: 0x%p", lpGUID, lplpDD, pUnkOuter);

    if (pUnkOuter )
    {
	return CLASS_E_NOAGGREGATION;
    }

    bReloadReg = FALSE;
    if( GetProfileInt("DirectDraw","reloadreg",0) )
    {
	bReloadReg = TRUE;
	DPF( 3, "Reload registry each time" );
    }
    hr = InternalDirectDrawCreate( lpGUID, lplpDD, NULL, 0UL, NULL );

#ifdef POSTPONED
    /*
     * Fix up the owning unknown for this object
     */
    if (hr == DD_OK && *lplpDD)
    {
	LPDDRAWI_DIRECTDRAW_INT this_int = (LPDDRAWI_DIRECTDRAW_INT)*lplpDD;
	if (pUnkOuter)
	{
	    this_int->lpLcl->pUnkOuter = pUnkOuter;
	}
	else
	{
	    this_int->lpLcl->pUnkOuter = (IUnknown*) &NonDelegatingIUnknownInterface;
	}
    }
#endif

#ifdef DEBUG
    if (hr == DD_OK)
	/*
	 * DD_OK implies lplpDD must be a valid pointer, so can't AV.
	 */
        // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	DPF(3,A,"   DirectDrawCreate succeeds, and returns ddraw pointer 0x%p", *lplpDD);
    else
	DPF_APIRETURNS(hr);
#endif //debug

    return hr;

} /* DirectDrawCreate */

/*
 * DirectDrawCreateEx
 *
 * One of the two end-user API exported from DDRAW.DLL.
 * Creates the DIRECTDRAW object.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawCreateEx"

HRESULT WINAPI DirectDrawCreateEx(
		LPGUID rGuid,
		LPVOID  *lplpDD,
                REFIID  iid,
		IUnknown FAR *pUnkOuter )
{
    HRESULT hr;
    LPDIRECTDRAW    lpDD1;
    DPF(2,A,"ENTERAPI: DirectDrawCreateEx");
    // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
    DPF(3,A,"rGuid: 0x%p, LPLPDD: 0x%p, pUnkOuter: 0x%p", rGuid, lplpDD, pUnkOuter);

    if (pUnkOuter )
    {
	return CLASS_E_NOAGGREGATION;
    }
    if ( rGuid != NULL )
    {
        if ( !VALID_IID_PTR( rGuid ) )
        {
            DPF_ERR( "GUID reference is invalid" );
            return DDERR_INVALIDPARAMS;
        }
    }
    if (!IsEqualIID(iid, &IID_IDirectDraw7 ) )
    {
	DPF_ERR( "only IID_IDirectDraw7 is supported" );
	return DDERR_INVALIDPARAMS;
    }

    bReloadReg = FALSE;
    if( GetProfileInt("DirectDraw","reloadreg",0) )
    {
	bReloadReg = TRUE;
	DPF( 3, "Reload registry each time" );
    }
    hr = InternalDirectDrawCreate((GUID FAR *)rGuid,&lpDD1, NULL, DDRAWILCL_DIRECTDRAW7, NULL );

#ifdef POSTPONED
    /*
     * Fix up the owning unknown for this object
     */
    if (hr == DD_OK && lpDD1)
    {
	LPDDRAWI_DIRECTDRAW_INT this_int = (LPDDRAWI_DIRECTDRAW_INT)lpDD1;
	if (pUnkOuter)
	{
	    this_int->lpLcl->pUnkOuter = pUnkOuter;
	}
	else
	{
	    this_int->lpLcl->pUnkOuter = (IUnknown*) &NonDelegatingIUnknownInterface;
	}
    }
#endif
    if (DD_OK != hr)
    {
        *lplpDD=NULL;
    }
    if (hr == DD_OK)
    {
	/*
	 * DD_OK implies lpDD1 must be a valid pointer, so can't AV.
	 */
        // Now QI for the IDirectDraw7 interface
        hr=lpDD1->lpVtbl->QueryInterface(lpDD1,&IID_IDirectDraw7,lplpDD);
        lpDD1->lpVtbl->Release(lpDD1);
#ifdef DEBUG
        if (lpDD1)
        {
            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF(3,A,"   DirectDrawCreateEx succeeds, and returns ddraw pointer 0x%p", *lplpDD);
        }
#endif //debug
    }
    else
    {
	DPF_APIRETURNS(hr);
    }

    return hr;

} /* DirectDrawCreateEx */

/*
 * getDriverInterface
 */
static LPDDRAWI_DIRECTDRAW_INT getDriverInterface(
		LPDDRAWI_DIRECTDRAW_INT pnew_int,
		LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;

    if( pnew_int != NULL )
    {
	/*
	 * an interface was already created, so just assign the
	 * global data pointer and initialize a few things
	 */
	DPF( 4, "Interface pointer already exists!" );
	pdrv_lcl = pnew_int->lpLcl;
	pdrv_lcl->lpGbl = pdrv;
	pdrv_lcl->lpDDCB = pdrv->lpDDCBtmp;
#ifdef WIN95
        pdrv_lcl->dwPreferredMode = pdrv->dwModeIndex;
#else
        pdrv_lcl->dmiPreferred = pdrv->dmiCurrent;
#endif
	pdrv->dwRefCnt += pdrv_lcl->dwLocalRefCnt;
    }
    else
    {
	pnew_int = NewDriverInterface( pdrv, &ddCallbacks );
    }
    return pnew_int;

} /* getDriverInterface */


// Utility function that tells us if there is more than
// one display device in the system.  (We count all devices,
// regardless of whether they are attached to the desktop.)
BOOL IsMultiMonitor(void)
{
    int i, n;

    // Each loop below enumerates one display device.
    for (i = 0, n = 0; ; i++)
    {
	DISPLAY_DEVICEA dd;

	// Zero the memory of the DISPLAY_DEVICE struct between calls to
	// EnumDisplayDevices
	ZeroMemory(&dd, sizeof(dd));
	dd.cb = sizeof(dd);
	if (!xxxEnumDisplayDevicesA(NULL, i, &dd, 0))
	{
    	    break;   // no more devices to enumerate
	}
	if (dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER)
	{
    	    continue;	// not a real hardware display driver
	}
	// We're just trying to count the number of display devices in the
	// system and see if there is more than one.
	if (++n > 1)
	{
	    return TRUE;   // multiple display devices
	}
    }

    return FALSE;  // single display device
}


extern DWORD HackMeBaby( void );

BOOL fDoesGDI(HDC hdc)
{
    //
    // the 3Dfx driver always return 1 to every thing
    // verify GetNearest()  color works.
    //
    BOOL b = GetNearestColor(hdc, 0x000000) == 0x000000 &&
	     GetNearestColor(hdc, 0xFFFFFF) == 0xFFFFFF;
    if(b)
    {
	DPF(3,"Driver is a GDI driver");
    }

    return b;
}

/*
 * IsAttachedToDesktop
 *
 * DCI is hardwired to the primary display which means it can't
 * be used on a multi-mon system.  Usually GDI disables it for
 * us, but it does not when there are two monitors and only one
 * of them uses the desktop.  We'd still like to use DCI for
 * the desktop in this case, but we can't use it if the monitor
 * is not attached to the desktop.  That is why this function exists.
 */
BOOL IsAttachedToDesktop( LPGUID lpGuid )
{
    DWORD       n;
    GUID        guid;
    DISPLAY_DEVICEA dd;

    if( !IsMultiMonitor() )
    {
	return TRUE;
    }

    /*
     * Assume that the primary is always attached
     */
    if( (lpGuid == (GUID *) DDCREATE_EMULATIONONLY) ||
	(lpGuid == (GUID *) DDCREATE_HARDWAREONLY) ||
	(lpGuid == NULL) ||
	(IsEqualGUID( lpGuid, &GUID_NULL) ) )
    {
	return TRUE;
    }

    ZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(dd);
    for( n=0; xxxEnumDisplayDevicesA( NULL, n, &dd, 0 ); n++ )
    {
	guid = DisplayGUID;
	guid.Data1 += n;

	if( IsEqualIID( lpGuid, &guid) )
	{
	    if( dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP )
	    {
		return TRUE;
	    }
	    else
	    {
		return FALSE;
	    }
	}
	ZeroMemory( &dd, sizeof(dd) );
	dd.cb = sizeof(dd);
    }

    return TRUE;

} /* IsAttachedToDesktop */

/*
 * Functions to dynamically link against exports we need in user32 on
 * older OSes
 */
//These statics will be per-process, cuz it's outside the shared section
typedef BOOL (WINAPI * LPENUMMONITORS) (HDC, LPRECT, MONITORENUMPROC, LPARAM);
typedef BOOL (WINAPI * LPGETMONINFO) (HMONITOR, MONITORINFO *);
typedef BOOL (WINAPI * LPISDEBUG) (void);
static LPISDEBUG pIsDebuggerPresent = 0;
static LPENUMMONITORS pEnumMonitors = 0;
static LPGETMONINFO pGetMonitorInfo = 0;
static BOOL bTriedToGetProcAlready = FALSE;

BOOL DynamicLinkToOS(void)
{
    if (1) //!pEnumMonitors)
    {
	HMODULE hUser32;
	HMODULE hKernel32;

	if (0) //bTriedToGetProcAlready)
	    return FALSE;

	bTriedToGetProcAlready = TRUE;

	hUser32 = GetModuleHandle(TEXT("USER32"));
	pEnumMonitors = (LPENUMMONITORS) GetProcAddress(hUser32,"EnumDisplayMonitors");
	pGetMonitorInfo = (LPGETMONINFO) GetProcAddress(hUser32,"GetMonitorInfoA");

	hKernel32 = GetModuleHandle(TEXT("KERNEL32"));
	pIsDebuggerPresent = (LPISDEBUG) GetProcAddress(hKernel32,"IsDebuggerPresent");

	if (!pEnumMonitors || !pGetMonitorInfo || !pIsDebuggerPresent)
	{
	    DPF(3,"Failed to get proc addresses");
	    return FALSE;
	}
    }

    DDASSERT(pEnumMonitors);
    DDASSERT(pGetMonitorInfo);
    DDASSERT(pEnumMonitors);

    return TRUE;
}

BOOL InternalGetMonitorInfo(HMONITOR hMon, MONITORINFO *lpInfo)
{
    DynamicLinkToOS();

    if (!pGetMonitorInfo)
	return FALSE;

    return pGetMonitorInfo(hMon, lpInfo);
}

typedef struct
{
    LPSTR       pName;
    HMONITOR    hMon;
} CALLBACKSTRUCT, * LPCALLBACKSTRUCT;


BOOL InternalEnumMonitors(MONITORENUMPROC proc, LPCALLBACKSTRUCT lp)
{
    DynamicLinkToOS();

    if (!pEnumMonitors)
	return FALSE;

    pEnumMonitors(NULL,NULL,proc,(LPARAM)lp);

    return TRUE;
}
/*
 * InternalIsDebuggerPresent
 * A little helper so that this runtime runs against older OSes
 */
BOOL InternalIsDebuggerPresent(void)
{
    DynamicLinkToOS();

    if (!pIsDebuggerPresent)
	return FALSE;

    return pIsDebuggerPresent();
}

//
// getPrimaryDisplayName
//

void getPrimaryDisplayName(void)
{
	DISPLAY_DEVICE dd;
	int i;

	ZeroMemory(&dd, sizeof dd);
	dd.cb = sizeof dd;

	for (i = 0; xxxEnumDisplayDevicesA(NULL, i, &dd, 0); ++i)
	{
		if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
		{
			lstrcpyn(g_szPrimaryDisplay, dd.DeviceName, sizeof g_szPrimaryDisplay);
			return;
		}
	}

	lstrcpy(g_szPrimaryDisplay, DISPLAY_STR);
}

/*
 * InternalDirectDrawCreate
 */
HRESULT InternalDirectDrawCreate(
		GUID * lpGUID,
		LPDIRECTDRAW *lplpDD,
		LPDDRAWI_DIRECTDRAW_INT pnew_int,
		DWORD dwCallFlags,
                char * pDeviceName)
{
    DCICMD                      cmd;
    UINT                        u;
    int                         rc;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    LPDDRAWI_DIRECTDRAW_LCL     pdrv_lcl;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int;
    LPSTR                       pdrvname;
    HDC                         hdc_dd;
    BOOL                        isdispdrv;
    BOOL                        hel_only;
    DWORD                       dwFlags;
    char                        drvname[MAX_PATH];
    DWORD                       pid;
    HKEY                        hkey;
    DWORD                       hackflags;
#ifdef WIN95
    int                         halver;
#endif
    HANDLE                      hDDVxd;
    BOOL                        bIsPrimary;
    BOOL                        bExplicitMonitor = FALSE;
    ULONG_PTR                	hDD;

    #ifndef DX_FINAL_RELEASE
	#pragma message( REMIND( "Remove time bomb for final!" ))
	{
	    SYSTEMTIME  st;
		TCHAR	tstrText[MAX_PATH];
		TCHAR	tstrTitle[MAX_PATH];

	    GetSystemTime( &st );

	    if( ( st.wYear > DX_EXPIRE_YEAR ) ||
		( ( st.wYear == DX_EXPIRE_YEAR ) &&
		  ( ( st.wMonth > DX_EXPIRE_MONTH ) || ( ( st.wMonth == DX_EXPIRE_MONTH ) && ( st.wDay >= DX_EXPIRE_DAY ) ) ) ) )
	    {
		
		LoadString( hModule, IDS_TIME_BOMB, tstrText, MAX_PATH);
		LoadString( hModule, IDS_TIME_BOMB_TITLE, tstrTitle, MAX_PATH);

		if( 0 == MessageBox( NULL, tstrText, tstrTitle, MB_OK) )
		{
		    DPF( 0, "DirectDraw Beta Expired. Please Update" );
		    *lplpDD = (LPDIRECTDRAW) NULL;
		    return DDERR_GENERIC;
		}
	    }
	}
    #endif //DX_FINAL_RELEASE

    /*
     * validate parameters
     */
    if( !VALIDEX_PTR_PTR( lplpDD ) )
    {
	DPF_ERR( "Invalid lplpDD" );
	return DDERR_INVALIDPARAMS;
    }
    *lplpDD = (LPDIRECTDRAW) NULL;

    /*
     * check for < 8 bpp and disallow.
     */
    if( !DirectDrawSupported(!(dwCallFlags & DDRAWILCL_DIRECTDRAW8)) )
    {
	return DDERR_NODIRECTDRAWSUPPORT;
    }



    ENTER_CSDDC();
    ENTER_DDRAW();

    hackflags = HackMeBaby();

    DPF( 5, "DirectDrawCreate: pid = %08lx", GETCURRPID() );

    /*
     * pull in registry values
     */
    DPF( 4, "Reading Registry" );
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hkey ) )
    {
	DWORD   type;
	DWORD   value;
	DWORD   cb;
	cb = sizeof( value );
	dwRegFlags &= ~(DDRAW_REGFLAGS_MODEXONLY       |
			DDRAW_REGFLAGS_EMULATIONONLY   |
			DDRAW_REGFLAGS_SHOWFRAMERATE   |
			DDRAW_REGFLAGS_ENABLEPRINTSCRN |
			DDRAW_REGFLAGS_DISABLEWIDESURF |
			DDRAW_REGFLAGS_NODDSCAPSINDDSD |
			DDRAW_REGFLAGS_DISABLEMMX      |
                        DDRAW_REGFLAGS_FORCEREFRESHRATE |
			DDRAW_REGFLAGS_DISABLEAGPSUPPORT);
	dwRegFlags &= ~DDRAW_REGFLAGS_AGPPOLICYMAXBYTES;
#ifndef WINNT
	#ifdef DEBUG
	    dwAGPPolicyCommitDelta = DEFAULT_AGP_COMMIT_DELTA;
	#endif /* DEBUG */
#endif
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_MODEXONLY, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    ModeXOnly: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_MODEXONLY;
	    }
	}
	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_EMULATIONONLY, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    EmulationOnly: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_EMULATIONONLY;
	    }
	}
	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_SHOWFRAMERATE, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    ShowFrameRate: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_SHOWFRAMERATE;
	    }
	}
	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_ENABLEPRINTSCRN, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    EnablePrintScreen: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_ENABLEPRINTSCRN;
	    }
	}
	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_FORCEAGPSUPPORT, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    ForceAGPSupport: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_FORCEAGPSUPPORT;
	    }
	}
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEAGPSUPPORT, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    DisableAGPSupport: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_DISABLEAGPSUPPORT;
	    }
	}
	cb = sizeof( value );
#ifdef WIN95
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_AGPPOLICYMAXPAGES, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    AGPPolicyMaxPages: %d", value );
	    dwRegFlags |= DDRAW_REGFLAGS_AGPPOLICYMAXBYTES;
	    dwAGPPolicyMaxBytes = value * 4096;
	}
	#ifdef DEBUG
	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_AGPPOLICYCOMMITDELTA, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
		DPF( 2, "    AGPPolicyCommitDelta: %d", value );
		dwAGPPolicyCommitDelta = value;
	    }
	#endif /* DEBUG */
#endif

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEMMX, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    DisableMMX: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_DISABLEMMX;
	    }
	}

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_NODDSCAPSINDDSD, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    Disable ddscaps in DDSURFACEDESC: %d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_NODDSCAPSINDDSD;
	    }
	}

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEWIDERSURFACES, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    DisableWiderSurfaces:%d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_DISABLEWIDESURF;
	    }
	}

        cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_D3D_USENONLOCALVIDMEM, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    UseNonLocalVidmem:%d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_USENONLOCALVIDMEM;
	    }
	}

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_FORCEREFRESHRATE, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, "    ForceRefreshRate:%d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_FORCEREFRESHRATE;
                dwForceRefreshRate = value;
	    }
	}

	#ifdef DEBUG
	    /*
	     * NOSYSLOCK (No Win16 locking) control flags. DEBUG only.
	     */
	    dwRegFlags &= ~(DDRAW_REGFLAGS_DISABLENOSYSLOCK | DDRAW_REGFLAGS_FORCENOSYSLOCK | DDRAW_REGFLAGS_DISABLEINACTIVATE);

	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLENOSYSLOCK, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
		DPF( 2, "    DisableNoSysLock:%d", value );
		if( value )
		{
		    dwRegFlags |= DDRAW_REGFLAGS_DISABLENOSYSLOCK;
		}
	    }

	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_FORCENOSYSLOCK, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
		DPF( 2, "    ForceNoSysLock:%d", value );
		if( value )
		{
		    dwRegFlags |= DDRAW_REGFLAGS_FORCENOSYSLOCK;
		}
	    }
	    if( ( dwRegFlags & DDRAW_REGFLAGS_DISABLENOSYSLOCK ) &&
		( dwRegFlags & DDRAW_REGFLAGS_FORCENOSYSLOCK ) )
	    {
		DPF( 0, "Attempt to both disable and force NOSYSLOCK on locks. Ignoring both" );
		dwRegFlags &= ~(DDRAW_REGFLAGS_DISABLENOSYSLOCK | DDRAW_REGFLAGS_FORCENOSYSLOCK);
	    }

	    /*
	     * Hack to allow multi-mon debugging w/o minimizing the exclusive
	     * mode app when it gets a WM_ACTIVATEAPP msg.  We only do this
	     * in the debug version.
	     */
	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEINACTIVATE, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
		DPF( 2, "    DisableInactivate:%d", value );
		if( value && InternalIsDebuggerPresent() )
		{
		    dwRegFlags |= DDRAW_REGFLAGS_DISABLEINACTIVATE;
		}
	    }

	#endif /* DEBUG */
	RegCloseKey(hkey);
    }
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, RESPATH_D3D, &hkey ) )
    {
	DWORD   type;
	DWORD   value;
	DWORD   cb;
	cb = sizeof( value );
	dwRegFlags &= ~DDRAW_REGFLAGS_FLIPNONVSYNC;
	if( !RegQueryValueEx( hkey, REGSTR_VAL_D3D_FLIPNOVSYNC, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    DPF( 2, REGSTR_VAL_D3D_FLIPNOVSYNC" :%d", value );
	    if( value )
	    {
		dwRegFlags |= DDRAW_REGFLAGS_FLIPNONVSYNC;
	    }
	}
	RegCloseKey(hkey);
    }
    hdc_dd = NULL;
    hDD = 0;
    dwFlags = 0;

    //
    // Get the primary display name, which will usually be something like
    // \\.\Display1 and in some cases may be \\.\Display1\Unit0. We only
    // do this one time, and store it globally. On Win98, the global name
    // will be shared between all processes, and on NT5, each process will
    // have its own copy. Also, note that the primary device name may change
    // on NT5; we need to look into this.
    //

    if (g_szPrimaryDisplay[0] == '\0')
    {
	    getPrimaryDisplayName();
    }

    /*
     * any special cases?
     */
    bIsPrimary = FALSE;
    isdispdrv = FALSE;
    if( dwRegFlags & DDRAW_REGFLAGS_EMULATIONONLY )
    {
        DWORD cMonitors = GetSystemMetrics( SM_CMONITORS );

	dwFlags |= DDCREATE_EMULATIONONLY;
	if( cMonitors <= 1 )
	{
	    // For compatibility with pre-multimon versions of DDraw
	    bIsPrimary = TRUE;
	}
    }
    if( pDeviceName == NULL)
    {
        if( lpGUID == (GUID *) DDCREATE_EMULATIONONLY )
        {
	    dwFlags |= DDCREATE_EMULATIONONLY;
	    bIsPrimary = TRUE;
        }
        else if( lpGUID == NULL )
        {
	    bIsPrimary = TRUE;
        }
        else if( lpGUID == (GUID *) DDCREATE_HARDWAREONLY )
        {
	    dwFlags |= DDCREATE_HARDWAREONLY;
	    bIsPrimary = TRUE;
        }
        if (bIsPrimary)
        {
	    lpGUID = (GUID *) &GUID_NULL;   // primary monitor
        }
        else if( !VALIDEX_GUID_PTR( lpGUID ) )
        {
	    DPF_ERR( "Invalid GUID passed in" );
	    LEAVE_DDRAW();
	    LEAVE_CSDDC();
	    return DDERR_INVALIDPARAMS;
        }
        if( IsEqualGUID( lpGUID, &GUID_NULL ) )
        {
	    pdrvname = DISPLAY_STR;	    // "display"
	    isdispdrv = TRUE;
	    bIsPrimary = TRUE;
        }
        else
        {
	    if( !getDriverNameFromGUID( lpGUID, drvname, &isdispdrv, &bIsPrimary ) )
	    {
	        DPF_ERR( "Invalid GUID for driver" );
	        LEAVE_DDRAW();
	        LEAVE_CSDDC();
	        return DDERR_INVALIDDIRECTDRAWGUID;
	    }
	    pdrvname = drvname;
        }
    }
    else
    {
        pdrvname = pDeviceName;
    }

    if ((ULONG_PTR)pdrvname != (ULONG_PTR)DISPLAY_STR)
    {
	bExplicitMonitor = TRUE;

	if (_stricmp(pdrvname, g_szPrimaryDisplay) == 0)
	{
	    pdrvname = DISPLAY_STR;
	}
    }

    pid = GETCURRPID();

    #ifdef WIN95
	/*
	 * We need to ensure that DDHELP has a handle to the DirectX VXD
	 * that it can use when creating, freeing or mapping virtual memory
	 * aliases or AGP heaps on mode switches or cleanups.
	 */
	if( INVALID_HANDLE_VALUE == hHelperDDVxd )
	{
	    hHelperDDVxd = HelperGetDDVxd();
	    if( INVALID_HANDLE_VALUE == hHelperDDVxd )
	    {
		DPF_ERR( "DDHELP could not load the DirectX VXD" );
		LEAVE_DDRAW();
		LEAVE_CSDDC();
		return DDERR_GENERIC;
	    }
	}

	/*
	 * Create a handle for VXD communication. We will use this for
	 * alias construction in this function and we will later store
	 * this in the local object for later alias manipulation and
	 * page locking purposes.
	 */
	hDDVxd = GetDXVxdHandle();
	if( INVALID_HANDLE_VALUE == hDDVxd )
	{
	    DPF_ERR( "Unable to open the DirectX VXD" );
	    LEAVE_DDRAW();
	    LEAVE_CSDDC();
	    return DDERR_GENERIC;
	}
    #else /* WIN95 */
	hDDVxd = INVALID_HANDLE_VALUE;
    #endif /* WIN95 */

    /*
     * run the driver list, looking for one that already exists.  We used to run
     * the interface list, but thanks to D3D it is possible for all locals to exist
     * w/o anything in the interface list.
     */
    pdrv_lcl = lpDriverLocalList;
    while( pdrv_lcl != NULL )
    {
	pdrv = pdrv_lcl->lpGbl;
	if( pdrv != NULL )
	{
	    if( !_stricmp( pdrv->cDriverName, pdrvname ) )
	    {
		// If they asked for hardware; then don't accept the
		// emulated driver
		if( !(dwFlags & DDCREATE_EMULATIONONLY) &&
		    !(pdrv->dwFlags & DDRAWI_NOHARDWARE) )
		{
		    DPF( 2, "Driver \"%s\" found for hardware", pdrvname );
		    break;
		}
		// If they asked for emulation; then don't accept the
		// hardware driver
		if( (dwFlags & DDCREATE_EMULATIONONLY) &&
		    (pdrv->dwFlags & DDRAWI_NOHARDWARE) )
		{
		    DPF( 2, "Driver \"%s\" found for emulation", pdrvname );
		    break;
		}
		// Compatibility: on single monitor systems take whatever
		// we got. (This is what we did in DX3)
		if( pdrv->cMonitors <= 1 )
		{
		    DPF( 2, "Driver \"%s\" found", pdrvname );
		    break;
		}
	    }
	}
	pdrv_lcl = pdrv_lcl->lpLink;
    }

    /*
     * if driver object already exists, get emulation layer if needed,
     * create a new interface to it and return
     */
    if( pdrv_lcl != NULL )
    {
	LPDDRAWI_DIRECTDRAW_LCL tmp_lcl;

	// This is the hdc we need to release if something
	// goes wrong; since we are sometimes
	// sharing an HDC with an existing LCL, we must
	// be careful not to release it while it is still
	// in use.
	HDC hdcCleanup = NULL;
	/*
	 * see if the current process has attached to this driver before...
	 */
	tmp_lcl = lpDriverLocalList;
	while( tmp_lcl != NULL )
	{
	    if( tmp_lcl->dwProcessId == pid &&
		    tmp_lcl->lpGbl == pdrv)
	    {
		break;
	    }
	    tmp_lcl = tmp_lcl->lpLink;
	}
	if( tmp_lcl == NULL )
	{
	    hdc_dd = NULL;
	}
	else
	{
	    // We found the process/driver pair we were looking for.
	    hdc_dd = (HDC) tmp_lcl->hDC;
	    DDASSERT(hdc_dd != 0);
	    hDD = tmp_lcl->hDD;
	}

	/*
	 * we need a new DC if this is a new process/driver pair...
	 */
	if( hdc_dd == NULL )
	{
	    DWORD       flags;
	    flags = pdrv->dwFlags;
	    hdc_dd = DD_CreateFirstDC( pdrvname );
	    if( hdc_dd == NULL )
	    {
		DPF_ERR( "Could not get a DC for the driver" );
		CLOSEVXD( hDDVxd );
		LEAVE_DDRAW();
		LEAVE_CSDDC();
		/* GEE: decided this error was rare enough to be left generic */
		return DDERR_GENERIC;
	    }

	    if (!(pdrv->dwFlags & DDRAWI_DISPLAYDRV))
	    {
		if (fDoesGDI(hdc_dd))
		{
		    pdrv->dwFlags |= DDRAWI_GDIDRV;
		}
		else
		{
		    pdrv->dwFlags &= ~DDRAWI_GDIDRV;
		}
	    }

	    // We need to free it if something goes wrong
	    hdcCleanup = hdc_dd;
	}

	/*
	 * Set up emulation for display and non-display drivers
	 */
	if( dwFlags & DDCREATE_EMULATIONONLY )
	{
	    if( !(pdrv->dwFlags & DDRAWI_NOHARDWARE) )
	    {
		DD_DoneDC(hdcCleanup);
		DPF_ERR( "EMULATIONONLY requested, but driver exists and has hardware" );
		CLOSEVXD( hDDVxd );
		LEAVE_DDRAW();
		LEAVE_CSDDC();
		/* GEE: Why do we fail emulation only calls just because we have a driver? */
		return DDERR_GENERIC;
	    }
	}

	/*
	 * we will need to load the emulation layer...
	 */
	if( !(pdrv->dwFlags & DDRAWI_NOEMULATION) &&
	    !(pdrv->dwFlags & DDRAWI_EMULATIONINITIALIZED ) )
	{
	    capsInit( pdrv );
	    hel_only = ((dwFlags & DDCREATE_EMULATIONONLY) != 0);
	    if( !helInit( pdrv, dwFlags, hel_only ) )
	    {
		DD_DoneDC(hdcCleanup);
		DPF_ERR( "HEL initialization failed" );
		CLOSEVXD( hDDVxd );
		LEAVE_DDRAW();
		LEAVE_CSDDC();
		/* GEE: HEL can only fail in v1 for lack of memory */
		return DDERR_GENERIC;
	    }
	}

	pdrv_int = getDriverInterface( pnew_int, pdrv );
	if( pdrv_int == NULL )
	{
	    DD_DoneDC(hdcCleanup);
	    DPF_ERR( "No memory for driver callbacks." );
	    CLOSEVXD( hDDVxd );
	    LEAVE_DDRAW();
	    LEAVE_CSDDC();
	    return DDERR_OUTOFMEMORY;
	}
	pdrv_lcl = pdrv_int->lpLcl;

	pdrv_lcl->dwAppHackFlags = hackflags;
	#ifdef DEBUG
	    if( dwRegFlags & DDRAW_REGFLAGS_DISABLEINACTIVATE )
	    {
		pdrv_lcl->dwLocalFlags |= DDRAWILCL_DISABLEINACTIVATE;
	    }
	#endif
	if( IsAttachedToDesktop( lpGUID ) )
	{
	    pdrv->dwFlags |= DDRAWI_ATTACHEDTODESKTOP;
	}
	if (bExplicitMonitor)
	{
		pdrv_lcl->dwLocalFlags |= DDRAWILCL_EXPLICITMONITOR;
	}

        pdrv_lcl->dwLocalFlags |= dwCallFlags;

	pdrv_lcl->hDDVxd = (ULONG_PTR) hDDVxd;

	#ifdef WIN95
	    if( hdcCleanup )
	    {
		// If we had to create a DC from
		// scratch then we need to mark it
		// private so that it will be never
		// be deleted out from under us
		DDASSERT( hdcCleanup == hdc_dd );
		DD16_MakeObjectPrivate( hdc_dd, TRUE );
	    }
	#endif
	#ifdef WINNT
	    if( hdcCleanup )
	    {
    		BOOL bRetVal;

		// We had to create a DC from scratch for this process/driver pair.
		DDASSERT(hdcCleanup == hdc_dd);
		// GDI creates a DirectDraw handle for each unique process/driver pair.
                if( pdrv->dwFlags & DDRAWI_NOHARDWARE )
		{
		    // A fake DDraw driver that lets the HEL do everything.
		    bRetVal = DdCreateDirectDrawObject(pdrv, (HDC)0);
		}
		else
		{
		    // A real DDraw driver with hardware acceleration.
		    bRetVal = DdCreateDirectDrawObject(pdrv, hdc_dd);
		}
		if (!bRetVal)
		{
		    DPF_ERR( "Call to DdCreateDirectDrawObject failed!");
		    DD_DoneDC(hdc_dd);
		    LEAVE_DDRAW();
		    LEAVE_CSDDC();
		    return DDERR_NODIRECTDRAWHW;
		}
		// The DdCreateDirectDrawObject() call above loaded a DD handle into a
		// into a temp location in the driver GBL object, but we must now save
		// the handle in the driver LCL object so it won't be overwritten if
		// another process calls DdCreateDirectDrawObject() on the same driver.
		hDD = pdrv->hDD;
	    }
	    pdrv_lcl->hDD = hDD;
	#endif //WINNT

	(HDC) pdrv_lcl->hDC = hdc_dd;

	*lplpDD = (LPDIRECTDRAW) pdrv_int;

	LEAVE_DDRAW();
	LEAVE_CSDDC();
	return DD_OK;
    }

    /*
     * if no match among the existing drivers, then we have to go off
     * and create one
     */
    hdc_dd = DD_CreateFirstDC( pdrvname );
    if( hdc_dd == NULL )
    {
	DPF_ERR( "Could not create driver, CreateDC failed!" );
	CLOSEVXD( hDDVxd );
	LEAVE_DDRAW();
	LEAVE_CSDDC();
	return DDERR_CANTCREATEDC;
    }

    #ifdef WIN95
        /*
         * HACK-O-RAMA TIME!  We need to do something smart if the VGA is
         * powered down or if we're in a DOS box.  We don't have the pDevice
         * yet, so we'll hack around w/ the DC we just created.
         */
        if( DD16_IsDeviceBusy( hdc_dd ) )
        {
            /*
             * Something is happenning, but we don't know what.  If it's
             * a DOS box, creating a simple POPUP should make it go away.
             */
            WNDCLASS cls;
            HWND     hWnd;
            cls.lpszClassName  = "DDrawHackWindow";
            cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
            cls.hInstance      = hModule;
            cls.hIcon          = NULL;
            cls.hCursor        = NULL;
            cls.lpszMenuName   = NULL;
            cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
            cls.lpfnWndProc    = DefWindowProc;
            cls.cbWndExtra     = 0;
            cls.cbClsExtra     = 0;
            RegisterClass(&cls);
            hWnd = CreateWindowEx(WS_EX_TOPMOST|WS_EX_TOOLWINDOW,
                "DDrawHackWindow", "DDrawHackWindow",
                WS_OVERLAPPED|WS_POPUP|WS_VISIBLE, 0, 0, 2, 2,
                NULL, NULL, hModule, NULL);
            if( hWnd != NULL )
            {
                DestroyWindow( hWnd );
                UnregisterClass( "DDrawHackWindow", hModule );
            }

            /*
             * Check again, and if we're still busy, that probably means
             * that the device is powered down.  In that case, forcing
             * emulaiton is probably the right thing to do.
             */
            if( DD16_IsDeviceBusy( hdc_dd ) )
            {
                dwFlags |= DDCREATE_EMULATIONONLY;
            }
        }
    #endif

    if( dwFlags & DDCREATE_EMULATIONONLY )
    {
	hel_only = TRUE;
    }
    else
    {
	hel_only = FALSE;
	/*
	 * "That's the chicago way..."
	 * Win95 drivers are talked to through the ExtEscape DCI extensions.
	 * Under NT we get at our drivers through the gdi32p dll.
	 * Consequently all this dci stuff goes away for NT. You'll find the
	 * equivalent stuff done at the top of DirectDrawObjectCreate
	 */
	#ifdef WIN95

		/*
		 * see if the DCICOMMAND escape is supported
		 */
		u = DCICOMMAND;
		halver = ExtEscape( hdc_dd, QUERYESCSUPPORT, sizeof(u),
			    (LPCSTR)&u, 0, NULL );
		if( (halver != DD_HAL_VERSION) && (halver != DD_HAL_VERSION_EXTERNAL) )
		{
		    if( halver <= 0 )
		    {
                        DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No DIRECTDRAW escape support" );
		    }
		    else
		    {
                        if (halver == 0x5250)
                        {
                            DPF(0,"****DirectDraw/Direct3D DRIVER DISABLING ERROR****:Acceleration slider is set to NONE");
                        }
                        else
                        {
			    DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:DIRECTDRAW driver is wrong version, got 0x%04lx, expected 0x%04lx",
				halver, DD_HAL_VERSION_EXTERNAL );
                        }
		    }

		    // We don't release the DC anymore becuase it always becomes part
		    // of the DDRAW_GBL object in all DisplayDrv cases.
		    hel_only = TRUE;
		}

	#endif //win95
    }

    if( hel_only && (dwFlags & DDCREATE_HARDWAREONLY))
    {
	DPF_ERR( "Only emulation available, but HARDWAREONLY requested" );
	CLOSEVXD( hDDVxd );
	LEAVE_DDRAW();
	LEAVE_CSDDC();
	DD_DoneDC(hdc_dd);
	return DDERR_NODIRECTDRAWHW;
    }

#ifdef WIN95
    // On non-multi-mon systems, we do this because
    // we did it in DX3. We set TRUE for multi-mon systems
    // because that will prevent us from using Death/Resurrection
    // which is Dangerous if some future DDraw object ever is
    // created for the secondary device. We can't wait until
    // the second device is created; because it's possible that
    // primary device is already in the middle of a death/resurrection
    // sequence and it is bad bad karma to change the flag between
    // the beginning of modex and the end of modex. (Specifically,
    // we'll see either a resurrection not being called when it should
    // have been or a resurrection called when it shouldn't have been.)
    if( IsMultiMonitor() )
	DD16_SetCertified( TRUE );
    else
	DD16_SetCertified( FALSE );
#endif

    /*
     * go try to create the driver object
     */

    if( !hel_only )
    {
	DWORD           hInstance = 0;
	DWORD           dwDriverData32 = 0;
	DWORD           p16;
	DDHALDDRAWFNS   ddhddfns;
	BOOL            bFailedWhackoVersion = FALSE;
	BOOL            bPassDriverInit = TRUE;

	/*
	 * "That's the chicago way..."
	 * Win95 drivers are talked to through the ExtEscape DCI extensions.
	 * Under NT we get at our drivers through the gdi32p dll.
	 * Consequently all this dci stuff goes away for NT. You'll find the
	 * equivalent stuff done at the top of DirectDrawObjectCreate
	 */
	#ifdef WIN95
	    DD32BITDRIVERDATA   data;
	    DDVERSIONDATA       verdata;

	    /*
	     * Notify the driver of the DirectDraw version.
	     *
	     * Why this is neccesary:  After DX3 it became a requirement for
	     * newer DDraws to work w/ older HALs and visa versa.  DD_VERSION
	     * was set at 0x200 in DX3 and all of the drivers hardcoded it.
	     * Therefore, setting dwVersion to anything other than 0x200 would
	     * cause DX3 HALs to fail. The other option was to put the real
	     * version in dwParam1 of the DDGET32BITDRIVERNAME call, but this
	     * option seems a little cleaner.  Since the information could be
	     * useful in the future, we also ask the HAL to tell us what
	     * version of DirectDraw they were designed for.
	     */
	    DPF( 4, "DDVERSIONINFO" );

	    /*
	     * On debug builds, probe the driver with a totally whacko ddraw version
	     * This ensures we can increment this version in the future i.e. that
	     * any existing drivers which catch this escape don't hard code for
	     * whatever version of the DDK they use
	     * We fail the driver if they give out on some large random ddraw version but
	     * pass on 0x500
	     */

	    cmd.dwCommand = (DWORD) DDVERSIONINFO;
	    cmd.dwParam1 = (GetCurrentProcessId() & 0xfff) + 0x501; //always > 0x500
	    cmd.dwParam2 = 0;
	    cmd.dwReserved = 0;
	    cmd.dwVersion = DD_VERSION;         // So older HALs won't fail

	    verdata.dwHALVersion = 0;
	    verdata.dwReserved1 = 0;
	    verdata.dwReserved2 = 0;
	    rc = ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, sizeof( verdata ), (LPSTR) &verdata );
	    if (rc <= 0)
	    {
		//Removed this DPF: It's misleading
		//DPF(1,"Driver failed random future DDraw version");
		bFailedWhackoVersion = TRUE;
	    }

	    cmd.dwCommand = (DWORD) DDVERSIONINFO;
	    cmd.dwParam1 = DD_RUNTIME_VERSION;
	    cmd.dwParam2 = 0;
	    cmd.dwReserved = 0;
	    cmd.dwVersion = DD_VERSION;         // So older HALs won't fail

	    verdata.dwHALVersion = 0;
	    verdata.dwReserved1 = 0;
	    verdata.dwReserved2 = 0;
	    rc = ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, sizeof( verdata ), (LPSTR) &verdata );
	    DPF( 5, "HAL version: %X", verdata.dwHALVersion );

	    /*
	     * If the driver failed the whacko version, but passed for 0x500 (DX5),
	     * then fail the driver.
	     */
	    if( rc > 0 && verdata.dwHALVersion >= 0x500 && bFailedWhackoVersion )
	    {
		DPF_ERR("****DirectDraw/Direct3D DRIVER DISABLING ERROR****Driver Failed a DDVERSIONINFO for a random future ddraw version but passed for DX5.");
		bPassDriverInit = FALSE;
		isdispdrv = FALSE;
		pdrv = NULL;
		hel_only = TRUE;
	    }

	    /*
	     * load up the 32-bit display driver DLL
	     */
	    DPF( 4, "DDGET32BITDRIVERNAME" );
	    cmd.dwCommand = (DWORD) DDGET32BITDRIVERNAME;
	    cmd.dwParam1 = 0;

	    cmd.dwVersion = DD_VERSION;
	    rc = ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, sizeof( data ), (LPSTR) &data );
	    if( rc > 0 )
	    {
		#ifndef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#endif
		dwDriverData32 = HelperLoadDLL( data.szName, data.szEntryPoint, data.dwContext );

		DPF( 5, "DriverInit returned 0x%x", dwDriverData32 );
		#ifndef WIN16_SEPARATE
		    ENTER_DDRAW();
		#endif
	    }

	    /*
	     * get the 16-bit callbacks
	     */
	    DD16_GetDriverFns( &ddhddfns );

	    DPF( 4, "DDNEWCALLBACKFNS" );
	    cmd.dwCommand = (DWORD) DDNEWCALLBACKFNS;
	    #ifdef WIN95
		p16 = MapLS( &ddhddfns );
		cmd.dwParam1 = p16;
		cmd.dwParam2 = 0;
	    #else
		cmd.dwParam1 = (UINT) &ddhddfns;
		cmd.dwParam2 = 0;
	    #endif

	    cmd.dwVersion = DD_VERSION;
	    cmd.dwReserved = 0;

	    ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, 0, NULL );
	    UnMapLS( p16 );

	    /*
	     * try to create the driver object now
	     */
	    DPF( 4, "DDCREATEDRIVEROBJECT" );
	    cmd.dwCommand = (DWORD) DDCREATEDRIVEROBJECT;
	    cmd.dwParam1 = dwDriverData32;
	    cmd.dwParam2 = 0;

	    cmd.dwVersion = DD_VERSION;
	    cmd.dwReserved = 0;

	    rc = ExtEscape( hdc_dd, DCICOMMAND, sizeof( cmd ),
			(LPCSTR)&cmd, sizeof( DWORD ), (LPVOID) &hInstance );
	    DPF( 5, "hInstance = %08lx", hInstance );

	    if( rc <= 0 )
	    {
		DPF( 0, "ExtEscape rc=%ld, GetLastError=%ld", rc, GetLastError() );
		DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:No DDCREATEDRIVEROBJECT support in driver" );
		isdispdrv = FALSE;
		pdrv = NULL;
		hel_only = TRUE;
	    }

            DPF(5,"bPassDriverInit:%d, rc:%d",bPassDriverInit,rc);

	    if ( (bPassDriverInit) && (rc > 0) )
	#endif //WIN95
	{
	    /*
	     * create our driver object
	     */
	    #ifdef WINNT
		uDisplaySettingsUnique=DdQueryDisplaySettingsUniqueness();
	    #endif
	    pdrv = FetchDirectDrawData( NULL, FALSE, hInstance, hDDVxd, pdrvname, dwDriverData32 , NULL);
	    if( pdrv )
	    {
		#ifdef WIN95
		    pdrv->dwInternal1 = verdata.dwHALVersion;
                    //Record 32-bit driver data so we can get its version info later
                    pdrv->dd32BitDriverData = data;
		#else
		    /*
		     * NT gets the same driver version as ddraw. Kernel
		     * has to filter ddraw.dll's ravings for the driver
		     */
		    pdrv->dwInternal1 = DD_RUNTIME_VERSION;
		#endif
		strcpy( pdrv->cDriverName, pdrvname );

#ifdef WIN95
                //
                // If we have to run in emulation only, then we better make sure we are
                // on a minidriver. If not, then emulation is unreliable so we'll bail
                // This is done to work around some messed up "remote control" programs
                // that turn off C1_DIBENGINE and make us fail (IsWin95MiniDriver used
                // to be called from IsDirectDrawSupported). The thinking is that if there's ddraw
                // support, then it is pretty much guaranteed to be a minidriver. If there's
                // no support, then we can trust the absence of C1_DIBENGINE and thus fail ddraw init
                //
                if( (pdrv->ddCaps.dwCaps & DDCAPS_NOHARDWARE) && !DD16_IsWin95MiniDriver() )
                {
	            DPF( 0, "****DirectDraw/Direct3D DRIVER DISABLING ERROR****:DirectDraw requires a Windows95 display driver" );
	            DirectDrawMsg(MAKEINTRESOURCE(IDS_DONTWORK_DRV));
	            CLOSEVXD( hDDVxd );
	            LEAVE_DDRAW();
	            LEAVE_CSDDC();
	            DD_DoneDC(hdc_dd);
	            return DDERR_GENERIC;
                }
#endif
	    }

            // 5/24/2000(RichGr): IA64: Use %p format specifier for 32/64-bit pointers.
	    DPF( 5, "pdrv = 0x%p", pdrv );
	    if( pdrv == NULL )
	    {
		DPF( 3, "Got returned NULL pdrv!" );
		isdispdrv = FALSE;
		hel_only = TRUE;
	    }
	    #ifdef WIN95
	    else
	    {
		/*
		 * The only certified drivers are ones that we produced.
		 * DD_HAL_VERSION is different for internal vs external.
		 * We use this difference pick out ours.
		 */
		if( halver == DD_HAL_VERSION )
		{
		    pdrv->ddCaps.dwCaps2 |= DDCAPS2_CERTIFIED;
		    DD16_SetCertified( TRUE );
		}
	    }
	    #endif
	}
    }

    /*
     * no driver object found, so fake one up for the HEL (only do this
     * for generic display drivers)
     */
    if( pdrv == NULL || hel_only )
    {
	hel_only = TRUE;
	pdrv = FakeDDCreateDriverObject( hdc_dd, pdrvname, NULL, FALSE, hDDVxd );
	if( pdrv == NULL )
	{
	    DPF_ERR( "Could not create HEL object" );
	    CLOSEVXD( hDDVxd );
	    LEAVE_DDRAW();
	    LEAVE_CSDDC();
	    DD_DoneDC(hdc_dd);
	    return DDERR_GENERIC;
	}

	/*
	 * the HEL is certified
	 */
	pdrv->ddCaps.dwCaps2 |= DDCAPS2_CERTIFIED;
	strcpy( pdrv->cDriverName, pdrvname );

	// Initialize Rect information for this pdrv
	UpdateRectFromDevice( pdrv );
    }

    /*
     * Even if it's not a display driver, it may still be a GDI driver
     */
    if( hdc_dd != NULL )
    {
	if( !(pdrv->dwFlags & DDRAWI_DISPLAYDRV))
	{
	    if (fDoesGDI(hdc_dd))
	    {
		pdrv->dwFlags |= DDRAWI_GDIDRV;
	    }
	    else
	    {
		pdrv->dwFlags &= ~DDRAWI_GDIDRV;
	    }
	}
    }
    /*
     * initialize for HEL usage
     */
    capsInit( pdrv );
    if( !helInit( pdrv, dwFlags, hel_only ) )
    {
	DPF_ERR( "helInit FAILED" );
	CLOSEVXD( hDDVxd );
	LEAVE_DDRAW();
	LEAVE_CSDDC();
	/* GEE: HEL can only fail in v1 for lack of memory */
	DD_DoneDC(hdc_dd);
	return DDERR_GENERIC;
    }

    /*
     * create a new interface, and update the driver object with
     * random bits o' data.
     */
    pdrv_int = getDriverInterface( pnew_int, pdrv );
    if( pdrv_int == NULL )
    {
	DPF_ERR( "No memory for driver callbacks." );
	CLOSEVXD( hDDVxd );
	LEAVE_DDRAW();
	LEAVE_CSDDC();
	DD_DoneDC(hdc_dd);
	return DDERR_OUTOFMEMORY;
    }
    pdrv_lcl = pdrv_int->lpLcl;
    pdrv_lcl->dwAppHackFlags = hackflags;

    #ifdef DEBUG
	if( dwRegFlags & DDRAW_REGFLAGS_DISABLEINACTIVATE )
	{
	    pdrv_lcl->dwLocalFlags |= DDRAWILCL_DISABLEINACTIVATE;
	}
    #endif
    if( IsAttachedToDesktop( lpGUID ) )
    {
	pdrv->dwFlags |= DDRAWI_ATTACHEDTODESKTOP;
    }
    if (bExplicitMonitor)
    {
	    pdrv_lcl->dwLocalFlags |= DDRAWILCL_EXPLICITMONITOR;
    }
    pdrv_lcl->dwLocalFlags |= dwCallFlags;
    /*
     * Will be initialized to NULL on NT.
     */
    pdrv_lcl->hDDVxd = (ULONG_PTR) hDDVxd;

    if( hdc_dd != NULL )
    {
    #ifdef WIN95
	    // Make sure it doesn't get released by mistake
	    DD16_MakeObjectPrivate(hdc_dd, TRUE);
    #endif
	(HDC) pdrv_lcl->hDC = hdc_dd;
    }
    strcpy( pdrv->cDriverName, pdrvname );

    #ifdef WINNT
	/*
	 * The FetchDirectDrawData() call above loaded a DD handle into a
	 * into a temp location in the driver GBL object; we must now save
	 * the handle in the driver LCL object so it won't be overwritten.
	 */
	pdrv_lcl->hDD = pdrv->hDD;
    #endif //WINNT

    // Initialize cObsolete just in case some driver references the
    // field. It will always be initialized to "DISPLAY".

    lstrcpy(pdrv->cObsolete, DISPLAY_STR);

    /*
     * Initialize the kernel interface
     */
    if( isdispdrv && !hel_only )
    {
	InitKernelInterface( pdrv_lcl );
    }

    LEAVE_DDRAW();
    #ifdef WIN95
	if( !hel_only )
	{
	    extern DWORD WINAPI OpenVxDHandle( HANDLE hWin32Obj );
	    DWORD       event16;
	    HANDLE      h;
	    HelperCreateModeSetThread( DDNotifyModeSet, &h, pdrv_lcl->lpGbl,
					pdrv->hInstance );
	    if( h != NULL )
	    {
		event16 = OpenVxDHandle( h );
		DPF( 4, "16-bit event handle=%08lx", event16 );
		DD16_SetEventHandle( pdrv->hInstance, event16 );
		pdrv->dwEvent16 = event16;
		CloseHandle( h );
	    }
	}

	/*
	 * Create thread that will notify us when we are returning from
	 * a DOS box so we can invalidate the surfaces.
	 */
	if( !hel_only && bIsPrimary && IsWindows98() )
	{
	    DWORD       event16;
	    HANDLE      h;
	    HelperCreateDOSBoxThread( DDNotifyDOSBox, &h, pdrv_lcl->lpGbl,
					pdrv->hInstance );
	    if( h != NULL )
	    {
		event16 = OpenVxDHandle( h );
		DPF( 4, "DOS Box event handle=%08lx", event16 );
		pdrv->dwDOSBoxEvent = event16;
		SetKernelDOSBoxEvent( pdrv_lcl );
		CloseHandle( h );
	    }
	}

    #endif

    LEAVE_CSDDC();
    *lplpDD = (LPDIRECTDRAW) pdrv_int;
    return DD_OK;

} /* InternalDirectDrawCreate */

BOOL CALLBACK MonitorEnumProc(HMONITOR hMon, HDC hdc, LPRECT lpr, LPARAM lParam)
{
    MONITORINFOEX       mix;
    MONITORINFO         mi;
    LPCALLBACKSTRUCT    lpcb = (LPCALLBACKSTRUCT) lParam;

    mi.cbSize = sizeof(mi);
    if (!InternalGetMonitorInfo(hMon,&mi))
	return FALSE;

    mix.cbSize = sizeof(mix);
    if (!InternalGetMonitorInfo(hMon,(MONITORINFO*) &mix))
	return FALSE;

    if (!strcmp(lpcb->pName,(LPSTR)mix.szDevice))
    {
	//Found it!!
	lpcb->hMon = hMon;
	return FALSE;
    }
    return TRUE;
}

/*
 * GetMonitorFromDeviceName
 */
HMONITOR GetMonitorFromDeviceName(LPSTR szName)
{
    CALLBACKSTRUCT cbs;
    cbs.pName = szName;
    cbs.hMon = NULL;

    if (!InternalEnumMonitors(MonitorEnumProc, &cbs))
	return NULL;

    return cbs.hMon;
}


/*
 * These callbacks are used to munge DirectDrawEnumerateEx's callback into the old
 * style callback.
 */
typedef struct
{
    LPDDENUMCALLBACKA   lpCallback;
    LPVOID              lpContext;
} ENUMCALLBACKTRANSLATORA, * LPENUMCALLBACKTRANSLATORA;

BOOL FAR PASCAL TranslateCallbackA(GUID FAR *lpGUID, LPSTR pName , LPSTR pDesc , LPVOID pContext, HMONITOR hm)
{
    LPENUMCALLBACKTRANSLATORA pTrans = (LPENUMCALLBACKTRANSLATORA) pContext;

    return (pTrans->lpCallback) (lpGUID,pName,pDesc,pTrans->lpContext);
}

typedef struct
{
    LPDDENUMCALLBACKW   lpCallback;
    LPVOID              lpContext;
} ENUMCALLBACKTRANSLATORW, * LPENUMCALLBACKTRANSLATORW;

BOOL FAR PASCAL TranslateCallbackW(GUID FAR *lpGUID, LPWSTR pName , LPWSTR pDesc , LPVOID pContext, HMONITOR hm)
{
    LPENUMCALLBACKTRANSLATORW pTrans = (LPENUMCALLBACKTRANSLATORW) pContext;

    return (pTrans->lpCallback) (lpGUID,pName,pDesc,pTrans->lpContext);
}

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawEnumerateA"

/*
 * DirectDrawEnumerateA
 */
HRESULT WINAPI DirectDrawEnumerateA(
		LPDDENUMCALLBACKA lpCallback,
		LPVOID lpContext )
{
    ENUMCALLBACKTRANSLATORA Translate;
    Translate.lpCallback = lpCallback;
    Translate.lpContext = lpContext;

    DPF(2,A,"ENTERAPI: DirectDrawEnumerateA");

    if( !VALIDEX_CODE_PTR( lpCallback ) )
    {
	DPF( 0, "Invalid callback routine" );
	return DDERR_INVALIDPARAMS;
    }

#ifdef DEBUG
    if (IsMultiMonitor())
    {
	DPF(0,"***********************************************");
	DPF(0,"* Use DirectDrawEnumerateEx to enumerate      *");
	DPF(0,"* multiple monitors                           *");
	DPF(0,"***********************************************");
    }
#endif

    return DirectDrawEnumerateExA(TranslateCallbackA, (LPVOID) & Translate, DDENUM_NONDISPLAYDEVICES);
} /* DirectDrawEnumerateA */



#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawEnumerateW"

/*
 * DirectDrawEnumerateW
 */
HRESULT WINAPI DirectDrawEnumerateW(
		LPDDENUMCALLBACKW lpCallback,
		LPVOID lpContext )
{
    ENUMCALLBACKTRANSLATORW Translate;
    Translate.lpCallback = lpCallback;
    Translate.lpContext = lpContext;

    DPF(2,A,"ENTERAPI: DirectDrawEnumerateW");

    if( !VALIDEX_CODE_PTR( lpCallback ) )
    {
	DPF( 0, "Invalid callback routine" );
	return DDERR_INVALIDPARAMS;
    }

#ifdef DEBUG
    if (IsMultiMonitor())
    {
	DPF(0,"***********************************************");
	DPF(0,"* Use DirectDrawEnumerateEx to enumerate      *");
	DPF(0,"* multiple monitors                           *");
	DPF(0,"***********************************************");
    }
#endif

    return DirectDrawEnumerateExW(TranslateCallbackW, (LPVOID) & Translate, DDENUM_NONDISPLAYDEVICES);
} /* DirectDrawEnumerateW */

#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawEnumerateA"

/*
 * DirectDrawEnumerateA
 */
HRESULT WINAPI DirectDrawEnumerateExA(
		LPDDENUMCALLBACKEXA lpCallback,
		LPVOID lpContext,
		DWORD dwFlags )
{
    DWORD       rc;
    DWORD       keyidx;
    HKEY        hkey;
    HKEY        hsubkey;
    char        keyname[256];
    char        desc[256];
    char        drvname[MAX_PATH];
    DWORD       cb;
    DWORD       n;
    DWORD       type;
    GUID        guid;
    HDC         hdc;
    DISPLAY_DEVICEA dd;
    BOOL        bEnumerateSecondariesLike3dfx=FALSE;

    DPF(2,A,"ENTERAPI: DirectDrawEnumerateExA");

    //BEGIN VOODOO2 HACK
    {
        HKEY hkey;

	dwRegFlags &= ~DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES;

        if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hkey ) )
        {
            DWORD cb;
            DWORD value;
	    cb = sizeof( value );
	    if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_ENUMSECONDARY, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	    {
                DPF( 2, "    EnumerateAttachedSecondaries: %d", value );
	        if( value )
	        {
                    bEnumerateSecondariesLike3dfx = TRUE;
	            dwRegFlags |= DDRAW_REGFLAGS_ENUMERATEATTACHEDSECONDARIES;
	        }
	    }
	    RegCloseKey(hkey);
        }
    }
    //END VOODOO2 HACK

#ifdef WIN95
    /*
     * Did DDHELP fail to initialize properly?
     */
    if( dwHelperPid == 0 )
    {
        return DDERR_NODIRECTDRAWSUPPORT;
    }
#endif

    if( !VALIDEX_CODE_PTR( lpCallback ) )
    {
	DPF( 0, "Invalid callback routine" );
	return DDERR_INVALIDPARAMS;
    }

    if( dwFlags & ~DDENUM_VALID)
    {
	DPF_ERR("Invalid flags for DirectDrawEnumerateEx");
	return DDERR_INVALIDPARAMS;
    }

#ifdef WINNT
    // We do not support detached devices on NT so silently ignore the flag:
    dwFlags &= ~DDENUM_DETACHEDSECONDARYDEVICES;
#endif
    
    LoadString( hModule, IDS_PRIMARYDISPLAY, desc, sizeof(desc) );

    TRY
    {
	rc = lpCallback( NULL, desc, DISPLAY_STR, lpContext, NULL );
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception occurred during DirectDrawEnumerateEx callback" );
	return DDERR_INVALIDPARAMS;
    }
    if( !rc )
    {
	return DD_OK;
    }

    if (dwFlags & DDENUM_NONDISPLAYDEVICES)
    {
	if( RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDHW, &hkey ) == 0 )
	{
	    /*
	     * enumerate all subkeys under HKEY_LOCALMACHINE\Hardware\DirectDrawDrivers
	     */
	    keyidx = 0;
	    while( !RegEnumKey( hkey, keyidx, keyname, sizeof( keyname ) ) )
	    {
		if( strToGUID( keyname, &guid ) )
		{
		    if( !RegOpenKey( hkey, keyname, &hsubkey ) )
		    {
			cb = sizeof( desc ) - 1;
			if( !RegQueryValueEx( hsubkey, REGSTR_KEY_DDHW_DESCRIPTION, NULL, &type,
				    (CONST LPBYTE)desc, &cb ) )
			{
			    if( type == REG_SZ )
			    {
				desc[cb] = 0;
				cb = sizeof( drvname ) - 1;
				if( !RegQueryValueEx( hsubkey, REGSTR_KEY_DDHW_DRIVERNAME, NULL, &type,
					    (CONST LPBYTE)drvname, &cb ) )
				{
				    /*
				     * It is possible that the registry is out
				     * of date, so we will try to create a DC.
				     * The problem is that the Voodoo 1 driver
                                     * will suceed on a Voodoo 2, Banshee, or
                                     * Voodoo 3 (and hang later), so we need to
                                     * hack around it.
				     */
				    drvname[cb] = 0;
                                    if( Voodoo1GoodToGo( &guid ) )
                                    {
                                        hdc = DD_CreateDC( drvname );
                                    }
                                    else
                                    {
                                        hdc = NULL;
                                    }
				    if( ( type == REG_SZ ) &&
					( hdc != NULL ) )
				    {
					drvname[cb] = 0;
					DPF( 5, "Enumerating GUID "
						    "%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x",
						    guid.Data1,
						    guid.Data2,
						    guid.Data3,
						    guid.Data4[ 0 ],
						    guid.Data4[ 1 ],
						    guid.Data4[ 2 ],
						    guid.Data4[ 3 ],
						    guid.Data4[ 4 ],
						    guid.Data4[ 5 ],
						    guid.Data4[ 6 ],
						    guid.Data4[ 7 ] );
					DPF( 5, "    Driver Name = %s", drvname );
					DPF( 5, "    Description = %s", desc );
					rc = lpCallback( &guid, desc, drvname, lpContext , NULL);
					if( !rc )
					{
					    DD_DoneDC( hdc );
                                            RegCloseKey( hsubkey );
					    RegCloseKey( hkey );
					    return DD_OK;
					}
				    }
				    if( hdc != NULL )
				    {
					DD_DoneDC( hdc );
				    }
				}
			    }
			}
			RegCloseKey( hsubkey );
		    }
		}
		keyidx++;
	    }
	    RegCloseKey( hkey );
	}
    }
    else
    {
	DPF( 3, "No registry information for any drivers" );
    }

    /*
     * now enumerate all devices returned by EnumDisplayDevices
     * We do this after the secondary drivers to hopefully not confuse people
     * who are looking for 3DFx and have written bad code. Putting these
     * after the 3DFx seems the safest thing to do..
     */

    /* If there is only one device in the system then we don't
     * enumerate it because it already is implicitly the primary
     * This will improve behavior for badly written (i.e. our samples)
     * D3D apps that are searching for a 3DFx device.
     */
    if( !IsMultiMonitor() )
    {
	// If there is only one device; then just stop here.
	DPF( 3, "Only one Display device in the current system." );
	return DD_OK;
    }

    DPF( 3, "More than one display device in the current system." );

    // Zero the memory of the DisplayDevice struct between calls to
    // EnumDisplayDevices
    ZeroMemory(&dd, sizeof(dd));
    dd.cb = sizeof(dd);

    for( n=0; xxxEnumDisplayDevicesA( NULL, n, &dd, 0 ); n++ )
    {
	GUID guid;

	//
	// skip drivers that are not hardware devices
	//
	if( dd.StateFlags & DISPLAY_DEVICE_MIRRORING_DRIVER )
	    continue;

	guid = DisplayGUID;
	guid.Data1 += n;

	if ( (dd.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) ?
	    ((dwFlags & DDENUM_ATTACHEDSECONDARYDEVICES) ||
//BEGIN VOODOO2 HACK
                    (bEnumerateSecondariesLike3dfx && !(dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)) ):
//END VOODOO2 HACK
            (dwFlags & DDENUM_DETACHEDSECONDARYDEVICES) )
	{
	    HMONITOR hMonitor;

	    DPF( 5, "Enumerating GUID "
			"%08lx-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x",
			guid.Data1,
			guid.Data2,
			guid.Data3,
			guid.Data4[ 0 ],
			guid.Data4[ 1 ],
			guid.Data4[ 2 ],
			guid.Data4[ 3 ],
			guid.Data4[ 4 ],
			guid.Data4[ 5 ],
			guid.Data4[ 6 ],
			guid.Data4[ 7 ] );
	    DPF( 5, "    Driver Name = %s", dd.DeviceName );
	    DPF( 5, "    Description = %s", dd.DeviceString );
	    hMonitor = GetMonitorFromDeviceName(dd.DeviceName);
	    rc = lpCallback( &guid, dd.DeviceString, dd.DeviceName, lpContext, hMonitor);

	    if( !rc )
	    {
		return DD_OK;
	    }
	}

	// Zero the memory of the DisplayDevice struct between calls to
	// EnumDisplayDevices
	ZeroMemory( &dd, sizeof(dd) );
	dd.cb = sizeof(dd);
    }

    return DD_OK;

} /* DirectDrawEnumerateExA */



#undef DPF_MODNAME
#define DPF_MODNAME "DirectDrawEnumerateExW"

/*
 * DirectDrawEnumerateExW
 */
HRESULT WINAPI DirectDrawEnumerateExW(
		LPDDENUMCALLBACKEXW lpCallback,
		LPVOID lpContext,
		DWORD dwFlags)
{
    DPF(2,A,"ENTERAPI: DirectDrawEnumerateExW");	
    DPF_ERR( "DirectDrawEnumerateEx for unicode is not created" );
    return DDERR_UNSUPPORTED;

} /* DirectDrawEnumerateExW */


/*
 * these are exported... temp. hack for non-Win95
 */
#ifndef WIN95
void DDAPI thk3216_ThunkData32( void )
{
}
void DDAPI thk1632_ThunkData32( void )
{
}

DWORD DDAPI DDGetPID( void )
{
    return 0;
}

int DDAPI DDGetRequest( void )
{
    return 0;
}

BOOL DDAPI DDGetDCInfo( LPSTR fname )
{
    return 0;
}

void DDAPI DDHAL32_VidMemFree(
		LPVOID this,
		int heap,
		FLATPTR ptr )
{
}

FLATPTR DDAPI DDHAL32_VidMemAlloc(
		LPVOID this,
		int heap,
		DWORD dwWidth,
		DWORD dwHeight )
{
    return 0;
}

#ifdef POSTPONED
BOOL DDAPI DD32_HandleExternalModeChange(LPDEVMODE pModeInfo)
{
    return FALSE;
}
#endif
#endif

/*
 * _DirectDrawMsg
 */
DWORD WINAPI _DirectDrawMsg(LPVOID msg)
{
    char                title[80];
    char                ach[512];
    MSGBOXPARAMS        mb;

    LoadString( hModule, IDS_TITLE, title, sizeof(title) );

    if( HIWORD((ULONG_PTR)msg) )
    {
	lstrcpy( ach, (LPSTR)msg );
    }
    else
    {
	LoadString( hModule, (int)((ULONG_PTR)msg), ach, sizeof(ach) );
    }

    mb.cbSize               = sizeof(mb);
    mb.hwndOwner            = NULL;
    mb.hInstance            = hModule;
    mb.lpszText             = ach;
    mb.lpszCaption          = title;
    mb.dwStyle              = MB_OK|MB_SETFOREGROUND|MB_TOPMOST|MB_ICONSTOP;
    mb.lpszIcon             = 0;
    mb.dwContextHelpId      = 0;
    mb.lpfnMsgBoxCallback   = NULL;
    mb.dwLanguageId         = 0;

    return MessageBoxIndirect(&mb);

} /* _DirectDrawMsg */

/*
 * DirectDrawMsg
 *
 * display an error message to the user, bring the message box up
 * in another thread so the caller does not get reentered.
 */
DWORD DirectDrawMsg( LPSTR msg )
{
    HANDLE h;
    DWORD  dw;
    HKEY   hkey;

    //
    // get the current error mode, dont show a message box if the app
    // does not want us too.
    //
    dw = SetErrorMode(0);
    SetErrorMode(dw);

    if( dw & SEM_FAILCRITICALERRORS )
    {
	return 0;
    }

    /*
     * If the registry says no dialogs, then no dialogs.
     */
    if( !RegOpenKey( HKEY_LOCAL_MACHINE, REGSTR_PATH_DDRAW, &hkey ) )
    {
	DWORD   type;
	DWORD   value;
	DWORD   cb;

	cb = sizeof( value );
	if( !RegQueryValueEx( hkey, REGSTR_VAL_DDRAW_DISABLEDIALOGS, NULL, &type, (CONST LPBYTE)&value, &cb ) )
	{
	    if (value)
	    {
		RegCloseKey( hkey );
		return 0;
	    }
	}
	RegCloseKey( hkey );
    }


    if( h = CreateThread(NULL, 0, _DirectDrawMsg, (LPVOID)msg, 0, &dw) )
    {
	WaitForSingleObject( h, INFINITE );
	GetExitCodeThread( h, &dw );
	CloseHandle( h );
    }
    else
    {
	dw = 0;
    }

    return dw;

} /* DirectDrawMsg */

/*
 * convertV1DDHALINFO
 *
 * Convert an obsolete DDHALINFO structure to the latest and greatest structure.
 * This function takes a pointer to an LPDDHALINFO structure which has the same size as
 * the new structure but has been filled in as if it is the V1 structure.  Information is moved
 * around in the structure and the new fields are cleared.
 */
void convertV1DDHALINFO( LPDDHALINFO lpDDHALInfo )
{
    DDHALINFO   ddNew;
    LPDDHALINFO_V1 lpddOld = (LPVOID)lpDDHALInfo;
    int         i;

    ddNew.dwSize = sizeof( DDHALINFO );
    ddNew.lpDDCallbacks = lpddOld->lpDDCallbacks;
    ddNew.lpDDSurfaceCallbacks = lpddOld->lpDDSurfaceCallbacks;
    ddNew.lpDDPaletteCallbacks = lpddOld->lpDDPaletteCallbacks;
    ddNew.vmiData = lpddOld->vmiData;

    // ddCaps
    ddNew.ddCaps.dwSize = lpddOld->ddCaps.dwSize;
    ddNew.ddCaps.dwCaps = lpddOld->ddCaps.dwCaps;
    ddNew.ddCaps.dwCaps2 = lpddOld->ddCaps.dwCaps2;
    ddNew.ddCaps.dwCKeyCaps = lpddOld->ddCaps.dwCKeyCaps;
    ddNew.ddCaps.dwFXCaps = lpddOld->ddCaps.dwFXCaps;
    ddNew.ddCaps.dwFXAlphaCaps = lpddOld->ddCaps.dwFXAlphaCaps;
    ddNew.ddCaps.dwPalCaps = lpddOld->ddCaps.dwPalCaps;
    ddNew.ddCaps.dwSVCaps = lpddOld->ddCaps.dwSVCaps;
    ddNew.ddCaps.dwAlphaBltConstBitDepths = lpddOld->ddCaps.dwAlphaBltConstBitDepths;
    ddNew.ddCaps.dwAlphaBltPixelBitDepths = lpddOld->ddCaps.dwAlphaBltPixelBitDepths;
    ddNew.ddCaps.dwAlphaBltSurfaceBitDepths = lpddOld->ddCaps.dwAlphaBltSurfaceBitDepths;
    ddNew.ddCaps.dwAlphaOverlayConstBitDepths = lpddOld->ddCaps.dwAlphaOverlayConstBitDepths;
    ddNew.ddCaps.dwAlphaOverlayPixelBitDepths = lpddOld->ddCaps.dwAlphaOverlayPixelBitDepths;
    ddNew.ddCaps.dwAlphaOverlaySurfaceBitDepths = lpddOld->ddCaps.dwAlphaOverlaySurfaceBitDepths;
    ddNew.ddCaps.dwZBufferBitDepths = lpddOld->ddCaps.dwZBufferBitDepths;
    ddNew.ddCaps.dwVidMemTotal = lpddOld->ddCaps.dwVidMemTotal;
    ddNew.ddCaps.dwVidMemFree = lpddOld->ddCaps.dwVidMemFree;
    ddNew.ddCaps.dwMaxVisibleOverlays = lpddOld->ddCaps.dwMaxVisibleOverlays;
    ddNew.ddCaps.dwCurrVisibleOverlays = lpddOld->ddCaps.dwCurrVisibleOverlays;
    ddNew.ddCaps.dwNumFourCCCodes = lpddOld->ddCaps.dwNumFourCCCodes;
    ddNew.ddCaps.dwAlignBoundarySrc = lpddOld->ddCaps.dwAlignBoundarySrc;
    ddNew.ddCaps.dwAlignSizeSrc = lpddOld->ddCaps.dwAlignSizeSrc;
    ddNew.ddCaps.dwAlignBoundaryDest = lpddOld->ddCaps.dwAlignBoundaryDest;
    ddNew.ddCaps.dwAlignSizeDest = lpddOld->ddCaps.dwAlignSizeDest;
    ddNew.ddCaps.dwAlignStrideAlign = lpddOld->ddCaps.dwAlignStrideAlign;
    ddNew.ddCaps.ddsCaps = lpddOld->ddCaps.ddsCaps;
    ddNew.ddCaps.dwMinOverlayStretch = lpddOld->ddCaps.dwMinOverlayStretch;
    ddNew.ddCaps.dwMaxOverlayStretch = lpddOld->ddCaps.dwMaxOverlayStretch;
    ddNew.ddCaps.dwMinLiveVideoStretch = lpddOld->ddCaps.dwMinLiveVideoStretch;
    ddNew.ddCaps.dwMaxLiveVideoStretch = lpddOld->ddCaps.dwMaxLiveVideoStretch;
    ddNew.ddCaps.dwMinHwCodecStretch = lpddOld->ddCaps.dwMinHwCodecStretch;
    ddNew.ddCaps.dwMaxHwCodecStretch = lpddOld->ddCaps.dwMaxHwCodecStretch;
    ddNew.ddCaps.dwSVBCaps = 0;
    ddNew.ddCaps.dwSVBCKeyCaps = 0;
    ddNew.ddCaps.dwSVBFXCaps = 0;
    ddNew.ddCaps.dwVSBCaps = 0;
    ddNew.ddCaps.dwVSBCKeyCaps = 0;
    ddNew.ddCaps.dwVSBFXCaps = 0;
    ddNew.ddCaps.dwSSBCaps = 0;
    ddNew.ddCaps.dwSSBCKeyCaps = 0;
    ddNew.ddCaps.dwSSBFXCaps = 0;
    ddNew.ddCaps.dwMaxVideoPorts = 0;
    ddNew.ddCaps.dwCurrVideoPorts = 0;
    ddNew.ddCaps.dwReserved1 = lpddOld->ddCaps.dwReserved1;
    ddNew.ddCaps.dwReserved2 = lpddOld->ddCaps.dwReserved2;
    ddNew.ddCaps.dwReserved3 = lpddOld->ddCaps.dwReserved3;
    ddNew.ddCaps.dwSVBCaps2 = 0;
    for(i=0; i<DD_ROP_SPACE; i++)
    {
	ddNew.ddCaps.dwRops[i] = lpddOld->ddCaps.dwRops[i];
	ddNew.ddCaps.dwSVBRops[i] = 0;
	ddNew.ddCaps.dwVSBRops[i] = 0;
	ddNew.ddCaps.dwSSBRops[i] = 0;
    }

    ddNew.dwMonitorFrequency = lpddOld->dwMonitorFrequency;
    ddNew.GetDriverInfo = NULL; // was unused hWndListBox in v1
    ddNew.dwModeIndex = lpddOld->dwModeIndex;
    ddNew.lpdwFourCC = lpddOld->lpdwFourCC;
    ddNew.dwNumModes = lpddOld->dwNumModes;
    ddNew.lpModeInfo = lpddOld->lpModeInfo;
    ddNew.dwFlags = lpddOld->dwFlags;
    ddNew.lpPDevice = lpddOld->lpPDevice;
    ddNew.hInstance = lpddOld->hInstance;

    ddNew.lpD3DGlobalDriverData = 0;
    ddNew.lpD3DHALCallbacks = 0;
    ddNew.lpDDExeBufCallbacks = NULL;

    *lpDDHALInfo = ddNew;
}

// The callback used by Win9x drivers and the software rasterizers to help them
// parse execute buffers.
HRESULT CALLBACK D3DParseUnknownCommand (LPVOID lpvCommands,
					 LPVOID *lplpvReturnedCommand)
{
    LPD3DINSTRUCTION lpInstr = (LPD3DINSTRUCTION) lpvCommands;

    // Initialize the return address to the command's address
    *lplpvReturnedCommand = lpvCommands;

    switch (lpInstr->bOpcode)
    {
    case D3DOP_PROCESSVERTICES:
        // cannot do D3DOP_PROCESSVERTICES here even for in-place copy because we
        // generally don't pass the execute buffer's vertex buffer as the DP2 vertex buffer
        return D3DERR_COMMAND_UNPARSED;
    case D3DOP_SPAN:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof (D3DINSTRUCTION) +
                                          lpInstr->wCount *
                                          lpInstr->bSize);
        return DD_OK;
    case D3DDP2OP_VIEWPORTINFO:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof(D3DHAL_DP2COMMAND) +
                                          lpInstr->wCount *
                                          sizeof(D3DHAL_DP2VIEWPORTINFO));
        return DD_OK;
    case D3DDP2OP_WINFO:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof(D3DHAL_DP2COMMAND) +
                                          lpInstr->wCount *
                                          sizeof(D3DHAL_DP2WINFO));
        return DD_OK;
    case D3DOP_MATRIXLOAD:
    case D3DOP_MATRIXMULTIPLY:
    case D3DOP_STATETRANSFORM:
    case D3DOP_STATELIGHT:
    case D3DOP_TEXTURELOAD:
    case D3DOP_BRANCHFORWARD:
    case D3DOP_SETSTATUS:
    case D3DOP_EXIT:
        return D3DERR_COMMAND_UNPARSED;
    default:
        return DDERR_GENERIC;
    }
}

/*
 * fetchModeXData
 */
LPDDRAWI_DIRECTDRAW_GBL fetchModeXData(
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		LPDDHALMODEINFO pmi,
                HANDLE hDDVxd )
{
    DDHALINFO                   ddhi;
    LPDDRAWI_DIRECTDRAW_GBL     new_pdrv;
    DDPIXELFORMAT               dpf;
#ifdef WINNT
    DDHALMODEINFO               dmi;
#endif

    /*
     * initialize the DDHALINFO struct
     */
    memset( &ddhi, 0, sizeof( ddhi ) );
    ddhi.dwSize = sizeof( ddhi );

    /*
     * capabilities supported (none)
     */
    ddhi.ddCaps.dwCaps = 0;
    ddhi.ddCaps.dwFXCaps = 0;
    ddhi.ddCaps.dwCKeyCaps = 0;
    ddhi.ddCaps.ddsCaps.dwCaps = 0;

    /*
     * pointer to primary surface.
     */
    if ( pmi->wFlags & DDMODEINFO_STANDARDVGA )
    {
        ddhi.vmiData.fpPrimary = 0xa0000;
    }
    else
    {
        //This needs to be SCREEN_PTR or the HEL won't realize it's a bad address
        //(since when restoring display modes, restoreSurface for the primary will
        //call into AllocSurfaceMem which will triviallt allocate the primary surface
        //by setting fpVidMem == fpPrimaryOrig which will have been set to whatever
        //we set here.
        ddhi.vmiData.fpPrimary = 0xffbadbad;
    }

    /*
     * build mode and pixel format info
     */
    ddhi.vmiData.dwDisplayHeight = pmi->dwHeight;
    ddhi.vmiData.dwDisplayWidth = pmi->dwWidth;
    ddhi.vmiData.lDisplayPitch = pmi->lPitch;
    BuildPixelFormat( NULL, pmi, &dpf );
    ddhi.vmiData.ddpfDisplay = dpf;

    /*
     * fourcc code information
     */
    ddhi.ddCaps.dwNumFourCCCodes = 0;
    ddhi.lpdwFourCC = NULL;

    /*
     * Fill in heap info
     */
    ddhi.vmiData.dwNumHeaps = 0;
    ddhi.vmiData.pvmList = NULL;

    /*
     * required alignments of the scanlines of each kind of memory
     * (DWORD is the MINIMUM)
     */
    ddhi.vmiData.dwOffscreenAlign = sizeof( DWORD );
    ddhi.vmiData.dwTextureAlign = sizeof( DWORD );
    ddhi.vmiData.dwZBufferAlign = sizeof( DWORD );

    /*
     * callback functions
     */
    ddhi.lpDDCallbacks = NULL;
    ddhi.lpDDSurfaceCallbacks = NULL;
    ddhi.lpDDPaletteCallbacks = NULL;

    /*
     * create the driver object
     */
#ifdef WINNT
    //We can only get into modex if the ddraw object has already been created:
    DDASSERT(pdrv);
    //Don't fetch the driver's caps
    ddhi.ddCaps.dwCaps = DDCAPS_NOHARDWARE;
    //Force the modex data into the pdd. This causes GetCurrentMode to be a noop.
    //pdrv->dwFlags |= DDRAWI_NOHARDWARE;
    pdrv->dmiCurrent.wWidth         =(WORD)pmi->dwWidth;
    pdrv->dmiCurrent.wHeight        =(WORD)pmi->dwHeight;
    pdrv->dmiCurrent.wBPP           =(BYTE)pmi->dwBPP;
    pdrv->dmiCurrent.wRefreshRate   =pmi->wRefreshRate;
    pdrv->dmiCurrent.wMonitorsAttachedToDesktop=(BYTE)GetNumberOfMonitorAttachedToDesktop();
#endif
    new_pdrv = DirectDrawObjectCreate( &ddhi, TRUE, pdrv, hDDVxd, NULL, 0 , 0 /* ATTENTION: No local flags for modex driver */ );
    DPF(5,"MODEX driver object's display is %dx%d, pitch is %d", ddhi.vmiData.dwDisplayHeight,ddhi.vmiData.dwDisplayWidth,ddhi.vmiData.lDisplayPitch);

    if( new_pdrv != NULL )
    {
	new_pdrv->dwFlags |= DDRAWI_MODEX;

        if ( pmi->wFlags & DDMODEINFO_STANDARDVGA )
        {
	    new_pdrv->dwFlags |= DDRAWI_STANDARDVGA;
        }
#ifdef WIN95
	if( new_pdrv->dwPDevice != 0 )
	{
	    new_pdrv->dwPDevice = 0;
	    new_pdrv->lpwPDeviceFlags = (WORD *)&dwFakeFlags;
	}
#endif //WIN95
    }
    DPF( 5, "ModeX DirectDraw object created (Standard VGA flag:%d)", (new_pdrv->dwFlags & DDRAWI_STANDARDVGA) ? 1 : 0 );
    DPF( 5, "	width=%ld, height=%ld, %ld bpp",
			new_pdrv->vmiData.dwDisplayWidth,
			new_pdrv->vmiData.dwDisplayHeight,
			new_pdrv->vmiData.ddpfDisplay.dwRGBBitCount );
    DPF( 5, "   lDisplayPitch = %ld", new_pdrv->vmiData.lDisplayPitch );

    return new_pdrv;

} /* fetchModeXData */

#ifdef WINNT
/*
 * GetDriverInfo2
 */
DWORD APIENTRY GetDriverInfo2(LPDDRAWI_DIRECTDRAW_GBL lpGbl,
                              DWORD* pdwDrvRet, 
                              DWORD dwType,
                              DWORD dwSize,
                              void* pBuffer)
{
    DD_GETDRIVERINFO2DATA*          pGDI2Data;
    DWORD                           ret;
    DDHAL_GETDRIVERINFODATA         gdidata;

    // We cannot do anything if the driver doesn't support GetDriverInfo2
    if ((lpGbl == NULL) || (!(lpGbl->dwFlags & DDRAWI_DRIVERINFO2)))
    {
        return 0;
    }
       
    // Setup GetDriverInfo2 call
    pGDI2Data = (DD_GETDRIVERINFO2DATA*) pBuffer;

    memset(pGDI2Data, 0, sizeof(*pGDI2Data));
    pGDI2Data->dwReserved       = sizeof(DD_STEREOMODE);
    pGDI2Data->dwMagic          = D3DGDI2_MAGIC;
    pGDI2Data->dwType           = dwType;
    pGDI2Data->dwExpectedSize   = dwSize;

    ret = GetDriverInfo(lpGbl->pGetDriverInfo, 
                        &gdidata,
                        pBuffer,
                        sizeof(DD_STEREOMODE),
                        &GUID_GetDriverInfo2, 
                        lpGbl,
                        TRUE /* bInOut */);

    *pdwDrvRet = gdidata.ddRVal;
    return ret;
}

/*
 * NotifyDriverOfFreeAliasedLocks
 *
 *  This notifies the driver that we have unlocked all outstanding aliased
 *  locks on the device.  It is possible to have multiple GBLs using the same
 *  physical device, so we need to handle that.
 */
void NotifyDriverOfFreeAliasedLocks()
{
    DD_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_temp;
    BOOL                        bSkipThisOne;

    if (dwNumLockedWhenModeSwitched == 0)
    {
        // Notify each device that all outstanding syslocks are gone
        fad.dwProcessId = GetCurrentProcessId();
        pdd_lcl = lpDriverLocalList;
        while (pdd_lcl != NULL)
        {
            bSkipThisOne = FALSE;
            pdd_temp = lpDriverLocalList;
            while ((pdd_temp != NULL) &&
                   (pdd_temp != pdd_lcl))
            {
                if (pdd_temp->lpGbl == pdd_lcl->lpGbl)
                {
                    bSkipThisOne = TRUE;
                    break;
                }
                pdd_temp = pdd_temp->lpLink;
            }

            if (!bSkipThisOne)
            {
                GetDriverInfo2(pdd_lcl->lpGbl, &dwDrvRet, 
                               D3DGDI2_TYPE_FREE_DEFERRED_AGP,
                               sizeof(fad), &fad);
            }
            pdd_lcl = pdd_lcl->lpLink;
        }
    }
}

/*
 * NotifyDriverToDeferFrees
 *
 *  This notifies the driver that we are doing a mode change and they
 *  should start defering AGP free if they need to.
 */
void NotifyDriverToDeferFrees()
{
    DD_FREE_DEFERRED_AGP_DATA   fad;
    DWORD                       dwDrvRet;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_temp;
    BOOL                        bSkipThisOne;

    // Notify each device that all outstanding syslocks are gone
    fad.dwProcessId = GetCurrentProcessId();
    pdd_lcl = lpDriverLocalList;
    while (pdd_lcl != NULL)
    {
        bSkipThisOne = FALSE;
        pdd_temp = lpDriverLocalList;
        while ((pdd_temp != NULL) &&
               (pdd_temp != pdd_lcl))
        {
            if (pdd_temp->lpGbl == pdd_lcl->lpGbl)
            {
                bSkipThisOne = TRUE;
                break;
            }
            pdd_temp = pdd_temp->lpLink;
        }

        if (!bSkipThisOne)
        {
            GetDriverInfo2(pdd_lcl->lpGbl, &dwDrvRet, 
                           D3DGDI2_TYPE_DEFER_AGP_FREES,
                           sizeof(fad), &fad);
        }
        pdd_lcl = pdd_lcl->lpLink;
    }
}

/*
 * CheckAliasedLocksOnModeChange
 *
 *  On NT we have to tell the driver when we are done using all surfaces that were 
 *  locked with NOSYSLOCK so they can properly handle the case when they manage 
 *  their own AGP heaps.
 */
void CheckAliasedLocksOnModeChange()
{
    DWORD                       dwGDI2Ret;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_lcl;
    LPDDRAWI_DIRECTDRAW_LCL     pdd_temp;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    BOOL                        bSkipThisOne;

    // For each device, figure out how many surfs are holding aliased locks and
    // mark the surfaces. 
    dwNumLockedWhenModeSwitched = 0;
    pdd_lcl = lpDriverLocalList;
    while (pdd_lcl != NULL)
    {
        // if we have already processed this GBL, don't do it again!
        bSkipThisOne = FALSE;
        pdd_temp = lpDriverLocalList;
        while ((pdd_temp != NULL) &&
               (pdd_temp != pdd_lcl))
        {
            if (pdd_temp->lpGbl == pdd_lcl->lpGbl)
            {
                bSkipThisOne = TRUE;
                break;
            }
            pdd_temp = pdd_temp->lpLink;
        }
        
        if (!bSkipThisOne &&
            (pdd_lcl->lpGbl != NULL))
        {
            // We need to start fresh with each device, so clear all flags we
            // have outstanding as to whether the surface has an outstanding
            // NOSYSLOCK lock.  
            psurf_int = pdd_lcl->lpGbl->dsList;
            while (psurf_int != NULL)
            {
                if (psurf_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED)
                {
                    psurf_int->lpLcl->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
                }
                psurf_int = psurf_int->lpLink;
            }

            // Now we go back through them and re-mark them.
            psurf_int = pdd_lcl->lpGbl->dsList;
            while (psurf_int != NULL)
            {
                if ((psurf_int->lpLcl->lpGbl->dwUsageCount > 0) &&
                    !(psurf_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_NOTIFYWHENUNLOCKED))
                {
                    // The code below relies on the fact that the NT kernel
                    // cannot handle multiple locks to the same surface if any
                    // one of them is a NOSYSLOCK.  If this ever changes, this
                    // code needs to be changed.
                    if (psurf_int->lpLcl->lpGbl->dwGlobalFlags & DDRAWISURFGBL_LOCKNOTHOLDINGWIN16LOCK)
                    {
                        psurf_int->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
                        dwNumLockedWhenModeSwitched++;
                    }
                    else if ((psurf_int->lpLcl->lpGbl->lpRectList != NULL) &&
                             (psurf_int->lpLcl->lpGbl->lpRectList->dwFlags & ACCESSRECT_NOTHOLDINGWIN16LOCK))
                    {
                        psurf_int->lpLcl->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_NOTIFYWHENUNLOCKED;
                        dwNumLockedWhenModeSwitched++;
                    }
                }
                psurf_int = psurf_int->lpLink;
            }
       }
       pdd_lcl = pdd_lcl->lpLink;
    }

    // Now see if we can notify the drivers to free the surfaces or not.
    if ((dwNumLockedWhenModeSwitched == 0) &&
        (lpDriverLocalList != NULL))
    {
        // For DX9, add logic here to handle bad PDEVs
        NotifyDriverOfFreeAliasedLocks();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddgamma.c ===
/*==========================================================================
 *  Copyright (C) 1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddgamma.c
 *  Content:    Implements the DirectDrawGammaControl interface, which
 *              allows controlling the gamma for the primary surface.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   05-mar-98  smac    created
 *
 ***************************************************************************/
#include "ddrawpr.h"
#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#define DPF_MODNAME "DirectDrawGammaControl"

#define DISPLAY_STR     "display"


/*
 * InitGamma
 *
 * Called while initializing the DDraw object.  It determines whether the
 * driver can support loadable gamma ramps and if so, it sets the
 * DDCAPS2_PRIMARYGAMMA cap bit.
 */
VOID InitGamma( LPDDRAWI_DIRECTDRAW_GBL pdrv, LPSTR szDrvName )
{
    /*
     * In NT, we set the DDCAPS2_PRIMARYGAMMA cap in kernel mode, but on Win9X
     * we just call GetDeviceGammaRamp and if it works, we assume that the device
     * supports gamma.  However, GetDeviceGammaRamp was obviously not well tested
     * in Win9X because GDI calls a NULL pointer in some instances where the driver
     * doesn't support downloadable gamma ramps.  The only way to work around
     * this is to look at the HDC and detect the situations that crash
     * and then know not to attemp gamma in those situations.  We have to do
     * this in DDRAW16.
     */
    #ifdef WIN95
        LPWORD      lpGammaRamp;
        HDC         hdc;

        pdrv->ddCaps.dwCaps2 &= ~DDCAPS2_PRIMARYGAMMA;
        lpGammaRamp = (LPWORD) LocalAlloc( LMEM_FIXED, sizeof( DDGAMMARAMP ) );
        if( NULL != lpGammaRamp )
        {
            hdc = DD_CreateDC( szDrvName );
            if( DD16_AttemptGamma(hdc) &&       
                GetDeviceGammaRamp( hdc, lpGammaRamp ) )
            {
                pdrv->ddCaps.dwCaps2 |= DDCAPS2_PRIMARYGAMMA;
            }
            DD_DoneDC( hdc );
            LocalFree( (HLOCAL) lpGammaRamp );
        }
    #endif
    if( bGammaCalibratorExists && 
        ( pdrv->ddCaps.dwCaps2 & DDCAPS2_PRIMARYGAMMA ) )
    {
        pdrv->ddCaps.dwCaps2 |= DDCAPS2_CANCALIBRATEGAMMA;
    }
    else
    {
        pdrv->ddCaps.dwCaps2 &= ~DDCAPS2_CANCALIBRATEGAMMA;
    }
}

/*
 * SetGamma
 *
 * Sets the new GammaRamp.  If it is being set for the first time, we will
 * save the old gamma ramp so we can restore it later.
 */
BOOL SetGamma( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    BOOL bRet = TRUE;

    if( !( this_lcl->dwFlags & DDRAWISURF_SETGAMMA ) )
    {
        bRet = GetDeviceGammaRamp( (HDC) pdrv_lcl->hDC,
            this_lcl->lpSurfMore->lpOriginalGammaRamp );
    }
    if( bRet )
    {
        #ifdef WINNT
            bRet = DdSetGammaRamp( pdrv_lcl, (HDC) pdrv_lcl->hDC,
	        this_lcl->lpSurfMore->lpGammaRamp);
        #else
            bRet = SetDeviceGammaRamp( (HDC) pdrv_lcl->hDC,
                this_lcl->lpSurfMore->lpGammaRamp );
        #endif
        this_lcl->dwFlags |= DDRAWISURF_SETGAMMA;
    }
    if( !bRet )
    {
        return DDERR_UNSUPPORTED;
    }
    return DD_OK;
}

/*
 * RestoreGamma
 *
 * Restores the old GammaRamp.
 */
VOID RestoreGamma( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    BOOL bRet;
    HDC hdcTemp = NULL;

    /*
     * If we are on DDHELP's thread cleaning up, then pdrv_lcl->hDC
     * will be invalid.  In this case, we need to temporarily create
     * a new DC to use.
     */
    if( ( pdrv_lcl->dwProcessId != GetCurrentProcessId() ) &&
        ( this_lcl->dwFlags & DDRAWISURF_SETGAMMA ) )
    {
        hdcTemp = (HDC) pdrv_lcl->hDC;
        if( _stricmp( pdrv_lcl->lpGbl->cDriverName, DISPLAY_STR ) == 0 )
        {
            (HDC) pdrv_lcl->hDC = DD_CreateDC( g_szPrimaryDisplay );
        }
        else
        {
            (HDC) pdrv_lcl->hDC = DD_CreateDC( pdrv_lcl->lpGbl->cDriverName );
        }
    }

    if( ( this_lcl->dwFlags & DDRAWISURF_SETGAMMA ) &&
        ( this_lcl->lpSurfMore->lpOriginalGammaRamp != NULL ))
    {
        #ifdef WINNT
    	    bRet = DdSetGammaRamp( pdrv_lcl, (HDC) pdrv_lcl->hDC,
		this_lcl->lpSurfMore->lpOriginalGammaRamp);
        #else
            bRet = SetDeviceGammaRamp( (HDC) pdrv_lcl->hDC,
                this_lcl->lpSurfMore->lpOriginalGammaRamp );
        #endif
    }
    this_lcl->dwFlags &= ~DDRAWISURF_SETGAMMA;

    if( hdcTemp != NULL )
    {
        DD_DoneDC( (HDC) pdrv_lcl->hDC );
        (HDC) pdrv_lcl->hDC = hdcTemp;
    }
}

/*
 * ReleaseGammaControl
 */
VOID ReleaseGammaControl( LPDDRAWI_DDRAWSURFACE_LCL lpSurface )
{
    RestoreGamma( lpSurface, lpSurface->lpSurfMore->lpDD_lcl );
    if( lpSurface->lpSurfMore->lpGammaRamp != NULL )
    {
        MemFree( lpSurface->lpSurfMore->lpGammaRamp );
        lpSurface->lpSurfMore->lpGammaRamp = NULL;
    }
    if( lpSurface->lpSurfMore->lpOriginalGammaRamp != NULL )
    {
        MemFree( lpSurface->lpSurfMore->lpOriginalGammaRamp );
        lpSurface->lpSurfMore->lpOriginalGammaRamp = NULL;
    }
}

/*
 * DD_Gamma_GetGammaControls
 */
HRESULT DDAPI DD_Gamma_GetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC,
                                    DWORD dwFlags, LPDDGAMMARAMP lpGammaRamp)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_MORE  lpSurfMore;
    BOOL                        bRet;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Gamma_GetGammaRamp");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDGC;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        lpSurfMore = this_lcl->lpSurfMore;

        if( (lpGammaRamp == NULL) || !VALID_BYTE_ARRAY( lpGammaRamp,
            sizeof( DDGAMMARAMP ) ) )
    	{
            DPF_ERR("DD_Gamma_GetGammaRamp: Invalid gamma table specified");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}

        if( dwFlags )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: Invalid flags specified");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }

        /*
         * For now, only support setting the gamma for the primary surface
         */
        if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: Must specify primary surface");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( !( pdrv_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_PRIMARYGAMMA ) )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: Device deos not support gamma ramps");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( SURFACE_LOST( this_lcl ) )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: Secified surface has been lost");
	    LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * If a gamma table has been set, return it; otherwise, get it from
     * the driver.
     */
    if( lpSurfMore->lpGammaRamp != NULL )
    {
        memcpy( lpGammaRamp, lpSurfMore->lpGammaRamp, sizeof( DDGAMMARAMP ) );
    }
    else
    {
        bRet = GetDeviceGammaRamp( (HDC) pdrv_lcl->hDC, (LPVOID) lpGammaRamp );
        if( bRet == FALSE )
        {
            DPF_ERR("DD_Gamma_GetGammaRamp: GetDeviceGammaRamp failed");
            LEAVE_DDRAW();
            return DDERR_UNSUPPORTED;
        }
    }

    LEAVE_DDRAW();
    return DD_OK;
}


/*
 * LoadGammaCalibrator
 */
VOID LoadGammaCalibrator( LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl )
{
    DDASSERT( pdrv_lcl->hGammaCalibrator == (ULONG_PTR) INVALID_HANDLE_VALUE );

    pdrv_lcl->hGammaCalibrator = (ULONG_PTR) LoadLibrary( szGammaCalibrator );
    if( pdrv_lcl->hGammaCalibrator != (ULONG_PTR) NULL )
    {
        pdrv_lcl->lpGammaCalibrator = (LPDDGAMMACALIBRATORPROC)
            GetProcAddress( (HANDLE)(pdrv_lcl->hGammaCalibrator), "CalibrateGammaRamp" );
        if( pdrv_lcl->lpGammaCalibrator == (ULONG_PTR) NULL )
        {
            FreeLibrary( (HMODULE) pdrv_lcl->hGammaCalibrator );
            pdrv_lcl->hGammaCalibrator = (ULONG_PTR) INVALID_HANDLE_VALUE;
        }
    }
    else
    {
        pdrv_lcl->hGammaCalibrator = (ULONG_PTR) INVALID_HANDLE_VALUE;
    }
}


/*
 * DD_Gamma_SetGammaRamp
 */
HRESULT DDAPI DD_Gamma_SetGammaRamp(LPDIRECTDRAWGAMMACONTROL lpDDGC,
                                    DWORD dwFlags, LPDDGAMMARAMP lpGammaRamp)
{
    LPDDRAWI_DDRAWSURFACE_INT   this_int;
    LPDDRAWI_DDRAWSURFACE_LCL   this_lcl;
    LPDDRAWI_DIRECTDRAW_LCL	pdrv_lcl;
    LPDDRAWI_DDRAWSURFACE_MORE  lpSurfMore;
    LPDDGAMMARAMP               lpTempRamp=NULL;
    HRESULT                     ddRVal;
    DWORD rc;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Gamma_SetGammaRamp");

    /*
     * Validate parameters
     */
    TRY
    {
        this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDGC;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
    	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
    	}
    	this_lcl = this_int->lpLcl;
	pdrv_lcl = this_lcl->lpSurfMore->lpDD_lcl;
        lpSurfMore = this_lcl->lpSurfMore;

        if( (lpGammaRamp != NULL) && !VALID_BYTE_ARRAY( lpGammaRamp,
            sizeof( DDGAMMARAMP ) ) )
    	{
            DPF_ERR("DD_Gamma_SetGammaRamp: Invalid gamma table specified");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
    	}

        if( dwFlags & ~DDSGR_VALID )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: Invalid flag specified");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( ( dwFlags & DDSGR_CALIBRATE ) && !bGammaCalibratorExists )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: DDSGR_CALIBRATE unsupported - Gamma calibrator not installed");
	    LEAVE_DDRAW();
            return DDERR_UNSUPPORTED;
        }

        /*
         * For now, only support setting the gamma for the primary surface
         */
        if( !( this_lcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE ) )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: Must specify primary surface");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( !( pdrv_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_PRIMARYGAMMA ) )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: Device deos not support gamma ramps");
	    LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        if( SURFACE_LOST( this_lcl ) )
        {
            DPF_ERR("DD_Gamma_SetGammaRamp: Secified surface has been lost");
	    LEAVE_DDRAW();
            return DDERR_SURFACELOST;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_EXCEPTION;
    }

    /*
     * lpGammaRamp is NULL, they are trying to restore the gamma.
     */
    if( lpGammaRamp == NULL )
    {
        ReleaseGammaControl( this_lcl );
    }
    else
    {
        /*
         * If they want to calibrate the gamma, we will do that now.  We will
         * copy this to a different buffer so that we don't mess up the one
         * passed in to us.
         */
        if( dwFlags & DDSGR_CALIBRATE )
        {
            /*
             * If the calibrator isn't loaded, do so now.
             */
            if( pdrv_lcl->hGammaCalibrator == (ULONG_PTR) INVALID_HANDLE_VALUE )
            {
                LoadGammaCalibrator( pdrv_lcl );
            }
            if( ( pdrv_lcl->hGammaCalibrator == (ULONG_PTR) INVALID_HANDLE_VALUE ) ||
                ( pdrv_lcl->lpGammaCalibrator == (ULONG_PTR) NULL ) )
            {
                /*
                 * If we were unable to load the library correctly,
                 * we shouldn't try again later.
                 */
                bGammaCalibratorExists = FALSE;
                DPF_ERR("DD_Gamma_SetGammaRamp: Unable to load gamma calibrator");
                LEAVE_DDRAW();
                return DDERR_UNSUPPORTED;
            }
            else
            {
                /*
                 * Call the calibrator to let it do it's thing.  First
                 * need to copy the buffer over so we don't mess with
                 * the one passed in.
                 */
                lpTempRamp = (LPDDGAMMARAMP) LocalAlloc( LMEM_FIXED,
                    sizeof( DDGAMMARAMP ) );
                if( lpTempRamp == NULL )
                {
                    DPF_ERR("DD_Gamma_SetGammaRamp: Insuficient memory for gamma ramps");
                    LEAVE_DDRAW();
                    return DDERR_OUTOFMEMORY;
                }
                memcpy( lpTempRamp, lpGammaRamp, sizeof( DDGAMMARAMP ) );
                lpGammaRamp = lpTempRamp;

                ddRVal = pdrv_lcl->lpGammaCalibrator( lpGammaRamp, pdrv_lcl->lpGbl->cDriverName );
                if( ddRVal != DD_OK )
                {
                    DPF_ERR("DD_Gamma_SetGammaRamp: Calibrator failed the call");
                    LocalFree( (HLOCAL) lpTempRamp );
                    LEAVE_DDRAW();
                    return ddRVal;
                }
            }
        }

        /*
         * If we are setting this for the first time, allocate memory to hold
         * the gamma ramps
         */
        if( lpSurfMore->lpOriginalGammaRamp == NULL )
        {
            lpSurfMore->lpOriginalGammaRamp = MemAlloc( sizeof( DDGAMMARAMP ) );
        }
        if( lpSurfMore->lpGammaRamp == NULL )
        {
            lpSurfMore->lpGammaRamp = MemAlloc( sizeof( DDGAMMARAMP ) );
        }

        /*
         * If we are in exlusive mode now, set the gamma ramp now; otherwise,
         * we'll let it get set when we enter excluisve mode.
         */
        if( lpSurfMore->lpGammaRamp && lpSurfMore->lpOriginalGammaRamp )
        {
            memcpy( lpSurfMore->lpGammaRamp, lpGammaRamp, sizeof( DDGAMMARAMP ) );
            if( pdrv_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE )
            {
                SetGamma( this_lcl, pdrv_lcl );
            }
            if( lpTempRamp != NULL )
            {
                LocalFree( (HLOCAL) lpTempRamp );
            }
        }
        else
        {
            /*
             * Out of memory condition.  Release the two ramps
             */
            if( lpTempRamp != NULL )
            {
                LocalFree( (HLOCAL) lpTempRamp );
            }
            if( lpSurfMore->lpGammaRamp != NULL )
            {
                MemFree( lpSurfMore->lpGammaRamp );
                lpSurfMore->lpGammaRamp = NULL;
            }
            if( lpSurfMore->lpOriginalGammaRamp != NULL )
            {
                MemFree( lpSurfMore->lpOriginalGammaRamp );
                lpSurfMore->lpOriginalGammaRamp = NULL;
            }
            DPF_ERR("DD_Gamma_SetGammaRamp: Insuficient memory for gamma ramps");
            LEAVE_DDRAW();
            return DDERR_OUTOFMEMORY;
        }
    }

    LEAVE_DDRAW();
    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddcsurf.c ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddcsurf.c
 *  Content:    DirectDraw support for for create surface
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   08-jan-95  craige  initial implementation
 *   13-jan-95  craige  re-worked to updated spec + ongoing work
 *   21-jan-95  craige  made 32-bit + ongoing work
 *   31-jan-95  craige  and even more ongoing work...
 *   21-feb-95  craige  work work work
 *   27-feb-95  craige  new sync. macros
 *   02-mar-95  craige  use pitch (not stride)
 *   07-mar-95  craige  keep track of flippable surfaces
 *   08-mar-95  craige  new APIs
 *   12-mar-95  craige  clean up surfaces after process dies...
 *   15-mar-95  craige  more HEL work
 *   19-mar-95  craige  use HRESULTs
 *   20-mar-95  craige  new CSECT work
 *   23-mar-95  craige  attachment work
 *   29-mar-95  craige  use GETCURRPID; only call emulation if
 *                      DDRAWI_EMULATIONINITIALIZED is set
 *   31-mar-95  craige  allow setting of hwnd & ckey
 *   01-apr-95  craige  happy fun joy updated header file
 *   12-apr-95  craige  don't use GETCURRPID
 *   13-apr-95  craige  EricEng's little contribution to our being late
 *   15-apr-95  craige  added GetBltStatus
 *   06-may-95  craige  use driver-level csects only
 *   15-may-95  kylej   changed overlay functions in ddSurfaceCallbacks
 *   22-may-95  craige  use MemAlloc16 to get selectors & ptrs
 *   24-may-95  kylej   Added AddOverlayDirtyRect and UpdateOverlayDisplay
 *   24-may-95  craige  added Restore
 *   04-jun-95  craige  added IsLost
 *   11-jun-95  craige  check for some
 *   16-jun-95  craige  removed fpVidMemOrig
 *   17-jun-95  craige  new surface structure
 *   18-jun-95  craige  allow duplicate surfaces
 *   19-jun-95  craige  automatically assign pitch for rectangular surfaces
 *   20-jun-95  craige  use fpPrimaryOrig when allocating primary
 *   21-jun-95  craige  use OBJECT_ISROOT
 *   25-jun-95  craige  one ddraw mutex
 *   26-jun-95  craige  reorganized surface structure
 *   27-jun-95  craige  added BltBatch; save display mode object was created in
 *   28-jun-95  craige  ENTER_DDRAW at very start of fns; always assign
 *                      back buffer count to first surface in flipping chain
 *   30-jun-95  kylej   extensive changes to support multiple primary
 *                      surfaces.
 *   30-jun-95  craige  clean pixel formats; use DDRAWI_HASPIXELFORMAT/HASOVERLAYDATA
 *   01-jul-95  craige  fail creation of primary/flipping if not in excl. mode
 *                      alloc overlay space on primary; cmt out streaming;
 *                      bug 99
 *   04-jul-95  craige  YEEHAW: new driver struct; SEH
 *   05-jul-95  craige  added Initialize
 *   08-jul-95  craige  restrict surface width to pitch
 *   09-jul-95  craige  export ComputePitch
 *   11-jul-95  craige  fail aggregation calls
 *   13-jul-95  craige  allow flippable offscreen & textures
 *   18-jul-95  craige  removed Flush
 *   22-jul-95  craige  bug 230 - unsupported starting modes
 *   10-aug-95  craige  misc caps combo bugs
 *   21-aug-95  craige  mode x support
 *   22-aug-95  craige  bug 641
 *   02-sep-95  craige  bug 854: disable > 640x480 flippable primary for rel1
 *   16-sep-95  craige  bug 1117: all primary surfaces were marked as root,
 *                      instead of just first one
 *   19-sep-95  craige  bug 1185: allow any width for explicit sysmem
 *   09-nov-95  colinmc slightly more validation of palettized surfaces
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   06-dec-95  colinmc added mip-map support
 *   09-dec-95  colinmc added execute buffer support
 *   14-dec-95  colinmc added shared back and z-buffer support
 *   18-dec-95  colinmc additional caps. bit validity checking
 *   22-dec-95  colinmc Direct3D support no longer conditional
 *   02-jan-96  kylej   handle new interface structures
 *   10-jan-96  colinmc IUnknowns aggregated by a surface is now a list
 *   18-jan-96  jeffno  NT hardware support in CreateSurface.
 *   29-jan-96  colinmc Aggregated IUnknowns now stored in additional local
 *                      surface data structure
 *   09-feb-96  colinmc Surface lost flag moved from global to local object
 *   15-feb-96  colinmc Changed message output on surface creation to make
 *                      creation of surfaces with unspecified memory caps
 *                      less frightening
 *   17-feb-96  colinmc Fixed execute buffer size limitation problem
 *   13-mar-96  jeffno  Correctly examine flags when allocating NT kernel
 *                      -mode structures
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   26-mar-96  colinmc Bug 14470: Compressed surface support
 *   14-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   17-may-96  craige  Bug 23299: non-power of 2 alignments
 *   23-may-96  colinmc Bug 24190: Explicit system memory surface with
 *                      no pixel format can cause heap corruption if
 *                      another app. changes display depth
 *   26-may-96  colinmc Bug 24552: Heap trash on emulated cards
 *   30-may-96  colinmc Bug 24858: Creating explicit flipping surfaces with
 *                      pixel format fails.
 *   11-jul-96  scottm  Fixed bug in IsDifferentPixelFormat
 *   10-oct-96  ketand  Created DDRAWSURFACE_GBL_MORE (for Physical Page table)
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   08-dec-96  colinmc Initial AGP support
 *   12-jan-96  colinmc More Win16 work
 *   18-jan-97  colinmc AGP support
 *   29-jan-97  jeffno  Mode13 support
 *   30-jan-97  jeffno  Allow surfaces wider than the primary
 *   09-feb-97  colinmc Enabled OWNDC for explicit system memory surfaces
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   08-mar-97  colinmc Support for DMA style AGP parts
 *   10-mar-97  colinmc Bug 5981 Explicit system memory surfaces with
 *                      pixel formats which match the primary don't
 *                      store thier pixel format and hence mutate on a mode
 *                      switch.
 *   24-mar-97  jeffno  Optimized Surfaces
 *   03-oct-97  jeffno  DDSCAPS2 and DDSURFACEDESC2
 *   31-oct-97 johnstep Persistent-content surfaces for Windows 9x
 *   18-dec-97 jvanaken CreateSurface now takes client-alloc'd surface memory.
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"


#ifdef WINNT
    #include "ddrawgdi.h"
#endif
#include "junction.h"
#include <limits.h>

/*
 * alignPitch - compute a new pitch that works with the requested alignment
 */
__inline DWORD alignPitch( DWORD pitch, DWORD align )
{
    DWORD       remain;

    /*
     * is it garbage we're getting?
     */
    if( align == 0 )
    {
	return pitch;
    }

    /*
     * is pitch already aligned properly?
     */
    remain = pitch % align;
    if( remain == 0 )
    {
	return pitch;
    }

    /*
     * align pitch to next boundary
     */
    return (pitch + (align - remain));

} /* alignPitch */

#define DPF_MODNAME     "CreateSurface"

/*
 * pixel formats we know we can work with...
 *
 * currently we don't included DDPF_PALETTEINDEXED1, DDPF_PALETTEINDEXED2 and
 * DDPF_PALETTEINDEXED4 in this list so if you want to use one of these you
 * must specify a valid pixel format and have a HEL/HAL that will accept such
 * surfaces.
 */

#define UNDERSTOOD_PF (                \
    DDPF_RGB               |           \
    DDPF_PALETTEINDEXED8   |           \
    DDPF_ALPHAPIXELS       |           \
    DDPF_ZBUFFER           |           \
    DDPF_LUMINANCE         |           \
    DDPF_BUMPDUDV          |           \
    DDPF_BUMPLUMINANCE     |           \
    DDPF_ALPHA             |           \
    DDPF_ZPIXELS)

#define DRIVER_SUPPORTS_DX6_ZBUFFERS(LPDDrawI_DDraw_GBL) ((LPDDrawI_DDraw_GBL)->dwNumZPixelFormats!=0)

// DP2 should always exist in a DX6 D3D driver
#define IS_DX6_D3DDRIVER(pDdGbl) (((pDdGbl)->lpD3DHALCallbacks3!=NULL) &&           \
				  ((pDdGbl)->lpD3DHALCallbacks3->DrawPrimitives2!=NULL))

typedef struct
{
    LPDDRAWI_DDRAWSURFACE_INT   *slist_int;
    LPDDRAWI_DDRAWSURFACE_LCL   *slist_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   *slist;
    BOOL                        listsize;
    BOOL                        listcnt;
    BOOL                        freelist;
    BOOL                        needlink;
} CSINFO;

/*
 * isPowerOf2
 *
 * if the input (dw) is a whole power of 2 returns TRUE and
 * *pPower is set to the exponent.
 * if the input (dw) is not a whole power of 2 returns FALSE and
 * *pPower is undefined.
 * NOTE: the caller can pass NULL for pPower.
 */
BOOL isPowerOf2(DWORD dw, int* pPower)
{
    int   n;
    int   nBits;
    DWORD dwMask;

    nBits = 0;
    dwMask = 0x00000001UL;
    for (n = 0; n < 32; n++)
    {
	if (dw & dwMask)
	{
	    if (pPower != NULL)
		*pPower = n;
	    nBits++;
	    if (nBits > 1)
		break;
	}
	dwMask <<= 1;
    }
    return (nBits == 1);
}

/*
 * freeSurfaceList
 *
 * free all surfaces in an associated surface list, and destroys any
 * resources associated with the surface struct.  This function is only called
 * before the surfaces have been linked into the global surface list and
 * before they have been AddRefed.
 */
static void freeSurfaceList( LPDDRAWI_DDRAWSURFACE_INT *slist_int,
			     int cnt )
{
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    int                         i;

    if( slist_int == NULL )
    {
	return;
    }

    for( i=0;i<cnt;i++ )
    {
	psurf_int = slist_int[i];
	psurf_lcl = psurf_int->lpLcl;
	/*
	 * if fpVidMem = DDHAL_PLEASEALLOC_BLOCKSIZE then we didn't actually allocate any
	 * video memory.  We still need to call the driver's DestroySurface but we don't want
	 * it to free any video memory because we haven't allocated any.  So we set the
	 * video memory pointer and the heap to NULL.
	 */
	if( (psurf_lcl->lpGbl->fpVidMem == DDHAL_PLEASEALLOC_BLOCKSIZE) ||
            //for the 3dfx driver which fails with fpVidMem correct and blocksizes setup..
            //blocksize is unioned with lpVidMemHeap so we crash in vidmemfree:
            ((psurf_lcl->lpGbl->dwBlockSizeY == (DWORD)psurf_lcl->lpGbl->wHeight) &&
             (psurf_lcl->lpGbl->dwBlockSizeX == (DWORD)psurf_lcl->lpGbl->wWidth)) )
	{
	    psurf_lcl->lpGbl->lpVidMemHeap = NULL;
	    psurf_lcl->lpGbl->fpVidMem = 0;
	}

	DestroySurface( psurf_lcl );

	DeleteAttachedSurfaceLists( psurf_lcl );

        if(IsD3DManaged(psurf_lcl))
        {
            if(psurf_lcl->lpSurfMore->lpRegionList)
            {
                MemFree( psurf_lcl->lpSurfMore->lpRegionList );
            }
        }
	/*
	 * NOTE: We DO NOT explicitly free the DDRAWI_DDRAWSURFACE_MORE
	 * structure pointed to by lpSurfMore as this is allocated in
	 * a single MemAlloc with the local surface structure.
	 */
	MemFree( psurf_lcl );
	MemFree( psurf_int );
    }

} /* freeSurfaceList */

/*
 * GetBytesFromPixels
 */
DWORD GetBytesFromPixels( DWORD pixels, UINT bpp )
{
    DWORD       bytes;

    bytes = pixels;
    switch( bpp ) {
    case 1:
	bytes = (bytes+7)/8;
	break;
    case 2:
	bytes = (bytes+3)/4;
	break;
    case 4:
	bytes = (bytes+1)/2;
	break;
    case 8:
	break;
    case 16:
	bytes *= 2;
	break;
    case 24:
	bytes *= 3;
	break;
    case 32:
	bytes *= 4;
	break;
    default:
	bytes = 0;
    }
    DPF( 5, "GetBytesFromPixels( %ld, %d ) = %d", pixels, bpp, bytes );

    return bytes;

} /* GetBytesFromPixels */

/*
 * getPixelsFromBytes
 */
static DWORD getPixelsFromBytes( DWORD bytes, UINT bpp )
{
    DWORD       pixels;

    pixels = bytes;
    switch( bpp ) {
    case 1:
	pixels *= 8L;
	break;
    case 2:
	pixels *= 4L;
	break;
    case 4:
	pixels *= 2L;
	break;
    case 8:
	break;
    case 16:
	pixels /= 2L;
	break;
    case 24:
	pixels /= 3L;
	break;
    case 32:
	pixels /= 4L;
	break;
    default:
	pixels = 0;
    }
    DPF( 5, "getPixelsFromBytes( %ld, %d ) = %d", bytes, bpp, pixels );
    return pixels;

} /* getPixelsFromBytes */

DWORD
GetSurfaceHandle(LPDWLIST lpSurfaceHandleList, LPDDRAWI_DDRAWSURFACE_LCL lpSurface)
{
    DWORD   handle=lpSurfaceHandleList->dwFreeList;
    if (0==handle)
    {
        // need to grow the dwList
        LPDDSURFACELISTENTRY  newList;
        DWORD   newsize;
        DWORD   index;
        if (NULL != lpSurfaceHandleList->dwList)
        {
            // old size(current dwFreeList) must not be zero
            DDASSERT(0 != lpSurfaceHandleList->dwList[0].nextentry);
            // new dwFreeList is always gonna be the old dwList[0].nextentry
            newsize = lpSurfaceHandleList->dwList[0].nextentry + LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
	        DPF_ERR( "MemAlloc failure in GetSurfaceHandle()" );
                return  0;
            }
            lpSurfaceHandleList->dwFreeList=lpSurfaceHandleList->dwList[0].nextentry;
            memcpy((LPVOID)newList,(LPVOID)lpSurfaceHandleList->dwList,
                lpSurfaceHandleList->dwList[0].nextentry*sizeof(DDSURFACELISTENTRY));
            MemFree(lpSurfaceHandleList->dwList);
        }
        else
        {
            newsize = LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
	        DPF_ERR( "MemAlloc failure in GetSurfaceHandle()" );
                return  0;
            }
            // start from one as we don't want 0 as a valid handle
            lpSurfaceHandleList->dwFreeList = 1;
        }
        lpSurfaceHandleList->dwList=newList;
        lpSurfaceHandleList->dwList[0].nextentry=newsize;

        for(index=lpSurfaceHandleList->dwFreeList;index<newsize-1;index++)
        {
            newList[index].nextentry=index+1;
        }
        // indicate end of new FreeList
        newList[newsize-1].nextentry=0;
        // now pop up one and assign it to handle
        handle=lpSurfaceHandleList->dwFreeList;
    }
    // handle slot is avialable so just remove it from freeList
    lpSurfaceHandleList->dwFreeList=lpSurfaceHandleList->dwList[handle].nextentry;
#if DBG
    lpSurfaceHandleList->dwList[handle].nextentry=0xDEADBEEF;
#endif
    lpSurfaceHandleList->dwList[handle].dwFlags=0;  //mark it's new
    lpSurfaceHandleList->dwList[handle].lpSurface=lpSurface;
    DDASSERT ( handle > 0);
    DDASSERT ( handle < lpSurfaceHandleList->dwList[0].nextentry);
    return handle;
}

void
ReleaseSurfaceHandle(LPDWLIST   lpSurfaceHandleList,DWORD handle)
{
    DDASSERT ( handle > 0);
    DDASSERT ( NULL != lpSurfaceHandleList->dwList);
    DDASSERT ( handle < lpSurfaceHandleList->dwList[0].nextentry);
#if DBG
    DDASSERT ( 0xDEADBEEF == lpSurfaceHandleList->dwList[handle].nextentry);
#endif
    lpSurfaceHandleList->dwList[handle].nextentry = lpSurfaceHandleList->dwFreeList;
    lpSurfaceHandleList->dwFreeList = handle;
}

LPDDRAWI_DDRAWSURFACE_LCL
WINAPI GetDDSurfaceLocal(LPDDRAWI_DIRECTDRAW_LCL this_lcl, DWORD handle, BOOL* isnew)
{
    DDASSERT ( NULL != this_lcl);
    DDASSERT ( NULL != SURFACEHANDLELIST(this_lcl).dwList);
    DDASSERT ( handle > 0);
    DDASSERT ( handle < SURFACEHANDLELIST(this_lcl).dwList[0].nextentry);
#if DBG
    DDASSERT ( 0xDEADBEEF == SURFACEHANDLELIST(this_lcl).dwList[handle].nextentry);
#endif
    if (FALSE == *isnew)
    {
        // only change flag if we are called from Reference Raterizer
        *isnew=(SURFACEHANDLELIST(this_lcl).dwList[handle].dwFlags==0);
        SURFACEHANDLELIST(this_lcl).dwList[handle].dwFlags=1;   //mark it's not new anymore
    }
    return SURFACEHANDLELIST(this_lcl).dwList[handle].lpSurface;
}
/*
 * AllocSurfaceMem
 *
 * Allocate the memory for all surfaces that need it...
 */
HRESULT AllocSurfaceMem(
		LPDDRAWI_DIRECTDRAW_LCL     this_lcl,
		LPDDRAWI_DDRAWSURFACE_LCL * slist_lcl,
		int                         nsurf)
{
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DWORD                       vm_width;
    DWORD                       vm_height;
    int                         scnt;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    DWORD                       caps;
    FLATPTR                     pvidmem;
    LPVIDMEM                    pheap;
    BOOL                        do_alloc;
    LONG                        newpitch;
    BOOL                        save_pitch;
    DWORD                       newcaps;
    DWORD                       forcemem = 0;
    BOOL                        anytype;

    this = this_lcl->lpGbl;
    DDASSERT( NULL != this );

    /*
     * allocate any remaining video memory needed
     */
    for( scnt=0;scnt<nsurf;scnt++ )
    {
	/*
	 * Stores new capabilities which are introduced depending on the memory
	 * heap allocated from.
	 */
	newcaps = 0UL;
	newpitch = 0;
	DPF( 5,V, "*** Alloc Surface %d ***", scnt );

	/*
	 * get preset video memory pointer
	 */
	pheap = NULL;
	psurf_lcl = slist_lcl[scnt];
	psurf = psurf_lcl->lpGbl;
	do_alloc = TRUE;
	pvidmem = psurf->fpVidMem;  //If this is a Restore, this will be non-null only if it's the gdi surface...
				    //that's the only surface that doesn't have its vram deallocated
				    //by DestroySurface. (assumption of jeffno 960122)
	DPF( 5,V, "pvidmem = %08lx", pvidmem );
	save_pitch = FALSE;
	if( pvidmem != (FLATPTR) NULL )
	{
	    if( pvidmem != (FLATPTR) DDHAL_PLEASEALLOC_BLOCKSIZE )
	    {
		do_alloc = FALSE;

#ifdef SHAREDZ
		/*
		 * NOTE: Previously if we did not do the alloc we
		 * overwrote the heap pointer with NULL. This broke
		 * the shared surfaces stuff. So now we assume that
		 * if the heap pointer is non-NULL we will preserve
		 * that value.
		 *
		 * !!! NOTE: Will this break stuff. Need to check this
		 * out.
		 */
		if( psurf->lpVidMemHeap )
		    pheap = psurf->lpVidMemHeap;
#endif
	    }
	    save_pitch = TRUE;
	}
	caps = psurf_lcl->ddsCaps.dwCaps;

	/*
	 * are we creating a primary surface?
	 */
	if( psurf->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) //caps & DDSCAPS_PRIMARYSURFACE )
	{
	    DPF(5,V,"allocing for primary (do_alloc==%d)",do_alloc);
	    if( do_alloc )
	    {
		pvidmem = this->fpPrimaryOrig;
	    }

	/*
	 * must be an offscreen surface of some kind
	 */
	}
	else
	{
            /*
             * NT handles all memory management issues in the kernel....
             */
#ifndef WINNT
	    /*
	     * get a video memory pointer if no other ptr specified
	     */
	    if( do_alloc )
	    {
		/*
		 * get area of surface
		 */
		if( pvidmem == (FLATPTR) DDHAL_PLEASEALLOC_BLOCKSIZE )
		{
		    vm_width = psurf->dwBlockSizeX;
		    vm_height = psurf->dwBlockSizeY;
		    DPF( 5,V, "Driver requested width=%ld, height%ld", vm_width, vm_height );
		}
		else
		{
		    if( caps & DDSCAPS_EXECUTEBUFFER )
		    {
			/*
			 * Execute buffers are long, thin surfaces for the purposes
			 * of VM allocation.
			 */
			vm_width  = psurf->dwLinearSize;
			vm_height = 1UL;
		    }
		    else
		    {
			/*
			 * This lPitch may have been expanded by ComputePitch
			 * to cover global alignment restrictions.
			 */
			vm_width  = (DWORD) labs( psurf->lPitch );
			vm_height = (DWORD) psurf->wHeight;
		    }
		    DPF( 5,V, "width = %ld, height = %ld", vm_width, vm_height );
		}

		/*
		 * try to allocate memory
		 */
		if( caps & DDSCAPS_SYSTEMMEMORY )
		{
		    pvidmem = 0;
		    pheap = NULL;
		}
		else
		{
                    DWORD dwFlags = 0;
                    HANDLE hvxd = GETDDVXDHANDLE( this_lcl );

                    if (psurf->dwGlobalFlags &
                        DDRAWISURFGBL_LATEALLOCATELINEAR)
                    {
                        dwFlags |= DDHA_SKIPRECTANGULARHEAPS;
                    }

		    if (this_lcl->lpGbl->ddCaps.dwCaps2 &
			DDCAPS2_NONLOCALVIDMEMCAPS)
		    {
			dwFlags |= DDHA_ALLOWNONLOCALMEMORY;
		    }

		    if (this_lcl->lpGbl->lpD3DGlobalDriverData != 0 &&
			(this_lcl->lpGbl->lpD3DGlobalDriverData->hwCaps.dwDevCaps &
			D3DDEVCAPS_TEXTURENONLOCALVIDMEM))
		    {
			dwFlags |= DDHA_ALLOWNONLOCALTEXTURES;
		    }

                    if (forcemem)
                    {
                        // Force allocations to the same memory type as the first 
                        psurf_lcl->ddsCaps.dwCaps &= ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                        psurf_lcl->ddsCaps.dwCaps |= forcemem;
                    }

		    pvidmem = DdHeapAlloc( this->vmiData.dwNumHeaps,
					   this->vmiData.pvmList,
					   hvxd, &this->vmiData,
					   vm_width, vm_height, psurf_lcl,
					   dwFlags, &pheap,
					   &newpitch, &newcaps, NULL );
		    if( pvidmem == (FLATPTR) NULL )
		    {
			pvidmem = DdHeapAlloc( this->vmiData.dwNumHeaps,
					       this->vmiData.pvmList,
					       hvxd, &this->vmiData,
					       vm_width, vm_height, psurf_lcl,
					       dwFlags | DDHA_USEALTCAPS,
                                               &pheap, &newpitch, &newcaps, NULL );
		    }
                    
                    if (forcemem == 0)
                    {
                        // All surfaces must be of the same type as the first so we force 
                        // that type - newcaps contains either DDSCAPS_LOCALVIDMEM or 
                        // DDSCAPS_NONLOCALVIDMEM
                        forcemem = newcaps;
                        
                        // determines whether the memory type was explicit or not, so we know
                        // if we can change it if an allocation fails
                        anytype  = !(psurf_lcl->ddsCaps.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM));
                    }
                    else if (!pvidmem && anytype)
                    {
                        // Memory type was not explicity specified, so we're going to try the 
                        // other memory type

                        int i;
                        for (i=0; i<scnt; i++)
                        {
                            LPDDRAWI_DDRAWSURFACE_GBL tsurf = slist_lcl[i]->lpGbl;
                            DDASSERT(tsurf->lpVidMemHeap != NULL);
                            DDASSERT(tsurf->fpVidMem != (FLATPTR)NULL);
                            VidMemFree(tsurf->lpVidMemHeap, tsurf->fpVidMem);
                            tsurf->fpVidMem = (FLATPTR)NULL;
                        }

                        // Back up to the first surface
                        scnt = -1;

                        // Force the other memory type
                        forcemem = (forcemem & DDSCAPS_LOCALVIDMEM) ? DDSCAPS_NONLOCALVIDMEM : DDSCAPS_LOCALVIDMEM;
                        
                        // Can no longer change memory type
                        anytype  = FALSE;
                        
                        DPF(4,"Not all surfaces in chain fit into 1 memory type, trying another");
                        continue;
                    }
		}
	    }
#endif //!WINNT
	}

	/*
	 * zero out overloaded fields
	 */
	psurf->dwBlockSizeX = 0;
        if (!(psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME))
        {
            // Don't zero this for volumes because it contains the slice pitch.
            // We will zero it later.
	    psurf->dwBlockSizeY = 0;
        }

	/*
	 * if no video memory found, fail
	 */
	if( pvidmem == (FLATPTR) NULL   && !(psurf->dwGlobalFlags & DDRAWISURFGBL_ISGDISURFACE) )//(caps & DDSCAPS_PRIMARYSURFACE) )
	{
#ifndef WINNT
	    DPF( 1, "Out of Video Memory. requested block: (%ld,%ld) (%ld bytes)",
		vm_width, vm_height, vm_height * vm_width );
	    // set the heap to null so we don't mistakenly try to free the memory in DestroySurface
#endif //not WINNT
	    psurf->lpVidMemHeap = NULL;
	    return DDERR_OUTOFVIDEOMEMORY;
	}

	/*
	 * save pointer to video memory that we are using
	 */
        if (pheap)
	    psurf->lpVidMemHeap = pheap->lpHeap;
        else
	    psurf->lpVidMemHeap = 0;

	psurf->fpVidMem = pvidmem;
	if( newpitch != 0 && !save_pitch && !( caps & DDSCAPS_EXECUTEBUFFER ) )
	{
	    /*
	     * The stride is not relevant for an execute buffer so we don't
	     * override it.
	     */
	    psurf->lPitch = newpitch;
	}

	/*
	 * Need to ensure that all video memory surfaces are tagged with
	 * either DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM even if
	 * the driver allocated them.
	 */
	psurf_lcl->ddsCaps.dwCaps |= newcaps;
	if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
	{
	    if( !( psurf_lcl->ddsCaps.dwCaps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) ) )
	    {
		/*
		 * Neither of local or non-local video memory have been set. In the
		 * case of a driver which is not AGP aware then just turn local
		 * video memory on. We also turn it on in the case of the primary
		 * (which we know is in local video memory).
		 *
		 * NOTE: AGP aware devices should set the appropriate caps bit if
		 * they take over surface allocation. However, we assume that if
		 * they haven't then its local video memory (taking over non-local
		 * allocation is hard). This is a very dodgy assumption and we should
		 * revist it.
		 */
                psurf_lcl->ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM;
		#ifdef DEBUG
		    #pragma message(REMIND("Fail creation by drivers that don't set vid mem qualifiers?"))
		    if( this_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM )
		    {
			DDASSERT( psurf_lcl->ddsCaps.dwCaps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) );
			DPF( 1, "AGP aware driver failed to set DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM" );
		    }
		#endif /* DEBUG */
	    }

            #ifndef WINNT
                if (forcemem == 0)
                {
                    // Make sure we allocate all subsequent memory from the same source as the primary
                    forcemem = psurf_lcl->ddsCaps.dwCaps & (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                    anytype  = FALSE;
                }
            #endif
	}

	/*
	 * If the surface has ended up in non-local video memory then we need to
	 * compute the physical memory pointer of the surface and store this away
	 * for driver usage.
	 */
	if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM )
	{
	    /*
	     * Computing the offset is simple but it requires that we have a
	     * heap pointer. If we don't have one we assume that the driver
	     * has filled the physical pointer in for us (as it has taken
	     * over surface creation from us).
	     */
	    if( NULL != psurf->lpVidMemHeap )
	    {
		DWORD   dwOffset;
		FLATPTR fpPhysicalVidMem;

		DDASSERT( 0UL != psurf->fpVidMem );
		DDASSERT( 0UL != psurf->lpVidMemHeap->fpGARTLin );

		dwOffset = (DWORD)( psurf->fpVidMem - psurf->lpVidMemHeap->fpGARTLin );
		fpPhysicalVidMem = psurf->lpVidMemHeap->fpGARTDev + dwOffset;

		GET_LPDDRAWSURFACE_GBL_MORE( psurf )->fpPhysicalVidMem = fpPhysicalVidMem;

		DPF( 5, "Non-local surface: fpVidmem = 0x%08x fpPhysicalVidMem = 0x%08x",
		     psurf->fpVidMem, fpPhysicalVidMem );
	    }
	}
    }
    return DD_OK;

} /* AllocSurfaceMem */


/*
 * checkCaps
 *
 * check to make sure various caps combinations are valid
 */
static HRESULT checkCaps( DWORD caps, LPDDRAWI_DIRECTDRAW_INT pdrv_int, LPDDSCAPSEX lpCapsEx )
{
    DDASSERT(lpCapsEx);

    /*
     * check for no caps at all!
     */
    if( caps == 0 )
    {
	DPF_ERR( "no caps specified" );
	return DDERR_INVALIDCAPS;
    }

    /*
     * check for bogus caps.
     */
    if( caps & ~DDSCAPS_VALID )
    {
	DPF_ERR( "Create surface: invalid caps specified" );
	return DDERR_INVALIDCAPS;
    }

    if (lpCapsEx->dwCaps2 & ~DDSCAPS2_VALID)
    {
	DPF_ERR( "Create surface: invalid caps2 specified" );
	return DDERR_INVALIDCAPS;
    }

    if (lpCapsEx->dwCaps3 & ~DDSCAPS3_VALID)
    {
	DPF_ERR( "Create surface: invalid caps3 specified" );
	return DDERR_INVALIDCAPS;
    }

    if (!(lpCapsEx->dwCaps2 & DDSCAPS2_VOLUME))
    {
        if (lpCapsEx->dwCaps4 & ~DDSCAPS4_VALID)
        {
	    DPF_ERR( "Create surface: invalid caps4 specified" );
	    return DDERR_INVALIDCAPS;
        }
    }

    /*
     * check for "read-only" caps
     */
    if( caps & (DDSCAPS_PALETTE|
		DDSCAPS_VISIBLE) )
    {
	DPF_ERR( "read-only cap specified" );
	return DDERR_INVALIDCAPS;
    }
    if ((caps & DDSCAPS_WRITEONLY) && !(caps & DDSCAPS_EXECUTEBUFFER) && !(lpCapsEx->dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)))
    {
	DPF_ERR( "read-only cap specified" );
	return DDERR_INVALIDCAPS;
    }

    // Make sure that DONOTPERSIST is used only in texture managed surfaces
    if ( lpCapsEx->dwCaps2 & DDSCAPS2_DONOTPERSIST )
    {
        if ( !(lpCapsEx->dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)) )
        {
            DPF_ERR( "DDSCAPS2_DONOTPERSIST can only be used with managed surfaces" );
            return DDERR_INVALIDCAPS;
        }
    }

    // Check for correct usage of texturemanage caps
    if ( lpCapsEx->dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE) )
    {
	if (0 == (caps & DDSCAPS_TEXTURE) && !(pdrv_int->lpLcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8))
	{
	    DPF_ERR("Managed surfaces must be textures");
	    return DDERR_INVALIDCAPS;
	}
    }
    if( !(~lpCapsEx->dwCaps2 & (DDSCAPS2_TEXTUREMANAGE | DDSCAPS2_D3DTEXTUREMANAGE)) )
    {
	DPF_ERR( "DDSCAPS2 flags DDSCAPS2_TEXTUREMANAGE and DDSCAPS2_D3DTEXTUREMANAGE are mutually exclusive" );
	return DDERR_INVALIDCAPS;
    }

    // Check if DDSCAPS2_HINTDYNAMIC, DDSCAPS2_HINTSTATIC, and DDSCAPS2_OPAQUE have
    // been correctly specified
    if (!(pdrv_int->lpLcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8))
    {
        if( (lpCapsEx->dwCaps2 & (DDSCAPS2_HINTDYNAMIC | DDSCAPS2_HINTSTATIC | DDSCAPS2_OPAQUE)) &&
	    !(caps & DDSCAPS_TEXTURE) )
        {
	    DPF_ERR( "DDSCAPS2 flags HINTDYNAMIC, HINTSTATIC and OPAQUE can only be used with textures" );
	    return DDERR_INVALIDCAPS;
        }
    }
    if( !(~lpCapsEx->dwCaps2 & (DDSCAPS2_HINTDYNAMIC | DDSCAPS2_HINTSTATIC)) )
    {
	DPF_ERR( "DDSCAPS2 flags HINTDYNAMIC and HINTSTATIC are mutually exclusive" );
	return DDERR_INVALIDCAPS;
    }
    else if( !(~lpCapsEx->dwCaps2 & (DDSCAPS2_HINTDYNAMIC | DDSCAPS2_OPAQUE)) )
    {
	DPF_ERR( "DDSCAPS2 flags HINTDYNAMIC and OPAQUE are mutually exclusive" );
	return DDERR_INVALIDCAPS;
    }
    else if( !(~lpCapsEx->dwCaps2 & (DDSCAPS2_HINTSTATIC | DDSCAPS2_OPAQUE)) )
    {
	DPF_ERR( "DDSCAPS2 flags HINTSTATIC and OPAQUE are mutually exclusive" );
	return DDERR_INVALIDCAPS;
    }

    /*
     * Valid optimized surface caps?
     */
    if( caps & DDSCAPS_OPTIMIZED )
    {
	// ATTENTION: Potential Apps-Compat problem!!
	DPF_ERR("Optimized surfaces cannot be created by create-surface");
	return DDERR_INVALIDCAPS;
#if 0 //Old code
	if( !(caps & DDSCAPS_TEXTURE) )
	{
	    DPF_ERR("Optimized surfaces can only be textures");
	    return DDERR_INVALIDCAPS;
	}
	if (caps & (DDSCAPS_OWNDC|DDSCAPS_3DDEVICE|DDSCAPS_ALLOCONLOAD))
	{
	    DPF_ERR("Invalid caps used in conjunction with DDSCAPS_OPTIMIZED");
	    return DDERR_INVALIDCAPS;
	}
	if ( (caps & (DDSCAPS_SYSTEMMEMORY|DDSCAPS_VIDEOMEMORY)) == 0)
	{
	    DPF_ERR("Optimized surfaces must be explicitly system or video memory");
	    return DDERR_INVALIDCAPS;
	}
#endif //0
    }

    /*
     * Check for memory type qualifiers
     */
    if( caps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) )
    {
	/*
	 * Neither flag is allowed with system memory.
	 */
	if( caps & DDSCAPS_SYSTEMMEMORY )
	{
	    DPF_ERR( "Cannot specify local or non-local video memory with DDSCAPS_SYSTEMMEMORY" );
	    return DDERR_INVALIDCAPS;
	}

	/*
	 * One of the other of LOCALVIDMEM or NONLOCALVIDMEM but NOT both.
	 */
	if( ( caps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) ) ==
	    ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) )
	{
	    DPF_ERR( "Cannot specify both DDSCAPS_LOCALVIDMEM and DDSCAPS_NONLOCALVIDMEM" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * For non-v1 interfaces, FRONTBUFFER and BACKBUFFER are read-only
     */
    if( pdrv_int->lpVtbl != &ddCallbacks )
    {
	if( caps & (DDSCAPS_FRONTBUFFER | DDSCAPS_BACKBUFFER) )
	{
	    DPF_ERR( "can't specify FRONTBUFFER or BACKBUFFER");
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * Rather than having lots of little checks for execute buffers
     * we simply check for what can mix with execute buffers right
     * up front - its not a lot - system and video memory only.
     */
    if( caps & DDSCAPS_EXECUTEBUFFER )
    {
	if( caps & ~( DDSCAPS_EXECUTEBUFFER |
		      DDSCAPS_SYSTEMMEMORY  |
		      DDSCAPS_VIDEOMEMORY |
                      DDSCAPS_WRITEONLY ) )
	{
	    DPF_ERR( "invalid caps specified with execute buffer" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for caps that don't mix with complex
     */
    if( caps & DDSCAPS_COMPLEX )
    {
	if( caps & ( DDSCAPS_FRONTBUFFER) )
	{
	    DPF_ERR( "DDSCAPS_FRONTBUFFER flag is with DDSCAPS_COMPLEX" );
	    return DDERR_INVALIDCAPS;
	}
	if( caps & DDSCAPS_BACKBUFFER )
	{
	    if( !(caps & DDSCAPS_ALPHA) && !(caps & DDSCAPS_ZBUFFER))
	    {
		DPF_ERR( "invalid CAPS flags: complex & backbuffer, but no alpha or zbuffer" );
		return DDERR_INVALIDCAPS;
	    }
	    if( (caps & DDSCAPS_FLIP))
	    {
		DPF_ERR( "invalid CAPS flags: complex & backbuffer & flip" );
		return DDERR_INVALIDCAPS;
	    }
	}
	if( !(caps & (DDSCAPS_BACKBUFFER|
		     DDSCAPS_OFFSCREENPLAIN|
		     DDSCAPS_OVERLAY|
		     DDSCAPS_TEXTURE|
		     DDSCAPS_PRIMARYSURFACE)) )
	{
	    DPF_ERR( "invalid CAPS flags: DDSCAPS_COMPLEX requires at least one of DDSCAPS_BACKBUFFER/DDSCAPS_OFFSCREENPLAIN/DDSCAPS_OVERLAY/DDSCAPS_TEXTURE/DDSCAPS_PRIMARYSURFACE to be set");
	    return DDERR_INVALIDCAPS;
	}
	if( !(caps & (DDSCAPS_FLIP|DDSCAPS_ALPHA|DDSCAPS_MIPMAP|DDSCAPS_ZBUFFER) ) &&
            !(lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP) )
	{
	    DPF_ERR( "invalid CAPS flags: must specify at least one of FLIP, ALPHA, ZBUFFER, 2_CUBEMAP or MIPMAP with COMPLEX" );
	    return DDERR_INVALIDCAPS;
	}
    /*
     * flags that can't be used if not complex
     */
    }
    else
    {
//      if( caps & DDSCAPS_BACKBUFFER  ) {
//          DPF_ERR( "invalid flags: backbuffer specfied for non-complex surface" );
//          return DDERR_INVALIDCAPS;
//      }
    }

    /*
     * check for caps that don't mix with backbuffer
     */
    if( caps & DDSCAPS_BACKBUFFER )
    {
	if( caps & (DDSCAPS_ALPHA |
		    DDSCAPS_FRONTBUFFER ) )
	{
	    DPF_ERR( "Invalid flags with backbuffer" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for flags that don't mix with a flipping surface
     */
    if( caps & DDSCAPS_FLIP )
    {
	if( !(caps & DDSCAPS_COMPLEX) )
	{
	    DPF_ERR( "invalid flags - flip but not complex" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for flags that don't mix with a primary surface
     */
    if( caps & DDSCAPS_PRIMARYSURFACE )
    {
	if( caps & (DDSCAPS_BACKBUFFER     |
		    DDSCAPS_OFFSCREENPLAIN |
		    DDSCAPS_OVERLAY        |
		    DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags with primary" );
	    return DDERR_INVALIDCAPS;
	}
	/* GEE: can't allow complex attachments to the primary surface
	 * because of our attachment code.  The user is allowed to build
	 * these manually.
	 */
	#ifdef USE_ALPHA
	if( (caps & DDSCAPS_ALPHA) && !(caps & DDSCAPS_FLIP) )
	{
	    DPF_ERR( "invalid flags with primary - alpha but not flippable" );
	    return DDERR_INVALIDCAPS;
	}
	#endif
	if( (caps & DDSCAPS_ZBUFFER) && !(caps & DDSCAPS_FLIP) )
	{
	    DPF_ERR( "invalid flags with primary - z but not flippable" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * flags that don't mix with a plain offscreen surface
     */
    if( caps & DDSCAPS_OFFSCREENPLAIN )
    {
	/*
	 * I see no reason not to allow offscreen plains to be created
	 * with alpha's and z-buffers. So they have been enabled.
	 */
	if( caps & (DDSCAPS_BACKBUFFER |
		    DDSCAPS_OVERLAY    |
		    DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags with offscreenplain" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for flags that don't mix with asking for an overlay
     */
    if( caps & DDSCAPS_OVERLAY )
    {
	/* GEE: should remove BACKBUFFER here for 3D stuff */
	if( caps & (DDSCAPS_BACKBUFFER     |
		    DDSCAPS_OFFSCREENPLAIN |
		    DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags with overlay" );
	    return DDERR_INVALIDCAPS;
	}
	if( (caps & DDSCAPS_ZBUFFER) && !(caps & DDSCAPS_FLIP) )
	{
	    DPF_ERR( "invalid flags with overlay - zbuffer but not flippable" );
	    return DDERR_INVALIDCAPS;
	}
	#ifdef USE_ALPHA
	if( (caps & DDSCAPS_ALPHA) && !(caps & DDSCAPS_FLIP) )
	{
	    DPF_ERR( "invalid flags with overlay - alpha but not flippable" );
	    return DDERR_INVALIDCAPS;
	}
	#endif
    }

    /*
     * check for flags that don't mix with asking for an texture
     */
    if( caps & DDSCAPS_TEXTURE )
    {
    }

    /*
     * validate MIPMAP
     */
    if( caps & DDSCAPS_MIPMAP )
    {
	/*
	 * Must be used in conjunction with TEXTURE.
	 */
	if( !( caps & DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags, mip-map specified but not texture" );
	    return DDERR_INVALIDCAPS;
	}

	/*
	 * Can't specify Z-buffer and mip-map.
	 */
	if( caps & DDSCAPS_ZBUFFER )
	{
	    DPF_ERR( "invalid flags, can't specify z-buffer with mip-map" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check for flags that don't mix with asking for a z-buffer
     */
    if( caps & DDSCAPS_ZBUFFER )
    {
	#ifdef USE_ALPHA
	if( caps & DDSCAPS_ALPHA )
	{
	    if( !(caps & DDSCAPS_COMPLEX) )
	    {
		DPF_ERR( "invalid flags, alpha and Z specified, but not complex" );
	    }
	}
	#endif

	if( ( caps & DDSCAPS_BACKBUFFER ) && !( caps & DDSCAPS_COMPLEX ) )
	{
	    /*
	     * Can't specify z-buffer and back-buffer unless you also specify
	     * complex.
	     */
	    DPF_ERR( "invalid flags, z-buffer and back-buffer specified but not complex" );
	    return DDERR_INVALIDCAPS;
	}
    }

#ifdef SHAREDZ
    /*
     * Validate SHAREDZBUFFER
     */
    if( caps & DDSCAPS_SHAREDZBUFFER )
    {
	if( !( caps & DDSCAPS_ZBUFFER ) )
	{
	    DPF_ERR( "invalid flags, shared z-buffer specified, but not z-buffer" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * Validate SHAREDBACKBUFFER
     */
    if( caps & DDSCAPS_SHAREDBACKBUFFER )
    {
	/*
	 * Either BACKBUFFER must be specified explicitly or we must be part of
	 * a complex flippable chain.
	 */
	if( !( ( caps & DDSCAPS_BACKBUFFER ) ||
	       ( ( caps & ( DDSCAPS_COMPLEX | DDSCAPS_FLIP ) ) ==
			  ( DDSCAPS_COMPLEX | DDSCAPS_FLIP ) ) ) )
	{
	    DPF_ERR("invalid flags, shared back-buffer specified but not back-buffer or flippable chain" );
	    return DDERR_INVALIDCAPS;
	}
    }
#endif

    /*
     * check for flags that don't mix with asking for an alpha surface
     */
    #ifdef USE_ALPHA
    if( caps & DDSCAPS_ALPHA )
    {
    }
    #endif

    /*
     * check for flags that don't mix with asking for an alloc-on-load surface
     */
    if( caps & DDSCAPS_ALLOCONLOAD )
    {
	/*
	 * Must be texture map currently.
	 */
	if( !( caps & DDSCAPS_TEXTURE ) )
	{
	    DPF_ERR( "invalid flags, allocate-on-load surfaces must be texture maps" );
	    return DDERR_INVALIDCAPS;
	}
    }

    if (lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES)
    {
        if (0 == (lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP) )
        {
            DPF_ERR("You must specify DDSCAPS2_CUBEMAP if you specify any of DDSCAPS2_CUBEMAP_*");
            return DDERR_INVALIDCAPS;
        }
    }

    /*
     * What doesn't mix with cubemaps
     */
    if (lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP)
    {
        if (
           (caps & ~(
            DDSCAPS_SYSTEMMEMORY |
            DDSCAPS_VIDEOMEMORY |
            DDSCAPS_NONLOCALVIDMEM |
            DDSCAPS_LOCALVIDMEM |
            DDSCAPS_TEXTURE |
            DDSCAPS_3DDEVICE |
            DDSCAPS_MIPMAP |
            DDSCAPS_COMPLEX |
            DDSCAPS_OWNDC |
            DDSCAPS_ALLOCONLOAD |
            DDSCAPS_WRITEONLY |
            DDSCAPS_VIDEOPORT ) )
            ||
           (lpCapsEx->dwCaps2 & ~(
            DDSCAPS2_PERSISTENTCONTENTS |
            DDSCAPS2_RESERVED4 |
            DDSCAPS2_HINTDYNAMIC |
            DDSCAPS2_HINTSTATIC |
            DDSCAPS2_TEXTUREMANAGE |
            DDSCAPS2_D3DTEXTUREMANAGE |
            DDSCAPS2_OPAQUE |
            DDSCAPS2_CUBEMAP |
            DDSCAPS2_CUBEMAP_ALLFACES |
            DDSCAPS2_DONOTPERSIST |
            DDSCAPS2_HINTANTIALIASING |
            DDSCAPS2_DONOTCREATED3DTEXOBJECT |
            DDSCAPS2_NOTUSERLOCKABLE |
            DDSCAPS2_DEINTERLACE ) )
            ||
            lpCapsEx->dwCaps3
            ||
            lpCapsEx->dwCaps4
            )
        {
            DPF_ERR("Invalid surface caps with DDSCAPS2_CUBEMAP");
            DPF_ERR("   Valid additional surface caps are:");
            DPF_ERR("   DDSCAPS_SYSTEMMEMORY ");
            DPF_ERR("   DDSCAPS_VIDEOMEMORY ");
            DPF_ERR("   DDSCAPS_NONLOCALVIDMEM ");
            DPF_ERR("   DDSCAPS_LOCALVIDMEM ");
            DPF_ERR("   DDSCAPS_TEXTURE ");
            DPF_ERR("   DDSCAPS_3DDEVICE ");
            DPF_ERR("   DDSCAPS_MIPMAP ");
            DPF_ERR("   DDSCAPS_COMPLEX ");
            DPF_ERR("   DDSCAPS_OWNDC ");
            DPF_ERR("   DDSCAPS_ALLOCONLOAD ");
            DPF_ERR("   DDSCAPS_WRITEONLY ");
            DPF_ERR("   DDSCAPS_VIDEOPORT");
            DPF_ERR("   DDSCAPS2_PERSISTENTCONTENTS ");
            DPF_ERR("   DDSCAPS2_CUBEMAP_* ");
            DPF_ERR("   DDSCAPS2_HINTDYNAMIC ");
            DPF_ERR("   DDSCAPS2_HINTSTATIC ");
            DPF_ERR("   DDSCAPS2_TEXTUREMANAGE ");
            DPF_ERR("   DDSCAPS2_D3DTEXTUREMANAGE ");
            DPF_ERR("   DDSCAPS2_OPAQUE ");
            DPF_ERR("   DDSCAPS2_HINTANTIALIASING");
            DPF_ERR("   DDSCAPS2_DONOTPERSIST");
            DPF_ERR("   DDSCAPS2_DEINTERLACE");
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Must be either a texture or a render target
         */
        if ( (caps & (DDSCAPS_3DDEVICE|DDSCAPS_TEXTURE)) == 0)
        {
            DPF_ERR("DDSCAPS2_CUBEMAP requires DDSCAPS_3DDEVICE and/or DDSCAPS_TEXTURE");
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Must be complex
         */
        if ( (caps & DDSCAPS_COMPLEX) == 0)
        {
            DPF_ERR("DDSCAPS2_CUBEMAP requires DDSCAPS_COMPLEX");
            return DDERR_DDSCAPSCOMPLEXREQUIRED;
        }

        /*
         * Must specify at least one face
         */
        if ( (lpCapsEx->dwCaps2 & DDSCAPS2_CUBEMAP_ALLFACES) == 0)
        {
            DPF_ERR("DDSCAPS2_CUBEMAP requires at least one face (i.e. at least one DDSCAPS2_CUBEMAP_POSITIVE/NEGATIVE");
            return DDERR_INVALIDPARAMS;
        }

        /*
         * Device must support the caps. Note down here, we never see neither
         * memory type. We are guaranteed video or system
         */
        {
            DWORD dwCaps2 = 0;
            if ( caps & DDSCAPS_VIDEOMEMORY )
            {
                dwCaps2 = pdrv_int->lpLcl->lpGbl->ddsCapsMore.dwCaps2;
            }
            else if ( caps & DDSCAPS_SYSTEMMEMORY )
            {
                dwCaps2 = pdrv_int->lpLcl->lpGbl->ddsHELCapsMore.dwCaps2;
            }
            else
            {
                DDASSERT(!"Neither video nor system caps set on cubemap");
            }
            if ( ( dwCaps2 & DDSCAPS2_CUBEMAP ) == 0 )
            {
                DPF(0,"CubeMaps not supported in %s memory", (caps & DDSCAPS_VIDEOMEMORY) ? "video":"system");
                return DDERR_UNSUPPORTED;
            }
        }
    }
	// DX7Stereo
	if (lpCapsEx->dwCaps2 & DDSCAPS2_STEREOSURFACELEFT)
	{
		if ((caps & DDSCAPS_PRIMARYSURFACE)==0 ||
			(caps & DDSCAPS_FLIP)==0 ||
			(caps & DDSCAPS_COMPLEX)==0 ||
                        (caps & DDSCAPS_VIDEOMEMORY)==0)
		{
			DPF(0,"DDSCAPS2_STEREOSURFACELEFT only supported with: ");
                        DPF(0,"  DDSCAPS_PRIMARYSURFACE & DDSCAPS_FLIP & DDSCAPS_COMPLEX & DDSCAPS_VIDEOMEMORY");
			return DDERR_UNSUPPORTED;
		}
	}
    return DD_OK;
} /* checkCaps */

#ifdef SHAREDZ
/*
 * For this initial version of shared back and z support the shared back and
 * z-buffers can only be full screen. We don't allow a specification of size.
 */
#define CAPS_NOHEIGHT_REQUIRED ( DDSCAPS_PRIMARYSURFACE | DDSCAPS_EXECUTEBUFFER | DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER )
#define CAPS_NOWIDTH_REQUIRED  ( DDSCAPS_PRIMARYSURFACE | DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER )
#else
#define CAPS_NOHEIGHT_REQUIRED ( DDSCAPS_PRIMARYSURFACE | DDSCAPS_EXECUTEBUFFER )
#define CAPS_NOWIDTH_REQUIRED  ( DDSCAPS_PRIMARYSURFACE | DDSCAPS_EXECUTEBUFFER )
#endif

/*
 * checkSurfaceDesc
 *
 * make sure a provided surface description is OK
 */
HRESULT checkSurfaceDesc(
		LPDDSURFACEDESC2 lpsd,
		LPDDRAWI_DIRECTDRAW_GBL pdrv,
		DWORD FAR *psflags,
		BOOL emulation,
		BOOL real_sysmem,
		LPDDRAWI_DIRECTDRAW_INT pdrv_int )
{
    DWORD       sdflags;
    DWORD       pfflags;
    DWORD       caps;
    DDSCAPSEX   capsEx;
    HRESULT     ddrval;
    DWORD       bpp;
    BOOL        halonly;
    BOOL        helonly;
    int         wPower;
    int         hPower;

    if( emulation )
    {
	helonly = TRUE;
	halonly = FALSE;
    } else {
	helonly = FALSE;
	halonly = TRUE;
    }


    /*
     * we assume caps always - DDSD_CAPS is default
     */
    sdflags = lpsd->dwFlags;
    caps = lpsd->ddsCaps.dwCaps;
    capsEx = lpsd->ddsCaps.ddsCapsEx;

    /*
     * check complex
     */
    if( !(caps & DDSCAPS_COMPLEX) )
    {
	if( sdflags & DDSD_BACKBUFFERCOUNT )
	{
	    DPF_ERR( "backbuff count on non-complex surface" );
	    return DDERR_INVALIDCAPS;
	}
	if( sdflags & DDSD_MIPMAPCOUNT )
	{
	    DPF_ERR( "mip-map count on non-complex surface" );
	    return DDERR_INVALIDCAPS;
	}
    }
    else
    {
	if( ( sdflags & DDSD_BACKBUFFERCOUNT ) && ( sdflags & DDSD_MIPMAPCOUNT ) )
	{
	    DPF_ERR( "Currently can't specify both a back buffer and mip-map count" );
	    return DDERR_INVALIDPARAMS;
	}

    }

    /*
     * check flip
     */
    if( caps & DDSCAPS_FLIP )
    {
	if( !(caps & DDSCAPS_COMPLEX) )
	{
	    DPF_ERR( "flip specified without complex" );
	    return DDERR_INVALIDCAPS;
	}
	if( !(sdflags & DDSD_BACKBUFFERCOUNT) || (lpsd->dwBackBufferCount == 0) )
	{
	    DPF_ERR( "flip specified without any backbuffers" );
	    return DDERR_INVALIDCAPS;
	}
	/*
	 * Currently we don't allow the creating of flippable mip-map
	 * chains with a single call to CreateSurface(). They must be
	 * built manually. This will be implmented but is not in place
	 * as yet. Hence, for now we fail the attempt with a
	 * DDERR_UNSUPPORTED.
	 */
	if( sdflags & DDSD_MIPMAPCOUNT )
	{
	    DPF_ERR( "Creating flippable mip-map chains with a single call is not yet implemented" );
	    return DDERR_UNSUPPORTED;
	}
    }

    /*
     * Check hardware deinterlacing
     */
    if( capsEx.dwCaps2 & DDSCAPS2_RESERVED4 )
    {
	if( !( caps & DDSCAPS_VIDEOPORT ) || !( caps & DDSCAPS_OVERLAY ) )
	{
	    DPF_ERR( "DDSCAPS2_RESERVED4 specified w/o video port or overlay" );
	    return DDERR_INVALIDCAPS;
	}
	if( ( pdrv->lpDDVideoPortCaps == NULL ) ||
	    !( pdrv->lpDDVideoPortCaps->dwCaps & DDVPCAPS_HARDWAREDEINTERLACE ) )
	{
	    DPF_ERR( "No hardware support for DDSCAPS_RESERVED4" );
	    return DDERR_INVALIDCAPS;
	}
	if( caps & DDSCAPS_COMPLEX )
	{
	    DPF_ERR( "DDSCAPS2_RESERVERD4 not valid w/ a complex surface" );
	    return DDERR_INVALIDCAPS;
	}
    }

    /*
     * check various caps combinations
     */
    ddrval = checkCaps( caps, pdrv_int , &capsEx);
    if( ddrval != DD_OK )
    {
	return ddrval;
    }

    /*
     * check alpha
     */
    if( (caps & DDSCAPS_ALPHA) )
    {
	#pragma message( REMIND( "Alpha not supported in Rev 1" ))
	DPF_ERR( "Alpha not supported this release" );
	return DDERR_INVALIDPARAMS;
	#ifdef USE_ALPHA
	if( !(sdflags & DDSD_ALPHABITDEPTH) )
	{
	    DPF_ERR( "AlphaBitDepth required in SurfaceDesc" );
	    return DDERR_INVALIDPARAMS;
	}
	if( (lpsd->dwAlphaBitDepth > 8) ||
		GetBytesFromPixels( 1, lpsd->dwAlphaBitDepth ) == 0 )
	{
	    DPF_ERR( "Invalid AlphaBitDepth specified in SurfaceDesc" );
	    return DDERR_INVALIDPARAMS;
	}
	#endif
    }
    else if( sdflags & DDSD_ALPHABITDEPTH )
    {
	DPF_ERR( "AlphaBitDepth only valid for alpha surfaces" );
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check z buffer
     */
    if( (caps & DDSCAPS_ZBUFFER) )
    {
       DDSURFACEDESC *pOldSD=(DDSURFACEDESC *)lpsd;
       DWORD zbitdepth;

       if(lpsd->dwSize==sizeof(DDSURFACEDESC)) {

	   // allow old way to request Z, using DDSD_ZBUFFERBITDEPTH field
	   // also allow z to be requested through pixfmt

	   if(sdflags & DDSD_PIXELFORMAT) {

	      if(lpsd->ddpfPixelFormat.dwSize!=sizeof(DDPIXELFORMAT)) {
		   DPF_ERR("Hey, you didn't set DDSURFACEDESC.ddpfPixelFormat.dwSize to sizeof(DDPIXELFORMAT)! Do that.");
		   return DDERR_INVALIDPARAMS;
	      }

	      if(pOldSD->ddpfPixelFormat.dwFlags & DDPF_STENCILBUFFER) {
		  DPF_ERR("Stencil ZBuffers can only be created using a SURFACEDESC2 passed to IDirectDraw4's CreateSurface");
		  return DDERR_INVALIDPARAMS;
	      }

	      if(pOldSD->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER) {
	       // pixfmt overrides ddsd zbufferbitdepth.
	       // copy zbitdepth back to SD field because old drivers require it there
	       pOldSD->dwZBufferBitDepth=pOldSD->ddpfPixelFormat.dwZBufferBitDepth;
	       pOldSD->dwFlags|=DDSD_ZBUFFERBITDEPTH;
	       sdflags|=DDSD_ZBUFFERBITDEPTH;

	      } else {
		  DPF_ERR("If DDSD_PIXELFORMAT specified, DDPF_ZBUFFER flag must be too");
		  return DDERR_INVALIDPARAMS;
	      }
	   } else if(sdflags & DDSD_ZBUFFERBITDEPTH) {
		if(!(caps & DDSCAPS_COMPLEX)) {
		    // setup valid zpixfmt

		    memset(&pOldSD->ddpfPixelFormat,0,sizeof(DDPIXELFORMAT));

		    pOldSD->ddpfPixelFormat.dwSize=sizeof(DDPIXELFORMAT);
		    pOldSD->ddpfPixelFormat.dwZBufferBitDepth=pOldSD->dwZBufferBitDepth;
		    pOldSD->ddpfPixelFormat.dwFlags|=DDPF_ZBUFFER;
		    pOldSD->dwFlags|=DDSD_PIXELFORMAT;
		    sdflags|=DDSD_PIXELFORMAT;
		}
		// for complex surfaces, cannot write zbuffer pixfmt because that would overwrite
		// the main surface pixfmt

	      } else {
		  DPF_ERR("Neither DDSD_ZBUFFERBITDEPTH nor a ZBuffer ddpfPixelFormat was specified");
		  return DDERR_INVALIDPARAMS;
	      }

	       // fill in ZBitMask for them, so future pixfmt will be completely valid
	       if(!(caps & DDSCAPS_COMPLEX)) {
		   if(pOldSD->ddpfPixelFormat.dwZBufferBitDepth==32)
		     pOldSD->ddpfPixelFormat.dwZBitMask = 0xffffffff;
		   else pOldSD->ddpfPixelFormat.dwZBitMask = (1<<pOldSD->ddpfPixelFormat.dwZBufferBitDepth)-1;
	       }
	   } else {  // SURFACEDESC2 was used (IDDraw4:CreateSurface)

	       if(caps & DDSCAPS_COMPLEX) {
		   DPF_ERR( "As of IDirectDraw4, Complex Surface Creations can no longer contain ZBuffers, must create ZBuffer separately and attach");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(sdflags & DDSD_ZBUFFERBITDEPTH) {
		   DPF_ERR("DDSD_ZBUFFERBITDEPTH flag obsolete for DDSURFACEDESC2, specify ZBuffer format in ddpfPixelFormat instead");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(!(sdflags & DDSD_PIXELFORMAT)) {
		   DPF_ERR("DDSD_PIXELFORMAT flag not set. For DDSURFACEDESC2, ZBuffer format must be specified in ddpfPixelFormat");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(lpsd->ddpfPixelFormat.dwSize!=sizeof(DDPIXELFORMAT)) {
		   DPF_ERR("Hey, you didn't set DDSURFACEDESC2.ddpfPixelFormat.dwSize to sizeof(DDPIXELFORMAT)! Do that.");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(!(lpsd->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER)) {
		   DPF_ERR("DDPF_ZBUFFER flag must be set in pixfmt flags");
		   return DDERR_INVALIDPARAMS;
	       }

	       // not requiring this for legacy DDSURFACEDESC creations
	       if(lpsd->ddpfPixelFormat.dwZBitMask==0x0) {
		   DPF_ERR("Error: dwZBitMask must be non-0 (just copy it from the EnumZBufferFormats pixfmt)");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(lpsd->ddpfPixelFormat.dwFlags & DDPF_STENCILBUFFER) {
		 // probably can't trust old drivers' CanCreateSurface to fail stencil request,
		 // so just fail it ourselves right here.

		 // if driver doesn't support EnumZBufferFormats, it can't support stencil.
		 // this is indicated by the 0 in pdrv->dwNumZPixelFormats
		 if((!emulation) && !DRIVER_SUPPORTS_DX6_ZBUFFERS(pdrv)) {
		     DPF_ERR("Driver doesn't support Stencil ZBuffers");
		     return DDERR_UNSUPPORTED;
		 }
	       } else {
	       // NOTE: Old drivers require the DDSURFACEDESC.dwZBufferBitDepth to be set for
	       // CanCreateSurface and CreateSurface.  So if user asks for z-only surface, go
	       // ahead and set this field so creating z-only zbuffers with IDDraw4 will work with
	       // old drivers.  I'm leaving DDSD_ZBUFFERBITDEPTH flag unset because
	       // I dont want to confuse driver writers into still using that field and every driver
	       // I've looked at keys off of DDSCAPS_ZBUFFER (which is set) and not DDSD_ZBUFFERBITDEPTH.
	       // Any driver that allows stenciling is a DX6 driver and should ignore the SD zbufferbitdepth,
	       // so no need to do this copy for them

		   pOldSD->dwZBufferBitDepth=lpsd->ddpfPixelFormat.dwZBufferBitDepth;
	       }
	   }

	   if(caps & DDSCAPS_COMPLEX)
	       zbitdepth=((DDSURFACEDESC*)lpsd)->dwZBufferBitDepth;
	    else zbitdepth=lpsd->ddpfPixelFormat.dwZBufferBitDepth;

	   if(zbitdepth<8) {
	       DPF_ERR("Invalid dwZBufferBitDepth, must be >=8 bits");
	       return DDERR_INVALIDPARAMS;
	   }

	   // side note for stencils:  If stencils are present, dwZBufferBitDepth represents
	   // the total bit depth including both z and stencil bits, so z-only bits are
	   // dwZBufferBitDepth-dwStencilBufferBitDepth.  This was done because we're afraid
	   // ddraw code makes too many assumptions that the total bitdepth of a surface is always
	   // found in the pixfmt (dwRGBBitCount/dwZBufferBitDepth) union when it does pixel computations.

	   if(lpsd->ddpfPixelFormat.dwFlags & DDPF_STENCILBUFFER) {
	       if(lpsd->ddpfPixelFormat.dwStencilBitDepth==0) {
		   DPF_ERR("Invalid SurfaceDesc StencilBufferBitDepth, must be non-0");
		   return DDERR_INVALIDPARAMS;
	       }

	       if(lpsd->ddpfPixelFormat.dwStencilBitMask==0x0) {
		   DPF_ERR("Error: dwStencilBitMask must be non-0 (just copy it from the EnumZBufferFormats pixfmt)");
		   return DDERR_INVALIDPARAMS;
	       }
	   }
    } else if((sdflags & DDSD_ZBUFFERBITDEPTH) ||
	      ((sdflags & DDSD_PIXELFORMAT) && ((lpsd->ddpfPixelFormat.dwFlags & DDPF_ZBUFFER) ||
						(lpsd->ddpfPixelFormat.dwFlags & DDPF_STENCILBUFFER)))) {
	    DPF_ERR("DDSD_ZBUFFERBITDEPTH, DDPF_ZBUFFER, and DDPF_STENCILBUFFER flags only valid with DDSCAPS_ZBUFFER set");
	    return DDERR_INVALIDPARAMS;
	}

    /*
     * Validate height/width
     */
    if( sdflags & DDSD_HEIGHT )
    {
	if( (caps & DDSCAPS_PRIMARYSURFACE) )
	{
	    DPF_ERR( "Height can't be specified for primary surface" );
	    return DDERR_INVALIDPARAMS;
	}
#ifdef SHAREDZ
	if( caps & ( DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER ) )
	{
	    DPF_ERR( "Height can't be specified for shared back or z-buffers" );
	    return DDERR_INVALIDPARAMS;
	}
#endif
	if( lpsd->dwHeight < 1 )
	{
	    DPF_ERR( "Invalid height specified" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    else
    {
	if( !(caps & CAPS_NOHEIGHT_REQUIRED) )
	{
	    DPF_ERR( "Height must be specified for surface" );
	    return DDERR_INVALIDPARAMS;
	}
    }
    if( sdflags & DDSD_WIDTH )
    {
	DWORD   maxwidth;

	if( (caps & DDSCAPS_PRIMARYSURFACE) )
	{
	    DPF_ERR( "Width can't be specified for primary surface" );
	    return DDERR_INVALIDPARAMS;
	}
#ifdef SHAREDZ
	if( caps & ( DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER ) )
	{
	    DPF_ERR( "Width can't be specified for shared back or z-buffers" );
	    return DDERR_INVALIDPARAMS;
	}
#endif
	if( lpsd->dwWidth < 1 )
	{
	    DPF_ERR( "Invalid width specified" );
	    return DDERR_INVALIDPARAMS;
	}

	if( ( !real_sysmem ) && !( caps & DDSCAPS_EXECUTEBUFFER ) &&
	    !( caps & DDSCAPS_VIDEOPORT ) )
	{
	    if ( (dwRegFlags & DDRAW_REGFLAGS_DISABLEWIDESURF) ||
		( !(pdrv->ddCaps.dwCaps2 & DDCAPS2_WIDESURFACES)) )
	    {
		maxwidth = getPixelsFromBytes( pdrv->vmiData.lDisplayPitch,
					    pdrv->vmiData.ddpfDisplay.dwRGBBitCount );

		if( lpsd->dwWidth > maxwidth )
		{
		    DPF( 0, "Width too big: %ld reqested, max is %ld", lpsd->dwWidth, maxwidth );
		    return DDERR_INVALIDPARAMS;
		}
	    }
	}
    }
    else
    {
	if( !(caps & CAPS_NOWIDTH_REQUIRED) )
	{
	    DPF_ERR( "Width must be specified for surface" );
	    return DDERR_INVALIDPARAMS;
	}
    }

    /*
     * Extra validation for mip-map width and height (must be a whole power of 2)
     * and number of levels.
     */
    if( caps & DDSCAPS_MIPMAP )
    {
	if( sdflags & DDSD_MIPMAPCOUNT )
	{
	    if( lpsd->dwMipMapCount == 0 )
	    {
		DPF_ERR( "Invalid number of mip-map levels (0) specified" );
		return DDERR_INVALIDPARAMS;
	    }
	}

	if( sdflags & DDSD_HEIGHT )
	{
	    if( !isPowerOf2( lpsd->dwHeight, &hPower ) )
	    {
		DPF_ERR( "Invalid height: height of a mip-map must be whole power of 2" );
		return DDERR_INVALIDPARAMS;
	    }
	}
	if( sdflags & DDSD_WIDTH )
	{
	    if( !isPowerOf2( lpsd->dwWidth, &wPower ) )
	    {
		DPF_ERR( "Invalid width: width of a mip-map must be whole power of 2" );
		return DDERR_INVALIDPARAMS;
	    }
	}

        if (sdflags & (DDSD_WIDTH|DDSD_HEIGHT) )
        {
            /*
             * For deep mipmaps, we need to ensure that the supplied mipmapcount is no larger
             * than the largest of the supplied dimensions. This restriction is slightly weaker
             * than the DX2->DX6 restriction that the mipmapcount is no larger than either dimension.
             */
            int power = max ( hPower , wPower );
	    if( sdflags & DDSD_MIPMAPCOUNT )
	    {
		if (lpsd->dwMipMapCount > (DWORD) ( power + 1 ))
		{
		    DPF( 0, "Invalid number of mip-map levels (%ld) specified", lpsd->dwMipMapCount );
		    return DDERR_INVALIDPARAMS;
		}
	    }
        }
    }

    /*
     * validate pixel format
     */
    if( sdflags & DDSD_PIXELFORMAT )
    {
	if( caps & DDSCAPS_PRIMARYSURFACE )
	{
	    DPF_ERR( "Pixel format cannot be specified for primary surface" );
	    return DDERR_INVALIDPARAMS;
	}
	if(caps & DDSCAPS_ALPHA)
	{
	    DPF_ERR( "Can't specify alpha cap with pixel format" );
	    return DDERR_INVALIDPIXELFORMAT;
	}
	pfflags = lpsd->ddpfPixelFormat.dwFlags;

	if( pfflags & UNDERSTOOD_PF )
	{
	    // Get the number of bits per pixel (dwRGBBitCount is in a union
	    // of fields that all mean the same thing.)
	    bpp = lpsd->ddpfPixelFormat.dwRGBBitCount;
	    if( GetBytesFromPixels( 1, bpp ) == 0 )
	    {
		DPF_ERR( "Invalid BPP specified in pixel format" );
		return DDERR_INVALIDPIXELFORMAT;
	    }
	    if( pfflags & DDPF_RGB )
	    {
		if( pfflags & (DDPF_YUV) )
		{
		    DPF_ERR( "Invalid flags specified in pixel format" );
		    return DDERR_INVALIDPIXELFORMAT;
		}
	    }
            if ( pfflags & DDPF_ALPHA )
            {
                //Pretty much everything else must be off
                if ( pfflags & (DDPF_ALPHAPIXELS |
                                DDPF_FOURCC |
                                DDPF_PALETTEINDEXED1 |
                                DDPF_PALETTEINDEXED2 |
                                DDPF_PALETTEINDEXED4 |
                                DDPF_PALETTEINDEXED8 |
                                DDPF_RGB |
                                DDPF_YUV |
                                DDPF_ZBUFFER |
                                DDPF_ZPIXELS |
                                DDPF_STENCILBUFFER |
                                DDPF_LUMINANCE) )
                {
                    DPF_ERR("DDPF_ALPHA is valid only by itself");
                    return DDERR_INVALIDPARAMS;
                }
            }
	    if (pfflags & DDPF_LUMINANCE )
	    {
		if ( pfflags & ( ~ ( DDPF_LUMINANCE | DDPF_ALPHAPIXELS ) ) )
		{
		    DPF_ERR( "DDPF_LUMINANCE set in pixel format, compatible only with DDPF_ALPHAPIXELS" );
		    return DDERR_INVALIDPIXELFORMAT;
		}

		// we don't trust pre-dx6 drivers' CanCreateSurface callback to correctly reject
		// DX6 luminance/bump DDPIXELFORMATs, so reject them here
		if(!IS_DX6_D3DDRIVER(pdrv) && !emulation) {
		    DPF_ERR("Error: Driver doesn't support Luminance surfaces");
		    return DDERR_UNSUPPORTED;
		}

	    }
	    if (pfflags & DDPF_BUMPDUDV )
	    {
		if (pfflags & ( ~ (DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE)))
		{
		    DPF_ERR( "DDPF_BUMPDUDV set in pixel format, compatible only with DDPF_BUMPLUMINANCE");
		    return DDERR_INVALIDPIXELFORMAT;
		}

		if(!IS_DX6_D3DDRIVER(pdrv) && !emulation) {
		    DPF_ERR("Error: Driver doesn't support Bump Map surfaces");
		    return DDERR_UNSUPPORTED;
		}

	    }
	    if( pfflags & DDPF_PALETTEINDEXED8 )
	    {
		if( pfflags & (DDPF_PALETTEINDEXED1 |
			       DDPF_PALETTEINDEXED2 |
			       DDPF_PALETTEINDEXED4 |
			       DDPF_PALETTEINDEXEDTO8 ) )
		{
		    DPF_ERR( "Invalid flags specified in pixel format" );
		    return DDERR_INVALIDPIXELFORMAT;
		}

		/*
		 * ensure that we have zero for masks
		 */
		lpsd->ddpfPixelFormat.dwRBitMask = 0;
		lpsd->ddpfPixelFormat.dwGBitMask = 0;
		lpsd->ddpfPixelFormat.dwBBitMask = 0;
		if( !(pfflags & (DDPF_ZPIXELS|DDPF_ALPHAPIXELS) ) )
		    lpsd->ddpfPixelFormat.dwRGBZBitMask = 0;
	    }
	    lpsd->ddpfPixelFormat.dwFourCC = 0;

	    // Validate ZPixels
	    if( pfflags & DDPF_ZPIXELS )
	    {
		if( lpsd->ddpfPixelFormat.dwRGBZBitMask == 0 )
		{
		    DPF_ERR( "DDPF_ZPIXELS must have a dwRGBZBitMask" );
		    return DDERR_INVALIDPIXELFORMAT;
		}
		if( pfflags & (DDPF_ALPHAPIXELS | DDPF_ALPHA | DDPF_ZBUFFER) )
		{
		    DPF_ERR( "DDPF_ZPIXELS not compatible with ALPHAPIXELS or ALPHA or ZBUFFER" );
		    return DDERR_INVALIDPIXELFORMAT;
		}
	    }
	}
	else if (pfflags & DDPF_FOURCC)
	{
	    DWORD width, height;

	    /*
	     * We require the width and height of DirectX compressed-texture
	     * surfaces (FOURCC = DXT*) to be multiples of four.
	     */
	    switch ((int)lpsd->ddpfPixelFormat.dwFourCC)
	    {
	    case MAKEFOURCC('D','X','T','1'):
	    case MAKEFOURCC('D','X','T','2'):
	    case MAKEFOURCC('D','X','T','3'):
	    case MAKEFOURCC('D','X','T','4'):
	    case MAKEFOURCC('D','X','T','5'):
    		width  = (sdflags & DDSD_WIDTH)  ? lpsd->dwWidth  : pdrv->vmiData.dwDisplayWidth;
    		height = (sdflags & DDSD_HEIGHT) ? lpsd->dwHeight : pdrv->vmiData.dwDisplayHeight;
		if ((height | width) & 3)
		{
    		    DPF_ERR("Width, height of FOURCC=DXT* surface must be multiples of 4");
		    return DDERR_INVALIDPARAMS;
		}
		break;
	    default:
		break;
	    }
	}
    }

    // ACKACK: should caps be filled in in surface desc as well as sdflags?

    /*
     * validate dest overlay color key
     */
    if( sdflags & DDSD_CKDESTOVERLAY )
    {
	ddrval = CheckColorKey( DDCKEY_DESTOVERLAY, pdrv,
					&lpsd->ddckCKDestOverlay, psflags,
					halonly, helonly );
	if( ddrval != DD_OK )
	{
	    return ddrval;
	}
    }

    /*
     * validate dest blt color key
     */
    if( sdflags & DDSD_CKDESTBLT )
    {
	ddrval = CheckColorKey( DDCKEY_DESTBLT, pdrv,
					&lpsd->ddckCKDestBlt, psflags,
					halonly, helonly );
	if( ddrval != DD_OK )
	{
	    return ddrval;
	}
    }

    /*
     * validate src overlay color key
     */
    if( sdflags & DDSD_CKSRCOVERLAY )
    {
	ddrval = CheckColorKey( DDCKEY_SRCOVERLAY, pdrv,
					&lpsd->ddckCKSrcOverlay, psflags,
					halonly, helonly );
	if( ddrval != DD_OK )
	{
	    return ddrval;
	}
    }

    /*
     * validate src blt color key
     */
    if( sdflags & DDSD_CKSRCBLT )
    {
	ddrval = CheckColorKey( DDCKEY_SRCBLT, pdrv,
					&lpsd->ddckCKSrcBlt, psflags,
					halonly, helonly );
	if( ddrval != DD_OK )
	{
	    return ddrval;
	}
    }

    /*
     * cube maps
     */
    if ( capsEx.dwCaps2 & DDSCAPS2_CUBEMAP )
    {
        if (LOWERTHANDDRAW7(pdrv_int))
        {
            DPF_ERR("DDSCAPS2_CUBEMAP is not allowed for lower than IDirectDraw7 interfaces.");
            return DDERR_INVALIDPARAMS;
        }

        if ( (lpsd->dwFlags & (DDSD_WIDTH|DDSD_HEIGHT)) == 0)
        {
            DPF_ERR("dwWidth and dwHeight must be specified for a DDSCAPS2_CUBEMAP surface");
            return DDERR_INVALIDPARAMS;
        }
        if (lpsd->dwHeight != lpsd->dwWidth)
        {
            DPF_ERR("dwWidth and dwHeight must be equal for a DDSCAPS2_CUBEMAP surface");
            return DDERR_INVALIDPARAMS;
        }
        if (! isPowerOf2(lpsd->dwHeight,NULL) )
        {
            DPF_ERR("dwWidth and dwHeight must be a whole power of two");
            return DDERR_INVALIDPARAMS;
        }
        if (lpsd->dwFlags & DDSD_BACKBUFFERCOUNT)
        {
            DPF_ERR("Cubemaps cannot have backbuffers!");
            return DDERR_INVALIDPARAMS;
        }
    }

    return DD_OK;

} /* checkSurfaceDesc */



/*
 * ComputePitch
 *
 * compute the pitch for a given width
 */
DWORD ComputePitch(
		LPDDRAWI_DIRECTDRAW_GBL this,
		DWORD caps,
		DWORD width,
		UINT bpp )
{
    DWORD       vm_align;
    DWORD       vm_pitch;

    /*
     * adjust area for bpp
     */
    vm_pitch = GetBytesFromPixels( width, bpp );
    if( vm_pitch == 0 )
    {
	return vm_pitch;
    }

    /*
     * Increase the pitch of the surface so that it is a
     * multiple of the alignment requirement.  This
     * guarantees each scanline will start properly aligned.
     * The alignment is no longer required to be a power of
     * two but it must be divisible by 4 because of the
     * BLOCK_BOUNDARY requirement in the heap management
     * code.
     * The alignments are all verified to be non-zero during
     * driver initialization except for dwAlphaAlign.
     */

    /*
     * system memory?
     */
    if( caps & DDSCAPS_SYSTEMMEMORY )
    {
	vm_align = sizeof( DWORD);
	vm_pitch = alignPitch( vm_pitch, vm_align );
	return vm_pitch;
    }

    /*
     * If the driver exposed extended alignment, then we will simply set
     * pitch=width*bpp/8 and allow that to filter down to the heap alloc
     * routines which know how to align surfaces
     * Note this implies that extended alignment for any heap means
     * ddraw will IGNORE the legacy alignment values for all heaps.
     */
    if ( this->dwFlags & DDRAWI_EXTENDEDALIGNMENT )
    {
	return vm_pitch;
    }

    /*
     * overlay memory
     */
    if( caps & DDSCAPS_OVERLAY )
    {
	vm_align = this->vmiData.dwOverlayAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    /*
     * texture memory
     */
    }
    else if( caps & DDSCAPS_TEXTURE )
    {
	vm_align = this->vmiData.dwTextureAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    /*
     * z buffer memory
     */
    }
    else if( caps & DDSCAPS_ZBUFFER )
    {
	vm_align = this->vmiData.dwZBufferAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    /*
     * alpha memory
     */
    }
    else if( caps & DDSCAPS_ALPHA )
    {
	vm_align = this->vmiData.dwAlphaAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    /*
     * regular video memory
     */
    }
    else
    {
	vm_align = this->vmiData.dwOffscreenAlign;
	vm_pitch = alignPitch( vm_pitch, vm_align );
    }
    return vm_pitch;

} /* ComputePitch */

#define FIX_SLIST_CNT   16      // number of surfaces before malloc reqd

/*
 * initMipMapDim
 *
 * If we have a mip-map description then we can fill in some
 * fields for the caller. This function needs to be invoked
 * before the checkSurfaceDesc is called as it may put in
 * place some fields checked by that function.
 *
 * NOTE: This function may modify the surface description.
 */
static HRESULT initMipMapDim( LPDDSURFACEDESC2 lpsd, BOOL bDeepMipmaps )
{
    DWORD sdflags;
    DWORD caps;
    int   heightPower;
    int   widthPower;

    DDASSERT( lpsd != NULL );
    DDASSERT( lpsd->ddsCaps.dwCaps & DDSCAPS_MIPMAP );

    sdflags = lpsd->dwFlags;
    caps    = lpsd->ddsCaps.dwCaps;

    /*
     * This stuff is only relevant for complex, non-flipable
     * mip-maps.
     */
    if( ( caps & DDSCAPS_COMPLEX ) && !( caps & DDSCAPS_FLIP ) )
    {
	if( ( ( sdflags & DDSD_HEIGHT ) && ( sdflags & DDSD_WIDTH ) ) &&
	   !( sdflags & DDSD_MIPMAPCOUNT ) )
	{
	    /*
	     * Width and height but no number of levels so compute the
	     * maximum number of mip-map levels supported by the given
	     * width and height.
	     */
	    if( !isPowerOf2( lpsd->dwHeight, &heightPower ) )
	    {
		DPF_ERR( "Invalid height: height of a mip-map must be whole power of 2" );
		return DDERR_INVALIDPARAMS;
	    }
	    if( !isPowerOf2( lpsd->dwWidth, &widthPower ) )
	    {
		DPF_ERR( "Invalid width:  width of a mip-map must be whole powers of 2" );
		return DDERR_INVALIDPARAMS;
	    }

            /*
             * Deep mipmaps are those that clamp their smaller dimension at 1 as
             * the larger dimension ramps down to 1
             */
            if ( bDeepMipmaps )
	        lpsd->dwMipMapCount = (DWORD)(max(heightPower, widthPower) + 1);
            else
	        lpsd->dwMipMapCount = (DWORD)(min(heightPower, widthPower) + 1);
	    lpsd->dwFlags |= DDSD_MIPMAPCOUNT;
	}
	else if( ( sdflags & DDSD_MIPMAPCOUNT ) &&
		!( ( sdflags & DDSD_WIDTH ) || ( sdflags & DDSD_HEIGHT ) ) )
	{
	    /*
	     * We have been given a mip-map count but no width
	     * and height so compute the width and height assuming
	     * the smallest map is 1x1.
	     * NOTE: We don't help out if they supply a width or height but
	     * not both.
	     */
	    if( lpsd->dwMipMapCount == 0 )
	    {
		DPF_ERR( "Invalid number of mip-map levels (0) specified" );
		return DDERR_INVALIDPARAMS;
	    }
	    else
	    {
		lpsd->dwWidth = lpsd->dwHeight = 1 << (lpsd->dwMipMapCount - 1);
		lpsd->dwFlags |= (DDSD_HEIGHT | DDSD_WIDTH);
	    }
	}
    }

    return DD_OK;
}


HRESULT createsurfaceEx( LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl )
{
    LPDDRAWI_DIRECTDRAW_LCL     lpDDLcl=lpSurfLcl->lpSurfMore->lpDD_lcl;
    if (
        (0 != lpSurfLcl->lpSurfMore->dwSurfaceHandle)
        && (NULL != lpDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx) 
       )
   {
        DDHAL_CREATESURFACEEXDATA   csdex;
        DWORD   rc;
        csdex.ddRVal = DDERR_GENERIC;
        csdex.dwFlags = 0;
        csdex.lpDDLcl = lpDDLcl;
        csdex.lpDDSLcl = lpSurfLcl;
        rc = lpDDLcl->lpGbl->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx(&csdex);
	if( DDHAL_DRIVER_HANDLED == rc )
        {
            if( ( DD_OK != csdex.ddRVal ) &&
                !( lpSurfLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
            {
                DPF_ERR("Driver failed CreateSurfaceEx callback in createSurface");
                return csdex.ddRVal;
            }
        }
        else
        {
            DPF_ERR("Driver failed to handle CreateSurfaceEx callback in createSurface");
            return DDERR_GENERIC;
        }
    } 
    return  DD_OK;   
}
#ifdef WINNT
LPDDRAWI_DDRAWSURFACE_LCL GetTopLevel(LPDDRAWI_DDRAWSURFACE_LCL lpLcl);
BOOL WINAPI CompleteCreateSysmemSurface( LPDDRAWI_DDRAWSURFACE_LCL lpSurfLcl )
{
    DDASSERT(lpSurfLcl 
        && (DDSCAPS_SYSTEMMEMORY & lpSurfLcl->ddsCaps.dwCaps) 
        && (0 == lpSurfLcl->hDDSurface));
 
    if (lpSurfLcl->lpSurfMore->lpDD_lcl->lpGbl->hDD)
    {
        BOOL    bRet;
        int     scnt;
        int     nsurf;
        LPDDRAWI_DDRAWSURFACE_LCL   *slist;
        lpSurfLcl = GetTopLevel(lpSurfLcl);
        slist=lpSurfLcl->lpSurfMore->slist;
        if (slist)
        {
            DWORD   caps=lpSurfLcl->ddsCaps.dwCaps;
            DWORD   caps2=lpSurfLcl->lpSurfMore->ddsCapsEx.dwCaps2;
            nsurf=lpSurfLcl->lpSurfMore->cSurfaces;
            DDASSERT(nsurf);
            if (DDSCAPS2_CUBEMAP & caps2)
            {
                int dwCubeMapFaceCount;
                int surf_from;
                int perfacecnt;
                DDASSERT(lpSurfLcl->lpSurfMore->pCreatedDDSurfaceDesc2);
                // to calculate dwCubeMapFaceCount we must use this caps2
                caps2 = lpSurfLcl->lpSurfMore->pCreatedDDSurfaceDesc2->ddsCaps.dwCaps2;
                dwCubeMapFaceCount =
                    (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ? 1 : 0 )+
                    (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) ? 1 : 0 );
                DDASSERT(dwCubeMapFaceCount);
                DDASSERT(nsurf >= dwCubeMapFaceCount);
                DDASSERT(0 == (nsurf % dwCubeMapFaceCount));
                perfacecnt = nsurf/ dwCubeMapFaceCount;
                DDASSERT(perfacecnt == 1 || ((perfacecnt>1) && (caps & DDSCAPS_MIPMAP)) ); 

                /*
                 * Every (perfacecnt)th surface needs to be linked to the very first
                 * Otherwise, it's a mip level that needs linking to its parent
                 */
                for (scnt = 1; scnt < nsurf; scnt++)
                {
                    if ( (scnt % perfacecnt) == 0 )
                        surf_from = 0;
                    else
                        surf_from = scnt - 1;
                    if ( !DdAttachSurface(slist[surf_from], slist[scnt]) )
                        DPF(0,"DdAttachSurface CUBEMAP %d from %d failed!",surf_from,scnt);
                }            
            }
            else if (DDSCAPS_MIPMAP & caps)
            {
                for (scnt = 1; scnt < nsurf; scnt++)
                {
                    if ( !DdAttachSurface(slist[scnt-1], slist[scnt]) )
                        DPF(0,"DdAttachSurface MIPMAP %d failed!",scnt);
                }            
            }
        }
        else
        {
            slist=&lpSurfLcl;
            nsurf = 1;
        }
        for (scnt = 0; scnt < nsurf; scnt++)
        {
            bRet = DdCreateSurfaceObject(slist[scnt], FALSE);
            if (!bRet)
            {
                // cleanup is needed as hDDSurface could be created partially
                // by DdAttachSurface, 
                for (scnt = 0; scnt < nsurf; scnt++)
                {
                    if (slist[scnt]->hDDSurface)
                    {
                        if (!DdDeleteSurfaceObject(slist[scnt]))
                            DPF(5,"DdDeleteSurfaceObject failed");
                    }
                }
                break;
            }
        }            
        // we only allow system surface being created w/o succeeding Kernel side
        if (bRet)
        {
            DDASSERT(lpSurfLcl->hDDSurface);
            createsurfaceEx(lpSurfLcl);
        }
        else
        {
            DPF_ERR("Fail to complete SYSTEM surface w/ Kernel Object");
            return FALSE;
        }
    }
    return  TRUE;
}
#endif
/*
 * createSurface
 *
 * Create a surface, without linking it into the chain.
 * We could potentially create multiple surfaces here, if we get a
 * request to create a page flipped surface and/or attached alpha or
 * z buffer surfaces
 */
static HRESULT createSurface( LPDDRAWI_DIRECTDRAW_LCL this_lcl,
			      LPDDSURFACEDESC2 lpDDSurfaceDesc,
			      CSINFO *pcsinfo,
			      BOOL emulation,
			      BOOL real_sysmem,
			      BOOL probe_driver,
			      LPDDRAWI_DIRECTDRAW_INT this_int,
                              LPDDSURFACEINFO pSysMemInfo,
                              DWORD DX8Flags)
{

    LPDDRAWI_DIRECTDRAW_GBL     this;
    LPDDRAWI_DDRAWSURFACE_INT   psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL   psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   psurf;
    DWORD                       caps;
    int                         surf_size;
    int                         surf_size_lcl;
    int                         surf_size_lcl_more;
    HRESULT                     ddrval;
    int                         bbcnt;
    int                         scnt;
    int                         nsurf;
    BOOL                        do_abuffer;
    DWORD                       abuff_depth;
    BOOL                        do_zbuffer;
    BOOL                        firstbbuff;
    LPDDRAWI_DDRAWSURFACE_INT   *slist_int;
    LPDDRAWI_DDRAWSURFACE_LCL   *slist_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   *slist;
    int                         bbuffoff;
    int                         zbuffoff;
    DWORD                       rc;
    DDPIXELFORMAT               ddpf;
    LPDDPIXELFORMAT             pddpf;
    BOOL                        is_primary_chain;
    UINT                        bpp = 0;
    LONG                        vm_pitch;
    BOOL                        is_flip;
    BOOL                        is_diff;
    BOOL                        is_mipmap;
    DDHAL_CREATESURFACEDATA     csd;
    DDHAL_CANCREATESURFACEDATA  ccsd;
    DWORD                       sflags;
    BOOL                        is_curr_diff;
    BOOL                        understood_pf;
    DWORD                       nsflags;
    LPDDSCAPS                   pdrv_ddscaps;
    LPDDHAL_CANCREATESURFACE    ccsfn;
    LPDDHAL_CREATESURFACE       csfn;
    LPDDHAL_CANCREATESURFACE    ccshalfn;
    LPDDHAL_CREATESURFACE       cshalfn;
    BOOL                        is_excl;
    BOOL                        excl_exists;
    DWORD                       sdflags;
    #ifdef WIN95
	DWORD                   ptr16;
    #endif
    DWORD                       pid;
    LPDDRAWI_DDRAWSURFACE_GBL   lpGlobalSurface;
    DDSURFACEDESC2              sd;
    BOOL                        existing_global;
    DWORD                       caps2;
    BOOL                        is_cubemap;
	BOOL						is_stereo;
#ifdef SHAREDZ
    BOOL                        do_shared_z;
    BOOL                        do_shared_back;
#endif

    this = this_lcl->lpGbl;
    #ifdef WINNT
	// Update DDraw handle in driver GBL object.
	this->hDD = this_lcl->hDD;
    #endif //WINNT

    /*
     * validate surface description
     */
    nsflags = 0;
    sd = *lpDDSurfaceDesc;
    lpDDSurfaceDesc = &sd;

    /*
     * This new (DX7) caps bit is added to mipmap sublevels. Squish it in case old apps do the
     * GetSurfaceDesc, CreateSurface thing.
     */
    sd.ddsCaps.dwCaps2 &= ~DDSCAPS2_MIPMAPSUBLEVEL;

    /*
     * If we have a mip-map then we potentially can fill in some
     * blanks for the caller.
     */
    if( lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
    {
         /*
          * We allow deep mipmaps only for ddraw7 and above interfaces
          * and for DX7 and above class drivers.
          */
	ddrval = initMipMapDim( lpDDSurfaceDesc , !LOWERTHANDDRAW7(this_int) && this->lpDDCBtmp->HALDDMiscellaneous2.GetDriverState != NULL );
	if( ddrval != DD_OK )
	    return ddrval;
    }

    // Volume textures can only be created using the DX8 interfaces
    if ((lpDDSurfaceDesc->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME) &&
        !(DX8Flags & DX8SFLAG_DX8))
    {
        DPF_ERR("Volume textures cannot be created using the ddraw interfaces");
        return DDERR_INVALIDCAPS;
    }

    // Image surfaces can be in Z formats that CheckSurfaceDesc will fail since
    // the surface isn't a Z buffer.  Also, all image surface descs are filled in
    // the thunk layer, so we shouldn't have to check them anyway.
    if (!(DX8Flags & DX8SFLAG_IMAGESURF))
    {
        ddrval = checkSurfaceDesc( lpDDSurfaceDesc, this, &nsflags, emulation, real_sysmem, this_int );
        if( ddrval != DD_OK )
        {
	    return ddrval;
        }
    }

    sdflags = lpDDSurfaceDesc->dwFlags;
    pid     = GetCurrentProcessId();
    caps    = lpDDSurfaceDesc->ddsCaps.dwCaps;
    caps2   = lpDDSurfaceDesc->ddsCaps.dwCaps2;

    /*
     * set up for emulation vs driver
     *
     * NOTE: There are different HAL entry points for creating execute buffers
     * and conventional surfaces (to keep the driver writing simpler and because,
     * potentially, there may be different semantics for creating execute buffers
     * and conventional surfaces) so we need to set up the HAL call differently
     * here.
     */
    if( emulation )
    {
	pdrv_ddscaps = &this->ddHELCaps.ddsCaps;
	if( caps & DDSCAPS_EXECUTEBUFFER )
	{
	    ccsfn = this_lcl->lpDDCB->HELDDExeBuf.CanCreateExecuteBuffer;
	    csfn = this_lcl->lpDDCB->HELDDExeBuf.CreateExecuteBuffer;
	}
	else
	{
	    ccsfn = this_lcl->lpDDCB->HELDD.CanCreateSurface;
	    csfn = this_lcl->lpDDCB->HELDD.CreateSurface;
	}
	ccshalfn = ccsfn;
	cshalfn = csfn;
    }
    else
    {
	pdrv_ddscaps = &this->ddCaps.ddsCaps;
	if( caps & DDSCAPS_EXECUTEBUFFER )
	{
	    ccsfn = this_lcl->lpDDCB->HALDDExeBuf.CanCreateExecuteBuffer;
	    csfn = this_lcl->lpDDCB->HALDDExeBuf.CreateExecuteBuffer;
	    ccshalfn = this_lcl->lpDDCB->cbDDExeBufCallbacks.CanCreateExecuteBuffer;
	    cshalfn = this_lcl->lpDDCB->cbDDExeBufCallbacks.CreateExecuteBuffer;
            if ( DDSCAPS2_COMMANDBUFFER & caps2 )
            {
                // Asheron's Call(a DX6 app) will fail if we allow Video Command buffer
                // it's not interesting anyway, let's fail it
                DPF(4,"Command buffer is not supported in video-memory.");
                return DDERR_OUTOFVIDEOMEMORY;
            }
	}
	else
	{
	    ccsfn = this_lcl->lpDDCB->HALDD.CanCreateSurface;
	    csfn = this_lcl->lpDDCB->HALDD.CreateSurface;
	    ccshalfn = this_lcl->lpDDCB->cbDDCallbacks.CanCreateSurface;
	    cshalfn = this_lcl->lpDDCB->cbDDCallbacks.CreateSurface;
	}
    }

    /*
     * get some frequently used fields
     */
    if( sdflags & DDSD_BACKBUFFERCOUNT )
    {
	bbcnt = (int) lpDDSurfaceDesc->dwBackBufferCount;
	if( bbcnt < 0 )
	{
	    DPF( 0, "Invalid back buffer count %ld", bbcnt );
	    return DDERR_INVALIDPARAMS;
	}
    }
    else if( sdflags & DDSD_MIPMAPCOUNT )
    {
	/*
	 * Unlike the back-buffer count which can be 0
	 * the mip-map level count must be at least one
	 * if specified.
	 */
	bbcnt = (int) lpDDSurfaceDesc->dwMipMapCount - 1;
	if( bbcnt < 0 )
	{
	    DPF( 0, "Invalid mip-map count %ld", bbcnt + 1);
	    return DDERR_INVALIDPARAMS;
	}
    }
    else
    {
	bbcnt = 0;
    }

    /*
     * make sure the driver supports these caps
     */
    if( (caps & DDSCAPS_ALPHA) && !(pdrv_ddscaps->dwCaps & DDSCAPS_ALPHA) )
    {
	if( probe_driver )
	    DPF( 2, "Alpha not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Alpha not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOALPHAHW;
    }

    // DX7Stereo
	if (caps2 & DDSCAPS2_STEREOSURFACELEFT) 
        {   
            DPF(4,"validating driver caps for stereo flipping chain");
            DPF(5,"driver stereo caps dwCaps2: %08lx",this->ddCaps.dwCaps2); 
            DPF(5,"                   dwSVCaps:%08lx",this->ddCaps.dwSVCaps);
            DPF(5,"       ddsCapsMore.dwCaps2: %08lx",this->ddsCapsMore.dwCaps2);

            if (!(this->ddCaps.dwCaps2 & DDCAPS2_STEREO))
	        {
	            DPF(0,"DDSCAPS2_STEREOSURFACELEFT invalid, hardware does not support DDCAPS2_STEREO");
		        return DDERR_NOSTEREOHARDWARE;
	        }

            if (!(this->ddCaps.dwSVCaps & (DDSVCAPS_STEREOSEQUENTIAL)))
	        {
	            DPF(0,"DDSCAPS2_STEREOSURFACELEFT invalid, hardware must support DDSVCAPS_STEREOSEQUENTIAL");
		        return DDERR_NOSTEREOHARDWARE;
	        }


            if (!(this->ddsCapsMore.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT))
	        {
		        DPF(0,"DDSCAPS2_STEREOSURFACELEFT invalid, hardware does not support DDSCAPS2_STEREOSURFACELEFT");
		        return DDERR_NOSURFACELEFT;
	        }


    }

    #if 0
    if( (caps & DDSCAPS_FLIP) && !(pdrv_ddscaps->dwCaps & DDSCAPS_FLIP))
    {
	if( probe_driver )
	    DPF( 2, "Flip not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Flip not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOFLIPHW;
    }
    #endif
    if((caps & DDSCAPS_ZBUFFER) && !(pdrv_ddscaps->dwCaps & DDSCAPS_ZBUFFER))
    {
	if( probe_driver )
	    DPF( 2, "Z Buffer not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Z Buffer not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOZBUFFERHW;
    }
    if((caps & DDSCAPS_TEXTURE) && !(pdrv_ddscaps->dwCaps & DDSCAPS_TEXTURE))
    {
	if( probe_driver )
	    DPF( 2, "Textures not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Textures not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOTEXTUREHW;
    }
    if((caps & DDSCAPS_MIPMAP) && !(pdrv_ddscaps->dwCaps & DDSCAPS_MIPMAP))
    {
	if( probe_driver )
	    DPF( 2, "Mip-maps not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Mip-maps not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOMIPMAPHW;
    }
    if((caps & DDSCAPS_EXECUTEBUFFER) && !(pdrv_ddscaps->dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
	if( probe_driver )
	    DPF( 2, "Execute buffers not supported in hardware. Trying emulation..." );
	else
	    DPF( 2, "Execute buffers not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOEXECUTEBUFFERHW;
    }
#ifdef SHAREDZ
    if((caps & DDSCAPS_SHAREDZBUFFER) && !(pdrv_ddscaps->dwCaps & DDSCAPS_SHAREDZBUFFER))
    {
	if( probe_driver )
	    DPF( 2, "Shared Z-buffer not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Shared Z-buffer not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOSHAREDZBUFFERHW;
    }
    if((caps & DDSCAPS_SHAREDBACKBUFFER) && !(pdrv_ddscaps->dwCaps & DDSCAPS_SHAREDBACKBUFFER))
    {
	if( probe_driver )
	    DPF( 2, "Shared back-buffer not supported in hardware. Trying emulation..." );
	else
	    DPF( 0, "Shared back-buffer not supported in %s", (emulation ? "emulation" : "hardware") );
	return DDERR_NOSHAREDBACKBUFFERHW;
    }
#endif
    if(caps & DDSCAPS_OVERLAY)
    {
	if( emulation )
	{
	    if( 0 == (this->ddHELCaps.dwCaps & DDCAPS_OVERLAY) )
	    {
		DPF_ERR( "No overlay hardware emulation" );
		return DDERR_NOOVERLAYHW;
	    }
	}
	else
	{
	    if( 0 == (this->ddCaps.dwCaps & DDCAPS_OVERLAY) )
	    {
		if( probe_driver )
		    DPF( 2, "No overlay hardware. Trying emulation..." );
		else
		    DPF_ERR( "No overlay hardware" );
		return DDERR_NOOVERLAYHW;
	    }
	}
    }
    if(caps2 & DDSCAPS2_DEINTERLACE)
    {
	if( emulation )
	{
            DPF_ERR( "No deinterlacing hardware emulation" );
            return DDERR_INVALIDPARAMS;
	}
	else
	{
	    if( 0 == (this->ddsCapsMore.dwCaps2 & DDSCAPS2_DEINTERLACE) )
	    {
		if( probe_driver )
		    DPF( 2, "No deinterlace hardware. Trying emulation..." );
		else
		    DPF_ERR( "No deinterlace hardware" );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
#ifdef DEBUG
    if( (caps & DDSCAPS_FLIP) && !emulation && GetProfileInt("DirectDraw","nohwflip",0))
    {
	DPF(1,"pretending flip not supported in HW (due to nohwflip in [DirectDraw] of win.ini" );
	return DDERR_NOFLIPHW;
    }
#endif

    /*
     * fail requests for non-local video memory allocations if the driver does not
     * support non-local video memory.
     *
     * NOTE: Should we really do this or just let the allocation fail from natural
     * causes?
     *
     * ALSO NOTE: Don't have to worry about emulation as no emulated surface should
     * ever get this far with DDSCAPS_NONLOCALVIDMEM set.
     *
     * ALSO ALSO NOTE: Should we also fail DDSCAPS_LOCALVIDMEM if the driver does
     * not support DDSCAPS_NONLOCALVIDMEM. My feeling is that we should allow.
     * DDSCAPS_LOCALVIDMEM is legal with a non AGP driver - redundant but legal.
     */
    if( caps & DDSCAPS_NONLOCALVIDMEM )
    {
	if( !( this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM ) )
	{
	    DPF_ERR( "Driver does not support non-local video memory" );
	    return DDERR_NONONLOCALVIDMEM;
	}
    }

#if 0 //Old code
    //ATTENTION: Potential Apps compat problem!!
    /*
     * Optimized surfaces in video memory are only allowed if the HAL supports
     * them. We won't send a legacy driver create surface HAL calls for optimized
     * surfaces.
     */
    if( caps & DDSCAPS_OPTIMIZED )
    {
	if( caps & DDSCAPS_VIDEOMEMORY )
	{
	    if ( !(this->ddCaps.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) )
	    {
		DPF_ERR("Can't specify video memory optimized surface... Driver doesn't support optimized surfaces");
		return DDERR_NOOPTIMIZEHW;
	    }
	}
	if( caps & DDSCAPS_SYSTEMMEMORY )
	{
	    if ( !(this->ddHELCaps.ddsCaps.dwCaps & DDSCAPS_OPTIMIZED) )
	    {
		DPF_ERR("Can't specify system memory optimized surface... HEL doesn't support optimized surfaces");
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
#endif //0

    CheckExclusiveMode(this_lcl, &excl_exists, &is_excl, FALSE, NULL, FALSE);

    if (!is_excl ||  !(this->dwFlags & DDRAWI_FULLSCREEN) )
    {
	if( (caps & DDSCAPS_FLIP) && (caps & DDSCAPS_PRIMARYSURFACE) )
	{
	    DPF_ERR( "Must be in full-screen exclusive mode to create a flipping primary surface" );
	    return DDERR_NOEXCLUSIVEMODE;
	}
    }

    /*
     * see if we are creating the primary surface; if we are, see if
     * we can allow its creation
     */
    if( (caps & DDSCAPS_PRIMARYSURFACE) )
    {
	LPDDRAWI_DDRAWSURFACE_INT       pprim_int;

	pprim_int = this_lcl->lpPrimary;
	if( pprim_int )
	{
	    DPF_ERR( "Can't create primary, already created by this process" );
	    return DDERR_PRIMARYSURFACEALREADYEXISTS;
	}

	if( (excl_exists) && (is_excl) )
	{
	    /*
	     * we are the exclusive mode process invalidate everyone 
             * else's primary surfaces and create our own
	     */
            InvalidateAllPrimarySurfaces( this );
	}
	else if( excl_exists )
	{
	    /*
	     * we are not the exclusive mode process but someone else is
	     */
	    DPF(1, "Can't create primary, exclusive mode not owned" );
	    return DDERR_NOEXCLUSIVEMODE;
	}
	else
	{
	    /*
	     * no one has exclusive mode
	     */
	    if( !MatchPrimary( this, lpDDSurfaceDesc ) )
	    {
		DPF_ERR( "Can't create primary, incompatible with current primary" );
		return DDERR_INCOMPATIBLEPRIMARY;
	    }
	    /*
	     * otherwise, it is possible to create a primary surface
	     */
	}
    }

#ifdef SHAREDZ
    if( caps & DDSCAPS_SHAREDZBUFFER )
    {
	if( this_lcl->lpSharedZ != NULL )
	{
	    DPF_ERR( "Can't create shared Z, already created by this process" );
	    return DDERR_SHAREDZBUFFERALREADYEXISTS;
	}
	if( !MatchSharedZBuffer( this, lpDDSurfaceDesc ) )
	{
	    DPF_ERR( "Can't create shared Z buffer, incompatible with existing Z buffer" );
	    return DDERR_INCOMPATIBLESHAREDZBUFFER;
	}
    }
    if( caps & DDSCAPS_SHAREDBACKBUFFER )
    {
	if( this_lcl->lpSharedBack != NULL )
	{
	    DPF_ERR( "Can't create shared back-buffer, already created by this process" );
	    return DDERR_SHAREDBACKBUFFERALREADYEXISTS;
	}
	if( !MatchSharedBackBuffer( this, lpDDSurfaceDesc ) )
	{
	    DPF_ERR( "Can't create shared back buffer, incompatible with existing back buffer" );
	    return DDERR_INCOMPATIBLESHAREDBACKBUFFER;
	}
    }
#endif

    /*
     * make sure the driver wants this to happen...
     */

    if(caps & DDSCAPS_ZBUFFER) {
       //NOTE: In DX5, DDSD_PIXELFORMAT was never set for ZBuffers (except maybe for complex surfs)
       //      so drivers came to expect ccsd.bIsDifferentPixelFormat to be FALSE for ZBuffers,
       //      even though it should really be TRUE by definition and the spec.  Changing it to TRUE
       //      breaks CanCreateSurface in these old drivers (they return DRIVER_HANDLED+DDERR_INVALIDPIXELFORMAT)
       //      Sooo, I'm forcing it to be false for zbuffers, except for if zpixelformats is non-zero, which
       //      implies a DX6 driver which should be written to handle that field correctly.

       if(DRIVER_SUPPORTS_DX6_ZBUFFERS(this)) {
           // See manbug 27011.
           // Setting is_diff TRUE here makes it TRUE for typical DX5 primary creates.
           // This causes us to fault later on because we assume is_diff => pddpf is non-null.
           // is_diff == TRUE in this case also causes the nv4, nv10 drivers to fail cancreate.
           // The solution is to set is_diff false if it's a complex DX5 chain with Z
           //
	   //DDASSERT((caps & DDSCAPS_COMPLEX)==0);  // shouldve already forbidden complex surf creation w/stencil

            if ( caps & DDSCAPS_COMPLEX ) 
            {
	        is_diff=FALSE;
            }
            else
            {
	        is_diff=TRUE;
            }

       } else is_diff=FALSE;

    } else if( sdflags & DDSD_PIXELFORMAT )
    {
	is_diff = IsDifferentPixelFormat( &this->vmiData.ddpfDisplay, &lpDDSurfaceDesc->ddpfPixelFormat );
    }
    else
    {
	is_diff = FALSE;
    }
    DPF( 5, "is_diff = %d", is_diff );
    rc = DDHAL_DRIVER_NOTHANDLED;

    if( ccshalfn != NULL )
    {
	DPF(4,"Calling HAL for create surface, emulation == %d",emulation);

	ccsd.CanCreateSurface = ccshalfn;
	ccsd.lpDD = this;
	ccsd.lpDDSurfaceDesc = (LPDDSURFACEDESC)lpDDSurfaceDesc;
	ccsd.bIsDifferentPixelFormat = is_diff;
	
/*
 * This hack breaks Sundown (passing a pointer in an HRESULT).
 * No longer necessary following a change to ddhel.c (in myCanCreateSurface).
 * If that change gets backed out, we'll need a real fix here.
	
	if(emulation) {
	    // slight hack: need to sneak this ptr to HEL's myCanCreateSurface because it might
	    // need to LoadLib d3dim.dll and set this_lcl->hD3DInstance, if a Zbuffer is created

	    ccsd.ddRVal=(LONG_PTR) this_lcl; // **** needs to be fixed.
	}
*/

	/*
	 * !!! NOTE: Currently we don't support 16-bit versions of the HAL
	 * execute buffer members. If this is so do we need to use DOHALCALL?
	 */
	if( caps & DDSCAPS_EXECUTEBUFFER )
	{
	    DOHALCALL( CanCreateExecuteBuffer, ccsfn, ccsd, rc, emulation );
	}
	else
	{
	    DOHALCALL( CanCreateSurface, ccsfn, ccsd, rc, emulation );
	}
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( ccsd.ddRVal != DD_OK )
	    {
		DPF(2, "Driver says surface can't be created" );
		return ccsd.ddRVal;
	    }
	}
    }

    /*
     * if the driver didn't handle it, then fail any requests to create a
     * surface that differs in format from the primary surface, except for
     * z buffer and alpha
     */

    if( rc == DDHAL_DRIVER_NOTHANDLED )
    {
	if( is_diff && !(caps & (DDSCAPS_ZBUFFER|DDSCAPS_ALPHA)) )
	{
	    return DDERR_INVALIDPIXELFORMAT;
	}
    }

    /*
     * is this a primary surface chain?
     */
    if( caps & DDSCAPS_PRIMARYSURFACE )
    {
	is_primary_chain = TRUE;
    }
    else
    {
	is_primary_chain = FALSE;
    }

#ifdef SHAREDZ
    do_shared_z    = FALSE;
    do_shared_back = FALSE;
#endif

    /*
     * see if we are looking for a z-buffer with our surface
     */
    if( (caps & DDSCAPS_ZBUFFER) )
    {
	do_zbuffer = TRUE;
#ifdef SHAREDZ
	if( caps & DDSCAPS_SHAREDZBUFFER )
	    do_shared_z = TRUE;
#endif
	if( (caps & DDSCAPS_COMPLEX) )
	{
	    caps &= ~DDSCAPS_ZBUFFER;
#ifdef SHAREDZ
	    caps &= ~DDSCAPS_SHAREDZBUFFER;
#endif
	}
    }
    else
    {
	do_zbuffer = FALSE;
    }

    /*
     * see if we are looking for an alpha buffer with our surface
     */
    if( (caps & DDSCAPS_ALPHA) )
    {
	do_abuffer = TRUE;
	abuff_depth = lpDDSurfaceDesc->dwAlphaBitDepth;
	if( (caps & DDSCAPS_COMPLEX) )
	{
	    caps &= ~DDSCAPS_ALPHA;
	}
    }
    else
    {
	do_abuffer = FALSE;
	abuff_depth = 0;
    }

#ifdef SHAREDZ
    /*
     * See if we looking for a shared back-buffer with our surface
     */
    if( caps & DDSCAPS_SHAREDBACKBUFFER )
	do_shared_back = TRUE;
#endif

    /*
     * number of surfaces we need
     */
    nsurf = 1 + bbcnt;	
    // DX7stereo
    is_stereo = (BOOL)(caps2 & DDSCAPS2_STEREOSURFACELEFT);
    if ( is_stereo )
	{
		nsurf *= 2;
		nsflags |= DDRAWISURF_STEREOSURFACELEFT;
		caps2 &= ~DDSCAPS2_STEREOSURFACELEFT;
		DPF( 3, "doubling surfaces for stereo support" );
	}
    if( do_zbuffer && (caps & DDSCAPS_COMPLEX) )
    {
	nsurf++;
	DPF( 3, "adding one for zbuffer" );
    }
    if( do_abuffer && (caps & DDSCAPS_COMPLEX) )
    {
	nsurf++;
	DPF( 3, "adding one for alpha" );
    }
    is_cubemap = (BOOL)(caps2 & DDSCAPS2_CUBEMAP);
    if ( is_cubemap )
    {
        //Count the number of real surfaces we're making for the cube map
        DWORD dwCubeMapFaceCount =
            (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) ? 1 : 0 )+
            (( caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) ? 1 : 0 );
        /*
         * If it's a mipmap, then we add the back buffer count
         * to each face in the cube
         * If no mipmap, then bbcnt==0
         */
        DDASSERT(bbcnt == 0 || (bbcnt && (caps & DDSCAPS_MIPMAP)) ); //If we have nonzero backbuffercount, then it has to be mipmaps
        DDASSERT(!do_zbuffer);
        DDASSERT(!do_abuffer);
        nsurf = dwCubeMapFaceCount * (bbcnt+1);
        DPF( 5, "I count %d cubemap faces",dwCubeMapFaceCount);
    }
    DPF( 5, "bbcnt=%d,nsurf=%d", bbcnt, nsurf );
    DPF( 5, "do_abuffer=%d,do_zbuffer=%d,is_stereo=%d", do_abuffer, do_zbuffer, is_stereo );

    /*
     * Compute offsets into the surface list of the various distinguished
     * surface types.
     */

    /*
     * are we creating a non-flipping complex surface?
     */
    if( nsurf > 1 )
    {
	if( (caps & DDSCAPS_COMPLEX) && !(caps & DDSCAPS_FLIP) )
	{
	    bbuffoff = 0;
	}
	else
	{
	    bbuffoff = 1;
	}
	if( do_zbuffer )
	{
	    if( do_abuffer )
		zbuffoff = (nsurf - 2);
	    else
		zbuffoff = (nsurf - 1);
	}
    }
    else
    {
	bbuffoff = 0;
	if( do_zbuffer )
	    zbuffoff = 0;
    }

    /*
     * is this a flipping surface?
     */
    if( caps & DDSCAPS_FLIP )
    {
	is_flip = TRUE;
    }
    else
    {
	is_flip = FALSE;
    }

    /*
     * Are we creating a mip-map chain?
     */
    if( ( ( caps & ( DDSCAPS_COMPLEX | DDSCAPS_MIPMAP ) ) ==
	  ( DDSCAPS_COMPLEX | DDSCAPS_MIPMAP ) ) &&
	( sdflags & DDSD_MIPMAPCOUNT ) )
    {
	is_mipmap = TRUE;
    }
    else
    {
	is_mipmap = FALSE;
    }

    /*
     * The creation of flipping optimized mipmaps has a different semantic from that of
     * non-optimized mipmap chains.
     * Since a single optimized mipmap represents the entire mipmap chain, a request to create
     * a complex optimized mipmap must be interpreted as meaning "please create me n mipmap chains
     * each represented by a single optimized surface."
     * In this case we need to turn off the is_mipmap flag to prevent the sizes of the subsequent
     * backbuffers from being cut in half (as would happen for a non-optimized mipmap).
     */
#if 0 //Old code
    if (caps & DDSCAPS_OPTIMIZED)
    {
	is_mipmap = FALSE;
    }
#endif //0

    /*
     * set up the list array
     */
    if( nsurf <= pcsinfo->listsize )
    {
	slist_int = pcsinfo->slist_int;
	slist_lcl = pcsinfo->slist_lcl;
	slist = pcsinfo->slist;
    }
    else
    {
	slist_int = MemAlloc( nsurf * sizeof( LPDDRAWI_DDRAWSURFACE_INT ) );
	if( NULL == slist_int )
	{
	    return DDERR_OUTOFMEMORY;
	}
	slist_lcl = MemAlloc( nsurf * sizeof( LPDDRAWI_DDRAWSURFACE_LCL ) );
	if( slist_lcl == NULL )
	{
	    MemFree(slist_int);
            return DDERR_OUTOFMEMORY;
	}
	slist = MemAlloc( nsurf * sizeof( LPDDRAWI_DDRAWSURFACE_GBL ) );
	if( slist == NULL )
	{
	    MemFree(slist_int);
            MemFree(slist_lcl);
	    return DDERR_OUTOFMEMORY;
	}
	pcsinfo->slist_int = slist_int;
	pcsinfo->slist_lcl = slist_lcl;
	pcsinfo->slist = slist;
	pcsinfo->listsize = nsurf;
    }
    pcsinfo->listcnt = nsurf;

    /*
     * Create all needed surface structures.
     *
     * The callback fns, caps, and other misc things are filled in.
     * Memory for the surface is allocated later.
     */
    pcsinfo->needlink = TRUE;
    firstbbuff = TRUE;
    if( is_primary_chain )
    {
	nsflags |= DDRAWISURF_PARTOFPRIMARYCHAIN;
	if( this->dwFlags & DDRAWI_MODEX )
	{
	    if( this->dwFlags & DDRAWI_STANDARDVGA )
	    {
		caps |= DDSCAPS_STANDARDVGAMODE;
	    }
	    else
	    {
		caps |= DDSCAPS_MODEX;
	    }
	}
    }
    for( scnt=0;scnt<nsurf;scnt++ )
    {
	DPF( 4, "*** Structs Surface %d ***", scnt );

	is_curr_diff = is_diff;
	understood_pf = FALSE;
	sflags = nsflags;
	pddpf = NULL;

	/*
	 * get the base pixel format
	 */
	if( is_primary_chain || !(sdflags & DDSD_PIXELFORMAT) )
	{
	    #ifdef USE_ALPHA
		if( (caps & DDSCAPS_ALPHA) && !(caps & DDSCAPS_COMPLEX) )
		{
		    memset( &ddpf, 0, sizeof( ddpf ) );
		    ddpf.dwSize = sizeof( ddpf );
		    pddpf = &ddpf;
		    pddpf->dwAlphaBitDepth = lpDDSurfaceDesc->dwAlphaBitDepth;
		    pddpf->dwFlags = DDPF_ALPHAPIXELS;
		    is_curr_diff = TRUE;
		    understood_pf = TRUE;
		}
		else
	    #endif
	    {
		/*
		 * If this surface has been explicitly requested in system
		 * memory then we will force the allocation of a pixel
		 * format. Why? because explicit system memory surfaces
		 * don't get lost when a mode switches. This is a problem
		 * if the surface has no pixel format as we will pick up
		 * the pixel format of the current mode instead. Trouble
		 * is that the surface was not created in that mode so
		 * we end up with a bad bit depth - very dangerous. Heap
		 * corruption follows.
		 */
		if( real_sysmem && !( caps & DDSCAPS_EXECUTEBUFFER ) )
		{
		    DPF( 3, "Forcing pixel format for explicit system memory surface" );
		    ddpf = this->vmiData.ddpfDisplay;
		    pddpf = &ddpf;
		    is_curr_diff = TRUE;
		}

		/*
		 * If no pixel format is specified then we use the pixel format
		 * of the primary. So if we understand the pixel format of the
		 * primary then we understand the pixel format of this surface.
		 * With one notable exception. We always understand the pixel
		 * format of an execute buffer - it hasn't got one.
		 */
		if( ( this->vmiData.ddpfDisplay.dwFlags & UNDERSTOOD_PF ) ||
		    ( caps & DDSCAPS_EXECUTEBUFFER ) )
		{
		    understood_pf = TRUE;
		}
	    }
	}
	else
	{
	    /*
	     * If we have an explicit system memory surface with a pixel format
	     * I don't care whether the specifed pixel format is the same as the
	     * primary. We are going to store it anyway. This is vital as
	     * explicit system memory surfaces survive mode switches so they must
	     * carry their pixel format with them.
	     */
	    if( real_sysmem && !( caps & DDSCAPS_EXECUTEBUFFER ) )
	    {
		DPF( 3, "Forcing pixel format for explicit system memory surface" );
		is_curr_diff = TRUE;
	    }

	    if( is_curr_diff )
	    {
		pddpf = &ddpf;
		ddpf = lpDDSurfaceDesc->ddpfPixelFormat;
		if( pddpf->dwFlags & UNDERSTOOD_PF )
		{
		    understood_pf = TRUE;
		}
	    }
	    else
	    {

		if( this->vmiData.ddpfDisplay.dwFlags & UNDERSTOOD_PF )
		{
		    understood_pf = TRUE;
		}
	    }
	}

	if((caps & DDSCAPS_ZBUFFER) && !(caps & DDSCAPS_COMPLEX)) {

	  DDASSERT(nsurf==1);

	  understood_pf = is_curr_diff = TRUE;
	  pddpf = &ddpf;

	  // proper pixfmt will have been set in checkSurfaceDesc
	  ddpf=lpDDSurfaceDesc->ddpfPixelFormat;

	}

	/*
	 * set up caps for each surface
	 */
	if( scnt > 0 )
	{
	    /*
	     * mark implicitly created surfaces as such
	     */
	    sflags |= DDRAWISURF_IMPLICITCREATE;

	    /*
	     * eliminated unwanted caps.
	     * NOTE: If we are creating a flipping chain for a mip-mapped
	     * texture then we don't propagate the MIPMAP cap to the back
	     * buffers, only the front buffer is tagged as a mip-map.
	     */
	    caps &= ~(DDSCAPS_PRIMARYSURFACE |
		      DDSCAPS_FRONTBUFFER | DDSCAPS_VISIBLE |
		      DDSCAPS_ALPHA | DDSCAPS_ZBUFFER |
		      DDSCAPS_BACKBUFFER );
            caps2 &= ~DDSCAPS2_STEREOSURFACELEFT;
#ifdef SHAREDZ
	    caps &= ~(DDSCAPS_SHAREDZBUFFER | DDSCAPS_SHAREDBACKBUFFER);
#endif
	    /*
	     * Complex optimized mipmaps actually keep the mipmap tags on their back buffers
	     * since each surface represents a whole chain of mipmaps
	     */
#if 0 //Old code
	    if ((caps & DDSCAPS_OPTIMIZED) == 0)
	    {
		if( is_flip )
		    caps &= ~DDSCAPS_MIPMAP;
	    }
#endif //0
	    #ifdef USE_ALPHA

	    /*
	     * caps for an alpha buffer
	     */
	    if( (do_abuffer && do_zbuffer && (scnt == nsurf-1) ) ||
		(do_abuffer && (scnt == nsurf-1)) )
	    {
		DPF( 4, "TRY ALPHA" );
		caps &= ~(DDSCAPS_TEXTURE | DDSCAPS_FLIP | DDSCAPS_OVERLAY | DDSCAPS_OFFSCREENPLAIN);
		caps |= DDSCAPS_ALPHA;
		memset( &ddpf, 0, sizeof( ddpf ) );
		ddpf.dwSize = sizeof( ddpf );
		pddpf = &ddpf;
		pddpf->dwAlphaBitDepth = lpDDSurfaceDesc->dwAlphaBitDepth;
		pddpf->dwFlags = DDPF_ALPHA;
		understood_pf = TRUE;
		is_curr_diff = TRUE;
	    /*
	     * caps for a z buffer
	     */
	    }
	    else
	    #endif
	    if( do_zbuffer && ( scnt == zbuffoff ) )
	    {
		caps &= ~(DDSCAPS_TEXTURE | DDSCAPS_FLIP | DDSCAPS_OVERLAY | DDSCAPS_OFFSCREENPLAIN | DDSCAPS_3DDEVICE);
		caps |= DDSCAPS_ZBUFFER;


#ifdef SHAREDZ
		if( do_shared_z )
		    caps |= DDSCAPS_SHAREDZBUFFER;
#endif
		pddpf = &ddpf;

		DDASSERT(caps & DDSCAPS_COMPLEX);  // scnt>0, so this must be true

		// must construct a valid z pixfmt in ddpf since DDSurfaceDesc one is being used
		// be primary surface.  note complex surfdescs will never be able to create stencil zbufs
		memset(&ddpf, 0, sizeof(DDPIXELFORMAT));
		ddpf.dwSize=sizeof(DDPIXELFORMAT);
		ddpf.dwFlags|=DDPF_ZBUFFER;
		ddpf.dwZBufferBitDepth = ((DDSURFACEDESC *)lpDDSurfaceDesc)->dwZBufferBitDepth;
		ddpf.dwZBitMask = (1 << ((DDSURFACEDESC *)lpDDSurfaceDesc)->dwZBufferBitDepth)-1;


		is_curr_diff = TRUE;
		understood_pf = TRUE;

	    /*
	     * set up for offscreen surfaces
	     */
	    }
	    else
	    {
		if( (!is_mipmap) && (!is_cubemap) )
		{
		    /*
		     * Flip and back buffer don't apply to mip-map chains or cubemaps.
		     */
			// DX7Stereo spec case for stereo
			// mark odd backbuffers only as surfaceleft
			if (is_stereo && ((scnt & 1)!=0))
			{
			caps2 |= DDSCAPS2_STEREOSURFACELEFT;
			} else 
			{
		    caps |= DDSCAPS_FLIP;
		    if( firstbbuff )
		    {
			caps |= DDSCAPS_BACKBUFFER;
			sflags |= DDRAWISURF_BACKBUFFER;
#ifdef SHAREDZ
			if( do_shared_back )
			    caps |= DDSCAPS_SHAREDBACKBUFFER;
#endif
			firstbbuff = FALSE;
		    }
			}
		}
	    }
	/*
	 * the first surface...
	 */
	}
	else
	{
	    if( caps & DDSCAPS_PRIMARYSURFACE )
	    {
		caps |= DDSCAPS_VISIBLE;
	    }
	    if( caps & DDSCAPS_FLIP )
	    {
		caps |= DDSCAPS_FRONTBUFFER;
		sflags |= DDRAWISURF_FRONTBUFFER;
	    }
	    if( nsurf > 1 )
	    {
		sflags |= DDRAWISURF_IMPLICITROOT;
	    }
	    if( caps & DDSCAPS_BACKBUFFER )
	    {
		sflags |= DDRAWISURF_BACKBUFFER;
	    }
	}

	/*
	 * if it isn't a pixel format we grok, then it is different...
	 */
	if( !understood_pf )
	{
	    is_curr_diff = TRUE;
	}

	/*
	 * pick size of structure we need to allocate...
	 */
	if( (caps & DDSCAPS_OVERLAY) ||
	    ((caps & DDSCAPS_PRIMARYSURFACE) &&
	     ((this->ddCaps.dwCaps & DDCAPS_OVERLAY) ||
	      (this->ddHELCaps.dwCaps & DDCAPS_OVERLAY))) )
	{
	    sflags |= DDRAWISURF_HASOVERLAYDATA;
	}
	/*
	 * Execute buffers should NEVER have pixel formats.
	 */
	if( is_curr_diff && !( caps & DDSCAPS_EXECUTEBUFFER ) )
	{
	    sflags |= DDRAWISURF_HASPIXELFORMAT;
	}

	/*
	 * allocate the surface struct, allowing for overlay and pixel
	 * format data
	 *
	 * NOTE: This single allocation can allocate space for local surface
	 * structure (DDRAWI_DDRAWSURFACE_LCL), the additional local surface
	 * structure (DDRAWI_DDRAWSURFACE_MORE) and the global surface structure
	 * (DDRAWI_DDRAWSURFACE_GBL). (And now the global surface more structure too
	 * (DDRAWI_DDRAWSURFACE_GBL_MORE). As both the local and global objects
	 * can be variable sized this can get pretty complex. Additionally, we have
	 * 4 bytes just before the surface_gbl that points to the surface_gbl_more.
	 *
	 * CAVEAT: All future surfaces that share this global all point to this
	 * allocation. The last surface's release has to free it. During
	 * InternalSurfaceRelease (in ddsiunk.c) a calculation is made to determine
	 * the start of this memory allocation. If the surface being released is
	 * the first one, then freeing "this_lcl" will free the whole thing. If
	 * not, then "this_lcl->lpGbl - (Surface_lcl + surface_more + more_ptr)"
	 * is computed. Keep this layout in synch with code in ddsiunk.c.
	 *
	 *  The layout of the various objects in the allocation is as follows:
	 *
	 * +-----------------+---------------+----+------------+-----------------+
	 * | SURFACE_LCL     | SURFACE_MORE  |More| SURFACE_GBL| SURFACE_GBL_MORE|
	 * | (variable)      |               |Ptr | (variable) |                 |
	 * +-----------------+---------------+----+------------+-----------------+
	 * <- surf_size_lcl ->               |                                   |
	 * <- surf_size_lcl_more ------------>                                   |
	 * <- surf_size --------------------------------------------------------->
	 *
	 */

	if( sflags & DDRAWISURF_HASOVERLAYDATA )
	{
	    surf_size_lcl = sizeof( DDRAWI_DDRAWSURFACE_LCL );
	    DPF( 5, "OVERLAY DATA SPACE" );
	}
	else
	{
	    surf_size_lcl = offsetof( DDRAWI_DDRAWSURFACE_LCL, ddckCKSrcOverlay );
	}

	surf_size_lcl_more = surf_size_lcl + sizeof( DDRAWI_DDRAWSURFACE_MORE );

	if( ( sflags & DDRAWISURF_HASPIXELFORMAT ) || ( caps & DDSCAPS_PRIMARYSURFACE ) )
	{
	    DPF( 5, "PIXEL FORMAT SPACE" );
	    surf_size = surf_size_lcl_more + sizeof( DDRAWI_DDRAWSURFACE_GBL );
	}
	else
	{
	    surf_size = surf_size_lcl_more +
			    offsetof( DDRAWI_DDRAWSURFACE_GBL, ddpfSurface );
	}

	// Need to allocate a pointer just before the SURFACE_GBL to
	// point to the beginning of the GBL_MORE.
	surf_size += sizeof( LPDDRAWI_DDRAWSURFACE_GBL_MORE );

	// Need to allocate a SURFACE_GBL_MORE too
	surf_size += sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE );

	DPF( 5, "Allocating struct (%ld)", surf_size );
	existing_global = FALSE;
	if( caps & DDSCAPS_PRIMARYSURFACE )
	{
	    // attempt to find existing global primary surface
	    lpGlobalSurface = FindGlobalPrimary( this );
	}
#ifdef SHAREDZ
	else if( caps & DDSCAPS_SHAREDZBUFFER )
	{
	    DPF( 4, "Searching for shared Z-buffer" );
	    lpGlobalSurface = FindGlobalZBuffer( this );
	}
	else if( caps & DDSCAPS_SHAREDBACKBUFFER )
	{
	    DPF( 4, "Searching for shared back-buffer" );
	    lpGlobalSurface = FindGlobalBackBuffer( this );
	}
#endif
	else
	{
	    lpGlobalSurface = NULL;
	}
	if( lpGlobalSurface )
	{
	    DPF( 4, "Using shared global surface" );
	    #ifdef WIN95
		psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc16( surf_size_lcl_more, &ptr16 );
	    #else
		psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc( surf_size_lcl_more );
	    #endif
	    if( psurf_lcl != NULL )
	    {
		psurf_lcl->lpGbl = lpGlobalSurface;
	    }
	    existing_global = TRUE;
	}
	else
	{
	    #ifdef WIN95
		psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc16( surf_size, &ptr16 );
	    #else
		psurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) MemAlloc( surf_size );
	    #endif
	    if( psurf_lcl != NULL )
	    {
		LPVOID *ppsurf_gbl_more;

		// Initialize SURFACE_GBL pointer
		// skipping 4 bytes for a pointer to the GBL_MORE
		psurf_lcl->lpGbl = (LPVOID) (((LPSTR) psurf_lcl) +
			surf_size_lcl_more + sizeof( LPVOID ) );

		// Initialize GBL_MORE pointer
		ppsurf_gbl_more = (LPVOID *)((LPBYTE)psurf_lcl->lpGbl - sizeof( LPVOID ));
		*ppsurf_gbl_more = (LPVOID)
			((LPBYTE)psurf_lcl + surf_size
			- sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE ));

		// Sanity Check
		DDASSERT( *ppsurf_gbl_more == (LPVOID)GET_LPDDRAWSURFACE_GBL_MORE( psurf_lcl->lpGbl ) );

		// Initialize GBL_MORE structure
		GET_LPDDRAWSURFACE_GBL_MORE( psurf_lcl->lpGbl )->dwSize = sizeof( DDRAWI_DDRAWSURFACE_GBL_MORE );
		/*
		 * Init the contents stamp to 0 means the surface's contents can change at
		 * any time.
		 */
		if ( caps & (DDSCAPS_VIDEOPORT|DDSCAPS_OWNDC) )
		{
		    GET_LPDDRAWSURFACE_GBL_MORE( psurf_lcl->lpGbl )->dwContentsStamp = 0;
		}
		else
		{
		    GET_LPDDRAWSURFACE_GBL_MORE( psurf_lcl->lpGbl )->dwContentsStamp = 1;
		}
	    }
	}
	if( psurf_lcl == NULL )
	{
	    freeSurfaceList( slist_int, scnt );
	    return DDERR_OUTOFMEMORY;
	}
	psurf = psurf_lcl->lpGbl;

	/*
	 * allocate surface interface
	 */
	psurf_int = (LPDDRAWI_DDRAWSURFACE_INT) MemAlloc( sizeof( DDRAWI_DDRAWSURFACE_INT ));
	if( NULL == psurf_int )
	{
	    freeSurfaceList( slist_int, scnt );
	    MemFree( psurf_lcl );
	    return DDERR_OUTOFMEMORY;
	}

	/*
	 * fill surface specific stuff
	 */
	psurf_int->lpLcl = psurf_lcl;
	if (LOWERTHANDDRAW4(this_int))
	{
	    psurf_int->lpVtbl = &ddSurfaceCallbacks;
	}
	else if (this_int->lpVtbl == &dd4Callbacks)
	{
	    psurf_int->lpVtbl = &ddSurface4Callbacks;
	}
	else
	{
	    psurf_int->lpVtbl = &ddSurface7Callbacks;
	}

	if( existing_global )
	{
	    psurf_lcl->dwLocalRefCnt = 0;
	}
	else
	{
	    psurf_lcl->dwLocalRefCnt = OBJECT_ISROOT;
	}
	psurf_lcl->dwProcessId = pid;

	slist_int[scnt] = psurf_int;
	slist_lcl[scnt] = psurf_lcl;
	slist[scnt] = psurf;

	/*
	 * fill in misc stuff
	 */
	psurf->lpDD = this;
	psurf_lcl->dwFlags = sflags;

	/*
	 * initialize extended fields if necessary
	 */
	if( sflags & DDRAWISURF_HASOVERLAYDATA )
	{
	    psurf_lcl->lpSurfaceOverlaying = NULL;
	}

	/*
	 * Initialize the additional local surface data structure
	 */
	psurf_lcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE) (((LPSTR) psurf_lcl) + surf_size_lcl );
	psurf_lcl->lpSurfMore->dwSize = sizeof( DDRAWI_DDRAWSURFACE_MORE );
	psurf_lcl->lpSurfMore->lpIUnknowns = NULL;
	psurf_lcl->lpSurfMore->lpDD_lcl = this_lcl;
	psurf_lcl->lpSurfMore->lpDD_int = this_int;
	psurf_lcl->lpSurfMore->dwMipMapCount = 0UL;
	psurf_lcl->lpSurfMore->lpddOverlayFX = NULL;
	psurf_lcl->lpSurfMore->lpD3DDevIList = NULL;
	psurf_lcl->lpSurfMore->dwPFIndex = PFINDEX_UNINITIALIZED;

#ifdef WIN95
        psurf_lcl->dwModeCreatedIn = this->dwModeIndex;
#else
        psurf_lcl->lpSurfMore->dmiCreated = this->dmiCurrent;
#endif
	/*
	 * fill in the current caps
	 */
	psurf_lcl->lpSurfMore->ddsCapsEx = sd.ddsCaps.ddsCapsEx;
	if (DDSD_TEXTURESTAGE & sd.dwFlags) //hack here to pass the flag too as dwTextureStage is [0,7]
	    psurf_lcl->lpSurfMore->dwTextureStage = sd.dwTextureStage | DDSD_TEXTURESTAGE;
	psurf_lcl->ddsCaps.dwCaps = caps;
	psurf_lcl->lpSurfMore->lpbDirty=NULL;    //initialized
 	psurf_lcl->lpSurfMore->dwSurfaceHandle=0;    //initialized
        psurf_lcl->lpSurfMore->qwBatch.QuadPart=0;
        if (sd.dwFlags & DDSD_FVF)
            psurf_lcl->lpSurfMore->dwFVF = sd.dwFVF;    //just stuff it in no matter what the surface type
        else
            psurf_lcl->lpSurfMore->dwFVF = 0;

        /* 
         * Mark surface as driver managed if the surface is marked with
         * DDSCAPS2_TEXTUREMANAGE *and* if the driver claims it can manage textures
         */
        if((psurf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) &&
            !(psurf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) &&
            (psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE) && 
            (psurf_lcl->lpSurfMore->lpDD_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANMANAGETEXTURE))
        {
            psurf_lcl->dwFlags |= DDRAWISURF_DRIVERMANAGED;
        }
        else if((psurf_lcl->lpSurfMore->lpDD_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) &&
                (psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
        {
            DDASSERT((psurf_lcl->lpSurfMore->lpDD_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANMANAGERESOURCE));
            psurf_lcl->dwFlags |= DDRAWISURF_DRIVERMANAGED;
        }

        /*
         * If it's a cubemap, then we need to mark up the surface's caps accordingly
         *
         * Cubemaps are laid out in the surface list such that the 0th and every subsequent
         * (bbcnt+1)th surface are the top levels of the mipmap. Surfaces in between these
         * are the mip levels. All surfaces in the map are tagged with their face cap.
         */
        if (is_cubemap)
        {
            int i;
            DWORD dwOrderedFaces[6] = {
                                       DDSCAPS2_CUBEMAP_POSITIVEX,
                                       DDSCAPS2_CUBEMAP_NEGATIVEX,
                                       DDSCAPS2_CUBEMAP_POSITIVEY,
                                       DDSCAPS2_CUBEMAP_NEGATIVEY,
                                       DDSCAPS2_CUBEMAP_POSITIVEZ,
                                       DDSCAPS2_CUBEMAP_NEGATIVEZ
            };
            int n;
            /*
             * Now we find the nth cubemap face in our ordered list.
             * This is the ordering, but some may be missing from the surfacedesc:
             *   DDSCAPS2_CUBEMAP_POSITIVEX
             *   DDSCAPS2_CUBEMAP_NEGATIVEX
             *   DDSCAPS2_CUBEMAP_POSITIVEY
             *   DDSCAPS2_CUBEMAP_NEGATIVEY
             *   DDSCAPS2_CUBEMAP_POSITIVEZ
             *   DDSCAPS2_CUBEMAP_NEGATIVEZ
             */
            n = (int) (scnt/(bbcnt+1));
            DDASSERT(n<=5);
            i=0;
            do
            {
                if (dwOrderedFaces[i] & sd.ddsCaps.dwCaps2)
                    n--;
            }
            while (n>=0 && i++<6);
            psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_CUBEMAP_ALLFACES;
            psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |= dwOrderedFaces[i];
            /*
             * Every top-level face is marked as a cubemap
             */
            psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_CUBEMAP;
        }

        if (is_stereo)
        {
            psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 = caps2;
        } 

        /*
         * Allocate memory to hold region list for D3D texture management
         */
        if(IsD3DManaged(psurf_lcl))
        {
            LPREGIONLIST lpRegionList;
            lpRegionList = (LPREGIONLIST)MemAlloc(sizeof(REGIONLIST));
            if(lpRegionList == NULL)
            {
                DPF_ERR("Out of memory allocating region list");
                freeSurfaceList( slist_int, scnt );
                psurf_lcl->lpSurfMore->lpRegionList = 0;
	        MemFree( psurf_lcl );
	        MemFree( psurf_int );
	        return DDERR_OUTOFMEMORY;
            }
            lpRegionList->rdh.dwSize = sizeof(RGNDATAHEADER);
            lpRegionList->rdh.iType = RDH_RECTANGLES;
            lpRegionList->rdh.nCount = 0;
            lpRegionList->rdh.nRgnSize = 0;
            lpRegionList->rdh.rcBound.left = LONG_MAX;
            lpRegionList->rdh.rcBound.right = 0;
            lpRegionList->rdh.rcBound.top = LONG_MAX;
            lpRegionList->rdh.rcBound.bottom = 0;
            psurf_lcl->lpSurfMore->lpRegionList = lpRegionList;
        }
        else
        {
            psurf_lcl->lpSurfMore->lpRegionList = 0;            
        }

	/*
	 * set up format info
	 *
	 * are we creating a primary surface?
	 */
	if( caps & DDSCAPS_PRIMARYSURFACE )
	{
	    /*
	     * NOTE: Previously we set ISGDISURFACE for all primary surfaces
	     * We now set it only for primarys hanging off display drivers.
	     * This is to better support drivers which are not GDI display
	     * drivers.
	     */
	    if( this->dwFlags & DDRAWI_DISPLAYDRV )
		psurf->dwGlobalFlags |= DDRAWISURFGBL_ISGDISURFACE;
	    psurf->wHeight = (WORD) this->vmiData.dwDisplayHeight;
	    psurf->wWidth = (WORD) this->vmiData.dwDisplayWidth;
	    psurf->lPitch = this->vmiData.lDisplayPitch;
	    DPF(5,"Primary Surface get's display size:%dx%d",psurf->wWidth,psurf->wHeight);
	    if( !understood_pf && (pddpf == NULL) )
	    {
		ddpf = this->vmiData.ddpfDisplay;
		pddpf = &ddpf;
	    }
	    bpp = this->vmiData.ddpfDisplay.dwRGBBitCount;
	}
	else
	{
	    /*
	     * process a plain ol' non-primary surface
	     */

	    /*
	     * set up surface attributes
	     */
	    if( scnt > 0 )
	    {
		/*
		 * NOTE: Don't have to worry about execute buffers here as
		 * execute buffers can never be created as part of a complex
		 * surface and hence scnt will never be > 0 for an execute
		 * buffer.
		 */
		DDASSERT( !( caps & DDSCAPS_EXECUTEBUFFER ) );

		/*
		 * If we are doing a mip-map chain then the width and height
		 * of each surface is half that of the preceeding surface.
                 * If we are doing cubemaps, then we need to reset every
                 * (bbcnt+1)th surface to the supplied size
		 */
		if( !is_mipmap || (is_cubemap && ((scnt%(bbcnt+1))==0) ) )
		{
		    psurf->wWidth  = slist[0]->wWidth;
		    psurf->wHeight = slist[0]->wHeight;
		}
		else
		{
		    psurf->wWidth  = max ( slist[scnt - 1]->wWidth  / 2 , 1);
		    psurf->wHeight = max ( slist[scnt - 1]->wHeight / 2 , 1);
		}
	    }
	    else
	    {
		if( caps & DDSCAPS_EXECUTEBUFFER )
		{
		    /*
		     * NOTE: Execute buffers are a special case. They are
		     * linear and not rectangular. We therefore store zero
		     * for width and height, they have no pitch and store
		     * their linear size in dwLinerSize (in union with lPitch).
		     * The linear size is given by the width of the surface
		     * description (the width MUST be specified - the height
		     * MUST NOT be).
		     */
		    DDASSERT(    lpDDSurfaceDesc->dwFlags & DDSD_WIDTH    );
		    DDASSERT( !( lpDDSurfaceDesc->dwFlags & DDSD_HEIGHT ) );

		    psurf->wWidth       = 0;
		    psurf->wHeight      = 0;
		    psurf->dwLinearSize = lpDDSurfaceDesc->dwWidth;
		}
		else
		{
		    if( sdflags & DDSD_HEIGHT )
		    {
			psurf->wHeight = (WORD) lpDDSurfaceDesc->dwHeight;
		    }
		    else
		    {
			psurf->wHeight = (WORD) this->vmiData.dwDisplayHeight;
		    }
		    if( sdflags & DDSD_WIDTH )
		    {
			psurf->wWidth = (WORD) lpDDSurfaceDesc->dwWidth;
		    }
		    else
		    {
			psurf->wWidth = (WORD) this->vmiData.dwDisplayWidth;
		    }
		}
	    }

	    /*
	     * set pixel format and pitch for surfaces we understand
	     */
	    if( lpDDSurfaceDesc->dwFlags & DDSD_PITCH )
	    {
		/*
		 * Client has alloc'd surface memory and specified its pitch.
		 */
		psurf->lPitch = lpDDSurfaceDesc->lPitch;
	    }
	    else if( caps & DDSCAPS_EXECUTEBUFFER )
	    {
		/*
		 * Execute buffers need to be handled differently from
		 * other surfaces. They never have pixel formats and
		 * BPP is a bit meaningless. You might wonder why we call
		 * ComputePitch at all for execute buffers. Well, they
		 * may also have alignment requirements and so it we
		 * need to give ComputePitch a chance to enlarge the
		 * size of the execute buffer.
		 *
		 * NOTE: For the purposes of this calculation. Execute
		 * buffers are 8-bits per pixel.
		 */
		psurf->dwLinearSize = ComputePitch( this, caps, psurf->dwLinearSize, 8U );
		if( psurf->dwLinearSize == 0UL )
		{
		    DPF_ERR( "Computed linear size of execute buffer as zero" );
                    MemFree(psurf_lcl->lpSurfMore->lpRegionList);
		    MemFree( psurf_lcl );
		    MemFree( psurf_int ); //oops, someone forgot these (jeffno 960118)
		    freeSurfaceList( slist_int, scnt );
		    return DDERR_INVALIDPARAMS;
		}
	    }
	    else
	    {
		if( understood_pf )
		{
		    LPDDPIXELFORMAT     pcurr_ddpf;

		    pcurr_ddpf = NULL;
		    if( is_curr_diff )
		    {
			if( (caps & DDSCAPS_FLIP) && scnt > 0 )
			{
			    GET_PIXEL_FORMAT( slist_lcl[0], slist[0], pcurr_ddpf );
			    pddpf->dwRGBBitCount = pcurr_ddpf->dwRGBBitCount;
			    bpp = pddpf->dwRGBBitCount;
			}
			else
			{
			    if(pddpf->dwFlags & DDPF_ZBUFFER) {
		   // note dwZBufferBitDepth includes any stencil bits too
			       bpp = (UINT)pddpf->dwZBufferBitDepth;
		} else {
		    bpp = (UINT) pddpf->dwRGBBitCount;
		}

			    if( bpp == 0 )
			    {
				bpp = (UINT) this->vmiData.ddpfDisplay.dwRGBBitCount;
				pddpf->dwRGBBitCount = (DWORD) bpp;
			    }
			}
		    }
		    else
		    {
			bpp = (UINT) this->vmiData.ddpfDisplay.dwRGBBitCount;
		    }
		    vm_pitch = (LONG) ComputePitch( this, caps,
					(DWORD) psurf->wWidth, bpp );
		    if( vm_pitch == 0 )
		    {
			DPF_ERR( "Computed pitch of 0" );
                        MemFree(psurf_lcl->lpSurfMore->lpRegionList);
			MemFree( psurf_lcl );
			MemFree( psurf_int ); //oops, someone forgot these (jeffno 960118)
			freeSurfaceList( slist_int, scnt );
			return DDERR_INVALIDPARAMS;
		    }
		}
		else
		{
		    vm_pitch = -1;
		}
		psurf->lPitch = vm_pitch;
	    }
	}

        /*
         * If this is a sysmem surface used for DX8, we need to use the memory 
         * that has already been allocated for this surface
         */
         if( (DX8Flags & DX8SFLAG_DX8) && real_sysmem && pSysMemInfo != NULL )
         {
            psurf->dwGlobalFlags |= DDRAWISURFGBL_DX8SURFACE;
            psurf->lPitch = pSysMemInfo[scnt].iPitch;
            psurf->fpVidMem = (ULONG_PTR) pSysMemInfo[scnt].pbPixels;
         }

         /*
          * If it's a volume texture, set that up
          */
         if ((DX8Flags & DX8SFLAG_DX8) && (lpDDSurfaceDesc->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME))
         {
             if (scnt > 0)
             {
                 psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;
             }
             psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps4 = 
                 MAKELONG((WORD)(pSysMemInfo[scnt].cpDepth),0);
             psurf->lSlicePitch = pSysMemInfo[scnt].iSlicePitch;
         }

	/*
	 *  Figure out what Blitting tables to use
	 */

	/*
	 * Initialize junctions if necessary
	 */
	if( g_rgjunc8 == NULL )
	{
	    HRESULT hr = InitializeJunctions( dwRegFlags & DDRAW_REGFLAGS_DISABLEMMX );
	    if( FAILED( hr ) )
	    {
		DPF_ERR( "InitializeJunctions failed" );
		return hr;
	    }
	}
	/*
	 *      Figure out what blitting table to use
	 */
	switch( bpp )
	{
	case 8:
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc8;
	    break;
	case 16:
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc565;
	    break;
	case 24:
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc24;
	    break;
	case 32:
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc32;
	    break;
        case 0:
            // DX7: Handle YUY2 and UYVY FourCC as just being 16bpp for the
            // purposes of bltting
            if (pddpf &&
                (pddpf->dwFlags & DDPF_FOURCC) &&
                ((pddpf->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2')) ||
                 (pddpf->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))))
            {
	        psurf_lcl->lpSurfMore->rgjunc = (VOID *) g_rgjunc565;
            }
            else
            {
                // No junction table support for other FOURCCs
	        psurf_lcl->lpSurfMore->rgjunc = (VOID *) NULL;
            }
            break;

	default:
	    // No table? Must be something weird like 1, 2, or 4 bits
	    psurf_lcl->lpSurfMore->rgjunc = (VOID *) NULL;
	    break;
	}

	/*
	 * first surface in flippable chain gets a back buffer count
	 */
	if( (scnt == 0) && (caps & DDSCAPS_FLIP) )
	{
	    psurf_lcl->dwBackBufferCount = lpDDSurfaceDesc->dwBackBufferCount;
	}
	else
	{
	    psurf_lcl->dwBackBufferCount = 0;
	}

	/*
	 * Each surface in the mip-map chain gets the number of levels
	 * in the map (including this level).
	 */
	if( caps & DDSCAPS_MIPMAP )
	{
	    if( is_mipmap )
	    {
		/*
		 * Part of complex mip-map chain.
                 * If it's a cube map, then its mip level is how far we are into the list
                 * away from the last top-level face. Top level faces are every bbcnt+1.
		 */
                if (is_cubemap)
                {
		    psurf_lcl->lpSurfMore->dwMipMapCount = ((nsurf - scnt -1) % (bbcnt+1) ) + 1;
                }
                else
                {
		    psurf_lcl->lpSurfMore->dwMipMapCount = (nsurf - scnt);
                }

                /*
                 * Set sublevel cap for any non-top-level (if we are not at a (bbcnt+1)th level)
                 */
                psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 &= ~DDSCAPS2_MIPMAPSUBLEVEL;
                if ( scnt%(bbcnt+1) )
                    psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 |= DDSCAPS2_MIPMAPSUBLEVEL;

		DPF( 5, "Assigning mip-map level %d to mip-map %d", psurf_lcl->lpSurfMore->dwMipMapCount, scnt );
	    }
	    else
	    {
		/*
		 * Single level map - not part of a chain.
		 */
		DPF( 5, "Assign mip-map level of 1 to single level mip-map" );
		psurf_lcl->lpSurfMore->dwMipMapCount = 1UL;
	    }
	}

	/*
	 * assign pixel format...
	 */
	if( is_curr_diff )
	{
	    /*
	     * Execute buffers should NEVER have a pixel format.
	     */
	    DDASSERT( !( caps & DDSCAPS_EXECUTEBUFFER ) );

	    psurf->ddpfSurface=*pddpf;

	    if( understood_pf )
	    {
		DPF( 5, "pitch=%ld, bpp = %d, (%hu,%hu)", psurf->lPitch,
					(UINT) psurf->ddpfSurface.dwRGBBitCount,
					psurf->wWidth, psurf->wHeight );
	    }
	}
	else
	{
	    if( !( caps & DDSCAPS_EXECUTEBUFFER ) )
	    {
		/*
		 * Somewhat misleading message for an execute buffer.
		 */
		DPF( 5, "pitch=%ld, WAS THE SAME PIXEL FORMAT AS PRIMARY", psurf->lPitch  );
	    }
	}

	/*
	 * FINALLY: set up attached surfaces: back buffers + alpha + Z
	 *
	 * NOTE:  Z & alpha get attached to the back buffer
	 */
	if( nsurf > 1 )
	{
	    #ifdef USE_ALPHA
	    if( do_zbuffer && do_abuffer && (scnt == nsurf-1) )
	    {
		DPF( 5, "linking alpha buffer to back buffer" );
		AddAttachedSurface( slist_lcl[bbuffoff], psurf_lcl, TRUE );
	    }
	    else if( do_zbuffer && do_abuffer && (scnt == nsurf-2) )
	    {
		DPF( 5, "linking Z buffer to back buffer" );
		AddAttachedSurface( slist_lcl[bbuffoff], psurf_lcl, TRUE );
	    }
	    else if( do_abuffer && (scnt == nsurf-1) )
	    {
		DPF( 5, "linking alpha buffer to back buffer" );
		AddAttachedSurface( slist_lcl[bbuffoff], psurf_lcl, TRUE );
	    }
	    else
	    #endif
	    if( do_zbuffer && (scnt == nsurf-1) )//DX7Stereo: adjust this for stereo
	    {
		DPF( 5, "linking Z buffer to back buffer" );
		AddAttachedSurface( slist_int[bbuffoff], psurf_int, TRUE );
	    }
	    // DX7Stereo: for stereo, exclude this case and handle it later
	    else if(!is_stereo && (is_flip && ((scnt == nsurf-1) ||
	    #ifndef USE_ALPHA
		       (do_zbuffer && do_abuffer && (scnt == nsurf-3)) ||
		       (do_abuffer && (scnt == nsurf-2)) ||
	    #endif
		       (do_zbuffer && (scnt == nsurf-2)))) )
	    {
		/*
		 * NOTE: For mip-maps we don't chain the last surface back
		 * to the first.
		 */


		DPF( 5, "linking buffer %d to buffer %d", scnt-1, scnt );
		AddAttachedSurface( slist_int[scnt-1], psurf_int, TRUE );
		/*
		 * link last surface to front buffer
		 */
		DPF( 5, "linking last buffer (%d) to front buffer", scnt );
		AddAttachedSurface( slist_int[scnt], slist_int[0], TRUE );
	    }
            else if( is_cubemap)
            {
                /*
                 * Every (bbcnt+1)th surface needs to be linked to the very first
                 * Otherwise, it's a mip level that needs linking to its parent
                 */
                if ( scnt>0 )
                {
                    if ( (scnt % (bbcnt+1)) == 0 )
                    {
                        DPF( 5, "linking cubemap surface #%d to root", scnt );
		        AddAttachedSurface( slist_int[0], psurf_int, TRUE );
                    }
                    else
                    {
                        DPF( 5, "linking cubemap mip surface #%d to buffer #%d", scnt-1, scnt );
		        AddAttachedSurface( slist_int[scnt-1], psurf_int, TRUE );
                    }
                }
            }
	    else if( ( is_flip || is_mipmap ) && (scnt > 0) )
	    {
			if (!is_stereo)	// DX7Stereo
			{
				DPF( 5, "linking buffer %d to buffer %d", scnt-1, scnt );
				AddAttachedSurface( slist_int[scnt-1], psurf_int, TRUE );
			} else
			{
				if (scnt & 1)
				{
					DPF( 5, "linking left buffer %d to buffer %d", scnt-1, scnt );
					AddAttachedSurface( slist_int[scnt-1], psurf_int, TRUE );
				} else
				{
					DPF( 5, "linking back buffer %d to buffer %d", scnt-2, scnt );
					AddAttachedSurface( slist_int[scnt-2], psurf_int, TRUE );
				}
				if (scnt==nsurf-1)
				{
					DPF( 5, "linking last back buffer %d to primary buffer", scnt-1);
					AddAttachedSurface( slist_int[scnt-1], slist_int[0], TRUE );
				}
			}
	    }
	    DPF( 4, "after addattached" );
	}

    } //end for(surfaces)
    DPF( 4, "**************************" );

    if ((caps & 
             (DDSCAPS_TEXTURE       | 
              DDSCAPS_EXECUTEBUFFER | 
              DDSCAPS_3DDEVICE      | 
              DDSCAPS_ZBUFFER)) &&
         !(DX8Flags & DX8SFLAG_IMAGESURF)
       )
    {
        int i;
        for (i=0; i < nsurf; i++)
        {
            slist_lcl[i]->lpSurfMore->dwSurfaceHandle=
            GetSurfaceHandle(&SURFACEHANDLELIST(this_lcl),slist_lcl[i]);
            //DPF(0,"Got slist_lcl[0]->lpSurfMore->dwSurfaceHandle=%08lx",slist_lcl[0]->lpSurfMore->dwSurfaceHandle);
        }
    }
    /*
     * OK, now create the physical surface(s)
     *
     * First, see if the driver wants to do it.
     */
    if( cshalfn != NULL )
    {
	DPF(4,"Calling driver to see if it wants to say something about create surface");
	csd.CreateSurface = cshalfn;
	csd.lpDD = this;
	csd.lpDDSurfaceDesc = (LPDDSURFACEDESC)lpDDSurfaceDesc;
	csd.lplpSList = slist_lcl;
	csd.dwSCnt = nsurf;

        //
        // record the creation stuff for dx7 drivers so we can do an atomic restore
        // with exactly the same parameters
        //
        if (NULL != this->lpDDCBtmp->HALDDMiscellaneous2.CreateSurfaceEx && 
            (nsurf > 1))
        {
            DDASSERT(slist_lcl[0]->lpSurfMore->cSurfaces == 0);
            DDASSERT(slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2 == 0);
            DDASSERT(slist_lcl[0]->lpSurfMore->slist == 0);

            
            slist_lcl[0]->lpSurfMore->slist = MemAlloc( sizeof(slist_lcl[0]) * nsurf );

            if( slist_lcl[0]->lpSurfMore->slist )
            {
                slist_lcl[0]->lpSurfMore->cSurfaces = nsurf;
                memcpy(slist_lcl[0]->lpSurfMore->slist , slist_lcl, sizeof(slist_lcl[0]) * nsurf ); 

                //
                // we don't need to waste all this goo on mipmaps
                //
                if ((0 == (slist_lcl[0]->ddsCaps.dwCaps & DDSCAPS_MIPMAP)) ||
                    (slist_lcl[0]->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP) )
                {
                    slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2 = MemAlloc(sizeof(*lpDDSurfaceDesc));
                    if ( slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2 )
                    {
                        memcpy(slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2, lpDDSurfaceDesc, sizeof(*lpDDSurfaceDesc) ); 
                    }
                    else
                    {
                        MemFree(slist_lcl[0]->lpSurfMore->slist);
                        slist_lcl[0]->lpSurfMore->slist=0;
                    }
                }
            }
        }

        /*
	 * NOTE: Different HAL entry points for execute buffers and
	 * conventional surfaces.
	 */
	if( caps & DDSCAPS_EXECUTEBUFFER )
	{
	    DOHALCALL( CreateExecuteBuffer, csfn, csd, rc, emulation );\
        }
        else
        {
            #ifdef    WIN95
                /* Copy the VXD handle from the per process local structure to global.
                 * This handle will be used by DDHAL32_VidMemAlloc(), rather than creating
                 * a new one using GetDXVxdHandle(). The assumptions here are:
                 * 1) Only one process can enter createSurface(), 2) Deferred calls to
                 * DDHAL32_VidMemAlloc() will result in the slow path, ie getting
                 * the VXD handle using GetDXVxdHandle().
                 * (snene 2/23/98)
                 */
                this->hDDVxd = this_lcl->hDDVxd;
            #endif /* WIN95 */

            DOHALCALL( CreateSurface, csfn, csd, rc, emulation );

            #ifdef    WIN95
                /* Restore the handle to INVALID_HANDLE_VALUE so that non-createSurface()
                 * calls using DDHAL32_VidMemAlloc() or deferred calls (possibly from other
                 * processes) will correctly recreate the handle using GetDXVxdHandle().
                 * (snene 2/23/98)
                 */
                this->hDDVxd = (DWORD)INVALID_HANDLE_VALUE;
            #endif /* WIN95 */
        }
	if( rc == DDHAL_DRIVER_HANDLED )
	{
	    if( csd.ddRVal != DD_OK )
	    {
                int i;
		#ifdef DEBUG
		    if( emulation )
		    {
			DPF( 1, "Emulation won't let surface be created, rc=%08lx (%ld)",
				    csd.ddRVal, LOWORD( csd.ddRVal ) );
		    }
		    else
		    {
			DPF( 1, "Driver won't let surface be created, rc=%08lx (%ld)",
				    csd.ddRVal, LOWORD( csd.ddRVal ) );
		    }
		#endif
                for (i=0; i < nsurf; i++)
                {
                    if (slist_lcl[i]->lpSurfMore->dwSurfaceHandle)
                        ReleaseSurfaceHandle(&SURFACEHANDLELIST(this_lcl),
                            slist_lcl[i]->lpSurfMore->dwSurfaceHandle);
                }
                if (slist_lcl[0]->lpSurfMore->slist)
                {   
                    MemFree(slist_lcl[0]->lpSurfMore->slist);
                }
                if (slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2)
                {
                    MemFree(slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2);
                }
		freeSurfaceList( slist_int, nsurf );

                //
                // If this routine returns either of these error values, then the calling routine
                // (createandlinksurfaces) will assume that something was wrong with the ddsurfacedesc
                // and return the error code to the app. This messes up the case where the app didn't
                // specify a memory type (sys/vid), since if the driver returns one of these codes on
                // the vidmem attempt, we will bail to the app and not try the sysmem attempt.
                //
                if ((csd.ddRVal == DDERR_INVALIDPARAMS || csd.ddRVal == DDERR_INVALIDCAPS) && 
                    (caps & DDSCAPS_VIDEOMEMORY) )
                {
                    csd.ddRVal = DDERR_INVALIDPIXELFORMAT;
                    DPF( 2, "Mutating driver's DDERR_INVALIDPARAMS/INVALIDCAPS into DDERR_INVALIDPIXELFORMAT!");
                }

		return csd.ddRVal;
	    }
	}
    }

#if 0 //Old code
    if ( (slist_lcl[0]->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)!= 0)
    {
	for( scnt=0;scnt<nsurf;scnt++ )
	{
	    /*
	     * Optimized surfaces get neither memory nor aliases at creation time.
	     * (In fact they'll never be aliased because they can't be locked.)
	     */

	    /*
	     * Optimized surfaces are born free!
	     */
	    if (slist_lcl[scnt]->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
	    {
		//HEL should have done this
		DDASSERT(slist_lcl[scnt]->lpGbl->dwGlobalFlags & DDRAWISURFGBL_MEMFREE);
	    }
	    slist_lcl[scnt]->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_MEMFREE;
	}
    }
    else //else not optimized surface
    {
#endif //0
	/*
	 * now, allocate any unallocated surfaces
	 */
	ddrval = AllocSurfaceMem( this_lcl, slist_lcl, nsurf );
	if( ddrval != DD_OK )
	{
            int i;
            for (i=0; i < nsurf; i++)
            {
                if (slist_lcl[i]->lpSurfMore->dwSurfaceHandle)
                    ReleaseSurfaceHandle(&SURFACEHANDLELIST(this_lcl),
                        slist_lcl[i]->lpSurfMore->dwSurfaceHandle);
            }
            if (slist_lcl[0]->lpSurfMore->slist)
            {   
                MemFree(slist_lcl[0]->lpSurfMore->slist);
            }
            if (slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2)
            {
                MemFree(slist_lcl[0]->lpSurfMore->pCreatedDDSurfaceDesc2);
            }
	    freeSurfaceList( slist_int, nsurf );
	    return ddrval;
	}

	#ifdef USE_ALIAS
	    /*
	     * If this device has heap aliases then precompute the pointer
	     * alias for the video memory returned at creation time. This
	     * is by far the most likely pointer we are going to be handing
	     * out at lock time so we are going to make lock a lot faster
	     * by precomputing this then at lock time all we need to do is
	     * compare the pointer we got from the driver with fpVidMem. If
	     * they are equal then we can just return this cached pointer.
	     */
	    for( scnt=0;scnt<nsurf;scnt++ )
	    {
		LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

		lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE( slist_lcl[scnt]->lpGbl );
		if( slist_lcl[scnt]->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY )
                {
		    lpGblMore->fpAliasedVidMem = GetAliasedVidMem( this_lcl, slist_lcl[scnt],
								   slist_lcl[scnt]->lpGbl->fpVidMem );
                    // If we succeeded in getting an alias, cache it for future use. Also store the original
                    // fpVidMem to compare with before using the cached pointer to make sure the cached value
                    // is still valid
                    if (lpGblMore->fpAliasedVidMem)
                        lpGblMore->fpAliasOfVidMem = slist_lcl[scnt]->lpGbl->fpVidMem;
                    else
                        lpGblMore->fpAliasOfVidMem = 0;
                }
		else
                {
		    lpGblMore->fpAliasedVidMem = 0UL;
                    lpGblMore->fpAliasOfVidMem = 0UL;
                }
	    }
	#endif /* USE_ALIAS */
#if 0 //Old code
    } //if optimized surface
#endif //0

    /*
     * remember the primary surface...
     */
    if( lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
    {
	this_lcl->lpPrimary = slist_int[0];
    }

#ifdef SHAREDZ
    /*
     * remember the shared back and z-buffers (if any).
     */
    if( lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_SHAREDZBUFFER )
    {
	this_lcl->lpSharedZ = slist_int[zbuffoff];

	/*
	 * It is possible that the an existing shared z-buffer we found
	 * was lost. If it was then the creation process we went through
	 * above has rendered it "found" so clear the lost surface flags.
	 */
	this_lcl->lpSharedZ->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
    }
    if( lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_SHAREDBACKBUFFER )
    {
	this_lcl->lpSharedBack = slist_int[bbuffoff];

	/*
	 * It is possible that the an existing shared back-buffer we found
	 * was lost. If it was then the creation process we went through
	 * above has rendered it "found" so clear the lost surface flags.
	 */
	this_lcl->lpSharedBack->lpGbl->dwGlobalFlags &= ~DDRAWISURFGBL_MEMFREE;
    }
#endif

    if (
#ifdef  WINNT
        // on NT side, we still call CreateSurfaceEx if HW driver isn't called
        emulation && slist_lcl[0]->hDDSurface &&
#endif  //WINNT
        !(DX8Flags & DX8SFLAG_ISLOST)
       )
    {
        DDASSERT(this_lcl == slist_lcl[0]->lpSurfMore->lpDD_lcl);
        return createsurfaceEx(slist_lcl[0]);
    }
    return DD_OK;

} /* createSurface */

/*
 * createAndLinkSurfaces
 *
 * Really create the surface.   Also used by EnumSurfaces
 * Assumes the lock on the driver object has been taken.
 */
HRESULT createAndLinkSurfaces(
	LPDDRAWI_DIRECTDRAW_LCL this_lcl,
	LPDDSURFACEDESC2 lpDDSurfaceDesc,
	BOOL emulation,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
	BOOL real_sysmem,
	BOOL probe_driver,
	LPDDRAWI_DIRECTDRAW_INT this_int,
        LPDDSURFACEINFO pSysMemInfo,
        DWORD DX8Flags)
{
    LPDDRAWI_DDRAWSURFACE_INT   curr_int;
    LPDDRAWI_DDRAWSURFACE_LCL   curr_lcl;
    LPDDRAWI_DDRAWSURFACE_GBL   curr;
    HRESULT                     ddrval;
    CSINFO                      csinfo;
    LPDDRAWI_DDRAWSURFACE_INT   fix_slist_int[FIX_SLIST_CNT];
    LPDDRAWI_DDRAWSURFACE_LCL   fix_slist_lcl[FIX_SLIST_CNT];
    LPDDRAWI_DDRAWSURFACE_GBL   fix_slist[FIX_SLIST_CNT];
    int                         i;
    LPDDRAWI_DIRECTDRAW_GBL     this;

    this = this_lcl->lpGbl;

    /*
     * try to create the surface
     */
    csinfo.needlink = FALSE;
    csinfo.slist_int = fix_slist_int;
    csinfo.slist_lcl = fix_slist_lcl;
    csinfo.slist = fix_slist;
    csinfo.listsize = FIX_SLIST_CNT;
    ddrval = createSurface( this_lcl, lpDDSurfaceDesc, &csinfo, emulation, real_sysmem, probe_driver, this_int, pSysMemInfo, DX8Flags );

    /*
     * if it worked, update the structures
     */
    if( ddrval == DD_OK )
    {
	/*
	 * link surface(s) into chain, increment refcnt
	 */
	for( i=0;i<csinfo.listcnt; i++ )
	{
	    curr_int = csinfo.slist_int[i];
	    curr_lcl = csinfo.slist_lcl[i];
	    curr = curr_lcl->lpGbl;

	    if( real_sysmem )
	    {
		curr->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMREQUESTED;
	    }
	    if( csinfo.needlink )
	    {
		if( curr_lcl->ddsCaps.dwCaps & DDSCAPS_OVERLAY )
		{
		    // This surface is an overlay.  Insert it into the overlay
		    // Z order list.  By inserting this node into the head of
		    // the list, it is the highest priority overlay,
		    // obscuring all others.
		    // The Z order list is implemented as a doubly linked list.
		    // The node for each surface exists in its
		    // DDRAWI_DDRAWSURFACE_GBL structure.  The root node
		    // exists in the direct draw object.  The next pointer of
		    // the root node points to the top-most overlay.  The prev
		    // pointer points to the bottom-most overlay.  The list
		    // may be traversed from back to front by following the
		    // prev pointers.  It may be traversed from front to back
		    // by following the next pointers.

		    curr_lcl->dbnOverlayNode.next =
			this->dbnOverlayRoot.next;
		    curr_lcl->dbnOverlayNode.prev =
			(LPVOID)(&(this->dbnOverlayRoot));
		    this->dbnOverlayRoot.next =
			(LPVOID)(&(curr_lcl->dbnOverlayNode));
		    curr_lcl->dbnOverlayNode.next->prev =
			(LPVOID)(&(curr_lcl->dbnOverlayNode));
		    curr_lcl->dbnOverlayNode.object_int = curr_int;
		    curr_lcl->dbnOverlayNode.object = curr_lcl;
		}
		/*
		 * link into list of all surfaces
		 */
                if (!(DX8Flags & DX8SFLAG_DX8) ||
                    (curr_lcl->dwFlags & DDRAWISURF_PARTOFPRIMARYCHAIN))
                {
		    curr_int->lpLink = this->dsList;
		    this->dsList = curr_int;
                }
	    }
	    DD_Surface_AddRef( (LPDIRECTDRAWSURFACE) curr_int );
	}
	*lplpDDSurface = (LPDIRECTDRAWSURFACE) csinfo.slist_int[0];
    }


    /*
     * free allocated list if needed
     */
    if( csinfo.listsize > FIX_SLIST_CNT )
    {
	MemFree( csinfo.slist_int );
	MemFree( csinfo.slist_lcl );
	MemFree( csinfo.slist );
    }

    return ddrval;

} /* createAndLinkSurfaces */

/*
 * InternalCreateSurface
 *
 * Create the surface.
 * This is the internal way of doing this; used by EnumSurfaces.
 * Assumes the directdraw lock has been taken.
 */
HRESULT InternalCreateSurface(
    LPDDRAWI_DIRECTDRAW_LCL this_lcl,
    LPDDSURFACEDESC2 lpDDSurfaceDesc,
    LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
    LPDDRAWI_DIRECTDRAW_INT this_int,
    LPDDSURFACEINFO pSysMemInfo,
    DWORD DX8Flags)
{
    DDSCAPS2                    caps;
    HRESULT         ddrval;
    LPDDRAWI_DIRECTDRAW_GBL this;

    this = this_lcl->lpGbl;

    /*
     * valid memory caps?
     */
    caps = lpDDSurfaceDesc->ddsCaps;

    if( (caps.dwCaps & DDSCAPS_SYSTEMMEMORY) && (caps.dwCaps & DDSCAPS_VIDEOMEMORY) )
    {
	DPF_ERR( "Can't specify SYSTEMMEMORY and VIDEOMEMORY" );
	return DDERR_INVALIDCAPS;
    }

    if (LOWERTHANDDRAW4(this_int))
    {
        lpDDSurfaceDesc->dwFlags &= ~(DDSD_PITCH | DDSD_LINEARSIZE);   // clear DDSD_LPSURFACE too?
    }

    // Has the client already allocated the surface memory?
    if( lpDDSurfaceDesc->dwFlags & DDSD_LPSURFACE )
    {
	LPDDPIXELFORMAT pddpf;

	/*
	 * The client has allocated the memory for this surface.  This is
	 * legal only if the surface's storage is explicitly specified to
	 * be in system memory.
	 */
	if( !(caps.dwCaps & DDSCAPS_SYSTEMMEMORY) )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag valid only with DDSCAPS_SYSTEMMEMORY flag" );
	    return DDERR_INVALIDCAPS;
	}

	if( !VALIDEX_PTR(lpDDSurfaceDesc->lpSurface,sizeof(DWORD)) )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag requires valid lpSurface ptr" );
	    return DDERR_INVALIDPARAMS;
	}

	if( caps.dwCaps & DDSCAPS_OPTIMIZED )   // what about DDSCAPS_ALLOCONLOAD?
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with optimized surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( caps.dwCaps & DDSCAPS_COMPLEX )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with complex surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( caps.dwCaps & DDSCAPS_EXECUTEBUFFER )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with execute-buffer surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( caps.dwCaps & (DDSCAPS_PRIMARYSURFACE | DDSCAPS_PRIMARYSURFACELEFT | DDSCAPS_OVERLAY) )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with primary surface or overlay surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( caps.dwCaps & DDSCAPS_VIDEOPORT )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag illegal with video-port surface" );
	    return DDERR_INVALIDCAPS;
	}

	if( ~lpDDSurfaceDesc->dwFlags & (DDSD_HEIGHT | DDSD_WIDTH) )
	{
	    DPF_ERR( "DDSD_LPSURFACE flag requires valid height and width" );
	    return DDERR_INVALIDPARAMS;
	}

	if ((ULONG_PTR)lpDDSurfaceDesc->lpSurface & 3)
	{
            if (this_int->lpVtbl != &dd4Callbacks)
	    {
		DPF_ERR( "Surface memory must be aligned to DWORD boundary" );
		return DDERR_INVALIDPARAMS;
	    }
	    // Avoid regression error with DX6 IDD4 interface.
            DPF(1, "Client-allocated surface memory is not DWORD-aligned" );
	}

	// Get a pointer to the pixel format for this surface.
	if( lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT )
	{
	    // The pixel format is specified in the DDSURFACEDESC2 structure.
	    pddpf = &lpDDSurfaceDesc->ddpfPixelFormat;
	}
	else
	{
	    // The pixel format is the same as the primary surface's.
	    pddpf = &this->vmiData.ddpfDisplay;
	}

	// Validate specified pitch or linear size.
	if (!(pddpf->dwFlags & DDPF_FOURCC))
	{
    	    long minpitch;
	    /*
	     * Verify that the pitch is an even multiple of 4 and that the pitch
	     * is large enough to accommodate the surface width.
	     */
	    if (!(lpDDSurfaceDesc->dwFlags & DDSD_PITCH))
	    {
		DPF_ERR( "DDSD_LPSURFACE flag requires valid pitch" );
		return DDERR_INVALIDPARAMS;
	    }
	    minpitch = (lpDDSurfaceDesc->dwWidth*pddpf->dwRGBBitCount + 7) >> 3;

	    if( lpDDSurfaceDesc->lPitch < minpitch || lpDDSurfaceDesc->lPitch & 3 )
	    {
		DPF_ERR( "Bad value specified for surface pitch" );
		return DDERR_INVALIDPARAMS;
	    }
	}
	else
	{
    	    DWORD blksize;
    	    DWORD dx, dy;
	    /*
	     * The client allocated memory for a surface with a FOURCC format.
	     * The only FOURCC formats we support in system memory are the
	     * DXT formats.
	     */
	    blksize = GetDxtBlkSize(pddpf->dwFourCC);   // returns 0 if not DXT

	    if (!blksize)
	    {
		DPF_ERR( "Specified FOURCC format is not supported in system memory" );
		return DDERR_UNSUPPORTED;
	    }
	    dx = (lpDDSurfaceDesc->dwWidth  + 3) >> 2;	 // surface width in blocks
	    dy = (lpDDSurfaceDesc->dwHeight + 3) >> 2;	 // surface height in blocks

	    if (lpDDSurfaceDesc->dwFlags & DDSD_PITCH)
	    {
		if (this_int->lpVtbl != &dd4Callbacks)
		{
		    DPF_ERR( "DXT surface requires DDSD_LINEARSIZE, not DDSD_PITCH" );
		    return DDERR_INVALIDPARAMS;
		}
		// Avoid regression error with DX6 IDD4 interface.
                DPF(1, "DXT surface requires DDSD_LINEARSIZE, not DDSD_PITCH" );
		lpDDSurfaceDesc->dwFlags &= ~DDSD_PITCH;
		lpDDSurfaceDesc->dwFlags |= DDSD_LINEARSIZE;
		lpDDSurfaceDesc->dwLinearSize = dx*dy*blksize;
	    }
    	    /*
    	     * The surface does have a DXT format.  Verify that the specified linear
	     * size is large enough to accommodate the specified width and height.
	     */
	    if (!(lpDDSurfaceDesc->dwFlags & DDSD_LINEARSIZE))
	    {
		DPF_ERR( "DDSD_LPSURFACE flag requires valid linear size for DXT surface" );
		return DDERR_INVALIDPARAMS;
	    }
	
	    if (lpDDSurfaceDesc->dwLinearSize < dx*dy*blksize)
	    {
		DPF_ERR( "Bad value specified for linear size" );
		return DDERR_INVALIDPARAMS;
	    }
	}
    }
    else if (lpDDSurfaceDesc->dwFlags & (DDSD_PITCH | DDSD_LINEARSIZE))
    {
	// Avoid regression error with DX6 IDD4 interface.
	DPF(1, "DDSD_PITCH and DDSD_LINEARSIZE flags ignored if DDSD_LPSURFACE=0" );
	lpDDSurfaceDesc->dwFlags &= ~(DDSD_PITCH | DDSD_LINEARSIZE);
    }

#if 0 // DDSCAPS2_LOCALALLOC, DDSCAPS2_COTASKMEM and DDRAWISURFGBL_DDFREESCLIENTMEM are gone
    // Will DirectDraw be responsible for freeing client-allocated surface memory?
    if( caps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM) )
    {
	if( !(lpDDSurfaceDesc->dwFlags & DDSD_LPSURFACE) )
	{
	    DPF_ERR( "DDSCAPS2 flags LOCALALLOC and COTASKMEM require DDSD_LPSURFACE flag" );
	    return DDERR_INVALIDCAPS;
	}

	if( !(~caps.dwCaps2 & (DDSCAPS2_LOCALALLOC | DDSCAPS2_COTASKMEM)) )
	{
	    DPF_ERR( "DDSCAPS2 flags LOCALALLOC and COTASKMEM are mutually exclusive" );
	    return DDERR_INVALIDCAPS;
	}
    }
#endif // 0

    //
    // Check persistent-content caps
    //

    if (caps.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS)
    {
#ifdef WIN95
	//
	// Primary surface contents can only persist if exclusive mode.
	//

	if ((caps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
	    !(this_lcl->dwLocalFlags & DDRAWILCL_HASEXCLUSIVEMODE))
	{
	    DPF_ERR("Non-exclusive primary surface contents cannot persist");
	    return DDERR_NOEXCLUSIVEMODE;
	}

	//
	// DDSCAPS_OWNDC and DDSCAPS_VIDEOPORT imply volatile surfaces.
	// Also, optimized surfaces are a special case which will be handled
	// later by deferring memory allocation.
	//

	// ATTENTION: Optimized surfaces can only be Persistent ?
	if ((caps.dwCaps & (DDSCAPS_OWNDC | DDSCAPS_VIDEOPORT | DDSCAPS_OPTIMIZED)))
	{
	    DPF_ERR("Surface is volatile, contents cannot persist");
	    return DDERR_INVALIDCAPS;
	}

	//
	// We don't have enough information to backup FourCC surface contents.
	//

	if (lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT)
	{
	    if (lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC)
	    {
		DPF_ERR("FourCC video memory surface contents cannot persist");
		return DDERR_INVALIDCAPS;
	    }
	}
#else
	DPF_ERR("Persistent content surfaces not implemented");
	return DDERR_INVALIDCAPS;
#endif
    }

    /*
     * If DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM are specified
     * then DDSCAPS_VIDOEMEMORY must be explicity specified. Note, we
     * can't dely this check until checkCaps() as by that time the heap
     * scanning software may well have turned on DDSCAPS_VIDOEMEMORY.
     */
    if( ( caps.dwCaps & ( DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM ) ) &&
	!( caps.dwCaps & DDSCAPS_VIDEOMEMORY ) )
    {
	DPF_ERR( "DDSCAPS_VIDEOMEMORY must be specified with DDSCAPS_LOCALVIDMEM or DDSCAPS_NONLOCALVIDMEM" );
	return DDERR_INVALIDCAPS;
    }

    /*
     * valid memory caps?
     */
    if( caps.dwCaps & DDSCAPS_OWNDC )
    {
	if( !( caps.dwCaps & DDSCAPS_SYSTEMMEMORY ) )
	{
	    DPF_ERR( "OWNDC only support for explicit system memory surfaces" );
	    return DDERR_UNSUPPORTED;
	}
    }

    /*
     * managed texture?
     */
    if( caps.dwCaps2 & DDSCAPS2_D3DTEXTUREMANAGE )
    {
        if ( caps.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM) )
        {
            DPF_ERR("Memory type can't be specified upon creation of managed surfaces ");
            return DDERR_INVALIDCAPS;
        }
        if ( (caps.dwCaps2 & DDSCAPS2_DONOTPERSIST) && (caps.dwCaps & DDSCAPS_WRITEONLY) && 
            (this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) && (this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM) && 
            !(this->dwFlags & DDRAWI_NOHARDWARE) && 
            ((this->ddCaps.dwCaps2 & DDCAPS2_TEXMANINNONLOCALVIDMEM) || (dwRegFlags & DDRAW_REGFLAGS_USENONLOCALVIDMEM)) )
        {
            lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
            lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
            lpDDSurfaceDesc->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
            DPF(2, "Creating managed surface in non-local vidmem");
            ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
                                            lplpDDSurface, FALSE, FALSE, this_int,
                                            pSysMemInfo, DX8Flags);
            lpDDSurfaceDesc->ddsCaps = caps;
            if(ddrval == DDERR_OUTOFVIDEOMEMORY)
            {
                if( this->dwFlags & DDRAWI_NOEMULATION )
                {
                    DPF_ERR( "No emulation support" );
                    return DDERR_NOEMULATION;
                }
                DPF(1, "Surface creation failed (out of memory). Now creating in system memory");
                lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
                lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
                lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
		        			lplpDDSurface, TRUE, FALSE, this_int,
                                                pSysMemInfo, DX8Flags);
                lpDDSurfaceDesc->ddsCaps = caps;
            }
        }
        else
        {
            if( this->dwFlags & DDRAWI_NOEMULATION )
            {
                DPF_ERR( "No emulation support" );
                return DDERR_NOEMULATION;
            }
            lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
            lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
            lpDDSurfaceDesc->ddsCaps.dwCaps  |= DDSCAPS_SYSTEMMEMORY;
            ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
					    lplpDDSurface, TRUE, FALSE, this_int,
                                            pSysMemInfo, DX8Flags);
            lpDDSurfaceDesc->ddsCaps = caps;
        }
    }
    else if( (caps.dwCaps2 & DDSCAPS2_TEXTUREMANAGE) && !(this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW8) )
    {
        if ( caps.dwCaps & (DDSCAPS_SYSTEMMEMORY | DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM | DDSCAPS_LOCALVIDMEM) )
        {
            DPF_ERR("Memory type can't be specified upon creation of managed surfaces ");
            return DDERR_INVALIDCAPS;
        }
        if( (this_lcl->lpGbl->ddCaps.dwCaps2 & DDCAPS2_CANMANAGETEXTURE) 
            && (this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) )
        {
            if( this->dwFlags & DDRAWI_NOHARDWARE )
            {
                DPF_ERR( "No hardware support" );
                return DDERR_NODIRECTDRAWHW;
            }
            lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
                                            lplpDDSurface, FALSE, FALSE, this_int,
                                            pSysMemInfo, DX8Flags);
            lpDDSurfaceDesc->ddsCaps = caps;
        }
        else
        {	    
            if ( (caps.dwCaps2 & DDSCAPS2_DONOTPERSIST) && (caps.dwCaps & DDSCAPS_WRITEONLY) && 
                (this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7) && (this->ddCaps.dwCaps2 & DDCAPS2_NONLOCALVIDMEM) &&
                !(this->dwFlags & DDRAWI_NOHARDWARE) &&
                ((this->ddCaps.dwCaps2 & DDCAPS2_TEXMANINNONLOCALVIDMEM) || (dwRegFlags & DDRAW_REGFLAGS_USENONLOCALVIDMEM)) )
            {
                lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
                lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
                lpDDSurfaceDesc->ddsCaps.dwCaps |= (DDSCAPS_VIDEOMEMORY | DDSCAPS_NONLOCALVIDMEM);
                DPF(2, "Creating managed surface in non-local vidmem");
                ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
                                                lplpDDSurface, FALSE, FALSE, this_int,
                                                pSysMemInfo, DX8Flags);
                lpDDSurfaceDesc->ddsCaps = caps;
                if(ddrval == DDERR_OUTOFVIDEOMEMORY)
                {
                    if( this->dwFlags & DDRAWI_NOEMULATION )
                    {
                        DPF_ERR( "No emulation support" );
                        return DDERR_NOEMULATION;
                    }
                    DPF(2, "CreateSurface failed (out of memory). Now creating in system memory");
                    lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
                    lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
                    lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
                    ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
                                                    lplpDDSurface, TRUE, FALSE, this_int,
                                                    pSysMemInfo, DX8Flags);
                    lpDDSurfaceDesc->ddsCaps = caps;
                }
            }
            else
            {
                if( this->dwFlags & DDRAWI_NOEMULATION )
                {
                    DPF_ERR( "No emulation support" );
                    return DDERR_NOEMULATION;
                }
                lpDDSurfaceDesc->ddsCaps.dwCaps  &= ~DDSCAPS_WRITEONLY;
                lpDDSurfaceDesc->ddsCaps.dwCaps2 &= ~DDSCAPS2_DONOTPERSIST;
                lpDDSurfaceDesc->ddsCaps.dwCaps  |= DDSCAPS_SYSTEMMEMORY;
	        ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
					        lplpDDSurface, TRUE, FALSE, this_int,
                                                pSysMemInfo, DX8Flags);
                lpDDSurfaceDesc->ddsCaps = caps;
            }
        }
        /*
         * want in video memory only?
         */
    }
    else if( caps.dwCaps & DDSCAPS_VIDEOMEMORY )
    {
	if( this->dwFlags & DDRAWI_NOHARDWARE )
	{
	    DPF_ERR( "No hardware support" );
	    return DDERR_NODIRECTDRAWHW;
	}

	ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
					lplpDDSurface, FALSE, FALSE, this_int,
                                        pSysMemInfo, DX8Flags);
	/*
	 * want in system memory only?
	 */
    }
    else if( caps.dwCaps & DDSCAPS_SYSTEMMEMORY )
    {
	if( this->dwFlags & DDRAWI_NOEMULATION )
	{
	    DPF_ERR( "No emulation support" );
	    return DDERR_NOEMULATION;
	}
	ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
					lplpDDSurface, TRUE, FALSE, this_int,
                                        pSysMemInfo, DX8Flags);
	/*
	 * don't care where it goes?  Try video memory first...
	 */
    }
    else
    {
	if( !(this->dwFlags & DDRAWI_NOHARDWARE) )
	{
	    lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
	    ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, FALSE,
					    lplpDDSurface, FALSE, TRUE, this_int,
                                            pSysMemInfo, DX8Flags);
	    lpDDSurfaceDesc->ddsCaps.dwCaps &= ~DDSCAPS_VIDEOMEMORY;
	}
	else
	{
	    ddrval = DDERR_NOEMULATION;
	}
	if( ddrval != DD_OK && ddrval != DDERR_INVALIDCAPS &&
	    ddrval != DDERR_INVALIDPARAMS )
	{
	    if( !(this->dwFlags & DDRAWI_NOEMULATION) &&
		(this->dwFlags & DDRAWI_EMULATIONINITIALIZED) )
	    {
		lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
		ddrval = createAndLinkSurfaces( this_lcl, lpDDSurfaceDesc, TRUE,
						lplpDDSurface, FALSE, FALSE, this_int,
                                                pSysMemInfo, DX8Flags);
		lpDDSurfaceDesc->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
	    }
	    else
	    {
		DPF_ERR( "Couldn't allocate a surface at all" );
	    }
	}
    }

    // any color keys specified?
    if( (ddrval == DD_OK) &&
	(lpDDSurfaceDesc->dwFlags & (DDSD_CKSRCOVERLAY|DDSD_CKDESTOVERLAY|
				     DDSD_CKSRCBLT|DDSD_CKDESTBLT) ) )
    {
	/*
	 * Attempt to set the specified color keys
	 */
	if( lpDDSurfaceDesc->dwFlags & DDSD_CKSRCBLT )
	    ddrval = DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)*lplpDDSurface,
					    DDCKEY_SRCBLT, &(lpDDSurfaceDesc->ddckCKSrcBlt) );
	if(ddrval == DD_OK)
	{
	    if( lpDDSurfaceDesc->dwFlags & DDSD_CKDESTBLT )
		ddrval = DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)*lplpDDSurface,
						DDCKEY_DESTBLT, &(lpDDSurfaceDesc->ddckCKDestBlt) );
	    if(ddrval == DD_OK)
	    {
		if( lpDDSurfaceDesc->dwFlags & DDSD_CKSRCOVERLAY )
		    ddrval = DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)*lplpDDSurface,
						    DDCKEY_SRCOVERLAY, &(lpDDSurfaceDesc->ddckCKSrcOverlay) );
		if(ddrval == DD_OK)
		{
		    if( lpDDSurfaceDesc->dwFlags & DDSD_CKDESTOVERLAY )
			ddrval = DD_Surface_SetColorKey((LPDIRECTDRAWSURFACE)*lplpDDSurface,
							DDCKEY_DESTOVERLAY, &(lpDDSurfaceDesc->ddckCKDestOverlay) );
		}
	    }
	}
	if( ddrval != DD_OK )
	{
	    DPF_ERR("Surface Creation failed because color key set failed.");
	    DD_Surface_Release((LPDIRECTDRAWSURFACE)*lplpDDSurface);
	    *lplpDDSurface = NULL;
	}
    }

#ifdef WIN95
    //
    // Allocate persistent-content surface memory, if specified
    //

    if (SUCCEEDED(ddrval) && (lpDDSurfaceDesc->ddsCaps.dwCaps2 & DDSCAPS2_PERSISTENTCONTENTS))
    {
	if (FAILED(AllocSurfaceContents(((LPDDRAWI_DDRAWSURFACE_INT) *lplpDDSurface)->lpLcl)))
	{
	    DD_Surface_Release((LPDIRECTDRAWSURFACE) *lplpDDSurface);
	    *lplpDDSurface = NULL;
	    ddrval = DDERR_OUTOFMEMORY;
	}
    }
#endif

    return ddrval;

} /* InternalCreateSurface */

void CopyDDSurfDescToDDSurfDesc2(DDSURFACEDESC2* ddsd2, DDSURFACEDESC* ddsd)
{
    memcpy(ddsd2, ddsd, sizeof(*ddsd));
    ddsd2->ddsCaps.dwCaps2 = 0;
    ddsd2->ddsCaps.dwCaps3 = 0;
    ddsd2->ddsCaps.dwCaps4 = 0;
    ddsd2->dwTextureStage = 0;
}

HRESULT DDAPI DD_CreateSurface4_Main(LPDIRECTDRAW lpDD,LPDDSURFACEDESC2 lpDDSurfaceDesc,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,IUnknown FAR *pUnkOuter,BOOL bDoSurfaceDescCheck,
        LPDDSURFACEINFO pSysMemInfo, DWORD DX8Flags);

/*
 * DD_CreateSurface
 *
 * Create a surface.
 * This is the method visible to the outside world.
 */
#undef DPF_MODNAME
#define DPF_MODNAME     "CreateSurface"

HRESULT DDAPI DD_CreateSurface(
	LPDIRECTDRAW lpDD,
	LPDDSURFACEDESC lpDDSurfaceDesc,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
	IUnknown FAR *pUnkOuter )
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    DDSURFACEDESC2              ddsd2;
    HRESULT                     hr = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreateSurface");

    ZeroMemory(&ddsd2,sizeof(ddsd2));

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        /*
         * verify that cooperative level is set
         */
        if( !(this_lcl->dwLocalFlags & DDRAWILCL_SETCOOPCALLED) )
        {
            DPF_ERR( "Must call SetCooperativeLevel before calling Create functions" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_NOCOOPERATIVELEVELSET);
            return DDERR_NOCOOPERATIVELEVELSET;
        }

	if( !VALID_DDSURFACEDESC_PTR( lpDDSurfaceDesc ) )
	{
	    DPF_ERR( "Invalid DDSURFACEDESC. Did you set the dwSize member?" );
	    DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}

        if( (this->dwModeIndex == DDUNSUPPORTEDMODE)
#ifdef  WINNT
            && !(DDSCAPS_SYSTEMMEMORY & lpDDSurfaceDesc->ddsCaps.dwCaps)
#endif
          )
	{
	    DPF_ERR( "Driver is in an unsupported mode" );
	    LEAVE_DDRAW();
	    DPF_APIRETURNS(DDERR_UNSUPPORTEDMODE);
	    return DDERR_UNSUPPORTEDMODE;
	}

        CopyDDSurfDescToDDSurfDesc2(&ddsd2, lpDDSurfaceDesc);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters: Bad LPDDSURFACEDESC" );
	DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

//  must leave dwSize intact so checkSurfaceDesc can distinguish DDSURFACEDESC from DDSURFACEDESC2,
//  ddsd2.dwSize = sizeof(ddsd2);

    hr = DD_CreateSurface4_Main(lpDD,&ddsd2,lplpDDSurface,pUnkOuter,FALSE, NULL, 0);

    LEAVE_DDRAW();

    return hr;
}

HRESULT DDAPI DD_CreateSurface4(
	LPDIRECTDRAW lpDD,
	LPDDSURFACEDESC2 lpDDSurfaceDesc,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
	IUnknown FAR *pUnkOuter ) {

   DPF(2,A,"ENTERAPI: DD_CreateSurface4");
   return DD_CreateSurface4_Main(lpDD,lpDDSurfaceDesc,lplpDDSurface,pUnkOuter,TRUE, NULL, 0);
}

HRESULT DDAPI DD_CreateSurface4_Main(
	LPDIRECTDRAW lpDD,
	LPDDSURFACEDESC2 lpDDSurfaceDesc,
	LPDIRECTDRAWSURFACE FAR *lplpDDSurface,
	IUnknown FAR *pUnkOuter,
	BOOL bDoSurfaceDescCheck,
        LPDDSURFACEINFO pSysMemInfo,
        DWORD DX8Flags)
{
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     this;
    HRESULT                     ddrval;

    if( pUnkOuter != NULL )
    {
	return CLASS_E_NOAGGREGATION;
    }

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_CreateSurface4_Main");

    /* DPF_ENTERAPI(lpDD); */

    TRY
    {
        this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
        if( !VALID_DIRECTDRAW_PTR( this_int ) )
        {
            DPF_ERR( "Invalid driver object passed" );
            DPF_APIRETURNS(DDERR_INVALIDOBJECT);
            LEAVE_DDRAW();
            return DDERR_INVALIDOBJECT;
        }
        this_lcl = this_int->lpLcl;
        this = this_lcl->lpGbl;

        /*
         * verify that cooperative level is set
         */
        if( !(this_lcl->dwLocalFlags & DDRAWILCL_SETCOOPCALLED) )
        {
            DPF_ERR( "Must call SetCooperativeLevel before calling Create functions" );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_NOCOOPERATIVELEVELSET);
            return DDERR_NOCOOPERATIVELEVELSET;
        }

        if( bDoSurfaceDescCheck && !VALID_DDSURFACEDESC2_PTR( lpDDSurfaceDesc ) )
        {
            DPF(0, "Invalid DDSURFACEDESC2. Did you set the dwSize member? (%d should be %d)", lpDDSurfaceDesc->dwSize, sizeof(DDSURFACEDESC2) );
            LEAVE_DDRAW();
            DPF_APIRETURNS(DDERR_INVALIDPARAMS);
            return DDERR_INVALIDPARAMS;
        }

        if( (this->dwModeIndex == DDUNSUPPORTEDMODE)
#ifdef  WINNT
            && !(DDSCAPS_SYSTEMMEMORY & lpDDSurfaceDesc->ddsCaps.dwCaps)
#endif
          )
	{
	    DPF_ERR( "Driver is in an unsupported mode" );
	    LEAVE_DDRAW();
	    DPF_APIRETURNS(DDERR_UNSUPPORTEDMODE);
	    return DDERR_UNSUPPORTEDMODE;
	}

	*lplpDDSurface = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	DPF_APIRETURNS(DDERR_INVALIDPARAMS);
	return DDERR_INVALIDPARAMS;
    }

    if( this_lcl->dwProcessId != GetCurrentProcessId() )
    {
	DPF_ERR( "Process does not have access to object" );
	LEAVE_DDRAW();
	DPF_APIRETURNS(DDERR_INVALIDOBJECT);
	return DDERR_INVALIDOBJECT;
    }

    ddrval = InternalCreateSurface( this_lcl, lpDDSurfaceDesc,
				    lplpDDSurface, this_int, pSysMemInfo, DX8Flags );
    if( ddrval == DD_OK )
    {
        /*
         * If this is DX7, then we need to create a D3D texture object
         * if the surface is marked with DDSCAPS_TEXTURE. If the
         * createsurface is call is before creating a Direct3D7 object,
         * then we will create a Direct3D7 ourselves.
         */
        if( ( this_lcl->dwLocalFlags & DDRAWILCL_DIRECTDRAW7 ) && !(DX8Flags & DX8SFLAG_DX8))
        {
            LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) (*lplpDDSurface);
            if((pInt->lpLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) && 
                !(pInt->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTCREATED3DTEXOBJECT))
            {
                if( !D3D_INITIALIZED( this_lcl ) )
                {
                    /*
                     * No Direct3D interface yet so try and create one.
                     */
                    DPF(3, "No Direct3D interface yet, creating one");
                    ddrval = InitD3D( this_int );
                    if( FAILED( ddrval ) )
                    {
                        DPF_APIRETURNS(ddrval);
                        LEAVE_DDRAW();
                        return ddrval;
                    }
                }
                DDASSERT( D3D_INITIALIZED( this_lcl ) );
                DPF(4, "Calling D3D to create texture");
                ddrval = this_lcl->pD3DCreateTexture((LPDIRECTDRAWSURFACE7)pInt);
                if(ddrval != DD_OK)
                {
                    DPF_APIRETURNS(ddrval);
                    LEAVE_DDRAW();
                    return ddrval;
                }
            }
        }
        else
        {
            ((LPDDRAWI_DDRAWSURFACE_INT)(*lplpDDSurface))->lpLcl->lpSurfMore->lpTex = NULL;
        }
	/*
	 * If this ddraw object generates independent child objects, then this surface takes
	 * a ref count on that ddraw object.
	 * Note how we don't take an addref of the ddraw object for implicitly created
	 * surfaces.
	 */
	if (CHILD_SHOULD_TAKE_REFCNT(this_int))
	{
            LPDDRAWI_DDRAWSURFACE_INT pInt = (LPDDRAWI_DDRAWSURFACE_INT) (*lplpDDSurface);

	    lpDD->lpVtbl->AddRef(lpDD);
	    pInt->lpLcl->lpSurfMore->pAddrefedThisOwner = (IUnknown*) lpDD;
	}

//      FillDDSurfaceDesc( (LPDDRAWI_DDRAWSURFACE_LCL) *lplpDDSurface, lpDDSurfaceDesc );
    }

    DPF_APIRETURNS(ddrval);
    LEAVE_DDRAW();

    return ddrval;

} /* DD_CreateSurface4_Main */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\ddgdi32.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddgdi32.c
 *  Content:    Contains the cross-process mapping layer similar to gdi32.dll
 *              on NT that the per-process DLL calls into on Win9X.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   11-oct-99  smac    initial implementation
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

#include "d3d8p.h"
#include "d3d8ddi.h"
#include "d3d8sddi.h"
#include "ddithunk.h"

extern HRESULT DDAPI DD_CreateSurface4_Main(LPDIRECTDRAW lpDD,LPDDSURFACEDESC2 lpDDSurfaceDesc,
        LPDIRECTDRAWSURFACE FAR *lplpDDSurface,IUnknown FAR *pUnkOuter,BOOL bDoSurfaceDescCheck,
        LPDDSURFACEINFO pSysMemInfo, DWORD DX8Flags);

extern void invalidateSurface(LPDDRAWI_DDRAWSURFACE_LCL this_lcl);
extern void makeDEVMODE(LPDDRAWI_DIRECTDRAW_GBL this, LPDDHALMODEINFO pmi, BOOL inexcl, BOOL useRefreshRate, LPDWORD pcds_flags, LPDEVMODE pdm);

void LoseDevice (DDDEVICEHANDLE* pDevice);

DDDEVICEHANDLE* pDeviceList = NULL;

// Bogus value used to initialize write only fields when communicating
// with the driver in debug builds
#define BOGUS_FIELD_VALUE          0xBAADCAFEul

typedef struct _KNOWNENTRY
{
    DWORD   PCIID;
    DWORD   VersionMajor;       // 0 means all versions
    DWORD   VersionMinor;       // 0 means all versions
    DWORD   Flags;
} KNOWNENTRY;

const KNOWNENTRY gKnownDeviceList[] =
{
    // NVidia
    {0x12D20018,          0,          0, KNOWN_ZSTENCILDEPTH},                                      // Riva 128         
    {0x10DE0020,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT
    {0x10DE0028,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2
    {0x10DE0029,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2 Ultra
    {0x10DE002C,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Vanta
    {0x10DE002D,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // TNT2 Model 64
    {0x10DE00A0,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Aladdin TNT2
    {0x10DE0100,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (GeForce) 
    {0x10DE0101,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (GeForce DDR) 
    {0x10DE0103,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV10 (Quadro) 
    {0x10DE0110,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (GeForce2 MX) 
    {0x10DE0111,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (GeForce2 MX) 
    {0x10DE0113,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV11 (Quadro2 MXR) 
    {0x10DE0150,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2)
    {0x10DE0151,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2 DDR) 
    {0x10DE0152,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (GeForce2 BR) 
    {0x10DE0153,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV15 (Quadro2) 
    {0x10DE0200,          0,          0, KNOWN_LIGHTWEIGHT|KNOWN_D16_LOCKABLE|KNOWN_MIPPEDCUBEMAPS|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // NV20 (GeForce 3)
    // 3DFX
    {0x121A0003,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},            // Banshee
    {0x121A0005,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5},            // Voodoo3
    {0x121a0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A8R8G8B8},       // Voodoo4/5; same PCI-ID
    // ATI                                                                                           
    {0x10024742,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024744,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024749,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474D,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x1002474F,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024750,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024752,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C42,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro (PCI)
    {0x10024C49,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro (PCI)
    {0x10024C4E,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C52,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C53,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro
    {0x10024C60,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // RagePro LT

    {0x10024C4D,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X1R5G5B5},   // Rage Mobility AGP

    {0x10024C46, 0x0004000c, 0x00010411, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024C46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024D46, 0x0004000c, 0x00010411, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128
    {0x10024D46,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // Rage Mobility 128

    {0x10025046, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS
    {0x10025046,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS
    {0x10025245, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025245,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025246, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x10025246,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x1002524B, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 VR PCI //DX8.1
    {0x1002524B,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 VR PCI //DX8.1
    {0x1002524C, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128
    {0x1002524C,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128

    //New 128s for DX8.1:
    {0x10025041, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025041,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025042, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025042,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025043, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025043,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025044, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025044,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025045, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025045,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025047, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025047,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025048, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025048,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025049, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025049,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x1002504a, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x1002504a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x1002504b, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x1002504b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x1002504c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x1002504c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x1002504d, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP            DX8.1
    {0x1002504d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP            DX8.1
    {0x1002504e, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x1002504e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x1002504f, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x1002504f,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025050, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025050,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025051, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025051,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025052, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025052,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025053, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025053,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI            DX8.1
    {0x10025054, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025054,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X         DX8.1
    {0x10025055, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025055,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X         DX8.1
    {0x10025056, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025056,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO PCI TMDS       DX8.1
    {0x10025057, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025057,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 2X TMDS    DX8.1
    {0x10025058, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
    {0x10025058,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO AGP 4X TMDS    DX8.1
                        
    {0x10025345, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x10025345,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x10025346, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x10025346,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x10025347, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x10025347,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x10025348, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X   DX8.1
    {0x10025348,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X   DX8.1
    {0x1002534b, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x1002534b,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X PCI    DX8.1
    {0x1002534c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x1002534c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 2X    DX8.1
    {0x1002534d, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x1002534d,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X AGP 4X    DX8.1
    {0x1002534e, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X     DX8.1
    {0x1002534e,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 4X     DX8.1

    {0x10025446, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA GL AGP      DX8.1
    {0x10025446,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA GL AGP      DX8.1
    {0x1002544c, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA VR AGP      DX8.1
    {0x1002544c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA VR AGP      DX8.1
    {0x10025452, 0x0004000c, 0x00011f43, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA4XL VR-R AGP DX8.1
    {0x10025452,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage128 PRO ULTRA4XL VR-R AGP DX8.1

    {0x10025144,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025145,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025146,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6
    {0x10025147,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Rage6

    // Intel                                                                                         
    {0x80867800,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},  // Intel i740
    {0x80867123,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},  // Intel 810
    {0x80867125,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                              // Intel 810e
    {0x80861132,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_R5G6B5},                                                 // Intel 815
    {0x80861A12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},                                            // Intel Timna

    // Matrox                                                                                        
    {0x102b0520, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},                                      // G200 PCI
    {0x102b0520,          0,          0, KNOWN_ZSTENCILDEPTH},                                      // G200 PCI
    {0x102b0521, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // G200 AGP
    {0x102b0521,          0,          0, KNOWN_ZSTENCILDEPTH},          // G200 AGP
    {0x102b0525, 0x0004000b, 0x000110ea, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // G400, G450
    {0x102b0525,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // G400, G450
    // 3DLabs                                                                                        
    {0x3d3d0008,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH},                                      // 3DLabs Gamma
    {0x104c3d07,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8}, // Perm2
    {0x3d3d0009,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8},                                      // Perm2
    {0x3d3d000a,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    {0x3d3d000c,          0,          0, KNOWN_CANMISMATCHRT|KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Perm3
    
    // Videologic                                                                                    
    {0x104a0010, 0x0004000c, 0x0001080c, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // PowerVR Kyro updated driver
    {0x104a0010,          0,          0, KNOWN_ZSTENCILDEPTH}, // PowerVR Kyro
    // S3                                                                                            
    {0x53338811,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge
    {0x53335631,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge
    {0x53338a01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge DX/GX DX8.1
    {0x53338c01,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge MX DX8.1
    {0x53338a10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X1R5G5B5},          // Virge GX2 DX8.1
    {0x53338a20,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // Savage3D
    {0x53338a22,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage4
    {0x53339102,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // Savage2K
    {0x53338c10,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},          // Savage MX DX8.1
    {0x53338c12,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5},          // Savage IX DX8.1
    {0x53338a25,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage Pro DX8.1
    {0x53338a26,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},          // Savage Pro DX8.1
    // Trident
    {0x10239880,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER}, // Trident Blade 3D 9880
    {0x10238500,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident Blade 3D/ProMedia DX8.1
    {0x10238400,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident Blade 3D/MVP4     DX8.1
    {0x10238420,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident CyberBlade i7 
    {0x10239910,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8}, // Trident CyberBlade DX8.1
    // SiS
    {0x10390300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_RTTEXTURE_R5G6B5},   // SiS 300
    {0x10390300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 300
    {0x10395300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 300
    {0x10396326,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_NOTAWINDOWEDBLTQUEUER},          // SiS 6326
    {0x10396300,          0,          0, KNOWN_ZSTENCILDEPTH|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5},   // SiS 6300
    {0x10396300, 0x0004000d, 0x000107da, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 6300
    {0x10390310, 0x0004000d, 0x00010352, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 6300
    {0x10390315, 0x0004000d, 0x00010352, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 6300
    {0x10390325, 0x0004000c, 0x000107d3, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 6300
    {0x10396325, 0x0004000c, 0x000107d3, KNOWN_ZSTENCILDEPTH|KNOWN_D16_LOCKABLE|KNOWN_CANMISMATCHRT|KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_A1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A4R4G4B4|KNOWN_RTTEXTURE_X8R8G8B8|KNOWN_RTTEXTURE_A8R8G8B8},   // SiS 640/740
    {0x126f0720,          0,          0, KNOWN_RTTEXTURE_X1R5G5B5|KNOWN_RTTEXTURE_R5G6B5|KNOWN_RTTEXTURE_A1R5G5B5}  //Silicon Motion Lynx3DM
};

#define NUM_KNOWN_DEVICES      (sizeof(gKnownDeviceList)/sizeof(KNOWNENTRY))


#define CACHE_GROW_SIZE     30

#define RESPATH_D3D "Software\\Microsoft\\Direct3D"



// Minimum size of DrawPrimitive buffer associated with a context.
#define MIN_PRIM_BUFFER_SIZE (1 << 14)
// Maximum
#define MAX_PRIM_BUFFER_SIZE (1 << 20)
// Default
#define DEF_PRIM_BUFFER_SIZE (1 << 16)

const DWORD dwOrderedFaces[6] = {
    DDSCAPS2_CUBEMAP_POSITIVEX,
    DDSCAPS2_CUBEMAP_NEGATIVEX,
    DDSCAPS2_CUBEMAP_POSITIVEY,
    DDSCAPS2_CUBEMAP_NEGATIVEY,
    DDSCAPS2_CUBEMAP_POSITIVEZ,
    DDSCAPS2_CUBEMAP_NEGATIVEZ
};

__inline LPDDRAWI_DDRAWSURFACE_INT GetHeavyweightSurf(DDSURFACE* pSurf)
{
    return (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT) ? MapLightweightSurface(pSurf) : pSurf->Surface.pHeavy;
}

#define DONE_HEAVYWEIGHT_SURF(x)                                \
    if (((PDDSURFACE)(x))->dwFlags & DDSURFACE_LIGHTWEIGHT)     \
        UnmapLightweightSurface(x)

HRESULT MapLegacyResult(HRESULT in)
{
    HRESULT hr;
    switch (in)
    {
    case DD_OK:
        hr = S_OK;
        break;

    case DDERR_OUTOFVIDEOMEMORY:
        hr = D3DERR_OUTOFVIDEOMEMORY;
        break;

    case DDERR_CURRENTLYNOTAVAIL:
    case DDERR_UNSUPPORTED:
        hr = D3DERR_NOTAVAILABLE;
        break;

    case DDERR_OUTOFMEMORY:
        hr = E_OUTOFMEMORY;
        break;

    default:
        hr = D3DERR_DRIVERINTERNALERROR;
    }
    return hr;
}


BOOL FormatCompatibleWithDisplayFormat(
    PDDDEVICEHANDLE pDD,
    D3DFORMAT Format)
{
    return (BOOL) (Format == pDD->DisplayFormatWithAlpha);
}

HRESULT LockDibEngine(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    HRESULT ret;
    LPWORD pdflags;
    BOOL isbusy;

    pdflags = pdrv->lpwPDeviceFlags;
    isbusy = 0;

    _asm
    {
        mov eax, pdflags
        bts word ptr [eax], BUSY_BIT
        adc isbusy,0
    }
    if (isbusy && (0 == pdrv->dwWin16LockCnt)) 
    {
        D3D_WARN(2, "LOCK_DIBENGINE, dibengine is busy");
        ret = DDERR_SURFACEBUSY;
    } else
        ret = DD_OK;

    return ret;
}

void UnlockDibEngine(LPDDRAWI_DIRECTDRAW_GBL pdrv)
{
    if (0 == pdrv->dwWin16LockCnt)
    { 
        *pdrv->lpwPDeviceFlags &= ~BUSY;
    }
}

#define CALL_D3DHAL_TAKEBUSY_NOWIN16(ret, pDevice, func, data)          \
{                                                                       \
    if (func)                                                           \
    {                                                                   \
        ret = LockDibEngine((pDevice)->pDD->lpLcl->lpGbl);              \
        if (ret != DD_OK)                                               \
        {                                                               \
            ret = DDHAL_DRIVER_HANDLED;                                 \
        }                                                               \
        else                                                            \
        {                                                               \
            ret = (*(func))(data);                                      \
            UnlockDibEngine((pDevice)->pDD->lpLcl->lpGbl);              \
        }                                                               \
    }                                                                   \
    else                                                                \
    {                                                                   \
        DPF_ERR("No HAL call available");                               \
        ret = DDHAL_DRIVER_NOTHANDLED;                                  \
    }                                                                   \
}

#define CALL_D3DHAL_TAKEBUSY_TAKEWIN16(ret, pDevice, func, data)        \
{                                                                       \
    ENTER_WIN16LOCK();                                                  \
    CALL_D3DHAL_TAKEBUSY_NOWIN16(ret, pDevice, func, data);             \
    LEAVE_WIN16LOCK();                                                  \
}

BOOL CanKnownDriverDoThis(PDDDEVICEHANDLE pDevice, DWORD Flag)
{
    BOOL ret = FALSE;
    int i;

    if (pDevice->ForceFlagsOff & Flag)
    {
        return FALSE;
    }
    else if (pDevice->ForceFlagsOn & Flag)
    {
        return TRUE;
    }

    // Only drivers in our known good list can support lightweight
    // surfaces

    if (pDevice->PCIID == 0)
    {
        DDDEVICEIDENTIFIER2 DI;

        if (InternalGetDeviceIdentifier7( (LPDIRECTDRAW) pDevice->pDD, &DI, 0, FALSE) == DD_OK)
        {
            pDevice->PCIID = (DI.dwVendorId << 16) | DI.dwDeviceId;
            pDevice->DriverVersionHigh = DI.liDriverVersion.HighPart;
            pDevice->DriverVersionLow = DI.liDriverVersion.LowPart;
        }
    }
    for (i = 0; i < NUM_KNOWN_DEVICES; i++)
    {
        if ((gKnownDeviceList[i].PCIID == pDevice->PCIID) &&
            (gKnownDeviceList[i].Flags & Flag) &&
            ((pDevice->DriverVersionHigh > gKnownDeviceList[i].VersionMajor) ||
             ((pDevice->DriverVersionHigh == gKnownDeviceList[i].VersionMajor) &&
              (pDevice->DriverVersionLow >= gKnownDeviceList[i].VersionMinor))))
        {
            ret = TRUE;
            break;
        }
    }

    return ret;
}


BOOL IsLightweightSurface(PDDDEVICEHANDLE pDevice, DDSURFACEDESC2* pddsd2, D3DFORMAT Format)
{
    // Render targets, Z buffers, cursor surfaces, and any part of flip chain 
    // must remain heavyweight surfaces.

    if (pddsd2->ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE |
                                  DDSCAPS_3DDEVICE |
                                  DDSCAPS_ZBUFFER |
                                  DDSCAPS_OFFSCREENPLAIN))
    {
        return FALSE;
    }

    // All paletized textures must be heavyweight unless it's at least a DX8
    // driver.  This is because some DX7 drivers don't handle palettes right.
    
    if ((pDevice->DriverLevel < 8) &&
        ((Format == D3DFMT_A8P8) || (Format == D3DFMT_P8)))
    {
        return FALSE;
    }
   
    if (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_VOLUME)
    {
        return FALSE;
    }

    // If it's a static VB or IB, then we can let that be lightweight
    if ((pDevice->DriverLevel >= 8) &&
        (pddsd2->ddsCaps.dwCaps2 & DDSCAPS_EXECUTEBUFFER) &&
        (pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_HINTSTATIC))
    {
        return TRUE;
    }

    // Unless it's static, the runtime locks vidmem vbs indefinately,
    // so if we make them lightweight they will fill up our cache table
    // with 1000s of entries. Therefore, we will make them heavyweight.
    if ((pddsd2->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        return FALSE;
    }

    // Dynamic textures will be frequently locked, so it is inefficient
    // to make them light weight.
    if ((pddsd2->ddsCaps.dwCaps2 & DDSCAPS2_HINTDYNAMIC) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
        (pddsd2->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        return FALSE;
    }

    return TRUE;
}


void UpdateSurfaceCache(DDSURFACE* pSurf)
{
    LPDDRAWI_DDRAWSURFACE_LCL   pLcl = GET_CACHED_LIGHTWEIGHT_INT(pSurf)->lpLcl;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE lpGblMore;

    // Update those fields in the lightweight structure that the driver may
    // have changed

    pSurf->Surface.pLight->GblFlags     = pLcl->lpGbl->dwGlobalFlags;
    pSurf->Surface.pLight->fpGblVidMem  = pLcl->lpGbl->fpVidMem;
    pSurf->Surface.pLight->GblPitch     = pLcl->lpGbl->lPitch;
    pSurf->Surface.pLight->GblReserved1 = pLcl->lpGbl->dwReserved1;

    pSurf->Surface.pLight->LclFlags     = pLcl->dwFlags;
    pSurf->Surface.pLight->LclCaps1     = pLcl->ddsCaps.dwCaps;
    pSurf->Surface.pLight->LclReserved1 = pLcl->dwReserved1;

    lpGblMore = GET_LPDDRAWSURFACE_GBL_MORE (pLcl->lpGbl);
    pSurf->Surface.pLight->GblMoreDriverReserved            = lpGblMore->dwDriverReserved;
    pSurf->Surface.pLight->GblMoreContentsStamp             = lpGblMore->dwContentsStamp;
    pSurf->Surface.pLight->pGblMoreUnswappedDriverReserved  = lpGblMore->lpvUnswappedDriverReserved;
    pSurf->Surface.pLight->fpGblMoreAliasOfVidMem           = lpGblMore->fpAliasOfVidMem;
    pSurf->Surface.pLight->cGblMorePageUnlocks              = lpGblMore->cPageUnlocks;

    if (pSurf->Surface.pLight->LclCaps1 & DDSCAPS_LOCALVIDMEM)
    {
        pSurf->Surface.pLight->fpGblMoreAliasedVidMem   = lpGblMore->fpAliasedVidMem;
    }
    else if (pSurf->Surface.pLight->LclCaps1 & DDSCAPS_NONLOCALVIDMEM)
    {
        pSurf->Surface.pLight->fpGblMorePhysicalVidMem  = lpGblMore->fpPhysicalVidMem;
    }
}


LPDDRAWI_DDRAWSURFACE_INT MapLightweightSurface(DDSURFACE* pSurf)
{
    LPDDRAWI_DDRAWSURFACE_INT       pCached = NULL;
    PDDDEVICEHANDLE                 pDevice = pSurf->pDevice;
    int                             i;
    LPDDRAWI_DDRAWSURFACE_GBL_MORE* ppGblMore;
    DWORD                           Lowest;
    DWORD                           LowestEntry;
    CACHEENTRY*                     pCachedEntry = NULL;
    UINT                            CacheIndex;

    // If the surface is already mapped, this is pretty easy

    if (pSurf->Surface.pLight->CachedIndex)
    {
        DDASSERT(pSurf->Surface.pLight->CachedIndex & INDEX_IN_USE);

        pCachedEntry = GET_CACHED_ENTRY(pSurf);
        pCachedEntry->pSurface->dwReserved2++;    // up the ref count
        pCachedEntry->UsageStamp = pDevice->CacheUsageStamp++;

        // Protect against wrap around of the usage stamp
        if (pDevice->CacheUsageStamp == 0)
        {
            for (i = 0; i < pDevice->NumCachedSurfaces; i++)
            {
                pDevice->pCachedSurfaceTable[i].UsageStamp = 0;
            }
        }

        return pCachedEntry->pSurface;
    }

    // Otherwise, find an available surface to use

    do
    {
        // Look through the list and look for either a surface that isn't being used,
        // or one that we can use with the lowest UsageStamp.

        Lowest = LowestEntry = (DWORD) -1;
        for (i = 0; i < pDevice->NumCachedSurfaces; i++)
        {
            if (pDevice->pCachedSurfaceTable[i].pSurface->dwReserved1 == (ULONG_PTR) NULL)
            {
                pCachedEntry = &(pDevice->pCachedSurfaceTable[i]);
                CacheIndex = i;
                break;
            }
            else if ((pDevice->pCachedSurfaceTable[i].pSurface->dwReserved2 == 0) &&
                (pDevice->pCachedSurfaceTable[i].UsageStamp < Lowest))
            {
                Lowest = pDevice->pCachedSurfaceTable[i].UsageStamp;
                LowestEntry = (DWORD) i;
            }
        }

        if ((pCachedEntry == NULL) && (LowestEntry != (DWORD) -1))
        {
            // We don't have an empty one, but we found one that we can flush

            UpdateSurfaceCache((DDSURFACE*)(pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1));
            ((DDSURFACE*)(pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1))->Surface.pLight->CachedIndex = 0;
            pDevice->pCachedSurfaceTable[LowestEntry].pSurface->dwReserved1 = (ULONG_PTR) NULL;
            pCachedEntry = &(pDevice->pCachedSurfaceTable[LowestEntry]);
            CacheIndex = LowestEntry;
        }

        if (pCachedEntry == NULL)
        {
            // If we still can't find one, then we need to grow the table

            int             NewNum;
            CACHEENTRY*     pNewTable;

            NewNum = pDevice->NumCachedSurfaces + CACHE_GROW_SIZE;
            pNewTable = (CACHEENTRY*) MemAlloc(sizeof(CACHEENTRY) * NewNum);
            if (pNewTable == NULL)
            {
                return NULL;
            }
            for (i = 0; i < pDevice->NumCachedSurfaces; i++)
            {
                pNewTable[i] = pDevice->pCachedSurfaceTable[i];
            }
            while (i < NewNum)
            {
                pNewTable[i].UsageStamp = 0; 
                pNewTable[i].pSurface = (LPDDRAWI_DDRAWSURFACE_INT) 
                    MemAlloc(sizeof(DDRAWI_DDRAWSURFACE_INT) +
                             sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                             sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                             sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                             sizeof(DDRAWI_DDRAWSURFACE_GBL_MORE) +
                             sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
                if (pNewTable[i].pSurface == NULL)
                {
                    break;
                }
                else
                {
                    i++;
                }
            }
            if (pDevice->pCachedSurfaceTable != NULL)
            {
                MemFree(pDevice->pCachedSurfaceTable);
            }
            pDevice->NumCachedSurfaces = i;
            pDevice->pCachedSurfaceTable = pNewTable;
        }
    } while (pCachedEntry == NULL);

    pCachedEntry->UsageStamp = pDevice->CacheUsageStamp++;

    // Protect against wrap around of the usage stamp
    if (pDevice->CacheUsageStamp == 0)
    {
        for (i = 0; i < pDevice->NumCachedSurfaces; i++)
        {
            pDevice->pCachedSurfaceTable[i].UsageStamp = 0;
        }
    }

    // We have the memory that we want to use, so now we need to initialze it

    pCached = pCachedEntry->pSurface;

    memset(pCached, 0, sizeof(DDRAWI_DDRAWSURFACE_INT) +
                       sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                       sizeof(DDRAWI_DDRAWSURFACE_GBL) +
                       sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                       sizeof(DDRAWI_DDRAWSURFACE_GBL_MORE) +
                       sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    pCached->dwReserved1 = (ULONG_PTR) pSurf;
    pCached->dwReserved2 = 1;   // Init the ref count
    pSurf->Surface.pLight->CachedIndex = CacheIndex | INDEX_IN_USE;    // So a used entry is never 0

    pCached->lpLcl = (LPDDRAWI_DDRAWSURFACE_LCL) 
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT));

    pCached->lpLcl->lpSurfMore = (LPDDRAWI_DDRAWSURFACE_MORE)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL));

    pCached->lpLcl->lpGbl = (LPDDRAWI_DDRAWSURFACE_GBL)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                            sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                            sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    
    ppGblMore = (LPDDRAWI_DDRAWSURFACE_GBL_MORE*) ((BYTE*)(pCached->lpLcl->lpGbl) - 
        sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE));
    *ppGblMore = (LPDDRAWI_DDRAWSURFACE_GBL_MORE)
        (((BYTE*)pCached) + sizeof(DDRAWI_DDRAWSURFACE_INT) +
                            sizeof(DDRAWI_DDRAWSURFACE_LCL) +
                            sizeof(DDRAWI_DDRAWSURFACE_MORE) +
                            sizeof(LPDDRAWI_DDRAWSURFACE_GBL_MORE) +
                            sizeof(DDRAWI_DDRAWSURFACE_GBL));

    // Now fill it in with the meaningful data

    pCached->lpLcl->dwFlags             = pSurf->Surface.pLight->LclFlags;
    pCached->lpLcl->ddsCaps.dwCaps      = pSurf->Surface.pLight->LclCaps1;
    pCached->lpLcl->dwReserved1         = pSurf->Surface.pLight->LclReserved1;
    pCached->lpLcl->dwModeCreatedIn     = pSurf->Surface.pLight->LclModeCreatedIn;
    pCached->lpLcl->dwBackBufferCount   = pSurf->Surface.pLight->LclBackBufferCount;
    pCached->lpLcl->dwProcessId         = pDevice->PID;

    pCached->lpLcl->lpGbl->dwGlobalFlags    = pSurf->Surface.pLight->GblFlags;
    pCached->lpLcl->lpGbl->lPitch           = pSurf->Surface.pLight->GblPitch;
    pCached->lpLcl->lpGbl->wWidth           = (WORD) pSurf->Surface.pLight->GblWidth;
    pCached->lpLcl->lpGbl->wHeight          = (WORD) pSurf->Height;
    pCached->lpLcl->lpGbl->dwReserved1      = pSurf->Surface.pLight->GblReserved1;
    if (pSurf->Surface.pLight->GblFormat != D3DFMT_UNKNOWN)
    {
        ConvertToOldFormat(&pCached->lpLcl->lpGbl->ddpfSurface, 
            pSurf->Surface.pLight->GblFormat);
    }
    pCached->lpLcl->lpGbl->lpVidMemHeap     = pSurf->Surface.pLight->pGblVidMemHeap;
    pCached->lpLcl->lpGbl->fpVidMem         = pSurf->Surface.pLight->fpGblVidMem;

    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps2   = pSurf->Surface.pLight->MoreCaps2;
    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps3   = pSurf->Surface.pLight->MoreCaps3;
    pCached->lpLcl->lpSurfMore->ddsCapsEx.dwCaps4   = pSurf->Surface.pLight->MoreCaps4;
    pCached->lpLcl->lpSurfMore->rgjunc              = pSurf->Surface.pLight->MoreRgjunc;
    pCached->lpLcl->lpSurfMore->dwSurfaceHandle     = pSurf->dwCookie;
    if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        pCached->lpLcl->lpSurfMore->lpDD_lcl = pDevice->pSwDD->lpLcl;
        pCached->lpLcl->lpSurfMore->lpDD_int = pDevice->pSwDD;
        pCached->lpLcl->lpGbl->lpDD          = pDevice->pSwDD->lpLcl->lpGbl;
    }
    else
    {
        pCached->lpLcl->lpSurfMore->lpDD_lcl = pDevice->pDD->lpLcl;
        pCached->lpLcl->lpSurfMore->lpDD_int = pDevice->pDD;
        pCached->lpLcl->lpGbl->lpDD          = pDevice->pDD->lpLcl->lpGbl;
    }

    (*ppGblMore)->dwDriverReserved              = pSurf->Surface.pLight->GblMoreDriverReserved;
    (*ppGblMore)->dwContentsStamp               = pSurf->Surface.pLight->GblMoreContentsStamp;
    (*ppGblMore)->lpvUnswappedDriverReserved    = pSurf->Surface.pLight->pGblMoreUnswappedDriverReserved;
    (*ppGblMore)->fpAliasOfVidMem               = pSurf->Surface.pLight->fpGblMoreAliasOfVidMem;
    (*ppGblMore)->cPageUnlocks                  = pSurf->Surface.pLight->cGblMorePageUnlocks;

    if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) 
    {
        pCached->lpLcl->lpSurfMore->dwMipMapCount   = pSurf->Surface.pLight->MoreMipMapCount;
    }
    else
    {
        pCached->lpLcl->lpSurfMore->dwFVF           = pSurf->Surface.pLight->MoreFVF;
    }

    if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pCached->lpLcl->lpSurfMore->dwBytesAllocated    = pSurf->Surface.pLight->MoreBytesAllocated;
    }
    else if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        (*ppGblMore)->fpPhysicalVidMem  = pSurf->Surface.pLight->fpGblMorePhysicalVidMem;
    }
    else if (pCached->lpLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
    {
        (*ppGblMore)->fpAliasedVidMem   = pSurf->Surface.pLight->fpGblMoreAliasedVidMem;
    }

    pCached->lpVtbl = (LPVOID) &ddSurface7Callbacks;

    return pCached;
}

void UnmapLightweightSurface(DDSURFACE* pSurf)
{
    DDASSERT(pSurf->Surface.pLight->CachedIndex & INDEX_IN_USE);
    DDASSERT(pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT);
    DDASSERT(GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved2 > 0);

    if (--(GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved2) == 0)
    {
        // Vertex and command buffers are used by DP2, so we want to optimize
        // for them.  Even though we are done using the surface, we will keep
        // the heavyweight surface around so we can use it again quickly if
        // we need to.

        if (!(pSurf->Surface.pLight->LclCaps1 & DDSCAPS_EXECUTEBUFFER))
        {
            UpdateSurfaceCache(pSurf);
            GET_CACHED_ENTRY(pSurf)->pSurface->dwReserved1 = (ULONG_PTR) NULL;
            pSurf->Surface.pLight->CachedIndex = 0;
        }
    }
}

void ReleaseDX7SurfaceHandle(HANDLE hDD, DWORD handle)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;

    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry =
        pDeviceHandle->SurfaceHandleList.dwFreeList;
    pDeviceHandle->SurfaceHandleList.dwFreeList = handle;
}

DWORD GetDX7SurfaceHandle (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    DWORD           handle = pDeviceHandle->SurfaceHandleList.dwFreeList;

    if (0==handle)
    {
        // need to grow the dwList
        LPDDSURFACELISTENTRY  newList;
        DWORD   newsize;
        DWORD   index;
        if (NULL != pDeviceHandle->SurfaceHandleList.dwList)
        {
            // old size(current dwFreeList) must not be zero
            DDASSERT(0 != pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
            // new dwFreeList is always gonna be the old dwList[0].nextentry
            newsize = pDeviceHandle->SurfaceHandleList.dwList[0].nextentry + LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle()");
                return  0;
            }
            pDeviceHandle->SurfaceHandleList.dwFreeList =
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry;
            memcpy((LPVOID)newList,(LPVOID)pDeviceHandle->SurfaceHandleList.dwList,
                pDeviceHandle->SurfaceHandleList.dwList[0].nextentry*sizeof(DDSURFACELISTENTRY));
            MemFree(pDeviceHandle->SurfaceHandleList.dwList);
        }
        else
        {
            newsize = LISTGROWSIZE;
            newList=(LPDDSURFACELISTENTRY)MemAlloc(newsize*sizeof(DDSURFACELISTENTRY));
            if (NULL == newList)
            {
                DPF_ERR("MemAlloc failure in GetSurfaceHandle()");
                return  0;
            }
            // start from one as we don't want 0 as a valid handle
            pDeviceHandle->SurfaceHandleList.dwFreeList = 1;
        }
        pDeviceHandle->SurfaceHandleList.dwList=newList;
        pDeviceHandle->SurfaceHandleList.dwList[0].nextentry=newsize;

        for (index = pDeviceHandle->SurfaceHandleList.dwFreeList;
            index < newsize - 1;
            index++)
        {
            newList[index].nextentry=index+1;
        }
        // indicate end of new FreeList
        newList[newsize-1].nextentry=0;
        // now pop up one and assign it to handle
        handle=pDeviceHandle->SurfaceHandleList.dwFreeList;
    }
    // handle slot is avialable so just remove it from freeList
    pDeviceHandle->SurfaceHandleList.dwFreeList =
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry;
#if DBG
    pDeviceHandle->SurfaceHandleList.dwList[handle].nextentry=0xDEADBEEF;
#endif
    pDeviceHandle->SurfaceHandleList.dwList[handle].dwFlags=0;  //mark it's new
    pDeviceHandle->SurfaceHandleList.dwList[handle].lpSurface=NULL;
    DDASSERT (handle > 0);
    DDASSERT (handle < pDeviceHandle->SurfaceHandleList.dwList[0].nextentry);
    return handle;
}

void FreeSurfaceObject (PDDSURFACE pSurf, BOOL bDestroy)
{
    if ((pSurf != NULL) &&
        !(pSurf->dwFlags & DDSURFACE_DUMMY))
    {
        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            LPDDRAWI_DDRAWSURFACE_INT pHeavy;

            if (pSurf->Surface.pLight != NULL)
            {
                pHeavy = GetHeavyweightSurf(pSurf);
                if (pHeavy != NULL)
                {
                    if (pSurf->dwFlags & DDSURFACE_CREATECOMPLETE)
                    {
                        SwDDIDestroySurface (pSurf->pDevice, pSurf, pHeavy->lpLcl);
                    }
                    else if (pSurf->dwFlags & DDSURFACE_CREATEEX)
                    {
                        pHeavy->lpLcl->lpGbl->fpVidMem = 0;
                        SwDDICreateSurfaceEx (pSurf->pDevice->pSwDD->lpLcl,
                            pHeavy->lpLcl);
                    }

                    // Uncache the lightweight surface

                    if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                    {
                        pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                        pHeavy->dwReserved2 = 0;
                    }
                }
                
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }

            if (pSurf->dwCookie != 0)
            {
                ReleaseDX7SurfaceHandle(pSurf->pDevice, pSurf->dwCookie);
                pSurf->dwCookie = 0;
            }
        }

        else if (pSurf->dwFlags & DDSURFACE_HEAVYWEIGHT)
        {
            // If we created a texture handle, free it now

            if ((pSurf->dwFlags & DDSURFACE_DX6HANDLE) &&
                (pSurf->pDevice->pContext != NULL) &&
                (pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy != NULL))
            {
                D3DHAL_TEXTUREDESTROYDATA   data;
                DWORD                       ret;

                data.dwhContext = (ULONG_PTR) pSurf->pDevice->pContext->Context;
                data.dwHandle = pSurf->dwCookie;

                CALL_D3DHAL_TAKEBUSY_TAKEWIN16(ret,
                            pSurf->pDevice,
                            pSurf->pDevice->pDD->lpLcl->lpGbl->lpD3DHALCallbacks->TextureDestroy,
                            &data);
            }
            pSurf->dwFlags &= ~DDSURFACE_DX6HANDLE;

            // Now delete the heavy weight surface

            if (bDestroy)
            {
                if (pSurf->Surface.pHeavy != NULL)
                {
                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        InternalSurfaceRelease(pSurf->Surface.pHeavy, FALSE, TRUE);
                    }
                }
                pSurf->Surface.pHeavy = NULL;
            }
            else if (pSurf->Surface.pHeavy != NULL)
            {
                invalidateSurface(pSurf->Surface.pHeavy->lpLcl);
            }
        }
        else if (pSurf->Surface.pLight != NULL)
        {
            LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

            pHeavy = MapLightweightSurface(pSurf);
            if (pHeavy != NULL)
            {
                if (bDestroy)
                {
                    pHeavy->dwIntRefCnt = 1;
                    pHeavy->lpLcl->dwLocalRefCnt = 1;
                    pHeavy->lpLcl->lpGbl->dwRefCnt = 1;

                    if (pSurf->dwFlags & DDSURFACE_ROOT)
                    {
                        pHeavy->lpLcl->lpSurfMore->pAddrefedThisOwner = (IUnknown*) pSurf->pDevice->pDD;
                    }
                    pHeavy->lpLcl->dwFlags &= ~DDRAWISURF_IMPLICITCREATE;

                    InternalSurfaceRelease(pHeavy, TRUE, TRUE);

                    pHeavy->dwReserved1 = (ULONG_PTR) NULL;
                    pHeavy->dwReserved2 = 0;
                }
                else
                {
                    invalidateSurface(pHeavy->lpLcl);
                    DONE_HEAVYWEIGHT_SURF(pSurf);
                }
            }
            if (bDestroy)
            {
                MemFree (pSurf->Surface.pLight);
                pSurf->Surface.pLight = NULL;
            }
        }
    }
}

/*****************************Private*Routine******************************\
* DdConvertToOldFormat
*
* History:
*  3-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void ConvertToOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT NewFormat)
{
    // Zero out the format to avoid missing
    // cases where it isn't initialized right
    ZeroMemory(pOldFormat, sizeof(*pOldFormat));

    // Set Size
    pOldFormat->dwSize = sizeof(DDPIXELFORMAT);

    // Convert away
    if (HIWORD((DWORD)NewFormat))
    {
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        return;
    }

    switch (NewFormat)
    {
    case D3DFMT_R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 24;
        break;

    case D3DFMT_A8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0xFF000000;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_X8R8G8B8:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00ff0000;
        pOldFormat->dwGBitMask        = 0x0000ff00;
        pOldFormat->dwBBitMask        = 0x000000ff;
        pOldFormat->dwRGBBitCount     = 32;
        break;

    case D3DFMT_R5G6B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x0000f800;
        pOldFormat->dwGBitMask        = 0x000007e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A1R5G5B5:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x00008000;
        pOldFormat->dwRBitMask        = 0x00007c00;
        pOldFormat->dwGBitMask        = 0x000003e0;
        pOldFormat->dwBBitMask        = 0x0000001f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000f000;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_X4R4G4B4:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x00000f00;
        pOldFormat->dwGBitMask        = 0x000000f0;
        pOldFormat->dwBBitMask        = 0x0000000f;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 8;
        break;

    case D3DFMT_A8R3G3B2:
        pOldFormat->dwFlags           = DDPF_RGB | DDPF_ALPHAPIXELS;
        pOldFormat->dwRGBAlphaBitMask = 0x0000FF00;
        pOldFormat->dwRBitMask        = 0x000000e0;
        pOldFormat->dwGBitMask        = 0x0000001c;
        pOldFormat->dwBBitMask        = 0x00000003;
        pOldFormat->dwRGBBitCount     = 16;
        break;

    case D3DFMT_A8P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_ALPHAPIXELS |
                                         DDPF_PALETTEINDEXED8;

        pOldFormat->dwRGBAlphaBitMask  = 0x0000FF00;
        pOldFormat->dwRGBBitCount      = 16;
        break;

    case D3DFMT_P8:
        pOldFormat->dwFlags            = DDPF_RGB         |
                                         DDPF_PALETTEINDEXED8;
        pOldFormat->dwRGBBitCount      = 8;
        break;

    case D3DFMT_L8:
        pOldFormat->dwFlags             = DDPF_LUMINANCE;
        pOldFormat->dwLuminanceBitMask  = 0x000000FF;
        pOldFormat->dwLuminanceBitCount = 8;
        break;

    case D3DFMT_A8L8:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x0000FF00;
        pOldFormat->dwLuminanceBitMask      = 0x000000FF;
        pOldFormat->dwLuminanceBitCount     = 16;
        break;

    case D3DFMT_A4L4:
        pOldFormat->dwFlags                 = DDPF_LUMINANCE |
                                              DDPF_ALPHAPIXELS;
        pOldFormat->dwLuminanceAlphaBitMask = 0x000000F0;
        pOldFormat->dwLuminanceBitMask      = 0x0000000F;
        pOldFormat->dwLuminanceBitCount     = 8;
        break;

    case D3DFMT_V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_L6V5U5:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x0000FC00;
        pOldFormat->dwBumpDvBitMask        = 0x000003E0;
        pOldFormat->dwBumpDuBitMask        = 0x0000001F;
        pOldFormat->dwBumpBitCount         = 16;
        break;

    case D3DFMT_X8L8V8U8:
        pOldFormat->dwFlags                = DDPF_BUMPDUDV |
                                             DDPF_BUMPLUMINANCE;
        pOldFormat->dwBumpLuminanceBitMask = 0x00FF0000;
        pOldFormat->dwBumpDvBitMask        = 0x0000FF00;
        pOldFormat->dwBumpDuBitMask        = 0x000000FF;
        pOldFormat->dwBumpBitCount         = 32;
        break;

    case D3DFMT_A8:
        pOldFormat->dwFlags                = DDPF_ALPHA;
        pOldFormat->dwAlphaBitDepth        = 8;
        break;

    case D3DFMT_D16:
    case D3DFMT_D16_LOCKABLE:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D32:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0;
        break;

    case D3DFMT_D15S1:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0xFFFE;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x0001;
        break;
    case D3DFMT_D24S8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF;
        break;
    case D3DFMT_S1D15:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;;
        pOldFormat->dwZBufferBitDepth      = 16;
        pOldFormat->dwZBitMask             = 0x7FFF;
        pOldFormat->dwStencilBitDepth      = 1;
        pOldFormat->dwStencilBitMask       = 0x8000;
        break;
    case D3DFMT_S8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 8;
        pOldFormat->dwStencilBitMask       = 0xFF000000;
        break;
    case D3DFMT_X8D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X8:
        pOldFormat->dwFlags                = DDPF_ZBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 0;
        pOldFormat->dwStencilBitMask       = 0x00000000;
        break;
    case D3DFMT_D24X4S4:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0xFFFFFF00;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0000000F;
        break;
    case D3DFMT_X4S4D24:
        pOldFormat->dwFlags                = DDPF_ZBUFFER |
                                             DDPF_STENCILBUFFER;
        pOldFormat->dwZBufferBitDepth      = 32;
        pOldFormat->dwZBitMask             = 0x00FFFFFF;
        pOldFormat->dwStencilBitDepth      = 4;
        pOldFormat->dwStencilBitMask       = 0x0F000000;
        break;

    default:
        // All other formats are treated as a
        // FOURCC
        pOldFormat->dwFlags = DDPF_FOURCC;
        pOldFormat->dwFourCC = (DWORD)NewFormat;
        break;
    }

    return;
}

/*****************************Private*Routine******************************\
* DdConvertFromOldFormat
*
* History:
*  13-Nov-1999 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void ConvertFromOldFormat(LPDDPIXELFORMAT pOldFormat, D3DFORMAT *pNewFormat)
{
    *pNewFormat = D3DFMT_UNKNOWN;
    if (pOldFormat->dwFlags & DDPF_FOURCC)
    {
        ((DWORD)*pNewFormat) = pOldFormat->dwFourCC;
    }
    else if (pOldFormat->dwFlags == DDPF_RGB)
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if ((pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_R3G3B2;
            }
            else
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if ((pOldFormat->dwRBitMask == 0x0000f800) &&
                (pOldFormat->dwGBitMask == 0x000007e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_R5G6B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_X1R5G5B5;
            }
            else if ((pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_X4R4G4B4;
            }
            break;

        case 24:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_R8G8B8;
            }
            break;

        case 32:
            if ((pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_X8R8G8B8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_RGB | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 16:
            if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x000000e0) &&
                (pOldFormat->dwGBitMask == 0x0000001c) &&
                (pOldFormat->dwBBitMask == 0x00000003))
            {
                *pNewFormat = D3DFMT_A8R3G3B2;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000f000) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x0000FF00) &&
                (pOldFormat->dwRBitMask == 0x00000f00) &&
                (pOldFormat->dwGBitMask == 0x000000f0) &&
                (pOldFormat->dwBBitMask == 0x0000000f))
            {
                *pNewFormat = D3DFMT_A4R4G4B4;
            }
            else if ((pOldFormat->dwRGBAlphaBitMask == 0x00008000) &&
                (pOldFormat->dwRBitMask == 0x00007c00) &&
                (pOldFormat->dwGBitMask == 0x000003e0) &&
                (pOldFormat->dwBBitMask == 0x0000001f))
            {
                *pNewFormat = D3DFMT_A1R5G5B5;
            }
            break;

        case 32:
            if ((pOldFormat->dwRGBAlphaBitMask == 0xff000000) &&
                (pOldFormat->dwRBitMask == 0x00ff0000) &&
                (pOldFormat->dwGBitMask == 0x0000ff00) &&
                (pOldFormat->dwBBitMask == 0x000000ff))
            {
                *pNewFormat = D3DFMT_A8R8G8B8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_ALPHA)
    {
        if (pOldFormat->dwAlphaBitDepth == 8)
        {
            *pNewFormat = D3DFMT_A8;
        }
    }
    else if (pOldFormat->dwFlags & (DDPF_PALETTEINDEXED8 | DDPF_RGB))
    {
        switch (pOldFormat->dwRGBBitCount)
        {
        case 8:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 | DDPF_RGB))
            {
                *pNewFormat = D3DFMT_P8;
            }
            break;

        case 16:
            if (pOldFormat->dwFlags == (DDPF_PALETTEINDEXED8 |
                                        DDPF_RGB             |
                                        DDPF_ALPHAPIXELS) &&
                pOldFormat->dwRGBAlphaBitMask == 0xFF00)
            {

                *pNewFormat = D3DFMT_A8P8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_ZBUFFER)
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if (pOldFormat->dwZBitMask == 0xffffffff)
            {
                *pNewFormat = D3DFMT_D32;
            }
            else if (pOldFormat->dwZBitMask == 0x00FFFFFF)
            {
                *pNewFormat = D3DFMT_X8D24;
            }
            else if (pOldFormat->dwZBitMask == 0xFFFFFF00)
            {
                *pNewFormat = D3DFMT_D24X8;
            }
            break;

        case 16:
            if (pOldFormat->dwZBitMask == 0xffff)
            {
                *pNewFormat = D3DFMT_D16;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_ZBUFFER | DDPF_STENCILBUFFER))
    {
        switch (pOldFormat->dwZBufferBitDepth)
        {
        case 32:
            if ((pOldFormat->dwZBitMask == 0xffffff00) &&
                (pOldFormat->dwStencilBitMask == 0x000000ff) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_D24S8;
            }
            else if ((pOldFormat->dwZBitMask == 0x00ffffff) &&
                (pOldFormat->dwStencilBitMask == 0xff000000) &&
                (pOldFormat->dwStencilBitDepth == 8))
            {
                *pNewFormat = D3DFMT_S8D24;
            }
            break;
        case 16:
            if ((pOldFormat->dwZBitMask == 0xfffe) &&
                (pOldFormat->dwStencilBitMask == 0x0001) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_D15S1;
            }
            else if ((pOldFormat->dwZBitMask == 0x7fff) &&
                (pOldFormat->dwStencilBitMask == 0x8000) &&
                (pOldFormat->dwStencilBitDepth == 1))
            {
                *pNewFormat = D3DFMT_S1D15;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_LUMINANCE)
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask == 0xFF)
            {
                *pNewFormat = D3DFMT_L8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_LUMINANCE | DDPF_ALPHAPIXELS))
    {
        switch (pOldFormat->dwLuminanceBitCount)
        {
        case 8:
            if (pOldFormat->dwLuminanceBitMask      == 0x0F &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xF0)
            {
                *pNewFormat = D3DFMT_A4L4;
            }
        case 16:
            if (pOldFormat->dwLuminanceBitMask      == 0x00FF &&
                pOldFormat->dwLuminanceAlphaBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_A8L8;
            }

            break;
        }
    }
    else if (pOldFormat->dwFlags == DDPF_BUMPDUDV)
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask == 0xFF &&
                pOldFormat->dwBumpDvBitMask == 0xFF00)
            {
                *pNewFormat = D3DFMT_V8U8;
            }
            break;
        }
    }
    else if (pOldFormat->dwFlags == (DDPF_BUMPDUDV | DDPF_BUMPLUMINANCE))
    {
        switch (pOldFormat->dwBumpBitCount)
        {
        case 16:
            if (pOldFormat->dwBumpDuBitMask        == 0x001F &&
                pOldFormat->dwBumpDvBitMask        == 0x03E0 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFC00)
            {
                *pNewFormat = D3DFMT_L6V5U5;
            }
            break;

        case 32:
            if (pOldFormat->dwBumpDuBitMask        == 0x0000FF &&
                pOldFormat->dwBumpDvBitMask        == 0x00FF00 &&
                pOldFormat->dwBumpLuminanceBitMask == 0xFF0000)
            {
                *pNewFormat = D3DFMT_X8L8V8U8;
            }
            break;
        }
    }
}

// How lost devices work:
//
// Device can be lost two ways:
// 1)  A mode change or something occurs, in which DDraw knows about it and
//     calls CleanupD3D8.  In this case, we free the surfaces and mark the
//     device as lost.
//
//     This will only happen when the DDRAW critical section is held, so as long
//     as we check for lost devices while the critical section is held, we are
//     safe to use the surface structures.
//
// 2)  A DOS box or something occurs in which case we don't know about it,
//     but we can find out by polling the busy bit.  This can occur at anytime,
//     although we are gaurenteed that it will never happen while we are holding
//     the win16 lock.  In fact, if we don't hold the win16 lock while checking
//     the busy bit, we will get false positives simple by dragging another window
//     around.
//
//  So, we have to grab the busy bit to check for lost, and we need to hold the
//  DDraw critical section throughout the remained of the call since not holding
//  it can cause surfaces to go away out from under us.  Also, when calling HAL
//  we always grab the win16 lock, so in each call we could be grabbing it twice.
//  With all of this in mind, it's probably better just to ENTER_BOTH() before
//  we check for device lost and then LEAVE_BOTH() at the end of the funtion.
//
//  We can also remove the busybit check from the HAL call since we already know
//  that it's not set since we checked it and are still holding the win16 lock, so
//  nobody else can set.

void LoseDevice (DDDEVICEHANDLE* pDevice)
{
    DDSURFACE*      pSurf;
    if (!pDevice->bDeviceLost)
    {
        // The device has transitioned to the lost state, so we need
        // walk through the list and free the vidmem surfaces..

        pDevice->bDeviceLost  = TRUE;
        pSurf = pDevice->pSurfList;
        while (pSurf != NULL)
        {
            if (IS_SURFACE_LOOSABLE(pSurf))
            {
                FreeSurfaceObject(pSurf, FALSE);
            }
            pSurf = pSurf->pNext;
        }
    }
}


BOOL CheckForDeviceLost (HANDLE hDD)
{
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) hDD;
    PDDSURFACE      pSurf;

    if (pDeviceHandle->bDeviceLost)
    {
        return TRUE;
    }

    // The below check will only be reliable if we are holding the win16 lock.
    // if dwWin16LockCnt != 0 that means BUSY bit was set by DdLock
    if ( 0 == pDeviceHandle->pDD->lpLcl->lpGbl->dwWin16LockCnt &&
        (*(pDeviceHandle->pDD->lpLcl->lpGbl->lpwPDeviceFlags) & BUSY )
       )
    {
        LoseDevice(pDeviceHandle);
        return TRUE;
    }

    return FALSE;
}


DWORD WINAPI DdBlt( PD3D8_BLTDATA pBlt )
{
    DDSURFACE*      pSrcSurf = (DDSURFACE*) pBlt->hSrcSurface;
    DDSURFACE*      pDstSurf = (DDSURFACE*) pBlt->hDestSurface;
    PDDDEVICEHANDLE pDevice  = (PDDDEVICEHANDLE) pBlt->hDD;

    // Return failure on bad paths
    pBlt->ddRVal = E_FAIL;

    ENTER_BOTH();
    if (CheckForDeviceLost(pBlt->hDD))
    {
        // Some blts should fail, others should succeed:
        // persistant -> non persitant : OK
        // persistant -> persitant : FAIL
        // non persistant -> persistant : FAIL
        // non persistant -> non persistant : OK

        if ((pDstSurf->Pool == D3DPOOL_LOCALVIDMEM) ||
            (pDstSurf->Pool == D3DPOOL_NONLOCALVIDMEM))
        {
            pBlt->ddRVal = DD_OK;
        }
        else
        {
            pBlt->ddRVal = D3DERR_DEVICELOST;
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

#ifdef DEBUG
    // Just a colorfill? Used only in debug for
    // enforcing DISCARD
    if (pSrcSurf == NULL)
    {
        LPDDRAWI_DDRAWSURFACE_INT   pHeavyDst;

        pHeavyDst = GetHeavyweightSurf(pDstSurf);
        if (pHeavyDst != NULL)
        {
            pBlt->bltFX.dwSize = sizeof(DDBLTFX);
            pBlt->ddRVal = DD_Surface_Blt((LPDIRECTDRAWSURFACE)pHeavyDst,
                                           NULL,
                                           NULL,
                                           NULL,
                                           pBlt->dwFlags,
                                           &pBlt->bltFX);
            if (FAILED(pBlt->ddRVal))
            {
                DPF_ERR("Driver failed color-fill blt");
            }

            DONE_HEAVYWEIGHT_SURF(pDstSurf);
        }

        pBlt->ddRVal = S_OK;

        LEAVE_BOTH();
        return S_OK;
    }
#endif 

    if (DDBLT_COPYVSYNC & pBlt->dwFlags) 
    {
        DWORD                msCurrentTime;
        DWORD                threshold;

        // Compute how many milliseconds there
        // are per refresh. We round down.
        if (pDevice->pDD->lpLcl->lpGbl->dwMonitorFrequency == 0)
        {
            // 60Hz = 16.666ms per frame
            // 75Hz = 13.333ms
            // 85Hz = 11.765ms
            threshold = 13;
        }
        else
        {
            threshold = (DWORD)(1000.0f / 
                    (float)(pDevice->pDD->lpLcl->lpGbl->dwMonitorFrequency)); 
        }

        while (1)
        {
            msCurrentTime = GetTickCount();
    
            // If the previous blt was long
            // enough ago i.e. a refresh, then
            // we can break out this loop
            if ((msCurrentTime - pBlt->msLastPresent) > threshold )
                break;
        }

        // For DDBLT_COPYVSYNC remember the
        // time for this blt was sent
        pBlt->msLastPresent = msCurrentTime;
    }

    if ((pSrcSurf) && (pDstSurf))
    {
        if ((pSrcSurf->Format == pDstSurf->Format ||
            (pBlt->dwFlags & DDBLT_WINDOWCLIP)) &&
            !IS_SOFTWARE_DRIVER_SURFACE(pSrcSurf) &&
            !IS_SOFTWARE_DRIVER_SURFACE(pDstSurf))
        {
            LPDDRAWI_DDRAWSURFACE_INT   pHeavySrc;
            LPDDRAWI_DDRAWSURFACE_INT   pHeavyDst;
            DWORD                       dwFlags = pBlt->dwFlags & ~DDBLT_WINDOWCLIP;

            pHeavySrc = GetHeavyweightSurf(pSrcSurf);
            if (pHeavySrc == NULL)
            {
                pBlt->ddRVal = DDERR_OUTOFMEMORY;
                LEAVE_BOTH();
                return DDHAL_DRIVER_HANDLED;
            }
            pHeavyDst = GetHeavyweightSurf(pDstSurf);
            if (pHeavyDst == NULL)
            {
                DONE_HEAVYWEIGHT_SURF(pSrcSurf);
                pBlt->ddRVal = DDERR_OUTOFMEMORY;
                LEAVE_BOTH();
                return DDHAL_DRIVER_HANDLED;
            }
    
            if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
            {
               LPDDRAWI_DDRAWCLIPPER_INT pcClipper = pHeavyDst->lpLcl->lpSurfMore->lpDDIClipper;

               DDASSERT(IsWindow(pBlt->hWnd));
               DDASSERT(DDSCAPS_PRIMARYSURFACE & pHeavyDst->lpLcl->ddsCaps.dwCaps);
               DDASSERT(pcClipper);
               if (pcClipper)
               {
                    (HWND) pcClipper->lpLcl->lpGbl->hWnd = pBlt->hWnd;
                    dwFlags |= DDBLT_WINDOWCLIP;
                    DPF(10,"Updated hWnd=%08lx", pBlt->hWnd);
                }
            }
            pBlt->bltFX.dwSize = sizeof(DDBLTFX);
            pBlt->bltFX.dwROP = SRCCOPY;
            pBlt->ddRVal = DD_Surface_Blt((LPDIRECTDRAWSURFACE)pHeavyDst,
                                           (LPRECT) &(pBlt->rDest),
                                           (LPDIRECTDRAWSURFACE)pHeavySrc,
                                           (LPRECT) &(pBlt->rSrc),
                                           dwFlags,
                                           &pBlt->bltFX);
            DONE_HEAVYWEIGHT_SURF(pSrcSurf);
            DONE_HEAVYWEIGHT_SURF(pDstSurf);
        }
        if (FAILED(pBlt->ddRVal))
        {
            // !!! Just use GetDC on the DirectDraw surface for now, though this is
            // probably way too slow on drivers which do not support derived
            // surfaces. DirectDraw Blt support should be added soon.
            HDC hDCTarget;
            if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
                hDCTarget = GetDC(pBlt->hWnd);
            else
                hDCTarget = D3D8GetDC(pBlt->hDestSurface, NULL);
            if (hDCTarget != NULL)
            {
                HDC hDCSource = D3D8GetDC(pBlt->hSrcSurface, NULL);
                if (hDCSource != NULL)
                {
                    LONG DestWidth=pBlt->rDest.right - pBlt->rDest.left;
                    LONG DestHeight= pBlt->rDest.bottom - pBlt->rDest.top;
                    LONG SrcWidth= pBlt->rSrc.right - pBlt->rSrc.left;
                    LONG SrcHeight= pBlt->rSrc.bottom - pBlt->rSrc.top;
                    if (DestWidth == SrcWidth && DestHeight == SrcHeight)
                    {
                        if (BitBlt(
                            hDCTarget,
                            pBlt->rDest.left,
                            pBlt->rDest.top,
                            DestWidth,
                            DestHeight,
                            hDCSource,
                            pBlt->rSrc.left,
                            pBlt->rSrc.top,
                            SRCCOPY))
                        {
                            pBlt->ddRVal = S_OK;
                        }
                    }
                    else
                    {
                        // COLORONCOLOR is not the default in NT
                        int saved = SetStretchBltMode(hDCTarget,COLORONCOLOR);
                        if (StretchBlt(
                            hDCTarget,
                            pBlt->rDest.left,
                            pBlt->rDest.top,
                            DestWidth,
                            DestHeight,
                            hDCSource,
                            pBlt->rSrc.left,
                            pBlt->rSrc.top,
                            SrcWidth,
                            SrcHeight,
                            SRCCOPY))
                        {
                            pBlt->ddRVal = S_OK;
                        }
                        // restore to previous mode
                        if (saved)
                            SetStretchBltMode(hDCTarget,saved);
                    }
                    D3D8ReleaseDC(pBlt->hSrcSurface, hDCSource);
                }
                if ((pBlt->hWnd) && (DDBLT_WINDOWCLIP & pBlt->dwFlags))
                    ReleaseDC(pBlt->hWnd, hDCTarget);
                else
                    D3D8ReleaseDC(pBlt->hDestSurface, hDCTarget);
            }
        }

        // We only want to report DP2 errors  during the present call because
        // checking for it everywhere is too hard.
        if ((pBlt->ddRVal == DD_OK) &&
            (pDevice->bDP2Error) &&
            (pBlt->dwFlags & DDBLT_WINDOWCLIP))
        {
            pDevice->bDP2Error = FALSE;

            // We use a special error here to mean that the blt succeeded
            // but that that some DP2 failed since the last present
            pBlt->ddRVal = D3DERR_DEFERRED_DP2ERROR;
        }

        LEAVE_BOTH();

        pBlt->ddRVal = MapLegacyResult(pBlt->ddRVal);
        return DDHAL_DRIVER_HANDLED;
    }
    LEAVE_BOTH();

    pBlt->ddRVal = MapLegacyResult(pBlt->ddRVal);
    return DDHAL_DRIVER_NOTHANDLED;
}

DWORD APIENTRY DdFlip( PD3D8_FLIPDATA pFlip )
{
    DDSURFACE*      pCurrSurf = (DDSURFACE*) pFlip->hSurfCurr;
    DDSURFACE*      pTargSurf = (DDSURFACE*) pFlip->hSurfTarg;

    ENTER_BOTH();
    if (CheckForDeviceLost(pFlip->hDD))
    {
        LEAVE_BOTH();
        pFlip->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    if ((pCurrSurf) && (pCurrSurf->dwFlags & DDSURFACE_HEAVYWEIGHT) &&
        (pTargSurf) && (pTargSurf->dwFlags & DDSURFACE_HEAVYWEIGHT))
    {
        pFlip->ddRVal = MapLegacyResult( DD_Surface_Flip((LPDIRECTDRAWSURFACE)pCurrSurf->Surface.pHeavy,
                           (LPDIRECTDRAWSURFACE)pTargSurf->Surface.pHeavy,
                           pFlip->dwFlags));
        if (SUCCEEDED(pFlip->ddRVal))
        {
            DDSURFACE Temp;

            // The DirectX runtime swaps the surface handles when it flips, so we
            // need to swap them back to preserve the integrity
        
            Temp = *pCurrSurf;

            DDASSERT(pCurrSurf->Pitch == pTargSurf->Pitch);
            DDASSERT(pCurrSurf->Pool == pTargSurf->Pool);
            DDASSERT(pCurrSurf->Type == pTargSurf->Type);
            DDASSERT(pCurrSurf->Height == pTargSurf->Height);

            pCurrSurf->dwFlags      = pTargSurf->dwFlags;
            pCurrSurf->Surface      = pTargSurf->Surface;
            pCurrSurf->fpVidMem     = pTargSurf->fpVidMem;
            pCurrSurf->pBits        = pTargSurf->pBits;
            pCurrSurf->LockFlags    = pTargSurf->LockFlags;
            pCurrSurf->LockRect     = pTargSurf->LockRect;

            pTargSurf->dwFlags      = Temp.dwFlags;
            pTargSurf->Surface      = Temp.Surface;
            pTargSurf->fpVidMem     = Temp.fpVidMem;
            pTargSurf->pBits        = Temp.pBits;
            pTargSurf->LockFlags    = Temp.LockFlags;
            pTargSurf->LockRect     = Temp.LockRect;

            // We only want to report DP2 errors  during the present call because
            // checking for it everywhere is too hard.
            if (((DDDEVICEHANDLE*)pFlip->hDD)->bDP2Error)
            {
                ((DDDEVICEHANDLE*)pFlip->hDD)->bDP2Error = FALSE;

                // We use a special error here to mean that the flip succeeded
                // but that that some DP2 failed since the last present
                pFlip->ddRVal = D3DERR_DEFERRED_DP2ERROR;
            }
        }
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }
    LEAVE_BOTH();
    return DDHAL_DRIVER_NOTHANDLED;
}

DWORD APIENTRY DdLock( PD3D8_LOCKDATA pLock )
{
    PDDSURFACE                  pSurf = (PDDSURFACE) pLock->hSurface;
    HRESULT                     hr;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyInt;

    // Mask off new flags
    pLock->dwFlags &= (D3DLOCK_READONLY         |
                       D3DLOCK_DISCARD          |   
                       D3DLOCK_NOOVERWRITE      |
                       D3DLOCK_NOSYSLOCK);         

    // Always turn on Wait
    pLock->dwFlags |= DDLOCK_WAIT;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        DWORD Width;

        if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
        {
            pLock->lpSurfData = (LPVOID) pSurf->Surface.pLight->fpGblVidMem;
            pLock->lPitch = pSurf->Surface.pLight->GblPitch;
            Width = pSurf->Surface.pLight->GblWidth;
        }
        else
        {
            ENTER_DDRAW();
            pLock->lpSurfData = (LPVOID) pSurf->Surface.pHeavy->lpLcl->lpGbl->fpVidMem;
            pLock->lPitch = pSurf->Surface.pHeavy->lpLcl->lpGbl->lPitch;
            Width = (DWORD) pSurf->Surface.pHeavy->lpLcl->lpGbl->wWidth;
            LEAVE_DDRAW();
        }

        if (pLock->bHasRange)
        {
            ((BYTE*)pLock->lpSurfData) += pLock->lPitch * pLock->range.Offset;
        }
        else if (pLock->bHasRect)
        {
            ((BYTE*)pLock->lpSurfData) += pLock->lPitch * pLock->rArea.top;
            ((BYTE*)pLock->lpSurfData) += (pLock->lPitch / Width) * pLock->rArea.left;
        }
        hr = DD_OK;
    }

    else if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
    {
        ENTER_DDRAW();
        pHeavyInt = GetHeavyweightSurf(pSurf);
        if (pHeavyInt == NULL)
        {
            // This can be caused by an out of memory condition when calling
            // MapLightweightSurface

            hr = DDERR_OUTOFMEMORY;
        }
        else
        {
            if(pLock->bHasRange)
            {
                pLock->bHasRange = FALSE;
                pLock->bHasRect = TRUE;
                pLock->rArea.left = 0;
                pLock->rArea.right = 0;
                pLock->rArea.top = pLock->range.Offset;
                pLock->rArea.bottom = pLock->range.Offset + pLock->range.Size;
            }

            hr = SwDDILock (pLock->hDD, pSurf, pLock, pHeavyInt->lpLcl);
            pLock->lPitch = pHeavyInt->lpLcl->lpGbl->lPitch;
        }
        LEAVE_DDRAW();
    }
    else 
    {
        ENTER_BOTH();
        if ((CheckForDeviceLost(pLock->hDD) &&
             pSurf->Pool != D3DPOOL_MANAGED) ||
            (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED))
        {
            DWORD Height = pSurf->Height;
            if (Height == 0)
            {
                Height++;
            }

            if ((pSurf->fpVidMem == NULL) ||
                !(pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED))
            {
                DDASSERT(pSurf->Pool != D3DPOOL_MANAGED);
                if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                    (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                {
                    // For volumes, height actually contains the depth
                    pSurf->fpVidMem = (char*) MemAlloc(
                        pSurf->iSlicePitch * Height);
                }
                else
                {
                    pSurf->fpVidMem = (char*)MemAlloc(pSurf->Pitch * Height);
                }
                if (pSurf->fpVidMem != NULL)
                {
                    pSurf->dwFlags |= DDSURFACE_SYSMEMALLOCATED;
                }
            }

            if (pSurf->dwFlags & DDSURFACE_SYSMEMALLOCATED)
            {
                DDASSERT(CheckForDeviceLost(pLock->hDD));

                pLock->lPitch = pSurf->Pitch;
                pLock->lpSurfData = pSurf->fpVidMem;
                pSurf->dwFlags |= DDSURFACE_SYSMEMLOCK;

                if ((pSurf->Type == D3DRTYPE_VOLUME) ||
                    (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
                {
                    pLock->lSlicePitch = pSurf->iSlicePitch;
                }

                hr = DD_OK;
            }
            else
            {
                hr = DDERR_GENERIC;
            }
        }
        else
        {
            pHeavyInt = GetHeavyweightSurf(pSurf);
            if (pHeavyInt == NULL)
            {
                // This can be caused by an out of memory condition when calling
                // MapLightweightSurface
    
                hr = DDERR_OUTOFMEMORY;
            }
            else
            {
                if(pLock->bHasRange)
                {
                    pLock->bHasRect = TRUE;
                    pSurf->LockRect.left = 0;
                    pSurf->LockRect.right = 0;
                    pSurf->LockRect.top = pLock->range.Offset;
                    pSurf->LockRect.bottom = pLock->range.Offset + pLock->range.Size;
                }
                else
                {
                    pSurf->LockRect.left    = pLock->rArea.left;
                    pSurf->LockRect.right   = pLock->rArea.right;
                    pSurf->LockRect.top     = pLock->rArea.top;
                    pSurf->LockRect.bottom  = pLock->rArea.bottom;
                }
                if (pLock->bHasBox)
                {
                    pLock->bHasRect = TRUE;
                    pSurf->LockRect.left = pLock->box.Left;
                    pSurf->LockRect.right = pLock->box.Right;
                    pSurf->LockRect.top = pLock->box.Top;
                    pSurf->LockRect.bottom = pLock->box.Bottom;
                    pSurf->LockRect.left |= (pLock->box.Front << 16);
                    pSurf->LockRect.right |= (pLock->box.Back << 16);
                }

                hr = InternalLock (pHeavyInt->lpLcl,
                                   &pLock->lpSurfData,
                                   pLock->bHasRect ? &pSurf->LockRect : NULL,
                                   pLock->dwFlags | DDLOCK_NOSYSLOCK | (pSurf->Pool == D3DPOOL_MANAGED ? 0 : DDLOCK_TAKE_WIN16));

                if (hr == DD_OK)
                {
                    pLock->lPitch = pHeavyInt->lpLcl->lpGbl->lPitch;
                    pSurf->pBits = pLock->lpSurfData;
                    pSurf->LockFlags = pLock->dwFlags;
                    if (pLock->bHasRect)
                    {
                        pSurf->dwFlags |= DDSURFACE_LOCKRECT;
                    }
                }
            }
        }
        LEAVE_BOTH();
    }

    if ((pSurf->Type == D3DRTYPE_VOLUME) ||
        (pSurf->Type == D3DRTYPE_VOLUMETEXTURE))
    {
        pLock->lSlicePitch = pSurf->iSlicePitch;
    }

    return MapLegacyResult(hr);
}


DWORD APIENTRY DdUnlock( PD3D8_UNLOCKDATA pUnlock )
{
    PDDSURFACE                  pSurf = (PDDSURFACE) pUnlock->hSurface;
    HRESULT                     hr = DDERR_GENERIC;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavy;

    if (pSurf->Pool == D3DPOOL_SYSTEMMEM)
    {
        hr = DD_OK;
    }
    else
    {
        if (IS_SOFTWARE_DRIVER_SURFACE(pSurf))
        {
            ENTER_DDRAW();
            if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
            {
                pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
                DDASSERT(pHeavy != NULL);
            }
            else
            {
                pHeavy = pSurf->Surface.pHeavy;
            }
            hr = SwDDIUnlock (pUnlock->hDD, pSurf, pUnlock, pHeavy->lpLcl);

            DONE_HEAVYWEIGHT_SURF(pSurf);
            LEAVE_DDRAW();
        }
        else
        {    
            if (pSurf->dwFlags & DDSURFACE_SYSMEMLOCK)
            {
                pSurf->dwFlags &= ~DDSURFACE_SYSMEMLOCK;
                hr = DD_OK;
            }
            else if (pSurf->LockFlags)
            {
                ENTER_BOTH();
                if (CheckForDeviceLost(pUnlock->hDD) && pSurf->Pool != D3DPOOL_MANAGED)
                {
                    hr = DD_OK;
                }
                else
                {
                    if (pSurf->dwFlags & DDSURFACE_LIGHTWEIGHT)
                    {
                        pHeavy = GET_CACHED_LIGHTWEIGHT_INT(pSurf);
                        DDASSERT(pHeavy != NULL);
                    }
                    else
                    {
                        pHeavy = pSurf->Surface.pHeavy;
                    }

                    hr = InternalUnlock (pHeavy->lpLcl,
                                         (pSurf->dwFlags & DDSURFACE_LOCKRECT) ? NULL : pSurf->pBits,
                                         (pSurf->dwFlags & DDSURFACE_LOCKRECT) ? &pSurf->LockRect : NULL,
                                         pSurf->LockFlags | DDLOCK_NOSYSLOCK | (pSurf->Pool == D3DPOOL_MANAGED ? 0 : DDLOCK_TAKE_WIN16));
                    pSurf->LockFlags = 0;
                    pSurf->dwFlags &= ~DDSURFACE_LOCKRECT;

                    DONE_HEAVYWEIGHT_SURF(pSurf);
                }
                LEAVE_BOTH();
            }
        }
    }
    return MapLegacyResult(hr);
}

DWORD APIENTRY DdGetBltStatus( PD3D8_GETBLTSTATUSDATA pGetBltStatus )
{
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) pGetBltStatus->hDD;
    PDDSURFACE              pSurf = (PDDSURFACE) pGetBltStatus->hSurface;
    DDHAL_GETBLTSTATUSDATA  gbsd;
    LPDDHALSURFCB_GETBLTSTATUS  gbsfn;

    // Software drivers will only do memcpy, so we don't need to call
    // the driver

    pGetBltStatus->ddRVal = DD_OK;
    if (IS_SOFTWARE_DRIVER(pDevice))
    {
        return DDHAL_DRIVER_HANDLED;
    }

    ENTER_BOTH();
    pGetBltStatus->ddRVal = DD_OK;
    if (CheckForDeviceLost(pDevice))
    {
        LEAVE_BOTH();
        return DDHAL_DRIVER_HANDLED;
    }

    /*
    gbsfn = pDevice->pDD->lpLcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus;
    gbsd.GetBltStatus = pDevice->pDD->lpLcl->lpDDCB->HALDDMiscellaneous.GetSysmemBltStatus;

    if( gbsd.GetBltStatus != NULL )
    {
        DWORD                           rc;

        gbsd.lpDD = pDevice->pDD->lpLcl->lpGbl;
        gbsd.dwFlags = pGetBltStatus->dwFlags;
        gbsd.lpDDSurface = pSurf->Surface.pHeavy->lpLcl;
        DOHALCALL( GetBltStatus, gbsfn, gbsd, rc, FALSE );
        if( rc == DDHAL_DRIVER_HANDLED )
        {
            pGetBltStatus->ddRVal = gbsd.ddRVal;
        }
    }
    */

    LEAVE_BOTH();
    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdGetFlipStatus( PD3D8_GETFLIPSTATUSDATA pGetFlipStatus )
{
    DPF_ERR("DdGetFlipStatus");
    return DD_OK;
}

DWORD APIENTRY DdSetMode( PD3D8_SETMODEDATA pSetMode )
{
    UINT    BPP;
    PDDDEVICEHANDLE pDeviceHandle = (PDDDEVICEHANDLE) pSetMode->hDD;

    pSetMode->ddRVal = D3DERR_DRIVERINTERNALERROR;

    switch (pSetMode->Format)
    {
    case D3DFMT_P8:
        BPP = 8;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
        BPP = 16;
        break;

    case D3DFMT_R8G8B8:
        BPP = 24;
        break;

    case D3DFMT_A8R8G8B8:
    case D3DFMT_X8R8G8B8:
        BPP = 32;
        break;

    default:
        return DDHAL_DRIVER_HANDLED;
    }

    pSetMode->ddRVal = D3D8SetMode((HANDLE)pDeviceHandle,
                                   pDeviceHandle->szDeviceName,
                                   pSetMode->dwWidth,
                                   pSetMode->dwHeight,
                                   BPP,
                                   pSetMode->dwRefreshRate,
                                   FALSE);

    return DDHAL_DRIVER_HANDLED;
}

DWORD APIENTRY DdDestroyDDLocal( PD3D8_DESTROYDDLOCALDATA pDestroyDDLocal )
{
    DPF_ERR("DdDestroyDDLocal");
    return DD_OK;
}

DWORD APIENTRY DdWaitForVerticalBlank( PD3D8_WAITFORVERTICALBLANKDATA pWaitForVerticalBlank )
{
    PDDDEVICEHANDLE pDevice = (PDDDEVICEHANDLE) pWaitForVerticalBlank->hDD;
    LPDDHAL_WAITFORVERTICALBLANK    wfvbhalfn;
    LPDDHAL_WAITFORVERTICALBLANK    wfvbfn;
    DWORD                           dwRet = DDHAL_DRIVER_HANDLED;

    ENTER_BOTH();
    if (CheckForDeviceLost(pDevice))
    {
        static int LostTestVerticalBlank;

        pWaitForVerticalBlank->ddRVal = DD_OK;
        if (pWaitForVerticalBlank->dwFlags == DDWAITVB_I_TESTVB)
        {
            if (LostTestVerticalBlank > 0)
            {
                pWaitForVerticalBlank->bIsInVB = TRUE;
            }
            else
            {
                pWaitForVerticalBlank->bIsInVB = FALSE;
            }
            LostTestVerticalBlank = LostTestVerticalBlank == 0 ? 1 : 0;
        }
        else if (pWaitForVerticalBlank->dwFlags == DDWAITVB_BLOCKEND)
        {
            pWaitForVerticalBlank->bIsInVB = FALSE;
        }
        else
        {
            pWaitForVerticalBlank->bIsInVB = TRUE;
        }
    }
    else
    {
        wfvbfn = pDevice->pDD->lpLcl->lpDDCB->HALDD.WaitForVerticalBlank;
        wfvbhalfn = pDevice->pDD->lpLcl->lpDDCB->cbDDCallbacks.WaitForVerticalBlank;
        dwRet = DDHAL_DRIVER_NOTHANDLED;
        if( wfvbhalfn != NULL )
        {
            DDHAL_WAITFORVERTICALBLANKDATA  wfvbd;

            wfvbd.WaitForVerticalBlank = wfvbhalfn;
            wfvbd.lpDD = pDevice->pDD->lpLcl->lpGbl;
            wfvbd.dwFlags = pWaitForVerticalBlank->dwFlags;
            wfvbd.hEvent = (ULONG_PTR) NULL;
            DOHALCALL( WaitForVerticalBlank, wfvbfn, wfvbd, dwRet, FALSE );
            if (dwRet == DDHAL_DRIVER_HANDLED)
            {
                pWaitForVerticalBlank->ddRVal = MapLegacyResult(wfvbd.ddRVal);
                if (wfvbd.ddRVal == DDERR_VERTICALBLANKINPROGRESS)
                {
                    pWaitForVerticalBlank->ddRVal = DD_OK;
                    pWaitForVerticalBlank->bIsInVB = TRUE;                   
                }
                else
                {
                    pWaitForVerticalBlank->bIsInVB = FALSE;                   
                }
            }
        }
    }
    LEAVE_BOTH();
    return dwRet;
}

void BuildSurfaceDesc( PD3D8_CREATESURFACEDATA pCreateSurface, DDSURFACEDESC2* pddsd2 )
{
    PDDDEVICEHANDLE             pDevice = (PDDDEVICEHANDLE) pCreateSurface->hDD;
    LPDDRAWI_DIRECTDRAW_INT     pdrv_int = pDevice->pDD;
    HRESULT                     hr;
    DWORD                       i;
    PDDSURFACE                  pSurf;
    LPDIRECTDRAWSURFACE         lpDDSurface;

    memset(pddsd2, 0, sizeof(DDSURFACEDESC2));
    pddsd2->dwSize = sizeof( DDSURFACEDESC2 );

    //dwCaps3==1 means 1 sample per pixel.
    pddsd2->ddsCaps.dwCaps3 = DDSCAPS3_MULTISAMPLE_MASK & (DWORD) pCreateSurface->MultiSampleType;

    // Convert all of the caps
    switch (pCreateSurface->Type)
    {
    case D3DRTYPE_SURFACE:

        if (pCreateSurface->dwUsage & D3DUSAGE_ALPHACHANNEL)
        {
            DPF(0,"Setting alphachannel");
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_ENABLEALPHACHANNEL;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_PRIMARYSURFACE)
        {
            // If we aren't creating a primary flip chain, then we
            // don't have to do much here.

            if (pCreateSurface->dwSCnt == 1)
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE |
                                          DDSCAPS_COMPLEX |
                                          DDSCAPS_FLIP |
                                          DDSCAPS_3DDEVICE;
            }
        }
        else if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
        {
            DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
        }
        else
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
        }

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->dwBackBufferCount = pCreateSurface->dwSCnt - 1;
            pddsd2->dwFlags |= DDSD_BACKBUFFERCOUNT;
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_COMPLEX;
        }

        break;
    case D3DRTYPE_TEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP | DDSCAPS_COMPLEX;
            pddsd2->dwFlags |= DDSD_MIPMAPCOUNT;
            pddsd2->dwMipMapCount = pCreateSurface->dwSCnt;
        }
        else
        {
            // To DDraw, a mipmap w/ one level is really only a texture
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    case D3DRTYPE_CUBETEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_COMPLEX;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_CUBEMAP;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_CUBEMAP_ALLFACES;

        DDASSERT(pCreateSurface->dwSCnt >= 6);
        DDASSERT((pCreateSurface->dwSCnt % 6) == 0);

        if (pCreateSurface->dwSCnt > 6)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_MIPMAP;
            pddsd2->dwFlags        |= DDSD_MIPMAPCOUNT;
            pddsd2->dwMipMapCount   = pCreateSurface->dwSCnt / 6;
        }

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    case D3DRTYPE_IMAGESURFACE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        // Image surfaces are marked as textures since they have the
        // greatest flexibility for formats. But they don't get
        // a CreateSurfaceEx handle since they are never passed to
        // a driver.
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
        break;


    case D3DRTYPE_COMMANDBUFFER:
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_COMMANDBUFFER;
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );
        DDASSERT((pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER) == 0);
        break;
    case D3DRTYPE_VERTEXBUFFER:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        if (!(pCreateSurface->dwUsage & D3DUSAGE_INTERNALBUFFER))
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_VERTEXBUFFER;
        }
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTSTATIC;
            }
        }
        break;
    case D3DRTYPE_INDEXBUFFER:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_INDEXBUFFER;
        if (pDevice->DriverLevel >= 8)
        {
            if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
            }
            else
            {
                pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTSTATIC;
            }
        }
        break;
    case D3DRTYPE_VOLUME:
        // We don't create stand-alone volumes
        DDASSERT(FALSE);
        break;
    case D3DRTYPE_VOLUMETEXTURE:
        DDASSERT(0 == (pCreateSurface->dwUsage & D3DUSAGE_DISCARD) );

        pddsd2->ddsCaps.dwCaps |= DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
        pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_VOLUME;
        pddsd2->ddsCaps.dwCaps4 =
            MAKELONG((WORD)(pCreateSurface->pSList[0].cpDepth),0);

        if (pCreateSurface->dwSCnt > 1)
        {
            pddsd2->ddsCaps.dwCaps |= DDSCAPS_COMPLEX;
            pddsd2->dwFlags        |= DDSD_MIPMAPCOUNT;
        }
        pddsd2->dwMipMapCount = pCreateSurface->dwSCnt;

        if (pCreateSurface->dwUsage & D3DUSAGE_DYNAMIC)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSCAPS2_HINTDYNAMIC;
        }
        break;
    }

    if (pCreateSurface->dwUsage & D3DUSAGE_RENDERTARGET)
    {
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
    }
    if (pCreateSurface->dwUsage & D3DUSAGE_DEPTHSTENCIL)
    {
        pddsd2->ddsCaps.dwCaps |= DDSCAPS_ZBUFFER;
    }
    if (pDevice->DriverLevel >= 8)
    {
        if (pCreateSurface->dwUsage & D3DUSAGE_LOADONCE)
        {
            pddsd2->ddsCaps.dwCaps2 |= DDSC